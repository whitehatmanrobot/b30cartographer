====================================
VariantGetBSTR

    Gets BSTR from the variant (does one possible indirection)

Parameters:
    var          - VARIANT

Returns:
    BSTR or NULL if none
===================================================================*/   
BSTR VariantGetBSTR(const VARIANT *pvar)
    {
    if (V_VT(pvar) == VT_BSTR)                      // straight BSTR
        return V_BSTR(pvar);

    if (V_VT(pvar) == (VT_BYREF|VT_VARIANT))
        {
        VARIANT *pvarRef = V_VARIANTREF(pvar);      // Variant by ref
        if (pvarRef && V_VT(pvarRef) == VT_BSTR)
            return V_BSTR(pvarRef);
        }

    return NULL;
    }

/*===================================================================
Normalize

    Converts a filename IN PLACE to a normalized form so that we don't
    cache identical files with different names (i.e. Foo, foo,
    .\foo, etc)

Algorithm:
    The file is translated to uppercase and forward slash (/)
    characters are converted to backward slash (\)

Return Value:
    cch of normalized string
Note:  This function is used for PathInfo only, and using system ANSI codepage.
===================================================================*/
int Normalize
(
TCHAR *   szSrc  // source string
)
    {
    BOOL    fReturn;

    Assert(szSrc != NULL);
    
    TCHAR *szTemp = szSrc;

    int cchRet = _tcslen(szSrc);

    _tcsupr(szTemp);

    szTemp = szSrc;
    while (*szTemp)
    {
        if (*szTemp == _T('/'))
            *szTemp = _T('\\');
        szTemp = CharNext(szTemp);
    }

    return cchRet;
}


#ifdef DBG
BOOLB IsNormalized(const TCHAR *sz)
    {
    while (*sz) {
#if !UNICODE
        if (_istlower(*sz))
            return FALSE;
#endif
        if (*sz == _T('/'))
            return FALSE;
        sz = CharNext(sz);
    }
    return TRUE;
}
#endif  // DBG

/*===================================================================
HTMLEncodeLen

HTML Encode len returns an int representing the string size
required to HTMLEncode a string.

Note: This returned value might be exceeds the actually string size needed to
HTMLEncode a string.(since we are going to drop the leading zeros in &#00257; 
case.,
the returned value includes the 2 chars for the leading zeros)

Parameters:
    szSrc  - Pointer to the source buffer
    fEncodeExtCharOnly - FALSE, Normal encoding
                 TRUE, encodes extended chars, does not encode '<', '>', '&',
and '"'.
    uCodePage - system code page

Returns:
    int storage required to encode string.
===================================================================*/
int HTMLEncodeLen(const char *szSrc, UINT uCodePage, BSTR bstrIn, BOOL fEncodeExtCharOnly)
    {
    int nstrlen = 1;        // Add NUL space now
    int i       = 0;

    // Bug 97049 return 0 on NULL instead of crashing
    if (!szSrc)
        return 0;

    while (*szSrc)
        {
        // The original condition is unsuitable for DBCS.
        // It is possible that new one allows to encode extended character
        // even if running system is DBCS.
        //

        // if bstrIn == NULL, chech DBCS
        // if bstrIn != NULL and Unicode is latin-1 area(<0x100), check DBCS
        // else skip to check DBCS
        if (!(bstrIn && bstrIn[i] < 0x100) && ::IsDBCSLeadByteEx(uCodePage, (BYTE)*szSrc))	
            {
            // this is a DBCS code page do not encode the data copy 2 bytes
            // no incremnt because of using CharNextExA at the end of the loop
            nstrlen += 2;
            }
            
        // Japanese only.
        // Do not encode if character is half-width katakana character.
        // We should use GetStringTypeA to detect half-width katakana char instead of _ismbbkana()???
        // (I used _ismbbkana at this time for performance reason...)
        //
        else if ((uCodePage == 932 || uCodePage == CP_ACP && ::GetACP() == 932 ) && _ismbbkana(*szSrc))
            {
            nstrlen++;
            }

        // Special case character encoding
        //
        else if (*szSrc == '<')
            if (fEncodeExtCharOnly)
                nstrlen++;
            else
                nstrlen += 4;

        else if (*szSrc == '>')
            if (fEncodeExtCharOnly)
                nstrlen++;
            else
                nstrlen += 4;

        else if (*szSrc == '&')
            if (fEncodeExtCharOnly)
                nstrlen++;
            else
                nstrlen += 5;

        else if (*szSrc == '"')
            if (fEncodeExtCharOnly)
                nstrlen++;
            else
                nstrlen += 6;

        // According RFC, if character code is greater than equal 0xa0, encode it.
        //
        // Note: For &#00257;, we might drop the leading zeros, therefore, we are not
        // going to use all 8 chars.  We will need only 6 digits in this case.(&#257;).
        // We need at most 8 chars.
        else if ( bstrIn && (bstrIn[i] >= 0xa0) )
       		{
   		    nstrlen += 8;
       		}
		else if ((unsigned char)*szSrc >= 0xa0 )
			{
			nstrlen += 6;
            }
        else
            {
            nstrlen++;
            }

            
       	// increment szSrc and i (they must be kept in sync)
		szSrc = AspCharNextA(WORD(uCodePage), szSrc);
		i++;
        }
        
    return nstrlen;
    }

/*===================================================================
HTMLEncode

HTML Encode a string containing the following characters

less than           <       &lt;
greater than        >       &gt;
ampersand           &       &amp;
quote               "       &quot;
any Ascii           ?       &#xxx   (where xxx is the ascii char val)

Parameters:
    szDest - Pointer to the buffer to store the HTMLEncoded string
    szSrc  - Pointer to the source buffer
    fEncodeExtCharOnly - FALSE, Normal encoding
                 TRUE, encodes extended chars, does not encode '<', '>', '&',
and '"'.
    uCodePage - system code page

Returns:
    A pointer to the NUL terminated string.
===================================================================*/
char *HTMLEncode(char *szDest, const char *szSrc, UINT uCodePage, BSTR bstrIn, BOOL fEncodeExtCharOnly)
    {
    char *pszDest = szDest;
	int   i       = 0;

    // Bug 97049 return on NULL instead of crashing
    if (!szDest)
        return NULL;
    if (!szSrc)
        {
        *szDest = '\0';
        return pszDest;
        }

    while (*szSrc)
        {
        //
        // The original condition is unsuitable for DBCS.
        // It is possible that new one allows to encode extended character
        // even if running system is DBCS.
        //
		// if Unicode is latin-1 area(<0x100), skip to check DBCS
		// bstrIn == NULL to handle the case were HTMLEncode is called internally 
		// and bstrIn is NULL
		//
        // if bstrIn == NULL, chech DBCS
        // if bstrIn != NULL and Unicode is latin-1 area(<0x100), check DBCS
        // else skip to check DBCS
        if (!(bstrIn && bstrIn[i] < 0x100) && ::IsDBCSLeadByteEx(uCodePage, (BYTE)*szSrc))	
            {
            // this is a DBCS code page do not encode the data copy 2 bytes
            // no incremnt because of using CharNextExA at the end of the loop
            *szDest++ = *szSrc;  
            *szDest++ = *(szSrc + 1);
            }
        //
        // Japanese only.
        // Do not encode if character is half-width katakana character.
        //
        else if ( (uCodePage == 932 || uCodePage == CP_ACP && ::GetACP() == 932) && _ismbbkana(*szSrc))
            {
            *szDest++ = *szSrc;
            }

        // Special case character encoding
        else if (*szSrc == '<')
            if (fEncodeExtCharOnly)
                *szDest++ = *szSrc;
            else
                szDest = strcpyExA(szDest, "&lt;");

        else if (*szSrc == '>')
            if (fEncodeExtCharOnly)
                *szDest++ = *szSrc;
            else
                szDest = strcpyExA(szDest, "&gt;");

        else if (*szSrc == '&')
            if (fEncodeExtCharOnly)
                *szDest++ = *szSrc;
            else
                szDest = strcpyExA(szDest, "&amp;");

        else if (*szSrc == '"')
            if (fEncodeExtCharOnly)
                *szDest++ = *szSrc;
            else
                szDest = strcpyExA(szDest, "&quot;");

        // According RFC, if character code is greater than equal 0xa0, encode it.
        //
	    // BUG 153089 - WideCharToMultiByte would incorrectly convert some
	    // characters above the range of 0xA0 so we now use the BSTR as our source
	    // to check for characters that should be encoded.
	    //
	    else if ( bstrIn && (bstrIn[i] >= 0xa0))
	    {
	        BOOL fSurrogate = FALSE;
	      	WORD count = 1;
	      	// Check if the bstrIn currently points to a surrogate Pair 
	      	// Surrogate pairs would account for 2 bytes in the BSTR.
            // High Surrogate = U+D800 <==> U+DBFF
            // Low Surrogate = U+DC00 <==> U+DFFF
	      	if ((bstrIn[i] >= 0xd800 && bstrIn[i] <= 0xdfff) 		// Check the higher byte.
	      	    && (bstrIn[i+1] >= 0xd800 && bstrIn[i+1] <= 0xdfff)) // Check the lower byte too.
	      	{	     	
	      	    // Surrogate Pair exists so iterate through the code twice.
	      	    fSurrogate = TRUE;
	      	    count++;	      		      	    
	      	}

	      	for (WORD iter = 0; iter < count ; iter ++)
	      	{
                WORD    wTemp = *(bstrIn+i+iter);
    	      	INT     iTemp;
    	      	BOOL    fLeadZero = TRUE;
    	      	
    	        *szDest++ = '&';
    	        *szDest++ = '#';
    	        for (WORD Index = 10000; Index > 0; Index /= 10) 
   	        	{
    	        	iTemp = ((unsigned char) (wTemp / Index));
    	        	if (fLeadZero == TRUE)
   	        	    {
    	        	    if (iTemp == 0 && Index > 100)
   	        	        {
    	        	        continue;
   	        	        }
    	        	    else
   	        	        {
    	        	        fLeadZero = FALSE;
   	        	        }
   	        	    }
    	       		*szDest++ =  iTemp + '0';
    	       		wTemp = wTemp % Index;
   		       	}
      	     	*szDest++ = ';';     	     		     	      	     	
    	    }
	      	
	      	if (fSurrogate) 
	      	    i++; // Increment bstrIn index as surrogatepair was detected.

	    }
	    else if ((unsigned char)*szSrc >= 0xa0)
	      	{
	      	// Since this is unsigned char casting, the value of WORD wTemp
	      	// is not going to exceed 0xff(255).  So, 3 digit is sufficient here.
	      	WORD wTemp = (unsigned char)*szSrc;

	        *szDest++ = '&';
	        *szDest++ = '#';
	        for (WORD Index = 100; Index > 0; Index /= 10) 
	        	{
	       		*szDest++ = ((unsigned char) (wTemp / Index)) + '0';
	       		wTemp = wTemp % Index;
		       	}
  	     	*szDest++ = ';';
    	    }
       else
            *szDest++ = *szSrc;

    	// increment szSrc and i (they must be kept in sync)
		szSrc = AspCharNextA(WORD(uCodePage), szSrc);  
    	
		i++;	// Regular increment of the bstrIn index.
        }

    *szDest = '\0';
    return pszDest;
    }

/*===================================================================
strcpyExA

Copy one string to another, returning a pointer to the NUL character
in the destination

Parameters:
    szDest - pointer to the destination string
    szSrc - pointer to the source string

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/
char *strcpyExA(char *szDest, const char *szSrc)
    {
    while (*szDest++ = *szSrc++)
        ;

    return szDest - 1;
    }



/*===================================================================
strcpyExW

Copy one wide string to another, returning a pointer to the NUL character
in the destination

Parameters:
    wszDest - pointer to the destination string
    wszSrc - pointer to the source string

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

wchar_t *strcpyExW(wchar_t *wszDest, const wchar_t *wszSrc)
    {
    while (*wszDest++ = *wszSrc++)
        ;

    return wszDest - 1;
    }



/*===================================================================
URLEncodeLen

Return the storage requirements for a URL-Encoded string

Parameters:
    szSrc  - Pointer to the string to URL Encode

Returns:
    the number of bytes required to encode the string
===================================================================*/

int URLEncodeLen(const char *szSrc)
    {
    int cbURL = 1;      // add terminator now

    // Bug 97049 return 0 on NULL instead of crashing
    if (!szSrc)
        return 0;

    while (*szSrc)
        {
        if (*szSrc & 0x80)              // encode foreign characters
            cbURL += 3;

        else if (*szSrc == ' ')         // encoded space requires only one character
            ++cbURL;

        else if (!isalnum((UCHAR)(*szSrc)))  // encode non-alphabetic characters
            cbURL += 3;

        else
            ++cbURL;

        ++szSrc;
        }

    return cbURL;
    }



/*===================================================================
URLEncode

URL Encode a string by changing space characters to '+' and escaping
non-alphanumeric characters in hex.

Parameters:
    szDest - Pointer to the buffer to store the URLEncoded string
    szSrc  - Pointer to the source buffer

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

char *URLEncode(char *szDest, const char *szSrc)
    {
    char hex[] = "0123456789ABCDEF";

    // Bug 97049 return on NULL instead of crashing
    if (!szDest)
        return NULL;
    if (!szSrc)
        {
        *szDest = '\0';
        return szDest;
        }

    while (*szSrc)
        {
        if (*szSrc == ' ')
            {
            *szDest++ = '+';
            ++szSrc;
            }
        else if ( (*szSrc & 0x80) || !isalnum((UCHAR)(*szSrc)) )
            {
            *szDest++ = '%';
            *szDest++ = hex[BYTE(*szSrc) >> 4];
            *szDest++ = hex[*szSrc++ & 0x0F];
            }

        else
            *szDest++ = *szSrc++;
        }

    *szDest = '\0';
    return szDest;
    }



/*===================================================================
DBCSEncodeLen

Return the storage requirements for a DBCS encoded string
(url-encoding of characters with the upper bit set ONLY)

Parameters:
    szSrc  - Pointer to the string to URL Encode

Returns:
    the number of bytes required to encode the string
===================================================================*/

int DBCSEncodeLen(const char *szSrc)
    {
    int cbURL = 1;      // add terminator now

    // Bug 97049 return 0 on NULL instead of crashing
    if (!szSrc)
        return 0;

    while (*szSrc)
        {
        cbURL += ((*szSrc & 0x80) || (!isalnum((UCHAR)(*szSrc)) && !strchr("/$-_.+!*'(),", *szSrc)))? 3 : 1;
        ++szSrc;
        }

    return cbURL;
    }



/*===================================================================
DBCSEncode

DBCS Encode a string by escaping characters with the upper bit
set - Basically used to convert 8 bit data to 7 bit in contexts
where full encoding is not needed.

Parameters:
    szDest - Pointer to the buffer to store the URLEncoded string
    szSrc  - Pointer to the source buffer

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

char *DBCSEncode(char *szDest, const char *szSrc)
    {
    char hex[] = "0123456789ABCDEF";

    // Bug 97049 return on NULL instead of crashing
    if (!szDest)
        return NULL;
    if (!szSrc)
        {
        *szDest = '\0';
        return szDest;
        }

    while (*szSrc)
        {
        if ((*szSrc & 0x80) || (!isalnum((UCHAR)(*szSrc)) && !strchr("/$-_.+!*'(),", *szSrc)))
            {
            *szDest++ = '%';
            *szDest++ = hex[BYTE(*szSrc) >> 4];
            *szDest++ = hex[*szSrc++ & 0x0F];
            }

        else
            *szDest++ = *szSrc++;
        }

    *szDest = '\0';
    return szDest;
    }


/*===================================================================
URLPathEncodeLen

Return the storage requirements for a URLPath-Encoded string

Parameters:
    szSrc  - Pointer to the string to URL Path Encode

Returns:
    the number of bytes required to encode the string
===================================================================*/

int URLPathEncodeLen(const char *szSrc)
    {
    int cbURL = 1;      // count terminator now

    // Bug 97049 return 0 on NULL instead of crashing
    if (!szSrc)
        return 0;

    while ((*szSrc) && (*szSrc != '?'))
        {
        switch (*szSrc)
            {
            // Ignore safe characters
            case '$' :  case '_' :  case '-' :
            case '+' :  case '.' :  case '&' :
            // Ignore URL syntax elements
            case '/' :  case ':' :  case '@' :
            case '#' :  case '*' :  case '!' :
                ++cbURL;
                break;

            default:
                if (!isalnum((UCHAR)(*szSrc)) || // encode non-alphabetic characters
                    (*szSrc & 0x80))    // encode foreign characters
                    cbURL += 3;
                else
                    ++cbURL;
            }
        ++szSrc;
        }

    if (*szSrc == '?')
        {
        while (*szSrc)
            {
            ++cbURL;
            ++szSrc;
            }
        }

    return cbURL;
    }



/*===================================================================
URLPathEncode

Encodes the path portion of a URL.  All characters up to the first
'?' are encoded with the following rules:
    o Charcters that are needed to parse the URL are left alone:
        '/' '.' ':' '@' '#' '*' '!'
    o Non-foreign alphanumberic characters are left alone
    o Anything else is escape encoded
Everything after the '?' is ignored.

Parameters:
    szDest - Pointer to the buffer to store the URLPathEncoded string
    szSrc  - Pointer to the source buffer

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

char *URLPathEncode(char *szDest, const char *szSrc)
    {
    char hex[] = "0123456789ABCDEF";

    // Bug 97049 return on NULL instead of crashing
    if (!szDest)
        return NULL;
    if (!szSrc)
        {
        *szDest = '\0';
        return szDest;
        }

    while ((*szSrc) && (*szSrc != '?'))
        {
        switch (*szSrc)
            {
            // Ignore safe characters
            case '$' :  case '_' :  case '-' :
            case '+' :  case '.' :  case '~' :
            case '&' :
            // Ignore URL syntax elements
            case '/' :  case ':' :  case '@' :
            case '#' :  case '*' :  case '!' :
                *szDest++ = *szSrc++;
                break;

            default:
                if (!isalnum((UCHAR)(*szSrc)) || (*szSrc & 0x80))
                    {
                    *szDest++ = '%';
                    *szDest++ = hex[BYTE(*szSrc) >> 4];
                    *szDest++ = hex[*szSrc++ & 0x0F];
                    }
                else
                    *szDest++ = *szSrc++;
            }
        }

    if (*szSrc == '?')
        {
        while (*szSrc)
            {
            *szDest++ = *szSrc++;
            }
        }

    *szDest = '\0';

    return szDest;
    }



// ***************************************************************************
// T I M E    C O N V E R S I O N    S U P P O R T
// ***************************************************************************

/*===================================================================
CTimeToVariantDate

Converts a time_t structure to a Variant Date structure

Parameters:
    ptNow     - date & time to convert
    pdtResult - DATE output of this function

Returns:
    E_FAIL if things go wrong.
===================================================================*/

HRESULT CTimeToVariantDate(const time_t *ptNow, DATE *pdtResult)
    {
    struct tm *ptmNow = localtime(ptNow);
    if (ptmNow == NULL)
        return E_FAIL;

    return
        DosDateTimeToVariantTime(
                ptmNow->tm_mday | ((ptmNow->tm_mon + 1) << 5) | ((ptmNow->tm_year - 80) << 9),
                (unsigned(ptmNow->tm_sec) >> 1) | (ptmNow->tm_min << 5) | (ptmNow->tm_hour << 11),
                pdtResult);
    }



/*===================================================================
VariantDateToCTime

Converts a variant date to a time_t structure used by the "C"
language

Parameters:
    dt       - date to convert to "time_t"
    ptResult - pointer to result which has the value

Returns:
    E_FAIL if things go wrong.
===================================================================*/

HRESULT VariantDateToCTime(DATE dt, time_t *ptResult)
    {
    // Convert the variant time to a documented time format
    //
    unsigned short wDOSDate, wDOSTime;
    if (! VariantTimeToDosDateTime(dt, &wDOSDate, &wDOSTime))
        return E_FAIL;

    // populate a "tm" struct
    //
    struct tm tmConverted;

    tmConverted.tm_sec   = (wDOSTime & 0x1F) << 1;
    tmConverted.tm_min   = (wDOSTime >> 5) & 0x3F;
    tmConverted.tm_hour  = wDOSTime >> 11;
    tmConverted.tm_mday  = wDOSDate & 0x1F;
    tmConverted.tm_mon   = ((wDOSDate >> 5) & 0x0F) - 1;
    tmConverted.tm_year  = (wDOSDate >> 9) + 80;    // adjust for offset from 1980
    tmConverted.tm_isdst = -1;

    // convert the "tm" struct to the number of seconds since Jan 1, 1980
    //
    *ptResult = mktime(&tmConverted);
    return (*ptResult == -1)? E_FAIL : S_OK;
    }



/*===================================================================
CTimeToStringGMT

Converts a C language time_t to a string of the form:

    "Wed, 09-Nov-1999 23:12:40 GMT"

Parameters:
    ptNow    - the time to convert
    szBuffer - pointer to the destination buffer

Returns:
    E_FAIL if something goes wrong

Notes:
    The longest day of the week (in terms of spelling) is "Wednesday";
    the other fields are fixed length. This means that we can
    guarantee the maximum length of szBuffer - there is no need
    for client code to dynamically allocate a buffer.
===================================================================*/
HRESULT CTimeToStringGMT(const time_t *ptNow, char szBuffer[DATE_STRING_SIZE], BOOL fFunkyCookieFormat)
    {
    // The internet standard explicitly says that
    // month and weekday names are in english.
    const char rgstrDOW[7][4] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    const char rgstrMonth[12][4] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    // convert time to GMT
    struct tm *ptmGMT = gmtime(ptNow);
    if (ptmGMT == NULL)
        {
        return E_FAIL;
        }

    // send output in internet format
    const char *szDateFormat = fFunkyCookieFormat?
                  "%s, %02d-%s-%d %02d:%02d:%02d GMT"
                : "%s, %02d %s %d %02d:%02d:%02d GMT";

    sprintf(szBuffer, szDateFormat, rgstrDOW[ptmGMT->tm_wday], ptmGMT->tm_mday,
                rgstrMonth[ptmGMT->tm_mon], ptmGMT->tm_year+1900,
                ptmGMT->tm_hour, ptmGMT->tm_min, ptmGMT->tm_sec);

    return S_OK;
    }

/*
// there is a bug in the C-runtime function strftime that will cause
// an AV on the ALPHA on multi-threaded stress the function has been
// re-written to work around this problem
//
HRESULT CTimeToStringGMT(const time_t *ptNow, char szBuffer[DATE_STRING_SIZE], BOOL fFunkyCookieFormat)
    {
    // convert time to GMT
    //
    struct tm *ptmGMT = gmtime(ptNow);
    if (ptmGMT == NULL)
        return E_FAIL;

    // Set locale to "C" locale.  The internet standard explicitly says that
    // month and weekday names are in english.
    //
    char *lcTimeCurrent = setlocale(LC_TIME, "C");
    if (lcTimeCurrent == NULL)
        return E_FAIL;

    // send output in internet format
    //
    const char *szDateFormat = fFunkyCookieFormat?
                                      "%a, %d-%b-%Y %H:%M:%S GMT"
                                    : "%a, %d %b %Y %H:%M:%S GMT";

    strftime(szBuffer, DATE_STRING_SIZE, szDateFormat, ptmGMT);

    // Restore locale
    //
    if (! setlocale(LC_TIME, lcTimeCurrent))
        return E_FAIL;

    // done
    return S_OK;
    }
*/


// ***************************************************************************
// W I D E    C H A R A C T E R    S U P P O R T
// ***************************************************************************

/*============================================================================
WstrToMBstrEx

Copies a wide character string into an ansi string.

Parameters:
    LPSTR dest      - The string to copy  into
    LPWSTR src      - the input BSTR
    cchBuffer      - the number of CHARs allocated for the destination string.
    lCodePage       - the codepage used in conversion, default to CP_ACP

============================================================================*/
UINT WstrToMBstrEx(LPSTR dest, INT cchDest, LPCWSTR src, int cchSrc, UINT lCodePage)
    {
    UINT cch;

    DBG_ASSERT(cchDest > 0);

    // if the src length was specified, then reserve room for the NULL terminator.
    // This is necessary because WideCharToMultiByte doesn't add or account for
    // the NULL terminator if a source is specified.

    if (cchSrc != -1)
        cchDest--;

    cch = WideCharToMultiByte(lCodePage, 0, src, cchSrc, dest, cchDest, NULL, NULL);
    if (cch == 0)
        {
        dest[0] = '\0';
        if(ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
            cch = WideCharToMultiByte(lCodePage, 0, src, cchSrc, dest, 0, NULL, NULL);

            // if a src length was specified, then WideCharToMultiByte does not include
            // it in it's resulting length.  Bump the count so that the caller does
            // account for the NULL.

            if (cchSrc != -1)
                cch++;         
            }
        else
            {
            DBG_ASSERT(FALSE);
            DBGERROR((DBG_CONTEXT, "Last error is %d\n", GetLastError()));
            cch = 1;
            }
        }
    else if (cchSrc != -1)
        {

        // if a src length was specified, then WideCharToMultiByte does not include
        // it in it's resulting length nor does it add the NULL terminator.  So add 
        // it and bump the count.

        dest[cch++] = '\0';
        }

    DBG_ASSERT(cch != 0);
    return cch;
    }

/*============================================================================
MBstrToWstrEx

Copies a ansi string into an wide character string.

Parameters:
    LPWSTR dest    - The string to copy  into
    LPSTR src      - the input ANSI string
    cchDest        - the number of Wide CHARs allocated for the destination string.
    cchSrc         - the length of the source ANSI string
    lCodePage      - the codepage used in conversion, default to CP_ACP

============================================================================*/
UINT MBstrToWstrEx(LPWSTR dest, INT cchDest, LPCSTR src, int cchSrc, UINT lCodePage)
    {
    UINT cch;

    DBG_ASSERT(cchDest > 0);

    // if the src length was specified, then reserve room for the NULL terminator.
    // This is necessary because WideCharToMultiByte doesn't add or account for
    // the NULL terminator if a source is specified.

    if (cchSrc != -1)
        cchDest--;

    cch = MultiByteToWideChar(lCodePage, 0, src, cchSrc, dest, cchDest);
    if (cch == 0)
        {
        dest[0] = '\0';
        if(ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
            cch = MultiByteToWideChar(lCodePage, 0, src, cchSrc, dest, 0);

            // if a src length was specified, then WideCharToMultiByte does not include
            // it in it's resulting length.  Bump the count so that the caller does
            // account for the NULL.

            if (cchSrc != -1)
                cch++;         
            }
        else
            {
            DBG_ASSERT(FALSE);
            DBGERROR((DBG_CONTEXT, "Last error is %d\n", GetLastError()));
            cch = 1;
            }
        }
    else if (cchSrc != -1)
        {

        // if a src length was specified, then WideCharToMultiByte does not include
        // it in it's resulting length nor does it add the NULL terminator.  So add 
        // it and bump the count.

        dest[cch++] = '\0';
        }

    DBG_ASSERT(cch != 0);
    return cch;
    }


/*============================================================================
SysAllocStringFromSz

Allocate a System BSTR and copy the given ANSI string into it.

Parameters:
    sz              - The string to copy (Note: this IS an "sz", we will stop at the first NULL)
    cch             - the number of ANSI characters in szT.  If 0, will calculate size.
    BSTR *pbstrRet  - the returned BSTR
    lCodePage       - the codepage for conversion

Returns:
    Allocated BSTR in return value
    S_OK on success, E_OUTOFMEMORY on OOM

Side effects:
    Allocates memory.  Caller must deallocate
============================================================================*/
HRESULT SysAllocStringFromSz
(
CHAR *sz,
DWORD cch,
BSTR *pbstrRet,
UINT lCodePage
)
    {
    BSTR bstrRet;

    Assert(pbstrRet != NULL);

    if (sz == NULL)
        {
        *pbstrRet = NULL;
        return(S_OK);
        }

    // initialize this because callers look at this to see if the routine was
    // successful

    *pbstrRet = NULL;

    // If they passed 0, then determine string length
    if (cch == 0)
        cch = strlen(sz);

    // Allocate a string of the desired length
    // SysAllocStringLen allocates enough room for unicode characters plus a null
    // Given a NULL string it will just allocate the space
    bstrRet = SysAllocStringLen(NULL, cch);
    if (bstrRet == NULL)
        return(E_OUTOFMEMORY);

    // If we were given "", we will have cch=0.  return the empty bstr
    // otherwise, really copy/convert the string
    // NOTE we pass -1 as 4th parameter of MulitByteToWideChar for DBCS support
    if (cch != 0)
        {
        UINT cchTemp = 0;
        if (MultiByteToWideChar(lCodePage, 0, sz, -1, bstrRet, cch+1) == 0)
            return(HRESULT_FROM_WIN32(GetLastError()));

        // If there are some DBCS characters in the sz(Input), then, the character count of BSTR(DWORD) is
        // already set to cch(strlen(sz)) in SysAllocStringLen(NULL, cch), we cannot change the count,
        // and later call of SysStringLen(bstr) always returns the number of characters specified in the
        // cch parameter at allocation time.  Bad, because one DBCS character(2 bytes) will convert
        // to one UNICODE character(2 bytes), not 2 UNICODE characters(4 bytes).
        // Example: For input sz contains only one DBCS character, we want to see SysStringLen(bstr)
        // = 1, not 2.
        bstrRet[cch] = 0;
        cchTemp = wcslen(bstrRet);
        if (cchTemp < cch)
            {
            BSTR bstrTemp = SysAllocString(bstrRet);
			if (bstrTemp == NULL)
				return(E_OUTOFMEMORY);
            SysFreeString(bstrRet);
            bstrRet = bstrTemp;
            cch = cchTemp;
            }
        }
    bstrRet[cch] = 0;
    *pbstrRet = bstrRet;

    return(S_OK);
    }

/*============================================================================
StringDupA

Duplicate a string.  An empty string will only be duplicated if the fDupEmpty
flag is set, else a NULL is returned.

Parameter
    CHAR *pszStrIn      string to duplicate

Returns:
    NULL if failed.
    Otherwise, the duplicated string.

Side Effects:
    ***ALLOCATES MEMORY -- CALLER MUST FREE***
============================================================================*/

CHAR *StringDupA
(
CHAR    *pszStrIn,
BOOL    fDupEmpty
)
    {
    CHAR *pszStrOut;
    INT  cch, cBytes;

    if (NULL == pszStrIn)
        return NULL;

    cch = strlen(pszStrIn);
    if ((0 == cch) && !fDupEmpty)
        return NULL;

    cBytes = sizeof(CHAR) * (cch+1);
    pszStrOut = (CHAR *)malloc(cBytes);
    if (NULL == pszStrOut)
        return NULL;

    memcpy(pszStrOut, pszStrIn, cBytes);
    return pszStrOut;
    }

/*============================================================================
StringDupW

Same as StrDup but for WCHAR strings

Parameter
    WCHAR *pwszStrIn      string to duplicate

Returns:
    NULL if failed.
    Otherwise, the duplicated string.

Side Effects:
    ***ALLOCATES MEMORY -- CALLER MUST FREE***
============================================================================*/

WCHAR *StringDupW
(
WCHAR *pwszStrIn,
BOOL  fDupEmpty
)
{
    WCHAR *pwszStrOut;
    INT  cch, cBytes;

    if (NULL == pwszStrIn)
        return NULL;

    cch = wcslen(pwszStrIn);
    if ((0 == cch) && !fDupEmpty)
        return NULL;

    cBytes = sizeof(WCHAR) * (cch+1);
    pwszStrOut = (WCHAR *)malloc(cBytes);
    if (NULL == pwszStrOut)
        return NULL;

    memcpy(pwszStrOut, pwszStrIn, cBytes);
    return pwszStrOut;
}


/*============================================================================
StringDupUTF8

Same as StrDup but for WCHAR strings that need to be Dup'd to UTF8

Parameter
    WCHAR *pwszStrIn      string to duplicate

Returns:
    NULL if failed.
    Otherwise, the duplicated UTF8 string.

Side Effects:
    ***ALLOCATES MEMORY -- CALLER MUST FREE***
============================================================================*/

CHAR *StringDupUTF8
(
WCHAR *pwszStrIn,
BOOL  fDupEmpty
)
{
    CWCharToMBCS convStr;

    if ((pwszStrIn == NULL) || (*pwszStrIn == L'\0')) {

        goto returnEmpty;
    }

    if (FAILED(convStr.Init(pwszStrIn))) {
        goto returnEmpty;
    }
    else {

        CHAR *pRetStr = convStr.GetString(TRUE);
        
        if (!pRetStr)
            goto returnEmpty;

        return pRetStr;
    }

returnEmpty:

    if (fDupEmpty)
        return StringDupA(NULL, TRUE);
    else
        return NULL;
}
/*===================================================================
CbWStr

Get byte length of WCHAR string (needed to manipulate hash keys)

Parameter
    LPWSTR pwszString   WCHAR string

Returns
    length in bytes
===================================================================*/
DWORD CbWStr
(
WCHAR *pwszString
)
    {
    return (pwszString ? (sizeof(WCHAR) * wcslen(pwszString)) : 0);
    }


/*===================================================================
DotPathToPath

This function offers support for parent path translation. for example
szFileSpec = "../foo/bar.asp"
szParentDirectory = "/scripts/more/stuff"

result = "/scripts/more/foo/bar.asp"

Parameter
    char *szDest                        - destination string
    const char *szFileSpec              - input path mask
    const char *szParentDirectory       - path to map from

Notes
    No more than "MAX_PATH" bytes are written into szDest.
    Returns FALSE when this happens.

Returns
    int TRUE/FALSE
===================================================================*/
BOOL
DotPathToPath
(
TCHAR *szDest,
const TCHAR *szFileSpec,
const TCHAR *szParentDirectory
)
{

    STACK_BUFFER( tempFileSpec, MAX_PATH );

    if (szFileSpec[0] == _T('\0')) {
        _tcscpy(szDest, szParentDirectory);
        return TRUE;
    }

    if (szFileSpec[0] == _T('/') || szFileSpec[0] == _T('\\'))
        return FALSE;

    // Make a copy of the FileSpec to allow for
    //    a. szDest == szFileSpec (inplace) should work
    //    b. Algorithm below works if szFileSpec ends with a '/' (or '\\')
    //

    if (!tempFileSpec.Resize((_tcslen(szFileSpec) + 2)*sizeof(TCHAR))) {
        return FALSE;
    }

    TCHAR *szFileSpecT = (TCHAR *)(tempFileSpec.QueryPtr());
    TCHAR *szT = strcpyEx(szFileSpecT, szFileSpec);
    szT = CharPrev(szFileSpecT, szT);
    if( *szT != _T('/') && *szT != _T('\\')) {
        szT = CharNext(szT);
        *szT++ = _T('/');
        *szT = _T('\0');
    }

    // Initialize "cchDest" - count of characters in destination
    int cchDest = _tcslen(szParentDirectory) + 1;
    if (cchDest > MAX_PATH)
        return FALSE;

    // OK if szParentDirectory is rewritten in place
    TCHAR *pchDestEnd;
    if (szDest == szParentDirectory)
        pchDestEnd = const_cast<TCHAR *>(&szParentDirectory[_tcslen(szParentDirectory)]);
    else
        pchDestEnd = strcpyEx(szDest, szParentDirectory);

    // Loop through each component in "szFileSpec", then do the following:
    //       for ".", do nothing
    //       for "..", delete rightmost dir from szDest
    //       otherwise, append the component.
    //

    const TCHAR *pchBegin = szFileSpecT;
    while (*pchBegin != _T('\0')) {
        // Calculate end of this segment
        const TCHAR *pchEnd = _tcspbrk(pchBegin,_T("\\/"));

        // check for parent path
        if ((_tcsncmp(pchBegin, _T(".."), 2) == 0) 
            && ((pchBegin[2] == _T('/')) || (pchBegin[2] == _T('\\')))) {
            // Delete rightmost path in dest
            while ((pchDestEnd > szDest) 
                    && (*pchDestEnd != _T('/'))
                    && (*pchDestEnd != _T('\\'))) {
                pchDestEnd = CharPrev(szDest, pchDestEnd);
            }

            if (pchDestEnd == szDest)   // we ".."'ed too many levels
                return FALSE;

            *pchDestEnd = _T('\0');
        }

        // Make sure this is not ".". If it is not, append the path
        else if (! (pchBegin[0] == _T('.') && (pchBegin[1] == _T('/') || pchBegin[1] == _T('\\')))) {
            cchDest += 1 + (int)(pchEnd - pchBegin);
            if (cchDest > MAX_PATH)
                return FALSE;

            *pchDestEnd++ = _T('/');
            _tcsncpy(pchDestEnd, pchBegin, pchEnd - pchBegin);
            pchDestEnd += (pchEnd - pchBegin);
            *pchDestEnd = _T('\0');
        }

        // Prepare for next iteration
        pchBegin = pchEnd + 1;
    }

    // It's possible that if the relative path is something like "..", and parent path is a single path
    // (either "/" or "C:/", then the root directory is indicator is missing - szDest is either the
    // empty string or something like "C:"
    //
#if UNICODE
    if (szDest[0] == '\0' 
        || ((szDest[1] == L':') && (szDest[2] == L'\0'))) {
        szDest[2] = L'/';
        szDest[3] = L'\0';
    }
#else
    if (szDest[0] == '\0' ||
        (!IsDBCSLeadByte(szDest[0]) && szDest[1] == ':' && szDest[2] == '\0') ||
        (IsDBCSLeadByte(szDest[0]) && szDest[2] == ':' && szDest[3] == '\0')) {
        strcat(szDest, "/");
    }
#endif
    return TRUE;
}

/*===================================================================
FIsGlobalAsa

Check if the given path points to GLOBAL.ASA

Parameter
    szPath      the path to check

Returns
    TRUE/FALSE
===================================================================*/
BOOL FIsGlobalAsa
(
const TCHAR *szPath,
DWORD cchPath
)
    {
    if (cchPath == 0)
        cchPath = _tcslen(szPath);
    return (cchPath >= CCH_GLOBAL_ASA &&
            !_tcsicmp(szPath+(cchPath-CCH_GLOBAL_ASA), SZ_GLOBAL_ASA));
    }

/*===================================================================
EncodeSessionIdCookie

Convert 3 DWORDs into a SessionID cookie string

Parameters
    dw1, dw2, dw3       DWORDs
    pszCookie           cookie to fill in

Returns
    HRESULT
===================================================================*/
HRESULT EncodeSessionIdCookie
(
DWORD dw1, DWORD dw2, DWORD dw3,
char *pszCookie
)
    {
    DWORD dw = dw1;

    for (int idw = 0; idw < 3; idw++)
        {
        for (int i = 0; i < 8; i++)
            {
            *(pszCookie++) = (char)('A' + (dw & 0xf));
            dw >>= 4;
            }
        dw = (idw == 0) ? dw2 : dw3;
        }

    *pszCookie = '\0';
    return S_OK;
    }

/*===================================================================
DecodeSessionIdCookie

Convert SessionID cookie string into 3 DWORDs

Parameters
    pszCookie           cookie string
    pdw1, pdw2, pdw3    [out] DWORDs

Returns
    HRESULT
===================================================================*/
HRESULT DecodeSessionIdCookie
(
const char *pszCookie,
DWORD *pdw1, DWORD *pdw2, DWORD *pdw3
)
    {
    if (strlen(pszCookie) != SESSIONID_LEN)
        return E_FAIL;

    DWORD *pdw = pdw1;

    for (int idw = 0; idw < 3; idw++)
        {
        *pdw = 0;

        for (int i = 0; i < 8; i++)
            {
            int ch = pszCookie[idw*8+7-i];
            if (ch < 'A' || ch > ('A'+0xf))
                return E_FAIL;

            *pdw <<= 4;
            *pdw |= (ch - 'A');
            }

        pdw = (idw == 0) ? pdw2 : pdw3;
        }

    return S_OK;
    }

/*===================================================================
GetTypelibFilenameFromRegistry

Find a typelib filename (path) from the registry using GUID, version,
and LCID. The algorithm taken from VBA. Does some tricky matching.

Parameters
    szUUID      GUID
    szVersion   Version
    lcid        LCID
    szName      [out] TYPELIB Path
    cbName      buffer length of szName

Returns
    HRESULT
===================================================================*/
HRESULT GetTypelibFilenameFromRegistry
(
const char *szUUID,
const char *szVersion,
LCID lcid,
char *szName,
DWORD cbName
)
    {
    szName[0] = '\0';

    LONG iRet;
    HKEY hkeyTLib = NULL;
    HKEY hkeyGuid = NULL;

    // Open up the typelib section of the registry.

    iRet = RegOpenKeyExA(HKEY_CLASSES_ROOT, "TypeLib", 0, KEY_READ, &hkeyTLib);
    if (iRet != ERROR_SUCCESS)
        return E_FAIL;

    // Now open up the guid, if it is registered.

    iRet = RegOpenKeyExA(hkeyTLib, szUUID, 0, KEY_READ, &hkeyGuid);
    if (iRet != ERROR_SUCCESS)
        {
        RegCloseKey(hkeyTLib);
        return E_FAIL;
        }

    // Iterate through the versions trying to find the exact match
    // or get the latest (max version number)

    char  szMaxVersion[16];
    DWORD dwMaxVersion = 0; // to calculate max version number

    BOOL fLookForExactMatch = (szVersion && *szVersion);

    int iVer = 0;
    szMaxVersion[0] = '\0';

    while (1)
        {
        char szEnumVer[16];

        iRet = RegEnumKeyA(hkeyGuid, iVer++, szEnumVer, sizeof(szEnumVer));
        if (iRet != ERROR_SUCCESS)
            break;

        // check for the exact match first
        if (fLookForExactMatch && strcmp(szEnumVer, szVersion))
            {
            strcpy(szMaxVersion, szEnumVer);
            break;
            }

        // calc the version number
        char *pchDot = strchr(szEnumVer, '.');
        if (!pchDot) // ignore if not #.#
            continue;

        DWORD dwVer = (strtoul(szEnumVer, NULL, 16) << 16) |
                       strtoul(pchDot+1, NULL, 16);

        if (dwVer && szMaxVersion[0] == '\0' || dwVer > dwMaxVersion)
            {
            strcpy(szMaxVersion, szEnumVer);
            dwMaxVersion = dwVer;
            }
        }

    // szMaxVersion (if not empty now has the desired version number)

    if (szMaxVersion[0])
        {
        HKEY hkeyVer = NULL;
        iRet = RegOpenKeyExA(hkeyGuid, szMaxVersion, 0, KEY_READ, &hkeyVer);

        if (iRet == ERROR_SUCCESS)
            {
            HKEY hkeyWin32 = NULL;  // "win32" under LCID is for TYPELIB name
            BOOL fLcidFound = FALSE;

            // Now there's a version key.
            // We need to find the best matching lcid

            for (int iTry = 1; !fLcidFound && iTry <= 3; iTry++)
                {
                char szLcid[10];

                switch (iTry)
                    {
                case 1:
                    // if the passed lcid is not 0, try it
                    if (!lcid)
                        continue;
                    _ultoa(lcid, szLcid, 16);
                    break;

                case 2:
                    // passed lcid stripped to primary language
                    if (!lcid)
                        continue;
                    _ultoa(PRIMARYLANGID(lcid), szLcid, 16);
                    break;

                case 3:
                    // "0"
                    szLcid[0] = '0';
                    szLcid[1] = '\0';
                    break;
                    }

                HKEY hkeyLcid  = NULL;
                iRet = RegOpenKeyExA(hkeyVer, szLcid, 0, KEY_READ, &hkeyLcid);
                if (iRet == ERROR_SUCCESS)
                    {
                    iRet = RegOpenKeyExA(hkeyLcid, "win32", 0, KEY_READ, &hkeyWin32);
                    if (iRet == ERROR_SUCCESS)
                        fLcidFound = TRUE;
                    RegCloseKey(hkeyLcid);
                    }
                }

            if (fLcidFound)
                {
                // LCID has been found - get the TYPELIB name
                Assert(hkeyWin32);
                LONG lName = cbName;
                iRet = RegQueryValueA(hkeyWin32, NULL, szName, &lName);

                if (iRet != ERROR_SUCCESS)
                    szName[0] = '\0';

                RegCloseKey(hkeyWin32);
                }

            RegCloseKey(hkeyVer);
            }
        }

    RegCloseKey(hkeyGuid);
    RegCloseKey(hkeyTLib);
    return (szName[0] == '\0') ? E_FAIL : S_OK;
    }

/*============================================================================
GetSecDescriptor

Get a file's Security Descriptor

Parameters:
    LPCSTR                  lpFileName              - file name
    PSECURITY_DESCRIPTOR    &pSecurityDescriptor    - security descriptor
    DWORD                   &nLength                - size of security descriptor

Returns:
    0 = No error
    or this will return the GetLastError results.

    Allocates memory.  Caller must deallocate (pSecurityDescriptor)
============================================================================*/

DWORD   GetSecDescriptor(LPCTSTR lpFileName, PSECURITY_DESCRIPTOR *ppSecurityDescriptor, DWORD *pnLength)
    {

    if (!FIsWinNT())
        return 0;

    // this should always be NULL
    Assert(*ppSecurityDescriptor == NULL);

    const SECURITY_INFORMATION  RequestedInformation =
                                          OWNER_SECURITY_INFORMATION        // security info struct
                                        | GROUP_SECURITY_INFORMATION
                                        | DACL_SECURITY_INFORMATION;

    DWORD                   nLastError  = 0;
    int                     fDidItWork  = TRUE;
    DWORD                   nLengthNeeded = 0;

    *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR) malloc( *pnLength );

    if (*ppSecurityDescriptor == NULL) {
        return E_OUTOFMEMORY;
    }

    while(TRUE)
        {
        fDidItWork = GetFileSecurity
            (lpFileName,                // address of string for file name
            RequestedInformation,       // requested information
            *ppSecurityDescriptor,      // address of security descriptor
            *pnLength,                  // size of security descriptor buffer
            &nLengthNeeded              // address of required size of buffer
            );

        if(!fDidItWork)
            {
            nLastError = GetLastError();
            if (ERROR_INSUFFICIENT_BUFFER == nLastError)
                {
                *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR) realloc(*ppSecurityDescriptor, nLengthNeeded );
                *pnLength = nLengthNeeded;
                nLastError = 0;
                }
            else
                {
                break;
                }
            }
        else
            {
            *pnLength = GetSecurityDescriptorLength( *ppSecurityDescriptor );
            break;
            }
        }

    // deal with errors and free the SD if needed
    //
    if (nLastError != 0)
        {
        if(*ppSecurityDescriptor)
            {
            free(*ppSecurityDescriptor);
            *ppSecurityDescriptor = NULL;
            }
        }
    return nLastError;
    }

/*============================================================================
AspGetFileAttributes

Wraps GetFileAttributes() and GetFileAttributesEx()

Parameters:
    pfad -- optional WIN32_FILE_ATTRIBUTE_DATA structure

Returns:
    S_OK or E_FAIL
============================================================================*/
HRESULT AspGetFileAttributes
(
LPCTSTR szFileName,
WIN32_FILE_ATTRIBUTE_DATA *pfad
)
    {
    // Take care of NT first (GetFileAttributesEx exists)
    if (Glob(fWinNT))
        {
        WIN32_FILE_ATTRIBUTE_DATA fad;

        BOOL fRet = GetFileAttributesEx
            (
            szFileName,
            GetFileExInfoStandard,
            pfad ? pfad : &fad
            );

        return fRet ? S_OK : E_FAIL;
        }

    // Win9x case
    DWORD dwAttributes = GetFileAttributes(szFileName);
    if (dwAttributes == 0xffffffff)
        return E_FAIL;

    // simulate the return of FAD if requested
    if (pfad)
        {
        memset(pfad, 0, sizeof(WIN32_FILE_ATTRIBUTE_DATA));
        pfad->dwFileAttributes = dwAttributes;
        }

    return S_OK;
    }



/*============================================================================
AspCharNextA

UTF-8 aware CharNext()
============================================================================*/

char *AspCharNextA(WORD wCodePage, const char *sz)
	{
	if (wCodePage != CP_UTF8)
		return CharNextExA(wCodePage, sz, 0);
	else
		{
		// CharNextExA won't work correctly in UTF-8.

		// Add support for UTF-8 encoding for Surrogate pairs
		// 110110wwwwzzzzyyyyyyxxxxxx gets encoded as 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
		// where uuuuu = wwww + 1 (to account for addition of 10000(b16) )
		// For further information refer : Page A-7 of "The Unicode Standard 2.0" ISBN-0-201-48345-9
		if ((*sz & 0xf8) == 0xF0)
		    return const_cast<char *>(sz + 4);  

		//zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
		if ((*sz & 0xF0) == 0xE0)
		    return const_cast<char *>(sz + 3);

        //00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
		else if ((*sz & 0xE0) == 0xC0)
			return const_cast<char *>(sz + 2);

        //000000000xxxxxxx = 0xxxxxxx
		else
			return const_cast<char *>(sz + 1);
		}
	}

/*============================================================================
CWCharToMBCS::~CWCharToMBCS

The destructor has to be in the source file to ensure that it gets the right
memory allocation routines defined.
============================================================================*/
CWCharToMBCS::~CWCharToMBCS() 
{
    if(m_pszResult && (m_pszResult != m_resMemory)) 
        free(m_pszResult); 
}

/*============================================================================
CWCharToMBCS::Init

Converts the passed in WideChar string to MultiByte in the code page
specified.  Uses memory declared in the object if it can, else allocates
from the heap.
============================================================================*/
HRESULT CWCharToMBCS::Init(LPCWSTR pWSrc, UINT lCodePage /* = CP_ACP */, int cchWSrc /* = -1 */)
{
    INT cbRequired;

    // don't even try to convert if we get a NULL pointer to the source.  This
    // condition could be handled by setting by just initing an empty string.

    if (pWSrc == NULL) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // The init method can be called multiple times on the same object.  Check
    // to see if memory was allocated the last time it was called.  If so,
    // free it and restore the result pointer to the object memory.  Note that
    // an allocation failure could have occurred in a previous call.  The result
    // would be a NULL m_pszResult.

    if (m_pszResult != m_resMemory) {
        if (m_pszResult)
            free(m_pszResult);
        m_pszResult = m_resMemory;
        m_cbResult = 0;
    }

    // set the first byte of the result string to NULL char.  This should help
    // to ensure that nothing wacky happens if this function fails.

    *m_pszResult = '\0';

    // attempt translation into object memory.

    cbRequired = WstrToMBstrEx(m_pszResult, sizeof(m_resMemory), pWSrc, cchWSrc, lCodePage);

    // if the conversion fit, then we're done.  Note the final result size and 
    // return.

    if (cbRequired <= sizeof(m_resMemory)) {
        m_cbResult = cbRequired;
        return NO_ERROR;
    }

    // if it didn't fit, allocate memory.  Return E_OUTOFMEMORY if it fails.

    m_pszResult = (LPSTR)malloc(cbRequired);
    if (m_pszResult == NULL) {
        return E_OUTOFMEMORY;
    }

    // try the convert again.  It should work.

    cbRequired = WstrToMBstrEx(m_pszResult, cbRequired, pWSrc, cchWSrc, lCodePage);

    // store the final char count in the object.

    m_cbResult = cbRequired;

    return NO_ERROR;
}

/*============================================================================
CWCharToMBCS::GetString

Returns a pointer to the converted string.

If the fTakeOwnerShip parameter is FALSE, then the pointer in the object is
simply returned to the caller.

If the fTakeOwnerShip parameter is TRUE, then the caller is expecting to be
returned a pointer to heap memory that they have to manage.  If the converted
string is in the object's memory, then the string is duplicated into the heap.
If it's already heap memory, then the pointer is handed off to the caller.

NOTE - Taking ownership essentially destroys the current contents of the 
object.  GetString cannot be called on the object again to get the same value.
The result will be a pointer to a empty string.

============================================================================*/
LPSTR CWCharToMBCS::GetString(BOOL fTakeOwnerShip)
{
    LPSTR retSz;

    // return the pointer stored in m_psz_Result if not being
    // requested to give up ownership on the memory or the
    // current value is NULL.

    if ((fTakeOwnerShip == FALSE) || (m_pszResult == NULL)) {
        retSz = m_pszResult;
    }

    // ownership is being requested and the pointer is non-NULL.

    // if the pointer is pointing to the object's memory, dup
    // the string and return that.

    else if (m_pszResult == m_resMemory) {

        retSz = StringDupA(m_pszResult, TRUE);
    }

    // if not pointing to the object's memory, then this is allocated
    // memory and we can relinquish it to the caller.  However, re-establish
    // the object's memory as the value for m_pszResult.

    else {
        retSz = m_pszResult;
        m_pszResult = m_resMemory;
        *m_pszResult = '\0';
        m_cbResult = 0;
    }

    return(retSz);
}

/*============================================================================
CMBCSToWChar::~CMBCSToWChar

The destructor has to be in the source file to ensure that it gets the right
memory allocation routines defined.
============================================================================*/
CMBCSToWChar::~CMBCSToWChar() 
{
    if(m_pszResult && (m_pszResult != m_resMemory)) 
        free(m_pszResult); 
}

/*============================================================================
CMBCSToWChar::Init

Converts the passed in MultiByte string to UNICODE in the code page
specified.  Uses memory declared in the object if it can, else allocates
from the heap.
============================================================================*/
HRESULT CMBCSToWChar::Init(LPCSTR pASrc, UINT lCodePage /* = CP_ACP */, int cchASrc /* = -1 */)
{
    INT cchRequired;

    // don't even try to convert if we get a NULL pointer to the source.  This
    // condition could be handled by setting by just initing an empty string.

    if (pASrc == NULL) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // The init method can be called multiple times on the same object.  Check
    // to see if memory was allocated the last time it was called.  If so,
    // free it and restore the result pointer to the object memory.  Note that
    // an allocation failure could have occurred in a previous call.  The result
    // would be a NULL m_pszResult.

    if (m_pszResult != m_resMemory) {
        if (m_pszResult)
            free(m_pszResult);
        m_pszResult = m_resMemory;
        m_cchResult = 0;
    }

    // set the first byte of the result string to NULL char.  This should help
    // to ensure that nothing wacky happens if this function fails.

    *m_pszResult = '\0';

    // attempt translation into object memory.  NOTE - MBstrToWstrEx returns the
    // count of characters, not bytes.

    cchRequired = MBstrToWstrEx(m_pszResult, sizeof(m_resMemory)/sizeof(WCHAR), pASrc, cchASrc, lCodePage);

    // if the conversion fit, then we're done.  Note the final result size and 
    // return.

    if (cchRequired <= (sizeof(m_resMemory)/sizeof(WCHAR))) {
        m_cchResult = cchRequired;
        return NO_ERROR;
    }

    // if it didn't fit, allocate memory.  Return E_OUTOFMEMORY if it fails.

    m_pszResult = (LPWSTR)malloc(cchRequired*sizeof(WCHAR));
    if (m_pszResult == NULL) {
        return E_OUTOFMEMORY;
    }

    // try the convert again.  It should work.

    cchRequired = MBstrToWstrEx(m_pszResult, cchRequired, pASrc, cchASrc, lCodePage);

    // store the final char count in the object.

    m_cchResult = cchRequired;

    return NO_ERROR;
}

/*============================================================================
CMBCSToWChar::GetString

Returns a pointer to the converted string.

If the fTakeOwnerShip parameter is FALSE, then the pointer in the object is
simply returned to the caller.

If the fTakeOwnerShip parameter is TRUE, then the caller is expecting to be
returned a pointer to heap memory that they have to manage.  If the converted
string is in the object's memory, then the string is duplicated into the heap.
If it's already heap memory, then the pointer is handed off to the caller.

NOTE - Taking ownership essentially destroys the current contents of the 
object.  GetString cannot be called on the object again to get the same value.
The result will be a pointer to a empty string.

============================================================================*/
LPWSTR CMBCSToWChar::GetString(BOOL fTakeOwnerShip)
{
    LPWSTR retSz;

    // return the pointer stored in m_psz_Result if not being
    // requested to give up ownership on the memory or the
    // current value is NULL.

    if ((fTakeOwnerShip == FALSE) || (m_pszResult == NULL)) {
        retSz = m_pszResult;
    }

    // ownership is being requested and the pointer is non-NULL.

    // if the pointer is pointing to the object's memory, dup
    // the string and return that.

    else if (m_pszResult == m_resMemory) {

        retSz = StringDupW(m_pszResult, TRUE);
    }

    // if not pointing to the object's memory, then this is allocated
    // memory and we can relinquish it to the caller.  However, re-establish
    // the object's memory as the value for m_pszResult.

    else {
        retSz = m_pszResult;
        m_pszResult = m_resMemory;
        *m_pszResult = '\0';
        m_cchResult = 0;
    }

    return(retSz);
}

// 
// (Un)DoRevertHack
//
// To prevent RPC token cache from growing without limit (and aging), we
// need to revert to self before calling back to inetinfo.exe.
//
// Now there is a new need to do this. As it turns out the performance
// hit we take from RPC caching these tokens is very significant.
// Ultimately we might want to implement a caching scheme ourselves so
// that the token we use is always the same for the same user identity,
// but that is a big change and this (although ugly as hell) works
// and has been tested for months.
//

VOID AspDoRevertHack( HANDLE * phToken )
{
    if ( OpenThreadToken( GetCurrentThread(),
                          TOKEN_IMPERSONATE,
                          TRUE,
                          phToken ) )
    {
        RevertToSelf();
    }
    else
    {
/*        
        DBGPRINTF((
            DBG_CONTEXT,
            "[DoRevertHack] OpenThreadToken failed.  Error %d.\r\n",
            GetLastError()
            ));
*/
        *phToken = INVALID_HANDLE_VALUE;
    }
}

VOID AspUndoRevertHack( HANDLE * phToken )
{
    if ( !*phToken || ( *phToken == INVALID_HANDLE_VALUE ) )
    {
        return;
    }

    SetThreadToken( NULL,
                    *phToken );

    CloseHandle( *phToken );

    *phToken = INVALID_HANDLE_VALUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\thrdgate.cpp ===
/*===================================================================
Microsoft IIS 5.0 (ASP)

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: Thread Gate

The thread gate limits number of threads executing at the
moment by sleeping some of them.

File: thrdgate.cpp

Owner: DmitryR

This file contains the code for the Thread Gate
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "thrdgate.h"
#include "memchk.h"

/*===================================================================
  Constants for tuning
===================================================================*/

/*===================================================================
  Class to track the processor load
===================================================================*/

inline DWORD GetNumberOfProcessors() {
    SYSTEM_INFO si;
    GetSystemInfo(&si);
    return si.dwNumberOfProcessors;
}

inline LONG GetPercentage(LARGE_INTEGER part, LARGE_INTEGER total) {

    if (total.HighPart == 0 && total.LowPart == 0) {
        return 100;
    }
    
    ULONG ul;
    LARGE_INTEGER t1, t2, t3;
    if (total.HighPart == 0) {
        t1 = RtlEnlargedIntegerMultiply(part.LowPart, 100);
        t2 = RtlExtendedLargeIntegerDivide(t1, total.LowPart, &ul);
    } else {
        t1 = RtlExtendedLargeIntegerDivide(total, 100, &ul);
        t2 = RtlLargeIntegerDivide(part, t1, &t3);
    }
    return t2.LowPart;
}

class CCPULoad {

private:
    DWORD m_cCPU;
    DWORD m_cbData;  // data struct length
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *m_psppiOld;
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *m_psppiNew;

public:

/*===================================================================
Constructor
===================================================================*/
CCPULoad() {

    // get the CPU count
    m_cCPU = GetNumberOfProcessors();

    m_cbData = m_cCPU * sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);
    
    m_psppiOld = new SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION[m_cCPU];
    m_psppiNew = new SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION[m_cCPU];
    if (m_psppiOld == NULL || m_psppiNew == NULL) {
        return;
    }

    // get the original snapshot
    NtQuerySystemInformation(
        SystemProcessorPerformanceInformation,
        m_psppiOld,
        m_cbData,
        NULL
        );
}
    
/*===================================================================
Destructor
===================================================================*/
~CCPULoad() {

    if (m_psppiOld != NULL) {
        delete m_psppiOld;
    }
    if (m_psppiNew != NULL) {
        delete m_psppiNew;
    }
}

/*===================================================================
GetReading
get the current reading as a percentage of CPU load
averaged across processors
===================================================================*/
DWORD GetReading() {

    if (m_psppiOld == NULL || m_psppiNew == NULL) {
        return 0;
    }
    
    // get the new snapshot
    NtQuerySystemInformation(
        SystemProcessorPerformanceInformation,
        m_psppiNew,
        m_cbData,
        NULL
        );

    // calculate
    LARGE_INTEGER cpuIdleTime, cpuUserTime, cpuKernelTime, 
                  cpuBusyTime, cpuTotalTime,
                  sumBusyTime = RtlConvertLongToLargeInteger(0),
                  sumTotalTime = RtlConvertLongToLargeInteger(0);

    for (DWORD i = 0; i < m_cCPU; i++) {
    
        cpuIdleTime   = RtlLargeIntegerSubtract(m_psppiNew[i].IdleTime, m_psppiOld[i].IdleTime);
        cpuUserTime   = RtlLargeIntegerSubtract(m_psppiNew[i].UserTime, m_psppiOld[i].UserTime);
        cpuKernelTime = RtlLargeIntegerSubtract(m_psppiNew[i].KernelTime, m_psppiOld[i].KernelTime);

        cpuTotalTime  = RtlLargeIntegerAdd(cpuUserTime, cpuKernelTime);
        cpuBusyTime   = RtlLargeIntegerSubtract(cpuTotalTime, cpuIdleTime);

        IF_DEBUG(THREADGATE)
            {
            LONG p = GetPercentage(cpuBusyTime, cpuTotalTime);
            DBGPRINTF((DBG_CONTEXT, "ThreadGate: load(%d)=%d", i+1, p));
            }

        sumBusyTime = RtlLargeIntegerAdd(sumBusyTime, cpuBusyTime);
        sumTotalTime = RtlLargeIntegerAdd(sumTotalTime, cpuTotalTime);
    }

    LONG nPercentage = GetPercentage(sumBusyTime, sumTotalTime);

    IF_DEBUG(THREADGATE)
        {
        DBGPRINTF((DBG_CONTEXT, "ThreadGate: **** load = %d\r\n", nPercentage));
        }

    // move new to old
    memcpy(m_psppiOld, m_psppiNew, m_cbData);

    return nPercentage;
}

/*=================================================================*/

}; // class CCPULoad


/*===================================================================
  The thread gate class
===================================================================*/

class CThreadGate {

private:

    DWORD m_msSlice;         // granularity
    DWORD m_msSleep;         // sleep length
    DWORD m_cSleepsMax;      // max wait 50 sleeps
    LONG  m_nLowLoad;        // low CPU load is < 75%
    LONG  m_nHighLoad;       // hight CPU load is > 90%
 
    LONG  m_cThreadLimitMin; // hunting range low
    LONG  m_cThreadLimitMax; // hunting range high

    LONG  m_cThreadLimit;    // current limit
    LONG  m_nTrend;          // last change

    DWORD m_msT0;            // starting time
    LONG  m_iCurrentSlice;   // current time slice index
    LONG  m_nRequests;       // number of active requests

    CCPULoad m_CPULoad;      // track the CPU load
    
public:

/*===================================================================
Constructor
===================================================================*/
CThreadGate(
    DWORD msSlice,
    DWORD msSleep,
    DWORD cSleepsMax,
    DWORD nLowLoad,
    DWORD nHighLoad,
    DWORD cLimitMin,
    DWORD cLimitMax
    ) {

    m_msSlice    = msSlice;
    m_msSleep    = msSleep;
    m_cSleepsMax = cSleepsMax;
    m_nLowLoad   = nLowLoad,
    m_nHighLoad  = nHighLoad;

    m_cThreadLimitMin = cLimitMin;
    m_cThreadLimitMax = cLimitMax;

    m_cThreadLimit = m_cThreadLimitMin;
    m_nTrend = 0;

    m_msT0 = GetTickCount();
    m_iCurrentSlice = 0;
    m_nRequests = 0;
}

/*===================================================================
Destructor
===================================================================*/
~CThreadGate()  {

}

/*===================================================================
HuntLoad

Do the load hunting
===================================================================*/
void HuntLoad() {

    LONG nLoad = m_CPULoad.GetReading();

    if (m_nRequests == 0) {
        // no requests - don't change
        m_nTrend = 0;
        return;
    }
    
    LONG cThreadLimit = m_cThreadLimit;
    LONG nTrend = m_nTrend;

    if (nLoad < m_nLowLoad) {
        nTrend = nTrend <= 0 ? 1 : nTrend+3;  // grow faster
        cThreadLimit += nTrend;
        
        if (cThreadLimit >= m_cThreadLimitMax) {
            cThreadLimit = m_cThreadLimitMax;
            nTrend = 0;
        }
    }
    else if (nLoad > m_nHighLoad) {
        nTrend = nTrend > 0 ? -1 : nTrend-1;
        cThreadLimit += nTrend;
        
        if (cThreadLimit <= m_cThreadLimitMin) {
            cThreadLimit = m_cThreadLimitMin;
            nTrend = 0;
        }
    }
    
    // set the new limit and trend
    m_cThreadLimit = cThreadLimit;
    m_nTrend = nTrend;
}

/*===================================================================
Enter

Pass through the gate. Can make the thread sleep

Returns
    Thread Gate Pass
===================================================================*/
void Enter(DWORD msCurrentTickCount) {

    DWORD cSleeps = 0;
    
    while (cSleeps++ < m_cSleepsMax) {

        // if shutting down, let the request go.  Later it will find
        // out again that the server is shutting down and not actually
        // fire the request.

        if (IsShutDownInProgress()) {
            break;
        }
		
    
        // calculate the current time slice
        DWORD msElapsedSinceT0 = (msCurrentTickCount >= m_msT0) ?
            (msCurrentTickCount - m_msT0) :
            ((0xffffffff - m_msT0) + msCurrentTickCount);
        LONG iSlice = msElapsedSinceT0 / m_msSlice;

        if (iSlice > m_iCurrentSlice) {
            // set it as the new one
            if (InterlockedExchange(&m_iCurrentSlice, iSlice) != iSlice) {

                // this is the first thread to jump the time slice - go hunting
                HuntLoad();
            }
        }

        // enforce the gate limit
        if (m_nRequests < m_cThreadLimit) {
            break;
        }

        // Too many active threads -- sleep
        Sleep(m_msSleep);
    }
    
    // let it through
    InterlockedIncrement(&m_nRequests);
}

/*===================================================================
Leave

Return. The user lets us know that the request finished.
===================================================================*/
void Leave() {

    InterlockedDecrement(&m_nRequests);
}

/*=================================================================*/

}; // class CThreadGate


// Pointer to the sole instance of the above
static CThreadGate *gs_pThreadGate = NULL;


/*===================================================================
  E x t e r n a l  A P I
===================================================================*/

/*===================================================================
InitThreadGate

Initialization

Parameters
    ptgc     configuration

Returns:
    HRESULT
===================================================================*/
HRESULT InitThreadGate(THREADGATE_CONFIG *ptgc) {

    DWORD cCPU = GetNumberOfProcessors();

    if (ptgc->fEnabled) {
        gs_pThreadGate = new CThreadGate(
            ptgc->msTimeSlice,
            ptgc->msSleepDelay,
            ptgc->nSleepMax,
            ptgc->nLoadLow,
            ptgc->nLoadHigh,
            ptgc->nMinProcessorThreads * cCPU,
            ptgc->nMaxProcessorThreads * cCPU
            );

        return (gs_pThreadGate != NULL) ? S_OK : E_OUTOFMEMORY;
        
    }
    
    gs_pThreadGate = NULL;
    return S_OK;
}


/*===================================================================
UnInitThreadGate

To be called from DllUnInit()

Parameters

Returns:
    n/a
===================================================================*/
void UnInitThreadGate() {

    if (gs_pThreadGate)  {
        delete gs_pThreadGate;
        gs_pThreadGate = NULL;
    }
}


/*===================================================================
PassThroughThreadGate

Pass through the gate. The current thread could be delayed in
case there are too many running threads at this moment

Parameters
    msCurrentTickCount      current tick count
===================================================================*/
void EnterThreadGate(DWORD msCurrentTickCount) {

    if (gs_pThreadGate) {
        gs_pThreadGate->Enter(msCurrentTickCount);
    }
}


/*===================================================================
LeaveThreadGate

Request done executing
===================================================================*/
void LeaveThreadGate() {

    if (gs_pThreadGate) {
        gs_pThreadGate->Leave();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\vecimpl.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: misc

File: vector.h

Owner: DGottner

This file contains a dynamic array
===================================================================*/

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright 1994, David Gottner
 *
 *                    All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice, this permission notice and
 * the following disclaimer notice appear unmodified in all copies.
 *
 * I DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL I
 * BE LIABLE FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef VECIMPL_H
#define VECIMPL_H


#define VEC_GROW_SIZE 64		// grow in chunks of this many items
#define __vec_rounded_size(s) \
			(((s) + (VEC_GROW_SIZE - 1)) & ~(VEC_GROW_SIZE - 1))


template <class TYPE>
vector<TYPE>::vector() : m_rgData(NULL), m_cItems(0), m_cCells(0)
{
}


template <class TYPE>
HRESULT vector<TYPE>::Init(const TYPE *anArray, size_t theSize)
{
	m_cCells = __vec_rounded_size(theSize);

	register size_t      n     = m_cItems = theSize;
	register TYPE *      pDest = m_rgData = new TYPE[m_cCells];
	register const TYPE *pSrc  = anArray;

	if (pDest == NULL)
		{
		m_cItems = m_cCells = 0;
		return E_OUTOFMEMORY;
		}

	while (n--)
		*pDest++ = *pSrc++;

	return S_OK;
}


template <class TYPE>
HRESULT vector<TYPE>::Init(size_t n)
{
	m_rgData = new TYPE[m_cCells = __vec_rounded_size(m_cItems = n)];
	if (m_rgData == NULL)
		{
		m_cItems = m_cCells = 0;
		return E_OUTOFMEMORY;
		}

	return S_OK;
}


template <class TYPE>
vector<TYPE>::~vector()
{
	delete[] m_rgData;
}


template <class TYPE>
HRESULT vector<TYPE>::resize(size_t cNewCells)
{
	cNewCells = __vec_rounded_size(cNewCells);
	if (m_cCells == cNewCells)
		return S_OK;

	TYPE *rgData = new TYPE[cNewCells];
	if (rgData == NULL)
		return E_OUTOFMEMORY;

	register size_t      n     = (m_cItems < cNewCells)? m_cItems : cNewCells;
	register TYPE *      pDest = rgData;
	register const TYPE *pSrc  = m_rgData;

	m_cItems = n;
	m_cCells = cNewCells;

	while (n--)
		*pDest++ = *pSrc++;

	delete[] m_rgData;
	m_rgData = rgData;

	return S_OK;
}


template <class TYPE>
HRESULT vector<TYPE>::reshape(size_t cNewItems)
{
	HRESULT hrRet = S_OK;
	if (cNewItems > m_cCells)
		hrRet = resize(cNewItems);

	if (SUCCEEDED(hrRet))
		m_cItems = cNewItems;

	return hrRet;
}


template <class TYPE>
HRESULT vector<TYPE>::insertAt(size_t pos, const TYPE &item)
{
	Assert (pos <= m_cItems);

	HRESULT hrRet = S_OK;
	if ((m_cItems + 1) > m_cCells)
		hrRet = resize(m_cCells + VEC_GROW_SIZE);

	if (SUCCEEDED(hrRet))
		{
		TYPE *pDest = &m_rgData[pos];
		for (register TYPE *ptr = &m_rgData[m_cItems];
			 ptr > pDest;
			 --ptr)
			*ptr = *(ptr - 1);

		*pDest = item;
		++m_cItems;
		}

	return hrRet;
}


template <class TYPE>
TYPE vector<TYPE>::removeAt(size_t pos)
{
	Assert (pos < m_cItems);

	TYPE *         end = &m_rgData[--m_cItems];
	register TYPE *ptr = &m_rgData[pos];
	TYPE           val = *ptr;

	for (; ptr < end; ++ptr)
		*ptr = *(ptr + 1);

	return val;
}


template <class TYPE>
int vector<TYPE>::find(const TYPE &item) const
{
	for (register unsigned i = 0; i < m_cItems; ++i)
		if (item == m_rgData[i])
			return i;

	return -1;
}

#endif /* VECIMPL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\xor.cpp ===
#include <wtypes.h>
#include <winbase.h>
#include <malloc.h>
#include <stdlib.h>
#include "c:\denali\inc\magic.h"

void WriteFileAsAsciiCodes(HANDLE hOutFile, BYTE pBuffer[], DWORD cbBuffer)
	{
	DWORD	cbWritten;
	char szCode[5];

	for(DWORD i = 0; i < cbBuffer; i++)
		{
		_itoa((int)pBuffer[i], szCode, 10);
		WriteFile(hOutFile, szCode, strlen(szCode), &cbWritten, NULL);
		if(i == (cbBuffer - 1))
			break;
		WriteFile(hOutFile, ",", 1, &cbWritten, NULL);
		if(0 == i % 20 && i > 0)
			WriteFile(hOutFile, "\r\n", 2, &cbWritten, NULL);
		}
	}

void main(int argc, char** argv)
	{
/*	char*	szText =	"Now is the time for us to sell a lot of Denali.";
	int	cchText = lstrlen(szText);
	DWORD	cbWritten;
*/
	int		cchKey = strlen(SZ_MAGICKEY);
	LPVOID	pBuffer;
	DWORD	cbBuffer;
	DWORD	cbRead;

  	HANDLE hInFile = CreateFile(argv[1], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hInFile == INVALID_HANDLE_VALUE && hInFile == NULL)
		return;
  	
	HANDLE hOutFile = CreateFile(argv[2], GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hOutFile == INVALID_HANDLE_VALUE && hOutFile == NULL)
		return;

	cbBuffer = GetFileSize(hInFile, NULL);
	pBuffer = _alloca(cbBuffer);

	if(!ReadFile(hInFile, pBuffer, cbBuffer, &cbRead, NULL))
		return;
	CloseHandle(hInFile);

	xor(pBuffer, cbBuffer, SZ_MAGICKEY, cchKey);

	WriteFileAsAsciiCodes(hOutFile, (BYTE*) pBuffer, cbBuffer);

/*	if(!WriteFile(hOutFile, pBuffer, cbBuffer, &cbWritten, NULL))
		return;

	xor(szText, cchText, SZ_MAGICKEY, cchKey);
	OutputDebugString(szText);
	OutputDebugString("\r\n");
	xor(szText, cchText, SZ_MAGICKEY, cchKey);
	OutputDebugString(szText);
	OutputDebugString("\r\n");
*/
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\viperint.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Viper Integration Objects

File: viperint.cpp

Owner: DmitryR

This file contains the implementation of viper integration classes
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "Context.h"
#include "package.h"
#include "memchk.h"

extern HDESK ghDesktop;

//
// COM holds the last reference to a CViperAsyncRequest
// we need to track these objects to ensure that we don't
// exit before the activity threads have released them.
//

volatile LONG g_nViperRequests = 0;

/*===================================================================
  C  V i p e r  A s y n c R e q u e s t
===================================================================*/

/*===================================================================
CViperAsyncRequest::CViperAsyncRequest

CViperAsyncRequest constructor

Parameters:

Returns:
===================================================================*/	
CViperAsyncRequest::CViperAsyncRequest()
    : m_cRefs(1), m_pHitObj(NULL), m_hrOnError(S_OK), m_pActivity(NULL), m_dwRepostAttempts(0)
{
    InterlockedIncrement( (LONG *)&g_nViperRequests );
}

/*===================================================================
CViperAsyncRequest::~CViperAsyncRequest

CViperAsyncRequest destructor

Parameters:

Returns:
===================================================================*/	
CViperAsyncRequest::~CViperAsyncRequest()
{
    InterlockedDecrement( (LONG *)&g_nViperRequests );
}

/*===================================================================
CViperAsyncRequest::Init

Initialize CViperAsyncRequest with CHitObj object

Parameters:
    CHitObj       *pHitObj       Denali HitObj

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperAsyncRequest::Init
(
CHitObj           *pHitObj,
IServiceActivity  *pActivity
)
    {
    Assert(m_pHitObj == NULL);

    m_pHitObj = pHitObj;
    m_pActivity = pActivity;

    return S_OK;
    }

#ifdef DBG
/*===================================================================
CViperAsyncRequest::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CViperAsyncRequest::AssertValid() const
    {
    Assert(m_pHitObj);
    Assert(m_cRefs > 0);
    }
#endif

/*===================================================================
CViperAsyncRequest::QueryInterface

Standard IUnknown method

Parameters:
    REFIID iid
    void **ppv

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperAsyncRequest::QueryInterface
(
REFIID iid, 
void **ppv
)
    {
	if (iid == IID_IUnknown || iid == IID_IServiceCall)
	    {
		*ppv = this;
	    AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;
    }

/*===================================================================
CViperAsyncRequest::AddRef

Standard IUnknown method

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CViperAsyncRequest::AddRef()
    {
	return ++m_cRefs;
    }

/*===================================================================
CViperAsyncRequest::Release

Standard IUnknown method

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CViperAsyncRequest::Release()
    {
	if (--m_cRefs != 0)
		return m_cRefs;

	delete this;
	return 0;
    }
    
/*===================================================================
CViperAsyncRequest::OnCall

IMTSCall method implementation. This method is called by Viper
from the right thread when it's time to process a request

Parameters:

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperAsyncRequest::OnCall()
    {
    Assert(m_pHitObj);
    CIsapiReqInfo *pIReq = m_pHitObj->PIReq();

    BOOL fRequestReposted = FALSE;

    // add an extra addref here to prevent the deletion of the
    // hitobj deleting the CIsapiReqInfo for this request.

    if (pIReq)
        pIReq->AddRef();

    // Bracket ViperAsyncCallback

    if (SUCCEEDED(StartISAThreadBracket(pIReq)))
        {

        m_pHitObj->ViperAsyncCallback(&fRequestReposted);

        // Make sure there always is DONE_WITH_SESSION
        if (m_pHitObj->FIsBrowserRequest() && !fRequestReposted)
            {
            if (!m_pHitObj->FDoneWithSession())
                m_pHitObj->ReportServerError(IDE_UNEXPECTED);
            }

        if (!fRequestReposted)
            delete m_pHitObj;   // don't delete if reposted

        EndISAThreadBracket(pIReq);
        
        }
    else
        {
        // DONE_WITH_SESSION -- ServerSupportFunction
        // does not need bracketing
        if (m_pHitObj->FIsBrowserRequest())
            m_pHitObj->ReportServerError(0);

        // We never called to process request, there should
        // be no state and it's probably save to delete it
        // outside of bracketing
        delete m_pHitObj;
        }

    m_pHitObj = NULL;       // set to NULL even if not deleted
    Release();              // release this, Viper holds another ref

    if (pIReq)
        pIReq->Release();

    return S_OK;
    }

/*===================================================================
CViperAsyncRequest::OnError

Called by COM+ when it is unable to dispatch the request properly
on the configured thread

Parameters:

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperAsyncRequest::OnError(HRESULT hrViperError)
{
    Assert(m_pHitObj);
    CIsapiReqInfo *pIReq = m_pHitObj->PIReq();
    HRESULT     hr = S_OK;

    if (pIReq)
        pIReq->AddRef();

    m_dwRepostAttempts++;

    // attempt to repost the request if it hasn't errored out three
    // times yet.

    if (m_dwRepostAttempts <= 3) {

        hr = m_pActivity->AsynchronousCall(this);

        Assert(SUCCEEDED(hr));
    }

    // if it has errored out three times or the repost failed,
    // pitch the request

    if (FAILED(hr) || (m_dwRepostAttempts > 3)) {

        // DONE_WITH_SESSION -- ServerSupportFunction
        // does not need bracketing
        if (m_pHitObj->FIsBrowserRequest())
            m_pHitObj->ReportServerError(IDE_UNEXPECTED);

        // We never called to process request, there should
        // be no state and it's probably save to delete it
        // outside of bracketing

        delete m_pHitObj;

        m_pHitObj = NULL;       // set to NULL even if not deleted
        Release();              // release this, Viper holds another ref
    }

    if (pIReq)
        pIReq->Release();

    return S_OK;
}


/*===================================================================
  C  V i p e r  A c t i v i t y
===================================================================*/

/*===================================================================
CViperActivity::CViperActivity

CViperActivity constructor

Parameters:

Returns:
===================================================================*/	
CViperActivity::CViperActivity()
    : m_pActivity(NULL), m_cBind(0)
    {
    }

/*===================================================================
CViperActivity::~CViperActivity

CViperActivity destructor

Parameters:

Returns:
===================================================================*/	
CViperActivity::~CViperActivity()
    {
    UnInit();
    }

/*===================================================================
CViperActivity::Init

Create actual Viper activity using MTSCreateActivity()

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::Init(IUnknown  *pServicesConfig)
    {
    Assert(!FInited());

    HRESULT hr = S_OK;

    hr = CoCreateActivity(pServicesConfig, IID_IServiceActivity,  (void **)&m_pActivity);

    if (FAILED(hr))
        return hr;

    m_cBind = 1;
    return S_OK;
    }

/*===================================================================
CViperActivity::InitClone

Clone Viper activity (AddRef() it)

Parameters:
    CViperActivity *pActivity   activity to clone from

Returns:
    HRESULT
===================================================================*/
HRESULT CViperActivity::InitClone
(
CViperActivity *pActivity
)
    {
    Assert(!FInited());
    Assert(pActivity);
    pActivity->AssertValid();

    m_pActivity = pActivity->m_pActivity;
    m_pActivity->AddRef();

    m_cBind = 1;
    return S_OK;
    }

/*===================================================================
CViperActivity::UnInit

Release Viper activity

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::UnInit()
    {
    if (m_pActivity)
        {
        while (m_cBind > 1)  // 1 is for inited flag
            {
            m_pActivity->UnbindFromThread();
            m_cBind--;
            }
                
        m_pActivity->Release();
        m_pActivity = NULL;
        }

    m_cBind = 0;
    return S_OK;
    }

/*===================================================================
CViperActivity::BindToThread

Bind Activity to current thread using IMTSActivity method

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::BindToThread()
    {
    Assert(FInited());
    
    m_pActivity->BindToCurrentThread();
    m_cBind++;
    
    return S_OK;
    }
    
/*===================================================================
CViperActivity::UnBindFromThread

UnBind Activity from using IMTSActivity method

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::UnBindFromThread()
    {
    Assert(FInited());
    Assert(m_cBind > 1);

    m_pActivity->UnbindFromThread();
    m_cBind--;

    return S_OK;
    }
    
/*===================================================================
CViperActivity::PostAsyncRequest

Call HitObj Async.
Creates IMTSCCall object to do it.

Parameters:
    CHitObj      *pHitObj    Denali's HitObj

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::PostAsyncRequest
(
CHitObj *pHitObj
)
    {
    AssertValid();

    HRESULT hr = S_OK;

    CViperAsyncRequest *pViperCall = new CViperAsyncRequest;
    if (!pViperCall)
         hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = pViperCall->Init(pHitObj, m_pActivity);

	RevertToSelf();

    if (SUCCEEDED(hr))
        hr = m_pActivity->AsynchronousCall(pViperCall);

    if (FAILED(hr) && pViperCall)  // cleanup if failed
        pViperCall->Release();
        
    return hr;
    }

/*===================================================================
CViperActivity::PostGlobalAsyncRequest

Static method.
Post async request without an activity.
Creates temporary activity

Parameters:
    CHitObj *pHitObj    Denali's HitObj

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::PostGlobalAsyncRequest
(
CHitObj *pHitObj
)
    {
    HRESULT hr = S_OK;
    
    CViperActivity *pTmpActivity = new CViperActivity;
    if (!pTmpActivity)
         hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = pTmpActivity->Init(pHitObj->PAppln()->PServicesConfig());

    if (SUCCEEDED(hr))
        {
        // remember this activity as HitObj's activity
        // HitObj will get rid of it on its destructor
        pHitObj->SetActivity(pTmpActivity);

        hr = pTmpActivity->PostAsyncRequest(pHitObj);
        
        pTmpActivity = NULL; // don't delete, HitObj will
        }

    if (pTmpActivity)
        delete pTmpActivity;

    return hr;
    }

#ifdef DBG
/*===================================================================
CViperAsyncRequest::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CViperActivity::AssertValid() const
	{
    Assert(FInited());
	Assert(m_pActivity);
	}
#endif

#ifdef UNUSED
/*===================================================================
  C  V i p e r  T h r e a d E v e n t s
===================================================================*/

/*===================================================================
CViperThreadEvents::CViperThreadEvents

CViperThreadEvents constructor

Parameters:

Returns:
===================================================================*/	
CViperThreadEvents::CViperThreadEvents()
    : m_cRefs(1)
    {
    }

#ifdef DBG
/*===================================================================
CViperThreadEvents::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CViperThreadEvents::AssertValid() const
    {
    Assert(m_cRefs > 0);
    Assert(ghDesktop != NULL);
    }
#endif

/*===================================================================
CViperThreadEvents::QueryInterface

Standard IUnknown method

Parameters:
    REFIID iid
    void **ppv

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperThreadEvents::QueryInterface
(
REFIID iid, 
void **ppv
)
    {
	if (iid == IID_IUnknown || iid == IID_IThreadEvents)
	    {
		*ppv = this;
	    AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;
    }

/*===================================================================
CViperThreadEvents::AddRef

Standard IUnknown method

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CViperThreadEvents::AddRef()
    {
    DWORD cRefs = InterlockedIncrement((LPLONG)&m_cRefs);
    return cRefs;
    }

/*===================================================================
CViperThreadEvents::Release

Standard IUnknown method

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CViperThreadEvents::Release()
    {
    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
    if (cRefs)
        return cRefs;

	delete this;
	return 0;
    }
    
/*===================================================================
CViperThreadEvents::OnStartup

IThreadEvents method implementation. This method is called by Viper
whenever they start up a thread.

Parameters:
	None

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperThreadEvents::OnStartup()
    {
    HRESULT hr;
    
    AssertValid();

	// Set the desktop for this thread
	hr = SetDesktop();
	
    return hr;
    }

/*===================================================================
CViperThreadEvents::OnShutdown

IThreadEvents method implementation. This method is called by Viper
whenever they shut down a thread.

Parameters:
	None
	
Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperThreadEvents::OnShutdown()
    {
    AssertValid();

    return S_OK;
    }
#endif //UNUSED


/*===================================================================
  G l o b a l  F u n c t i o n s
===================================================================*/

/*===================================================================
ViperSetContextProperty

Static utility function.

Set Viper context property by BSTR and IDispatch*.
The real interface takes BSTR and VARIANT.

Parameters
    IContextProperties *pContextProperties       Context
    BSTR                bstrPropertyName         Name
    IDispatch          *pdispPropertyValue       Value

Returns:
    HRESULT
===================================================================*/
static HRESULT ViperSetContextProperty
(
IContextProperties *pContextProperties,
BSTR                bstrPropertyName, 
IDispatch          *pdispPropertyValue
)
    {
    // Make VARIANT from IDispatch*

    pdispPropertyValue->AddRef();

    VARIANT Variant;
    VariantInit(&Variant);
    V_VT(&Variant) = VT_DISPATCH;
    V_DISPATCH(&Variant) = pdispPropertyValue;

    // Call Viper to set the property
    
    HRESULT hr = pContextProperties->SetProperty
        (
        bstrPropertyName, 
        Variant
        );

    // Cleanup

    VariantClear(&Variant);

    return hr;
    }

/*===================================================================
ViperAttachIntrinsicsToContext

Attach ASP intrinsic objects as Viper context properties

Parameters - Intrinsics as interface pointers
    IApplicationObject *pAppln      Application   (required)
    ISessionObject     *pSession    Session       (optional)
    IRequest           *pRequest    Request       (optional)
    IResponse          *pResponse   Response      (optional)
    IServer            *pServer     Server        (optional)

Returns:
    HRESULT
===================================================================*/
HRESULT ViperAttachIntrinsicsToContext
(
IApplicationObject *pAppln,
ISessionObject     *pSession,
IRequest           *pRequest,
IResponse          *pResponse,
IServer            *pServer
)
    {
    Assert(pAppln);
    
    HRESULT hr = S_OK;

    // Get Viper Context
    
    IObjectContext *pViperContext = NULL;
    hr = GetObjectContext(&pViperContext);

    // Get IContextPoperties interface

    IContextProperties *pContextProperties = NULL;
    if (SUCCEEDED(hr))
   		hr = pViperContext->QueryInterface
   		    (
   		    IID_IContextProperties, 
   		    (void **)&pContextProperties
   		    );

    // Set properties

    if (SUCCEEDED(hr))
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_APPLICATION,
            pAppln
            );

    if (SUCCEEDED(hr) && pSession)
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_SESSION,
            pSession
            );
        
    if (SUCCEEDED(hr) && pRequest)
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_REQUEST,
            pRequest
            );

    if (SUCCEEDED(hr) && pResponse)
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_RESPONSE, 
            pResponse
            );

    if (SUCCEEDED(hr) && pServer)
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_SERVER, 
            pServer
            );

    // Cleanup

    if (pContextProperties)
        pContextProperties->Release();

    if (pViperContext)
        pViperContext->Release();

    return hr;
    }
    
/*===================================================================
ViperGetObjectFromContext

Get Viper context property by LPWSTR and
return it as IDispatch*.
The real interface takes BSTR and VARIANT.

Parameters
    BSTR       bstrName      Property Name
    IDispatch  **ppdisp       [out] Object (Property Value)

Returns:
    HRESULT
===================================================================*/
HRESULT ViperGetObjectFromContext
(
BSTR bstrName,
IDispatch **ppdisp
)
    {
    Assert(ppdisp);

    HRESULT hr = S_OK;

    // Get Viper Context
    
    IObjectContext *pViperContext = NULL;
    hr = GetObjectContext(&pViperContext);

    // Get IContextPoperties interface

    IContextProperties *pContextProperties = NULL;
    if (SUCCEEDED(hr))
   		hr = pViperContext->QueryInterface
   		    (
   		    IID_IContextProperties, 
   		    (void **)&pContextProperties
   		    );

    // Get property Value as variant

    VARIANT Variant;
    VariantInit(&Variant);

    if (SUCCEEDED(hr))
        hr = pContextProperties->GetProperty(bstrName, &Variant);

    // Convert Variant to IDispatch*

    if (SUCCEEDED(hr))
        {
        IDispatch *pDisp = NULL;
        if (V_VT(&Variant) == VT_DISPATCH)
            pDisp = V_DISPATCH(&Variant);

        if (pDisp)
            {
            pDisp->AddRef();
            *ppdisp = pDisp;
            }
        else
            hr = E_FAIL;
        }
    
    // Cleanup

    VariantClear(&Variant);

    if (pContextProperties)
        pContextProperties->Release();

    if (pViperContext)
        pViperContext->Release();

    if (FAILED(hr))
        *ppdisp = NULL;

    return hr;
    }

/*===================================================================
ViperGetHitObjFromContext

Get Server from Viper context property and get
it's current HitObj

Parameters
    CHitObj **ppHitObj  [out]

Returns:
    HRESULT
===================================================================*/
HRESULT ViperGetHitObjFromContext
(
CHitObj **ppHitObj
)
    {
    *ppHitObj = NULL;
    
    IDispatch *pdispServer = NULL;
    HRESULT hr = ViperGetObjectFromContext(BSTR_OBJ_SERVER, &pdispServer);
    if (FAILED(hr))
        return hr;

    if (pdispServer)
        {
        CServer *pServer = static_cast<CServer *>(pdispServer);
        *ppHitObj = pServer->PHitObj();
        pdispServer->Release();
        }

    return *ppHitObj ? S_OK : S_FALSE;
    }
    
/*===================================================================
ViperCreateInstance

Viper's implementation of CoCreateInstance

Parameters
    REFCLSID rclsid         class id
    REFIID   riid           interface
    void   **ppv            [out] pointer to interface

Returns:
    HRESULT
===================================================================*/
HRESULT ViperCreateInstance
(
REFCLSID rclsid,
REFIID   riid,
void   **ppv
)
{
    /*
    DWORD dwClsContext = (Glob(fAllowOutOfProcCmpnts)) ? 
            CLSCTX_INPROC_SERVER | CLSCTX_SERVER : 
            CLSCTX_INPROC_SERVER;
    */

    // The reasons for supporting ASPAllowOutOfProcComponents seem to have
    // vanished. Because this only partially worked in II4 and we changed
    // the default in IIS5 this was causing problems with upgrades. So
    // we're going to ignore the fAllowOutOfProcCmpnts setting.

    DWORD dwClsContext = CLSCTX_INPROC_SERVER | CLSCTX_SERVER;
	return CoCreateInstance(rclsid, NULL, dwClsContext, riid, ppv);
}

/*===================================================================
ViperConfigure

Viper settings:  # of threads, queue len, 
                 in-proc failfast, 
                 allow oop components

Parameters
	cThreads                --  number of threads
	fAllowOopComponents     --  TRUE or FALSE
	
Returns:
    HRESULT
===================================================================*/
HRESULT ViperConfigure
(
DWORD cThreads,
BOOL  fAllowOopComponents
)
    {
    HRESULT hr = S_OK;
    IMTSPackage *pPackage = NULL;

    //
    // Get hold of the package
    //

    hr = CoCreateInstance(CLSID_MTSPackage,
			  NULL,
			  CLSCTX_INPROC_SERVER,
			  IID_IMTSPackage,
			  (void **)&pPackage);
    if (SUCCEEDED(hr) && !pPackage)
    	hr = E_FAIL;

    //
    // Set knobs
    //

    if (SUCCEEDED(hr))
        {
#define MTS_STYLE_THREAD_POOL

#ifdef MTS_STYLE_THREAD_POOL
    	IComStaThreadPoolKnobs *pKnobs = NULL;
	    hr = pPackage->QueryInterface(IID_IComStaThreadPoolKnobs, (void **)&pKnobs);
#else
    	IThreadPoolKnobs *pKnobs = NULL;
	    hr = pPackage->QueryInterface(IID_IThreadPoolKnobs, (void **)&pKnobs);
#endif

    	if (SUCCEEDED(hr) && pKnobs)
    	    {
    	    // number of threads
    		SYSTEM_INFO si;
	    	GetSystemInfo(&si);
		    cThreads *= si.dwNumberOfProcessors;
#ifdef MTS_STYLE_THREAD_POOL
    		pKnobs->SetMaxThreadCount(cThreads);
    		pKnobs->SetMinThreadCount(si.dwNumberOfProcessors + 7);

    		// queue length
    		pKnobs->SetQueueDepth(30000);

    		pKnobs->SetActivityPerThread(1);
#else
    		pKnobs->SetMaxThreads(cThreads);
    		pKnobs->SetMinThreads(si.dwNumberOfProcessors + 7);

    		// queue length
    		pKnobs->SetMaxQueuedRequests(30000);
#endif
    		
    	    pKnobs->Release();
    	    }
        }

    //
    // Bug 111008: Tell Viper that we do impersonations
    //
 
    if (SUCCEEDED(hr)) 
        {
    	IImpersonationControl *pImpControl = NULL;
        hr = pPackage->QueryInterface(IID_IImpersonationControl, (void **)&pImpControl);

    	if (SUCCEEDED(hr) && pImpControl) 
    	    {
            hr = pImpControl->ClientsImpersonate(TRUE);
    	    pImpControl->Release();
	        }
        }

    //
    // Disable FAILFAST for in-proc case
    //

    if (SUCCEEDED(hr) && !g_fOOP)
        {
    	IFailfastControl *pFFControl = NULL;
    	hr = pPackage->QueryInterface(IID_IFailfastControl, (void **)&pFFControl);

    	if (SUCCEEDED(hr) && pFFControl) 
    	    {
    	    pFFControl->SetApplFailfast(FALSE);
	        pFFControl->Release();
	        }
    	}

/*
    //
    // Set Allow OOP Components
    //
    if (SUCCEEDED(hr)) 
        {
	    INonMTSActivation *pNonMTSActivation = NULL;
    	hr = pPackage->QueryInterface(IID_INonMTSActivation, (void **)&pNonMTSActivation);
    	
    	if (SUCCEEDED(hr) && pNonMTSActivation) 
    	    {
        	pNonMTSActivation->OutOfProcActivationAllowed(fAllowOopComponents);
    		pNonMTSActivation->Release();
    	    }
   	    }
*/

    //
    // Clean-up
    //

    if (pPackage) 
    	pPackage->Release();

    return hr;
    }


/*===================================================================
  C O M  H e l p e r  A P I
===================================================================*/

/*===================================================================
ViperCoObjectIsaProxy

Checks if the given IUnknown* points to a proxy

Parameters
    IUnknown* pUnk      pointer to check

Returns:
    BOOL    (TRUE if Proxy)
===================================================================*/
BOOL ViperCoObjectIsaProxy
(
IUnknown* pUnk
)
    {
	HRESULT hr;
	IUnknown *pUnk2;

	hr = pUnk->QueryInterface(IID_IProxyManager, (void**)&pUnk2);
	if (FAILED(hr))
		return FALSE;

	pUnk2->Release();
	return TRUE;
    }

/*===================================================================
ViperCoObjectAggregatesFTM

Checks if the given object agregates free threaded marshaller
(is agile)

Parameters
    IUnknown* pUnk      pointer to check

Returns:
    BOOL    (TRUE if Agile)
===================================================================*/
BOOL ViperCoObjectAggregatesFTM
(
IUnknown *pUnk
)
    {
	HRESULT hr;
	IMarshal *pMarshal;
	GUID guidClsid;

	hr = pUnk->QueryInterface(IID_IMarshal, (void**)&pMarshal);
	if (FAILED(hr))
		return FALSE;

	hr = pMarshal->GetUnmarshalClass(IID_IUnknown, pUnk, MSHCTX_INPROC,
	                                 NULL, MSHLFLAGS_NORMAL, &guidClsid);
	pMarshal->Release();

	if (FAILED(hr))
		return FALSE;

	return (guidClsid == CLSID_InProcFreeMarshaler);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\vector.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: misc

File: vector.h

Owner: DGottner

This file contains a dynamic array
===================================================================*

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright 1994, David Gottner
 *
 *                    All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice, this permission notice and
 * the following disclaimer notice appear unmodified in all copies.
 *
 * I DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL I
 * BE LIABLE FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef VECTOR_H
#define VECTOR_H

 /*---------------------------------------------------------------------------*
 ** The vector class is a thin encapsulation of a C style array, which
 ** allows dynamic sizing of the array and bounds checking; you can also use
 ** this array as a stack.  This is a value-based collection.
 */

template <class TYPE>
class vector {
	TYPE *	m_rgData;
	size_t	m_cItems;
	size_t	m_cCells;

public:
	vector<TYPE>();
	~vector();

	HRESULT Init(const TYPE *, size_t);
	HRESULT Init(size_t n);

	vector<TYPE> &operator= (const vector<TYPE> &);

	size_t length() const	 { return m_cItems; }
	const TYPE *vec() const	 { return m_rgData; }

	// STL iterators (const)
	const TYPE *begin() const { return &m_rgData[0]; }
	const TYPE *end() const   { return &m_rgData[m_cItems]; }

	// STL iterators (non-const)
	TYPE *begin()             { return &m_rgData[0]; }
	TYPE *end()               { return &m_rgData[m_cItems]; }

	TYPE operator[](unsigned i) const
	{
		Assert (i < m_cItems);
		return m_rgData[i];
	}

	TYPE &operator[](unsigned i)
	{
		Assert (i < m_cItems);
		return m_rgData[i];
	}

	HRESULT resize(size_t);
	HRESULT reshape(size_t);

	HRESULT append(const TYPE &a)   { return insertAt(m_cItems, a); }
	HRESULT prepend(const TYPE &a)  { return insertAt(0, a);         }

	HRESULT insertAt(size_t, const TYPE &);
	TYPE removeAt(size_t);

	HRESULT push(const TYPE &a)	{ return append(a); }
	TYPE pop()					{ return m_rgData[--m_cItems]; }

	int find(const TYPE &) const;
};

#endif /* VECTOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\applmgr.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Application Object Manager

File: Applmgr.cpp

Owner: PramodD

This is the Application Manager source file.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "activdbg.h"
#include "mtacb.h"
#include "debugger.h"
#include "memchk.h"

PTRACE_LOG          CAppln::gm_pTraceLog = NULL;
CApplnMgr           g_ApplnMgr;
CApplnCleanupMgr    g_ApplnCleanupMgr;
DWORD               g_nApplications = 0;
DWORD               g_nApplicationsRestarting = 0;
DWORD               g_nApplicationsRestarted = 0;


#define DENALI_FILE_NOTIFY_FILTER 0

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

/*===================================================================
   S c r i p t E n g i n e C l e a n u p

Node type for linked list of script engines to cleanup
===================================================================*/

struct CScriptEngineCleanupElem : CDblLink
    {
    CActiveScriptEngine *m_pEngine;
    CScriptEngineCleanupElem(CActiveScriptEngine *pEngine) : m_pEngine(pEngine)
        {
        m_pEngine->AddRef();
        }

    ~CScriptEngineCleanupElem()
        {
        m_pEngine->FinalRelease();
        }
    };

/*===================================================================
   C A p p l n V a r i a n t s
===================================================================*/

/*===================================================================
CApplnVariants::CApplnVariants

Constructor

Parameters:

Returns:
===================================================================*/
CApplnVariants::CApplnVariants()
    :
    m_cRefs(1),
    m_pAppln(NULL),
    m_ctColType(ctUnknown),
    m_ISupportErrImp(this, this, IID_IVariantDictionary)
    {
    CDispatch::Init(IID_IVariantDictionary);
    }

/*===================================================================
CApplnVariants::~CApplnVariants

Constructor

Parameters:

Returns:
===================================================================*/
CApplnVariants::~CApplnVariants()
    {
    Assert(!m_pAppln);
    }

/*===================================================================
CApplnVariants::Init

Init ApplnVariants

Parameters:
    CAppln   *pAppln            application
    CompType  ctColType         component collection type

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnVariants::Init
(
CAppln *pAppln,
CompType ctColType
)
    {
    Assert(pAppln);
    pAppln->AddRef();

    Assert(!m_pAppln);

    m_pAppln    = pAppln;
    m_ctColType = ctColType;
    return S_OK;
    }

/*===================================================================
CApplnVariants::UnInit

UnInit ApplnVariants

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnVariants::UnInit()
    {
    if (m_pAppln)
        {
        m_pAppln->Release();
        m_pAppln = NULL;
        }
    return S_OK;
    }

/*===================================================================
CApplnVariants::QueryInterface
CApplnVariants::AddRef
CApplnVariants::Release

IUnknown members for CApplnVariants object.
===================================================================*/
STDMETHODIMP CApplnVariants::QueryInterface
(
REFIID iid,
void **ppvObj
)
    {
    if (iid == IID_IUnknown || iid == IID_IDispatch ||
        iid == IID_IVariantDictionary)
        {
        AddRef();
        *ppvObj = this;
        return S_OK;
        }
    else if (iid == IID_ISupportErrorInfo)
        {
        m_ISupportErrImp.AddRef();
        *ppvObj = &m_ISupportErrImp;
        return S_OK;
        }

    *ppvObj = NULL;
    return E_NOINTERFACE;
    }

STDMETHODIMP_(ULONG) CApplnVariants::AddRef()
    {
    return InterlockedIncrement((LPLONG)&m_cRefs);
    }

STDMETHODIMP_(ULONG) CApplnVariants::Release()
    {
    if (InterlockedDecrement((LPLONG)&m_cRefs) > 0)
        return m_cRefs;

    delete this;
    return 0;
    }

/*===================================================================
CApplnVariants::ObjectNameFromVariant

Gets name from variant. Resolves operations by index.
Allocates memory for name.

Parameters:
    vKey        VARIANT
    ppwszName   [out] allocated name
    fVerify     flag - check existance if named

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnVariants::ObjectNameFromVariant
(
VARIANT &vKey,
WCHAR **ppwszName,
BOOL fVerify
)
    {
    *ppwszName = NULL;

    if (!m_pAppln->PCompCol())
        return E_FAIL;

    VARIANT *pvarKey = &vKey;
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    if (V_VT(pvarKey) != VT_BSTR && V_VT(pvarKey) != VT_I2 && V_VT(pvarKey) != VT_I4)
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &vKey, IID_IVariantDictionary, IDE_APPLICATION)))
            {
            ExceptionId(IID_IVariantDictionary, IDE_APPLICATION, IDE_EXPECTING_STR);
            VariantClear(&varKeyCopy);
            return E_FAIL;
            }
        pvarKey = &varKeyCopy;
        }

    LPWSTR pwszName = NULL;

    switch (V_VT(pvarKey))
        {
        case VT_BSTR:
            {
            pwszName = V_BSTR(pvarKey);

            if (fVerify && pwszName)
                {
                CComponentObject *pObj = NULL;

                Assert(m_pAppln);
                Assert(m_pAppln->PCompCol());

                if (m_ctColType == ctTagged)
                    m_pAppln->PCompCol()->GetTagged(pwszName, &pObj);
                else
                    m_pAppln->PCompCol()->GetProperty(pwszName, &pObj);

                if (!pObj || pObj->GetType() != m_ctColType)
                    pwszName = NULL; // as if not found
                }
            break;
            }

        case VT_I1:  case VT_I2:               case VT_I8:
        case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
        case VT_R4:  case VT_R8:
            // Coerce all integral types to VT_I4
            if (FAILED(VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
                return E_FAIL;

        // fallthru to VT_I4

        case VT_I4:
            {
            int i;
            // Look up the object by index
            i = V_I4(pvarKey);

            if (i > 0)
                {
                Assert(m_pAppln);
                Assert(m_pAppln->PCompCol());

                m_pAppln->PCompCol()->GetNameByIndex
                    (
                    m_ctColType,
                    i,
                    &pwszName
                    );
                }
            break;
            }
        }

    if (pwszName)
    {
        *ppwszName = StringDupW(pwszName);        
    }

    VariantClear(&varKeyCopy);
    return S_OK;
    
    }

/*===================================================================
CApplnVariants::get_Item

Function called from DispInvoke to get keys from the collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - integers access collection as an array
    pvarReturn    VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::get_Item
(
VARIANT varKey,
VARIANT *pVar
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    // Initialize return value
    VariantInit(pVar);

    if (!m_pAppln->PCompCol())
        return S_OK;

    // Get HitObj from Viper if Tagged Variants
    CHitObj *pHitObj = NULL;
    if (m_ctColType == ctTagged)
        {
        ViperGetHitObjFromContext(&pHitObj);
        if (!pHitObj)
            return S_OK; // return emtpy variant
        }

    m_pAppln->Lock();

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        {
        m_pAppln->UnLock();
        return hr;
        }

    // Find object by name
    CComponentObject *pObj = NULL;

    if (m_ctColType == ctTagged)
        {
        Assert(pHitObj);
        // need to go through HitObj for instantiation
        pHitObj->GetComponent(csAppln, pwszName, CbWStr(pwszName), &pObj);
        if (pObj && (pObj->GetType() != ctTagged))
            pObj = NULL;
        }
    else
        {
        m_pAppln->PCompCol()->GetProperty(pwszName, &pObj);
        }

    if (pObj)
        pObj->GetVariant(pVar);

    m_pAppln->UnLock();

    free(pwszName);
    return S_OK;
    }

/*===================================================================
CApplnVariants::put_Item

OLE automation put for Item property

Parameters:
    varKey     key
    Var        value

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::put_Item
(
VARIANT varKey,
VARIANT Var
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION,
                    IDE_CANT_MOD_STATICOBJECTS);
        return E_FAIL;
        }

    Assert(m_ctColType == ctProperty);

    if (!m_pAppln->PCompCol())
        return E_FAIL;

    m_pAppln->Lock();

    // Resolve the variant
    VARIANT varResolved;
    HRESULT hr = VariantResolveDispatch
        (
        &varResolved,
        &Var,
        IID_IApplicationObject,
        IDE_APPLICATION
        );
    if (FAILED(hr))
        {
        m_pAppln->UnLock();
        return hr;      // exception already raised
        }

    // Get name
    WCHAR *pwszName = NULL;
    hr = ObjectNameFromVariant(varKey, &pwszName);
    if (pwszName)
        {
        // Set the property
        if (m_pAppln->PCompCol())
            hr = m_pAppln->PCompCol()->AddProperty(pwszName, &varResolved);
        else
            hr = E_FAIL; // not likely if application not UnInited
        }

    VariantClear(&varResolved);
    m_pAppln->UnLock();

    if (hr == RPC_E_WRONG_THREAD)
        {
        // We use RPC_E_WRONG_THREAD to indicate bad model object
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_OBJECT);
         hr = E_FAIL;
        }

    free(pwszName);
    return hr;
    }

/*===================================================================
CApplnVariants::putref_Item

OLE automation putref for Item property

Parameters:
    varKey     key
    Var        value

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::putref_Item
(
VARIANT varKey,
VARIANT Var
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION,
                    IDE_CANT_MOD_STATICOBJECTS);
        return E_FAIL;
        }

    if (FIsIntrinsic(&Var))
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_INTRINSIC);
        return E_FAIL;
        }

    Assert(m_ctColType == ctProperty);

    if (!m_pAppln->PCompCol())
        return E_FAIL;

    m_pAppln->Lock();

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName);
    if (pwszName)
        {
        // Set the property
        if (m_pAppln->PCompCol())
            hr = m_pAppln->PCompCol()->AddProperty(pwszName, &Var);
        else
            hr = E_FAIL; // not likely if application not UnInited
        }

    m_pAppln->UnLock();

    if (hr == RPC_E_WRONG_THREAD)
        {
        // We use RPC_E_WRONG_THREAD to indicate bad model object
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_OBJECT);
         hr = E_FAIL;
        }

    if (pwszName)
        free(pwszName);
    return hr;
    }

/*===================================================================
CApplnVariants::get_Key

Function called from DispInvoke to get values from the collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - integers access collection as an array
    pvarReturn    VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::get_Key
(
VARIANT varKey,
VARIANT *pVar
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    VariantInit(pVar);

    if (!m_pAppln->PCompCol())
        return S_OK;

    m_pAppln->Lock();

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName, TRUE);

    m_pAppln->UnLock();

    if (!pwszName)
        return hr;

    // Return BSTr
    BSTR bstrT = SysAllocString(pwszName);
    free(pwszName);

    if (!bstrT)
        return E_OUTOFMEMORY;

    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = bstrT;
    return S_OK;
    }

/*===================================================================
CApplnVariants::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/
STDMETHODIMP CApplnVariants::get_Count
(
int *pcValues
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        *pcValues = m_pAppln->m_pApplCompCol->GetTaggedObjectCount();
    else
        *pcValues = m_pAppln->m_pApplCompCol->GetPropertyCount();

    return S_OK;
    }

/*===================================================================
CApplnVariants::get__NewEnum

Return a new enumerator
===================================================================*/
HRESULT CApplnVariants::get__NewEnum
(
IUnknown **ppEnumReturn
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    *ppEnumReturn = NULL;

    CVariantsIterator *pIterator = new CVariantsIterator(m_pAppln, m_ctColType);
    if (pIterator == NULL)
        {
        ExceptionId(IID_IVariantDictionary, IDE_SESSION, IDE_OOM);
        return E_OUTOFMEMORY;
        }

    *ppEnumReturn = pIterator;
    return S_OK;
    }

/*===================================================================
CApplnVariants::Remove

Remove item

Parameters:
    varKey     key

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::Remove
(
VARIANT varKey
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION,
                    IDE_CANT_MOD_STATICOBJECTS);
        return E_FAIL;
        }

    Assert(m_ctColType == ctProperty);

    m_pAppln->Lock();

    // Get name
    WCHAR *pwszName = NULL;
    ObjectNameFromVariant(varKey, &pwszName);
    if (pwszName)
        {
        CComponentCollection *pCompCol = m_pAppln->PCompCol();

        // Set the property
        if (pCompCol)
            pCompCol->RemoveProperty(pwszName);

        free(pwszName);
        }

    m_pAppln->UnLock();
    return S_OK;
    }

/*===================================================================
CApplnVariants::RemoveAll

Remove all items

Parameters:
    varKey     key

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::RemoveAll()
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION,
                    IDE_CANT_MOD_STATICOBJECTS);
        return E_FAIL;
        }

    Assert(m_ctColType == ctProperty);

    m_pAppln->Lock();

    CComponentCollection *pCompCol = m_pAppln->PCompCol();
        
    if (pCompCol)
        {
        pCompCol->RemoveAllProperties();
        }

    m_pAppln->UnLock();
    return S_OK;
    }


/*===================================================================
  C A p p l n
===================================================================*/

/*===================================================================
CAppln::CAppln

Constructor

Parameters:
    NONE

Returns:
    NONE
===================================================================*/

CAppln::CAppln()
    :
    m_fInited(FALSE),
    m_fFirstRequestRan(FALSE),
    m_fGlobalChanged(FALSE),
    m_fDeleteInProgress(FALSE),
    m_fTombstone(FALSE),
    m_fDebuggable(FALSE),
    m_fNotificationAdded(FALSE),
    m_fUseImpersonationHandle(FALSE),
    m_cRefs(1),
    m_pszMetabaseKey(NULL),
    m_pszApplnPath(NULL),
    m_pszGlobalAsa(NULL),
    m_pGlobalTemplate(NULL),
    m_cSessions(0),
    m_cRequests(0),
    m_pSessionMgr(NULL),
    m_pApplCompCol(NULL),
    m_pProperties(NULL),
    m_pTaggedObjects(NULL),
    m_pAppRoot(NULL),
    m_pActivity(NULL),
    m_dwLockThreadID(INVALID_THREADID),
    m_cLockRefCount(0),
    m_hUserImpersonation(NULL),
    m_pdispGlobTypeLibWrapper(NULL)
{
    
    // COM stuff
    m_ISuppErrImp.Init(static_cast<IApplicationObject *>(this), 
                        static_cast<IApplicationObject *>(this), 
                        IID_IApplicationObject);
    CDispatch::Init(IID_IApplicationObject);

    IF_DEBUG(APPLICATION) {
		WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);
    }
}

/*===================================================================
CAppln::~CAppln

Destructor

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CAppln::~CAppln()
    {
    Assert(m_fTombstone);  // must be tombstoned before destructor
    Assert(m_cRefs == 0);  // must have 0 ref count

    #ifdef DBG_NOTIFICATION
    DBGPRINTF((DBG_CONTEXT, "Deleting application %p\n", this));
    #endif // DBG_NOTIFICATION
    }

/*===================================================================
HRESULT CAppln::Init

Initialize object

Parameters:
    char *pszApplnKey           application's metabase key
    char *pszApplnPath          application's directory path
    CIsapiReqInfo  *pIReq       Isapi Req Info
    HANDLE hUserImpersonation   impersonation handle

Returns:
    S_OK              Success
    E_FAIL            Failure
    E_OUTOFMEMORY    Out of memory failure
===================================================================*/
HRESULT CAppln::Init
(
TCHAR *pszApplnKey,
TCHAR *pszApplnPath,
CIsapiReqInfo *pIReq,
HANDLE hUserImpersonation
)
    {
    HRESULT         hr = S_OK;
    CMBCSToWChar    convStr;

    InterlockedIncrement((LPLONG)&g_nApplications);

    Assert(pszApplnKey);
    Assert(pszApplnPath);

    void *pHashKey = NULL;
    DWORD dwHashKeyLength = 0;
    DWORD cch;

    // Debugging variables (These are placed here for possible cleanup)
    IDebugApplicationNode *pVirtualServerRoot = NULL;
    CFileNode *pFileNode = NULL;

    // Critical sections created together --
    // they are deleted in the destructor based on m_fInited flag

    ErrInitCriticalSection(&m_csInternalLock, hr);
    if (SUCCEEDED(hr))
        {
        ErrInitCriticalSection(&m_csApplnLock, hr);
        if (FAILED(hr))
            DeleteCriticalSection(&m_csInternalLock);
        }

    if (FAILED(hr))
    	{
    	DBGPRINTF((DBG_CONTEXT, "New Application Failed to acquire Critical Section, hr = %08x\n", hr));
        return hr;
        }

    // Remember (copy of) metabase key

    cch = _tcslen(pszApplnKey);
    m_pszMetabaseKey = new TCHAR[(cch+1) * sizeof(TCHAR)];
    if (!m_pszMetabaseKey)
    	goto LCleanupOOM;
    memcpy(m_pszMetabaseKey, pszApplnKey, (cch+1)*sizeof(TCHAR));

    pHashKey = m_pszMetabaseKey;
    dwHashKeyLength = cch * sizeof(TCHAR);

    // Remember (copy of) appln path
    cch = _tcslen(pszApplnPath);
    m_pszApplnPath = new TCHAR[(cch+1) * sizeof(TCHAR)];
    if (!m_pszApplnPath)
        goto LCleanupOOM;
    memcpy(m_pszApplnPath, pszApplnPath, (cch+1)*sizeof(TCHAR));

    // Get virtual path of appln & remember what it is
    TCHAR szApplnVRoot[256];
    if (FAILED(FindApplicationPath(pIReq, szApplnVRoot, sizeof szApplnVRoot)))
    	{
        DBGWARN((DBG_CONTEXT, "New Application Failed to FindApplicationPath(), hr = %#08x\n", hr));
        goto LCleanup;
        }

    if ((m_pszApplnVRoot = new TCHAR [(_tcslen(szApplnVRoot) + 1)*sizeof(TCHAR)]) == NULL)
        goto LCleanupOOM;
    _tcscpy(m_pszApplnVRoot, szApplnVRoot);

    // Initialize link element with key
    Assert(pHashKey);
    Assert(dwHashKeyLength);

    if (FAILED(CLinkElem::Init(pHashKey, dwHashKeyLength)))
    	goto LCleanupOOM;

    // Setup impersonation

    m_fNotificationAdded = FALSE;
    if (FIsWinNT() && pszApplnPath &&
        pszApplnPath[0] ==_T('\\') && pszApplnPath[1] == _T('\\'))
        {
        m_fUseImpersonationHandle = DuplicateToken
            (
            hUserImpersonation,
            SecurityImpersonation,
            &m_hUserImpersonation
            );
        }

    m_cSessions = 0;
    m_cRequests = 0;

    // Create and init app config
    m_pAppConfig = new CAppConfig();
    if (!m_pAppConfig)
		goto LCleanupOOM;

    hr = m_pAppConfig->Init(pIReq, this);
    if (FAILED(hr))
        {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init the AppConfig, hr = %#08x\n", hr));
        goto LCleanup;
        }

    // Create and init application level component collection
    m_pApplCompCol = new CComponentCollection;
    if (!m_pApplCompCol)
        goto LCleanupOOM;

    hr = m_pApplCompCol->Init(csAppln);
    if (FAILED(hr))
        {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init the Component Collection, hr = %#08x\n", hr));
        goto LCleanup;
        }

    // initialize application properties collection
    m_pProperties = new CApplnVariants;
    if (!m_pProperties)
        goto LCleanupOOM;
    hr = m_pProperties->Init(this, ctProperty);
    if (FAILED(hr))
        {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init the Application Properties, hr = %#08x\n", hr));
        goto LCleanup;
        }

    // initialize application tagged object collection
    m_pTaggedObjects = new CApplnVariants;
    if (!m_pTaggedObjects)
        goto LCleanupOOM;
    hr = m_pTaggedObjects->Init(this, ctTagged);
    if (FAILED(hr))
        {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init the Application Tagged Objects, hr = %#08x\n", hr));
        goto LCleanup;
        }

    // Debugging support  - Create an application node
    // If PDM does not exist it means debugger not installed or it's Win 95
    //
    if (g_pPDM)
        {
        // Debugging directories are shown as:
        //
        //      <virtual web server>
        //         <application name>
        //              <path to ASP>
        //
        // Get a pointer to the document node containing the virtual web server.
        if (FAILED(hr = GetServerDebugRoot(pIReq, &pVirtualServerRoot)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Could not GetServerDebugRoot(), hr = %#08x\n", hr));
            goto LCleanup;
            }

        // Create a node for this application
        if (FAILED(hr = g_pDebugApp->CreateApplicationNode(&m_pAppRoot)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Could not CreateApplicationNode(), hr = %#08x\n", hr));
            goto LCleanup;
            }

        // Create a doc provider for the node
        if ((pFileNode = new CFileNode) == NULL)
            goto LCleanupOOM;

        // Name the application
        TCHAR szDebugApp[256];
        TCHAR *pchEnd = strcpyEx(szDebugApp, m_pszApplnVRoot);
        if (! QueryAppConfig()->fAllowDebugging()) {
#if UNICODE
            CwchLoadStringOfId(
#else
            CchLoadStringOfId(
#endif
            IDS_DEBUGGING_DISABLED, pchEnd, DIFF(&szDebugApp[sizeof (szDebugApp)/sizeof(TCHAR)] - pchEnd));
            m_fDebuggable = FALSE;
        }
        else
            m_fDebuggable = TRUE;
        Assert (_tcslen(szDebugApp) < (sizeof(szDebugApp)/sizeof(TCHAR)));

        WCHAR   *pswzDebugApp;
#if UNICODE
        pswzDebugApp = szDebugApp;
#else
        if (FAILED(hr = convStr.Init(szDebugApp))) {
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Cannot convert szDebugApp to UNICODE, hr = %#08x\n", hr));
            goto LCleanup;
        }
        pswzDebugApp = convStr.GetString();
#endif

        if (FAILED(hr = pFileNode->Init(pswzDebugApp)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Cannot Init CFileNode, hr = %#08x\n", hr));
            goto LCleanup;
            }

        if (FAILED(hr = m_pAppRoot->SetDocumentProvider(pFileNode)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: SetDocumentProvider failed, hr = %#08x\n", hr));
            goto LCleanup;
            }

        // Attach to the UI
        if (FAILED(hr = m_pAppRoot->Attach(pVirtualServerRoot)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Attach to debugger, hr = %#08x\n", hr));
            goto LCleanup;
            }

        // If this application had a previous incarnation (changed global.asa
        // or debugging being flipped on in midstream), then there may be some
        // documents in the cache which should be added to the debugger now.
        if (m_fDebuggable)
            {
            g_TemplateCache.AddApplicationToDebuggerUI(this);

            // In DEBUG mode: all requests run on the same thread
            if (FAILED(hr = BindToActivity(g_pDebugActivity)))
				{
				DBGWARN((DBG_CONTEXT, "New Application Failed: Could not bind application to debugging activity, hr = %#08x\n", hr));
				goto LCleanup;
				}
            }
        }

    // For Win95: all requests run on the same thread

    if (!FIsWinNT())
        {
        if (FAILED(hr = BindToActivity()))
			{
			DBGWARN((DBG_CONTEXT, "New Application Failed: Could not bind application to Win95 activity, hr = %#08x\n", hr));
			goto LCleanup;
			}
        }

    // Create and init session manager
    m_pSessionMgr = new CSessionMgr;
    if (!m_pSessionMgr)
        goto LCleanupOOM;

    hr = m_pSessionMgr->Init(this);
    if (FAILED(hr))
		{
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init session manager, hr = %#08x\n", hr));
		goto LCleanup;
		}

LCleanup:
    // Release interfaces
    if (pFileNode)
        pFileNode->Release();

    if (pVirtualServerRoot)
        pVirtualServerRoot->Release();

    if (SUCCEEDED(hr))
        m_fInited = TRUE;

    return hr;

LCleanupOOM:
	hr = E_OUTOFMEMORY;
	DBGERROR((DBG_CONTEXT, "New Application Failed: E_OUTOFMEMORY\n"));
	goto LCleanup;
    }


/*===================================================================
CAppln::Restart

Restart an application. (used for when global.asa changes or
debugging enable metabase key changes)
===================================================================*/
HRESULT CAppln::Restart(BOOL  fForceRestart /* = FALSE*/)
    {
    AddRef();  // keep addref'd while restarting
    g_ApplnMgr.Lock();

    // If   already restarted or
    //      in the tombstone state or
    //      restart not allowed
    //      shutting down -> don't restart
    if (m_fGlobalChanged || 
        m_fTombstone || 
        (!m_pAppConfig->fEnableApplicationRestart() && !fForceRestart) ||
        IsShutDownInProgress())
        {
        // Give back the lock and refcount
        // since we don't need them
        g_ApplnMgr.UnLock();
        Release();
        return S_OK;
        }

    // Indicate to Delete All Sessions
    m_fGlobalChanged = TRUE;

    // Increment the count of restarting applications
    InterlockedIncrement((LPLONG)&g_nApplicationsRestarting);

    // Increment the count of restarted applications
    InterlockedIncrement((LPLONG)&g_nApplicationsRestarted);

    m_pSessionMgr->UnScheduleSessionKiller();

    // cleanup the directory monitor entries

    if (FIsWinNT())
        {
        while ((m_rgpvDME).Count())
            {
            static_cast<CDirMonitorEntry *>(m_rgpvDME[0])->Release();
            (m_rgpvDME).Remove(0);
            }
        m_rgpvDME.Clear();
        }

    // remove the application from the global hash

    CLinkElem *pLinkElem = g_ApplnMgr.DeleteElem
        (
        m_pszMetabaseKey,
        _tcslen(m_pszMetabaseKey) * sizeof(TCHAR)
        );
    Assert(pLinkElem);
    Assert(static_cast<CAppln *>(pLinkElem) == this);

    // Unlock
    g_ApplnMgr.UnLock();

    // add this application to the CleanupManager...
#if 0
    g_ApplnCleanupMgr.AddAppln(this);
#else
    ApplnCleanupProc();
#endif

    return S_OK;
}

/*===================================================================
CAppln::ApplnCleanupProc

Called by the g_ApplnCleanupMgr thread to complete cleanup

===================================================================*/
HRESULT CAppln::ApplnCleanupProc()
{

    // Let the requests to drain while trying to delete sessions
    while (!IsShutDownInProgress() && (m_cRequests || m_cSessions))
        {
        if (m_cSessions)
            m_pSessionMgr->DeleteAllSessions(FALSE);

        if (m_cSessions || m_cRequests)
            Sleep(200);
        }

    // Re-lock
    g_ApplnMgr.Lock();

    g_ApplnMgr.DeleteApplicationIfExpired(this);

    // Decrement the count of restarting applications
    InterlockedDecrement((LPLONG)&g_nApplicationsRestarting);

    g_ApplnMgr.UnLock();
    Release();

    return S_OK;
    }

/*===================================================================
CAppln::UnInit

Convert to tombstone state

Parameters:
    NONE

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CAppln::UnInit()
    {
    Assert(!m_fTombstone);  // don't do it twice

#ifdef DBG_NOTIFICATION
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "Uniniting  application %S, %p\n", m_pszApplnPath, this));
#else
    DBGPRINTF((DBG_CONTEXT, "Uniniting  application %s, %p\n", m_pszApplnPath, this));
#endif
#endif // DBG_NOTIFICATION

    // Flush the global.asa from the script engine cache
    if (m_pszGlobalAsa)
        {
        g_ScriptManager.FlushCache(m_pszGlobalAsa);
        }

    if (m_pGlobalTemplate)
        {
        // Keep template (and inc file) cache locked while releasing
        // GLOBAL.ASA template so that it wouldn't step onto Flush logic
        //
        // NOTE: CTemplate::End potentially queues global.asa for cleanup on
        //       our thread!  CleanupEngines() must therefore be called
        //       *after* this step.
        //
        LockTemplateAndIncFileCaches();
        m_pGlobalTemplate->End();
        UnLockTemplateAndIncFileCaches();

        m_pGlobalTemplate = NULL;
        }

    //If NT, remove this app from any file/appln mappings it may be in
    if (FIsWinNT())
        {
        g_FileAppMap.Lock();
        int i = m_rgpvFileAppln.Count();
        while (i > 0)
            {

            #ifdef DBG_NOTIFICATION
            DBGPRINTF((DBG_CONTEXT, "Removing application from File/App mapping\n"));
            #endif // DBG_NOTIFICATION

            static_cast<CFileApplnList *>(m_rgpvFileAppln[0])->RemoveApplication(this);
            m_rgpvFileAppln.Remove(0);
            i--;
            }
        g_FileAppMap.UnLock();
        m_rgpvFileAppln.Clear();

        m_rgpvDME.Clear();

        // If debuggable application, clean up pending scripts
        if (m_fDebuggable)
            g_ApplnMgr.CleanupEngines();
        }

    // Free the properties collection
    if (m_pProperties)
        {
        m_pProperties->UnInit();
        m_pProperties->Release();
        m_pProperties = NULL;
        }

    // Free the tagged objects collection
    if (m_pTaggedObjects)
        {
        m_pTaggedObjects->UnInit();
        m_pTaggedObjects->Release();
        m_pTaggedObjects = NULL;
        }

    // Before we close down, debuggable templates need to be made non-debuggable
    if (m_fDebuggable)
        g_TemplateCache.RemoveApplicationFromDebuggerUI(this);

    if (m_pAppRoot)
        {
        m_pAppRoot->Detach();
        m_pAppRoot->Close();
        m_pAppRoot->Release();
        m_pAppRoot = NULL;
        }

    if (m_pApplCompCol)
        {
        delete m_pApplCompCol;
        m_pApplCompCol = NULL;
        }

    if (m_pActivity)
        {
        delete m_pActivity;
        m_pActivity = NULL;
        }

    if (m_pSessionMgr)
        {
        delete m_pSessionMgr;
        m_pSessionMgr = NULL;
        }

    if (m_pAppConfig)
        {
        /*
         * BUG 89144: Uninit AppConfig but do it from the MTA
         * When AppConfig is inited, it is done on a WAM thread.  WAM
         * threads are MTA threads.  At that time we register an event
         * sink to get Metabase change notifications.  Now, during shutdown,
         * we are running on an ASP worker thread, which is an STA thread.
         * That means we will get an RPC_E_WRONGTHREAD error shutting down.  The
         * fix is to make the uninit call happen on an MTA thread.
         */
        HRESULT hr;
        HRESULT AppConfigUnInit(void *pV1, void *pV2);

		HANDLE hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        hr = CallMTACallback
            (
            AppConfigUnInit,
            m_pAppConfig,
            hCompletionEvent
            );
        Assert(SUCCEEDED(hr));
		WaitForSingleObject(hCompletionEvent, INFINITE);

		CloseHandle(hCompletionEvent);
        delete m_pAppConfig;
        m_pAppConfig = NULL;
        }

    if (m_pdispGlobTypeLibWrapper)
        {
        m_pdispGlobTypeLibWrapper->Release();
        m_pdispGlobTypeLibWrapper = NULL;
        }

    if (m_pszGlobalAsa)
        {
        // If there was a change notification on global.asa
        // then flush the template now.
        // UNDONE: flush correct global.asa
        if (m_fGlobalChanged)
            g_TemplateCache.Flush(m_pszGlobalAsa, MATCH_ALL_INSTANCE_IDS);

        delete [] m_pszGlobalAsa;
        m_pszGlobalAsa = NULL;
        }

    if (m_pszMetabaseKey)
        {
        delete [] m_pszMetabaseKey;
        m_pszMetabaseKey = NULL;
        }

    if (m_pszApplnPath)
        {
        delete [] m_pszApplnPath;
        m_pszApplnPath = NULL;
        }

    if (m_pszApplnVRoot)
        {
        delete [] m_pszApplnVRoot;
        m_pszApplnVRoot = NULL;
        }

    if (FIsWinNT() && m_fUseImpersonationHandle)
        {
        CloseHandle(m_hUserImpersonation);
        m_hUserImpersonation = NULL;
        }

    if (m_fInited)
        {
        DeleteCriticalSection(&m_csInternalLock);
        DeleteCriticalSection(&m_csApplnLock);
        }

    // Mark this application as Tombstone

    m_fTombstone = TRUE;

    InterlockedDecrement((LPLONG)&g_nApplications);

	// Disconnennect from proxies (in case we are shutting down or will shortly shut down)

	CoDisconnectObject(static_cast<IApplicationObject *>(this), 0);

    return S_OK;
    }

/*===================================================================
CAppln::BindToActivity

Creates application level activity either
    as a clone of the given activity or
    as a brand new activity

Must be called within critical section. Does not lock itself.

Parameters:
    CViperActivity *pActivity       activity to clone (could be NULL)

Returns:
    NONE
===================================================================*/
HRESULT CAppln::BindToActivity
(
CViperActivity *pActivity
)
    {
    if (m_pActivity)
        {
        // multiple requests to bind to new activity are ok
        if (!pActivity)
            return S_OK;
        // but not to clone from an existing activity
        Assert(FALSE);
        return E_FAIL;
        }

    m_pActivity = new CViperActivity;
    if (!m_pActivity)
        return E_OUTOFMEMORY;

    HRESULT hr;

    if (pActivity)
        hr = m_pActivity->InitClone(pActivity);
    else
        hr = m_pActivity->Init(QueryAppConfig()->fExecuteInMTA());

    if (FAILED(hr))
        {
        delete m_pActivity;
        m_pActivity = NULL;
        }

    return hr;
    }

/*===================================================================
CAppln::SetGlobalAsa

Remembers GLOBAL.ASA file path for this application

Parameters:
    const char *pszGlobalAsa    path to (copy and) remember

Returns:
    HRESULT
===================================================================*/
HRESULT CAppln::SetGlobalAsa
(
const TCHAR *pszGlobalAsa
)
    {
    // remove existing
    if (m_pszGlobalAsa)
        {
        delete [] m_pszGlobalAsa;
        m_pszGlobalAsa = NULL;
        }

    // store new
    if (pszGlobalAsa)
        {
        DWORD cch = _tcslen(pszGlobalAsa);
        DWORD cb = (cch + 1) * sizeof(TCHAR);

        m_pszGlobalAsa = new TCHAR[cch+1];
        if (!m_pszGlobalAsa)
            return E_OUTOFMEMORY;

        memcpy(m_pszGlobalAsa, pszGlobalAsa, cb);
        }

    return S_OK;
    }

/*===================================================================
CAppln::AddDirMonitorEntry

Remembers change notifcation monitor entries for this application

Parameters:
    pDirMonitorEntry    pointer to DME

Returns:
    S_OK if the monitor entry was added to the list
===================================================================*/
HRESULT CAppln::AddDirMonitorEntry(CDirMonitorEntry *pDirMonitorEntry)
    {
    DBG_ASSERT(m_fInited);
    DBG_ASSERT(pDirMonitorEntry);

    HRESULT hr = S_OK;

   // Add the DME to the list
   if (FAILED(hr = m_rgpvDME.Append(pDirMonitorEntry)))
        {
        pDirMonitorEntry->Release();
        }
    return hr;

    }

/*===================================================================
CAppln::AddFileApplnEntry

Remembers change notifcation monitor entries for this application

Parameters:
    pFileAppln    pointer to FileApplnEntry

Returns:
    S_OK if the monitor entry was added to the list
    S_FALSE if the monitor entry was alread in the list
===================================================================*/
HRESULT CAppln::AddFileApplnEntry(CFileApplnList *pFileAppln)
    {
    DBG_ASSERT(m_fInited);
    DBG_ASSERT(pFileAppln);

    HRESULT hr = S_OK;
    int index;

    // See if the file/application entry is alreay in the list
    hr = m_rgpvFileAppln.Find(pFileAppln, &index);
    if (hr == S_FALSE)
        {
       // Add the file/application entry to the list
       hr = m_rgpvFileAppln.Append(pFileAppln);
        }
    else
        {
        // The file/application entry was already in the list
        hr = S_FALSE;
        }
    return hr;

    }

/*===================================================================
CAppln::QueryInterface

QueryInterface() -- IApplicationObject implementation.

Parameters:
    REFIID riid
    void **ppv

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CAppln::QueryInterface
(
REFIID riid,
void **ppv
)
    {
    *ppv = NULL;

    if (IID_IUnknown           == riid ||
        IID_IDispatch          == riid ||
        IID_IApplicationObject == riid ||
        IID_IDenaliIntrinsic   == riid)
        {
        *ppv = static_cast<IApplicationObject *>(this);
        }
    else if (IID_ISupportErrorInfo == riid)
        {
        *ppv = &m_ISuppErrImp;
        }
    else if (IID_IMarshal == riid)
        {
        *ppv = static_cast<IMarshal *>(this); 
        }
    if (*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }

/*===================================================================
CAppln::AddRef

AddRef() -- IUnknown implementation.

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CAppln::AddRef() {
    DWORD cRefs = InterlockedIncrement((LPLONG)&m_cRefs);
    IF_DEBUG(APPLICATION) {
		WriteRefTraceLog(gm_pTraceLog, cRefs, this);
    }
    return cRefs;
}

/*===================================================================
CAppln::Release

Release() -- IUnknown implementation.

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CAppln::Release()
    {
    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
    IF_DEBUG(APPLICATION) {
		WriteRefTraceLog(gm_pTraceLog, cRefs, this);
    }
    if (cRefs)
        return cRefs;

    delete this;
    return 0;
    }

/*===================================================================
CAppln::CheckForTombstone

Tombstone stub for IApplicationObject methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:

Returns:
    HRESULT     E_FAIL  if Tombstone
                S_OK if not
===================================================================*/
HRESULT CAppln::CheckForTombstone()
    {
    if (!m_fTombstone)
        return S_OK;

    ExceptionId
        (
        IID_IApplicationObject,
        IDE_APPLICATION,
        IDE_INTRINSIC_OUT_OF_SCOPE
        );
    return E_FAIL;
    }
/*===================================================================
CAppln::Lock

IApplicationObject method.

Will allow the user to lock the application intrinsic for the
purpose of adding/deleting values.

Parameters:
    NONE

Returns:
    HRESULT        S_OK on success
                E_FAIL otherwise
===================================================================*/
STDMETHODIMP CAppln::Lock()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    Assert(m_fInited);

    DWORD dwId = GetCurrentThreadId();

    // If this thread already has the lock, increment lock ref count

    if (m_dwLockThreadID == dwId)
        {
        m_cLockRefCount++;
        }
    else
        {
        EnterCriticalSection(&m_csApplnLock);
        m_cLockRefCount = 1;
        m_dwLockThreadID = dwId;
        }

    return S_OK;
    }

/*===================================================================
CAppln::UnLock

IApplicationObject method.

Will allow the user to unlock the application intrinsic only
if it has been locked by this user.

Parameters:
    NONE

Returns:
    HRESULT        S_OK
===================================================================*/
STDMETHODIMP CAppln::UnLock()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (m_dwLockThreadID == GetCurrentThreadId())
        {
        if (--m_cLockRefCount == 0)
            {
            // Unlock the application
            m_dwLockThreadID = INVALID_THREADID;
            LeaveCriticalSection(&m_csApplnLock);
            }
        }

    return S_OK;
    }

/*===================================================================
CAppln::UnLockAfterRequest

Remove any application locks left by the user script

Parameters:
    NONE

Returns:
    HRESULT        S_OK
===================================================================*/
HRESULT CAppln::UnLockAfterRequest()
    {
    Assert(!m_fTombstone);

    if (m_cLockRefCount > 0 && m_dwLockThreadID == GetCurrentThreadId())
        {
        m_cLockRefCount = 0;
        m_dwLockThreadID = INVALID_THREADID;
        LeaveCriticalSection(&m_csApplnLock);
        }
    return S_OK;
    }

/*===================================================================
CAppln::get_Value

IApplicationObject method.

Will allow the user to retreive a application state variable,
the variable will come as a named pair, bstr is the name and
var is the value or object to be returned for that name

Parameters:
    BSTR FAR *     bstrName    Name of the variable to get
    VARIANT *    pVar         Value/object to get for the variable

Returns:
    HRESULT        S_OK on success
===================================================================*/
STDMETHODIMP CAppln::get_Value
(
BSTR bstrName,
VARIANT *pVar
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (bstrName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    VariantInit(pVar); // default variant empty

    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);

    if (pwszName == NULL)
        return S_OK; // no name - no value - no error
    //_wcsupr(pwszName);

    Assert(m_pApplCompCol);

    HRESULT           hr   = S_OK;
    CComponentObject *pObj = NULL;

    // Lock the application
    Lock();

    hr = m_pApplCompCol->GetProperty(pwszName, &pObj);

    if (SUCCEEDED(hr))
        {
        Assert(pObj);
        hr = pObj->GetVariant(pVar);
        }

    // UnLock the application
    UnLock();

    return S_OK;
    }

/*===================================================================
CAppln::putref_Value

IApplicationObject method.

Will allow the user to assign a application state variable to be saved
the variable will come as a named pair, bstr is the name and
var is the value or object to be stored for that name

Parameters:
    BSTR     bstrName    Name of the variable to set
    VARIANT Var            Value/object to set for the variable

Returns:
    HRESULT        S_OK on success
===================================================================*/
STDMETHODIMP CAppln::putref_Value
(
BSTR bstrName,
VARIANT Var
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FIsIntrinsic(&Var))
        {
        ExceptionId(IID_IApplicationObject, IDE_APPLICATION,
                    IDE_APPLICATION_CANT_STORE_INTRINSIC);
        return E_FAIL;
        }

    if (bstrName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    HRESULT hr;

    Assert(m_pApplCompCol);

    // Prepare property name
    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);

    if (pwszName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }
    //_wcsupr(pwszName);

    // Lock the application
    Lock();

    hr = m_pApplCompCol->AddProperty(pwszName, &Var);

    // Unlock the application
    UnLock();

    if (hr == RPC_E_WRONG_THREAD)
        {
        // We use RPC_E_WRONG_THREAD to indicate bad model object
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_OBJECT);
         hr = E_FAIL;
        }

    return hr;
    }

/*===================================================================
CAppln::put_Value

IApplicationObject method.

Implement property put by dereferencing variants before
calling putref.

Parameters:
    BSTR FAR *     bstrName    Name of the variable to set
    VARIANT     Var            Value/object to set for the variable

Returns:
    HRESULT        S_OK on success
===================================================================*/
STDMETHODIMP CAppln::put_Value
(
BSTR bstrName,
VARIANT Var
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (bstrName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    HRESULT hr;

    Assert(m_pApplCompCol);

    // Prepare property name
    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);

    if (pwszName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }
    //_wcsupr(pwszName);

    // Lock the application
    Lock();

    VARIANT varResolved;
    hr = VariantResolveDispatch(&varResolved, &Var,
                                IID_IApplicationObject,
                                IDE_APPLICATION);
    if (SUCCEEDED(hr))
        {
        hr = m_pApplCompCol->AddProperty(pwszName, &varResolved);
        VariantClear(&varResolved);
        }

    // Unlock the application
    UnLock();

    if (hr == RPC_E_WRONG_THREAD)
        {
        // We use RPC_E_WRONG_THREAD to indicate bad model object
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_OBJECT);
         hr = E_FAIL;
        }

    return hr;
    }

/*===================================================================
CAppln::get_Contents

Return the application contents dictionary
===================================================================*/

STDMETHODIMP CAppln::get_Contents(IVariantDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()) || !m_pProperties)
        return E_FAIL;

    return m_pProperties->QueryInterface(IID_IVariantDictionary, reinterpret_cast<void **>(ppDictReturn));
    }

/*===================================================================
CAppln::get_StaticObjects

Return the application static objects dictionary
===================================================================*/
STDMETHODIMP CAppln::get_StaticObjects(IVariantDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()) || !m_pTaggedObjects)
        return E_FAIL;

    return m_pTaggedObjects->QueryInterface(IID_IVariantDictionary, reinterpret_cast<void **>(ppDictReturn));
    }

/*===================================================================
CAppln::UpdateConfig

Updates configuration from metabase if needed
===================================================================*/
HRESULT CAppln::UpdateConfig(CIsapiReqInfo  *pIReq, BOOL *pfRestart, BOOL *pfFlushAll)
    {
    BOOL fRestart = FALSE;
    BOOL fFlushAll = FALSE;

    if (m_pAppConfig->fNeedUpdate())
        {
        InternalLock();

        if (m_pAppConfig->fNeedUpdate()) // still need update?
            {
            BOOL fAllowedDebugging   = m_pAppConfig->fAllowDebugging();
            BOOL fAllowedClientDebug = m_pAppConfig->fAllowClientDebug();
            BOOL fAllowedRestart     = m_pAppConfig->fEnableApplicationRestart();
            BOOL fParentPathsEnabled = m_pAppConfig->fEnableParentPaths();
            UINT uLastCodePage       = m_pAppConfig->uCodePage();
            LCID uLastLCID           = m_pAppConfig->uLCID();

            BOOL fRestartEnabledUpdated = m_pAppConfig->fRestartEnabledUpdated();
			char szLastDefaultEngine[64];
			strncpy(szLastDefaultEngine, m_pAppConfig->szScriptLanguage(), sizeof szLastDefaultEngine);
			szLastDefaultEngine[sizeof(szLastDefaultEngine) - 1] = '\0';

            m_pAppConfig->Update(pIReq);

            BOOL fAllowDebugging     = m_pAppConfig->fAllowDebugging();
            BOOL fAllowClientDebug   = m_pAppConfig->fAllowClientDebug();
            BOOL fAllowRestart       = m_pAppConfig->fEnableApplicationRestart();
            BOOL fEnableParentPaths  = m_pAppConfig->fEnableParentPaths();
            UINT uCodePage           = m_pAppConfig->uCodePage();
            LCID uLCID               = m_pAppConfig->uLCID();

			const char *szNewDefaultEngine = m_pAppConfig->szScriptLanguage();

            fFlushAll = strcmpi(szLastDefaultEngine, szNewDefaultEngine) != 0
                        || (fParentPathsEnabled != fEnableParentPaths)
                        || (uLastCodePage != uCodePage)
                        || (uLastLCID != uLCID);
            
            fRestart = (fAllowDebugging != fAllowedDebugging) ||
                       (fAllowClientDebug != fAllowedClientDebug) ||
                       ((fAllowRestart  != fAllowedRestart) && fAllowRestart) ||
                       ((fAllowRestart == fAllowedRestart) && fRestartEnabledUpdated) ||
                       fFlushAll;
            }

        InternalUnLock();
        }

    if (pfRestart)
        *pfRestart = fRestart;

    if (pfFlushAll)
        *pfFlushAll = fFlushAll;

    return S_OK;
    }

/*===================================================================
CAppln::FPathMonitored()

Checks the list of DMEs in application to see if the specified path
is already being monitored.

===================================================================*/
CASPDirMonitorEntry  *CAppln::FPathMonitored(LPCTSTR  pszPath)
{
    int cDMEs = m_rgpvDME.Count();
    int i;

    for (i=0; i < cDMEs; i++) {
        CASPDirMonitorEntry  *pDME = static_cast<CASPDirMonitorEntry *>(m_rgpvDME[i]);
        if (pDME == NULL)
            break;
        if (pDME->FPathMonitored(pszPath))
            return pDME;
    }

    return NULL;
}

#ifdef DBG
/*===================================================================
CAppln::AssertValid

Test to make sure that the CAppln object is currently correctly
formed and assert if it is not.

Returns:
    Nothing

Side effects:
    None.
===================================================================*/
void CAppln::AssertValid() const
    {
    Assert(m_fInited);

    Assert(m_pSessionMgr);

    Assert(m_pApplCompCol);
    m_pApplCompCol->AssertValid();
    }
#endif // DBG


/*===================================================================
  C  A p p l n  M g r
===================================================================*/

/*===================================================================
CApplnMgr::CApplnMgr

Application Manager constructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CApplnMgr::CApplnMgr()
    : m_fInited(FALSE),
      m_fHashTableInited(FALSE), m_fCriticalSectionInited(FALSE),
      m_hDeleteApplnEvent(INVALID_HANDLE_VALUE)
    {
    }

/*===================================================================
CApplnMgr::~CApplnMgr

Application Manager destructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CApplnMgr::~CApplnMgr()
    {
    if (!m_fInited)
        UnInit();
    }

/*===================================================================
HRESULT CApplnMgr::Init

Initializes the Appln Manager.

Parameters:
    NONE

Returns:
    S_OK            Success
    E_FAIL            Failure
    E_OUTOFMEMORY    Out of memory
===================================================================*/
HRESULT CApplnMgr::Init( void )
    {
    HRESULT hr = S_OK;

    Assert(!m_fInited);

    // Create delete app event

    m_hDeleteApplnEvent = IIS_CREATE_EVENT(
                              "CApplnMgr::m_hDeleteApplnEvent",
                              this,
                              FALSE,
                              FALSE
                              );

    if (!m_hDeleteApplnEvent)
        return E_FAIL;

    // Init hash table

    hr = CHashTable::Init(NUM_APPLMGR_HASHING_BUCKETS);
    if (FAILED(hr))
        return hr;
    m_fHashTableInited = TRUE;

    // Init critical section

    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
        return(hr);
    m_fCriticalSectionInited = TRUE;

    m_fInited = TRUE;

    return g_ApplnCleanupMgr.Init();
    }

/*===================================================================
HRESULT CApplnMgr::UnInit

UnInitializes the Appln Manager.

Parameters:
    NONE

Returns:
    S_OK        Success
    E_FAIL        Failure
===================================================================*/
HRESULT CApplnMgr::UnInit( void )
    {
    if (m_hDeleteApplnEvent != INVALID_HANDLE_VALUE)
        {
        CloseHandle(m_hDeleteApplnEvent);
        m_hDeleteApplnEvent = INVALID_HANDLE_VALUE;
        }

    if (m_fHashTableInited)
        {
        CHashTable::UnInit();
        m_fHashTableInited = FALSE;
        }

    if (m_fCriticalSectionInited)
        {
        DeleteCriticalSection(&m_csLock);
        m_fCriticalSectionInited = FALSE;
        }

    m_fInited = FALSE;
    return g_ApplnCleanupMgr.UnInit();
    }

/*===================================================================
CApplnMgr::AddAppln

Adds a CAppln element to link list / hash table.
User has to check if Appln already exists before calling this.
Critical sectioning is in CHitObj::BrowserRequestInit().

Parameters:
    char   *pszApplnKey         Application metabase key
    char   *pszApplnPath        Application directory path
    CIsapiReqInfo   *pIReq
    HANDLE  hUserImpersonation  impersonation handle

    CAppln **ppAppln            [out] Application created

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnMgr::AddAppln
(
TCHAR    *pszApplnKey,
TCHAR    *pszApplnPath,
CIsapiReqInfo   *pIReq,
HANDLE   hUserImpersonation,
CAppln **ppAppln
)
    {
    *ppAppln = NULL;   // return NULL if failed

    // Create CAppln object

    CAppln *pAppln = new CAppln;

    if (!pAppln)
        return E_OUTOFMEMORY;

    // Init CAppln object

    HRESULT hr;

    hr = pAppln->Init
        (
        pszApplnKey,
        pszApplnPath,
        pIReq,
        hUserImpersonation
        );

    if (FAILED(hr))
        {
        pAppln->UnInit();
        pAppln->Release();
        return hr;
        }

    // Add to hash table

    if (!CHashTable::AddElem(pAppln))
        {
        pAppln->UnInit();
        pAppln->Release();
        return E_FAIL;
        }

    *ppAppln = pAppln;
    return S_OK;
    }

/*===================================================================
CApplnMgr::FindAppln

Finds CAppln in hash table
Critical sectioning must be done outside

Parameters:
    char   *pszApplnKey         Application metabase key
    CAppln **ppAppln            [out] Application found

Returns:
    S_OK            if found
    S_FALSE         if not found
===================================================================*/
HRESULT CApplnMgr::FindAppln
(
TCHAR *pszApplnKey,
CAppln **ppAppln
)
    {
    CLinkElem *pLinkElem = CHashTable::FindElem
        (
        pszApplnKey,
        _tcslen(pszApplnKey)*sizeof(TCHAR)
        );

    if (!pLinkElem)
        {
        *ppAppln = NULL;
        return S_FALSE;
        }

    *ppAppln = static_cast<CAppln *>(pLinkElem);
    return S_OK;
    }

/*===================================================================
CApplnMgr::AddEngine

When a change notification occurs for a file being debugged,
we need to delete its associated scripting engine.  The naive
approach of Releasing the engine during notification won't work
because the engine is on the wrong thread.  Instead of marshaling
to the thread (which raises possibilities of deadlock or starving
the notification thread if debugging is happening on the debug
thread), the engines are added to a queue in the application.
When a request is serviced for debugging (which is now in the
correct thread context), the application object first flushes
this list by releasing the engines
===================================================================*/
HRESULT CApplnMgr::AddEngine(CActiveScriptEngine *pEngine)
    {
    CScriptEngineCleanupElem *pScriptElem = new CScriptEngineCleanupElem(pEngine);
    if (pScriptElem == NULL)
        return E_OUTOFMEMORY;

    pScriptElem->AppendTo(m_listEngineCleanup);
    return S_OK;
    }

/*===================================================================
CApplnMgr::CleanupEngines()

Call Release all engine cleanup list.
===================================================================*/
void CApplnMgr::CleanupEngines()
    {
    while (! m_listEngineCleanup.FIsEmpty())
        delete m_listEngineCleanup.PNext();
    }


/*===================================================================
CApplnMgr::DeleteApplicationIfExpired

Removes CAppln object if exprired
Critical sectioning must be done outside

Parameters:
    CAppln *pAppln      application to delete

Returns:
    NONE
===================================================================*/
HRESULT CApplnMgr::DeleteApplicationIfExpired
(
CAppln *pAppln
)
    {
    if (!pAppln->m_fGlobalChanged)
        return S_OK;

    if (pAppln->m_cSessions || pAppln->m_cRequests)
        return S_OK;

    if (pAppln->m_fDeleteInProgress)
        return S_OK;

    pAppln->m_fDeleteInProgress = TRUE;

    HRESULT hr = S_OK;

    // Queue it up for deletion
    CHitObj *pHitObj = new CHitObj;
    if (!pHitObj)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        {
        pHitObj->ApplicationCleanupInit(pAppln);

        // Ask Viper to queue this request
        hr = pHitObj->PostViperAsyncCall();
        }

    // cleanup
    if (FAILED(hr) && pHitObj)
        delete pHitObj;

    return hr;
    }

/*===================================================================
CApplnMgr::DeleteAllApplications

Removes CAppln objects from the application manager link list
and hash table.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnMgr::DeleteAllApplications()
    {
    HRESULT hr = S_OK;

    Lock();

    CLinkElem *pLink = CHashTable::Head();
    CHashTable::ReInit();

    while (pLink)
        {
        CAppln *pAppln = static_cast<CAppln *>(pLink);
        pLink = pLink->m_pNext;

        if (pAppln->m_fDeleteInProgress)
            continue;

        pAppln->m_fDeleteInProgress = TRUE;


        // Queue it up for deletion
        CHitObj *pHitObj = new CHitObj;
        if (!pHitObj)
            {
            hr = E_OUTOFMEMORY;
            break;
            }

        // If NT, Unregister for notifications
        if (FIsWinNT())
            {
            while ((pAppln->m_rgpvDME).Count())
                {
                static_cast<CDirMonitorEntry *>(pAppln->m_rgpvDME[0])->Release();
                (pAppln->m_rgpvDME).Remove(0);
                }
            pAppln->m_rgpvDME.Clear();
            }

        pHitObj->ApplicationCleanupInit(pAppln);

        // Ask Viper to queue this request
        hr = pHitObj->PostViperAsyncCall();
        if (FAILED(hr))
            {
            delete pHitObj;
            break;
            }

        }

    UnLock();
    return hr;
    }

/*===================================================================
CApplnMgr::RestartAllChagnedApplications

Restarts CAppln objects from the application manager link list
We walk the list recording which applications are dependent
on files that have changed since they were compiled. Once we
have the list, we restart each of the applications.

This is a fall back when we may have missed a change notification,
for instance when we had insufficient buffer to record all the changes
that occured.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnMgr::RestartApplications(BOOL fRestartAllApplications)
    {
    HRESULT hr = S_OK;
    CPtrArray *prgpapplnRestartList = new CPtrArray();
	if (prgpapplnRestartList == NULL)
		return E_OUTOFMEMORY;

    Lock();

    CLinkElem *pLink = CHashTable::Head();

    // Find out which applications need restarting

    while (pLink)
        {
        CAppln *pAppln = static_cast<CAppln *>(pLink);
        pLink = pLink->m_pNext;
        if (!pAppln->FTombstone() && (fRestartAllApplications || (pAppln->m_pGlobalTemplate != NULL && pAppln->m_pGlobalTemplate->FTemplateObsolete())))
            {
            pAppln->AddRef();
            prgpapplnRestartList->Append(pAppln);
            }
        }

    UnLock();

    // Restart the applicaitons

    // Don't want to CloseHandle on this, _beginthread implicitly calls _endthread
    // which closes the handle implicitly.
	uintptr_t hThread = _beginthread(RestartAppsThreadProc, 0, prgpapplnRestartList);
	if (hThread == -1) 
		{
		delete prgpapplnRestartList;
		return E_OUTOFMEMORY;
		}

    return hr;
    }

void __cdecl RestartAppsThreadProc(VOID *arg)
	{
    CPtrArray *prgpapplnRestartList = (CPtrArray *)arg;
	
    for (int i = 0; i < prgpapplnRestartList->Count(); i++)
        {
            CAppln *pAppln = (CAppln *)((*prgpapplnRestartList)[i]);
            pAppln->Restart();
            pAppln->Release();
        }

	delete prgpapplnRestartList;
    return;
    }

/*===================================================================
  C  A p p l n  C l e a n u p  M g r
===================================================================*/

/*===================================================================
CApplnMgr::CApplnCleanupMgr

Application Cleanup Manager constructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CApplnCleanupMgr::CApplnCleanupMgr()
    : m_fInited(FALSE),
      m_fHashTableInited(FALSE), 
      m_fCriticalSectionInited(FALSE),
      m_fThreadAlive(FALSE),
      m_hAppToCleanup(INVALID_HANDLE_VALUE)
    {
    }

/*===================================================================
CApplnCleanupMgr::~CApplnCleanupMgr

Application Cleanup Manager destructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CApplnCleanupMgr::~CApplnCleanupMgr()
    {
    UnInit();
    }

/*===================================================================
HRESULT CApplnCleanupMgr::Init

Initializes the Appln Cleanup Manager.

Parameters:
    NONE

Returns:
    S_OK            Success
    E_FAIL            Failure
    E_OUTOFMEMORY    Out of memory
===================================================================*/
HRESULT CApplnCleanupMgr::Init( void )
    {
    HRESULT hr = S_OK;

    Assert(!m_fInited);

    // Create delete app event

    m_hAppToCleanup = IIS_CREATE_EVENT(
                              "CApplnCleanupMgr::m_hAppToCleanup",
                              this,
                              FALSE,
                              FALSE
                              );

    if (!m_hAppToCleanup)
        return E_FAIL;

    // Init hash table

    hr = CHashTable::Init(NUM_APPLMGR_HASHING_BUCKETS);
    if (FAILED(hr))
        return hr;
    m_fHashTableInited = TRUE;

    // Init critical section

    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
        return(hr);
    m_fCriticalSectionInited = TRUE;

    HANDLE  hThread = CreateThread(NULL, 0, CApplnCleanupMgr::ApplnCleanupThread, 0, 0, NULL);

    if (!hThread) {
        return E_FAIL;
    }

    CloseHandle(hThread);

    m_fInited = TRUE;

    return S_OK;
    }

/*===================================================================
HRESULT CApplnCleanupMgr::UnInit

UnInitializes the Appln Cleanup Manager.

Parameters:
    NONE

Returns:
    S_OK        Success
    E_FAIL        Failure
===================================================================*/
HRESULT CApplnCleanupMgr::UnInit( void )
{
    // set fInited to FALSE here so that the cleanup thread
    // can safely detect that we're shutting down.

    m_fInited = FALSE;

    if (m_hAppToCleanup != INVALID_HANDLE_VALUE) {
        // Set the event one last time so that the thread
        // wakes up, sees that shutdown is occurring and
        // exits.
        SetEvent(m_hAppToCleanup);
        CloseHandle(m_hAppToCleanup);
        m_hAppToCleanup = INVALID_HANDLE_VALUE;
    }

    // we'll wait for the thread to finish its work

    while(m_fThreadAlive) {
        Sleep(200);
    }

    if (m_fHashTableInited) {
        CHashTable::UnInit();
        m_fHashTableInited = FALSE;
    }

    if (m_fCriticalSectionInited) {
        DeleteCriticalSection(&m_csLock);
        m_fCriticalSectionInited = FALSE;
    }

    return S_OK;
}

/*===================================================================
CApplnCleanupMgr::AddAppln

Adds a CAppln element to link list / hash table.


Parameters:
    CAppln *pAppln            Application to cleanup

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnCleanupMgr::AddAppln
(
CAppln *pAppln
)
{
    HRESULT     hr = S_OK;

#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "[CApplnCleanupMgr] Adding App (%S)\n",pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)));
#else
    DBGPRINTF((DBG_CONTEXT, "[CApplnCleanupMgr] Adding App (%s)\n",pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)));
#endif

    Lock();

    // Add to hash table

    if (!CHashTable::AddElem(pAppln)) {
        hr = E_FAIL;
    }

    UnLock();

    if (SUCCEEDED(hr)) {
        SetEvent(m_hAppToCleanup);
    }

    return hr;
}

/*===================================================================
CApplnCleanupMgr::ApplnCleanupProc

The thread that does the work to cleanup applications

Parameters:

Returns:
    HRESULT
===================================================================*/
DWORD __stdcall CApplnCleanupMgr::ApplnCleanupThread(VOID  *pArg)
{
    g_ApplnCleanupMgr.ApplnCleanupDoWork();

    return 0;
}

/*===================================================================
CApplnCleanupMgr::ApplnCleanupDoWork

Proc that actually does the work

Parameters:

Returns:
    HRESULT
===================================================================*/
void CApplnCleanupMgr::ApplnCleanupDoWork()
{
    m_fThreadAlive = TRUE;

    while(1) {

        Lock();

        CLinkElem *pLink =  CHashTable::Head();
        CHashTable::ReInit();

        UnLock();

        while(pLink) {

            CAppln *pAppln = static_cast<CAppln *>(pLink);
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "[CApplnCleanupMgr] Cleanup Thread working on (%S)\n",pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)));
#else
    DBGPRINTF((DBG_CONTEXT, "[CApplnCleanupMgr] Cleanup Thread working on (%s)\n",pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)));
#endif

            pLink = pLink->m_pNext;

            pAppln->ApplnCleanupProc();
        }

        // no need waiting if there is more work to do...
        if (CHashTable::Head() != NULL) {
            continue;
        }

        WaitForSingleObject(m_hAppToCleanup, INFINITE);

        // check to see if shutdown is occurring...
        if (m_fInited == FALSE) {
            Assert(CHashTable::Head() == NULL);
            m_fThreadAlive = FALSE;
            return;
        }
    }

    return;
}

#define            WSTR_NULL       L"\0"

/*===================================================================
  C  A p p l n  I t e r a t o r
===================================================================*/

/*===================================================================
CApplnIterator::CApplnIterator

Constructor

Parameters:
    NONE

Returns:
    NONE
===================================================================*/

CApplnIterator::CApplnIterator()
    : m_pApplnMgr(NULL), m_pCurr(NULL), m_fEnded(FALSE)
    {
    }

/*===================================================================
CApplnIterator::~CApplnIterator

Destructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/

CApplnIterator::~CApplnIterator( void )
    {
    if (m_pApplnMgr != NULL)
        Stop();
    }

/*===================================================================
HRESULT CApplnIterator::Start

Starts iterator on the Appln Manager.

Parameters:
    CApplnMgr * pApplnMgr   Appln Manager
                            (if NULL g_ApplnManager is assumed)

Returns:
    S_OK        Success
    E_FAIL        Failure
===================================================================*/

HRESULT CApplnIterator::Start
(
CApplnMgr *pApplnMgr
)
    {
    m_pApplnMgr = pApplnMgr ? m_pApplnMgr : &g_ApplnMgr;

    m_pApplnMgr->Lock();

    m_pCurr  = NULL;
    m_fEnded = FALSE;

    return S_OK;
    }

/*===================================================================
HRESULT CApplnIterator::Stop

Stops iterator on the Appln Manager.

Parameters:
    NONE

Returns:
    S_OK        Success
    E_FAIL        Failure
===================================================================*/

HRESULT CApplnIterator::Stop()
    {
    if (m_pApplnMgr)
        {
        m_pApplnMgr->UnLock();
        m_pApplnMgr = NULL;
        }

    m_pCurr  = NULL;
    m_fEnded = FALSE;

    return S_OK;
    }

/*===================================================================
HRESULT CApplnIterator::Next

Iterates to the next Appln.

Parameters:
    NONE

Returns:
    Appln * or NULL
===================================================================*/

CAppln *CApplnIterator::Next( void )
    {
    if (m_pApplnMgr == NULL || m_fEnded)
        return NULL;  // didn't start or already ended

    CLinkElem *pT = m_pCurr ? m_pCurr->m_pNext : m_pApplnMgr->Head();
    if (pT)
        {
        m_pCurr = static_cast<CAppln *>(pT);
        return m_pCurr;
        }

    m_fEnded = TRUE;
    return NULL;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\viperint.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Viper Integration Objects

File: viperint.h

Owner: DmitryR

This file contains the definiton of viper integration classes
===================================================================*/

#ifndef VIPERINT_H
#define VIPERINT_H

#include "mtx.h"
#include "mtxpriv.h"
#include "comsvcs.h"
#include "package.h"

#include "asptlb.h"     // needed to define interface pointers

#include "memcls.h"

class CHitObj;  // forward decl

/*===================================================================
  Transaction Support Types
===================================================================*/
#define TransType       DWORD

#define ttUndefined     0x00000000
#define ttNotSupported  0x00000001
#define ttSupported     0x00000002
#define ttRequired      0x00000004
#define ttRequiresNew   0x00000008

/*===================================================================
CViperAsyncRequest class implements IMTSCall interface.
Its OnCall() method does HitObj processing.
This is a private class used in CViperActivity class
===================================================================*/

class CViperAsyncRequest : public IServiceCall, public IAsyncErrorNotify
	{
private: 
	DWORD             m_cRefs;	          // reference count
	CHitObj          *m_pHitObj;         // request
    IServiceActivity *m_pActivity;
    HRESULT           m_hrOnError;
    DWORD             m_dwRepostAttempts;
	
private:
	CViperAsyncRequest();
	~CViperAsyncRequest();

	HRESULT Init(CHitObj *pHitObj, IServiceActivity  *pActivity);

public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif

public:
	// IUnknown Methods
	STDMETHODIMP		 QueryInterface(REFIID iid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// IServiceCall Method
	STDMETHODIMP OnCall();

    // IAsyncErrorNotify
    STDMETHODIMP OnError(HRESULT hr);



friend class CViperActivity;

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

extern volatile LONG g_nViperRequests;

/*===================================================================
CViperActivity corresponds to a Session.
It creates MTS activity, and launches async requests
===================================================================*/

class CViperActivity
    {
private:
    IServiceActivity *m_pActivity;
    DWORD m_cBind;    // inited-flag + bind-to-thread count

    inline BOOL FInited() const { return (m_cBind > 0); }

public:
    CViperActivity();
    ~CViperActivity();

    // Create Viper activity
    HRESULT Init(IUnknown  *pConfig);
    
    // Clone Viper activity
    HRESULT InitClone(CViperActivity *pActivity);

    // Bind/Unbind
    HRESULT BindToThread();
    HRESULT UnBindFromThread();

    // Release Viper activity
    HRESULT UnInit(); 

    // Check if thread-bound
    inline BOOL FThreadBound() const { return (m_cBind > 1); }

    // Post async request within this activity
    HRESULT PostAsyncRequest(CHitObj *pHitObj);

    // post async request without an activity
    static HRESULT PostGlobalAsyncRequest(CHitObj *pHitObj);

public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*===================================================================
Misc. Functions
===================================================================*/

HRESULT ViperAttachIntrinsicsToContext
    (
    IApplicationObject *pAppln,
    ISessionObject     *pSession  = NULL,
    IRequest           *pRequest  = NULL,
    IResponse          *pResponse = NULL,
    IServer            *pServer   = NULL
    );

HRESULT ViperGetObjectFromContext
    (
    BSTR bstrName,
    IDispatch **ppdisp
    );

HRESULT ViperGetHitObjFromContext
    (
    CHitObj **ppHitObj
    );

HRESULT ViperCreateInstance
    (
    REFCLSID rclsid,
    REFIID   riid,
    void   **ppv
    );

HRESULT ViperConfigure(DWORD cThreads, BOOL fAllowOopComponents);

#ifdef UNUSED
HRESULT SetViperThreadEvents();
#endif //UNUSED

/*===================================================================
COM Helper API
===================================================================*/

BOOL ViperCoObjectIsaProxy
    (
    IUnknown *pUnk
    );

BOOL ViperCoObjectAggregatesFTM
    (
    IUnknown *pUnk
    );

#endif // VIPERINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\wraptlib.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Thu Jul 24 14:01:48 1997
 */
/* Compiler settings for D:\VBScript\src\idl\wraptlib.idl, all.acf:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wraptlib_h__
#define __wraptlib_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWrapTypeLibs_FWD_DEFINED__
#define __IWrapTypeLibs_FWD_DEFINED__
typedef interface IWrapTypeLibs IWrapTypeLibs;
#endif 	/* __IWrapTypeLibs_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Jul 24 14:01:48 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// WrapTLib.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
//
// Declarations for ActiveX Script Type Library Wrapping.
//

#ifndef __WrapTLib_h
#define __WrapTLib_h

/* GUIDs
 ********/

// {62238910-C1C9-11d0-ABF7-00A0C911E8B2}
DEFINE_GUID(IID_IWrapTypeLibs, 0x62238910, 0xc1c9, 0x11d0, 0xab, 0xf7, 0x00, 0xa0, 0xc9, 0x11, 0xe8, 0xb2);

/* Interfaces
 *************/






extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IWrapTypeLibs_INTERFACE_DEFINED__
#define __IWrapTypeLibs_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWrapTypeLibs
 * at Thu Jul 24 14:01:48 1997
 * using MIDL 3.00.44
 ****************************************/
/* [object][unique][uuid] */ 



EXTERN_C const IID IID_IWrapTypeLibs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IWrapTypeLibs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WrapTypeLib( 
            /* [in] */ ITypeLib __RPC_FAR *__RPC_FAR *prgptlib,
            /* [in] */ UINT ctlibs,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWrapTypeLibsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWrapTypeLibs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWrapTypeLibs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWrapTypeLibs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WrapTypeLib )( 
            IWrapTypeLibs __RPC_FAR * This,
            /* [in] */ ITypeLib __RPC_FAR *__RPC_FAR *prgptlib,
            /* [in] */ UINT ctlibs,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);
        
        END_INTERFACE
    } IWrapTypeLibsVtbl;

    interface IWrapTypeLibs
    {
        CONST_VTBL struct IWrapTypeLibsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWrapTypeLibs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWrapTypeLibs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWrapTypeLibs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWrapTypeLibs_WrapTypeLib(This,prgptlib,ctlibs,ppdisp)	\
    (This)->lpVtbl -> WrapTypeLib(This,prgptlib,ctlibs,ppdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWrapTypeLibs_WrapTypeLib_Proxy( 
    IWrapTypeLibs __RPC_FAR * This,
    /* [in] */ ITypeLib __RPC_FAR *__RPC_FAR *prgptlib,
    /* [in] */ UINT ctlibs,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);


void __RPC_STUB IWrapTypeLibs_WrapTypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWrapTypeLibs_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0137
 * at Thu Jul 24 14:01:48 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 



#endif  // __WrapTLib_h



extern RPC_IF_HANDLE __MIDL__intf_0137_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0137_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\asperror.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: ASPError object

File: asperror.cpp

Owner: dmitryr

This file contains the code for the implementation of 
the ASPError class.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "asperror.h"

#include "memchk.h"

/*===================================================================
CASPError::CASPError

Constructor for the empty error object

Returns:
===================================================================*/
CASPError::CASPError()
    :
    m_cRefs(1),
    m_szASPCode(NULL),
    m_lNumber(0),
    m_szSource(NULL),
    m_szFileName(NULL),
    m_lLineNumber(0),
    m_szDescription(NULL),
    m_szASPDescription(NULL),
	m_bstrLineText(NULL)
	{
	CDispatch::Init(IID_IASPError);
	}

/*===================================================================
CASPError::CASPError

Constructor for real error object given CErrInfo

Parameters
    pErrInfo        [in] copy data from there

Returns:
===================================================================*/
CASPError::CASPError(CErrInfo *pErrInfo)
    :
    m_cRefs(1),
    m_szASPCode(NULL),
    m_lNumber(0),
    m_szSource(NULL),
    m_szFileName(NULL),
    m_lLineNumber(0),
    m_szDescription(NULL),
    m_szASPDescription(NULL),
	m_bstrLineText(NULL)
	{
	CDispatch::Init(IID_IASPError);

    if (!pErrInfo)
        return;

    // Parse ASP error code and HRESULT from szErrorCode
    CHAR *szErrorCode =  StringDupA(pErrInfo->GetItem(Im_szErrorCode));
    if (szErrorCode != NULL)
        {
        CHAR *szC = strchr(szErrorCode, ':');
        if (szC)
            {
            // format "ASP XXX : HRESULT"
            szC[-1] = '\0';
            m_szASPCode = szErrorCode;
            m_lNumber = strtoul(szC+2, NULL, 16);
            }
        else if (strncmp(szErrorCode, "ASP", 3) == 0)
            {
            // format "ASP XXX"
            m_szASPCode = szErrorCode;
            m_lNumber = E_FAIL;
            }
        else
            {
            // format "HRESULT"
            m_szASPCode = NULL;
            m_lNumber = strtoul(szErrorCode, NULL, 16);
            free(szErrorCode);
            }
        }
    else
        {
        // no error description available
        m_szASPCode = NULL;
        m_lNumber = E_FAIL;
        }

    // Copy the rest
	m_szSource         = StringDupA(pErrInfo->GetItem(Im_szEngine));
	m_szFileName       = StringDupA(pErrInfo->GetItem(Im_szFileName));
	m_szDescription    = StringDupA(pErrInfo->GetItem(Im_szShortDescription));
	m_szASPDescription = StringDupA(pErrInfo->GetItem(Im_szLongDescription));

	// Get line text & column (supplies init. values if not available)
	BSTR bstrLineText;
	pErrInfo->GetLineInfo(&bstrLineText, &m_nColumn);
	m_bstrLineText = SysAllocString(bstrLineText);

    // Line number if present
	if (pErrInfo->GetItem(Im_szLineNum))
    	m_lLineNumber = atoi(pErrInfo->GetItem(Im_szLineNum));
	}

/*===================================================================
CASPError::~CASPError

Destructor

Parameters:
					
Returns:
===================================================================*/
CASPError::~CASPError()
    {
    Assert(m_cRefs == 0);  // must have 0 ref count

    if (m_szASPCode)
        free(m_szASPCode);
    if (m_szSource)
        free(m_szSource);
    if (m_szFileName)
        free(m_szFileName);
    if (m_szDescription)
        free(m_szDescription);
    if (m_szASPDescription)
        free(m_szASPDescription);
	if (m_bstrLineText)
		SysFreeString(m_bstrLineText);
    }

/*===================================================================
CASPError::ToBSTR

Produce a BSTR to be returned by get_XXX methods

Parameters:
    sz      return this string as BSTR
					
Returns:
    BSTR or NULL if FAILED
===================================================================*/
BSTR CASPError::ToBSTR(CHAR *sz)
    {
    BSTR bstr;
    if (sz == NULL || *sz == '\0')
        bstr = SysAllocString(L"");
    else if (FAILED(SysAllocStringFromSz(sz, 0, &bstr)))
        bstr = NULL;
    return bstr;
    }

/*===================================================================
CASPError::QueryInterface
CASPError::AddRef
CASPError::Release

IUnknown members for CASPError object.
===================================================================*/
STDMETHODIMP CASPError::QueryInterface(REFIID riid, VOID **ppv)
	{
	if (IID_IUnknown == riid ||	IID_IDispatch == riid || IID_IASPError == riid)
		{
		AddRef();
		*ppv = this;
		return S_OK;
		}
		
	*ppv = NULL;
	return E_NOINTERFACE;
	}

STDMETHODIMP_(ULONG) CASPError::AddRef()
	{
	return InterlockedIncrement(&m_cRefs);
	}

STDMETHODIMP_(ULONG) CASPError::Release()
	{
    LONG cRefs = InterlockedDecrement(&m_cRefs);
	if (cRefs)
		return cRefs;
	delete this;
	return 0;
	}

/*===================================================================
CASPError::get_ASPCode
CASPError::get_Number
CASPError::get_Source
CASPError::get_FileName
CASPError::get_LineNumber
CASPError::get_Description
CASPError::get_ASPDescription

IASPError members for CASPError object.
===================================================================*/
STDMETHODIMP CASPError::get_ASPCode(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szASPCode);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
    
STDMETHODIMP CASPError::get_Number(long *plNumber)
    {
    *plNumber = m_lNumber;
    return S_OK;
    }
    
STDMETHODIMP CASPError::get_Category(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szSource);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
    
STDMETHODIMP CASPError::get_File(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szFileName);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
    
STDMETHODIMP CASPError::get_Line(long *plLineNumber)
    {
    *plLineNumber = m_lLineNumber;
    return S_OK;
    }
    
STDMETHODIMP CASPError::get_Column(long *pnColumn)
    {
    *pnColumn = long(m_nColumn);
    return S_OK;
    }
    
STDMETHODIMP CASPError::get_Source(BSTR *pbstrLineText)
    {
	*pbstrLineText = SysAllocString(m_bstrLineText? m_bstrLineText : L"");
	return S_OK;
    }
    
STDMETHODIMP CASPError::get_Description(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szDescription);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
    
STDMETHODIMP CASPError::get_ASPDescription(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szASPDescription);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\asperror.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: ASPError object

File: asperror.h

Owner: dmitryr

This file contains the definiton of the ASPError class
===================================================================*/

#ifndef _ASPERROR_H
#define _ASPERROR_H

#include "debug.h"
#include "asptlb.h"
#include "disptch2.h"
#include "memcls.h"

// forward decl
class CErrInfo; 


class CASPError : public IASPErrorImpl
	{
private:
    LONG  m_cRefs;

    CHAR *m_szASPCode;
    LONG  m_lNumber;
	int   m_nColumn;
    CHAR *m_szSource;
    CHAR *m_szFileName;
    LONG  m_lLineNumber;
    CHAR *m_szDescription;
    CHAR *m_szASPDescription;
	BSTR  m_bstrLineText;

    BSTR ToBSTR(CHAR *sz);

public:
	// default constructor for 'dummy' error
	CASPError();
	// real constructor
	CASPError(CErrInfo *pErrInfo);
	
	~CASPError();

    // IUnknown
	STDMETHODIMP		 QueryInterface(REFIID, VOID**);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IASPError
	STDMETHODIMP get_ASPCode(BSTR *pbstrASPCode);
	STDMETHODIMP get_Number(long *plNumber);
	STDMETHODIMP get_Category(BSTR *pbstrSource);
	STDMETHODIMP get_File(BSTR *pbstrFileName);
	STDMETHODIMP get_Line(long *plLineNumber);
	STDMETHODIMP get_Description(BSTR *pbstrDescription);
	STDMETHODIMP get_ASPDescription(BSTR *pbstrDescription);
	STDMETHODIMP get_Column(long *plColumn);
	STDMETHODIMP get_Source(BSTR *pbstrLineText);

	// Cache on per-class basis
	ACACHE_INCLASS_DEFINITIONS()
	};

#endif //_ASPERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\appcnfg.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Globals

File: AppCnfg.h

Owner: AndrewS

Useful globals
===================================================================*/

#ifndef __APPCNFG_H
#define __APPCNFG_H

#include "util.h"
#include <schnlsp.h>
#include <wincrypt.h>
#include <iadmw.h>

extern "C" {

#define SECURITY_WIN32
#include <sspi.h>           // Security Support Provider APIs

}
class CAppln;   // forward declaration
class CAppConfig;

class CMDAppConfigSink : public IMSAdminBaseSinkW
        {
        private:
        INT                     m_cRef;
        CAppConfig      *m_pAppConfig;
        public:

        CMDAppConfigSink (CAppConfig *pAppConfig)                       {m_cRef = 1; m_pAppConfig = pAppConfig;};

        HRESULT STDMETHODCALLTYPE       QueryInterface(REFIID riid, void **ppv);
        ULONG   STDMETHODCALLTYPE       AddRef(void);
        ULONG   STDMETHODCALLTYPE       Release(void);

        HRESULT STDMETHODCALLTYPE       SinkNotify(
                        DWORD   dwMDNumElements,
                        MD_CHANGE_OBJECT        __RPC_FAR       pcoChangeList[]);

        HRESULT STDMETHODCALLTYPE ShutdownNotify( void)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }
        };

//      Index used in ReadPropsfromRegistry().  Also, we can use the same index to enable the global
//      data to be table-driven.

#define IApp_AllowSessionState                                  0x0
#define IApp_BufferingOn                                        0x1
#define IApp_ScriptLanguage                                     0x2
#define IApp_EnableParentPaths                                  0x3
#define IApp_ScriptErrorMessage                                 0x4
#define IApp_SessionTimeout                                     0x5
#define IApp_CodePage                                           0x6
#define IApp_ScriptTimeout                                      0x7
#define IApp_ScriptErrorsSenttoBrowser                          0x8
#define IApp_AllowDebugging                                     0x9
#define IApp_AllowClientDebug                                   0xa
#define IApp_QueueTimeout                                       0xb
#define IApp_EnableApplicationRestart                           0xc
#define IApp_QueueConnectionTestTime                            0xd
#define IApp_SessionMax                                         0xe
#define IApp_ExecuteInMTA                                       0xf
#define IApp_LCID                                               0x10
#define IApp_KeepSessionIDSecure                                0x11 
#define IApp_MAX                                                0x12

//      Index to glob's szMessage array.
#define IAppMsg_SCRIPTERROR             0
#define IAppMsg_SCRIPTLANGUAGE  1
#define APP_CONFIG_MESSAGEMAX   2

//      Glob data object
class CAppConfig
        {
        friend class CMDAppConfigSink;
        friend HRESULT  ReadConfigFromMD(CIsapiReqInfo *pIReq, CAppConfig *pAppConfig, BOOL fLoadGlob);
        friend HRESULT  SetConfigToDefaults(CAppConfig *pAppConfig, BOOL fLoadGlob);

private:

        CAppln          *m_pAppln;
        BOOL            m_fNeedUpdate;
        BOOL            m_fInited:1;
        BOOL            m_fRestartEnabledUpdated:1;
		BOOL            m_fIsValidProglangCLSID:1;
        /*
         * Configurable values from Metabase
         */
        BOOL            m_fScriptErrorsSentToBrowser;
        BOOL            m_fBufferingOn;                                 // Is buffering on by default?
        BOOL            m_fEnableParentPaths;
        BOOL            m_fAllowSessionState;
        BOOL            m_fAllowOutOfProcCmpnts;
        BOOL            m_fAllowDebugging;
        BOOL            m_fAllowClientDebug;
        BOOL            m_fEnableApplicationRestart;
        BOOL            m_fKeepSessionIDSecure;               
        UINT            m_uCodePage;
        DWORD           m_dwScriptTimeout;
        DWORD           m_dwSessionTimeout;
        DWORD           m_dwQueueTimeout;
        CLSID           m_DefaultScriptEngineProgID;
        DWORD           m_dwQueueConnectionTestTime;
        DWORD           m_dwSessionMax;
        BOOL            m_fExecuteInMTA;
        LCID            m_uLCID;

        
        IMSAdminBase   *m_pMetabase;
        CMDAppConfigSink *m_pMetabaseSink;
        DWORD           m_dwMDSinkCookie;

        LPSTR           m_szString[APP_CONFIG_MESSAGEMAX];

        //Private functions
        HRESULT         SetValue(unsigned int index, BYTE *lpByte);

public:

        CAppConfig();
        HRESULT         Init(CIsapiReqInfo  *pIReq, CAppln *pAppln);
        HRESULT         UnInit(void);
        void            NotifyNeedUpdate(void);
        BOOL            fNeedUpdate()                           {return m_fNeedUpdate;};
        BOOL            fRestartEnabledUpdated()                {return m_fRestartEnabledUpdated;};
        void            NotifyRestartEnabledUpdated()           { m_fRestartEnabledUpdated = TRUE;};
        HRESULT         Update(CIsapiReqInfo  *pIReq);

        UINT            uCodePage()                             {return m_uCodePage;};
        DWORD           dwSessionTimeout()                      {return m_dwSessionTimeout;};
        DWORD           dwQueueTimeout()                        {return m_dwQueueTimeout;};
        DWORD           dwScriptTimeout()                       {return m_dwScriptTimeout;};
        BOOL            fScriptErrorsSentToBrowser()            {return m_fScriptErrorsSentToBrowser;};
        BOOL            fBufferingOn()                          {return m_fBufferingOn;};
        BOOL            fEnableParentPaths()                    {return !m_fEnableParentPaths;};
        BOOL            fAllowSessionState()                    {return m_fAllowSessionState;};
        BOOL            fAllowOutOfProcCmpnts()                 {return m_fAllowOutOfProcCmpnts;};
        BOOL            fAllowDebugging()                       {return m_fAllowDebugging;};
        BOOL            fAllowClientDebug()                     {return m_fAllowClientDebug;};
        BOOL            fInited()                               {return m_fInited;};
        BOOL            fKeepSessionIDSecure()                  {return m_fKeepSessionIDSecure;};              
        BOOL            fExecuteInMTA()                         {return m_fExecuteInMTA;};
        LCID            uLCID()                                 {return m_uLCID; };
        LPCSTR          szScriptErrorMessage()                  {return (m_szString[IAppMsg_SCRIPTERROR]);};
        LPCSTR          szScriptLanguage()                      {return (m_szString[IAppMsg_SCRIPTLANGUAGE]);};
        CLSID           *pCLSIDDefaultEngine()                  {return m_fIsValidProglangCLSID? &m_DefaultScriptEngineProgID : NULL;};
        
        BOOL            fEnableApplicationRestart() { return m_fEnableApplicationRestart; }
        DWORD           dwQueueConnectionTestTime() { return m_dwQueueConnectionTestTime; }
        DWORD           dwSessionMax() { return m_dwSessionMax; }

        LPTSTR           SzMDPath();
        };

inline void CAppConfig::NotifyNeedUpdate(void)
{
        InterlockedExchange((LPLONG)&m_fNeedUpdate, 1);
}
#endif // __APPCNFG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\clcert.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request, Response objects

File: clcert.h

Owner: DGottner

This file contains the definiton of the CCookie class, which
contains all of the state for an HTTP cookie
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "asptlb.h"
#include "dispatch.h"
#include "hashing.h"
#include "memcls.h"

class CClCert;

// Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);


/*
 * C C l C e r t S u p p o r t E r r
 *
 * Implements ISupportErrorInfo for the CClCert class. The CSupportError class
 * is not adequate because it will only report a max of one interface which
 * supports error info. (We have two)
 */
class CClCertSupportErr : public ISupportErrorInfo
	{
private:
	CClCert *	m_pClCert;

public:
	CClCertSupportErr(CClCert *pClCert);

	// IUnknown members that delegate to m_pClCert
	//
	STDMETHODIMP		 QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// ISupportErrorInfo members
	//
	STDMETHODIMP InterfaceSupportsErrorInfo(const GUID &);
	};


/*
 * C R e a d C l C e r t
 *
 * Implements IClCert which is the interface that Request.ClientCert
 * returns.  It is an IRequestDictionary.
 */
class CReadClCert : public IRequestDictionaryImpl
	{
private:
	CClCert *			m_pClCert;

public:
	CReadClCert(CClCert *);

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const IID &rIID, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// IRequestDictionary implementation
	//
	STDMETHODIMP			get_Item(VARIANT i, VARIANT *pVariantReturn);
	STDMETHODIMP			get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP			get_Count(int *pcValues);
	STDMETHODIMP			get_Key(VARIANT VarKey, VARIANT *pvar);
	};




/*
 * C C l C e r t
 *
 * Implements CClCert, which is the object stored in the Request.Cookies
 * dictionary.
 */
class CClCert : public IUnknown
	{
	friend CReadClCert;

protected:
	ULONG				m_cRefs;			// reference count
	PFNDESTROYED		m_pfnDestroy;		// To call on closure

private:
	CReadClCert			m_ReadClCertInterface;		// implementation of IStringList
	CClCertSupportErr	m_ClCertSupportErrorInfo;	// implementation of ISupportErrorInfo

	char *				m_szValue;					// value of clcert when not a dictionary
    VARENUM             m_veType;
    UINT                m_cLen;

public:
	CClCert(IUnknown * = NULL, PFNDESTROYED = NULL);
	~CClCert();

	HRESULT AddValue(char *szValue, VARENUM ve = VT_BSTR, UINT l = 0 );

	size_t GetHTTPClCertSize();				// return information on how big a buffer should be
	char * GetHTTPClCert(char *szBuffer);	// return the clcert value HTTP encoded

	size_t GetClCertHeaderSize(const char *szName);				// return buffer size for header
	char *GetClCertHeader(const char *szName, char *szBuffer);	// return cookie header

	HRESULT		Init();

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const GUID &Iid, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

//
// simple class to handle extensible buffer
// It is guaranteed that a portion of the buffer 
// can be appended to itself.
// extension is done on a XBF_EXTEND granularity
//

#define XBF_EXTEND  512

class XBF {

public:
    XBF( LPSTR pB, int cB ) { m_pV = pB; m_cAlloc = cB; m_cSize = 0; }
    ~XBF() {}
    void Reset() { m_cSize = 0; m_cAlloc = 0; m_pV = NULL; }

    // Append a string with '\0' delimiter

    LPSTR AddStringZ( LPSTR pszV, BOOL fXt = FALSE )
    {
        return AddBlob( pszV, strlen(pszV) +1, fXt );
    }

    // Append a string w/o '\0' delimiter

    LPSTR AddString( LPSTR pszV, BOOL fXt = FALSE )
    {
        return AddBlob( pszV, strlen(pszV), fXt );
    }

    // Append a byte range

    LPSTR AddBlob( LPSTR pszV, int cV, BOOL fXt = FALSE )
    {
        if ( m_cSize + cV > m_cAlloc )
        {
            if ( !fXt || !Extend( m_cSize + cV ) )
            {
                return NULL;
            }
        }

        LPSTR pV;
        memcpy( pV = m_pV + m_cSize, pszV, cV );
        m_cSize += cV;

        return pV;
    }

    LPSTR ReserveRange( int cV , int align = 1)
    {
        int curUsed = ((m_cSize + (align - 1)) & ~(align - 1));
        if ( (curUsed + cV) > m_cAlloc )
        {
            return NULL;
        }

        return m_pV + curUsed;
    }

    VOID SkipRange( int cV, int align = 1)
    {
        m_cSize += ((cV + (align - 1)) & ~(align - 1));
    }

    BOOL Extend( int cA );

    // pointer to buffer

    LPSTR QueryBuf() const { return m_pV; }

    // size of buffer

    int QuerySize() { return m_cSize; }

    int QueryAllocSize() { return m_cAlloc; }

private:
    int m_cAlloc;       // allocated memory
    int m_cSize;        // used memory
    LPSTR m_pV;         // buffer
} ;


class CCertRequest {
public:
    CCertRequest( CRequest* Req ) { pReq = Req; }
    ~CCertRequest() {}

    HRESULT AddStringPair( CollectionType Source, LPSTR szName, 
                           LPSTR szValue, XBF *pxbf, BOOL fDuplicate, UINT lCodePage );
    HRESULT AddDatePair( CollectionType Source, LPSTR szName, 
                           FILETIME* pValue, XBF *pxbf );
    HRESULT AddDwordPair( CollectionType Source, LPSTR szName, 
                           LPDWORD pValue, XBF *pxbf );
    HRESULT AddBinaryPair( CollectionType Source, LPSTR szName, 
                           LPBYTE pValue, DWORD cValue, XBF *pxbf, UINT lCodePage );
    HRESULT AddUuBinaryPair( CollectionType Source, LPSTR szName, 
                           LPBYTE pValue, DWORD cValue, XBF *pxbf, UINT lCodePage );
    HRESULT AddName( LPSTR szName, CRequestHit **ppReqHit, XBF *pxbf );
    HRESULT ParseRDNS( CERT_NAME_INFO* pNameInfo, LPSTR pszPrefix, XBF *pxbf, UINT lCodePage );
    HRESULT ParseCertificate( LPBYTE pCert, DWORD cCert, DWORD dwEncoding, DWORD dwFlags, UINT lCodePage );
    HRESULT NoCertificate();

private:
    CRequest *pReq;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\applmgr.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Appln Manager

File: Applmgr.h

Owner: PramodD

This is the application manager header file.
===================================================================*/
#ifndef APPLMGR_H
#define APPLMGR_H

#include "debug.h"
#include "hashing.h"
#include "cachemgr.h"
#include "appcnfg.h"
#include "compcol.h"
#include "fileapp.h"
#include "idhash.h"

#include "memcls.h"
#include "ftm.h"

#include "disptch2.h"

/*===================================================================
  #defines
===================================================================*/

#define    NUM_APPLMGR_HASHING_BUCKETS            17
#define    NOTIFICATION_BUFFER_SIZE            4096

#define    INVALID_THREADID            0xFFFFFFFF

#include "asptlb.h"

// Use to specify which source file name you want (pathInfo or pathTranslated)
#ifndef _SRCPATHTYPE_DEFINED
#define _SRCPATHTYPE_DEFINED

enum SOURCEPATHTYPE
	{
	SOURCEPATHTYPE_VIRTUAL = 0,
	SOURCEPATHTYPE_PHYSICAL = 1
	};

#endif


/*===================================================================
  Forward declarations
===================================================================*/

class CComponentCollection;
class CSessionMgr;
class CViperActivity;
class CActiveScriptEngine;
struct IDebugApplication;
struct IDebugApplicationNode;

/*===================================================================
  C A p p l n V a r i a n t s
===================================================================*/
class CApplnVariants : public IVariantDictionaryImpl
    {
private:
    ULONG               m_cRefs;            // ref count
    CAppln *            m_pAppln;           // pointer to parent object
    CompType            m_ctColType;        // type of components in collection
    CSupportErrorInfo   m_ISupportErrImp;   // implementation of ISupportErr

	HRESULT ObjectNameFromVariant(VARIANT &vKey, WCHAR **ppwszName,
	                              BOOL fVerify = FALSE);

public:
	CApplnVariants();
	~CApplnVariants();

	HRESULT Init(CAppln *pAppln, CompType ctColType);
	HRESULT UnInit();

    // The Big Three

    STDMETHODIMP         QueryInterface(const GUID &, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // OLE Automation Interface

    STDMETHODIMP get_Item(VARIANT Var, VARIANT *pvar);
    STDMETHODIMP put_Item(VARIANT varKey, VARIANT var);
    STDMETHODIMP putref_Item(VARIANT varKey, VARIANT var);
    STDMETHODIMP get_Key(VARIANT Var, VARIANT *pvar);
    STDMETHODIMP get__NewEnum(IUnknown **ppEnumReturn);
    STDMETHODIMP get_Count(int *pcValues);
	STDMETHODIMP Remove(VARIANT VarKey);
	STDMETHODIMP RemoveAll();
    
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };


/*===================================================================
  C  A p p l n
===================================================================*/

class CAppln : public IApplicationObjectImpl, public CLinkElem, public CFTMImplementation
    {

friend class CApplnMgr;
friend class CApplnCleanupMgr;
friend class CDirMonitorEntry;
friend class CApplnVariants;
    
private:

    //========= Misc flags
    
    DWORD m_fInited : 1;            // Are we initialized?
    DWORD m_fFirstRequestRan : 1;   // 1st request for this app ran?
    DWORD m_fGlobalChanged : 1;     // Global.asa has changed?
    DWORD m_fDeleteInProgress : 1;  // Delete event posted?
    DWORD m_fTombstone : 1;         // ASP is done with the app?
    DWORD m_fDebuggable : 1;        // Debugging enabled for this app?

    //========= Notification flags

    // ReadDirectoryChangesW done?
    DWORD m_fNotificationAdded : 1;    
    // change notification should use impersonation?
    DWORD m_fUseImpersonationHandle : 1;

    //========= Ref counts

    DWORD m_cRefs;
    DWORD        m_cRequests;    // Active requests count
    DWORD        m_cSessions;    // Session count

    //========= Application's key, path, global.asa

    // metabase key (unique app id)
    TCHAR *m_pszMetabaseKey;
    // physical application directory path
    TCHAR *m_pszApplnPath;
    // virtual application directory path
    TCHAR *m_pszApplnVRoot;
    // Path to global.asa for application
    TCHAR *m_pszGlobalAsa;
    // Pointer to compliled template for global.asa
    CTemplate *m_pGlobalTemplate;

    //========= Application's Session Manager

    CSessionMgr *m_pSessionMgr;  // Session manager for this app

    //========= Application's Configuration Settings
    
    CAppConfig  *m_pAppConfig; // Application Configuration object

    //========= Application's Component Collection
    
    CComponentCollection *m_pApplCompCol;      // Application scope objects

    //========= Application's dictionaries for presenting component collection
    CApplnVariants    *m_pProperties;
    CApplnVariants    *m_pTaggedObjects;

    //========= Viper Activity
    
    // Application's activity (for thread-locked appls)
    CViperActivity *m_pActivity;
    
    //========= Critical section for internal lock
    
    CRITICAL_SECTION m_csInternalLock;

    //========= External lock support
    
    CRITICAL_SECTION m_csApplnLock;
    DWORD            m_dwLockThreadID; // thread which locked
    DWORD            m_cLockRefCount;  // lock count

    //========= Notification support    
    
    // Identifiers stored by notification system
    CPtrArray	m_rgpvDME;			// list of directory monitor entries
    CPtrArray	m_rgpvFileAppln;	// list of entries relating files to applications

    // User impersonation handle for UNC change notification
    HANDLE m_hUserImpersonation;

    //========= Type Library wrapper from GLOBAL.ASA
   	IDispatch *m_pdispGlobTypeLibWrapper;

    //========= SupportErrorInfo
    
    // Interface to indicate that we support ErrorInfo reporting
    CSupportErrorInfo m_ISuppErrImp;
    
    //========= Debugging Support

    // root node for browsing of running documents
    IDebugApplicationNode *m_pAppRoot;

    // proc used to asynchronously cleanup the app

    HRESULT ApplnCleanupProc();

public:
    CAppln();
    ~CAppln();
    
    HRESULT Init
        (
        TCHAR *pszApplnKey, 
        TCHAR *pszApplnPath, 
        CIsapiReqInfo   *pIReq, 
        HANDLE hUserImpersonation
        );

    // cnvert to tombstone state
    HRESULT UnInit();

    // create application's activity as clone of param
    HRESULT BindToActivity(CViperActivity *pActivity = NULL);

    // set (and remember) global.asa for this app
    HRESULT SetGlobalAsa(const TCHAR *pszGlobalAsa);

    // make sure script didn't leave locks
    HRESULT UnLockAfterRequest();

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Tombstone stub
    HRESULT CheckForTombstone();

    // Restart an application (such as when global.asa changes)
    HRESULT Restart(BOOL fForceRestart = FALSE);

    // IApplicationObject functions
    STDMETHODIMP Lock();
    STDMETHODIMP UnLock();
    STDMETHODIMP get_Value(BSTR bstr, VARIANT *pvar);
    STDMETHODIMP put_Value(BSTR bstr, VARIANT var);
    STDMETHODIMP putref_Value(BSTR bstr, VARIANT var);
    STDMETHODIMP get_Contents(IVariantDictionary **ppDictReturn);
    STDMETHODIMP get_StaticObjects(IVariantDictionary **ppDictReturn);

    // Application config related methods
    CAppConfig *QueryAppConfig();
    BOOL        FConfigNeedsUpdate();
    HRESULT     UpdateConfig(CIsapiReqInfo   *pIReq, BOOL *pfRestart = NULL, BOOL *pfFlushAll = NULL);

    // inline methods to access member properties
    CSessionMgr           *PSessionMgr();
    CComponentCollection  *PCompCol();
    CViperActivity        *PActivity();
	IDebugApplicationNode *PAppRoot();
	CTemplate             *PGlobalTemplate();
	void                   SetGlobalTemplate(CTemplate *);
	TCHAR                 *GetMetabaseKey();
	TCHAR                 *GetApplnPath(SOURCEPATHTYPE = SOURCEPATHTYPE_PHYSICAL);
	TCHAR                 *GetGlobalAsa();
	DWORD                  GetNumSessions();
	DWORD                  GetNumRequests();
	BOOL                   FGlobalChanged();
	BOOL                   FDebuggable();
	BOOL                   FTombstone();
	BOOL                   FHasGlobalAsa();
	BOOL                   FFirstRequestRun();
   	IDispatch             *PGlobTypeLibWrapper();

    void SetFirstRequestRan();
   	void SetGlobTypeLibWrapper(IDispatch *);
    HRESULT AddDirMonitorEntry(CDirMonitorEntry *);
    HRESULT AddFileApplnEntry(CFileApplnList *pFileAppln);

    CASPDirMonitorEntry  *FPathMonitored(LPCTSTR  pszPath);
    
    // Misc inline methods
    void InternalLock();
    void InternalUnLock();
    void IncrementSessionCount();
    void DecrementSessionCount();
    void IncrementRequestCount();
    void DecrementRequestCount();

    // AssertValid()
public:

#ifdef DBG
    virtual void AssertValid() const;
#else
    virtual void AssertValid() const {}
#endif
    
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()

	// Trace Log info -- keep in both free & checked builds so that ntsd extension will work for both builds
	// for FREE build, trace log is always NULL.  Checked builds, it must be enabled.
	static PTRACE_LOG gm_pTraceLog;
    };

/*===================================================================
  C  A p p l n   inlines
===================================================================*/

inline CSessionMgr *CAppln::PSessionMgr()
    {
    return m_pSessionMgr;
    }

inline CComponentCollection *CAppln::PCompCol()
    {
    return m_pApplCompCol;
    }

inline CViperActivity *CAppln::PActivity()
    {
    return m_pActivity;
    }

inline IDebugApplicationNode *CAppln::PAppRoot()
    {
    return m_pAppRoot;
    }

inline TCHAR *CAppln::GetMetabaseKey()
    {
    return m_pszMetabaseKey;
    }

inline TCHAR *CAppln::GetApplnPath(SOURCEPATHTYPE pathtype)
    {
	return (pathtype == SOURCEPATHTYPE_VIRTUAL? m_pszApplnVRoot :
			(pathtype == SOURCEPATHTYPE_PHYSICAL? m_pszApplnPath : NULL));
    }

inline CTemplate *CAppln::PGlobalTemplate()
    {
    return m_pGlobalTemplate;
    }

inline void CAppln::SetGlobalTemplate(CTemplate *pTemplate)
    {
    pTemplate->AddRef();
    m_pGlobalTemplate = pTemplate;
    }

inline TCHAR *CAppln::GetGlobalAsa()
    {
    return m_pszGlobalAsa;
    }

inline DWORD CAppln::GetNumSessions()
    {
    return m_cSessions;
    }

inline DWORD CAppln::GetNumRequests()
    {
    return m_cRequests;
    }

inline BOOL CAppln::FGlobalChanged()
    {
    return m_fGlobalChanged;
    }

inline BOOL CAppln::FDebuggable()
    {
    return m_fDebuggable;
    }

inline BOOL CAppln::FTombstone()
    {
    return m_fTombstone;
    }

inline BOOL CAppln::FHasGlobalAsa()
    {
    return (m_pszGlobalAsa != NULL);
    }

inline BOOL CAppln::FFirstRequestRun()
    {
    return m_fFirstRequestRan;
    }

inline void CAppln::SetFirstRequestRan()
    {
    Assert(m_fInited);
    m_fFirstRequestRan = TRUE;
    }

inline IDispatch *CAppln::PGlobTypeLibWrapper()
    {
    return m_pdispGlobTypeLibWrapper;
    }
    
inline void CAppln::SetGlobTypeLibWrapper(IDispatch *pdisp)
    {
    if (m_pdispGlobTypeLibWrapper)
        m_pdispGlobTypeLibWrapper->Release();
        
    m_pdispGlobTypeLibWrapper = pdisp;
    
    if (m_pdispGlobTypeLibWrapper)
        m_pdispGlobTypeLibWrapper->AddRef();
    }

inline void CAppln::IncrementSessionCount()
    {
    Assert(m_fInited);
    InterlockedIncrement((LPLONG)&m_cSessions);
    }
    
inline void CAppln::DecrementSessionCount()
    {
    Assert(m_fInited);
    InterlockedDecrement((LPLONG)&m_cSessions);
    }

inline void CAppln::IncrementRequestCount()
    {
    Assert(m_fInited);
    InterlockedIncrement((LPLONG)&m_cRequests);
    }
    
inline void CAppln::DecrementRequestCount()
    {
    Assert(m_fInited);
    InterlockedDecrement((LPLONG)&m_cRequests);
    }
    
inline void CAppln::InternalLock()
    {
    Assert(m_fInited);
    EnterCriticalSection(&m_csInternalLock);
    }
    
inline void CAppln::InternalUnLock()
    {
    Assert(m_fInited);
    LeaveCriticalSection(&m_csInternalLock); 
    }

inline CAppConfig * CAppln::QueryAppConfig()
    {
    return m_pAppConfig;
    }

inline BOOL CAppln::FConfigNeedsUpdate()
    {
    return m_pAppConfig->fNeedUpdate();
    }

/*===================================================================
  C  A p p l n  M g r
===================================================================*/

class CApplnMgr : public CHashTable
    {
private:
    // Flags
    DWORD m_fInited : 1;                // Are we initialized?
    DWORD m_fHashTableInited : 1;       // Need to UnInit hash table?
    DWORD m_fCriticalSectionInited : 1; // Need to delete CS?

    // Event handles
    HANDLE m_hDeleteApplnEvent; // Flush application object

    // Critical section for locking
    CRITICAL_SECTION m_csLock;

    // List of script engines that need to be closed on next request.
    // (See comments in code, esp. CApplnMgr::AddEngine)
    CDblLink m_listEngineCleanup;

public:    
    CApplnMgr();
    ~CApplnMgr();

    HRESULT    Init();
    HRESULT    UnInit();

    // CAppln manipulations
    
    HRESULT AddAppln
        (
        TCHAR *pszApplnKey, 
        TCHAR *pszApplnPath, 
        CIsapiReqInfo   *pIReq,
        HANDLE hUserImpersonation,
        CAppln **ppAppln
        );
    
    HRESULT FindAppln
        (
        TCHAR *pszApplnKey, 
        CAppln **ppAppln
        );
        
    HRESULT DeleteApplicationIfExpired(CAppln *pAppln);
    HRESULT DeleteAllApplications();
    HRESULT RestartApplications(BOOL fRestartAllApplications = FALSE);
    
    // Add an engine to the deferred cleanup list/release engines in the list
	HRESULT AddEngine(CActiveScriptEngine *pEng);
	void CleanupEngines();

    // inlines
    
    void   Lock();
    void   UnLock();
    HANDLE HDeleteEvent();
    void   SetDeleteEvent(void);
    
    };

/*===================================================================
  C  A p p l n  M g r   inlines
===================================================================*/

inline void    CApplnMgr::Lock()
    {
    Assert(m_fInited);
    EnterCriticalSection(&m_csLock);
    }
    
inline void    CApplnMgr::UnLock()
    {
    Assert(m_fInited);
    LeaveCriticalSection( &m_csLock ); 
    }
    
inline HANDLE CApplnMgr::HDeleteEvent()
    {
    return m_hDeleteApplnEvent;
    }
    
inline void CApplnMgr::SetDeleteEvent()
    {
    DWORD error;
    Assert(m_hDeleteApplnEvent != INVALID_HANDLE_VALUE);
    BOOL flag = SetEvent(m_hDeleteApplnEvent);
    if (!flag)
        error = GetLastError();
    }

/*===================================================================
  C  A p p l n  C l e a n u p M g r
===================================================================*/

class CApplnCleanupMgr : public CHashTable
    {
private:
    // Flags
    DWORD m_fInited : 1;                // Are we initialized?
    DWORD m_fHashTableInited : 1;       // Need to UnInit hash table?
    DWORD m_fCriticalSectionInited : 1; // Need to delete CS?
    DWORD m_fThreadAlive : 1;           // worker thread alive?

    // Critical section for locking
    CRITICAL_SECTION m_csLock;

    HANDLE m_hAppToCleanup; // event to signal when there is an app to cleanup

public:    
    CApplnCleanupMgr();
    ~CApplnCleanupMgr();

    HRESULT    Init();
    HRESULT    UnInit();

    // CAppln manipulations
    
    HRESULT AddAppln
        (
        CAppln *ppAppln
        );
    
private:
    // inlines
    
    void   Lock();
    void   UnLock();

    // thread proc used to cleanup deleted applications
    static  DWORD __stdcall ApplnCleanupThread(VOID  *pArg);
    void    ApplnCleanupDoWork();
    
    };

/*===================================================================
  C  A p p l n  C l e a n u p M g r   inlines
===================================================================*/

inline void    CApplnCleanupMgr::Lock()
    {
    Assert(m_fCriticalSectionInited);
    EnterCriticalSection(&m_csLock);
    }
    
inline void    CApplnCleanupMgr::UnLock()
    {
    Assert(m_fCriticalSectionInited);
    LeaveCriticalSection( &m_csLock ); 
    }
    
/*===================================================================
C A p p l n M g r thread proc prototype
===================================================================*/
void __cdecl RestartAppsThreadProc(VOID *arg);

/*===================================================================
  Globals
===================================================================*/

extern CApplnMgr    g_ApplnMgr;
extern DWORD        g_nApplications;
extern DWORD        g_nApplicationsRestarting;

/*===================================================================
  C  A p p l n  I t e r a t o r
===================================================================*/

class CApplnIterator
    {
private:
    CApplnMgr   *m_pApplnMgr;
    CAppln      *m_pCurr;
    BOOL         m_fEnded; // iterator ended

public:
                CApplnIterator(void);
    virtual        ~CApplnIterator(void);

public:
    HRESULT            Start(CApplnMgr *pApplnMgr = NULL);
    HRESULT            Stop(void);
    CAppln *        Next(void);
    };

#endif // APPLMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\aspdmon.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       aspdirmon.cpp

   Abstract:
       This module includes derivation of class supporting change
       notification for ASP template cache, from abstract class DIR_MON_ENTRY

   Author:

       Charles Grant    ( cgrant )     June-1997 

   Revision History:

--*/
#ifndef _CACHEDIRMON_H
#define _CACHEDIRMON_H

// ASP-customized file notification filter 
// see Winnt.h for valid flags, only valid for NT
#define FILE_NOTIFY_FILTER  (FILE_NOTIFY_CHANGE_FILE_NAME  | \
                               FILE_NOTIFY_CHANGE_DIR_NAME | \
                               FILE_NOTIFY_CHANGE_ATTRIBUTES | \
                               FILE_NOTIFY_CHANGE_SIZE       | \
                               FILE_NOTIFY_CHANGE_LAST_WRITE | \
                               FILE_NOTIFY_CHANGE_SECURITY)

// Number of times we will try to get request notification
#define MAX_NOTIFICATION_FAILURES 3

/************************************************************
 *     Include Headers
 ************************************************************/
# include "dirmon.h"
# include "reftrace.h"

class CASPDirMonitorEntry : public CDirMonitorEntry
{
private:
    DWORD m_cNotificationFailures;

    BOOL ActOnNotification(DWORD dwStatus, DWORD dwBytesWritten);
    void FileChanged(const char *pszScriptName, bool fFileWasRemoved);

public:
    CASPDirMonitorEntry();
    ~CASPDirMonitorEntry();
    VOID AddRef(VOID);
    BOOL Release(VOID);

    BOOL FPathMonitored(LPCSTR  pszPath);

	// Trace Log info
	static PTRACE_LOG gm_pTraceLog;

};

BOOL RegisterASPDirMonitorEntry(LPCSTR pszDirectory, CASPDirMonitorEntry **ppDME, BOOL  fWatchSubDirs = FALSE);

BOOL ConvertToLongFileName(const char *pszPath, const char *pszName, WIN32_FIND_DATA *pwfd);

/*===================================================================
  Globals
===================================================================*/

extern CDirMonitor  *g_pDirMonitor;


#endif /* _CACHEDIRMON_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\aspdmon.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       aspdirmon.cpp

   Abstract:
       This module includes derivation of class supporting change
       notification for ASP template cache, from abstract class DIR_MON_ENTRY

   Author:

       Charles Grant    ( cgrant )     June-1997 

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "denpre.h"
#pragma hdrstop

#include "aspdmon.h"
#include "ie449.h"
#include "memchk.h"

/************************************************************
 *    Inlined Documentation on change notification
 *
 * Change Notification:
 *      This module is to used to monitor the file system for changes
 *      to scripts. We need to know about changes to scripts for two 
 *      reasons:
 *      1) To keep the template cache current
 *      2) To manage applications lifetimes. If the GLOBAL.ASA
 *          for an application, or a file included in the GLOBAL.ASA
 *          changes, that application should be restarted.
 *      
 *
 *  Outline of Change Notification System
 *
 *      To obtain change notification we use the ReadDirectoryChangesW
 *      API as wrapped by the CDirMonitor and CDirMonitorEntry classes.
 *      Three hash tables are used by the change notifcation system:
 *
 *      CTemplateCacheManager   g_TemplateCache
 *      CDirMonitor             g_DirMonitor
 *      CFileApplicationMap     g_FileAppMap
 *
 *      When a template is compiled and inserted into the g_TemplateCache
 *      the template is provided with a list of files included in that
 *      template. For each file included in the template, we search the
 *      g_DirMonitor table to see if see if we are already monitoring the
 *      files parent directory for changes. If so we simply addref the 
 *      CDirMonitorEntry instance we obtain, and save a pointer to the
 *      monitor entry in an array in the corresponding file map. If the
 *      directory is not being monitored we create a new CDirMonitorEntry'
 *      instance and add it to g_DirMonitor. When we add the monitor entry
 *      to the g_DirMonitor we launch an asynchronous request to ReadDirectoryChangesW
 *      for that directory.
 *      
 *      Managing the template cache and application life times are logically 
 *      independent activities. We must monitor GLOBAL.ASA for changes even if
 *      the GLOBAL.ASA template is not currently in the template cache.
 *      So, if the template is a GLOBAL.ASA for an application, additional work
 *      must be done. For each file included in the GLOBAL.ASA we add an entry
 *      to g_FileAppMap relating that file to the applications that depend on it.
 *      We store a back pointer to the file/application mappping in the application
 *      instance, so that the application can remove the mapping when it shuts down.
 *      In the application we store a pointer to the GLOBAL.ASA template. For
 *      each file in the GLOBAL.ASA, We check g_DirMonitor to find the monitor entry
 *      for the parent directory for that file, AddRef the monitor entry we find, and
 *      add it to a list of monitor entries in the application.
 *
 *      When a change occurs to a directory we are monitoring, the callback function
 *      DirMontiorCompletionFunction will be invoked, and in turn will invoke the
 *      the ActOnNotification method of the monitor entry for that directory. If a file
 *      has changed we use g_FileAppMap to shut down those applications that depend on
 *      that file and flush the file from the template cache.
 *
 ************************************************************/

#define MAX_BUFFER_SIZE 8192

PTRACE_LOG CASPDirMonitorEntry::gm_pTraceLog = NULL;
CDirMonitor *g_pDirMonitor=NULL;

CASPDirMonitorEntry::CASPDirMonitorEntry() : m_cNotificationFailures(0)
/*++

Routine Description:

    Constructor
    
Arguments:

    None

Return Value:

    None
--*/
{
}

CASPDirMonitorEntry::~CASPDirMonitorEntry()
/*++

Routine Description:

    Destructor
    
Arguments:

    None

Return Value:

    None
--*/
{
}


/*++
increment refcount for an entry -- writes to reftrace log if it is defined
--*/
VOID CASPDirMonitorEntry::AddRef(VOID)
	{
	CDirMonitorEntry::AddRef();
	IF_DEBUG(FCN)
		WriteRefTraceLogEx(gm_pTraceLog, m_cDirRefCount, this, PVOID(UIntToPtr(m_cIORefCount)), m_pszPath, 0);
	}

BOOL CASPDirMonitorEntry::Release(VOID)
/*++

Routine Description:

    Decrement refcount to an entry, we override the base class because
    otherwise Denali's memory manager can't track when we free the object
    and reports  it as a memory leak

Arguments:

    None

Return Value:

    TRUE if object still alive, FALSE if was last release and object
    destroyed

--*/
{
	BOOL fAlive = CDirMonitorEntry::Release();

	IF_DEBUG(FCN)
		WriteRefTraceLogEx(gm_pTraceLog, m_cDirRefCount, this, PVOID(UIntToPtr(m_cIORefCount)), m_pszPath, 0);

	return fAlive;
}


BOOL 
CASPDirMonitorEntry::ActOnNotification(
                        DWORD dwStatus, 
                        DWORD dwBytesWritten)
/*++

Routine Description:

    Do any work associated with a change notification, i.e.

Arguments:

    None

Return Value:

    TRUE if application should continue to be monitored, otherwise FALSE

--*/
{
    FILE_NOTIFY_INFORMATION *pNotify = NULL;
    FILE_NOTIFY_INFORMATION *pNextNotify = NULL;
    LPSTR                   pszScriptName = NULL; // Name of script 
    WCHAR                   *pwstrFileName = NULL; // Wide file name
    DWORD                   cch = 0;
    CWCharToMBCS            convFileName;

    pNextNotify = (FILE_NOTIFY_INFORMATION *) m_pbBuffer;

    // If the status word is not NOERROR, then the ReadDirectoryChangesW failed
    if (dwStatus)
    {
        // If the status is ERROR_ACCESS_DENIED the directory may be deleted
        // or secured so we want to stop watching it for changes. The changes to the
        // individual scripts will flush the template cache, but we may also be watching
        // the directory for the addition of a GLOBAL.ASA. By calling FileChanged on 
        // global.asa we will force that handle on the directory to close.

        if (dwStatus == ERROR_ACCESS_DENIED)
            {
            FileChanged(SZ_GLOBAL_ASA, false);
            
            // No further notificaitons desired
            // so return false
            
            return FALSE;
            }
            
        // If we return TRUE, we'll try change notification again
        // If we return FALSE, we give up on any further change notifcation
        // We'll try a MAX_NOTIFICATION_FAILURES times and give up.
        
        if (m_cNotificationFailures < MAX_NOTIFICATION_FAILURES)
        {
            IF_DEBUG(FCN)
				DBGPRINTF((DBG_CONTEXT, "[CASPDirMonitorEntry] ReadDirectoryChange failed. Status = %d\n", dwStatus));

            m_cNotificationFailures++;
            return TRUE;    // Try to get change notification again
        }
        else
        {
			IF_DEBUG(FCN)
				DBGPRINTF((DBG_CONTEXT, "[CASPDirMonitorEntry] ReadDirectoryChange failed too many times. Giving up.\n"));
            return FALSE;   // Give up trying to get change notification
        }
    }
    else
    {
        // Reset the number of notification failure
        
        m_cNotificationFailures = 0;
    }

    // If dwBytesWritten is 0, then there were more changes then could be
    // recorded in the buffer we provided. Flush the whole cache just in case
    // CONSIDER: is this the best course of action, or should iterate through the
    // cache and test which files are expired

    if (dwBytesWritten == 0)
    {
		IF_DEBUG(FCN)
			DBGPRINTF((DBG_CONTEXT, "[CASPDirMonitorEntry] ReadDirectoryChange failed, too many changes for buffer\n"));

        // Flush the 449 response file cache
        
        Do449ChangeNotification();

        // Flush everything in the cache as a precaution
        
        g_TemplateCache.FlushAll();

        // Check all applications to see if they need to be restarted

        g_ApplnMgr.RestartApplications();

		// Flush the script engine cache as a precaution (should be flushed via TemplateCache, but just in case.)

		g_ScriptManager.FlushAll();

        // Try to increase the buffer size so this doesn't happen again
        // Unfortunately the first call to ReadDirectoryChangesW on this
        // file handle establishes the buffer size. We must close and re-open
        // the file handle to change the buffer size

        if (ResetDirectoryHandle() && (GetBufferSize() < MAX_BUFFER_SIZE))
        {
        	SetBufferSize(2 * GetBufferSize());
        }

        return TRUE;
    }

    while ( pNextNotify != NULL )
    {
        pNotify        = pNextNotify;            
        pNextNotify = (FILE_NOTIFY_INFORMATION    *) ((PCHAR) pNotify + pNotify->NextEntryOffset);

        // Get the unicode file name from the notification struct
        // pNotify->FileNameLength returns the wstr's length in **bytes** not wchars

        cch = pNotify->FileNameLength / 2;

        // Convert to ANSI with uniform case and directory delimiters

        if (convFileName.Init(pNotify->FileName, CP_ACP, cch))
            continue;

        pszScriptName = convFileName.GetString();

        // Take the appropriate action for the directory change
        switch (pNotify->Action)
        {
            case FILE_ACTION_ADDED:
            case FILE_ACTION_RENAMED_NEW_NAME:
                // 'File Added' only matters for GLOBAL.ASA
				IF_DEBUG(FCN)
					DBGPRINTF((DBG_CONTEXT, "Change Notification: New file added: %s\n", pszScriptName));

                if (cch != CCH_GLOBAL_ASA || 
                    lstrcmpi(pszScriptName, SZ_GLOBAL_ASA) != 0)
                {
                    break;
                }
            case FILE_ACTION_REMOVED:
            case FILE_ACTION_MODIFIED:
            case FILE_ACTION_RENAMED_OLD_NAME:
				IF_DEBUG(FCN)
					DBGPRINTF((DBG_CONTEXT, "Change Notification: File %s: %s\n", pNotify->Action == FILE_ACTION_MODIFIED? "changed" : "removed", pszScriptName));

                FileChanged(pszScriptName, pNotify->Action != FILE_ACTION_MODIFIED);
                break;
            default:
                break;
        }
        
        if(pNotify == pNextNotify)
        {
            break;
        }  
    }
    
    // We should sign up for further change notification
    
    return TRUE;        
}

void 
CASPDirMonitorEntry::FileChanged(const char *pszScriptName, bool fFileWasRemoved)
/*++

Routine Description:

    An existing file has been modified or deleted
    Flush scripts from cache or mark application as expired

Arguments:

    pszScriptName   Name of file that changed

Return Value:

    None    Fail silently

--*/
{

    // The file name is set by the application that
    // modified the file, so old applications like EDIT
    // may hand us a munged 8.3 file name which we should
    // convert to a long name. All munged 8.3 file names contain '~'
    // We assume the path does not contain any munged names.
    WIN32_FIND_DATA wfd;

    STACK_BUFFER( tempScriptName, MAX_PATH );
    STACK_BUFFER( tempScriptPath, MAX_PATH );

	bool fRemoveMultiple = false;
	char *pT = strchr(pszScriptName, '~');
    if (pT)
    {
        
        if (ConvertToLongFileName(m_pszPath, pszScriptName, &wfd))
        {
            pszScriptName = (char *) &wfd.cFileName;
        }
        else
        {
			// It could be a long filename that was deleted, so remove everything in cache past the '~'.
			if (fFileWasRemoved)
			{
				fRemoveMultiple = true;
				DWORD cchToCopy = (DWORD)(pT - pszScriptName);

                if (!tempScriptName.Resize(cchToCopy + 1)) {
                    return;
                }
				char *szScriptNameCopy = static_cast<char *>(tempScriptName.QueryPtr());

				// copy prefix to delete into local buffer.
				strncpy(szScriptNameCopy, pszScriptName, cchToCopy);
				szScriptNameCopy[cchToCopy] = '\0';

				pszScriptName = szScriptNameCopy;
			}
			else
				return;
        }
    }

    // Allocate enough memory to concatentate the 
    // application path and script name

    DWORD cch = m_cPathLength + strlen(pszScriptName);

    if (!tempScriptPath.Resize(cch + 1)) 
        return;

    LPSTR pszScriptPath = (LPSTR) tempScriptPath.QueryPtr(); // CONSIDER using malloc
    Assert(pszScriptPath != NULL);
    
    // Copy the application path into the script path
    // pT will point to the terminator of the application path

    pT = strcpyEx(pszScriptPath, m_pszPath);

    // Now append the script name. Note that the script name is
    // relative to the directory that we received the notification for

    lstrcpy(pT, pszScriptName);
    Normalize(pszScriptPath);

    // It is important that we flush the cache and then shutdown applications
    // The call to shut down applications is asynch, and could result in the 
    // template being delted while we are in the process of flushing it.
    // CONSIDER: Is this really indicative of a ref-counting problem?
    
	if (fRemoveMultiple)
	{
		IF_DEBUG(FCN)
			DBGPRINTF((DBG_CONTEXT, "ChangeNotification: Flushing \"%s*\" from cache.\n", pszScriptPath));

		g_IncFileMap.FlushFiles(pszScriptPath);
		g_TemplateCache.FlushFiles(pszScriptPath);
		Do449ChangeNotification(NULL);   // not used often, no selective delete
	}
	else
	{
		g_IncFileMap.Flush(pszScriptPath);
		g_TemplateCache.Flush(pszScriptPath, MATCH_ALL_INSTANCE_IDS);
		Do449ChangeNotification( pszScriptPath );
	}

    // g_FileAppMap will shutdown any applications
    // that depend on this file.
    g_FileAppMap.ShutdownApplications( pszScriptPath );
}

 
BOOL CASPDirMonitorEntry::FPathMonitored(LPCSTR pszPath)
{
    if (m_fWatchSubdirectories && (strncmp(m_pszPath,pszPath, m_cPathLength) == 0)) {
        return TRUE;
    }
    return FALSE;
}

BOOL
RegisterASPDirMonitorEntry(
            LPCSTR pszDirectory,
            CASPDirMonitorEntry **ppDME,
            BOOL    fWatchSubDirs /* = FALSE */
    )
/*++

Routine Description:

    Find entry and create a new one and start monitoring
    if not found.

Arguments:

    pszDirectory - directory to monitor
    ppDNE - Found (or newly created) entry (optional)

Return Value:

    TRUE if success, otherwise FALSE

Remarks:

    Not compatible with WIN95

--*/
{
	// Keep other threads from add or removing entries while we register this one
	g_pDirMonitor->Lock();

    LPSTR  pszDirCopy = NULL;
    DWORD  len = strlen(pszDirectory);

    // see if the directory string has a trailing back-slash.  The trailing
    // slash is a requirement as the ActOnNotification code simply appends the
    // filename to this directory path.  If there isn't a trailing slash, the
    // filename and directory are munged together.

    if ( *CharPrev(pszDirectory, pszDirectory+len) != '\\')
    {

        // if not, allocate memory to make a copy of the string that
        // does include the trailing back slash

        char  *pT;

        // allocate memory to hold the string plus the trailing
        // slash and NULL char

        pszDirCopy = (LPSTR)malloc(len+2);

        // return failure if unable to allocate the memory

        if (pszDirCopy == NULL) {
            return FALSE;
        }

        // copy the directory string to the copy, append the trailing
        // backslash and NULL char

        pT = strcpyEx(pszDirCopy, pszDirectory);
        pT[0] = '\\';
        pT[1] = '\0';

        // re-assign pszDirectory to this copy

        pszDirectory = pszDirCopy;
    }
	
    // Check Existing first
    CDirMonitorEntry *pDME = g_pDirMonitor->FindEntry(pszDirectory);

    if ( pDME == NULL )
    {
        // Not found - create new entry

        pDME = new CASPDirMonitorEntry;
        
        if ( pDME )
        {
            pDME->AddRef();
     		pDME->Init(NULL);

            // Start monitoring
            if ( !g_pDirMonitor->Monitor(pDME, pszDirectory, fWatchSubDirs, FILE_NOTIFY_FILTER) )
            {
                // Cleanup if failed
                pDME->Release();
                pDME = NULL;
            }
        }
    }

    // delete the temp copy of the directory string, if allocated
    if (pszDirCopy)
        free(pszDirCopy);

    g_pDirMonitor->Unlock();

    // Return entry if found
    if ( pDME != NULL )
    {
        *ppDME = static_cast<CASPDirMonitorEntry *>(pDME);
        return TRUE;
    }
    else
    {
        *ppDME = NULL;
        return FALSE;
    }
}


BOOL 
ConvertToLongFileName(
                const char *pszPath, 
                const char *pszName, 
                WIN32_FIND_DATA *pwfd)
/*++

Routine Description:

    Finds the long filename corresponding to a munged 8.3 filename.
    
Arguments:

    pszPath     The path to the file
    pszName     The 8.3 munged version of the file name
    pwfd        Find data structure used to contain the long
                version of the file name.

Return Value:

    TRUE        if the file is found,
    FALSE       otherwise
--*/
{
    // Allocate enough memory to concatentate the file path and name

    STACK_BUFFER( tempName, MAX_PATH );

    DWORD cch = strlen(pszPath) + strlen(pszName);

    if (!tempName.Resize(cch + 1))
        return FALSE;

    char *pszFullName = (char *) tempName.QueryPtr();
    Assert(pszFullName != NULL);

    // Copy the path into the working string
    // pT will point to the terminator of the application path

    char* pT = strcpyEx(pszFullName,
                        pszPath);

    // Now append the file name. Note that the script name is
    // relative to the directory that we received the notification for

    lstrcpy(pT, pszName);


    // FindFirstFile will find using the short name
    // We can then find the long name from the WIN32_FIND_DATA

    HANDLE hFindFile = FindFirstFile(pszFullName, pwfd);
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
           return FALSE;
    }

    // Now that we have the find data we don't need the handle
    FindClose(hFindFile);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\connpt.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: IConnectionPoint implementation

File: ConnPt.h

Owner: DGottner

Implementation of IConnectionPoint
===================================================================*/

#ifndef _ConnPt_H
#define _ConnPt_H

/*
 * C C o n n e c t i o n P o i n t
 *
 * IConnectionPoint interface implementation for OLE objects
 *
 * This class contains the basic five IConnectionPoint members.  The Big Three
 * (QueryInterface, AddRef, Release) are left as pure virtual, as this
 * class is designed as an intermediate class for further derivation.
 *
 * This also means that we no longer need a pointer to the controlling unknown.
 */

#include "DblLink.h"


/*	****************************************************************************
	Class:		CConnectionPoint
	Synopsis:	Provide a reusable implementation of IConnectionPoint

    NOTE: Linked list of sinks is used because we are expecting very
          few connections. (in fact only one (Caesars))
*/

class CConnectionPoint : public IConnectionPoint
	{
	friend class CEnumConnections;

private:
	struct CSinkElem : CDblLink
		{
		DWORD		m_dwCookie;			// cookie that we assigned the connection
		IUnknown *	m_pUnkObj;			// event sink

		CSinkElem(DWORD dwCookie, IUnknown *pUnkObj)
			{
			m_dwCookie = dwCookie;
			if ((m_pUnkObj = pUnkObj) != NULL) m_pUnkObj->AddRef();
			}

		~CSinkElem()
			{
			if (m_pUnkObj) m_pUnkObj->Release();
			}
		};

	CDblLink		m_listSinks;		// list of event sinks
	DWORD			m_dwCookieNext; 	// Next cookie

protected:
	IUnknown *		m_pUnkContainer;	// pointer to parent container
	GUID			m_uidEvent;			// connection point interface

public:
	CConnectionPoint(IUnknown *, const GUID &);
	~CConnectionPoint();

	// IConnectionPoint members
	STDMETHODIMP GetConnectionInterface(GUID *);
	STDMETHODIMP GetConnectionPointContainer(IConnectionPointContainer **);
	STDMETHODIMP Advise(IUnknown *, DWORD *);
	STDMETHODIMP Unadvise(DWORD);
	STDMETHODIMP EnumConnections(IEnumConnections **);

	inline BOOL FIsEmpty()			// quick way to check if list is empty w/o allocating enumerator
		{
		return m_listSinks.FIsEmpty();
		}
	};


/*	****************************************************************************
	Class:		CEnumConnections
	Synopsis:	Provide the enumerator for CConnectionPoint
*/

class CEnumConnections : public IEnumConnections
	{
private:
	ULONG				m_cRefs;		// Reference count
	CDblLink *			m_pElemCurr;	// Current element
	CConnectionPoint *	m_pCP;			// pointer to iteratee

public:
	CEnumConnections(CConnectionPoint *pCP);
	~CEnumConnections(void);

	// The Big Three

	STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IEnumConnections members

	STDMETHODIMP Next(ULONG, CONNECTDATA *, ULONG *);
	STDMETHODIMP Skip(ULONG);
	STDMETHODIMP Reset(void);
	STDMETHODIMP Clone(IEnumConnections **);
	};

#endif _ConnPt_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\context.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: ScriptingContext object

File: Context.h

Owner: SteveBr

This file contains the header info for defining the Context object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef SCRIPTING_CONTEXT_H
#define SCRIPTING_CONTEXT_H

#include "debug.h"
#include "util.h"

#include "request.h"
#include "response.h"
#include "server.h"

#include "asptlb.h"
#include "memcls.h"

/*===================================================================
  C S c r i p t i n g C o n t e x t
===================================================================*/

class CScriptingContext : public IScriptingContextImpl
	{
private:
	// Ref count
	ULONG m_cRef; 	    

    // Intrinsics
	IApplicationObject *m_pAppln;
	ISessionObject     *m_pSession;
	IRequest           *m_pRequest;
	IResponse          *m_pResponse;
	IServer            *m_pServer;
	
	// Interface to indicate that we support ErrorInfo reporting
	CSupportErrorInfo m_ImpISuppErr;

public:
	CScriptingContext() 
	    {
	    Assert(FALSE); // Default constructor should not be used
	    }
	
	CScriptingContext
	    (
	    IApplicationObject *pAppln,
        ISessionObject     *pSession,
        IRequest           *pRequest,
        IResponse          *pResponse,
        IServer            *pServer
        );

	~CScriptingContext();
        
	// Non-delegating object IUnknown
	
	STDMETHODIMP		 QueryInterface(REFIID, PPVOID);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IScriptingContext implementation
	
	STDMETHODIMP get_Request(IRequest **ppRequest);
	STDMETHODIMP get_Response(IResponse **ppResponse);
	STDMETHODIMP get_Server(IServer **ppServer);
	STDMETHODIMP get_Session(ISessionObject **ppSession);
	STDMETHODIMP get_Application(IApplicationObject **ppApplication);

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

#endif // SCRIPTING_CONTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\context.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: ScriptingContext object

File: Context.cpp

Owner: DmitryR

This file contains the code for the implementation of the 
ScriptingContext object, which is passed to server controls
via the OnStartPage method.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "context.h"
#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

/*===================================================================
CScriptingContext::CScriptingContext

CScriptingContext constructor

Parameters:
    IApplicationObject *pAppln          Application
    ISessionObject     *pSession        Session
    IRequest           *pRequest        Request
    IResponse          *pResponse       Response
    IServer            *pServer         Server

Returns:
===================================================================*/
CScriptingContext::CScriptingContext
(
IApplicationObject *pAppln,
ISessionObject     *pSession,
IRequest           *pRequest,
IResponse          *pResponse,
IServer            *pServer
)
	: m_cRef(1),
	  m_pAppln(pAppln), m_pSession(pSession),
      m_pRequest(pRequest), m_pResponse(pResponse), m_pServer(pServer),
      m_ImpISuppErr(this, NULL, IID_IScriptingContext)
	{
	CDispatch::Init(IID_IScriptingContext);

    // AddRef Intrinsics -- they are now true COM objects
    if (m_pAppln)
        m_pAppln->AddRef();
    if (m_pSession)
        m_pSession->AddRef();
    if (m_pRequest)
        m_pRequest->AddRef();
    if (m_pResponse)
        m_pResponse->AddRef();
    if (m_pServer)
        m_pServer->AddRef();
	}

/*===================================================================
CScriptingContext::~CScriptingContext

CScriptingContext destructor

Parameters:

Returns:
===================================================================*/
CScriptingContext::~CScriptingContext()
    {
    Assert(m_cRef == 0);

    // Release Intrinsics
    if (m_pAppln)
        m_pAppln->Release();
    if (m_pSession)
        m_pSession->Release();
    if (m_pRequest)
        m_pRequest->Release();
    if (m_pResponse)
        m_pResponse->Release();
    if (m_pServer)
        m_pServer->Release();
    }

/*===================================================================
IScriptingContext Interface Methods

CScriptingContext::Application
CScriptingContext::Session
CScriptingContext::Request
CScriptingContext::Response
CScriptingContext::Server

Parameters:
	[out] Intrinsic object pointer

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CScriptingContext::get_Request(IRequest **ppRequest)
	{
	if (m_pRequest)
	    {
    	m_pRequest->AddRef();
    	*ppRequest = m_pRequest;
    	return S_OK;
    	}
    else
        {
    	*ppRequest = NULL;
    	return TYPE_E_ELEMENTNOTFOUND;
        }
	}
	
STDMETHODIMP CScriptingContext::get_Response(IResponse **ppResponse)
	{
	if (m_pResponse)
	    {
    	m_pResponse->AddRef();
    	*ppResponse = m_pResponse;
    	return S_OK;
    	}
    else
        {
    	*ppResponse = m_pResponse;
    	return TYPE_E_ELEMENTNOTFOUND;
        }
	}

STDMETHODIMP CScriptingContext::get_Server(IServer **ppServer)
	{
	if (m_pServer)
	    {
	    m_pServer->AddRef();
    	*ppServer = m_pServer;
    	return S_OK;
	    }
	else
	    {
    	*ppServer = NULL;
    	return TYPE_E_ELEMENTNOTFOUND;
	    }
	}

STDMETHODIMP CScriptingContext::get_Session(ISessionObject **ppSession)
	{
	if (m_pSession)
	    {
	    m_pSession->AddRef();
    	*ppSession = m_pSession;
    	return S_OK;
	    }
	else
	    {
    	*ppSession = NULL;
    	return TYPE_E_ELEMENTNOTFOUND;
	    }
	}

STDMETHODIMP CScriptingContext::get_Application(IApplicationObject **ppAppln)
	{
	if (m_pAppln)
	    {
	    m_pAppln->AddRef();
    	*ppAppln = m_pAppln;
    	return S_OK;
	    }
	else
	    {
    	*ppAppln = NULL;
    	return TYPE_E_ELEMENTNOTFOUND;
	    }
	}


/*===================================================================
IUnknown Interface Methods

CScriptingContext::QueryInterface
CScriptingContext::AddRef
CScriptingContext::Release
===================================================================*/
STDMETHODIMP CScriptingContext::QueryInterface
(
REFIID riid,
PPVOID ppv
)
	{
	if (riid == IID_IUnknown  ||
	    riid == IID_IDispatch ||
	    riid == IID_IScriptingContext)
	    {
        AddRef();
		*ppv = this;
		}
	else if (riid == IID_IRequest)
        {
        if (FAILED(get_Request((IRequest **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_IResponse)
        {
        if (FAILED(get_Response((IResponse **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_IServer)
        {
        if (FAILED(get_Server((IServer **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_ISessionObject)
        {
        if (FAILED(get_Session((ISessionObject **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_IApplicationObject)
        {
        if (FAILED(get_Application((IApplicationObject **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_ISupportErrorInfo)
	    {
        m_ImpISuppErr.AddRef();
		*ppv = &m_ImpISuppErr;
		}
	else
	    {
    	*ppv = NULL;
    	return E_NOINTERFACE;
        }
	    
	return S_OK;
	}

STDMETHODIMP_(ULONG) CScriptingContext::AddRef()
	{
	return ++m_cRef;
	}

STDMETHODIMP_(ULONG) CScriptingContext::Release()
	{
	if (--m_cRef)
		return m_cRef;
		
	delete this;
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\clcert.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request, Response objects

File: clcert.cpp

Owner: DGottner

This file contains the code for the implementation of the 
Request.ClientCertificate
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include <schnlsp.h>

#include "objbase.h"
#include "request.h"
#include "clcert.h"

#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

#define UUENCODEDSIZE(a)  ((((a)+3)*4)/3+1)

#define BLOB_AS_ARRAY

HRESULT
SetVariantAsByteArray(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    );

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int _pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const int _pr2six64[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};
     
char _six2pr64[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

/*------------------------------------------------------------------
 * X B F
 */

BOOL XBF::Extend( int cA )
{
    if ( cA > m_cAlloc )
    {
        int cNew = (( cA + XBF_EXTEND )/XBF_EXTEND)*XBF_EXTEND;
        LPSTR pN = (LPSTR)malloc( cNew );
        if ( pN == NULL )
        {
            return FALSE;
        }
        if ( m_cSize )
        {
            memcpy( pN, m_pV, m_cSize );
        }
        if ( m_cAlloc )
        {
            free( m_pV );
        }
        m_pV = pN;
        m_cAlloc = cNew;
    }
    return TRUE;
}

/*------------------------------------------------------------------
 * C C l C e r t S u p p o r t E r r
 */

/*===================================================================
CClCertSupportErr::CClCertSupportErr

constructor
===================================================================*/

CClCertSupportErr::CClCertSupportErr(CClCert *pClCert)
{
    m_pClCert = pClCert;
}



/*===================================================================
CClCertSupportErr::QueryInterface
CClCertSupportErr::AddRef
CClCertSupportErr::Release

Delegating IUnknown members for CClCertSupportErr object.
===================================================================*/

STDMETHODIMP CClCertSupportErr::QueryInterface(const IID &idInterface, void **ppvObj)
{
    return m_pClCert->QueryInterface(idInterface, ppvObj);
}

STDMETHODIMP_(ULONG) CClCertSupportErr::AddRef()
{
    return m_pClCert->AddRef();
}

STDMETHODIMP_(ULONG) CClCertSupportErr::Release()
{
    return m_pClCert->Release();
}



/*===================================================================
CClCertSupportErr::InterfaceSupportsErrorInfo

Report back to OA about which interfaces we support that return
error information
===================================================================*/

STDMETHODIMP CClCertSupportErr::InterfaceSupportsErrorInfo(const GUID &idInterface)
{
    if (idInterface == IID_IDispatch)
        return S_OK;

    return S_FALSE;
}



/*------------------------------------------------------------------
 * C R e a d C l C e r t
 */

/*===================================================================
CReadClCert::CReadClCert

constructor
===================================================================*/

CReadClCert::CReadClCert(CClCert *pClCert)
{
    m_pClCert = pClCert;
    CDispatch::Init(IID_IRequestDictionary);
}



/*===================================================================
CReadClCert::QueryInterface
CReadClCert::AddRef
CReadClCert::Release

Delegating IUnknown members for CReadClCert object.
===================================================================*/

STDMETHODIMP CReadClCert::QueryInterface(const IID &idInterface, void **ppvObj)
{
    return m_pClCert->QueryInterface(idInterface, ppvObj);
}

STDMETHODIMP_(ULONG) CReadClCert::AddRef()
{
    return m_pClCert->AddRef();
}

STDMETHODIMP_(ULONG) CReadClCert::Release()
{
    return m_pClCert->Release();
}


/*===================================================================
CReadClCert::get_Item

Retrieve a value in the clcert dictionary.
===================================================================*/

STDMETHODIMP CReadClCert::get_Item(VARIANT varKey, VARIANT *pVarReturn)
{
    VariantInit(pVarReturn);                // default return value is Empty
    VARIANT *pvarKey = &varKey;
    HRESULT hres;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    if (V_VT(pvarKey) != VT_BSTR) {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
    }

    switch (V_VT(pvarKey)) {
        case VT_BSTR:
            break;
        
        case VT_ERROR:
            if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND) {
                // simple value, URLEncoding NOT a good idea in this case
                if (m_pClCert->m_szValue) {
                    V_VT(pVarReturn) = VT_BSTR;
                    switch( m_pClCert->m_veType ) {
                        case VT_BSTR: {
                            BSTR bstrT;
                            if ( FAILED(SysAllocStringFromSz(m_pClCert->m_szValue, 0, &bstrT )) ) {
                                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                                VariantClear(&varKeyCopy);
                                return E_FAIL;
                            }
                            V_BSTR(pVarReturn) = bstrT;
                            break;
                        }
                                                
                        case VT_DATE:
                            V_VT(pVarReturn) = VT_DATE;
                            V_DATE(pVarReturn) = *(UNALIGNED64 DATE*)m_pClCert->m_szValue;
                            break;

                        case VT_I4:
                            V_VT(pVarReturn) = VT_I4;
                            V_I4(pVarReturn) = *(UNALIGNED64 DWORD*)m_pClCert->m_szValue;
                            break;

                        case VT_BLOB:
#if defined(BLOB_AS_ARRAY)
                            if ( FAILED( hres = SetVariantAsByteArray( pVarReturn, 
                                                                       m_pClCert->m_cLen, 
                                                                       (LPBYTE)m_pClCert->m_szValue ) ) ) {
                                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                                VariantClear(&varKeyCopy);
                                return hres;
                            }
#else
                            V_BSTR(pVarReturn) = SysAllocStringByteLen(m_pClCert->m_szValue, m_pClCert->m_cLen );
#endif
                            break;

                        default:
                            Assert( FALSE );
                    }
                }
                        
                // dictionary value, must URLEncode to prevent '&', '=' from being misinterpreted
                else {
                }

                VariantClear(&varKeyCopy);
                return S_OK;
            }

        default:
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
            VariantClear(&varKeyCopy);
            return E_FAIL;
    }
LExit:
    VariantClear(&varKeyCopy);
    return S_OK;
}

/*===================================================================
CReadClCert::get_Key

Function called from DispInvoke to get keys from the QueryString collection.

Parameters:
        vKey            VARIANT [in], which parameter to get the key of
        pvarReturn      VARIANT *, [out] value of the requested parameter

Returns:
        S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CReadClCert::get_Key(VARIANT varKey, VARIANT *pVar)
{
    return E_NOTIMPL;
}

/*===================================================================
CReadClCert::get_Count

Parameters:
        pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CReadClCert::get_Count(int *pcValues)
{
    HRESULT hrReturn = S_OK;

    *pcValues = 0;

    return hrReturn;
}

/*===================================================================
CReadClCert::get__NewEnum

Return an enumerator object.
===================================================================*/

STDMETHODIMP CReadClCert::get__NewEnum(IUnknown **ppEnum)
{
    *ppEnum = NULL;
    return E_NOTIMPL;
}



/*------------------------------------------------------------------
 * C C l C e r t
 */

/*===================================================================
CClCert::CClCert

constructor
===================================================================*/

CClCert::CClCert(IUnknown *pUnkOuter, PFNDESTROYED pfnDestroy)
    : m_ReadClCertInterface(this),
      m_ClCertSupportErrorInfo(this)
{
    m_szValue    = NULL;
    m_veType     = VT_BSTR;
    m_pfnDestroy = pfnDestroy;
    m_cRefs      = 1;
}



/*===================================================================
CClCert::~CClCert

Destructor
===================================================================*/

CClCert::~CClCert()
{
}



/*===================================================================
CClCert::Init

initialize the clcert. This initializes the clcert's value hashing
table
===================================================================*/

HRESULT CClCert::Init()
{
    return S_OK;
}



/*===================================================================
CClCert::QueryInterface
CClCert::AddRef
CClCert::Release

IUnknown members for CClCert object.

Note on CClCert::QueryInterface: The Query for IDispatch is
ambiguous because it can either refer to DIRequestDictionary or
DIWriteClCert.  To resolve this, we resolve requests for IDispatch
to IRequestDictionary.
===================================================================*/

STDMETHODIMP CClCert::QueryInterface(const IID &idInterface, void **ppvObj)
{
    if (idInterface == IID_IUnknown)
        *ppvObj = this;

    else if (idInterface == IID_IRequestDictionary || idInterface == IID_IDispatch)
        *ppvObj = &m_ReadClCertInterface;

    else if (idInterface == IID_ISupportErrorInfo)
        *ppvObj = &m_ClCertSupportErrorInfo;

    else
        *ppvObj = NULL;

    if (*ppvObj != NULL)
    {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CClCert::AddRef()
{
    return ++m_cRefs;
}


STDMETHODIMP_(ULONG) CClCert::Release(void)
{
    if (--m_cRefs != 0)
        return m_cRefs;

    if (m_pfnDestroy != NULL)
        (*m_pfnDestroy)();

    delete this;
    return 0;
}



/*===================================================================
CClCert::AddValue

Set the clcert's primary value. One you set the primary value,
you can't reset it.
===================================================================*/

HRESULT CClCert::AddValue(char *szValue, VARENUM ve, UINT l )
{
    if (m_szValue != NULL)          // clcert already is marked as single-valued
        return E_FAIL;

    m_szValue = szValue;

    m_veType = ve;
    m_cLen = l;
    return S_OK;
}



/*===================================================================
CClCert::GetHTTPClCertSize

Return the number of bytes required for the expansion of the clcert
===================================================================*/

size_t CClCert::GetHTTPClCertSize()
        {
        if (m_szValue)
                return URLEncodeLen(m_szValue);
    else
        return 1;
        }


/*===================================================================
CClCert::GetHTTPClCert

Return the URL Encoded value a single clcert

Parameters:
        szBuffer -  pointer to the destination buffer to store the
                                URL encoded value

Returns:
        Returns a pointer to the terminating NUL character.
===================================================================*/

char *CClCert::GetHTTPClCert(char *szBuffer)
{
    if (m_szValue)
        return URLEncode(szBuffer, m_szValue);

    else
    {
        char *szDest = szBuffer;
        *szDest = '\0';

        return szDest;
    }
}



/*===================================================================
CClCert::GetClCertHeaderSize

Return the number of bytes required to allocate for the "Set-ClCert" header.

Parameters:
        szName - the name of the cookie (the size of the name is added to the value)

Returns:
        Returns 0 if *this does not contain a cookie value.
===================================================================*/

size_t CClCert::GetClCertHeaderSize(const char *szName)
{
    int cbClCert = sizeof "Set-ClCert: ";           // initialize and add NUL terminator now

    // Add size of the URL Encoded name, a character for the '=', and the size
    // of the URL Encoded cookie value.  URLEncodeLen, and GetHttpClCertSize
    // compensate for the NUL terminator, so we actually SUBTRACT 1. (-2 for
    // these two function calls, +1 for the '=' sign
    //
    cbClCert += URLEncodeLen(szName) + GetHTTPClCertSize() - 1;
    
    return cbClCert;
}



/*===================================================================
CClCert::GetClCertHeader

Construct the appropriate "Set-ClCert" header for a clcert.

Parameters:
        szName - the name of the clcert (the size of the name is added to the value)

Returns:
        Returns 0 if *this does not contain a clcert value.
===================================================================*/

char *CClCert::GetClCertHeader(const char *szName, char *szBuffer)
{
    // write out the clcert name and value
    //
    char *szDest = strcpyExA(szBuffer, "Set-ClCert: ");
    szDest = URLEncode(szDest, szName);
    szDest = strcpyExA(szDest, "=");
    szDest = GetHTTPClCert(szDest);
    
    return szDest;
}



/*------------------------------------------------------------------
 * C C e r t R e q u e s t
 */


/*===================================================================
CCertRequest::AddStringPair

Add a string element in the collection

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    szValue - ptr to value as string
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT 
CCertRequest::AddStringPair( 
    CollectionType Source, 
    LPSTR szName, 
    LPSTR szValue,
    XBF *pxbf,
    BOOL fDuplicate,
    UINT lCodePage
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;

    if ( fDuplicate )
    {
        if ( (szValue = pxbf->AddStringZ( szValue )) == NULL )
        {
            return E_OUTOFMEMORY;
        }
    }

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        if ( hResult == E_FAIL )
        {
            // assume duplicate value found
            // if out of memore, OUT_OF_MEMORY would have been returned

            hResult = S_OK;
        }
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddValue( Source, szValue, NULL, lCodePage )))
    {
        return hResult;
    }

    return S_OK;
}


/*===================================================================
CCertRequest::AddDatePair

Add a date element in the collection

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    pValue - ptr to date as FILETIME
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT 
CCertRequest::AddDatePair( 
    CollectionType Source, 
    LPSTR szName, 
    FILETIME* pValue,
    XBF *pxbf
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;
    DATE Date;
    SYSTEMTIME st;
    LPBYTE pVal;

    if ( !FileTimeToSystemTime( pValue, &st ) )
    {
        return E_FAIL;
    }

    SystemTimeToVariantTime( &st, &Date );

    if ( (pVal = (LPBYTE)pxbf->AddBlob( (LPSTR)&Date, sizeof(Date) )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddCertValue( VT_DATE, pVal, sizeof(Date) )))
    {
        return hResult;
    }

    return S_OK;
}




/*===================================================================
CCertRequest::AddDwordPair

Add a DWORD element in the collection

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    pValue - ptr to date as DWORD
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT 
CCertRequest::AddDwordPair( 
    CollectionType Source, 
    LPSTR szName, 
    DWORD* pValue,
    XBF *pxbf
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;
    LPBYTE pVal;

    if ( (pVal = (LPBYTE)pxbf->AddBlob( (LPSTR)pValue, sizeof(DWORD) )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddCertValue( VT_I4, pVal, sizeof(DWORD) )))
    {
        return hResult;
    }

    return S_OK;
}




/*===================================================================
CCertRequest::AddBinaryPair

Add a binary element in the collection
Each byte is converted to UNICODE character so that mid() & asc() work

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    pValue - ptr to value as byte array
    cValue - # of bytes pointed to by pValue
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT 
CCertRequest::AddBinaryPair( 
    CollectionType Source, 
    LPSTR szName, 
    LPBYTE pValue,
    DWORD cValue,
    XBF *pxbf,
    UINT lCodePage
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;
    LPBYTE pVal;

#if defined(BLOB_AS_ARRAY)

    if ( (pVal = (LPBYTE)pxbf->ReserveRange( cValue )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    memcpy( pVal, pValue, cValue );

    pxbf->SkipRange( cValue );

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddCertValue( VT_BLOB, pVal, cValue )))
    {
        return hResult;
    }

#else

    if ( (pVal = (LPBYTE)pxbf->ReserveRange( cValue * sizeof(WCHAR), sizeof(WCHAR))) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if ( !(cValue = MultiByteToWideChar( lCodePage, 0, (LPSTR)pValue, cValue, (WCHAR*)pVal, cValue)) )
    {
        return E_FAIL;
    }

    pxbf->SkipRange( cValue * sizeof(WCHAR), sizeof(WCHAR));

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddCertValue( VT_BLOB, pVal, cValue * sizeof(WCHAR) )))
    {
            return hResult;
    }

#endif

    return S_OK;
}


BOOL IISuuencode( BYTE *   bufin,
               DWORD    nbytes,
               BYTE *   outptr,
               BOOL     fBase64 )
{
   unsigned int i;
   char *six2pr = fBase64 ? _six2pr64 : _six2pr;

   for (i=0; i<nbytes; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   /* If nbytes was not a multiple of 3, then we have encoded too
    * many characters.  Adjust appropriately.
    */
   if(i == nbytes+1) {
      /* There were only 2 bytes in that last group */
      outptr[-1] = '=';
   } else if(i == nbytes+2) {
      /* There was only 1 byte in that last group */
      outptr[-1] = '=';
      outptr[-2] = '=';
   }

   *outptr = '\0';

   return TRUE;
}

/*===================================================================
CCertRequest::AddUuBinaryPair

Add a binary element in the collection
buffer is uuencoded then converted to UNICODE character so that mid() & asc() work

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    pValue - ptr to value as byte array
    cValue - # of bytes pointed to by pValue
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT 
CCertRequest::AddUuBinaryPair( 
    CollectionType Source, 
    LPSTR szName, 
    LPBYTE pValue,
    DWORD cValue,
    XBF *pxbf,
    UINT lCodePage
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;
    LPBYTE pVal;

    if ( (pVal = (LPBYTE)pxbf->ReserveRange( UUENCODEDSIZE(cValue) )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if ( !IISuuencode( (LPBYTE)pValue, cValue, pVal, FALSE ) )
    {
        return E_FAIL;
    }

    Assert( (strlen((LPSTR)pVal)+1) <= UUENCODEDSIZE(cValue) );

    pxbf->SkipRange( strlen((LPSTR)pVal)+1 );

        if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
                return hResult;
    }

        if (FAILED(hResult = pReqHit->AddValue( Source, (LPSTR)pVal, NULL, lCodePage )))
    {
                return hResult;
    }

    return S_OK;
}


/*===================================================================
CCertRequest::AddName

Add a named entry to the collection

Parameters:
        szName - name of entry
    ppReqHit - updated with ptr to created entry
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT 
CCertRequest::AddName( 
    LPSTR szName, 
    CRequestHit **ppReqHit,
    XBF *pxbf
    )
{
    if ( (szName = pxbf->AddStringZ( szName )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    // Add this object to the Request
    CRequestHit *pRequestHit = (CRequestHit *)(pReq->CertStoreFindElem(szName, strlen(szName)));
    if (pRequestHit == NULL)
    {
        pRequestHit = new CRequestHit;
        if (pRequestHit == NULL)
        {
            return E_OUTOFMEMORY;
        }

        if (FAILED(pRequestHit->Init(szName)))
        {
            delete pRequestHit;
            return E_FAIL;
        }

        pReq->CertStoreAddElem( (CLinkElem*) pRequestHit );
    }
    else if (pRequestHit->m_pClCertData)    // a clcert by this name already exists
    {
        return E_FAIL;
    }

    if (!pReq->m_pData->m_ClCerts.AddRequestHit(pRequestHit))
    {
        return E_OUTOFMEMORY;
    }

    *ppReqHit = pRequestHit;

    return S_OK;
}


typedef struct _MAP_ASN {
    LPSTR pAsnName;
    LPSTR pTextName;
} MAP_ASN;


//
// definition of ASN.1 <> X.509 name conversion
//

MAP_ASN aMapAsn[] = {
    { szOID_COUNTRY_NAME, "C" },
    { szOID_ORGANIZATION_NAME, "O" },
    { szOID_ORGANIZATIONAL_UNIT_NAME, "OU" },
    { szOID_COMMON_NAME, "CN" },
    { szOID_LOCALITY_NAME, "L" },
    { szOID_STATE_OR_PROVINCE_NAME, "S" },
    { szOID_TITLE, "T" },
    { szOID_GIVEN_NAME, "GN" },
    { szOID_INITIALS, "I" },
    { "1.2.840.113549.1.9.1", "EMAIL" },
} ;


LPSTR MapAsnName(
    LPSTR pAsnName
    )
/*++

Routine Description:

    Convert ASN.1 name ( as ANSI string ) to X.509 member name

Arguments:

    pAsnName - ASN.1 name

Return Value:

    ptr to converted name if ASN.1 name was recognized, else ASN.1 name

--*/
{
    UINT x;
    for ( x = 0 ; x < sizeof(aMapAsn)/sizeof(MAP_ASN) ; ++x )
    {
        if ( !strcmp( pAsnName, aMapAsn[x].pAsnName ) )
        {
            return aMapAsn[x].pTextName;
        }
    }

    return pAsnName;
}


BOOL
DecodeRdn( 
    CERT_NAME_BLOB* pNameBlob,
    PCERT_NAME_INFO* ppNameInfo
    )
/*++

Routine Description:

    Create a PNAME_INFO from PNAME_BLOB

Arguments:

    pNameBlob - ptr to name blob to decode
    ppNameInfo - updated with ptr to name info

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    PCERT_NAME_INFO     pNameInfo = NULL;
    DWORD               cbNameInfo;

    if (!CryptDecodeObject(X509_ASN_ENCODING,
                          (LPCSTR)X509_NAME,
                          pNameBlob->pbData,
                          pNameBlob->cbData,
                          0,
                          NULL,
                          &cbNameInfo))
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_CERTIFICATE_BAD_CERT);
        return FALSE;
    }

    if (NULL == (pNameInfo = (PCERT_NAME_INFO)malloc(cbNameInfo)))
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        return FALSE;
    }

    if (!CryptDecodeObject(X509_ASN_ENCODING,
                           (LPCSTR)X509_NAME,
                           pNameBlob->pbData,
                           pNameBlob->cbData,
                           0,
                           pNameInfo,
                           &cbNameInfo))
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_CERTIFICATE_BAD_CERT);
        free( pNameInfo );
        return FALSE;
    }

    *ppNameInfo = pNameInfo;

    return TRUE;
}


VOID
FreeDecodedRdn(
    PCERT_NAME_INFO pNameInfo
    )
/*++

Routine Description:

    Free a PNAME_BLOB created by DecodeRdn()

Arguments:

    pNameInfo - ptr to name info created by DecodeRdn()

Return Value:

    None

--*/
{
    free( pNameInfo );
}


BOOL
BuildRdnList(
    PCERT_NAME_INFO pNameInfo,
    XBF* pxbf,
    BOOL fXt
    )
/*++

Routine Description:

    Build a clear text representation of the Rdn list in pNameInfo
    Format as "C=US, O=Ms, CN=name"

Arguments:

    pNameInfo - ptr to name info
    pxbf - ptr to buffer receiving output
    fXt - TRUE if buffer to be extended, FALSE does not extend ( buffer 
          must be big enough before calling this function or FALSE will
          be returned )

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    DWORD               cRDN;
    DWORD               cAttr;
    PCERT_RDN           pRDN;
    PCERT_RDN_ATTR      pAttr;
    BOOL                fFirst = TRUE;

    for (cRDN = pNameInfo->cRDN, pRDN = pNameInfo->rgRDN; cRDN > 0; cRDN--, pRDN++)
    {
        for ( cAttr = pRDN->cRDNAttr, pAttr = pRDN->rgRDNAttr ; cAttr > 0 ; cAttr--, ++pAttr )
        {
            if ( !fFirst )
            {
                if ( !pxbf->AddBlob( ", ", sizeof(", ")-1, fXt ) )
                {
                    return FALSE;
                }
            }
            else
            {
                fFirst = FALSE;
            }

            if ( pAttr->dwValueType == CERT_RDN_UNICODE_STRING )
            {
                INT                 iRet;
                BYTE                abBuffer[ 512 ];
                DWORD               cbNameBuffer;
                PBYTE               pNameBuffer = NULL;
                
                //
                // Need to convert unicode string to MBCS :(
                //

                iRet = WideCharToMultiByte( CP_ACP,
                                            0,
                                            (LPWSTR) pAttr->Value.pbData,
                                            -1,
                                            NULL,
                                            0,
                                            NULL,
                                            NULL );

                if ( !iRet )
                {
                    return FALSE;
                }
                else
                {
                    cbNameBuffer = (DWORD) iRet;
                    if ( (DWORD) iRet > sizeof( abBuffer ) )
                    {
                        pNameBuffer = (PBYTE) LocalAlloc( LPTR,
                                                          (DWORD) iRet );
                        if ( !pNameBuffer )
                        {
                            return FALSE;
                        }
                    }
                    else
                    {
                        pNameBuffer = abBuffer;
                    }
                }

                iRet = WideCharToMultiByte( CP_ACP,
                                            0,
                                            (LPWSTR) pAttr->Value.pbData,
                                            -1,
                                            (LPSTR) pNameBuffer,
                                            cbNameBuffer,
                                            NULL,
                                            NULL );

                if ( !iRet )
                {
                    if ( pNameBuffer != abBuffer )
                    {
                        LocalFree( pNameBuffer );
                    }
                    return FALSE;
                }

                //
                // Now stuff the MBCS string back into the blob.  I do this
                // because there is other code that re-reads and re-processes
                // the CRYPTAPI blob.  
                //

                if ( cbNameBuffer <= pAttr->Value.cbData )
                {
                    memcpy( pAttr->Value.pbData,
                            pNameBuffer,
                            cbNameBuffer );
                    pAttr->Value.cbData = cbNameBuffer;
                    pAttr->dwValueType = CERT_RDN_OCTET_STRING;
                }

                if ( pNameBuffer != abBuffer )
                {
                    LocalFree( pNameBuffer );
                    pNameBuffer = NULL;
                }
            }
            
            if ( !pxbf->AddString( MapAsnName( pAttr->pszObjId ), fXt ) ||
                 !pxbf->AddBlob( "=", sizeof("=")-1, fXt ) ||
                 !pxbf->AddString( (LPSTR) pAttr->Value.pbData, fXt ) )
            {
                return FALSE;
            }
        }
    }

    return pxbf->AddBlob( "", sizeof(""), fXt ) != NULL;
}
        

/*===================================================================
CCertRequest::ParseRDNS

Function called to parse a certificate into a OA collection

Parameters:
        pNameInfo - ptr to name structure ( cf. CAPI 2 )
    pszPrefix - prefix to prepend to members name
    pxbf - ptr to buffer to hold result

Returns:
        S_OK on success, E_OUTOFMEMORY if out of memory or E_FAIL for
    other errors
===================================================================*/

HRESULT
CCertRequest::ParseRDNS( 
    PCERT_NAME_INFO pNameInfo,
    LPSTR pszPrefix,
    XBF *pxbf,
    UINT lCodePage
    )
{
    DWORD               cRDN;
    DWORD               cAttr;
    PCERT_RDN           pRDN;
    PCERT_RDN_ATTR      pAttr;
    DWORD               cRDNs;
    DWORD               cAttrs;
    PCERT_RDN           pRDNs;
    PCERT_RDN_ATTR      pAttrs;
    LPSTR               pszFullName = NULL;
    HRESULT             hRes = S_OK;
    LPSTR               pName;
    UINT                cL;
    LPSTR               pVal = NULL;


    for (cRDN = pNameInfo->cRDN, pRDN = pNameInfo->rgRDN; cRDN > 0; cRDN--, pRDN++)
    {
        for ( cAttr = pRDN->cRDNAttr, pAttr = pRDN->rgRDNAttr ; cAttr > 0 ; cAttr--, ++pAttr )
        {
            if ( pAttr->dwValueType & 0x80000000 )
            {
                continue;
            }

            // scan for attr of same name

            pAttr->dwValueType |= 0x80000000;
            cL = 0;
            pVal = NULL;
            for ( cRDNs = cRDN, pRDNs = pRDN; 
                  cRDNs > 0; 
                  cRDNs--, pRDNs++)
            {
                for ( cAttrs = pRDNs->cRDNAttr, pAttrs = pRDNs->rgRDNAttr ; 
                      cAttrs > 0 ; 
                      cAttrs--, ++pAttrs )
                {
                    if ( !(pAttrs->dwValueType & 0x80000000) &&
                         !strcmp( pAttr->pszObjId, pAttrs->pszObjId ) )
                    {
                        cL += strlen( (LPSTR)pAttrs->Value.pbData ) + 1;
                    }                    
                }
            }

            //
            // if attributes of the same name found, concatenate their
            // values separated by ';'
            //

            if ( cL )
            {
                pVal = (LPSTR)malloc( cL + strlen((LPSTR)pAttr->Value.pbData) + 1 );
                if ( pVal == NULL )
                {
                    return E_OUTOFMEMORY;
                }
                strcpy( pVal, (LPSTR)pAttr->Value.pbData );
                for ( cRDNs = cRDN, pRDNs = pRDN; 
                      cRDNs > 0; 
                      cRDNs--, pRDNs++)
                {
                    for ( cAttrs = pRDNs->cRDNAttr, pAttrs = pRDNs->rgRDNAttr ; 
                          cAttrs > 0 ; 
                          cAttrs--, ++pAttrs )
                    {
                        if ( !(pAttrs->dwValueType & 0x80000000) &&
                             !strcmp( pAttr->pszObjId, pAttrs->pszObjId ) )
                        {
                            strcat( pVal, ";" );
                            strcat( pVal, (LPSTR)pAttrs->Value.pbData );
                            pAttrs->dwValueType |= 0x80000000;
                        }                    
                    }
                }
            }

            pName = MapAsnName( pAttr->pszObjId );
            if ( (pszFullName = (LPSTR)malloc( strlen(pszPrefix)+strlen(pName)+1 )) == NULL )
            {
                hRes = E_OUTOFMEMORY;
                goto cleanup;
            }
            strcpy( pszFullName, pszPrefix );
            strcat( pszFullName, pName );
            if ( (hRes = AddStringPair( CLCERT, 
                                        pszFullName,
                                        pVal ? pVal : (LPSTR)pAttr->Value.pbData, 
                                        pxbf,
                                        TRUE,
                                        lCodePage )) != S_OK )
            {
                if ( pVal != NULL )
                {
                    free( pVal );
                }
                goto cleanup;
            }
            if ( pVal != NULL )
            {
                free( pVal );
                pVal = NULL;
            }
            free( pszFullName );
            pszFullName = NULL;
        }
    }

cleanup:
    if ( pszFullName != NULL )
    {
        free( pszFullName );
    }

    return hRes;
}
        

/*===================================================================
CCertRequest::ParseCertificate

Function called to parse a certificate into a OA collection

Parameters:
        pspcRCI - client certificate structure

Returns:
        S_OK on success, E_OUTOFMEMORY if out of memory or E_FAIL for
    other errors
===================================================================*/

HRESULT
CCertRequest::ParseCertificate( 
    LPBYTE      pbCert,
    DWORD       cCert,
    DWORD       dwEncoding,
    DWORD       dwFlags,
    UINT        lCodePage
    )
{
    XBF                 xbf( pReq->GetCertStoreBuf(), pReq->GetCertStoreSize() );
    HRESULT             hRes = S_OK;
    PCERT_NAME_INFO     pNameInfo = NULL;
    UINT                cStore;
    UINT                x;
    LPSTR               pVal;
    PCCERT_CONTEXT      pCert;


    if (NULL == (pCert = CertCreateCertificateContext(dwEncoding,
                                                      pbCert,
                                                      cCert))) {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hRes = E_FAIL;
        goto cleanup;
    }

    // estimate size of buffer holding values

    cStore = pCert->cbCertEncoded +          // for clear text format
             sizeof("ISSUER") +
             sizeof("BINARYISSUER") + (UUENCODEDSIZE(pCert->pCertInfo->Issuer.cbData)*sizeof(WCHAR)) +
             sizeof("BINARYSUBJECT") + (UUENCODEDSIZE(pCert->pCertInfo->Subject.cbData)*sizeof(WCHAR)) +
             sizeof("SUBJECT") + ((pCert->cbCertEncoded + 2) * 2 * sizeof(WCHAR)) +     // store fields
             sizeof("CERTIFICATE") + ((pCert->cbCertEncoded +2)* sizeof(WCHAR)) +
             sizeof("SERIALNUMBER") + (pCert->pCertInfo->SerialNumber.cbData * 3) +
             sizeof("PUBLICKEY") + ((pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData+2) * sizeof(WCHAR)) +
             sizeof("VALIDFROM") + sizeof(DATE) +
             sizeof("VALIDUNTIL") + sizeof(DATE) +
             sizeof("FLAGS") + sizeof(DWORD) +
             sizeof("ENCODING") + sizeof(DWORD);
           ;

    if ( !xbf.Extend( cStore ) ) {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hRes = E_OUTOFMEMORY;
        goto cleanup;
    }

    //
    // Build Issuer clear text format & fields collection
    //

    if ( !DecodeRdn( &pCert->pCertInfo->Issuer, &pNameInfo ) )
    {
        hRes = E_FAIL;
        goto cleanup;
    }
    pVal = xbf.ReserveRange( 0 );
    if ( !BuildRdnList( pNameInfo, &xbf, FALSE ) )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hRes = E_FAIL;
        goto cleanup;
    }
    if ( (hRes = AddStringPair( CLCERT, "ISSUER", pVal, &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddUuBinaryPair( CLCERT, 
                                "BINARYISSUER", 
                                pCert->pCertInfo->Issuer.pbData, 
                                pCert->pCertInfo->Issuer.cbData, 
                                &xbf,
                                lCodePage ))!=S_OK ) {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=ParseRDNS( pNameInfo, "ISSUER", &xbf, lCodePage )) != S_OK ) {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }
    FreeDecodedRdn( pNameInfo );

    //
    // Build Subject clear text format & fields collection
    //

    if ( !DecodeRdn( &pCert->pCertInfo->Subject, &pNameInfo ) )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        return E_FAIL;
    }
    pVal = xbf.ReserveRange( 0 );
    if ( !BuildRdnList( pNameInfo, &xbf, FALSE ) )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hRes = E_FAIL;
        goto cleanup;
    }
    if ( (hRes = AddStringPair( CLCERT, "SUBJECT", pVal, &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddUuBinaryPair( CLCERT, 
                                "BINARYSUBJECT", 
                                pCert->pCertInfo->Subject.pbData, 
                                pCert->pCertInfo->Subject.cbData, 
                                &xbf,
                                lCodePage ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=ParseRDNS( pNameInfo, "SUBJECT", &xbf, lCodePage )) != S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }
    FreeDecodedRdn( pNameInfo );

    if ( (hRes=AddBinaryPair( CLCERT, "CERTIFICATE", pCert->pbCertEncoded, pCert->cbCertEncoded, &xbf, lCodePage ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    //
    //  SerialNumber 
    //  The certificate's serial number. (Decoded as a multiple byte integer. 
    //  SerialNumber.pbData[0] is the least significant byte. SerialNumber.pbData[
    //  SerialNumber.cbData - 1] is the most significant byte.)
    //
    char achSerNum[128];
    UINT cbSN;

    DBG_ASSERT(pCert->pCertInfo->SerialNumber.cbData > 1);
    cbSN = pCert->pCertInfo->SerialNumber.cbData;
    if (cbSN > 0)
    {
        cbSN--;
    }
    else
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }
    
    UINT iOffSet;
    for ( x = 0, iOffSet = 0; x < pCert->pCertInfo->SerialNumber.cbData ; ++x )
    {
        iOffSet = (cbSN-x)*3;   // start with the least significant byte
        achSerNum[iOffSet] = "0123456789abcdef"[((LPBYTE)pCert->pCertInfo->SerialNumber.pbData)[x]>>4];
        achSerNum[iOffSet+1] = "0123456789abcdef"[pCert->pCertInfo->SerialNumber.pbData[x]&0x0f];
        if ( x != 0 ) {
            achSerNum[iOffSet+2] = '-';
        }
        else
        {
            achSerNum[iOffSet+2] = '\0';
        }
    }

    if ( (hRes=AddStringPair( CLCERT, "SERIALNUMBER", achSerNum, &xbf, TRUE, lCodePage ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddBinaryPair( CLCERT, "PUBLICKEY", pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData, pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData, &xbf, lCodePage ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddDatePair( CLCERT, "VALIDFROM", &pCert->pCertInfo->NotBefore, &xbf ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddDatePair( CLCERT, "VALIDUNTIL", &pCert->pCertInfo->NotAfter, &xbf ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddDwordPair( CLCERT, "FLAGS", &dwFlags, &xbf ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddDwordPair( CLCERT, "ENCODING", &dwEncoding, &xbf ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

cleanup:
    if ( pCert )
    {
        CertFreeCertificateContext( pCert );
    }
    
    pReq->SetCertStore( xbf.QueryBuf(), xbf.QueryAllocSize() );

    xbf.Reset();

    return hRes;
}


/*===================================================================
CCertRequest::NoCertificate

Function called to create NULL certificate info into a OA collection

Parameters:
        None

Returns:
        S_OK on success, E_OUTOFMEMORY if out of memory or E_FAIL for
    other errors
===================================================================*/

HRESULT
CCertRequest::NoCertificate( 
    )
{
#if 1

    return S_OK;

#else

    XBF                 xbf( pReq->GetCertStoreBuf(), pReq->GetCertStoreSize() );
    HRESULT             hRes = S_OK;
    UINT                cStore;
    FILETIME            ft;

    // estimate size of buffer holding values

    cStore = 
             sizeof("ISSUER") + 2*sizeof(WCHAR) +
             sizeof("BINARYISSUER") + 2*sizeof(WCHAR) +
             sizeof("BINARYSUBJECT") + 2*sizeof(WCHAR) +
             sizeof("SUBJECT") + 2*sizeof(WCHAR) +
             sizeof("CERTIFICATE") + 2 * sizeof(WCHAR) +
             sizeof("SERIALNUMBER") + 2 * sizeof(WCHAR) +
             sizeof("PUBLICKEY") + 2 * sizeof(WCHAR) +
             sizeof("VALIDFROM") + sizeof(DATE) +
             sizeof("VALIDUNTIL") + sizeof(DATE)
           ;

    if ( !xbf.Extend( cStore ) )
    {
        hRes = E_OUTOFMEMORY;
        goto cleanup;
    }

    ft.dwLowDateTime = 0;
    ft.dwHighDateTime = 0;

    //
    // Build Issuer clear text format & fields collection
    //

    if ( (hRes = AddStringPair( CLCERT, "ISSUER", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes = AddStringPair( CLCERT, "BINARYISSUER", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes = AddStringPair( CLCERT, "SUBJECT", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes = AddStringPair( CLCERT, "BINARYSUBJECT", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes = AddStringPair( CLCERT, "CERTIFICATE", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddStringPair( CLCERT, "SERIALNUMBER", "", &xbf, TRUE, lCodePage ))!=S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddStringPair( CLCERT, "PUBLICKEY", "", &xbf, TRUE, lCodePage ))!=S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddDatePair( CLCERT, "VALIDFROM", &ft, &xbf ))!=S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddDatePair( CLCERT, "VALIDUNTIL", &ft, &xbf ))!=S_OK )
    {
        goto cleanup;
    }

cleanup:

    pReq->SetCertStore( xbf.QueryBuf(), xbf.QueryAllocSize() );

    xbf.Reset();

    return hRes;

#endif
}


/*===================================================================
RequestSupportTerminate

Function called to initialize certificate support

Parameters:
        None

Returns:
        TRUE on success, otherwise FALSE
===================================================================*/

BOOL 
RequestSupportInit(
    )
{
    return TRUE;
}


/*===================================================================
RequestSupportTerminate

Function called to terminate certificate support

Parameters:
        None

Returns:
        Nothing
===================================================================*/

VOID
RequestSupportTerminate(
    )
{
}


HRESULT
SetVariantAsByteArray(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    )
/*++

Routine Description:

    Create variant as byte array

Arguments:

    pVarReturn - ptr to created variant
    cbLen - byte count
    pbIn - byte array

Returns:

    COM status

--*/
{
    HRESULT         hr;
    SAFEARRAYBOUND  rgsabound[1];
    BYTE *          pbData = NULL;

    // Set the variant type of the output parameter

    V_VT(pvarReturn) = VT_ARRAY|VT_UI1;
    V_ARRAY(pvarReturn) = NULL;

    // Allocate a SafeArray for the data

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cbLen;

    V_ARRAY(pvarReturn) = SafeArrayCreate(VT_UI1, 1, rgsabound);
    if (V_ARRAY(pvarReturn) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(SafeArrayAccessData(V_ARRAY(pvarReturn), (void **) &pbData)))
    {
        return E_UNEXPECTED;
    }

    memcpy(pbData, pbIn, cbLen );

    SafeArrayUnaccessData(V_ARRAY(pvarReturn));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\cachemgr.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Template Cache Manager

File: CacheMgr.h

Owner: DGottner

Template cache manager definition
-----------------------------------------------------------------------------*/

#ifndef _CACHEMGR_H
#define _CACHEMGR_H

// Includes -------------------------------------------------------------------

#include "Template.h"
#include "lkrhash.h"
#include "aspdmon.h"

class CHitObj;


// Types and Constants --------------------------------------------------------

#define CTEMPLATEBUCKETS 1021		// size of CTemplate hash table
#define CINCFILEBUCKETS  89			// size of CIncFile hash table


/*	****************************************************************************
	Class:		CTemplateCacheManager
	Synopsis:	A CCacheManager that manages a cache of Denali templates
*/	
class CTemplateCacheManager
	{

private:
    class CTemplateHashTable;
    friend class CTemplateHashTable;

    // since there is only one CTemplateCacheManager object ever available, namely
    // g_TemplateCache, this is safe to call these two members static.

    static BOOL     m_fFailedToInitPersistCache;
    static char     m_szPersistCacheDir[MAX_PATH];

    // The type for a hash table of CTemplates keyed on instance id + name
	//
	// since we provide new methods, make parent methods uncallable
	class CTemplateHashTable :  private CTypedHashTable<CTemplateHashTable, CTemplate, const CTemplateKey *>
	{
	private:
        CDblLink m_listMemoryTemplates;
        CDblLink m_listPersistTemplates;
        DWORD    m_dwInMemoryTemplates;
        DWORD    m_dwPersistedTemplates;

        VOID     ScavengePersistCache();


	public:
		// export some methods
        DWORD InMemoryTemplates() { return m_dwInMemoryTemplates; };
		//CTypedHashTable<CTemplateHashTable, CTemplate, const CTemplateKey *>::Size;

        // test to see if the template can be persisted...
        BOOL  CanPersistTemplate(CTemplate *pTemplate);

        // trim some number of templates from the persist cache...
        BOOL  TrimPersistCache(DWORD    dwTrimCount);

		// new methods
		CTemplateHashTable()
			: CTypedHashTable<CTemplateHashTable, CTemplate, const CTemplateKey *>("ASP Template Cache") {
            m_dwInMemoryTemplates = 0;
            m_dwPersistedTemplates = 0;
            }

		static const CTemplateKey *ExtractKey(const CTemplate *pTemplate)
			{
			return pTemplate->ExtractHashKey();
			}

		// NOTE: We don't hash the pTemplateKey->nInstanceID because it can be wildcarded.
		//       if we were to include in the hash, the wildcard won't hash to the same key
		//
		static DWORD CalcKeyHash(const CTemplateKey *pTemplateKey)
			{
			return HashString(pTemplateKey->szPathTranslated, 0);
			}

		static bool EqualKeys(const CTemplateKey *pKey1, const CTemplateKey *pKey2) {
            return (_tcscmp(pKey1->szPathTranslated, pKey2->szPathTranslated) == 0) 
                    && (pKey1->dwInstanceID == pKey2->dwInstanceID 
                            || pKey1->dwInstanceID == MATCH_ALL_INSTANCE_IDS 
                            || pKey2->dwInstanceID == MATCH_ALL_INSTANCE_IDS);
        }

		// NOTE: In theory, the LKHash can help solve our ref. counting problems, by
		//       automatic addref/release.  However, since prior code uses non-refcounting
		//       data structure, it's safer to leave old code alaone in this respect, and
		//       no-op the AddRefRecord method.
		//
		static void AddRefRecord(CTemplate *pTemplate, int nIncr)
			{
			}

    	// Provide new methods to automatically manage the LRU ordering.
    	// NOTE: We used to override the methods but ran into inconsistencies (bugs?)
    	// in VC compiler. Sometimes it would call derived & sometimes the base class
    	// given the same arguemt datatypes.
		//
		LK_RETCODE InsertTemplate(CTemplate *pTemplate);

		LK_RETCODE RemoveTemplate(CTemplate *pTemplate, BOOL fPersist = FALSE);

		// NOTE: Template signature also requires const ptr to const data
		LK_RETCODE FindTemplate(const CTemplateKey &rTemplateKey, CTemplate **ppTemplate);

		// accessor methods for hidden LRU cache
		bool FMemoryTemplatesIsEmpty() const
			{
			return m_listMemoryTemplates.FIsEmpty();
			}

		// you CANNOT compare LRU nodes to NULL to know if you are at the end
		// of the list!  Instead use this member.
		//
		BOOL FMemoryTemplatesDblLinkAtEnd(CDblLink *pElem)
			{
			pElem->AssertValid();
			return pElem == &m_listMemoryTemplates;
			}

		CDblLink *MemoryTemplatesBegin()		// return pointer to last referenced item
			{
			return m_listMemoryTemplates.PNext();
			}

		CDblLink *MemoryTemplatesEnd()			// return pointer to least recently accessed item
			{
			return m_listMemoryTemplates.PPrev();
			}

		// accessor methods for hidden LRU cache
		bool FPersistTemplatesIsEmpty() const
			{
			return m_listPersistTemplates.FIsEmpty();
			}

		// you CANNOT compare LRU nodes to NULL to know if you are at the end
		// of the list!  Instead use this member.
		//
		BOOL FPersistTemplatesDblLinkAtEnd(CDblLink *pElem)
			{
			pElem->AssertValid();
			return pElem == &m_listPersistTemplates;
			}

		CDblLink *PersistTemplatesBegin()		// return pointer to last referenced item
			{
			return m_listPersistTemplates.PNext();
			}

		CDblLink *PersistTemplatesEnd()			// return pointer to least recently accessed item
			{
			return m_listPersistTemplates.PPrev();
			}
		};

	CRITICAL_SECTION	m_csUpdate;			// CS for updating the data structures
	CTemplateHashTable	*m_pHashTemplates;	// the cache data structure
    
    // Initialize the persistant template cache
    BOOL     InitPersistCache();

    // static methods primarily used from a seperate thread to flush
    // the template cache out of band from the FCN thread notification.

    static  void  FlushHashTable(CTemplateHashTable   *pTable);   
    static  DWORD __stdcall FlushHashTableThread(VOID  *pArg);

public:


	CTemplateCacheManager();
	~CTemplateCacheManager();

    inline void LockTemplateCache()   { EnterCriticalSection(&m_csUpdate); }
    inline void UnLockTemplateCache() { LeaveCriticalSection(&m_csUpdate); }

	HRESULT Init();
	HRESULT UnInit();

    HRESULT FirstHitInit() { InitPersistCache(); return S_OK; }

	// Find in cache (don't load) -- for look-aheads
	/////
    HRESULT FindCached(const TCHAR *szFile, DWORD dwInstanceID, CTemplate **ppTemplate);

	// Get a template from the cache, or load it into cache
	/////
	HRESULT Load(BOOL fRunGlobalAsp, const TCHAR *szFile, DWORD dwInstanceID, CHitObj *pHitObj, CTemplate **ppTemplate, BOOL *pfTemplateInCache);

	// Remove a template from the cache
	//   for backward compatibility, "nInstanceID" can be omitted, in which case all instance ID
	//   templates are flushed.
	/////
	void Flush(const TCHAR *szFile, DWORD dwInstanceID);

	// Remove templates from the cache that have a common prefix
	//   Instance ID is ignored.
	/////
	void FlushFiles(const TCHAR *szFilePrefix);

	// Remove all templates from the cache
	/////
	void FlushAll(VOID);

	// Add all templates that form an application to the debugger's list of
	// running documents
	/////
	void AddApplicationToDebuggerUI(CAppln *pAppln);

	// Remove all templates that form an application from the debugger's list of
	// running documents
	/////
	void RemoveApplicationFromDebuggerUI(CAppln *pAppln);

	// Get directory change notification on directories used by template
	BOOL RegisterTemplateForChangeNotification(CTemplate *pTemplate, CAppln  *pApplication);

	// Get directory change notification for applications
	BOOL RegisterApplicationForChangeNotification(CTemplate *pTemplate, CAppln *pApplication);

    // Stop getting change notification for changes to templates in the cache.
	BOOL ShutdownCacheChangeNotification();

	};



/*	****************************************************************************
	Class:		CIncFileMap
	Synopsis:	A database mapping template include files to a list of their users
*/	
class CIncFileMap
	{
	CRITICAL_SECTION	m_csUpdate;			// CS for updating the data structures
	CHashTable			m_mpszIncFile;		// the cache data structure

public:

	CIncFileMap();
	~CIncFileMap();

    inline void LockIncFileCache()   { EnterCriticalSection(&m_csUpdate); }
    inline void UnLockIncFileCache() { LeaveCriticalSection(&m_csUpdate); }

	HRESULT Init();
	HRESULT UnInit();

	HRESULT	GetIncFile(const TCHAR *szIncFile, CIncFile **ppIncFile);
	void Flush(const TCHAR *szIncFile);
	void FlushFiles(const TCHAR *szIncFilePrefix);
	};



/*	****************************************************************************
	Non-class support functions
*/
BOOL FFileChangedSinceCached(const TCHAR *szFile, FILETIME& ftPrevWriteTime);



// Globals --------------------------------------------------------------------

extern CTemplateCacheManager	g_TemplateCache;
extern CIncFileMap 				g_IncFileMap;

inline void LockTemplateAndIncFileCaches()
    {
    g_TemplateCache.LockTemplateCache();
    g_IncFileMap.LockIncFileCache();
    }

inline void UnLockTemplateAndIncFileCaches()
    {
    g_TemplateCache.UnLockTemplateCache();
    g_IncFileMap.UnLockIncFileCache();
    }


// Prototypes -----------------------------------------------------------------

#endif // _CACHEMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\cookies.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request, Response objects

File: cookies.h

Owner: DGottner

This file contains the definiton of the CCookie class, which
contains all of the state for an HTTP cookie
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "asptlb.h"
#include "dispatch.h"
#include "hashing.h"
#include "memcls.h"

class CCookie;

// Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);



/* C C o o k i e P a i r
 *
 * Implements a name/value pair in the Cookie dictionary
 */
class CCookiePair : public CLinkElem
	{
public:
	char *m_szValue;
	BOOL m_fDuplicate;		// TRUE if we have a strdup'ed copy of m_pKey, m_szValue

	HRESULT Init(const char *szKey, const char *szValue, BOOL fDuplicate = FALSE);

	CCookiePair();
	~CCookiePair();
	};
	

/*
 * C C o o k i e S u p p o r t E r r
 *
 * Implements ISupportErrorInfo for the CCookie class. The CSupportError class
 * is not adequate because it will only report a max of one interface which
 * supports error info. (We have two)
 */
class CCookieSupportErr : public ISupportErrorInfo
	{
private:
	CCookie *	m_pCookie;

public:
	CCookieSupportErr(CCookie *pCookie);

	// IUnknown members that delegate to m_pCookie
	//
	STDMETHODIMP		 QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// ISupportErrorInfo members
	//
	STDMETHODIMP InterfaceSupportsErrorInfo(const GUID &);
	};



/*
 * C W r i t e C o o k i e
 *
 * Implements IWriteCookie which is the interface that Response.Cookies
 * returns.
 */
class CWriteCookie : public IWriteCookieImpl
	{
private:
	CCookie *			m_pCookie;

public:
	CWriteCookie(CCookie *);

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const IID &rIID, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// IWriteCookie implementation
	//
	STDMETHODIMP	put_Item(VARIANT varKey, BSTR bstrValue);
	STDMETHODIMP	put_Expires(DATE dtExpires);
	STDMETHODIMP	put_Domain(BSTR bstrDomain);
	STDMETHODIMP	put_Path(BSTR bstrPath);
	STDMETHODIMP	put_Secure(VARIANT_BOOL fSecure);
	STDMETHODIMP	get_HasKeys(VARIANT_BOOL *pfHasKeys);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnum);
	};



/*
 * C R e a d C o o k i e
 *
 * Implements IReadCookie which is the interface that Request.Cookies
 * returns.
 */
class CReadCookie : public IReadCookieImpl
	{
private:
	CCookie *			m_pCookie;

public:
	CReadCookie(CCookie *);

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const IID &rIID, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// IReadCookie implementation
	//
	STDMETHODIMP			get_Item(VARIANT i, VARIANT *pVariantReturn);
	STDMETHODIMP			get_HasKeys(VARIANT_BOOL *pfHasKeys);
	STDMETHODIMP			get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP			get_Count(int *pcValues);
	STDMETHODIMP			get_Key(VARIANT VarKey, VARIANT *pvar);
	};



/*
 * C C o o k i e
 *
 * Implements CCookie, which is the object stored in the Request.Cookies
 * dictionary.
 */
class CCookie : public IUnknown
	{
	friend class CWriteCookie;
	friend class CReadCookie;
	friend class CCookieIterator;

protected:
	ULONG				m_cRefs;			// reference count
	PFNDESTROYED		m_pfnDestroy;		// To call on closure

private:
	CWriteCookie		m_WriteCookieInterface;		// implementation of IWriteCookie
	CReadCookie			m_ReadCookieInterface;		// implementation of IStringList
	CCookieSupportErr	m_CookieSupportErrorInfo;	// implementation of ISupportErrorInfo

	CIsapiReqInfo *                 m_pIReq;        // pointer to CIsapiReqInfo for this cookie
    UINT                            m_lCodePage;    // code page used for UNICODE conversions
	char *							m_szValue;	    // value of cookie when not a dictionary
	CHashTableMBStr					m_mpszValues;	// dictionary of values for the cookie
	time_t							m_tExpires;		// date & time when cookie expires
	char *							m_szDomain;		// Cookie's domain
	CHAR *							m_szPath;		// Cookie's path (If UNICODE, stored as UTF-8)
	VARIANT_BOOL					m_fSecure:1;	// does cookie require security?
	BOOL							m_fDirty:1;		// does cookie need to be sent?
	BOOL							m_fDuplicate:1;	// does cookie contain dynamically allocated string?

public:
	CCookie(CIsapiReqInfo *, UINT  lCodePage, IUnknown * = NULL, PFNDESTROYED = NULL);
	~CCookie();

	HRESULT AddValue(char *szValue, BOOL fDuplicate = FALSE);
	HRESULT AddKeyAndValue(char *szKey, char *szValue, BOOL fDuplicate = FALSE);

	size_t GetHTTPCookieSize();				// return information on how big a buffer should be
	char * GetHTTPCookie(char *szBuffer);	// return the cookie value HTTP encoded

	size_t GetCookieHeaderSize(const char *szName);				// return buffer size needed for Set-Cookie header
	char *GetCookieHeader(const char *szName, char *szBuffer);	// return cookie header

	BOOL IsDirty() { return m_fDirty; }

	HRESULT		Init();

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const GUID &Iid, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};



/*
 * C C o o k i e I t e r a t o r
 *
 * IEnumVariant implementation for Cookie dictionaries
 */

class CCookieIterator : public IEnumVARIANT
	{
public:
	CCookieIterator(CCookie *pCookie);
	~CCookieIterator();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG m_cRefs;					// reference count
	CCookie *m_pCookie;				// pointer to iteratee
	CCookiePair *m_pCurrent;		// pointer to current item
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\compcol.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Component Collection

File: Compcol.cpp

Owner: DmitryR

This is the Component Collection source file.

Component collection replaces:  (used in:)
COleVar, COleVarList            (HitObj, Session, Application)
CObjectCover                    (HitObj, Server, Session)
VariantLink HasTable            (Session, Application)
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "Context.h"
#include "MTAcb.h"
#include "Request.h"
#include "Response.h"
#include "Server.h"
#include "tlbcache.h"
#include "memchk.h"

/*===================================================================
  Defines for hash table sizes
===================================================================*/

#define HT_TAGGED_OBJECTS_BUCKETS_MAX   19
#define HT_PROPERTIES_BUCKETS_MAX       17
#define HT_IUNKNOWN_PTRS_BUCKETS_MAX    23

#define HT_PAGE_OBJECTS_BUCKETS_MAX     17

/*===================================================================
  Static utility function prototypes
===================================================================*/

static HRESULT QueryOnPageInfo
    (
    IDispatch *pDisp,
    COnPageInfo *pOnPageInfo
    );

static HRESULT CLSIDToMultibyteString
    (
    CLSID ClsId,
    char *psz,
    int cch
    );

#define REG_MODEL_TEXT_LEN_MAX  20  // big enough for "Apartment"
static CompModel RegStrToCompModel
    (
    BYTE *pb,
    DWORD cb
    );

/*===================================================================
  Static utility functions code
===================================================================*/

/*===================================================================
QueryOnPageInfo

Query dispatch ids for OnStartPage and OnEndPage

Parameters:
    IDispatch   *pDisp              Object to query
    COnPageInfo *pOnPageInfo        Struct to fill in

Returns:
    HRESULT
===================================================================*/
HRESULT QueryOnPageInfo
(
IDispatch   *pDisp,
COnPageInfo *pOnPageInfo
)
    {
    static LPOLESTR BStrEntryPoints[ONPAGE_METHODS_MAX] =
        {
        L"OnStartPage",
        L"OnEndPage"
        };

    HRESULT hr = S_OK;
    for (int i = 0; i < ONPAGE_METHODS_MAX; i++)
        {
        hr = pDisp->GetIDsOfNames
            (
            IID_NULL,
            &BStrEntryPoints[i],
            1,
            LOCALE_SYSTEM_DEFAULT,
            &pOnPageInfo->m_rgDispIds[i]
            );
        if (FAILED(hr))
            {
            if (hr != DISP_E_UNKNOWNNAME &&
                hr != DISP_E_MEMBERNOTFOUND)
                {
                break;
                }

            // If UNKNOWNNAME, set dispid to DISPID_UNKNOWN
            hr = S_OK;
            pOnPageInfo->m_rgDispIds[i] = DISPID_UNKNOWN;
            }
        }
    return hr;
    }

/*===================================================================
CLSIDToMultibyteString

Converts CLSID into multibyte string
Used in CompModelFromCLSID

Parameters:
    CLSID  ClsId     (in) CLSID to convert
    char  *pb        put string into this buffer
    int    cch       of this length

Returns:
    HRESULT
===================================================================*/
HRESULT CLSIDToMultibyteString
(
CLSID  ClsId,
char  *psz,
int    cch
)
    {
    // First convert it to OLECHAR string
    OLECHAR *pszWideClassID = NULL; // temp wide string classid
    HRESULT hr = StringFromCLSID(ClsId, &pszWideClassID);
    if (FAILED(hr))
        return hr;

    // OLECHAR to MultiByte
    BOOL f = WideCharToMultiByte
        (
        CP_ACP,         // code page
        0,              // performance and mapping flags
        pszWideClassID, // address of wide-character string
        -1,             // length (-1 == null-terminated)
        psz,            // address of buffer for new string
        cch,            // size of buffer for new string
        NULL,           // address of default for unmappable
                        //      characters; quickest if null
        NULL            // address of flag set when default
                        //      char. used; quickest if null
        );
    if (f == FALSE)
        hr = E_FAIL;

    if (pszWideClassID)
        CoTaskMemFree(pszWideClassID);
    return hr;
    }

/*===================================================================
RegStrToCompModel

Get CompModel value from a registry string

Parameters:
    char  *pb        string as returned from registry
    int    cb        length returned from registry

Returns:
    HRESULT
===================================================================*/
CompModel RegStrToCompModel
(
BYTE *pb,
DWORD cb
)
    {
    CompModel cmModel = cmSingle; // assume single

    if (cb == 5)  // 5 include '\0'
        {
        if (!(_strnicmp((const char*)pb, "Both", cb)))
            cmModel = cmBoth;
        else if (!(_strnicmp((const char*)pb, "Free", cb)))
            cmModel = cmFree;
        }
    else if (cb == 10)  // 10 include '\0'
        {
        if (!(_strnicmp((const char*)pb, "Apartment", cb)))
            cmModel = cmApartment;
        }

    return cmModel;
    }

/*===================================================================
  Public utility functions code
===================================================================*/

/*===================================================================
CompModelFromCLSID

Get object's model and InProc flag by its CLSID from the registry

Parameters:
    CLSID     &ClsId       (in)
    CompModel *pcmModel    (out) Model (optional)
    BOOL      *pfInProc    (out) InProc flag (optional)

Returns:
    CompModel (cmFree, cmBoth, etc.)
===================================================================*/
HRESULT CompModelFromCLSID
(
const CLSID &ClsId,
CompModel   *pcmModel,
BOOL        *pfInProc
)
    {
    if (!Glob(fTrackThreadingModel) && !pfInProc)
        {
        // ignore registry value for threading model and
        // inproc flag is not requested -> take short return
        if (pcmModel)
            *pcmModel = cmUnknown;
        return S_OK;
        }

    // default returns
    CompModel cmModel  = cmSingle;   // assume single
    BOOL      fInProc  = TRUE;       // assume inproc

    HRESULT hr = S_OK;

    // Convert ClsId to multibyte string

    char szClassID[50];
    hr = CLSIDToMultibyteString(ClsId, szClassID, sizeof(szClassID));
    if (FAILED(hr))
        return hr;

    /*  query the registry; threading model is stored as:
        HKEY_CLASSES_ROOT
          key: CLSID
            key: <object's classid>
              key: InprocServer32
                name: ThreadingModel data: "Both" | "Apartment"
    */

    // Navigate the registry to "InprocServer32" key

    HKEY hKey1 = NULL;  // handle of open reg key
    HKEY hKey2 = NULL;  // handle of open reg key
    HKEY hKey3 = NULL;  // handle of open reg key

    if (SUCCEEDED(hr))
        {
        int nRet = RegOpenKeyExA
            (
            HKEY_CLASSES_ROOT,
            "CLSID",
            0,
            KEY_READ,
            &hKey1
            );
        if (nRet != ERROR_SUCCESS)
            hr = E_FAIL;
        }

    if (SUCCEEDED(hr))
        {
        int nRet = RegOpenKeyExA
            (
            hKey1,
            szClassID,
            0,
            KEY_READ,
            &hKey2
            );
        if (nRet != ERROR_SUCCESS)
            hr = E_FAIL;
        }

    // Get the stuff from the registry "InprocServer32" key

    if (SUCCEEDED(hr))
        {
        int nRet = RegOpenKeyExA
            (
            hKey2,
            "InprocServer32",
            0,
            KEY_READ,
            &hKey3
            );
        if (nRet == ERROR_SUCCESS)
            {
            DWORD cbData = REG_MODEL_TEXT_LEN_MAX;
            BYTE  szData[REG_MODEL_TEXT_LEN_MAX];

            nRet = RegQueryValueExA
                (
                hKey3,
                "ThreadingModel",
                NULL,
                NULL,
                szData,
                &cbData
                );
            if (nRet == ERROR_SUCCESS)
                cmModel = RegStrToCompModel(szData, cbData);

            if (cmModel == cmBoth)
                {
                // Some objects marked as "Both" ASP treats as
                // "Apartment". These objects should be marked in
                // the registry as "ASPComponentNonAgile"

                nRet = RegQueryValueExA
                    (
                    hKey3,
                    "ASPComponentNonAgile",
                    NULL,
                    NULL,
                    szData,
                    &cbData
                    );

                // If the key is found pretend it's "apartment"
                if (nRet == ERROR_SUCCESS)
                    cmModel = cmApartment;
                }
            }
        else
            {
            // if there is no InprocServer32 key,
            // then it must be a localserver or remote server.
            fInProc = FALSE;
            }
        }

    // clean up registry keys
    if (hKey3)
        RegCloseKey(hKey3);
    if (hKey2)
        RegCloseKey(hKey2);
    if (hKey1)
        RegCloseKey(hKey1);

    // return values
    if (pcmModel)
        *pcmModel = Glob(fTrackThreadingModel) ? cmModel : cmUnknown;
    if (pfInProc)
        *pfInProc = fInProc;

    return hr;
    }

/*===================================================================
FIsIntrinsic

Checks if the given IDispatch * points to an ASP intrinsic.

Parameters:
    pdisp       pointer to check

Returns:
    TRUE if Intrinsic
===================================================================*/
BOOL FIsIntrinsic
(
IDispatch *pdisp
)
    {
    if (!pdisp)
        return FALSE; // null dispatch pointer - not an intrinsic

    IUnknown *punk = NULL;
    if (FAILED(pdisp->QueryInterface(IID_IDenaliIntrinsic, (void **)&punk)))
        return FALSE;

    Assert(punk);
    punk->Release();
    return TRUE;
    }

/*===================================================================
FIsSimpleVariant

Checks if the given VARIANT is a simple one

Parameters:
    pvar       variant to check

Returns:
    TRUE if [for sure] simple, FALSE if [possibly] not
===================================================================*/
inline FIsSimpleVariant(VARIANT *pvar)
    {
    switch (V_VT(pvar))
        {
    case VT_BSTR:
    case VT_I2:
    case VT_I4:
    case VT_BOOL:
    case VT_DATE:
    case VT_R4:
    case VT_R8:
        return TRUE;
        }
    return FALSE;
    }


/*===================================================================
  C  C o m p o n e n t  O b j e c t
===================================================================*/

/*===================================================================
CComponentObject::CComponentObject

CComponentObject constructor

Parameters:
    CompScope scScope       Object scope
    CompType  ctType        Object type
    CompModel cmModel       Object threading model

Returns:
===================================================================*/
CComponentObject::CComponentObject
(
CompScope scScope,
CompType  ctType,
CompModel cmModel
)
    :
    m_csScope(scScope), m_ctType(ctType), m_cmModel(cmModel),
    m_fAgile(FALSE),
    m_fOnPageInfoCached(FALSE),
    m_fOnPageStarted(FALSE),
    m_fFailedToInstantiate(FALSE), m_fInstantiatedTagged(FALSE),
    m_fInPtrCache(FALSE),
    m_fVariant(FALSE),
    m_fNameAllocated(FALSE),
    m_dwGIPCookie(NULL_GIP_COOKIE),
    m_pDisp(NULL), m_pUnknown(NULL),
    m_pCompNext(NULL), m_pCompPrev(NULL)
    {
    }

#ifdef DBG
/*===================================================================
CComponentObject::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CComponentObject::AssertValid() const
    {
    Assert(m_ctType != ctUnknown);
    }
#endif

/*===================================================================
CComponentObject::~CComponentObject

CComponentObject destructor
Releases interface pointers

Parameters:

Returns:
===================================================================*/
CComponentObject::~CComponentObject()
    {
    // Release all interface pointers
    Clear();

    // Name used in hash (from CLinkElem)
    if (m_fNameAllocated)
        {
        Assert(m_pKey);
        free(m_pKey);
        }
    }

/*===================================================================
CComponentObject::Init

Initialize CLinkElem portion with the object name
Needed to implement string hash

Parameters:
    LPWSTR pwszName      object name
    DWORD  cbName        name length in bytes

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::Init
(
LPWSTR pwszName,
DWORD  cbName
)
    {
    Assert(pwszName);
    Assert(*pwszName != L'\0');
    Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

    // required buffer length
    DWORD cbBuffer = cbName + sizeof(WCHAR);
    WCHAR *pwszNameBuffer = (WCHAR *)m_rgbNameBuffer;

    if (cbBuffer > sizeof(m_rgbNameBuffer))
        {
        // the name doesn't fit into the member buffer -> allocate
        pwszNameBuffer = (WCHAR *)malloc(cbBuffer);
        if (!pwszNameBuffer)
            return E_OUTOFMEMORY;
        m_fNameAllocated = TRUE;
        }

    memcpy(pwszNameBuffer, pwszName, cbBuffer);

    // init link with name as the key (length excludes null term)
    return CLinkElem::Init(pwszNameBuffer, cbName);
    }

/*===================================================================
CComponentObject::ReleaseAll

Releases all interface pointers

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::ReleaseAll()
    {
    // Release all other present interface pointers
    if (m_pDisp)
        {
        m_pDisp->Release();
        m_pDisp = NULL;
        }
    if (m_pUnknown)
        {
        m_pUnknown->Release();
        m_pUnknown = NULL;
        }

    // Variant
    if (m_fVariant)
        {
        VariantClear(&m_Variant);
        m_fVariant = FALSE;
        }

    if (m_dwGIPCookie != NULL_GIP_COOKIE)
        {
        g_GIPAPI.Revoke(m_dwGIPCookie);
        m_dwGIPCookie = NULL_GIP_COOKIE;
        }

    return S_OK;
    }

/*===================================================================
CComponentObject::Clear

Clears out data leaving link alone

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::Clear()
    {
    // Release all pointers
    TRY
        ReleaseAll();
    CATCH(nExcept)
        Assert(FALSE);
        m_pDisp = NULL;
        m_pUnknown = NULL;
        m_fVariant = FALSE;
        m_dwGIPCookie = NULL_GIP_COOKIE;
    END_TRY

    // Invalidate cached OnPageInfo
    m_fOnPageInfoCached = FALSE;
    m_fOnPageStarted = FALSE;

    // Mark it as unknown
    m_csScope = csUnknown;
    m_ctType  = ctUnknown;
    m_cmModel = cmUnknown;
    m_fAgile = FALSE;

    return S_OK;
    }

/*===================================================================
CComponentObject::Instantiate

Create object instance if it's not there already
Calls TryInstantiate() from within TRY CATCH

Parameters:
    CHitObj *pHitObj    Hit object for error reporting

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::Instantiate
(
CHitObj *pHitObj
)
    {
    HRESULT hr = S_OK;

    if (Glob(fExceptionCatchEnable))
        {
        TRY
            hr = TryInstantiate(pHitObj);
        CATCH(nExcept)
            HandleErrorMissingFilename(IDE_SCRIPT_OBJ_INSTANTIATE_FAILED,
                                       pHitObj,
                                       TRUE,
                                       GetName(),
                                       nExcept);
            hr = nExcept;
        END_TRY
        }
    else
        {
        hr = TryInstantiate(pHitObj);
        }

    if (FAILED(hr))
        {
        // Something failed -- need to clean-up
        ReleaseAll();

        // mark as "failed to instantiate"
        m_fFailedToInstantiate = TRUE;
        }

    return hr;
    }

/*===================================================================
CComponentObject::TryInstantiate

Create object instance if it's not there already
Called by Instantiate() from within TRY CATCH

Parameters:
    CHitObj *pHitObj    Hit object for error reporting


Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::TryInstantiate
(
CHitObj *pHitObj
)
    {
    // Check if the object already exist
    if (m_pUnknown)
        return S_OK;

    if (m_fFailedToInstantiate)
        return E_FAIL;  // already tried once

    if (m_cmModel == cmUnknown && m_ClsId != CLSID_NULL)
        {
        CompModel cmModel;  // needed because m_cmModel is a bit fld
        HRESULT hr = CompModelFromCLSID(m_ClsId, &cmModel);
		if (FAILED(hr))
			return hr;
        m_cmModel = cmModel;
        }

    HRESULT hr = ViperCreateInstance
        (
        m_ClsId,
        IID_IUnknown,
        (void **)&m_pUnknown
        );

    // If we failed because we incorrectly cached the clsid
    // (could happen for tagged objects) try to get updated
    // cls id and retry
    if (m_ctType == ctTagged && FAILED(hr))
        {
        if (g_TypelibCache.UpdateMappedCLSID(&m_ClsId) == S_OK)
            {
            hr = ViperCreateInstance
                (
                m_ClsId,
                IID_IUnknown,
                (void **)&m_pUnknown
                );
            }
        }

    if (SUCCEEDED(hr))
        {
        if (Glob(fTrackThreadingModel) && m_cmModel == cmBoth)
            m_fAgile = TRUE;
        else
            m_fAgile = ViperCoObjectAggregatesFTM(m_pUnknown);

        hr = m_pUnknown->QueryInterface
            (
            IID_IDispatch,
            (void **)&m_pDisp
            );
        }

    // Check if application level object that
    // restricts threading -> use Global Interface Cookie

    if (SUCCEEDED(hr)
        && (m_csScope == csAppln || m_csScope == csSession)
        && !m_fAgile)
        {
        return ConvertToGIPCookie();
        }

    if (SUCCEEDED(hr) && !m_fOnPageInfoCached)
        {
        // don't really care if the following fails
        GetOnPageInfo();
        }

    return hr;
    }

/*===================================================================
CComponentObject::SetPropertyValue

Sets value from a Variant
Checks agility and possible deadlocks
Does GIP conversion

Parameters:
    VARIANT *pVariant       [in]  Value to set

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::SetPropertyValue
(
VARIANT *pVariant
)
    {
    Assert(m_ctType == ctProperty);

    HRESULT hr = S_OK;

    // Copy the variant value
    VariantInit(&m_Variant);
    m_fVariant = TRUE;

    hr = VariantCopyInd(&m_Variant, pVariant);
    if (FAILED(hr))
        return hr;

    // Get IDispatch pointer
    if (V_VT(&m_Variant) == VT_DISPATCH)
        {
        m_pDisp = V_DISPATCH(&m_Variant);
        }
    else
        {
        m_pDisp = NULL;
        }

    if (!m_pDisp)
        {
        m_fAgile = TRUE; // not VT_DISPATCH VARIANTs are agile
        return S_OK;
        }

    m_pDisp->AddRef();

    // Query (and cache) OnPageInfo inside TRY CATCH
    if (Glob(fExceptionCatchEnable))
        {
        TRY
            hr = GetOnPageInfo();
        CATCH(nExcept)
            hr = E_UNEXPECTED;
        END_TRY
        }
    else
        {
        hr = GetOnPageInfo();
        }

    // Don't really care if failed
    hr = S_OK;

    // Check if the assigned object is agile
    m_fAgile = ViperCoObjectAggregatesFTM(m_pDisp);

    if (Glob(fTrackThreadingModel) && !m_fAgile)
        {
        // doesn't mean it really isn't. could be one of
        // our objects marked as 'both'
        CComponentObject *pObjCopyOf = NULL;

        hr = CPageComponentManager::FindComponentWithoutContext
            (
            m_pDisp,
            &pObjCopyOf
            );

        if (hr == S_OK)
            {
            m_fAgile = pObjCopyOf->FAgile();
            }

        // end of getting of agile flag from the original object
        hr = S_OK; // even if object was not found
        }

    // Decide whether to use GIP and if invalid assignment
    // Applies only to non-agile application objects

    if (!m_fAgile && (m_csScope == csAppln || m_csScope == csSession))
        {
        if (!ViperCoObjectIsaProxy(m_pDisp) && (m_csScope == csAppln)) // deadlocking?
            {
            m_pDisp->Release();
            m_pDisp = NULL;
            VariantClear(&m_Variant);
            hr = RPC_E_WRONG_THREAD; // to tell the caller the error
            }
        else
            {
            // use GIP
            hr = ConvertToGIPCookie();
            }
        }

    return hr;
    }

/*===================================================================
CComponentObject::ConvertToGIPCookie

Convert Object to be GIP cookie. Release all pointers

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::ConvertToGIPCookie()
    {
    Assert(m_pDisp);  // has to have dispatch pointer

    if (!FIsWinNT())
        {
        // No GIPs on Win95
        // On Win95 everything is on the same thread
        // -> it is ok for the objects stay as pointers
        return S_OK;
        }

    DWORD dwCookie = NULL_GIP_COOKIE;
    HRESULT hr = g_GIPAPI.Register(m_pDisp, IID_IDispatch, &dwCookie);

    if (SUCCEEDED(hr))
        {
        Assert(dwCookie != NULL_GIP_COOKIE);

        // Release all pointeres
        ReleaseAll();

        // Store the cookie instead
        m_dwGIPCookie = dwCookie;
        }

    return hr;
    }

/*===================================================================
CComponentObject::GetOnPageInfo

Query dispatch ids for OnStartPage and OnEndPage
Calls static QueryOnPageInfo

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::GetOnPageInfo()
    {
    Assert(m_pDisp);

    HRESULT hr = QueryOnPageInfo(m_pDisp, &m_OnPageInfo);

    if (SUCCEEDED(hr))
        m_fOnPageInfoCached = TRUE;

    return hr;
    }

/*===================================================================
CComponentObject::GetAddRefdIDispatch

Get AddRef()'d Dispatch *
Handles the Global Interface Ole Cookies

Parameters:
    Dispatch **ppdisp    output

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::GetAddRefdIDispatch
(
IDispatch **ppdisp
)
    {
    Assert(ppdisp);

    if (m_pDisp)
        {
        *ppdisp = m_pDisp;
        (*ppdisp)->AddRef();
        return S_OK;
        }

    // try to restore from cookie
    if (m_dwGIPCookie != NULL_GIP_COOKIE)
        {
        // Even if IUnknown * needs to be returned,
        // Ask for IDispatch *, because IDispatch * is the one
        // that was put in by CoGetInterfaceFromGlobal()

        HRESULT hr = g_GIPAPI.Get
            (
            m_dwGIPCookie,
            IID_IDispatch,
            (void **)ppdisp
            );

        if (SUCCEEDED(hr))
            return S_OK;
        }

    *ppdisp = NULL;
    return E_NOINTERFACE;
    }

/*===================================================================
CComponentObject::GetAddRefdIUnknown

Get AddRef()'d IUnknown *
Handles the Global Interface Ole Cookies

Parameters:
    IUnknown **ppunk    output

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::GetAddRefdIUnknown
(
IUnknown **ppunk
)
    {
    Assert(ppunk);

    if (m_pUnknown)
        {
        *ppunk = m_pUnknown;
        (*ppunk)->AddRef();
        return S_OK;
        }

    // Use IDispatch (from cookie)

    IDispatch *pDisp = NULL;
    if (SUCCEEDED(GetAddRefdIDispatch(&pDisp)))
        {
        *ppunk = pDisp;  // IDispatch implements IUnknown
        return S_OK;
        }

    *ppunk = NULL;
    return E_NOINTERFACE;
    }

/*===================================================================
CComponentObject::GetVariant

Get object's values as variant
Handles the Global Interface Ole Cookies

Parameters:
    VARIANT *pVar       [out]  Variant filled in with object value

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::GetVariant
(
VARIANT *pVar
)
    {
    HRESULT hr = S_OK;

    VariantInit(pVar); // default variant empty

    if (m_fVariant)
        {
        // already has variant
        hr = VariantCopyInd(pVar, &m_Variant);
        }
    else if (m_pDisp)
        {
        // create variant from IDispatch*
        m_pDisp->AddRef();

        V_VT(pVar) = VT_DISPATCH;
        V_DISPATCH(pVar) = m_pDisp;
        }
    else if (m_dwGIPCookie != NULL_GIP_COOKIE)
        {
        // create variant from cookie
        IDispatch *pDisp = NULL;
        hr = g_GIPAPI.Get(m_dwGIPCookie, IID_IDispatch, (void **)&pDisp);

        if (SUCCEEDED(hr))
            {
            V_VT(pVar) = VT_DISPATCH;
            V_DISPATCH(pVar) = pDisp;
            }
        }
    else
        {
        // nowhere to get the VARIANT value from
        hr = E_POINTER;
        }

    return hr;
    }


/*===================================================================
  C  P a g e  O b j e c t
===================================================================*/

/*===================================================================
CPageObject::CPageObject

CPageObject constructor

Parameters:

Returns:
===================================================================*/
CPageObject::CPageObject()
    : m_pDisp(NULL),
      m_fStartPageCalled(FALSE), m_fEndPageCalled(FALSE)
    {
    }

#ifdef DBG
/*===================================================================
CPageObject::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CPageObject::AssertValid() const
    {
    Assert(m_pDisp);
    }
#endif

/*===================================================================
CPageObject::~CPageObject

CPageObject destructor

Parameters:

Returns:
===================================================================*/
CPageObject::~CPageObject()
    {
    // Release interface pointer
    if (m_pDisp)
        {
        m_pDisp->Release();
        m_pDisp = NULL;
        }
    }

/*===================================================================
CPageObject::Init

Initialize CLinkElem portion with the IDispatch pointer
Needed to implement string hash

Parameters:
    IDispatch   *pDisp          dispatch pointer (AddRef()ed)
    COnPageInfo *pOnPageInfo    OnStartPage, OnEndPage Ids

Returns:
    HRESULT
===================================================================*/
HRESULT CPageObject::Init
(
IDispatch   *pDisp,
const COnPageInfo &OnPageInfo
)
    {
    Assert(pDisp);

    m_pDisp = pDisp;
    m_OnPageInfo = OnPageInfo;

    m_fStartPageCalled = FALSE;
    m_fEndPageCalled   = FALSE;

    return S_OK;
    }

/*===================================================================
CPageObject::InvokeMethod

Invokes OnPageStart() or OnPageEnd()

Parameters:
    DWORD iMethod                   which method
    CScriptingContext *pContext     scripting context (for OnStart)
    CHitObj *pHitObj                HitObj for errors

Returns:
    HRESULT
===================================================================*/
HRESULT CPageObject::InvokeMethod
(
DWORD iMethod,
CScriptingContext *pContext,
CHitObj *pHitObj
)
    {
    BOOL fOnStart = (iMethod == ONPAGEINFO_ONSTARTPAGE);

    // check if method exists
    if (m_OnPageInfo.m_rgDispIds[iMethod] == DISPID_UNKNOWN)
        return S_OK;

    // two OnStart in a row - BAD
    Assert(!(fOnStart && m_fStartPageCalled));

    // two OnEnd in a row - BAD
    Assert(!(!fOnStart && m_fEndPageCalled));

    Assert(m_pDisp);

    HRESULT hr = S_OK;

    if (Glob(fExceptionCatchEnable))
        {
        // Call method inside TRY CATCH
        TRY
            hr = TryInvokeMethod
                (
                m_OnPageInfo.m_rgDispIds[iMethod],
                fOnStart,
                pContext,
                pHitObj
                );
        CATCH(nExcept)
            if (fOnStart)
                ExceptionId
                    (
                    IID_IObjectCover,
                    IDE_COVER,
                    IDE_COVER_ON_START_PAGE_GPF
                    );
            else
                HandleErrorMissingFilename
                    (
                    IDE_COVER_ON_END_PAGE_GPF,
                    pHitObj
                    );
            hr = E_UNEXPECTED;
        END_TRY
        }
    else
        {
        // don't CATCH
        hr = TryInvokeMethod
            (
            m_OnPageInfo.m_rgDispIds[iMethod],
            fOnStart,
            pContext,
            pHitObj
            );
        }

    if (fOnStart)
        m_fStartPageCalled = TRUE;
    else
        m_fEndPageCalled = TRUE;

    return hr;
    }

/*===================================================================
CPageObject::TryInvokeMethod

Invokes OnPageStart() or OnPageEnd()

Parameters:
    DISPID     DispId           method's DISPID
    BOOL       fOnStart         TRUE if invoking OnStart
    IDispatch *pDispContext     scripting context (for OnStart)
    CHitObj   *pHitObj          HitObj for errors

Returns:
    HRESULT
===================================================================*/
HRESULT CPageObject::TryInvokeMethod
(
DISPID     DispId,
BOOL       fOnStart,
IDispatch *pDispContext,
CHitObj   *pHitObj
)
    {
    EXCEPINFO   ExcepInfo;
    DISPPARAMS  DispParams;
    VARIANT     varResult;
    VARIANT     varParam;
    UINT        nArgErr;

    memset(&DispParams, 0, sizeof(DISPPARAMS));
    memset(&ExcepInfo, 0, sizeof(EXCEPINFO));

    if (fOnStart)
        {
        VariantInit(&varParam);
        V_VT(&varParam) = VT_DISPATCH;
        V_DISPATCH(&varParam) = pDispContext;

        DispParams.rgvarg = &varParam;
        DispParams.cArgs = 1;
        }

    VariantInit(&varResult);

    // Invoke it

    HRESULT hr = m_pDisp->Invoke
        (
        DispId,          // Call method
        IID_NULL,        // REFIID - Reserved, must be NULL
        NULL,            // Locale id
        DISPATCH_METHOD, // Calling a method, not a property
        &DispParams,     // pass arguments
        &varResult,      // return value
        &ExcepInfo,      // exeption info on failure
        &nArgErr
        );

    // Ignore errors indicating that this method doesnt exist.
    if (FAILED(hr))
        {
        if (hr == E_NOINTERFACE         ||
            hr == DISP_E_MEMBERNOTFOUND ||
            hr == DISP_E_UNKNOWNNAME)
            {
            // the above errors really aren't
            hr = S_OK;
            }
        }

    /*
     * NOTE: The OnStartPage method is always called while the
     * script is running, so we use ExceptionId and let the
     * scripting engine report the error.  OnEndPage is always
     * called after the engine is gone, so we use HandleError.
     */
    if (FAILED(hr))
        {
        if (ExcepInfo.bstrSource && ExcepInfo.bstrDescription)
            {
            // User supplied error
            Exception
                (
                IID_IObjectCover,
                ExcepInfo.bstrSource,
                ExcepInfo.bstrDescription
                );
            }
        else if (fOnStart)
            {
            // Standard on-start error
            ExceptionId
                (
                IID_IObjectCover,
                IDE_COVER,
                IDE_COVER_ON_START_PAGE_FAILED,
                hr
                );
            }
        else
            {
            // Standard on-end error
            HandleErrorMissingFilename
                (
                IDE_COVER_ON_END_PAGE_FAILED,
                pHitObj
                );
            }
        }

    return hr;
    }

/*===================================================================
  C  C o m p o n e n t  C o l l e c t i o n
===================================================================*/

/*===================================================================
CComponentCollection::CComponentCollection

CComponentCollection constructor

Parameters:

Returns:
===================================================================*/
CComponentCollection::CComponentCollection()
    :
    m_csScope(csUnknown),
    m_fUseTaggedArray(FALSE), m_fUsePropArray(FALSE),
    m_fHasComProperties(FALSE),
    m_cAllTagged(0), m_cInstTagged(0),
    m_cProperties(0), m_cUnnamed(0),
    m_pCompFirst(NULL)
    {
    }

#ifdef DBG
/*===================================================================
CComponentCollection::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CComponentCollection::AssertValid() const
    {
    Assert(m_csScope != csUnknown);
    m_htTaggedObjects.AssertValid();
    m_htTaggedObjects.AssertValid();
    m_htidIUnknownPtrs.AssertValid();
    }
#endif

/*===================================================================
CComponentCollection::~CComponentCollection

CComponentCollection destructor
Deletes all the objects

Parameters:

Returns:
===================================================================*/
CComponentCollection::~CComponentCollection()
    {
    UnInit();
    }

/*===================================================================
CComponentCollection::Init

Sets collection scope
Initializes hash tables

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::Init
(
CompScope scScope
)
    {
    HRESULT hr = S_OK;

    m_csScope = scScope;

    hr = m_htTaggedObjects.Init(HT_TAGGED_OBJECTS_BUCKETS_MAX);
    if (FAILED(hr))
        return hr;

    hr = m_htProperties.Init(HT_PROPERTIES_BUCKETS_MAX);
    if (FAILED(hr))
        return hr;

    hr = m_htidIUnknownPtrs.Init(HT_IUNKNOWN_PTRS_BUCKETS_MAX);
    if (FAILED(hr))
        return hr;

    return S_OK;
    }

/*===================================================================
CComponentCollection::UnInit

Deletes all the objects

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CComponentCollection::UnInit()
    {
    // clear out pointer arrays
    m_rgpvTaggedObjects.Clear();
    m_rgpvProperties.Clear();
    m_fUseTaggedArray = FALSE;
    m_fUsePropArray = FALSE;

    // clear out name hash tables
    m_htTaggedObjects.UnInit();
    m_htProperties.UnInit();

    // clear out pointers hash table
    m_htidIUnknownPtrs.UnInit();

    // delete all member component objects
    if (m_pCompFirst)
        {
        CComponentObject *pObj = m_pCompFirst;
        while (pObj)
            {
            CComponentObject *pNext = pObj->m_pCompNext;
            delete pObj;
            pObj = pNext;
            }
        m_pCompFirst = NULL;
        }

    // reset the counters
    m_cAllTagged = 0;
    m_cInstTagged = 0;
    m_cProperties = 0;
    m_cUnnamed = 0;
    m_fHasComProperties = FALSE;

    return S_OK;
    }

/*===================================================================
CComponentCollection::AddComponentToNameHash

Adds an object to the proper hash table

Parameters:
    CComponentObject *pObj      object to add
    LPWSTR            pwszName  object's name (hash)
    DWORD             cbName    name length in bytes

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddComponentToNameHash
(
CComponentObject *pObj,
LPWSTR            pwszName,
DWORD             cbName
)
    {
    Assert(pwszName);
    Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

    // determine which hash table
    CHashTableStr *pHashTable;

    if (pObj->m_ctType == ctTagged)
        pHashTable = &m_htTaggedObjects;
    else if (pObj->m_ctType == ctProperty)
        pHashTable = &m_htProperties;
    else
        return S_OK; // nowhere to add, OK

    // Initialize object's CLinkElem
    HRESULT hr = pObj->Init(pwszName, cbName);
    if (FAILED(hr))
        return hr;

    // Add to hash table
    CLinkElem *pAddedElem = pHashTable->AddElem(pObj);
    if (!pAddedElem)
        return E_FAIL;  // couldn't add

    if (pObj != static_cast<CComponentObject *>(pAddedElem))
        return E_FAIL;  // another object with the same name
                        // already there

    return S_OK;
    }

/*===================================================================
CComponentCollection::AddComponentToPtrHash

Adds an object to the IUnkown * hash table

Parameters:
    CComponentObject *pObj      object to add

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddComponentToPtrHash
(
CComponentObject *pObj
)
    {
    // If we don't track the threading model, we don't care
    // to add objects to cache by IUnknown * - no need to look them up
    if (!Glob(fTrackThreadingModel))
        return S_OK;

    void *ptr = pObj->m_pUnknown;
    if (!ptr)
        return S_OK; // uninstatiated

    if (FAILED(m_htidIUnknownPtrs.AddObject((DWORD_PTR)ptr, pObj)))
        return E_FAIL;

    pObj->m_fInPtrCache = TRUE;
    return S_OK;
    }

/*===================================================================
ComponentCollection::FindComponentObjectByName

Find tagged object by name

Parameters:
    LPWSTR             pwszName   object's name
    DWORD              cbName     name length
    CComponentObject **ppObj      found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CComponentCollection::FindComponentObjectByName
(
LPWSTR pwszName,
DWORD  cbName,
CComponentObject **ppObj
)
    {
    Assert(pwszName);
    Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

    CLinkElem *pElem = m_htTaggedObjects.FindElem(pwszName, cbName);
    if (!pElem)
        {
        *ppObj = NULL;
        return S_FALSE;
        }

    *ppObj = static_cast<CComponentObject *>(pElem);
    return S_OK;
    }

/*===================================================================
ComponentCollection::FindComponentPropertyByName

Find property by name

Parameters:
    LPWSTR             pwszName   object's name
    DWORD              cbName     name length
    CComponentObject **ppObj      found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CComponentCollection::FindComponentPropertyByName
(
LPWSTR pwszName,
DWORD  cbName,
CComponentObject **ppObj
)
    {
    Assert(pwszName);
    Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

    CLinkElem *pElem = m_htProperties.FindElem(pwszName, cbName);
    if (!pElem)
        {
        *ppObj = NULL;
        return S_FALSE;
        }

    *ppObj = static_cast<CComponentObject *>(pElem);
    return S_OK;
    }

/*===================================================================
ComponentCollection::FindComponentByIUnknownPtr

Find property by IUnknown *

Parameters:
    IUnknown          *pUnk    find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/

HRESULT CComponentCollection::FindComponentByIUnknownPtr
(
IUnknown *pUnk,
CComponentObject **ppObj
)
    {
    void *pv;
    if (m_htidIUnknownPtrs.FindObject((DWORD_PTR)pUnk, &pv) != S_OK)
        {
        *ppObj = NULL;
        return S_FALSE;
        }

    *ppObj = reinterpret_cast<CComponentObject *>(pv);
    return S_OK;
    }

/*===================================================================
CComponentCollection::AddTagged

Adds a tagged object to the collection. Does not instanciate it yet.

Parameters:
    LPWSTR     pwszName     Object name
    CLSID     &ClsId        Class ID
    CompModel  cmModel      Object model

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddTagged
(
LPWSTR    pwszName,
const CLSID &ClsId,
CompModel cmModel
)
    {
    HRESULT hr = S_OK;

    DWORD cbName = CbWStr(pwszName);    // do strlen once

    if (m_htTaggedObjects.FindElem(pwszName, cbName))
        return E_FAIL;  // duplicate name

    CComponentObject *pObj = new CComponentObject
        (
        m_csScope,
        ctTagged,
        cmModel
        );

    if (pObj == NULL)
        return E_OUTOFMEMORY;

    pObj->m_ClsId = ClsId;

    hr = AddComponentToList(pObj);
    if (FAILED(hr))
        return hr;

    hr = AddComponentToNameHash(pObj, pwszName, cbName);
    if (FAILED(hr))
        return hr;

    if (m_fUseTaggedArray)
        m_rgpvTaggedObjects.Append(pObj);

    m_cAllTagged++;
    return S_OK;
    }

/*===================================================================
CComponentCollection::AddProperty

Adds a property object to the collection.
If property with the same name exists, it changes the value

Parameters:
    LPWSTR             pwszName   Object name
    VARIANT            pVariant   Property value
    CComponentObject **ppObj      [out] Property object could
                                        be NULL if not requested

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddProperty
(
LPWSTR   pwszName,
VARIANT *pVariant,
CComponentObject **ppObj
)
    {
    if (ppObj)
        *ppObj = NULL;

    HRESULT hr = S_OK;

    CComponentObject *pObj = NULL;

    DWORD cbName = CbWStr(pwszName);    // do strlen once

    // Find the existing object first
    CLinkElem *pElem = m_htProperties.FindElem(pwszName, cbName);

    if (pElem)
        {
        // Object already exists - use it
        pObj = static_cast<CComponentObject *>(pElem);
        Assert(pObj->m_ctType == ctProperty);

        // Clear out the object from any data
        hr = pObj->Clear();
        if (FAILED(hr))
            return hr;

        // Reinitialize object
        pObj->m_csScope = m_csScope;
        pObj->m_ctType  = ctProperty;
        pObj->m_cmModel = cmUnknown;
        }
    else
        {
        // Create new object
        pObj = new CComponentObject(m_csScope, ctProperty, cmUnknown);
        if (pObj == NULL)
            return E_OUTOFMEMORY;

        // Add the object to the list
        hr = AddComponentToList(pObj);
        if (FAILED(hr))
            return hr;

        // Add the object to the hash
        hr = AddComponentToNameHash(pObj, pwszName, cbName);
        if (FAILED(hr))
            return hr;

        // Add to properties array if needed
        if (m_fUsePropArray)
            m_rgpvProperties.Append(pObj);

        m_cProperties++;
        }

    // Assign value
    hr = pObj->SetPropertyValue(pVariant);

    if (SUCCEEDED(hr))
        {
        // check if simple variant
        if (!FIsSimpleVariant(&pObj->m_Variant))
            m_fHasComProperties = TRUE;
        }

    // Return object ptr if requested
    if (SUCCEEDED(hr))
        {
        if (ppObj)
            *ppObj = pObj;
        }

    return hr;
    }

/*===================================================================
CComponentCollection::AddUnnamed

Add object to be instantiated using Server.CreateObject

Parameters:
    CLSID             &ClsId    Class ID
    CompModel          cmModel  Object model
    CComponentObject **ppObj    Object Added

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddUnnamed
(
const CLSID &ClsId,
CompModel cmModel,
CComponentObject **ppObj
)
    {
    HRESULT hr = S_OK;

    if (cmModel == cmUnknown)
        {
        hr = CompModelFromCLSID(ClsId, &cmModel);
        if (FAILED(hr))
            return hr;
        }

    CComponentObject *pObj = new CComponentObject
        (
        m_csScope,
        ctUnnamed,
        cmModel
        );

    if (pObj == NULL)
        return E_OUTOFMEMORY;

    pObj->m_ClsId = ClsId;

    hr = AddComponentToList(pObj);
    if (FAILED(hr))
        return hr;

    *ppObj = pObj;
    m_cUnnamed++;
    return S_OK;
    }

/*===================================================================
CComponentCollection::GetTagged

Finds tagged object by name

Parameters:
    LPWSTR   pwszName           Object name
    CComponentObject **ppObj    [out] Object Found

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::GetTagged
(
LPWSTR pwszName,
CComponentObject **ppObj
)
    {
    Assert(ppObj);
    *ppObj = NULL;

    CComponentObject *pObj = NULL;
    HRESULT hr = FindComponentObjectByName
        (
        pwszName,
        CbWStr(pwszName),
        &pObj
        );

    if (FAILED(hr))
        return hr;

    if (pObj && pObj->m_ctType != ctTagged)
        pObj = NULL;

    if (pObj)
        *ppObj = pObj;
    else
        hr = TYPE_E_ELEMENTNOTFOUND;

    return hr;
    }

/*===================================================================
CComponentCollection::GetProperty

Finds property object by name

Parameters:
    LPWSTR   pwszName           Property name
    CComponentObject **ppObj    [out] Object Found

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::GetProperty
(
LPWSTR pwszName,
CComponentObject **ppObj
)
    {
    Assert(ppObj);
    *ppObj = NULL;

    CComponentObject *pObj = NULL;
    HRESULT hr = FindComponentPropertyByName
        (
        pwszName,
        CbWStr(pwszName),
        &pObj
        );

    if (FAILED(hr))
        return hr;

    if (pObj)
        *ppObj = pObj;
    else
        hr = TYPE_E_ELEMENTNOTFOUND;

    return hr;
    }

/*===================================================================
CComponentCollection::GetNameByIndex

Find name of a tagged objects or property by index

Parameters:
    CompType ctType       tagged or property
    int      index        index (1-based)
    LPWSTR  *ppwszName    [out] name (NOT allocated)

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::GetNameByIndex
(
CompType ctType,
int index,
LPWSTR *ppwszName
)
    {
    CPtrArray *pPtrArray;

    if (ctType == ctTagged)
        {
        if (!m_fUseTaggedArray)
            StartUsingTaggedObjectsArray();
        pPtrArray = &m_rgpvTaggedObjects;
        }
    else if (ctType == ctProperty)
        {
        if (!m_fUsePropArray)
            StartUsingPropertiesArray();
        pPtrArray = &m_rgpvProperties;
        }
    else
        {
        Assert(FALSE);
        *ppwszName = NULL;
        return E_FAIL;
        }

    if (index >= 1 && index <= pPtrArray->Count())
        {
        CComponentObject *pObj = (CComponentObject *)pPtrArray->Get(index-1);
        if (pObj)
            {
            Assert(pObj->GetType() == ctType);
            *ppwszName = pObj->GetName();
            if (*ppwszName)
                return S_OK;
            }
        }

    *ppwszName = NULL;
    return E_FAIL;
    }

/*===================================================================
CComponentCollection::RemoveComponent

Remove a known component.
Slow method for a non-recent objects.

Parameters:
    CComponentObject *pObj      -- object to remove

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::RemoveComponent
(
CComponentObject *pObj
)
    {
    Assert(pObj);

    // Remove from by-name hash tables and arrays
    if (pObj->m_ctType == ctTagged)
        {
        // tagged cannot be removed
        Assert(FALSE);
        return E_FAIL;
        }
    else if (pObj->m_ctType == ctProperty)
        {
        // hash table
        if (m_htProperties.DeleteElem(pObj->GetName(), CbWStr(pObj->GetName())))
            {
            m_cProperties--;
            }

        // array
        if (m_fUsePropArray)
            {
            m_rgpvProperties.Remove(pObj);
            }
        }
    else
        {
        Assert(pObj->m_ctType == ctUnnamed);
        m_cUnnamed--;
        }

    // Remove from the 'by pointer hash table'
    if (pObj->m_fInPtrCache)
        {
        void *ptr = pObj->m_pUnknown;
        if (ptr)
            m_htidIUnknownPtrs.RemoveObject((DWORD_PTR)ptr);
        pObj->m_fInPtrCache = FALSE;
        }

    // Remove from the list
    RemoveComponentFromList(pObj);

    // Remove
    delete pObj;

    return S_OK;
    }

/*===================================================================
CComponentCollection::RemovePropery

Remove a property by name.

Parameters:
    LPWSTR pwszName -- property name

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::RemoveProperty
(
LPWSTR pwszName
)
    {
    CComponentObject *pObj = NULL;
    HRESULT hr = FindComponentPropertyByName
        (
        pwszName,
        CbWStr(pwszName),
        &pObj
        );

    if (FAILED(hr))
        return hr;

    if (pObj)
        hr = RemoveComponent(pObj);

    return hr;
    }

/*===================================================================
CComponentCollection::RemoveAllProperties

Remove all properties.  Faster than iterating.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::RemoveAllProperties()
    {
    // Clear out the properties array
    if (m_fUsePropArray)
        {
        m_rgpvProperties.Clear();
        m_fUsePropArray = FALSE;
        }

    // Walk the object list to remove properties
    CComponentObject *pObj = m_pCompFirst;
    while (pObj)
    {
        CComponentObject *pNextObj = pObj->m_pCompNext;

        if (pObj->m_ctType == ctProperty)
            {
            // remove from the hash table
            m_htProperties.DeleteElem(pObj->GetName(), CbWStr(pObj->GetName()));
            // properties are not in the 'by pointer hash table'
            Assert(!pObj->m_fInPtrCache);
            // remove from the list
            RemoveComponentFromList(pObj);
            // remove
            delete pObj;
            }

        pObj = pNextObj;
    }

    m_cProperties = 0;
    m_fHasComProperties = FALSE;

    return S_OK;
    }

/*===================================================================
CComponentCollection::StartUsingTaggedObjectsArray

Fill in the tagged objects array for access by index for the
first time

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::StartUsingTaggedObjectsArray()
    {
    if (m_fUseTaggedArray)
        return S_OK;

    m_rgpvTaggedObjects.Clear();

    CComponentObject *pObj = m_pCompFirst;
    while (pObj)
        {
        if (pObj->GetType() == ctTagged)
            m_rgpvTaggedObjects.Append(pObj);
        pObj = pObj->m_pCompNext;
        }

    m_fUseTaggedArray = TRUE;
    return S_OK;
    }

/*===================================================================
CComponentCollection::StartUsingPropertiesArray

Fill in the properties array for access by index for the
first time

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::StartUsingPropertiesArray()
    {
    if (m_fUsePropArray)
        return S_OK;

    m_rgpvProperties.Clear();

    CComponentObject *pObj = m_pCompFirst;
    while (pObj)
        {
        if (pObj->GetType() == ctProperty)
            m_rgpvProperties.Prepend(pObj); // backwards
        pObj = pObj->m_pCompNext;
        }

    m_fUsePropArray = TRUE;
    return S_OK;
    }


/*===================================================================
  C  P a g e  C o m p o n e n t  M a n a g e r
===================================================================*/

/*===================================================================
CPageComponentManager::CPageComponentManager

CPageComponentManager constructor

Parameters:

Returns:
===================================================================*/
CPageComponentManager::CPageComponentManager()
    : m_pHitObj(NULL)
    {
    }

#ifdef DBG
/*===================================================================
CPageComponentManager::AssertValid()

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CPageComponentManager::AssertValid() const
    {
    Assert(m_pHitObj);
    m_pHitObj->AssertValid();
    m_htidPageObjects.AssertValid();
    }
#endif

/*===================================================================
CPageComponentManager::~CPageComponentManager

CPageComponentManager destructor
Deletes all page objects

Parameters:

Returns:
===================================================================*/
CPageComponentManager::~CPageComponentManager()
    {
    // delete all page objects
    m_htidPageObjects.IterateObjects(DeletePageObjectCB);
    }

/*===================================================================
CPageComponentManager::DeletePageObjectCB

Static callback from hash table iterator to delete a CPageObject

Parameters:
    pvObj       CPageObject* to delete passed as void*

Returns:
    iccContinue
===================================================================*/
IteratorCallbackCode CPageComponentManager::DeletePageObjectCB
(
void *pvObj,
void *,
void *
)
    {
    Assert(pvObj);
    CPageObject *pObj = reinterpret_cast<CPageObject *>(pvObj);
    delete pObj;
    return iccContinue;
    }

/*===================================================================
CPageComponentManager::Init

Sets collection scope (to page)
Initializes hash tables

Parameters:
    CHitObj *pHitObj        this page

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::Init
(
CHitObj *pHitObj
)
    {
    HRESULT hr;

    // Init hash table of Page Objects
    hr = m_htidPageObjects.Init(HT_PAGE_OBJECTS_BUCKETS_MAX);
    if (FAILED(hr))
        return hr;

    // remember pHitObj
    m_pHitObj = pHitObj;

    return S_OK;
    }

/*===================================================================
CPageComponentManager::OnStartPage

Adds new page object. Ignores objects withount page info
(OnEndPage is done for all objects at the end of page)

Parameters:
    CComponentObject  *pCompObj     object to do OnStartPage
    CScriptingContext *pContext     arg to OnStart
    COnPageInfo *pOnPageInfo        pre-queried ids (optional)
    BOOL        *pfStarted          returned flag

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::OnStartPage
(
CComponentObject  *pCompObj,
CScriptingContext *pContext,
const COnPageInfo *pOnPageInfo,
BOOL              *pfStarted
)
    {
    IDispatch  *pDisp = pCompObj->m_pDisp;
    HRESULT hr = S_OK;

    if(pDisp == NULL)
        {
        Assert(pCompObj->m_dwGIPCookie != NULL_GIP_COOKIE);
        // try to restore from cookie
        hr = g_GIPAPI.Get
            (
            pCompObj->m_dwGIPCookie,
            IID_IDispatch,
            (void **)&pDisp
            );

        if (FAILED(hr))
            return hr;
        }
	else
		pDisp->AddRef();

    Assert(pDisp);

    Assert(pfStarted);
    *pfStarted = FALSE;

    // check if onpageinfo passed and the methods aren't defined
    if (pOnPageInfo && !pOnPageInfo->FHasAnyMethod())
		{
		pDisp->Release();
        return S_OK;
		}

    // check if already in the PageObject Hash
    if (m_htidPageObjects.FindObject((DWORD_PTR)pDisp) == S_OK)
        {
		pDisp->Release();
        return S_OK;
        }

    COnPageInfo OnPageInfo;

    if (pOnPageInfo)
        {
        OnPageInfo = *pOnPageInfo;
        }
    else
        {
        // dynamically create OnPageInfo if not passed
        if (Glob(fExceptionCatchEnable))
            {
            TRY
                hr = QueryOnPageInfo(pDisp, &OnPageInfo);
            CATCH(nExcept)
                HandleErrorMissingFilename(IDE_SCRIPT_OBJ_ONPAGE_QI_FAILED,
                                           m_pHitObj,
                                           TRUE,
                                           pCompObj->GetName(),
                                           nExcept);
                hr = nExcept;
            END_TRY
            }
        else
            {
            hr = QueryOnPageInfo(pDisp, &OnPageInfo);
            }

        if (FAILED(hr))
            {
			pDisp->Release();
            return hr;
            }

        // check if any of the methods is defined
        if (!OnPageInfo.FHasAnyMethod())
            {
			pDisp->Release();
            return S_OK;
            }
        }

    // create object
    CPageObject *pPageObj = new CPageObject;
    if (!pPageObj)
        {
		pDisp->Release();
        return E_OUTOFMEMORY;
        }

    // init LinkElem
    hr = pPageObj->Init(pDisp, OnPageInfo);   // this eats our previous AddRef()
    if (SUCCEEDED(hr))
        {
        // add to hash table
        hr = m_htidPageObjects.AddObject((DWORD_PTR)pDisp, pPageObj);
        }

    // cleanup if failed
    if (FAILED(hr) && pPageObj)
        {
        pDisp->Release();   // Init failed, so remove our AddRef()
        delete pPageObj;
        return hr;
        }

    *pfStarted = TRUE;

    return pPageObj->InvokeMethod
        (
        ONPAGEINFO_ONSTARTPAGE,
        pContext,
        m_pHitObj
        );
    }

/*===================================================================
PageComponentManager::OnEndPageAllObjects

Does OnEndPage() for all objects that need it
(OnStartPage() is on demand basis)

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::OnEndPageAllObjects()
    {
    HRESULT hrGlobal = S_OK;

    m_htidPageObjects.IterateObjects
        (
        OnEndPageObjectCB,
        m_pHitObj,
        &hrGlobal
        );

    return hrGlobal;
    }

/*===================================================================
CPageComponentManager::OnEndPageObjectCB

Static callback from hash table iterator to execute OnEndPage
for a CPageObject

Parameters:
    pvObj       CPageObject* to delete passed as void*

Returns:
    iccContinue
===================================================================*/
IteratorCallbackCode CPageComponentManager::OnEndPageObjectCB
(
void *pvObj,
void *pvHitObj,
void *pvhr
)
    {
    Assert(pvObj);
    Assert(pvHitObj);
    Assert(pvhr);

    CPageObject *pObj = reinterpret_cast<CPageObject *>(pvObj);

    HRESULT hr = pObj->InvokeMethod
        (
        ONPAGEINFO_ONENDPAGE,
        NULL,
        reinterpret_cast<CHitObj *>(pvHitObj)
        );

    if (FAILED(hr))
        *(reinterpret_cast<HRESULT *>(pvhr)) = hr;

    return iccContinue;
    }

/*===================================================================
CPageComponentManager::GetPageCollection

Queries HitObj for the Page's Component Collection

Parameters:
    CComponentCollection **ppCollection (out)

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetPageCollection
(
CComponentCollection **ppCollection
)
    {
    Assert(m_pHitObj);

    *ppCollection = NULL;

    return m_pHitObj->GetPageComponentCollection(ppCollection);
    }

/*===================================================================
CPageComponentManager::GetSessionCollection

Queries HitObj for the Session's Component Collection

Parameters:
    CComponentCollection **ppCollection (out)

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetSessionCollection
(
CComponentCollection **ppCollection
)
    {
    Assert(m_pHitObj);

    *ppCollection = NULL;

    return m_pHitObj->GetSessionComponentCollection(ppCollection);
    }

/*===================================================================
CPageComponentManager::GetApplnCollection

Queries HitObj for the Application's Component Collection

Parameters:
    CComponentCollection **ppCollection (out)

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetApplnCollection
(
CComponentCollection **ppCollection
)
    {
    Assert(m_pHitObj);

    *ppCollection = NULL;

    return m_pHitObj->GetApplnComponentCollection(ppCollection);
    }

/*===================================================================
CPageComponentManager::GetCollectionByScope

Gets the collection corresponding to the scope

Parameters:
    CompScope              csScope      (in) desired scope
    CComponentCollection **ppCollection (out)

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetCollectionByScope
(
CompScope scScope,
CComponentCollection **ppCollection
)
    {
    HRESULT hr = S_OK;

    switch (scScope)
        {
        case csPage:
            hr = GetPageCollection(ppCollection);
            break;
        case csSession:
            hr = GetSessionCollection(ppCollection);
            break;
        case csAppln:
            hr = GetApplnCollection(ppCollection);
            break;
        default:
            hr = E_UNEXPECTED;
            break;
        }

    if (FAILED(hr))
        *ppCollection = NULL;
    else if (*ppCollection == NULL)
        hr = E_POINTER; // to make sure we fail if no collection
    return hr;
    }

/*===================================================================
CPageComponentManager::FindScopedComponentByName

Finds object by name. Searches multiple collections if
the scope is unknown.
Internal private method used in GetScoped...()

Parameters:
    CompScope             csScope       Scope (could be csUnknown)
    LPWSTR                pwszName      Object name
    DWORD                 cbName        name length
    BOOL                  fProperty     TRUE = property,
                                        FALSE = tagged

    CComponentObject     **ppObj        (out) Object found
    CComponentCollection **ppCollection (out) Collection where found
                                              (optional)

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CPageComponentManager::FindScopedComponentByName
(
CompScope csScope,
LPWSTR pwszName,
DWORD  cbName,
BOOL   fProperty,
CComponentObject **ppObj,
CComponentCollection **ppCollection
)
    {
    int cMaxTry = (csScope == csUnknown) ? 3 : 1;
    int cTry = 0;
    *ppObj = NULL;

    while (*ppObj == NULL && cTry < cMaxTry)
        {
        HRESULT hr = S_OK;
        CComponentCollection *pCollection = NULL;

        switch (++cTry)
            {
            case 1: // page (or explicit scope) first
                if (csScope == csUnknown)
                    hr = GetPageCollection(&pCollection);
                else  // explicit scope
                    hr = GetCollectionByScope(csScope, &pCollection);
                break;
            case 2: // session
                hr = GetSessionCollection(&pCollection);
                break;
            case 3: // application
                hr = GetApplnCollection(&pCollection);
                break;
            }
        if (FAILED(hr) || !pCollection)
            continue;   // couldn't get the collection

        Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

        // find the object
        if (fProperty)
            {
            hr = pCollection->FindComponentPropertyByName
                (
                pwszName,
                cbName,
                ppObj
                );
            }
        else
            {
            hr = pCollection->FindComponentObjectByName
                (
                pwszName,
                cbName,
                ppObj
                );
            }

        if (hr != S_OK)
            *ppObj = NULL;

        // remember where found
        if (*ppObj && ppCollection)
            *ppCollection = pCollection;
        }

    return (*ppObj ? S_OK : S_FALSE);
    }

/*===================================================================
CPageComponentManager::AddScopedTagged

Adds a tagged object to the collection. Does not instantiate it yet.

Parameters:
    CompScope csScope      Object scope (which collection)
    LPWSTR    pwszName     Object name
    CLSID    &ClsId        Class ID
    CompModel cmModel      Object model

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::AddScopedTagged
(
CompScope csScope,
LPWSTR    pwszName,
const CLSID &ClsId,
CompModel cmModel
)
    {
    CComponentCollection *pCollection;
    HRESULT hr = GetCollectionByScope(csScope, &pCollection);
    if (FAILED(hr))
        return hr;
    return pCollection->AddTagged(pwszName, ClsId, cmModel);
    }

/*===================================================================
CPageComponentManager::AddScopedProperty

Adds a property object to the collection.
If property with the same name exists, it changes the value

Parameters:
    CompScope          csScope    Object scope (which collection)
    LPWSTR             pwszName   Object name
    VARIANT            pVariant   Property value
    CComponentObject **ppObj      [out] Property object could
                                        be NULL if not requested

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::AddScopedProperty
(
CompScope csScope,
LPWSTR pwszName,
VARIANT *pVariant,
CComponentObject **ppObj
)
    {
    CComponentCollection *pCollection;
    HRESULT hr = GetCollectionByScope(csScope, &pCollection);
    if (FAILED(hr))
        {
        if (ppObj)
            *ppObj = NULL;
        return hr;
        }
    return pCollection->AddProperty(pwszName, pVariant, ppObj);
    }

/*===================================================================
CPageComponentManager::AddScopedUnnamedInstantiated

Server.CreateObject
Also does OnStartPage (adds created pDisp as CPageObject)

Parameters:
    csScope     Object scope (which collection)
    ClsId       Class ID
    cmModel     Object model
    pOnPageInfo DispIds for OnStartPage/OnEndPage (can be NULL)
    ppObj       [out] Object Added

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::AddScopedUnnamedInstantiated
(
CompScope csScope,
const CLSID &ClsId,
CompModel cmModel,
COnPageInfo *pOnPageInfo,
CComponentObject **ppObj
)
    {
    CComponentCollection *pCollection;
    HRESULT hr = GetCollectionByScope(csScope, &pCollection);
    if (FAILED(hr))
        return hr;
    hr = pCollection->AddUnnamed(ClsId, cmModel, ppObj);
    if (FAILED(hr))
        return hr;

    CComponentObject *pObj = *ppObj;

    // remember passed OnPageInfo
    if (pOnPageInfo)
        {
        pObj->m_OnPageInfo = *pOnPageInfo;
        pObj->m_fOnPageInfoCached = TRUE;
        }

    // create it
    hr = pObj->Instantiate(m_pHitObj);
    if (FAILED(hr))
        return hr;

    // add to pointer cash
    pCollection->AddComponentToPtrHash(pObj);

    // add as page object when needed
    if (csScope == csPage
        && (pObj->m_pDisp || (pObj->m_dwGIPCookie != NULL_GIP_COOKIE))
        && m_pHitObj && m_pHitObj->FIsBrowserRequest())
        {
        BOOL fStarted = FALSE;

        hr = OnStartPage
            (
            pObj,
            m_pHitObj->PScriptingContextGet(),
            pObj->GetCachedOnPageInfo(),
            &fStarted
            );

        if (fStarted)
            pObj->m_fOnPageStarted = TRUE;
        }

    return hr;
    }

/*===================================================================
CPageComponentManager::GetScopedObjectInstantiated

Finds component object (tagged) by name.
Scope could be csUnknown.
Instantiates tagged objects.
Also does OnStartPage (adds created pDisp as CPageObject)

Parameters:
    CompScope          csScope        Scope (could be csUnknown)
    LPWSTR             pwszName       Object name
    DWORD              cbName         Object name length (in bytes)
    CComponentObject **ppObj          Object found
    BOOL              *pfNewInstance  [out] TRUE if just instantiated

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetScopedObjectInstantiated
(
CompScope csScope,
LPWSTR pwszName,
DWORD  cbName,
CComponentObject **ppObj,
BOOL *pfNewInstance
)
    {
    HRESULT hr;

    Assert(pfNewInstance);
    *pfNewInstance = FALSE;

    CComponentCollection *pCollection;
    hr = FindScopedComponentByName
        (
        csScope,
        pwszName,
        cbName,
        FALSE,
        ppObj,
        &pCollection
        );
    if (FAILED(hr))
        return hr;

    CComponentObject *pObj = *ppObj;
    if (!pObj)   // not failed, but not found either
        return TYPE_E_ELEMENTNOTFOUND;

    if (pObj->m_ctType != ctTagged)
        return S_OK;

    // For tagged only - instantiate and do OnStartPage()

    // For application level objects instantiation must be
    // done within critical section

    BOOL fApplnLocked = FALSE;

    Assert(m_pHitObj);

    if (!pObj->m_fInstantiatedTagged &&          // uninstantiated
        pObj->m_csScope == csAppln   &&          // application scope
        m_pHitObj->PAppln()->FFirstRequestRun()) // after GLOBAL.ASA
        {
        // Lock
        m_pHitObj->PAppln()->Lock();

        // check if the object is still uninstantiated
        if (!pObj->m_fInstantiatedTagged)
            {
            // yes, still uninstantiated - keep the lock
            fApplnLocked = TRUE;
            }
        else
            {
            // object instantiated while we waited - don't keep lock
            m_pHitObj->PAppln()->UnLock();
            }
        }

    // Instantiate tagged if needed
    if (!pObj->m_fInstantiatedTagged)
        {
        if (pObj->m_csScope == csAppln)
            {
            // For applicatin scoped objects, instantiate from MTA
            hr = CallMTACallback
                (
                CPageComponentManager::InstantiateObjectFromMTA,
                pObj,
                m_pHitObj
                );
            }
        else
            {
            hr = pObj->Instantiate(m_pHitObj);
            }

        if (SUCCEEDED(hr))
            {
            // keep count
            pCollection->m_cInstTagged++;
            // add to pointer cash
            pCollection->AddComponentToPtrHash(pObj);
            // return flag
            *pfNewInstance = TRUE;
            }

        // Flag as instantiated even if failed
        pObj->m_fInstantiatedTagged = TRUE;
        }

    // Remove the lock kept while instantiating appln level object
    if (fApplnLocked)
        m_pHitObj->PAppln()->UnLock();

    // Return if [instantiation] failed
    if (FAILED(hr))
        {
        *ppObj = NULL;
        return hr;
        }

    // Add as page object when needed
    if (pObj->m_csScope != csAppln
        && (pObj->m_pDisp || (pObj->m_dwGIPCookie != NULL_GIP_COOKIE))
        && m_pHitObj && m_pHitObj->FIsBrowserRequest())
        {
        BOOL fStarted;
        OnStartPage     // don't care if failed
            (
            pObj,
            m_pHitObj->PScriptingContextGet(),
            pObj->GetCachedOnPageInfo(),
            &fStarted
            );
        }

    return hr;
    }

/*===================================================================
CPageComponentManager::InstantiateObjectFromMTA

Static callback called by CallMTACallback() to
instantiate aplication scoped objects

Parameters:
    void *pvObj       ComponentObject
    void *pvHitObj    HitObj

Returns:
    HRESULT
===================================================================*/
HRESULT __stdcall CPageComponentManager::InstantiateObjectFromMTA
(
void *pvObj,
void *pvHitObj
)
    {
    Assert(pvHitObj);
    Assert(pvObj);

    CHitObj *pHitObj = (CHitObj *)pvHitObj;
    CComponentObject *pObj = (CComponentObject *)pvObj;

    return pObj->Instantiate(pHitObj);
    }

/*===================================================================
CPageComponentManager::GetScopedProperty

Find property component by name.
Also does OnStartPage (adds created pDisp as CPageObject)

Parameters:
    CompScope          csScope      Scope (could not be csUnknown)
    LPWSTR             pwszName     Object name
    CComponentObject **ppObj        Object found

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetScopedProperty
(
CompScope csScope,
LPWSTR pwszName,
CComponentObject **ppObj
)
    {
    HRESULT hr;

    hr = FindScopedComponentByName
        (
        csScope,
        pwszName,
        CbWStr(pwszName),
        TRUE,
        ppObj
        );
    if (FAILED(hr))
        return hr;

    CComponentObject *pObj = *ppObj;
    if (!pObj)   // not failed, but not found either
        return TYPE_E_ELEMENTNOTFOUND;

    // Add as page object if IDispatch * is there
    // as VT_DISPATCH property
    if (pObj->m_csScope != csAppln
        && (pObj->m_pDisp || (pObj->m_dwGIPCookie != NULL_GIP_COOKIE))
        && m_pHitObj && m_pHitObj->FIsBrowserRequest())
        {
        BOOL fStarted;
        hr = OnStartPage
            (
            pObj,
            m_pHitObj->PScriptingContextGet(),
            pObj->GetCachedOnPageInfo(),
            &fStarted
            );
        }

    return hr;
    }

/*===================================================================
CPageComponentManager::FindAnyScopeComponentByIUnknown

Find component by its IUnknown *.

Parameters:
    IUnknown          *pUnk    find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CPageComponentManager::FindAnyScopeComponentByIUnknown
(
IUnknown *pUnk,
CComponentObject **ppObj
)
    {
    int cTry = 0;
    *ppObj = NULL;

    while (*ppObj == NULL && cTry < 3)
        {
        HRESULT hr = S_OK;
        CComponentCollection *pCollection = NULL;

        switch (++cTry)
            {
            case 1: // page first
                hr = GetPageCollection(&pCollection);
                break;
            case 2: // session
                hr = GetSessionCollection(&pCollection);
                break;
            case 3: // application
                hr = GetApplnCollection(&pCollection);
                break;
            }
        if (FAILED(hr) || !pCollection)
            continue;   // couldn't get the collection

        // find the object
        hr = pCollection->FindComponentByIUnknownPtr(pUnk, ppObj);
        if (hr != S_OK)
            *ppObj = NULL;
        }

    return (*ppObj ? S_OK : S_FALSE);
    }

/*===================================================================
CPageComponentManager::FindAnyScopeComponentByIDispatch

Find component by its IDispatch *.
Uses FindAnyScopeComponentByIUnknown.

Parameters:
    IDispatch         *pDisp   find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CPageComponentManager::FindAnyScopeComponentByIDispatch
(
IDispatch *pDisp,
CComponentObject **ppObj
)
    {
    IUnknown *pUnk = NULL;
    HRESULT hr = pDisp->QueryInterface(IID_IUnknown, (void **)&pUnk);

    if (SUCCEEDED(hr) && !pUnk)
        hr = E_FAIL;

    if (FAILED(hr))
        {
        *ppObj = NULL;
        return hr;
        }

    return FindAnyScopeComponentByIUnknown(pUnk, ppObj);
    }

/*===================================================================
CPageComponentManager::FindComponentWithoutContext

The same as FindAnyScopeComponentByIDispatch -
    but static - gets context from Viper

Uses FindAnyScopeComponentByIUnknown.

Parameters:
    IDispatch         *pDisp   find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CPageComponentManager::FindComponentWithoutContext
(
IDispatch *pDisp,
CComponentObject **ppObj
)
    {
    // Get HitObj from Viper Context
    CHitObj *pHitObj = NULL;
    ViperGetHitObjFromContext(&pHitObj);
    if (!pHitObj)
        return E_FAIL;

    // Get page component manager
    CPageComponentManager *pPCM = pHitObj->PPageComponentManager();
    if (!pPCM)
        return E_FAIL;

    // Call the page component manager to find the object
    return pPCM->FindAnyScopeComponentByIUnknown(pDisp, ppObj);
    }

/*===================================================================
CPageComponentManager::RemoveComponent

Remove component -- the early release logic

Parameters:
    IDispatch         *pDisp   find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
===================================================================*/
 HRESULT CPageComponentManager::RemoveComponent
 (
 CComponentObject *pObj
 )
    {
    Assert(pObj);

    CComponentCollection *pCollection;
    HRESULT hr = GetCollectionByScope(pObj->m_csScope, &pCollection);
    if (FAILED(hr))
        return hr;

    return pCollection->RemoveComponent(pObj);
    }

/*===================================================================
  C  C o m p o n e n t  I t e r a t o r
===================================================================*/

/*===================================================================
CComponentIterator::CComponentIterator

CComponentIterator constructor

Parameters:
    CHitObj *pHitObj    page to init with (optional)

Returns:
===================================================================*/
CComponentIterator::CComponentIterator(CHitObj *pHitObj)
    : m_fInited(FALSE), m_fFinished(FALSE), m_pHitObj(NULL),
      m_pLastObj(NULL), m_csLastScope(csUnknown)
    {
    if (pHitObj)
        Init(pHitObj);
    }

/*===================================================================
CComponentIterator::~CComponentIterator

CComponentIterator destructor

Parameters:

Returns:
===================================================================*/
CComponentIterator::~CComponentIterator()
    {
    }

/*===================================================================
CComponentIterator::Init

Start iterating

Parameters:
    CHitObj *pHitObj    page

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentIterator::Init
(
CHitObj *pHitObj
)
    {
    Assert(pHitObj);
    pHitObj->AssertValid();

    m_pHitObj = pHitObj;
    m_fInited = TRUE;
    m_fFinished = FALSE;

    m_pLastObj = NULL;
    m_csLastScope = csUnknown;

    return S_OK;
    }

/*===================================================================
CComponentIterator::WStrNextComponentName

The iteration function

Parameters:

Returns:
    Next component name or NULL if done
===================================================================*/
LPWSTR CComponentIterator::WStrNextComponentName()
    {
    Assert(m_fInited);

    if (m_fFinished)
        return NULL;

    Assert(m_pHitObj);

    CompScope csScope = m_csLastScope;
    CComponentObject *pObj = m_pLastObj ?
        static_cast<CComponentObject *>(m_pLastObj->m_pNext) : NULL;

    while (!m_fFinished)
        {
        // try the current scope

        if (pObj)
            {
            Assert(pObj->m_ctType == ctTagged);
            Assert(pObj->GetName());

            m_pLastObj = pObj;
            m_csLastScope = csScope;
            return pObj->GetName();
            }

        // couldn't find in the current scope - try next scope
        CComponentCollection *pCol = NULL;

        switch (csScope)
            {
            case csUnknown:
                csScope = csPage;
                m_pHitObj->GetPageComponentCollection(&pCol);
                break;
            case csPage:
                csScope = csSession;
                m_pHitObj->GetSessionComponentCollection(&pCol);
                break;
            case csSession:
                csScope = csAppln;
                m_pHitObj->GetApplnComponentCollection(&pCol);
                break;
            case csAppln:
            default:
                csScope = csUnknown;
                m_fFinished = TRUE;
                break;
            }

        // start at the beginning of the new collection

        if (pCol)
            pObj = static_cast<CComponentObject *>(pCol->m_htTaggedObjects.Head());
        }

    // finished
    return NULL;
    }

/*===================================================================
  C  V a r i a n t s I t e r a t o r
===================================================================*/

/*===================================================================
CVariantsIterator::CVariantsIterator

CVariantsIterator constructor by application

Parameters:
    CAppln  *pAppln       collection to init with
    DWORD    ctCollType   type of components to list iteration

Returns:
===================================================================*/
CVariantsIterator::CVariantsIterator
(
CAppln *pAppln,
DWORD ctColType
)
    : m_pCompColl(NULL), m_pAppln(NULL), m_pSession(NULL)
    {
    Assert(pAppln);
    pAppln->AddRef();

    m_cRefs = 1;
    m_pCompColl = pAppln->PCompCol();
    m_pAppln = pAppln;
    m_ctColType = ctColType;
    m_dwIndex = 0;
    }

/*===================================================================
CVariantsIterator::CVariantsIterator

CVariantsIterator constructor by session

Parameters:
    CSession *pSession        collection to init with
    DWORD     ctCollType      type of components to list iteration

Returns:
===================================================================*/
CVariantsIterator::CVariantsIterator
(
CSession *pSession,
DWORD ctColType
)
    : m_pCompColl(NULL), m_pAppln(NULL), m_pSession(NULL)
    {
    Assert(pSession);
    pSession->AddRef();

    m_cRefs = 1;
    m_pCompColl = pSession->PCompCol();
    m_ctColType = ctColType;
    m_pSession = pSession;
    m_dwIndex = 0;
    }

/*===================================================================
CVariantsIterator::~CVariantsIterator

CVariantsIterator destructor

Parameters:

Returns:
===================================================================*/
CVariantsIterator::~CVariantsIterator()
    {
    if (m_pSession)
        m_pSession->Release();
    if (m_pAppln)
        m_pAppln->Release();
    }

/*===================================================================
CVariantsIterator::QueryInterface

CVariantsIterator QI

Parameters:
    GUID&    iid
    VOID **  ppvObj

Returns: HRESULT
===================================================================*/
STDMETHODIMP CVariantsIterator::QueryInterface
(
const GUID &iid,
void **ppvObj
)
    {
    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
        {
        AddRef();
        *ppvObj = this;
        return S_OK;
        }

    *ppvObj = NULL;
    return E_NOINTERFACE;
    }

/*===================================================================
CVariantsIterator::AddRef

CVariantsIterator AddRef

Parameters:

Returns: ULONG
===================================================================*/
STDMETHODIMP_(ULONG) CVariantsIterator::AddRef()
    {
    return ++m_cRefs;
    }

/*===================================================================
CVariantsIterator::Release

CVariantsIterator Release

Parameters:

Returns:
===================================================================*/
STDMETHODIMP_(ULONG) CVariantsIterator::Release()
    {
    if (--m_cRefs > 0)
        return m_cRefs;

    delete this;
    return 0;
    }

/*===================================================================
CVariantsIterator::Clone

CVariantsIterator Clone

Parameters:

Returns:
===================================================================*/
STDMETHODIMP CVariantsIterator::Clone
(
IEnumVARIANT **ppEnumReturn
)
    {
    CVariantsIterator *pNewIterator = NULL;
    if (m_pSession)
        {
        pNewIterator = new CVariantsIterator(m_pSession, m_ctColType);
        }
    else if (m_pAppln)
        {
        pNewIterator = new CVariantsIterator(m_pAppln, m_ctColType);
        }
    else
        {
        Assert(FALSE);  // better be either Appln or Session
        return E_FAIL;
        }

    if (pNewIterator == NULL)
        return E_OUTOFMEMORY;

    // new iterator should point to same location as this.
    pNewIterator->m_dwIndex = m_dwIndex;

    *ppEnumReturn = pNewIterator;
    return S_OK;
    }

/*===================================================================
CVariantsIterator::Next

CVariantsIterator Next

Parameters:

Returns:
===================================================================*/
STDMETHODIMP CVariantsIterator::Next
(
unsigned long cElementsRequested,
VARIANT *rgVariant,
unsigned long *pcElementsFetched
)
    {
    // give a valid pointer value to 'pcElementsFetched'
    unsigned long cElementsFetched;
    if (pcElementsFetched == NULL)
        pcElementsFetched = &cElementsFetched;

    if (cElementsRequested == 0)
        {
        if (pcElementsFetched)
            *pcElementsFetched = 0;
        return S_OK;
        }

    DWORD cMax = 0;
    if (m_ctColType == ctTagged)
        {
        cMax = m_pCompColl ? m_pCompColl->m_cAllTagged : 0;
        }
    else if (m_ctColType == ctProperty)
        {
        cMax = m_pCompColl ? m_pCompColl->m_cProperties : 0;
        }
    else
        {
        // Should always be either tagged object or property
        Assert(FALSE);
        return E_FAIL;
        }

    // Loop through the collection until either we reach the end or
    // cElements becomes zero
    //
    unsigned long cElements = cElementsRequested;
    *pcElementsFetched = 0;

    while (cElements > 0 && m_dwIndex < cMax)
        {
        LPWSTR pwszName = NULL;

        if (m_pAppln) 
            m_pAppln->Lock();

        m_pCompColl->GetNameByIndex(m_ctColType, ++m_dwIndex, &pwszName);

        if (!pwszName) {
            if (m_pAppln)
                m_pAppln->UnLock();
            continue;
        }

        BSTR bstrT = SysAllocString(pwszName);

        if (m_pAppln)
            m_pAppln->UnLock();

        if (!bstrT)
            return E_OUTOFMEMORY;

        V_VT(rgVariant) = VT_BSTR;
        V_BSTR(rgVariant) = bstrT;
		++rgVariant;

        --cElements;
        ++(*pcElementsFetched);
        }

    // initialize the remaining variants
    while (cElements-- > 0)
        VariantInit(rgVariant++);

    return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
    }

/*===================================================================
CVariantsIterator::Skip

CVariantsIterator Skip

Parameters:

Returns:
===================================================================*/
STDMETHODIMP CVariantsIterator::Skip
(
unsigned long cElements
)
    {
    /* Adjust the index by cElements or
     * until we hit the max element
     */
    DWORD cMax = 0;

    // We iterate over different arrays depending on the collection type
    if (m_ctColType == ctTagged)
        {
        cMax = m_pCompColl ? m_pCompColl->m_cAllTagged : 0;
        }
    else if (m_ctColType == ctProperty)
        {
        cMax = m_pCompColl ? m_pCompColl->m_cProperties : 0;
        }
    else
        {
        // Should always be either tagged object or property
        Assert(FALSE);
        return E_FAIL;
        }

	m_dwIndex += cElements;
    return (m_dwIndex < cMax)? S_OK : S_FALSE;
    }

/*===================================================================
CVariantsIterator::Reset

CVariantsIterator Reset

Parameters:

Returns:
===================================================================*/
STDMETHODIMP CVariantsIterator::Reset()
    {
    m_dwIndex = 0;
    return NO_ERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\cachemgr.cpp ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Template Cache Manager

File: CacheMgr.cpp

Owner: DGottner

Template cache manager implementation
-----------------------------------------------------------------------------*/
#include "denpre.h"
#pragma hdrstop

#include "perfdata.h"
#include "memchk.h"

CTemplateCacheManager   g_TemplateCache;
CIncFileMap             g_IncFileMap;
LONG                    g_nFlushThreads = 0;

BOOL  CTemplateCacheManager::m_fFailedToInitPersistCache = FALSE;
char  CTemplateCacheManager::m_szPersistCacheDir[MAX_PATH];

/*===================================================================
ZapTemplate

Decrement the ref. count of a template to remove it from cache.
If the template is global.asa, that's all we do because application
manager has the last reference.  Otherwise, we Release the template
by calling CTemplate::End() to also free references to it from the
debugger.

Parameters: pTemplate - template pointer to Release() from cache

Returns: new ref. count
===================================================================*/

static inline
ULONG ZapTemplate(CTemplate *pTemplate)
    {
    if (! pTemplate->FGlobalAsa())
        return pTemplate->End();

    else
        return pTemplate->Release();
    }


/*  ****************************************************************************
    CCacheManager member functions
*/

/*===================================================================
CTemplateCacheManager::CTemplateCacheManager

Parameters: N/A

Returns: N/A
===================================================================*/

CTemplateCacheManager::CTemplateCacheManager()
    {
    m_pHashTemplates = NULL;
    m_szPersistCacheDir[0] = '\0';
    m_fFailedToInitPersistCache = FALSE;
    }


/*===================================================================
CTemplateCacheManager::~CTemplateCacheManager

Parameters: N/A

Returns: N/A
===================================================================*/

CTemplateCacheManager::~CTemplateCacheManager()
    {
    }


/*===================================================================
CTemplateCacheManager::Init

Init the template cache manager - phase 1 - that which can be done
with just default values in Glob.

Parameters: None

Returns: Completion Status
===================================================================*/

HRESULT CTemplateCacheManager::Init()
    {
    HRESULT hrInit;
    ErrInitCriticalSection(&m_csUpdate, hrInit);
    if (FAILED(hrInit))
        return(hrInit);

    // allocate the initial CTemplateHashTable

    m_pHashTemplates = new CTemplateHashTable;

    return S_OK;
    }

/*  ****************************************************************************
    CTemplateCacheManager member functions
*/

/*===================================================================
CTemplateCacheManager::UnInit

Parameters: N/A

Returns: Completion status
===================================================================*/

HRESULT CTemplateCacheManager::UnInit()
{

    if (m_pHashTemplates) {
        while (! m_pHashTemplates->FMemoryTemplatesIsEmpty()) {
		    CTemplate *pTemplate = static_cast<CTemplate *>(m_pHashTemplates->MemoryTemplatesBegin());
		    m_pHashTemplates->RemoveTemplate(pTemplate);
		    ZapTemplate(pTemplate);
		}

        while (! m_pHashTemplates->FPersistTemplatesIsEmpty()) {
		    CTemplate *pTemplate = static_cast<CTemplate *>(m_pHashTemplates->PersistTemplatesBegin());
		    m_pHashTemplates->RemoveTemplate(pTemplate);
		    ZapTemplate(pTemplate);
		}
    }
    delete m_pHashTemplates;
    m_pHashTemplates = NULL;

#ifndef PERF_DISABLE
    g_PerfData.Zero_MEMORYTEMPLCACHE();
    g_PerfData.Zero_TEMPLCACHE();
#endif
    DeleteCriticalSection(&m_csUpdate);

    // give any flush threads a chance to finish.  This is necessary
    // to prevent an AV by LKRHash.

    DWORD   maxSecondsToWait = 60;

    while (maxSecondsToWait-- && g_nFlushThreads) {
        Sleep(1000);
    }

    return S_OK;
}

/*===================================================================
CTemplateCacheManager::FindCached

    Get a template from the cache only

Parameters:
    szFile       - file to find in the cache
    ppTemplate   - [out] template object found

Returns:
    HRESULT (S_OK if found, S_FALSE if noe found)
===================================================================*/

HRESULT CTemplateCacheManager::FindCached(const TCHAR *szFile, DWORD dwInstanceID, CTemplate **ppTemplate)
    {
    Assert(IsNormalized(szFile));
    if (!ppTemplate)
    	return E_POINTER;

    LockTemplateCache();

    m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), ppTemplate);
    if (*ppTemplate)
        {
        if (!(*ppTemplate)->m_fReadyForUse)
            *ppTemplate = NULL;         // not ready - as if nor found
        else
            (*ppTemplate)->AddRef();    // addref inside critical section
        }

    UnLockTemplateCache();

    return *ppTemplate? S_OK : S_FALSE;
    }

/*===================================================================
CTemplateCacheManager::Load

    Get a template from the cache, or load it into cache

Parameters:
    szFile - file to load into the cache

Returns: N/A
===================================================================*/

HRESULT CTemplateCacheManager::Load(BOOL fRunGlobalAsp, const TCHAR *szFile, DWORD dwInstanceID, CHitObj *pHitObj, CTemplate **ppTemplate, BOOL *pfTemplateInCache)
    {
    HRESULT hr = S_OK;                   // return value
    HRESULT (CTemplate::*pmAction)(CHitObj *);  // do we need to compile a new template or deliver an existing one?

    Assert(IsNormalized(szFile));

    BOOL fLocked = FALSE;

    // If this is the GLOBAL.ASA we can pick up
    // template directly from the application
    if (fRunGlobalAsp && pHitObj->PAppln()->PGlobalTemplate())
        {
        *ppTemplate = pHitObj->PAppln()->PGlobalTemplate();
        }
    // see if we already have looked up the template on the I/O thread...
    else if (!fRunGlobalAsp && pHitObj->GetTemplate())
        {
        *ppTemplate = pHitObj->GetTemplate();
        pHitObj->SetTemplate(NULL);
        }
    else 
    // Otherwise we have to look for it in the cache
        {
        LockTemplateCache();
        fLocked = TRUE;
        m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), ppTemplate);
        }

    if (*ppTemplate != NULL)
        {
        // Template found in cache -> use it
        (*ppTemplate)->AddRef();
        *pfTemplateInCache = TRUE;

        if (fLocked)    // Global.Asa from App - no lock
            UnLockTemplateCache();

        pmAction = CTemplate::Deliver;
        }
    else
        {
        *pfTemplateInCache = FALSE;

        Assert(fLocked); // only could get here if not found in the hash table
        UnLockTemplateCache();

        // Create and init new template outside of crirical section

        CTemplate *pNewTemplate = new CTemplate;

        if (!pNewTemplate)
            hr = E_OUTOFMEMORY;

        if (SUCCEEDED(hr))
            hr = pNewTemplate->Init(pHitObj, !!fRunGlobalAsp, CTemplateKey(szFile, dwInstanceID));

        if (SUCCEEDED(hr))
            {
            LockTemplateCache();

            // Try to find if inserted by another thread
            m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), ppTemplate);

            if (*ppTemplate != NULL)
                {
                // Template found in cache -> use it
                (*ppTemplate)->AddRef();
                UnLockTemplateCache();
                pmAction = CTemplate::Deliver;
                }
            else
                {

                // since we are creating a new template, call FlushCache to make
                // sure that no script engines are cached with this name

                g_ScriptManager.FlushCache(szFile);

                // Insert the newly created template

                *ppTemplate = pNewTemplate;
                pNewTemplate = NULL; // not to be deleted later

                m_pHashTemplates->InsertTemplate(*ppTemplate);
                (*ppTemplate)->AddRef();

                if (Glob(dwScriptFileCacheSize) == 0) {
                    // This is special case when a valid template
                    // does not get added to the cache
                    // Don't attach such templates to debugger
                    (*ppTemplate)->m_fDontAttach = TRUE;
                }

                UnLockTemplateCache();

                pmAction = CTemplate::Compile;
                }
            }

        // cleanup new template if created but unused
        if (pNewTemplate)
            pNewTemplate->Release();
        }

    if (FAILED(hr))
        return hr;

    // init succeeded: compile or deliver the template, as required
    hr = ((*ppTemplate)->*pmAction)(pHitObj);

    if (pmAction == CTemplate::Compile && (*ppTemplate)->m_fDontCache)
        {
        /*  We were compiling and the compiler alerted us not to cache the failed template.
            Typically, this occurs when compile failure was caused by something other than
            bad template syntax (permissions failure, bad include file reference, etc.).

            We need to roll back to where the template did not exist.
        */

        // de-cache and release the template
        // NOTE we don't nullify template ptr, because we want ExecuteRequest to do the final release

        LockTemplateCache();
        if (m_pHashTemplates->RemoveTemplate(*ppTemplate) == LK_SUCCESS)
            ZapTemplate(*ppTemplate);
        UnLockTemplateCache();

		(*ppTemplate)->Release();
		*ppTemplate = NULL;
        }

    LockTemplateCache();

    // Remove old scripts from cache

    while (!m_pHashTemplates->FMemoryTemplatesIsEmpty()
           && (m_pHashTemplates->InMemoryTemplates() > Glob(dwScriptFileCacheSize))) {
        Assert (!m_pHashTemplates->FMemoryTemplatesIsEmpty());
        CTemplate *pOldTemplate = static_cast<CTemplate *>(m_pHashTemplates->MemoryTemplatesEnd());
        m_pHashTemplates->RemoveTemplate(pOldTemplate, TRUE);
        
        // flush the corresponding script engines.  But only if the template
        // is valid.

        if (pOldTemplate->FIsValid()) {
            g_ScriptManager.FlushCache(pOldTemplate->GetSourceFileName());
        }

        // Only Zap the template if it is not persisted.  The result of the above
        // call to RemoveTemplate is that the template may have been moved from the
        // memory cache to the persist cache.  In which case, the template is still
        // effectively cached.  

        if (pOldTemplate->FIsPersisted() == FALSE) {

            ZapTemplate(pOldTemplate);
        }
    }

    UnLockTemplateCache();

    // Store a pointer to the template with the application
    // if we haven't already done so
    if (SUCCEEDED(hr) && fRunGlobalAsp && pHitObj->PAppln()->PGlobalTemplate() == NULL)
        pHitObj->PAppln()->SetGlobalTemplate(*ppTemplate);

    // If we are shutting down, don't request change notification

    if (!IsShutDownInProgress())
        {
        // If running on NT, and we just compiled the template
        // register all the directories used by this template
        // for change notification
        if (FIsWinNT() && pmAction == CTemplate::Compile && SUCCEEDED(hr)) {
            if (!RegisterTemplateForChangeNotification(*ppTemplate, pHitObj->PAppln())) {
                LockTemplateCache();
                if (m_pHashTemplates->RemoveTemplate(*ppTemplate) == LK_SUCCESS)
                    ZapTemplate(*ppTemplate);
                UnLockTemplateCache();
            }
        }

        // If running on NT, this is a new application, and the template is a global.asa
        // register this application for file change notifications
        if (FIsWinNT() && SUCCEEDED(hr) && (*ppTemplate)->m_fGlobalAsa && pHitObj->FStartApplication())
            {
            RegisterApplicationForChangeNotification(*ppTemplate, pHitObj->PAppln());
            }
        }

    return hr;
    }



/*===================================================================
CTemplateCacheManager::Flush

Parameters:
    szFile - the file to remove from cache

Returns:
    None
===================================================================*/

void CTemplateCacheManager::Flush(const TCHAR *szFile, DWORD dwInstanceID)
    {
    LockTemplateAndIncFileCaches();

    Assert (IsNormalized(szFile));
    CTemplate *pTemplate;
    m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), &pTemplate);

    while (pTemplate != NULL)
        {
#ifndef PERF_DISABLE
        g_PerfData.Incr_TEMPLFLUSHES();
#endif

		m_pHashTemplates->RemoveTemplate(pTemplate);

        // Make sure anyone using this template can tell it is obsolete
        pTemplate->Zombify();

        // Don't flush engines if this is a global.asa file
        // We'll need the engines to run Application_OnEnd
        // The application will flush the engine from the cache
        // when it unints
        if (!FIsGlobalAsa(szFile))
            {
            g_ScriptManager.FlushCache(szFile);
            }

        ZapTemplate(pTemplate);

        // If wildcard was specified in Flush for Instance ID, there may be
        // more templates to remove.
        m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), &pTemplate);
        }

    UnLockTemplateAndIncFileCaches();
    }

/*===================================================================
CTemplateCacheManager::FlushAll

    Completely empties the template cache

Parameters:
    None

Returns:
    None
===================================================================*/

void CTemplateCacheManager::FlushAll(VOID)
    {
    LockTemplateAndIncFileCaches();

    CTemplateHashTable  *pNewTable = NULL;
    HANDLE              hnd;
    
    // note that all of the following logic works on the premise that any
    // error causes the code to fall into the old mechanism of flushing
    // the hash table in place...

    // allocate a new table

    if (!(pNewTable = new CTemplateHashTable));

    // Create a thread to clean up the old table

    else if (!(hnd = CreateThread(NULL, 0, CTemplateCacheManager::FlushHashTableThread, m_pHashTemplates, 0, NULL)));

    else {

        // all the above was successful, so note that the new table is the
        // current table in the cache, cleanup and exit.

        DBGPRINTF((DBG_CONTEXT, "[CTemplateCacheManager] Flushing entire cache on another thread.\n"));

        InterlockedIncrement(&g_nFlushThreads);
        m_pHashTemplates = pNewTable;
        CloseHandle(hnd);
        UnLockTemplateAndIncFileCaches();

        return;
    }

    // delete the new table if something above failed.

    if (pNewTable)
        delete pNewTable;

    DBGPRINTF((DBG_CONTEXT, "[CTemplateCacheManager] Flushing entire cache in place\n"));

    FlushHashTable(m_pHashTemplates);

    UnLockTemplateAndIncFileCaches();

    return;
}

/*===================================================================
CTemplateCacheManager::FlushHashTableThread

    Thread spun up by CTemplateCacheMgr::FlushAll() to flush all
    templates in the cache but not while under the critical section
    on the notification thread.  Prevents unwanted contention on the
    cache.

Parameters:
    None

Returns:
    None
===================================================================*/

DWORD CTemplateCacheManager::FlushHashTableThread(VOID  *pArg)
{
    CTemplateHashTable  *pTable = (CTemplateHashTable *)pArg;

    Assert(pTable);

    FlushHashTable(pTable);

    delete pTable;

    InterlockedDecrement(&g_nFlushThreads);

    return S_OK;
}

/*===================================================================
CTemplateCacheManager::FlushHashTable

    Does the actual work of flushing the templates.

    This routine may or may not be under the global cache manager
    crit sec.  It will if the flush is happening on the notification
    thread.  It won't be if it's happening on the FlushHashTableThread.

Parameters:
    None

Returns:
    None
===================================================================*/

void CTemplateCacheManager::FlushHashTable(CTemplateHashTable  *pTable)
{
    // Delete templates from the cache until there are no more

    while (!pTable->FMemoryTemplatesIsEmpty()) {
        CTemplate *pTemplate = static_cast<CTemplate *>(pTable->MemoryTemplatesEnd());

        // Remove the template from its various data structures
		pTable->RemoveTemplate(pTemplate);

        // Make sure anyone using this template can tell it is obsolete
        pTemplate->Zombify();

        // Flush the engine for this template from the script engine cache
		//   (use hash key, in case template was previously a zombie.)
        g_ScriptManager.FlushCache(pTemplate->ExtractHashKey()->szPathTranslated);

        ZapTemplate(pTemplate);

    }

    // Delete templates from the cache until there are no more

    while (!pTable->FPersistTemplatesIsEmpty()) {
        CTemplate *pTemplate = static_cast<CTemplate *>(pTable->PersistTemplatesEnd());

        // Remove the template from its various data structures
		pTable->RemoveTemplate(pTemplate);

        // Make sure anyone using this template can tell it is obsolete
        pTemplate->Zombify();

        // Flush the engine for this template from the script engine cache
		//   (use hash key, in case template was previously a zombie.)
        g_ScriptManager.FlushCache(pTemplate->ExtractHashKey()->szPathTranslated);

        ZapTemplate(pTemplate);

    }
}


/*===================================================================
CTemplateCacheManager::FlushFiles

    Empties template cache of files that match a prefix

Parameters:
    None

Returns:
    None
===================================================================*/

void CTemplateCacheManager::FlushFiles(const TCHAR *szFilePrefix)
{
    LockTemplateAndIncFileCaches();
    BOOL    fDoingMemoryTemplates = TRUE;

    // Delete templates from the cache until there are no more

	CDblLink *pLink = m_pHashTemplates->MemoryTemplatesBegin();
	while (! (fDoingMemoryTemplates 
                ? m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pLink)
                : m_pHashTemplates->FPersistTemplatesDblLinkAtEnd(pLink))) {

		CDblLink *pNextLink = pLink->PNext();
		CTemplate *pTemplate = static_cast<CTemplate *>(pLink);

		if (_tcsncmp(pTemplate->ExtractHashKey()->szPathTranslated, szFilePrefix, _tcslen(szFilePrefix)) == 0) {
#if UNICODE
			DBGPRINTF((DBG_CONTEXT, "FlushFiles: flushing %S\n", pTemplate->ExtractHashKey()->szPathTranslated));
#else
            DBGPRINTF((DBG_CONTEXT, "FlushFiles: flushing %s\n", pTemplate->ExtractHashKey()->szPathTranslated));
#endif
			// Remove the template from its various data structures
			m_pHashTemplates->RemoveTemplate(pTemplate);

			// Make sure anyone using this template can tell it is obsolete
			pTemplate->Zombify();

			// Flush the engine for this template from the script engine cache
			//   (use hash key, in case template was previously a zombie.)
			g_ScriptManager.FlushCache(pTemplate->ExtractHashKey()->szPathTranslated);

			ZapTemplate(pTemplate);

#ifndef PERF_DISABLE
			g_PerfData.Incr_TEMPLFLUSHES();
#endif
        }

		pLink = pNextLink;

        if (fDoingMemoryTemplates && m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pLink)) {
            fDoingMemoryTemplates = FALSE;
            pLink = m_pHashTemplates->PersistTemplatesBegin();
        }
    }

    UnLockTemplateAndIncFileCaches();
}


/*===================================================================
CTemplateCacheManager::AddApplicationToDebuggerUI

    Loop through the template cache, and create doc nodes for
    all templates that belong to the application

Parameters:
    pAppln - pointer to application to attach to.

Returns: N/A
===================================================================*/

void CTemplateCacheManager::AddApplicationToDebuggerUI(CAppln *pAppln)
    {
    CDblLink *pLink;
    for (pLink = m_pHashTemplates->MemoryTemplatesBegin(); !m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pLink); pLink = pLink->PNext())
        {
        // Bug  92070:
        //   Determine if the template is a member of pAppln by comparing
        //   the virtual path of the template to the application's virtual
        //   path (previously compared physical paths)  Since a template
        //   can have multiple virtual paths, only the first instance wins.
        //   Thus the template will only appear in the application that first
        //   loaded it.

		CTemplate *pTemplate = static_cast<CTemplate *>(pLink);
        if (_tcscmp(pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL), pTemplate->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)) == 0)
            pTemplate->AttachTo(pAppln);
        }
    }



/*===================================================================
CTemplateCacheManager::RemoveApplicationFromDebuggerUI

    Loop through the template cache, and remove doc nodes for
    all templates that belong to the application

Parameters:
    pAppln - pointer to application to detach from
             if pAppln is NULL, detach from ALL applications


Returns: N/A
===================================================================*/

void CTemplateCacheManager::RemoveApplicationFromDebuggerUI(CAppln *pAppln)
    {
    CDblLink *pLink;
    for (pLink = m_pHashTemplates->MemoryTemplatesBegin(); 
         !m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pLink); 
         pLink = pLink->PNext())
        {
		CTemplate *pTemplate = static_cast<CTemplate *>(pLink);
        if (pAppln != NULL)
            pTemplate->DetachFrom(pAppln);
        else
            pTemplate->Detach();
        }
    }

/*===================================================================
void CTemplateCacheManager::RegisterTemplateForChangeNotification

    Request to watch template directories for file changes

Parameters:
    A pointer to the template

Returns:
    BOOL    True if successfully registered for change notification
===================================================================*/
BOOL CTemplateCacheManager::RegisterTemplateForChangeNotification(CTemplate *pTemplate, CAppln  *pApplication)
{

    STACK_BUFFER( tempPath, MAX_PATH );

    // Doesnt happen on Win95
    if (!FIsWinNT()) {
        return FALSE;
    }

    for (DWORD i = 0; i < pTemplate->m_cFilemaps; i++) {
        // Check if this directory is already registered for change notification

        // Pick out the directory portion of the path
        TCHAR *szEndOfPath = _tcsrchr(pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, _T('\\'));
        size_t cch = DIFF(szEndOfPath - pTemplate->m_rgpFilemaps[i]->m_szPathTranslated)+1;

        if (tempPath.Resize((cch * sizeof(TCHAR)) + sizeof(TCHAR)) == FALSE) {

            // if failure to resize, continue registering...
            continue;
        }
        TCHAR *szPath = (TCHAR *) tempPath.QueryPtr();
        _tcsncpy(szPath, pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, cch);
        szPath[cch] = 0;

        // if the template is within the application's physical path, then it is
        // already being monitored.

        CASPDirMonitorEntry *pDME = NULL;

        if (pDME = pApplication->FPathMonitored(szPath)) {
            pDME->AddRef();
            pTemplate->m_rgpFilemaps[i]->m_pDME= pDME;
            continue;
        }

        if (RegisterASPDirMonitorEntry(szPath, &pDME)) {
            Assert(pDME);
            pTemplate->m_rgpFilemaps[i]->m_pDME= pDME;
        }
        else {
            // the current file failed to register.  Release all previous DMEs
            // and return FALSE...

            if (i > 0) {
                while (--i) {

                    pTemplate->m_rgpFilemaps[i]->m_pDME->Release();
                    pTemplate->m_rgpFilemaps[i]->m_pDME = NULL;
                }
            }
            return FALSE;

        }
    }
    return TRUE;
}

/*===================================================================
void CTemplateCacheManager::RegisterApplicationForChangeNotification

    Request to watch template directories for file changes

Parameters:
    A pointer to the template

Returns:
    BOOL    True if successfully registered for change notification
===================================================================*/
BOOL CTemplateCacheManager::RegisterApplicationForChangeNotification(CTemplate *pTemplate, CAppln *pApplication)
    {

    STACK_BUFFER( tempPath, MAX_PATH );

    // Doesnt happen on Win95
    if (!FIsWinNT())
        {
        return FALSE;
        }

    // Start with 1 to skip GLOBAL.ASA that is always added
    // in hitobj.cpp when new application gets created

    for (DWORD i = 1; i < pTemplate->m_cFilemaps; i++)
        {

        // Add to list of file-application mappings
        g_FileAppMap.AddFileApplication(pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, pApplication);

        // Check if this directory is already registered for change notification
        // Pick out the directory portion of the path
        TCHAR *szEndOfPath = _tcsrchr(pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, _T('\\'));
        size_t cch = DIFF(szEndOfPath - pTemplate->m_rgpFilemaps[i]->m_szPathTranslated) + 1;

        if (tempPath.Resize((cch*sizeof(TCHAR)) + sizeof(TCHAR)) == FALSE) {

            // if failure, continue registering anyway...
            continue;
        }
        TCHAR *szPath = (TCHAR *) tempPath.QueryPtr();
        _tcsncpy(szPath, pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, cch);
        szPath[cch] = 0;

        // if the template is within the application's physical path, then it is
        // already being monitored.

        if (pApplication->FPathMonitored(szPath)) {

            continue;
        }

        // Register directory for monitoring
        CASPDirMonitorEntry *pDME = NULL;
        if (RegisterASPDirMonitorEntry(szPath, &pDME))
            {
            Assert(pDME);
            pApplication->AddDirMonitorEntry(pDME);
            }
        }

    return TRUE;
    }


/*===================================================================
BOOL CTemplateCacheManager::ShutdownCacheChangeNotification

    Turn off change notification for changes to files in the cache

Parameters:
    None

Returns:
    Nothing
===================================================================*/
BOOL CTemplateCacheManager::ShutdownCacheChangeNotification()
    {

    BOOL fDoingMemoryTemplates = TRUE;
    // Doesnt happen on Win95
    if (!FIsWinNT())
        {
        return FALSE;
        }

    LockTemplateCache();

    CTemplate *pTemplate = static_cast<CTemplate *>(m_pHashTemplates->MemoryTemplatesBegin());
    while (fDoingMemoryTemplates
             ? !m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pTemplate)
             : !m_pHashTemplates->FPersistTemplatesDblLinkAtEnd(pTemplate)) {

        if(pTemplate->m_rgpFilemaps)
            {
            for(UINT i = 0; i < pTemplate->m_cFilemaps; i++)
                {
                // Give up our ref count on the directory monitor entry
                if (pTemplate->m_rgpFilemaps[i]->m_pDME)
                    {
                    pTemplate->m_rgpFilemaps[i]->m_pDME->Release();
                    pTemplate->m_rgpFilemaps[i]->m_pDME = NULL;
                    }
                }
            }

        pTemplate = static_cast<CTemplate *>(pTemplate->PNext());
        if (fDoingMemoryTemplates && m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pTemplate)) {
            fDoingMemoryTemplates = FALSE;
            pTemplate = static_cast<CTemplate *>(m_pHashTemplates->PersistTemplatesBegin());
        }
    }

    UnLockTemplateCache();
    return TRUE;
    }

/*  ****************************************************************************
    CIncFileMap member functions
*/

/*===================================================================
CIncFileMap::CIncFileMap

Parameters: N/A

Returns: N/A
===================================================================*/

CIncFileMap::CIncFileMap()
    {
    }


/*===================================================================
CIncFileMap::~CIncFileMap

Parameters: N/A

Returns: N/A
===================================================================*/

CIncFileMap::~CIncFileMap()
    {
    }



/*===================================================================
CIncFileMap::Init

Parameters: None

Returns: Completion Status
===================================================================*/

HRESULT CIncFileMap::Init()
    {
    HRESULT hr;
    ErrInitCriticalSection(&m_csUpdate, hr);
    if (FAILED(hr))
        return(hr);
    return m_mpszIncFile.Init(CINCFILEBUCKETS);
    }


/*===================================================================
CIncFileMap::GetIncFile

    Get an inc-file from the cache, first storing it into cache if it is not yet there.

Parameters:
    szIncFile   - file name
    ppIncFile   - ptr-to-ptr to inc-file (out-parameter)

Returns: HRESULT
===================================================================*/

HRESULT CIncFileMap::GetIncFile(const TCHAR *szFile, CIncFile **ppIncFile)
    {
    HRESULT hrInit = S_OK;           // return value

    LockIncFileCache();

    Assert(IsNormalized(szFile));
    *ppIncFile = static_cast<CIncFile *>(m_mpszIncFile.FindElem(szFile, _tcslen(szFile)*sizeof(TCHAR)));

    // if we have a cached inc-file at this stage, it must be "reliable," so we use it.
    // else, if we have no cached inc-file, create a new one.
    if (*ppIncFile == NULL)
        {
        if ((*ppIncFile = new CIncFile) == NULL)
            {
            UnLockIncFileCache();
            return E_OUTOFMEMORY;
            }

        if (SUCCEEDED(hrInit = (*ppIncFile)->Init(szFile)))
            {
            // The hash table will hold a reference to the inc file
            (*ppIncFile)->AddRef();
            m_mpszIncFile.AddElem(*ppIncFile);
            }
        else
            *ppIncFile = NULL;

        }

    if (SUCCEEDED(hrInit))
        {
        // The caller will hold a reference to the inc file
        (*ppIncFile)->AddRef();
        }

    UnLockIncFileCache();

    return hrInit;
    }



/*===================================================================
CIncFileMap::UnInit

Parameters: N/A

Returns: Completion status
===================================================================*/

HRESULT CIncFileMap::UnInit()
    {
    CIncFile *pNukeIncFile = static_cast<CIncFile *>(m_mpszIncFile.Head());
    while (pNukeIncFile != NULL)
        {
        CIncFile *pNext = static_cast<CIncFile *>(pNukeIncFile->m_pNext);
        pNukeIncFile->OnIncFileDecache();
        pNukeIncFile->Release();
        pNukeIncFile = pNext;
        }
    DeleteCriticalSection(&m_csUpdate);
    return m_mpszIncFile.UnInit();
    }



/*===================================================================
CIncFileMap::Flush

Parameters:
    szFile - the file to remove from cache

Returns:
    None
===================================================================*/

void CIncFileMap::Flush(const TCHAR *szFile)
    {
    LockTemplateAndIncFileCaches();

    Assert(IsNormalized(szFile));
    CIncFile *pIncFile = static_cast<CIncFile *>(m_mpszIncFile.FindElem(szFile, _tcslen(szFile)*sizeof(TCHAR)));

    if (pIncFile != NULL)
        {
        if (pIncFile->FlushTemplates())
            {
            // Remove from hash table
            m_mpszIncFile.DeleteElem(szFile, _tcslen(szFile)*sizeof(TCHAR));
            // The hash table gave up its reference
            // to the incfile
            pIncFile->OnIncFileDecache();
            pIncFile->Release();
            }
        }

    UnLockTemplateAndIncFileCaches();
    }



/*===================================================================
CIncFileMap::FlushFiles

Parameters:
    szFile - the file prefix to search for in cache

Returns:
    None
===================================================================*/

void CIncFileMap::FlushFiles(const TCHAR *szFilePrefix)
    {
    LockTemplateAndIncFileCaches();

    Assert(IsNormalized(szFilePrefix));
    CIncFile *pIncFile = static_cast<CIncFile *>(m_mpszIncFile.Head());

    while (pIncFile != NULL)
        {
		CIncFile *pNextFile = static_cast<CIncFile *>(pIncFile->m_pNext);

		int cchFilePrefix = _tcslen(szFilePrefix);
		if (pIncFile->m_cbKey >= (cchFilePrefix*(int)sizeof(TCHAR)) &&
		    _tcsncmp(reinterpret_cast<TCHAR *>(pIncFile->m_pKey), szFilePrefix, cchFilePrefix) == 0)
			{
#if UNICODE
			DBGPRINTF((DBG_CONTEXT, "FlushFiles: flushing %S\n", pIncFile->m_pKey));
#else
            DBGPRINTF((DBG_CONTEXT, "FlushFiles: flushing %s\n", pIncFile->m_pKey));
#endif
            if (pIncFile->FlushTemplates())
				{
				// Remove from hash table
				m_mpszIncFile.DeleteElem(pIncFile->m_pKey, pIncFile->m_cbKey);
				// The hash table gave up its reference
				// to the incfile
				pIncFile->OnIncFileDecache();
				pIncFile->Release();
				}
			}

		pIncFile = pNextFile;
        }

    UnLockTemplateAndIncFileCaches();
    }



/*  ****************************************************************************
    Non-class support functions
*/

/*===================================================================
FFileChangedSinceCached
Has the file changed since it was cached?

Parameters:
    szFile          - file name
    ftPrevWriteTime - the file's "previous write time"
                      (its last-write-time value when the file was cached)

Returns:
    TRUE or FALSE
===================================================================*/
BOOL FFileChangedSinceCached(const TCHAR *szFile, FILETIME& ftPrevWriteTime)
    {
    WIN32_FILE_ATTRIBUTE_DATA   fad;            // win32 file attributes data structure
    BOOL                        fRet = FALSE;   // return value

    // This fn doesnt exist on Win95.  On Win95 we do no caching anyway, so we dont care.
    if (!FIsWinNT())
        return(TRUE);

    if (FAILED(AspGetFileAttributes(szFile, &fad)))
        {
        // assume file was changed if get file attributes failed
        fRet = TRUE;
        }

    if( 0 != CompareFileTime( &ftPrevWriteTime, &(fad.ftLastWriteTime) ) )
        {
        // file was changed if file times differ
        fRet = TRUE;
        }

    return fRet;
    }

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::TrimPersistCache

Parameters:
    dwTrimCount - the number of templates to trim from the cache

Returns:
    TRUE - if dwTrimCount was actually trimmed
    FALSE - if exited before dwTrimCount was met

===================================================================*/

BOOL CTemplateCacheManager::CTemplateHashTable::TrimPersistCache(DWORD  dwTrimCount)
{
    // enter a while loop to trim until the count is reached

    while(dwTrimCount--) {

        // if there isn't anything else to trim, we're done.  Return FALSE
        // to indicate that dwTrimCount was not met.

        if (m_dwPersistedTemplates == 0) {
            return(FALSE);
        }
        else {

            CTemplate   *pTemplate;

            // get the oldest template from the list

            pTemplate = static_cast<CTemplate *>(PersistTemplatesEnd());

            // remove the template.

            RemoveTemplate(pTemplate);

            ZapTemplate(pTemplate);

        }
    }

    // return TRUE to indicate that the TrimCount was met.
    return(TRUE);
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::ScavengePersistCache

Parameters:
    <NONE>

Returns:
    VOID

===================================================================*/
VOID CTemplateCacheManager::CTemplateHashTable::ScavengePersistCache()
{
    CTemplate   *pTemplate;
    CTemplate   *pTemplateNext;

    // enter a for loop to look at all persisted templates to see if
    // any memory can be freed.  It's memory can be freed only if the
    // ref count is 1 (the sole ref count is for the cache).  Also note
    // that the list is re-ordered to move templates to the head of the
    // list that can't have their memory freed at this time because of
    // the ref count.  

    for (pTemplate = static_cast<CTemplate *>(PersistTemplatesBegin());
         (pTemplate != static_cast<CTemplate *>(&m_listPersistTemplates)) && (pTemplate->m_pbStart != NULL);
         pTemplate = pTemplateNext) {

        pTemplateNext = static_cast<CTemplate *>(pTemplate->PNext());

        // this check should be safe.  The only risk is that we miss a release
        // of the template from 2 to 1, in which case will miss it this time
        // but get it the next time through.  AddRef from 1 to 2 is impossible
        // to interrupt because it couldn't be on this list when it gets AddRef'd
        // from 1 to 2 and moving it from this list is protected by the template
        // cache lock which we should be under.

        if (pTemplate->m_cRefs == 1) {

            // remove the memory

            CTemplate::LargeFree(pTemplate->m_pbStart);
            pTemplate->m_pbStart = NULL;
        }
        else {
            
            // if some is still using it, move the template to the head of the
            // list so that we'll check again later.

            pTemplate->PrependTo(m_listPersistTemplates);
        }
    }
}

/*===================================================================
    GetAggregatedTemplCounter()

    Returns the Template Perf Counter.  To do this, initializes a private
    copy of the perfmainblock and aggregates the stats into it.

===================================================================*/
static DWORD GetAggregatedTemplCounter()
{

    CPerfMainBlock  perfSharedBlk;
    DWORD           pdwCounters[C_PERF_PROC_COUNTERS];
    BOOL            bInited = FALSE;

    memset(pdwCounters, 0, sizeof(pdwCounters));

    if (!(bInited = (perfSharedBlk.Init() == S_OK)));

    else {
        
        perfSharedBlk.GetStats(pdwCounters);
    }

    if (bInited)
        perfSharedBlk.UnInit();

    return(pdwCounters[ID_TEMPLCACHE]);
}

/*===================================================================
 CTemplateCacheManager::InitPersistCache

Parameters:
    [none]

Returns:
    BOOL to indicate if the init was successful

===================================================================*/

BOOL    CTemplateCacheManager::InitPersistCache()
{
    HANDLE      hImpersonationToken = NULL;
    BOOL        fRevertedToSelf = FALSE;
    HANDLE      hThread;

    hThread = GetCurrentThread();

    if (OpenThreadToken( hThread,
                         TOKEN_READ | TOKEN_IMPERSONATE,
                         TRUE,           
                         &hImpersonationToken )) {

       RevertToSelf();
       fRevertedToSelf = TRUE;
    }

    // get the PersistCacheDir from the globals table

    strcpy(m_szPersistCacheDir,Glob(pszPersistTemplateDir));

    // Check to see if the directory exists...

    DWORD   dirAttribs = GetFileAttributesA(m_szPersistCacheDir);

    if ((dirAttribs == 0xffffffff)
        || !(dirAttribs & FILE_ATTRIBUTE_DIRECTORY)) {

        MSG_Error(IDS_CACHE_DIR_MISSING);
        m_fFailedToInitPersistCache = TRUE;
    }
    else {

        // append the trailing slash to the directory name

        strcat(m_szPersistCacheDir,"\\");

        // next, cleanup the temp directory.

        // since asp.dll can execute in many process simultaneously, we'll
        // check the perf counter to see if there are any templates
        // cached anywhere on the system.  

        if (GetAggregatedTemplCounter() == 0) {

            CHAR DirectoryWildcard[MAX_PATH];
            WIN32_FIND_DATAA win32FindData;

            strcpy(DirectoryWildcard, m_szPersistCacheDir);
            strcat(DirectoryWildcard, "ASP*.TMP");

            // use FindFirstFile to begin the enumeration of all files in the 
            // temp directory.

            HANDLE hDirectory = FindFirstFileA( DirectoryWildcard, &win32FindData );

            if ( hDirectory != INVALID_HANDLE_VALUE ) {

                BOOL success = TRUE;

                while ( success ) {

                    char fileName[MAX_PATH];
                
                    // FindFirst/FindNext returns just the filename.  Build up
                    // the entire path and then call DeleteFile.  We'll ignore
                    // errors as there isn't much we could do with the error
                    // except fail the cache init.

                    strcpy( fileName, m_szPersistCacheDir );
                    strcat( fileName, win32FindData.cFileName );

                    DeleteFileA( fileName );

                    success = FindNextFileA( hDirectory, &win32FindData );
                }

                FindClose( hDirectory );
            }
            else {
                GetLastError();
            }
        }
    }

    if (fRevertedToSelf) {
        SetThreadToken(&hThread, hImpersonationToken);
    }

    return(!m_fFailedToInitPersistCache);
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::CanPersistTemplate

Parameters:
    pTemplate - The template to test for persistability

Returns:
    BOOL to indicate if template can be persisted.

===================================================================*/

BOOL CTemplateCacheManager::CTemplateHashTable::CanPersistTemplate(CTemplate  *pTemplate)
{

    // if MaxFiles is zero, then the persist cache is disabled

    if (Glob(dwPersistTemplateMaxFiles) == 0) {
        return(FALSE);
    }

    // can't persist if the persist cache failed to init

    if (m_fFailedToInitPersistCache == TRUE) {
        return(FALSE);
    }

    // can't persist templates that are marked as debuggable.  The 
    // script engines need access to the memory.

    if (pTemplate->FDebuggable()) {
        return(FALSE);
    }

    // at this point, we're going to return true.  The next part of the code
    // trims the cache as necessary.

    if (m_dwPersistedTemplates >= Glob(dwPersistTemplateMaxFiles)) {
        TrimPersistCache(m_dwPersistedTemplates - Glob(dwPersistTemplateMaxFiles) + 1);
    }

    return(TRUE);
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::InsertTemplate

Parameters:
    pTemplate - Template to insert into the memory cache

Returns:
    LK_RETCODE indicating the success of the insertion

===================================================================*/

LK_RETCODE CTemplateCacheManager::CTemplateHashTable::InsertTemplate(CTemplate *pTemplate)
{
	LK_RETCODE rcode = InsertRecord(pTemplate, true);

	if (rcode == LK_SUCCESS) {
#ifndef PERF_DISABLE
        g_PerfData.Incr_MEMORYTEMPLCACHE();
        g_PerfData.Incr_TEMPLCACHE();
#endif
        m_dwInMemoryTemplates++;
		pTemplate->PrependTo(m_listMemoryTemplates);
        pTemplate->SetHashTablePtr(this);
    }

    ScavengePersistCache();

	return rcode;
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::RemoveTemplate

Parameters:
    pTemplate - Template to remove from cache
    fPersist - indicate if memory template is a candidate for persist

Returns:
    LK_RETCODE indicating the success of the removal

===================================================================*/

LK_RETCODE CTemplateCacheManager::CTemplateHashTable::RemoveTemplate(CTemplate *pTemplate, BOOL fPersist)
{
	LK_RETCODE rcode = LK_SUCCESS;
#if DBG_PERSTEMPL
    DBGPRINTF((DBG_CONTEXT, 
              "RemoveTemplate entered.\n\tTemplate = %s.\n\tfPersist = %d.\n\tFIsPersisted = %d\n",
              pTemplate->GetSourceFileName(),
              fPersist,
              pTemplate->FIsPersisted()));
#endif

    // if the template isn't in the cache, or if the template isn't on this
    // particular hash table, then just bail.  Nothing to
    // do here.  It may not be on this particular hash table because the entire
    // table may have been torn off the global cache manager and scheduled for
    // cleanup on the flush thread.  In this case, we're checking the wrong
    // table.  The flush thread will eventually clean this one up.

    if (pTemplate->FIsEmpty() || (pTemplate->GetHashTablePtr() != this)) {

        return LK_NO_SUCH_KEY;
    }

    // no matter what, this template is going to be unlinked from it's
    // current CDblLink

    pTemplate->UnLink();

    // update the appropriate counter

    if (pTemplate->FIsPersisted() == FALSE) {

        // decrement the number of InMemoryTemplates...

#ifndef PERF_DISABLE
        g_PerfData.Decr_MEMORYTEMPLCACHE();
#endif
        m_dwInMemoryTemplates--;
    }
    else {
        m_dwPersistedTemplates--;
    }

    // if asked to be persisted, see if it's a candidate to be persisted.

    if (fPersist && CanPersistTemplate(pTemplate)) {

        // so persist it.

        if (pTemplate->PersistData(m_szPersistCacheDir) != S_OK) {

            // a failure will result in the record being deleted.

#ifndef PERF_DISABLE
            g_PerfData.Decr_TEMPLCACHE();
#endif
            rcode = DeleteRecord(pTemplate);

        }
        else {

            // if successfully persisted, then add to the list of
            // persisted templates

            pTemplate->PrependTo(m_listPersistTemplates);

            m_dwPersistedTemplates++;
        }
    }
    else {

#ifndef PERF_DISABLE
            g_PerfData.Decr_TEMPLCACHE();
#endif
        // if not asked to persist, then delete the record.

        rcode = DeleteRecord(pTemplate);
    }

    ScavengePersistCache();

	return rcode;
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::FindTemplate

Parameters:
    rTemplate - the key for the template being looked up

Returns:
    LK_RETCODE indicating the success of the look up

===================================================================*/

LK_RETCODE  CTemplateCacheManager::CTemplateHashTable::FindTemplate(const CTemplateKey &rTemplateKey, CTemplate **ppTemplate)
 {

#if DBG_PERSTEMPL

    DBGPRINTF((DBG_CONTEXT, 
              "FindTemplate entered\n\tLooking for %s\n",
              rTemplateKey.szPathTranslated));
#endif

#ifndef PERF_DISABLE
    g_PerfData.Incr_MEMORYTEMPLCACHETRYS();
    g_PerfData.Incr_TEMPLCACHETRYS();
#endif

    LK_RETCODE rcode = FindKey(&rTemplateKey, ppTemplate);

    // see if we found it.

	if (rcode == LK_SUCCESS) {

#if DBG_PERSTEMPL

        DBGPRINTF((DBG_CONTEXT, 
                   "Template found\n\tfPersisted = %d\n",
                   (*ppTemplate)->FIsPersisted()));
#endif                  

#ifndef PERF_DISABLE
            g_PerfData.Incr_TEMPLCACHEHITS();
#endif
        // found it.  Is it persisted?

        if ((*ppTemplate)->FIsPersisted()) {

            // It is persisted.  Unlink it from the persisted list.

            (*ppTemplate)->UnLink();

            m_dwPersistedTemplates--;

            // unpersist it

            if ((*ppTemplate)->UnPersistData() != S_OK) {

                // error occurred

                // get the template out of the cache

                DeleteRecord(*ppTemplate);

                // release the reference that the cache had on the template

                (*ppTemplate)->Release();

                // NULL out *ppTemplate so that the caller doesn't think they
                // got a valid template

                *ppTemplate = NULL;

#ifndef PERF_DISABLE
                g_PerfData.Decr_TEMPLCACHE();
#endif
                // return NO_SUCH_KEY so that a new template will be built

                return(LK_NO_SUCH_KEY);
            }

            // bump the number of in memory templates

#ifndef PERF_DISABLE
            g_PerfData.Incr_MEMORYTEMPLCACHE();
#endif
            m_dwInMemoryTemplates++;
        }
        else {
#ifndef PERF_DISABLE
            g_PerfData.Incr_MEMORYTEMPLCACHEHITS();
#endif
        }

        // add it to, or move it to the top of, the memory templates

		(*ppTemplate)->PrependTo(m_listMemoryTemplates);
    }

    ScavengePersistCache();

	return rcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\dbgcxt.h ===
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

File:			dbgcxt.h
Maintained by:	DGottner
Component:		include file for IDebugDocumentContext
==============================================================================*/

#ifndef _DBGCXT_H
#define _DBGCXT_H

#include "activdbg.h"

/*	These GUIDs exist to enable the document to determine if an arbitrary
	IDebugDocumentContext object belongs to its document class.  QueryInterface
	for this GUID causes the IDebugDocument object to return a pointer to
	the CDocumentContext (or CIncFileContext) class.
*/
extern const GUID IID_IDenaliTemplateDocumentContext;
extern const GUID IID_IDenaliIncFileDocumentContext;


/*	============================================================================
	Class:		CTemplateDocumentContext
	Synopsis:	implementation of IDebugDocumentContext for CTemplate objects
*/
class CTemplateDocumentContext : public IDebugDocumentContext
	{
friend class CTemplate;		// CTemplate is only user who even cares about this stuff

public:
	// IUnknown methods

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(const GUID &guid, void **ppvObj);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

	// IDebugDocumentContext methods

	virtual HRESULT STDMETHODCALLTYPE GetDocument(
		/* [out] */ IDebugDocument **ppDebugDocument);
 
	virtual HRESULT STDMETHODCALLTYPE EnumCodeContexts(
		/* [out] */ IEnumDebugCodeContexts **ppEnum);
        
	// Constructor & destructor

	CTemplateDocumentContext(
					CTemplate *pTemplate,
					ULONG cchSourceOffset,
					ULONG cchText,
					IActiveScriptDebug *pDebugScript = NULL,	// cached values
					ULONG idEngine = -1,						// only initialize ctor if
					ULONG cchTargetOffset = -1					// values happen to be on hand
					);


	~CTemplateDocumentContext();

private:
	IActiveScriptDebug *m_pDebugScript;		// pointer to script engine
	CTemplate *			m_pTemplate;		// pointer to source document
	ULONG				m_idEngine;			// Engine # in template
	ULONG				m_cchSourceOffset;	// character offset in source
	ULONG				m_cchTargetOffset;	// character offset in target (cached)
	ULONG				m_cchText;			// # of characters in the context
	LONG				m_cRefs;			// reference count
	};


/*	============================================================================
	Class:		CIncFileDocumentContext
	Synopsis:	implementation of IDebugDocumentContext for CIncFile objects
*/
class CIncFileDocumentContext : public IDebugDocumentContext
	{
friend class CIncFile;						// CIncFile is only user who even cares about this stuff
friend class CIncFileEnumCodeContexts;		// iterator class

public:
	// IUnknown methods

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(const GUID &guid, void **ppvObj);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

	// IDebugDocumentContext methods

	virtual HRESULT STDMETHODCALLTYPE GetDocument(
		/* [out] */ IDebugDocument **ppDebugDocument);
 
	virtual HRESULT STDMETHODCALLTYPE EnumCodeContexts(
		/* [out] */ IEnumDebugCodeContexts **ppEnum);
        
	// Constructor & destructor

	CIncFileDocumentContext(
					CIncFile *pIncFile,
					ULONG cchSourceOffset,
					ULONG cchText
					);


	~CIncFileDocumentContext();

private:
	CIncFile *			m_pIncFile;			// pointer to source document
	ULONG				m_cchSourceOffset;	// character offset in source
	ULONG				m_cchText;			// # of characters in the context
	LONG				m_cRefs;			// reference count
	};

#endif /* _DBGCXT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\compcol.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Component Collection

File: Compcol.h

Owner: DmitryR

This is the Component Collection header file.

Component collection replaces:  (used in:)
COleVar, COleVarList            (HitObj, Session, Application)
CObjectCover                    (HitObj, Server, Session)
VariantLink HasTable            (Session, Application)
===================================================================*/

#ifndef COMPCOL_H
#define COMPCOL_H

/*===================================================================
  Special OLE stuff
===================================================================*/

#include "gip.h"

/*===================================================================
  Misc declarations
===================================================================*/

#include "hashing.h"
#include "idhash.h"
#include "dbllink.h"
#include "util.h"
#include "viperint.h"
#include "memcls.h"

// Forward declarations
class CHitObj;
class CAppln;
class CSession;
class CScriptingContext;

// Component Types
#define CompType    DWORD
#define ctUnknown   0x00000000  // (Used as UnInitialized state)
#define ctTagged    0x00000001  // Created by <OBJECT ...> tag
#define ctProperty  0x00000002  // Created with Session("xxx") =
#define ctUnnamed   0x00000004  // Created with Server.CreateObject()

// Scope levels 
#define CompScope   DWORD
#define csUnknown   0x00000000
#define csAppln     0x00000001
#define csSession   0x00000002
#define csPage      0x00000004

// COM threading models
#define CompModel   DWORD
#define cmUnknown   0x00000000
#define cmSingle    0x00000001
#define cmApartment 0x00000002
#define cmFree      0x00000004
#define cmBoth      0x00000008

/*===================================================================
  Utility Functions Prototypes
===================================================================*/

HRESULT CompModelFromCLSID
    (
    const CLSID &ClsId, 
    CompModel *pcmModel = NULL, 
    BOOL *pfInProc = NULL
    );

BOOL FIsIntrinsic(IDispatch *pdisp);

inline BOOL FIsIntrinsic(VARIANT *pVar)
    {
    if (V_VT(pVar) != VT_DISPATCH)
        return FALSE;
    return FIsIntrinsic(V_DISPATCH(pVar));
    }

/*===================================================================
  OnPageInfo struct used to cache ids of OnStartPage()/OnEndPage()
===================================================================*/

#define ONPAGEINFO_ONSTARTPAGE      0
#define ONPAGEINFO_ONENDPAGE        1
#define ONPAGE_METHODS_MAX          ONPAGEINFO_ONENDPAGE+1

struct COnPageInfo
    {
    DISPID m_rgDispIds[ONPAGE_METHODS_MAX];

    BOOL FHasAnyMethod() const;
    };

inline BOOL COnPageInfo::FHasAnyMethod() const
    {
#if (ONPAGE_METHODS_MAX == 2)
    // fast implementation for the real case
    return
        (
        m_rgDispIds[0] != DISPID_UNKNOWN ||
        m_rgDispIds[1] != DISPID_UNKNOWN
        );
#else
    for (int i = 0; i < ONPAGE_METHODS_MAX; i++)
        {
        if (m_rgDispIds[i] != DISPID_UNKNOWN)
            return TRUE;
        }
    return FALSE;
#endif
    }

/*===================================================================
  Component object stores information about a single object
  Each component object belongs to a component collection
  Component objects are linked into a list, also
  tagged objects are hashed by name, and
  properties are hashed by name, and
  all instantiated objects are hashed by IUnknown*
===================================================================*/
class CComponentObject : public CLinkElem
    {

friend class CComponentCollection;
friend class CPageComponentManager;
friend class CComponentIterator;

private:
    // properties
	CompScope   m_csScope : 4;	// Scope
    CompType    m_ctType  : 4;  // Component Object Type
	CompModel	m_cmModel : 4;  // Threading behavior (from Registry)

	DWORD       m_fAgile : 1;   // Agile?

	// flag to indicate if OnPageInfo was queried
	DWORD       m_fOnPageInfoCached : 1;
	// flag: on-start-page done, waiting to do on-end-page
	DWORD       m_fOnPageStarted : 1;

	// flag to avoid multiple unsuccessful attempts to instantiate
	DWORD       m_fFailedToInstantiate : 1;
	// flag to mark instantiated (or tried to inst.) tagged objects
	DWORD       m_fInstantiatedTagged : 1;

	// flag to mark the object in pointer cache
	DWORD       m_fInPtrCache : 1;

    // variant filled with value?
	DWORD       m_fVariant : 1;

    // name was allocated (longer than the default buffer)?
	DWORD       m_fNameAllocated : 1;

	// pointers to object and type info
	IDispatch   *m_pDisp;		// Dispatch interface pointer
	IUnknown    *m_pUnknown;	// IUnknown interface pointer

    union
    {
	CLSID		m_ClsId;	// Class id (for tagged and unnamed)
	VARIANT     m_Variant;  // Variant (for properties)
    };
    
	// For objects that use OLE cookie API
	DWORD       m_dwGIPCookie;

	// cached OnPageInfo
	COnPageInfo m_OnPageInfo;

	// pointer to connect objects into link list
	CComponentObject *m_pCompNext;  // Next object in the link list.
    CComponentObject *m_pCompPrev;  // Prev object in the link list.

    // buffer for names that fit in (36 bytes = 17 unicode chars + '\0')
	BYTE        m_rgbNameBuffer[36];

private:
    // constructor is private! (not for outside use)
    CComponentObject
        (
        CompScope csScope, 
        CompType  ctType,
        CompModel cmModel
        );
    ~CComponentObject();

    // Initializes CLinkElem portion
    HRESULT Init(LPWSTR pwszName, DWORD cbName);

    // Releases all interface pointers (used by clear)
    HRESULT ReleaseAll();

    // Clears out data (releases all) leaving link alone
    HRESULT Clear();
    
    // Create instance if not there already
	HRESULT Instantiate(CHitObj *pHitObj);
	HRESULT TryInstantiate(CHitObj *pHitObj);
	
    // Set value from variant
    HRESULT SetPropertyValue(VARIANT *);

    // Convert Object to be GIP cookie
    HRESULT ConvertToGIPCookie();
    
    // Get and cache the ids for OnStart methods
    HRESULT GetOnPageInfo();

public:
    // functions to get the COM object (internally resolve cookies)
    HRESULT GetAddRefdIDispatch(IDispatch **ppdisp);
    HRESULT GetAddRefdIUnknown(IUnknown **ppunk);
    HRESULT GetVariant(VARIANT *pVar);  // not for GIP cookies

    // Check if the unnamed page level object object 
    // can be removed without waiting till the end of request
    inline BOOL FEarlyReleaseAllowed() const;
    
    // public inlines to access the object's properties
    // these are the only methods available from outside
    inline LPWSTR GetName();
    
    inline CompScope GetScope() const;
    inline CompType  GetType()  const;
    inline CompModel GetModel() const;
    inline BOOL      FAgile()   const;

    // Retrieve the cached ids
    inline const COnPageInfo *GetCachedOnPageInfo() const;

public:
#ifdef DBG
	void AssertValid() const;
#else
	void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline LPWSTR CComponentObject::GetName()
    {
    return (LPWSTR)m_pKey; 
    }

inline CompScope CComponentObject::GetScope() const
    {
    return m_csScope;
    }
    
inline CompType CComponentObject::GetType() const
    {
    return m_ctType; 
    }

inline CompType CComponentObject::GetModel() const
    {
    return m_cmModel; 
    }

inline BOOL CComponentObject::FAgile() const
    {
    return m_fAgile;
    }

inline const COnPageInfo *CComponentObject::GetCachedOnPageInfo() const
    {
    return m_fOnPageInfoCached ? &m_OnPageInfo : NULL;
    }

inline BOOL CComponentObject::FEarlyReleaseAllowed() const
    {
    return (!m_fOnPageStarted   &&  // no need to do on-end-page
            !m_fInPtrCache      &&  // no need to search by pointer
            m_csScope == csPage &&  // page scoped
            m_ctType == ctUnnamed); // created with Server.CreateObject()
    }

/*===================================================================
  Component collection is a manager of various types of component
  objects:
    1) Tagged objects (<OBJECT...>) (instantiated or not)
    2) Session("xxx") and Application("xxx") properties
    3) Unnamed objects (Server.CreateObject())
  It hashes added objects as needed (some by name, IUnkn *, etc.)

  The idea is to isolate the above issues from outside as much
  as possible.

  Component collections exist under session, application, hitobj
===================================================================*/
class CComponentCollection
    {
    
friend class CPageComponentManager;
friend class CComponentIterator;
friend class CVariantsIterator;

private:
    CompScope m_csScope : 4;          // scope (page, session, appln)
    DWORD     m_fUseTaggedArray : 1;  // remember tagged objects array?
    DWORD     m_fUsePropArray   : 1;  // remember properties array?
    DWORD     m_fHasComProperties : 1; // any property VARIANTs that could be objects
    
    // hash table (by name) of tagged objects
    CHashTableStr m_htTaggedObjects;     
    
    // hash table (by name) of properties (4)
    CHashTableStr m_htProperties;
    
    // hash table (by IUnknown *) of all instances
    CIdHashTable m_htidIUnknownPtrs;

    // Pointer to the component objects link list
	CComponentObject *m_pCompFirst;  // First object in link list.

	// Array of pointers to static objects to speed lookup by index
	CPtrArray m_rgpvTaggedObjects;

	// Array of pointers to properties to speed lookup by index
	CPtrArray m_rgpvProperties;

    // Various object counts in the collection
    USHORT m_cAllTagged;         // all tagged objects
    USHORT m_cInstTagged;        // instanciated tagged objects
    USHORT m_cProperties;        // all properties
    USHORT m_cUnnamed;           // number of unnamed objects
    
    // Add/remove object to the component objects link list
    HRESULT AddComponentToList(CComponentObject *pObj);
    HRESULT RemoveComponentFromList(CComponentObject *pObj);
    
    // Add named object to the proper hash table by name
    HRESULT AddComponentToNameHash
        (
        CComponentObject *pObj, 
        LPWSTR pwszName,
        DWORD  cbName
        );
    
    // Add named object to the IUnkown * hash table
    HRESULT AddComponentToPtrHash(CComponentObject *pObj);

    // Find by name (for tagged)
    HRESULT FindComponentObjectByName
        (
        LPWSTR pwszName,
        DWORD  cbName,
        CComponentObject **ppObj
        );
        
    // Find by name (for properties)
    HRESULT FindComponentPropertyByName
        (
        LPWSTR pwszName, 
        DWORD  cbName,
        CComponentObject **ppObj
        );

    // Find by IUnknown*
    HRESULT FindComponentByIUnknownPtr
        (
        IUnknown *pUnk,
        CComponentObject **ppObj
        );

    // Fill in the arrays for access by index for the first time
    HRESULT StartUsingTaggedObjectsArray();
    HRESULT StartUsingPropertiesArray();

public:
    // Add various kinds of objects to the collection
    // They are also used by 
    //      CPageComponentManager AddScoped...()
    
    HRESULT AddTagged
        (
        LPWSTR pwszName, 
        const CLSID &clsid, 
        CompModel cmModel
        );
        
    HRESULT AddProperty
        (
        LPWSTR pwszName,
        VARIANT *pVariant,
        CComponentObject **ppObj = NULL
        );

    HRESULT AddUnnamed
        (
        const CLSID &clsid, 
        CompModel cmModel, 
        CComponentObject **ppObj
        );

    HRESULT GetTagged
        (
        LPWSTR pwszName,
        CComponentObject **ppObj
        );

    HRESULT GetProperty
        (
        LPWSTR pwszName,
        CComponentObject **ppObj
        );

    HRESULT GetNameByIndex
        (
        CompType ctType,
        int index,
        LPWSTR *ppwszName
        );

    HRESULT RemoveComponent(CComponentObject *pObj);
    
    HRESULT RemoveProperty(LPWSTR pwszName);
    
    HRESULT RemoveAllProperties();

    CComponentCollection();
    ~CComponentCollection();

    HRESULT Init(CompScope csScope);
    HRESULT UnInit();

    BOOL FHasStateInfo() const;    // TRUE when state-full
    BOOL FHasObjects() const;      // TRUE when contains objects

    DWORD GetPropertyCount() const;
    DWORD GetTaggedObjectCount() const;

public:
#ifdef DBG
	void AssertValid() const;
#else
	void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline BOOL CComponentCollection::FHasStateInfo() const
    {
    return ((m_cAllTagged + m_cProperties + m_cUnnamed) > 0);
    }

inline BOOL CComponentCollection::FHasObjects() const
    {
    return (m_cInstTagged > 0 || m_cUnnamed > 0 ||
            (m_cProperties > 0 && m_fHasComProperties));
    }

inline DWORD CComponentCollection::GetPropertyCount() const
    {
    return m_cProperties;
    }

inline DWORD CComponentCollection::GetTaggedObjectCount() const
    {
    return m_cAllTagged;
    }

inline HRESULT CComponentCollection::AddComponentToList
(
CComponentObject *pObj
)
    {
    pObj->m_pCompNext = m_pCompFirst;
    pObj->m_pCompPrev = NULL;
    if (m_pCompFirst)
        m_pCompFirst->m_pCompPrev = pObj;
    m_pCompFirst = pObj;
    return S_OK;
    }

inline HRESULT CComponentCollection::RemoveComponentFromList
(
CComponentObject *pObj
)
    {
    if (pObj->m_pCompPrev)
        pObj->m_pCompPrev->m_pCompNext = pObj->m_pCompNext;
    if (pObj->m_pCompNext)
        pObj->m_pCompNext->m_pCompPrev = pObj->m_pCompPrev;
    if (m_pCompFirst == pObj)
        m_pCompFirst = pObj->m_pCompNext;
    pObj->m_pCompPrev = pObj->m_pCompNext = NULL;
    return S_OK;
    }

/*===================================================================
  A page object controls calls to OnStartPage(), OnEndPage().
  Page objects are used by CPageComponentManager
  They are hashed using IDispatch * to avoid multiple OnStartPage()
  calls for the same object.
===================================================================*/
class CPageObject
    {

friend class CPageComponentManager;

private:
	IDispatch   *m_pDisp;		       // Dispatch interface pointer
	COnPageInfo  m_OnPageInfo;         // cached OnPageInfo

    DWORD        m_fStartPageCalled : 1;
    DWORD        m_fEndPageCalled : 1;
	
private: // the only access is using CPageComponentManager
    CPageObject();
    ~CPageObject();

    HRESULT	Init(IDispatch *pDisp, const COnPageInfo &OnPageInfo);

    // Invoke OnStartPage or OnEndPage
    HRESULT InvokeMethod
        (
        DWORD iMethod, 
        CScriptingContext *pContext, 
        CHitObj *pHitObj
        );
    HRESULT TryInvokeMethod     // used by InvokeMethod
        (                       // inside TRY CATCH
        DISPID     DispId,
        BOOL       fOnStart, 
        IDispatch *pDispContext,
        CHitObj   *pHitObj
        );

public:
#ifdef DBG
	void AssertValid() const;
#else
	void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };
    
/*===================================================================
  Page component manager provides access to component collections
  for page, session, application level.
  It is associated with a HitObj.

  It also takes care of covering (OnStartPage(), OnEndPage()).
===================================================================*/
class CPageComponentManager
    {
private:
    // hashtable of page objects hashed by IDispatch *
    CIdHashTable m_htidPageObjects;

    // hit object (this page)
    CHitObj *m_pHitObj;

    // hash table iterator callbacks
    static IteratorCallbackCode DeletePageObjectCB(void *pvObj, void *, void *);
    static IteratorCallbackCode OnEndPageObjectCB(void *pvObj, void *pvHitObj, void *pvhr);

private:
    // collections related to page, session and application
    HRESULT GetPageCollection(CComponentCollection **ppCollection);
    HRESULT GetSessionCollection(CComponentCollection **ppCollection);
    HRESULT GetApplnCollection(CComponentCollection **ppCollection);
    
    HRESULT GetCollectionByScope
        (
        CompScope csScope, 
        CComponentCollection **ppCollection
        );

    // find objectc in any of the related collections 
    // (internal private method)
    HRESULT FindScopedComponentByName
        (
        CompScope csScope, 
        LPWSTR pwszName,
        DWORD  cbName,
        BOOL fProperty,
        CComponentObject **ppObj, 
        CComponentCollection **ppCollection = NULL
        );

    static HRESULT __stdcall InstantiateObjectFromMTA
        (
        void *pvObj,
        void *pvHitObj
        );

public:
    CPageComponentManager();
    ~CPageComponentManager();

    HRESULT Init(CHitObj *pHitObj);
    
    // OnStartPage processing for an object that need it
    // (OnEndPage is done for all objects at the end of page)
    HRESULT OnStartPage
        (
        CComponentObject  *pCompObj,
        CScriptingContext *pContext,
        const COnPageInfo *pOnPageInfo,
        BOOL *pfStarted
        );

    // request OnEndPage() for all objects that need it
    // (OnStartPage() is done on demand on per-object basis)
    HRESULT OnEndPageAllObjects();

    // Add various kinds of objects. Objects get added to the
    // right collection depending on scope argument
    
    HRESULT AddScopedTagged
        (
        CompScope csScope, 
        LPWSTR pwszName, 
        const CLSID &clsid,
        CompModel cmModel
        );
        
    HRESULT AddScopedProperty
        (
        CompScope csScope, 
        LPWSTR pwszName, 
        VARIANT *pVariant,
        CComponentObject **ppObj = NULL
        );

    // Server.CreateObject
    HRESULT AddScopedUnnamedInstantiated
        (
        CompScope csScope, 
        const CLSID &clsid, 
        CompModel cmModel,
        COnPageInfo *pOnPageInfo,
        CComponentObject **ppObj
        );

    // Get component object (tagged) by name. 
    // Scope could be csUnknown
    HRESULT GetScopedObjectInstantiated
        (
        CompScope csScope, 
        LPWSTR pwszName, 
        DWORD  cbName,
        CComponentObject **ppObj,
        BOOL *pfNewInstance
        );

    // Get component property by name. Scope could be csUnknown
    HRESULT GetScopedProperty
        (
        CompScope csScope, 
        LPWSTR pwszName, 
        CComponentObject **ppObj
        );

    // Find component by IUnknown * (or IDispatch *).
    HRESULT FindAnyScopeComponentByIUnknown
        (
        IUnknown *pUnk, 
        CComponentObject **ppObj
        );
    HRESULT FindAnyScopeComponentByIDispatch
        (
        IDispatch *pDisp, 
        CComponentObject **ppObj
        );
    // The same - but static - gets context from Viper
    static HRESULT FindComponentWithoutContext
        (
        IDispatch *pDisp, 
        CComponentObject **ppObj
        );

    // Remove component -- the early release logic
    HRESULT RemoveComponent(CComponentObject *pObj);

public:
#ifdef DBG
	void AssertValid() const;
#else
	void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

// Component iterator is used to go through component names
// all the HitObj - reletated object across collections
// Needed for scripting

class CComponentIterator
    {
private:
    CHitObj *m_pHitObj;
    
    DWORD     m_fInited : 1;
    DWORD     m_fFinished : 1;
    
    CompScope m_csLastScope : 4;
    
    CComponentObject *m_pLastObj;

public:    
    CComponentIterator(CHitObj *pHitObj = NULL);
    ~CComponentIterator();

    HRESULT Init(CHitObj *pHitObj);
    LPWSTR  WStrNextComponentName();
    };

 // Variant Iterator is used to go through Property or Tagged object
 // names in a component collection. Needed for scripting

class CVariantsIterator : public IEnumVARIANT
	{
public:
	CVariantsIterator(CAppln *, DWORD);
	CVariantsIterator(CSession *, DWORD);
	~CVariantsIterator();

	HRESULT Init();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG m_cRefs;							// reference count
	CComponentCollection 	*m_pCompColl;	// collection we are iterating over
	DWORD					m_dwIndex;		// current position for iteration
	CAppln					*m_pAppln;		// application (to clone iterator and Lock())
	CSession				*m_pSession;	// session (to clone iterator)
	DWORD					m_ctColType;	// type of collection
	
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

#endif // COMPCOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\dbllink.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash tables with LRU threading 

File: DblLink.cpp

Owner: DGottner

simple, effective linked list manager
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "DblLink.h"
#include "memchk.h"


/*------------------------------------------------------------------
 * C D b l L i n k
 */

/*===================================================================
CDblLink::UnLink

Unlink this element from the list that it currently resides on
===================================================================*/

void CDblLink::UnLink()
	{
	m_pLinkPrev->m_pLinkNext = m_pLinkNext;
	m_pLinkNext->m_pLinkPrev = m_pLinkPrev;

	// Paranoia:
	//       reset the node to empty after the unlink
	//
	m_pLinkPrev = m_pLinkNext = this;
	}



/*===================================================================
CDblLink::AppendTo

Append this link onto a list

Parameters: pListHead - pointer to a the list header (itself
						a CDblLink) to append this item onto.

Condition: the link must be UnLink'ed before this method is called
===================================================================*/

void CDblLink::AppendTo(CDblLink &ListHead)
	{
	UnLink();

	m_pLinkNext = &ListHead;		// remember termination is at list head
	m_pLinkPrev = ListHead.m_pLinkPrev;
	ListHead.m_pLinkPrev->m_pLinkNext = this;
	ListHead.m_pLinkPrev = this;
	}



/*===================================================================
CDblLink::Prepend

Prepend this link onto a list

Parameters: pListHead - pointer to a the list header (itself
						a CDblLink) to prepend this item onto.

Condition: the link must be UnLink'ed before this method is called
===================================================================*/

void CDblLink::PrependTo(CDblLink &ListHead)
	{
	UnLink();

	m_pLinkPrev = &ListHead;
	m_pLinkNext = ListHead.m_pLinkNext;
	ListHead.m_pLinkNext->m_pLinkPrev = this;
	ListHead.m_pLinkNext = this;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\dbllink.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash table for Script Manager

File: DblList.h

Owner: DGottner

extremly simple, yet very flexible, linked list manager
===================================================================*/

#ifndef DBLLINK_H
#define DBLLINK_H

#ifdef LINKTEST
#define _DEBUG
#include <assert.h>
#define Assert assert

#else
#include "debug.h"
#endif


/* C D b l L i n k
 *
 * This structure contains a set of links suitable for a doubly linked list
 * implementation.  Here we actually use it as a circularly linked list -
 * the links are extracted into this file because the list headers are also
 * of this type.
 */

class CDblLink
	{
public:
	CDblLink();
	virtual ~CDblLink();

	// manipulators
	/////
	void UnLink();
	void AppendTo(CDblLink &);
	void PrependTo(CDblLink &);

	// accessors
	/////
	CDblLink *PNext() const;
	CDblLink *PPrev() const;

	// testers
	/////
	bool FIsEmpty() const;
	void AssertValid() const
		{
		#ifdef _DEBUG
			Assert (this == m_pLinkPrev->m_pLinkNext && this == m_pLinkNext->m_pLinkPrev);
		#endif
		}

private:
	CDblLink *m_pLinkNext, *m_pLinkPrev;
	};

inline CDblLink::CDblLink()	 { m_pLinkNext = m_pLinkPrev = this; }
inline CDblLink::~CDblLink() { UnLink(); }

inline bool CDblLink::FIsEmpty() const { return this == m_pLinkNext; }
inline CDblLink *CDblLink::PNext() const { return m_pLinkNext; }
inline CDblLink *CDblLink::PPrev() const { return m_pLinkPrev; }

#endif // DBLLINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\debug.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Debug tools

File: debug.h

This file contains the header info for helping with debugging.
===================================================================*/
#include "dbgutil.h"

#define DEBUG_FCN				0x00000800L   // File Change Notification
#define DEBUG_TEMPLATE          0x00001000L
#define DEBUG_SCRIPT_DEBUGGER   0x00002000L
#define DEBUG_SCRIPT_ENGINE     0x00004000L

#define DEBUG_RESPONSE          0x00010000L
#define DEBUG_REQUEST           0x00020000L
#define DEBUG_SERVER            0x00040000L
#define DEBUG_APPLICATION       0x00080000L

#define DEBUG_SESSION           0x00100000L
#define DEBUG_MTS               0X00200000L
#define DEBUG_THREADGATE        0X00400000L

#undef Assert
#define Assert(exp)  DBG_ASSERT(exp)

#undef FImplies
#define FImplies(f1,f2) (!(f1)||(f2))

void _ASSERT_IMPERSONATING(void);

#define ASSERT_IMPERSONATING() _ASSERT_IMPERSONATING()

#if _IIS_6_0
#define DBGWARN     DBGPRINTF
#define DBGERROR    DBGPRINTF
#define DBGINFO     DBGPRINTF
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\debug.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Debug tools

File: debug.cpp

This file contains the routines for helping with debugging.
===================================================================*/
#include "denpre.h"
#pragma hdrstop


void _ASSERT_IMPERSONATING(void)
	{
	HANDLE _token;
	DWORD _err;																														
	if( OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &_token) ) 
		CloseHandle( _token );												
	else																	
		{																	
		_err = GetLastError();												
		ASSERT( _err != ERROR_NO_TOKEN );									
		}																	
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\denali.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hit Manager

File: Denali.h

Owner: PramodD

This is the Hit (Request) Manager header file.
===================================================================*/
#ifndef DENALI_H
#define DENALI_H

//#define	LOG_FCNOTIFICATIONS	// logs file change notifications to a file

#include "Hitobj.h"
#include "CacheMgr.h"
#include "Request.h"

extern BOOL g_fShutDownInProgress;

inline IsShutDownInProgress() 
    {
    return g_fShutDownInProgress;
    }

// de-comment the following line to build with no perfmon counters
//#define 	PERF_DISABLE

DWORD	HandleHit(CIsapiReqInfo     *pIReq);
//void	InitODBC( void );
//void	UnInitODBC( void );

extern BOOL g_fOOP;

/*  inlines to implement ISA per-thread bracketing in OOP case
*/

inline HRESULT StartISAThreadBracket(CIsapiReqInfo     *pIReq)
    {
    if (g_fOOP && pIReq)
        {
        HRESULT hr = pIReq->ISAThreadNotify(TRUE);
        if (FAILED(hr))
            return hr;
        }
    return S_OK;
    }

inline void EndISAThreadBracket(CIsapiReqInfo     *pIReq)
    {
    if (g_fOOP && pIReq)
        {
        pIReq->ISAThreadNotify(FALSE);
        }
    }

extern HINSTANCE g_hinstDLL;

/*	intrinsic object names (bug 164)
	NOTE to add an intrinsic object to denali, follow these steps:
	1. add both sz and wsz versions of the object name below
	2. add a check for the sz version of the object name in CTemplate::FValidObjectName
*/
#define 	CONCAT(a, b)				a ## b
#define 	WSZ(x)						CONCAT(L, x)

#define 	SZ_OBJ_APPLICATION			"Application"
#define 	SZ_OBJ_REQUEST				"Request"
#define 	SZ_OBJ_RESPONSE				"Response"
#define 	SZ_OBJ_SERVER				"Server"
#define 	SZ_OBJ_CERTIFICATE			"Certificate"
#define 	SZ_OBJ_SESSION				"Session"
#define 	SZ_OBJ_SCRIPTINGNAMESPACE 	"ScriptingNamespace"
#define 	SZ_OBJ_OBJECTCONTEXT		"ObjectContext"
#define     SZ_OBJ_ASPPAGETLB           "ASPPAGETLB"
#define     SZ_OBJ_ASPGLOBALTLB         "ASPGLOBALTLB"

#define 	WSZ_OBJ_APPLICATION			WSZ(SZ_OBJ_APPLICATION)
#define 	WSZ_OBJ_REQUEST				WSZ(SZ_OBJ_REQUEST)
#define 	WSZ_OBJ_RESPONSE			WSZ(SZ_OBJ_RESPONSE)
#define 	WSZ_OBJ_SERVER				WSZ(SZ_OBJ_SERVER)
#define 	WSZ_OBJ_CERTIFICATE			WSZ(SZ_OBJ_CERTIFICATE)
#define 	WSZ_OBJ_SESSION				WSZ(SZ_OBJ_SESSION)
#define 	WSZ_OBJ_SCRIPTINGNAMESPACE 	WSZ(SZ_OBJ_SCRIPTINGNAMESPACE)
#define 	WSZ_OBJ_OBJECTCONTEXT		WSZ(SZ_OBJ_OBJECTCONTEXT)
#define     WSZ_OBJ_ASPPAGETLB          WSZ(SZ_OBJ_ASPPAGETLB)
#define     WSZ_OBJ_ASPGLOBALTLB        WSZ(SZ_OBJ_ASPGLOBALTLB)

#define 	BSTR_OBJ_APPLICATION		g_bstrApplication
#define 	BSTR_OBJ_REQUEST			g_bstrRequest
#define 	BSTR_OBJ_RESPONSE			g_bstrResponse
#define 	BSTR_OBJ_SERVER				g_bstrServer
#define 	BSTR_OBJ_CERTIFICATE		g_bstrCertificate
#define 	BSTR_OBJ_SESSION			g_bstrSession
#define 	BSTR_OBJ_SCRIPTINGNAMESPACE g_bstrScriptingNamespace
#define 	BSTR_OBJ_OBJECTCONTEXT		g_bstrObjectContext

// Cached BSTRs
extern BSTR g_bstrApplication;
extern BSTR g_bstrRequest;
extern BSTR g_bstrResponse;
extern BSTR g_bstrServer;
extern BSTR g_bstrCertificate;
extern BSTR g_bstrSession;
extern BSTR g_bstrScriptingNamespace;
extern BSTR g_bstrObjectContext;

// Session ID Cookie 
// consist of 12 char literal constant and 8 hex process ID
#define     CCH_SESSION_ID_COOKIE           20
#define     CCH_SESSION_ID_COOKIE_PREFIX    12
#define		SZ_SESSION_ID_COOKIE_PREFIX     "ASPSESSIONID"

extern char g_szSessionIDCookieName[];

// CLIENT DEBUG (flag) Cookie
#define		SZ_CLIENT_DEBUG_COOKIE	"ASPCLIENTDEBUG"

// Dll name
#define		ASP_DLL_NAME				"ASP.DLL"

// Max # of bytes we will allocate before we assume an attack by a malicious browser
#define		REQUEST_ALLOC_MAX  (100 * 1024)

#define     SZ_GLOBAL_ASA       _T("GLOBAL.ASA")
#define     CCH_GLOBAL_ASA      10

/*
 * InitializeCriticalSection can throw.  Use this macro instead
 */
#define ErrInitCriticalSection( cs, hr ) \
		do { \
		hr = S_OK; \
		__try \
			{ \
			INITIALIZE_CRITICAL_SECTION(cs); \
			} \
		__except(1) \
			{ \
			hr = E_UNEXPECTED; \
			} \
		} while (0)

#ifdef LOG_FCNOTIFICATIONS
void LfcnCreateLogFile();
void LfcnCopyAdvance(char** ppchDest, const char* sz);
void LfcnAppendLog(const char* sz);
void LfcnLogNotification(char* szFile);
void LfcnLogHandleCreation(int i, char* szApp);
void LfcnUnmapLogFile();
#endif	//LOG_FCNOTIFICATIONS

#endif // DENALI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\denevent.c ===
/* Microsoft Developer Support
   Copyright (c) 1992, 1993 Microsoft Corporation */

/* This is the required stub entry point for the message-table DLL */
#include <windows.h>

BOOL WINAPI DllMain(HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{
  return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\cookies.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request, Response objects

File: cookies.cpp

Owner: DGottner

This file contains the code for the implementation of the 
Request.Cookies and Response.Cookies collections.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "objbase.h"
#include "cookies.h"
#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init



/*------------------------------------------------------------------
 * C C o o k i e S u p p o r t E r r
 */

/*===================================================================
CCookieSupportErr::CCookieSupportErr

constructor
===================================================================*/

CCookieSupportErr::CCookieSupportErr(CCookie *pCookie)
	{
	m_pCookie = pCookie;
	}



/*===================================================================
CCookieSupportErr::QueryInterface
CCookieSupportErr::AddRef
CCookieSupportErr::Release

Delegating IUnknown members for CCookieSupportErr object.
===================================================================*/

STDMETHODIMP CCookieSupportErr::QueryInterface(const IID &idInterface, void **ppvObj)
	{
	return m_pCookie->QueryInterface(idInterface, ppvObj);
	}

STDMETHODIMP_(ULONG) CCookieSupportErr::AddRef()
	{
	return m_pCookie->AddRef();
	}

STDMETHODIMP_(ULONG) CCookieSupportErr::Release()
	{
	return m_pCookie->Release();
	}



/*===================================================================
CCookieSupportErr::InterfaceSupportsErrorInfo

Report back to OA about which interfaces we support that return
error information
===================================================================*/

STDMETHODIMP CCookieSupportErr::InterfaceSupportsErrorInfo(const GUID &idInterface)
	{
	if (idInterface == IID_IDispatch || idInterface == IID_IWriteCookie || idInterface == IID_IReadCookie)
		return S_OK;

	return S_FALSE;
	}



/*------------------------------------------------------------------
 * C W r i t e C o o k i e
 */

/*===================================================================
CWriteCookie::CWriteCookie

constructor
===================================================================*/

CWriteCookie::CWriteCookie(CCookie *pCookie)
	{
	m_pCookie = pCookie;
	CDispatch::Init(IID_IWriteCookie);
	}



/*===================================================================
CWriteCookie::QueryInterface
CWriteCookie::AddRef
CWriteCookie::Release

Delegating IUnknown members for CWriteCookie object.
===================================================================*/

STDMETHODIMP CWriteCookie::QueryInterface(const IID &idInterface, void **ppvObj)
	{
	// Bug 85953 Trap IDispatch before it gets to the core object
	if (idInterface == IID_IUnknown || 
		idInterface == IID_IWriteCookie ||
		idInterface == IID_IDispatch)
		{
		*ppvObj = this;
		static_cast<IUnknown *>(*ppvObj)->AddRef();
		return S_OK;
		}
	else
		return m_pCookie->QueryInterface(idInterface, ppvObj);
	}

STDMETHODIMP_(ULONG) CWriteCookie::AddRef()
	{
	return m_pCookie->AddRef();
	}

STDMETHODIMP_(ULONG) CWriteCookie::Release()
	{
	return m_pCookie->Release();
	}



/*===================================================================
CWriteCookie::put_Item

Set the primary value for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Item(VARIANT varKey, BSTR bstrValue)
	{
	char            *szKey;		// ascii value of the key
    CWCharToMBCS    convValue;
    CWCharToMBCS    convKey;

	// Bug 122589: Don't crash when "bstrValue" is NULL
	if (bstrValue == NULL)
		return E_FAIL;

	// Initialize things
	//
	VARIANT *pvarKey = &varKey;
	HRESULT hrReturn = S_OK;

	// BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
	//          produced by IEnumVariant
	//
	// Use VariantResolveDispatch which will:
	//
	//     *  Copy BYREF variants for us using VariantCopyInd
	//     *  handle E_OUTOFMEMORY for us
	//     *  get the default value from an IDispatch, which seems
	//        like an appropriate conversion.
	//
	VARIANT varKeyCopy;
	VariantInit(&varKeyCopy);
	if (V_VT(pvarKey) != VT_BSTR)
		{
		if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
			goto LExit;

		pvarKey = &varKeyCopy;
		}

	switch (V_VT(pvarKey))
		{
	case VT_BSTR:
		break;

	case VT_ERROR:
		if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
			{
			if (m_pCookie->m_szValue == NULL)	// current value is a dictionary
				{
				CCookiePair *pNukePair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
				while (pNukePair != NULL)
					{
					CCookiePair *pNext = static_cast<CCookiePair *>(pNukePair->m_pNext);
					delete pNukePair;
					pNukePair = pNext;
					}

				m_pCookie->m_mpszValues.ReInit();
				}
			else								// no dictionary value
				if (m_pCookie->m_fDuplicate)
					free(m_pCookie->m_szValue);
            if (FAILED(hrReturn = convValue.Init(bstrValue,m_pCookie->m_lCodePage))) {
                goto LExit;
            }
			m_pCookie->m_szValue = NULL;
			m_pCookie->AddValue(convValue.GetString(), TRUE);
			m_pCookie->m_fDirty = TRUE;
			goto LExit;
			}

		// Other error, FALL THROUGH to wrong type case

	default:
		ExceptionId(IID_IWriteCookie, IDE_COOKIE, IDE_EXPECTING_STR);
		hrReturn = E_FAIL;
		goto LExit;
		}

	// don't allow empty keys in the cookie
	//
    
    if (V_BSTR(pvarKey)) {

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pCookie->m_lCodePage))) {
            goto LExit;
        }
        else {
            szKey = convKey.GetString();
        }
    }
    else {
		szKey = "";
    }

	if (*szKey == '\0')
		{
		ExceptionId(IID_IWriteCookie, IDE_COOKIE, IDE_COOKIE_EMPTY_DICT);
		hrReturn = E_FAIL;
		goto LExit;
		}

	// we're changing a dictionary value, so first trash the primary value
	//
	if (m_pCookie->m_fDuplicate)
		free(m_pCookie->m_szValue);

    if (FAILED(hrReturn = convValue.Init(bstrValue,m_pCookie->m_lCodePage))) {
        goto LExit;
    }

	m_pCookie->m_szValue = NULL;
	m_pCookie->AddKeyAndValue(szKey, convValue.GetString(), TRUE);
	m_pCookie->m_fDirty = TRUE;

LExit:
	VariantClear(&varKeyCopy);
	return hrReturn;
	}



/*===================================================================
CWriteCookie::put_Expires

Set the expires attribute for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Expires(DATE dtExpires)
	{
	if (FAILED(VariantDateToCTime(dtExpires, &m_pCookie->m_tExpires)))
		{
		ExceptionId(IID_IWriteCookie, IDE_COOKIE, IDE_COOKIE_BAD_EXPIRATION);
		return E_FAIL;
		}

	m_pCookie->m_fDirty = TRUE;
	return S_OK;
	}



/*===================================================================
CWriteCookie::put_Domain

Set the domain attribute for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Domain(BSTR bstrDomain)
	{
    CWCharToMBCS    convDomain;
    HRESULT         hr = S_OK;

    if (FAILED(hr = convDomain.Init(bstrDomain,m_pCookie->m_lCodePage)));

    else {
        if (m_pCookie->m_szDomain)
            free(m_pCookie->m_szDomain);
	    m_pCookie->m_szDomain = convDomain.GetString(TRUE);
	    m_pCookie->m_fDirty = TRUE;
    }

	return hr;
	}



/*===================================================================
CWriteCookie::put_Path

Set the path attribute for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Path(BSTR bstrPath) 
{
    HRESULT         hr = S_OK;

    CWCharToMBCS    convPath;

    if (FAILED(hr = convPath.Init(bstrPath,m_pCookie->m_lCodePage)));

    else {
		
        if (m_pCookie->m_szPath)
            free(m_pCookie->m_szPath);
	    m_pCookie->m_szPath = convPath.GetString(TRUE);
        if (m_pCookie->m_szPath == NULL)
            hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
        m_pCookie->m_fDirty = TRUE;

	return hr;
}

/*===================================================================
CWriteCookie::put_Secure

Set the secure attribute for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Secure(VARIANT_BOOL fSecure)
	{
	m_pCookie->m_fSecure = fSecure;
	m_pCookie->m_fDirty = TRUE;

	return S_OK;
	}



/*===================================================================
CWriteCookie::get_HasKeys

Return True if the cookie contains keys, False if it is a simple
value
===================================================================*/

STDMETHODIMP CWriteCookie::get_HasKeys(VARIANT_BOOL *pfHasKeys)
	{
	*pfHasKeys = ( m_pCookie->m_mpszValues.Count() > 0 ? VARIANT_TRUE : VARIANT_FALSE);
	return S_OK;
	}



/*===================================================================
CWriteCookie::get__NewEnum

Return an enumerator object.

ReadCookie and WriteCookie use the same iterator object.
To reduce useless redundancy, deletage to IReadCookie.
The IReadCookie enumerator will likely be used much more
frequently than the IWriteCookie iterator, so we pay the
overhead of delegation in this function.
===================================================================*/

STDMETHODIMP CWriteCookie::get__NewEnum(IUnknown **ppEnumReturn)
	{
	IReadCookie *pReadCookie;
	if (FAILED(QueryInterface(IID_IReadCookie, reinterpret_cast<void **>(&pReadCookie))))
		{
		Assert (FALSE);		// expect success!
		return E_FAIL;
		}

	HRESULT hrNewEnum = pReadCookie->get__NewEnum(ppEnumReturn);

	pReadCookie->Release();
	return hrNewEnum;
	}



/*------------------------------------------------------------------
 * C R e a d C o o k i e
 */

/*===================================================================
CReadCookie::CReadCookie

constructor
===================================================================*/

CReadCookie::CReadCookie(CCookie *pCookie)
	{
	m_pCookie = pCookie;
	CDispatch::Init(IID_IReadCookie);
	}



/*===================================================================
CReadCookie::QueryInterface
CReadCookie::AddRef
CReadCookie::Release

Delegating IUnknown members for CReadCookie object.
===================================================================*/

STDMETHODIMP CReadCookie::QueryInterface(const IID &idInterface, void **ppvObj)
	{
	// Bug 85953 Trap IDispatch before it gets to the core object
	if (idInterface == IID_IUnknown || 
		idInterface == IID_IReadCookie ||
		idInterface == IID_IDispatch)
		{
		*ppvObj = this;
		static_cast<IUnknown *>(*ppvObj)->AddRef();
		return S_OK;
		}
	else
		return m_pCookie->QueryInterface(idInterface, ppvObj);
	}

STDMETHODIMP_(ULONG) CReadCookie::AddRef()
	{
	return m_pCookie->AddRef();
	}

STDMETHODIMP_(ULONG) CReadCookie::Release()
	{
	return m_pCookie->Release();
	}



/*===================================================================
CReadCookie::get_Item

Retrieve a value in the cookie dictionary.
===================================================================*/

STDMETHODIMP CReadCookie::get_Item(VARIANT varKey, VARIANT *pvarReturn)
	{
	char            *szKey;			// ascii version of the key
	CCookiePair     *pPair = NULL;	// name and value of cookie in the dictionary
    CWCharToMBCS    convKey;

    STACK_BUFFER( tempCookie, 128 );

	// Initialize things
	//
	VariantInit(pvarReturn);
	VARIANT *pvarKey = &varKey;
	HRESULT hrReturn = S_OK;

	// BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
	//          produced by IEnumVariant
	//
	// Use VariantResolveDispatch which will:
	//
	//     *  Copy BYREF variants for us using VariantCopyInd
	//     *  handle E_OUTOFMEMORY for us
	//     *  get the default value from an IDispatch, which seems
	//        like an appropriate conversion.
	//
	VARIANT varKeyCopy;
	VariantInit(&varKeyCopy);
	DWORD vt = V_VT(pvarKey);

	if ((V_VT(pvarKey) != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
		{
		if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
			goto LExit;

		pvarKey = &varKeyCopy;
		}
	vt = V_VT(pvarKey);

	switch (vt)
		{
	// Bug 95201 support all numberic sub-types
	case VT_I1:  case VT_I2:               case VT_I8:
	case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
	case VT_R4:  case VT_R8:
		// Coerce all integral types to VT_I4
		if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
			goto LExit;

		// fallthru to VT_I4

	case VT_I4:
	case VT_BSTR:
		break;
	
	case VT_ERROR:
		if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
			{
			V_VT(pvarReturn) = VT_BSTR;
	
			// simple value, URLEncoding NOT a good idea in this case
			if (m_pCookie->m_szValue)
				{
               	BSTR bstrT;
               	if (FAILED(SysAllocStringFromSz(m_pCookie->m_szValue, 0, &bstrT,m_pCookie->m_lCodePage)))
            		{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
					hrReturn = E_FAIL;
					goto LExit;
            		}
		        V_BSTR(pvarReturn) = bstrT;
				}			
			// dictionary value, must URLEncode to prevent '&', '=' from being misinterpreted
			else
				{
				int cbHTTPCookie = m_pCookie->GetHTTPCookieSize();
				if (cbHTTPCookie > REQUEST_ALLOC_MAX)
					{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_STACK_OVERFLOW);
					hrReturn = E_FAIL;
					goto LExit;
					}

                if (tempCookie.Resize(cbHTTPCookie) == FALSE) {
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
                    hrReturn = E_OUTOFMEMORY;
                    goto LExit;
                }
				char *szHTTPCookie = static_cast<char *>(tempCookie.QueryPtr());
				m_pCookie->GetHTTPCookie(szHTTPCookie);
	
               	BSTR bstrT;
               	if (FAILED(SysAllocStringFromSz(szHTTPCookie, 0, &bstrT,m_pCookie->m_lCodePage)))
            		{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
					hrReturn = E_FAIL;
					goto LExit;
            		}
		        V_BSTR(pvarReturn) = bstrT;
				}

			goto LExit;
			}

	default:
		ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_EXPECTING_STR);
		hrReturn = E_FAIL;
		goto LExit;
		}

	if (vt == VT_BSTR)
		{
		// convert the key to ANSI
        if (V_BSTR(pvarKey)) {
            if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pCookie->m_lCodePage))) {
                goto LExit;
            }
            else {
                szKey = convKey.GetString();
            }
        }
        else {
			szKey = "";
        }

		// Look up the key in the Cookie.
		pPair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.FindElem(szKey, strlen(szKey)));
		}
	else 
		{
		// Look up item by index
		int iCount;

		iCount = V_I4(pvarKey);

		if ((iCount < 1) || 
			(m_pCookie->m_mpszValues.Count() == 0) ||
			(iCount > (int) m_pCookie->m_mpszValues.Count() ))
			{
			hrReturn = E_FAIL;
			ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_BAD_ARRAY_INDEX);
			goto LExit;
			}

		pPair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
		while((iCount > 1) && (pPair != NULL)) 
			{
			pPair = static_cast<CCookiePair *>(pPair->m_pNext);
			iCount--;
			}
		}

	if (pPair)
		{
       	BSTR bstrT;
       	if (FAILED(SysAllocStringFromSz(pPair->m_szValue, 0, &bstrT,m_pCookie->m_lCodePage)))
    		{
			ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
			hrReturn = E_FAIL;
			goto LExit;
    		}
		V_VT(pvarReturn) = VT_BSTR;
		V_BSTR(pvarReturn) = bstrT;
		}

LExit:
	VariantClear(&varKeyCopy);
	return hrReturn;
	}



/*===================================================================
CReadCookie::get_HasKeys

Return True if the cookie contains keys, False if it is a simple
value
===================================================================*/

STDMETHODIMP CReadCookie::get_HasKeys(VARIANT_BOOL *pfHasKeys)
	{
	*pfHasKeys = (m_pCookie->m_mpszValues.Count() > 0 ? VARIANT_TRUE : VARIANT_FALSE);
	return S_OK;
	}

/*===================================================================
CReadCookie::get__NewEnum

Return an enumerator object.
===================================================================*/

STDMETHODIMP CReadCookie::get__NewEnum(IUnknown **ppEnumReturn)
	{
	*ppEnumReturn = NULL;

	CCookieIterator *pIterator = new CCookieIterator(m_pCookie);
	if (pIterator == NULL)
		{
		ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
		return E_OUTOFMEMORY;
		}

	*ppEnumReturn = pIterator;
	return S_OK;
	}

/*===================================================================
CReadCookie::get_Count

Parameters:
	pcValues - count is stored in *pcValues.  Set to 0 if this
		cookie is not multi-valued.
===================================================================*/
STDMETHODIMP CReadCookie::get_Count(int *pcValues)
	{
	*pcValues = m_pCookie->m_mpszValues.Count();
	return S_OK;
	}

/*===================================================================
CReadCookie::get_Key

Function called from DispInvoke to get keys from a multi-valued
Cookie collection.

Parameters:
	vKey		VARIANT [in], which parameter to get the key of
	pvarReturn	VARIANT *, [out] value of the requested parameter

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
STDMETHODIMP CReadCookie::get_Key(VARIANT varKey, VARIANT *pvarReturn)
	{
	char            *szKey;			// ascii version of the key
	CCookiePair     *pPair = NULL;	// name and value of cookie in the dictionary
    CWCharToMBCS    convKey;

    STACK_BUFFER( tempCookie, 128);

	// Initialize things
	//
	VariantInit(pvarReturn);
	VARIANT *pvarKey = &varKey;
	HRESULT hrReturn = S_OK;

	// BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
	//          produced by IEnumVariant
	//
	// Use VariantResolveDispatch which will:
	//
	//     *  Copy BYREF variants for us using VariantCopyInd
	//     *  handle E_OUTOFMEMORY for us
	//     *  get the default value from an IDispatch, which seems
	//        like an appropriate conversion.
	//
	VARIANT varKeyCopy;
	VariantInit(&varKeyCopy);
	DWORD vt = V_VT(pvarKey);

	if ((V_VT(pvarKey) != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
		{
		if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
			goto LExit;

		pvarKey = &varKeyCopy;
		}
	vt = V_VT(pvarKey);

	switch (vt)
		{
	// Bug 95201 support all numberic sub-types
	case VT_I1:  case VT_I2:               case VT_I8:
	case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
	case VT_R4:  case VT_R8:
		// Coerce all integral types to VT_I4
		if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
			goto LExit;

		// fallthru to VT_I4

	case VT_I4:
	case VT_BSTR:
		break;
	
	case VT_ERROR:
		if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
			{
			V_VT(pvarReturn) = VT_BSTR;
	
			// simple value, URLEncoding NOT a good idea in this case
			if (m_pCookie->m_szValue)
				{
               	BSTR bstrT;
               	if (FAILED(SysAllocStringFromSz(m_pCookie->m_szValue, 0, &bstrT,m_pCookie->m_lCodePage)))
            		{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
					hrReturn = E_FAIL;
					goto LExit;
            		}
		        V_BSTR(pvarReturn) = bstrT;
				}			
			// dictionary value, must URLEncode to prevent '&', '=' from being misinterpreted
			else
				{
				int cbHTTPCookie = m_pCookie->GetHTTPCookieSize();
				if (cbHTTPCookie > REQUEST_ALLOC_MAX)
					{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_STACK_OVERFLOW);
					hrReturn = E_FAIL;
					goto LExit;
					}

                if (tempCookie.Resize(cbHTTPCookie) == FALSE) {
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
                    hrReturn = E_OUTOFMEMORY;
                    goto LExit;
                }
				char *szHTTPCookie = static_cast<char *>(tempCookie.QueryPtr());
				m_pCookie->GetHTTPCookie(szHTTPCookie);
	
               	BSTR bstrT;
               	if (FAILED(SysAllocStringFromSz(szHTTPCookie, 0, &bstrT, m_pCookie->m_lCodePage)))
            		{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
					hrReturn = E_FAIL;
					goto LExit;
            		}
		        V_BSTR(pvarReturn) = bstrT;
				}

			goto LExit;
			}

	default:
		ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_EXPECTING_STR);
		hrReturn = E_FAIL;
		goto LExit;
		}

	if (vt == VT_BSTR)
		{
		// convert the key to ANSI
        if (V_BSTR(pvarKey)) {
            if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pCookie->m_lCodePage))) {
                goto LExit;
            }
            else {
                szKey = convKey.GetString();
            }
        }
        else {
			szKey = "";
        }

		// Look up the key in the Cookie.
		pPair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.FindElem(szKey, strlen(szKey)));
		}
	else 
		{
		// Look up item by index
		int iCount;
		
		iCount = V_I4(pvarKey);

		if ((iCount < 1) || 
			(m_pCookie->m_mpszValues.Count() == 0) ||
			(iCount > (int) m_pCookie->m_mpszValues.Count() ))
			{
			hrReturn = E_FAIL;
			ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_BAD_ARRAY_INDEX);
			goto LExit;
			}

		pPair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
		while((iCount > 1) && (pPair != NULL)) 
			{
			pPair = static_cast<CCookiePair *>(pPair->m_pNext);
			iCount--;
			}
		}

	if (pPair)
		{
		// Create a BSTR containing the key for this variant
    	BSTR bstrT;
        SysAllocStringFromSz((CHAR *)pPair->m_pKey, 0, &bstrT, m_pCookie->m_lCodePage);
		if (!bstrT)
			return E_OUTOFMEMORY;
		V_VT(pvarReturn) = VT_BSTR;
		V_BSTR(pvarReturn) = bstrT;
    	}

LExit:
	VariantClear(&varKeyCopy);
	return hrReturn;
	}


/*------------------------------------------------------------------
 * C C o o k i e
 */

/*===================================================================
CCookie::CCookie

constructor
===================================================================*/

CCookie::CCookie(CIsapiReqInfo   *pIReq, UINT lCodePage, IUnknown *pUnkOuter, PFNDESTROYED pfnDestroy)
	: m_WriteCookieInterface(this),
	  m_ReadCookieInterface(this),
	  m_CookieSupportErrorInfo(this)
	{
	m_szValue    = NULL;
	m_tExpires  = -1;
	m_szDomain   = NULL;
	m_szPath     = NULL;
	m_fSecure    = FALSE;
	m_fDirty     = FALSE;
	m_fDuplicate = FALSE;
	m_pfnDestroy = pfnDestroy;
	m_pIReq      = pIReq;
    m_lCodePage  = lCodePage;
	m_cRefs      = 1;
	}



/*===================================================================
CCookie::~CCookie

Destructor
===================================================================*/

CCookie::~CCookie()
	{
	CCookiePair *pNukePair = static_cast<CCookiePair *>(m_mpszValues.Head());
	while (pNukePair != NULL)
		{
		CCookiePair *pNext = static_cast<CCookiePair *>(pNukePair->m_pNext);
		delete pNukePair;
		pNukePair = pNext;
		}

	m_mpszValues.UnInit();
	
	if (m_fDuplicate)
		free(m_szValue);
	
	if (m_szDomain) free(m_szDomain);
	if (m_szPath) free(m_szPath);
	}



/*===================================================================
CCookie::Init

initialize the cookie. This initializes the cookie's value hashing
table
===================================================================*/

HRESULT CCookie::Init()
{
    HRESULT     hr = S_OK;
    TCHAR       pathInfo[MAX_PATH];
#if UNICODE
    CWCharToMBCS  convStr;
#endif

    if (FAILED(hr = m_mpszValues.Init(7)));

    // it would be nice if we could use the application path from the metabase,
    // but because of case sensitivity issues, we can't.  The safest bet is
    // to use the request's path info up to the length of the application's
    // pathinfo.

    else if (FAILED(hr=FindApplicationPath(m_pIReq, pathInfo, sizeof(pathInfo))));

#if UNICODE
    else if (FAILED(hr = convStr.Init(m_pIReq->QueryPszPathInfo(), m_lCodePage, _tcslen(pathInfo))));

    else {

        m_szPath = convStr.GetString(TRUE);
    }
#else
    else {
        TCHAR *reqPath = m_pIReq->QueryPszPathInfo();

        if (reqPath == NULL)
        {
            reqPath=pathInfo;
        }

        DWORD cchPathInfo = _tcslen(pathInfo);

        if (cchPathInfo > _tcslen(reqPath))
        {   // unlikely
            cchPathInfo = _tcslen(reqPath);
        }

        if (!(m_szPath = (char *)malloc(cchPathInfo+1))) {
            hr = E_OUTOFMEMORY;
        }
        else {
            memcpy(m_szPath, reqPath, cchPathInfo);
            m_szPath[ cchPathInfo ] = 0;
        }
    }
#endif

    return hr;
}



/*===================================================================
CCookie::QueryInterface
CCookie::AddRef
CCookie::Release

IUnknown members for CCookie object.

Note on CCookie::QueryInterface: The Query for IDispatch is
ambiguous because it can either refer to IReadCookie or
IWriteCookie.  To resolve this, we resolve requests for IDispatch
to IReadCookie.  The rationale for this is that the code in
request.cpp calls QueryInterface for a generic IDispatch pointer
(because the collection is heterogenous)  The Response.Cookies
collection is homogeneous and so only calls QueryInterface for
IWriteCookie.
===================================================================*/

STDMETHODIMP CCookie::QueryInterface(const IID &idInterface, void **ppvObj)
	{
	if (idInterface == IID_IUnknown)
		*ppvObj = this;

	else if (idInterface == IID_IReadCookie || idInterface == IID_IDispatch)
		*ppvObj = &m_ReadCookieInterface;

	else if (idInterface == IID_IWriteCookie)
		*ppvObj = &m_WriteCookieInterface;

	else if (idInterface == IID_ISupportErrorInfo)
		*ppvObj = &m_CookieSupportErrorInfo;

	else
		*ppvObj = NULL;

	if (*ppvObj != NULL)
		{
		static_cast<IUnknown *>(*ppvObj)->AddRef();
		return S_OK;
		}

	return ResultFromScode(E_NOINTERFACE);
	}


STDMETHODIMP_(ULONG) CCookie::AddRef()
	{
	return ++m_cRefs;
	}


STDMETHODIMP_(ULONG) CCookie::Release(void)
	{
	if (--m_cRefs != 0)
		return m_cRefs;

	if (m_pfnDestroy != NULL)
		(*m_pfnDestroy)();

	delete this;
	return 0;
	}



/*===================================================================
CCookie::AddValue

Set the cookie's primary value. One you set the primary value,
you can't reset it.
===================================================================*/

HRESULT CCookie::AddValue(char *szValue, BOOL fDuplicate)
	{
	if (m_szValue != NULL)		// cookie already is marked as single-valued
		return E_FAIL;

	if (m_mpszValues.Count() != 0)	// cookie already has a value
		return E_FAIL;

	if (fDuplicate)
		{
		char *szNew = (char *)malloc(strlen(szValue) + 1);
		if (szNew == NULL)
			return E_OUTOFMEMORY;

		m_szValue = strcpy(szNew, szValue);
		}
	else
		m_szValue = szValue;

	m_fDuplicate = fDuplicate;
	return S_OK;
	}



/*===================================================================
CCookie::AddKeyAndValue

Add a key and value pair to the Cookie's dictionary. It fails
if the cookie has a primary value already set. It will overwrite
the value if the key already exists.
===================================================================*/

HRESULT CCookie::AddKeyAndValue(char *szKey, char *szValue, BOOL fDuplicate)
	{
	if (m_szValue != NULL)
		return E_FAIL;

	delete static_cast<CCookiePair *>(m_mpszValues.DeleteElem(szKey, strlen(szKey)));

	CCookiePair *pCookiePair = new CCookiePair;
	if (pCookiePair == NULL)
		return E_OUTOFMEMORY;

	if (FAILED(pCookiePair->Init(szKey, szValue, fDuplicate)))
		return E_FAIL;

	m_mpszValues.AddElem(pCookiePair);

	return S_OK;
	}




/*===================================================================
CCookie::GetHTTPCookieSize

Return the number of bytes required for the expansion of the HTTP_COOKIE variable
===================================================================*/

size_t CCookie::GetHTTPCookieSize()
	{
	if (m_szValue)
		return URLEncodeLen(m_szValue);

	else
		{
		int cbValue = 1;
		CCookiePair *pPair = static_cast<CCookiePair *>(m_mpszValues.Head());
		while (pPair)
			{
			// Add size of the URL Encoded key, a character for the '=', and a
			// character for the '&' or the NUL terminator.  URLEncodeLen
			// returns the size + 1, so the two calls to URLEncodeLen() add the
			// two characters we need.
			//
			cbValue += URLEncodeLen(reinterpret_cast<char *>(pPair->m_pKey)) + URLEncodeLen(pPair->m_szValue);
			pPair = static_cast<CCookiePair *>(pPair->m_pNext);
			}

		return cbValue;
		}
	}


/*===================================================================
CCookie::GetHTTPCookie

Return the URL Encoded value a single cookie

Parameters:
	szBuffer -  pointer to the destination buffer to store the
				URL encoded value

Returns:
	Returns a pointer to the terminating NUL character.
===================================================================*/

char *CCookie::GetHTTPCookie(char *szBuffer)
	{
	if (m_szValue)
		return URLEncode(szBuffer, m_szValue);

	else
		{
		char *szDest = szBuffer;
		*szDest = '\0';

		CCookiePair *pPair = static_cast<CCookiePair *>(m_mpszValues.Head());
		while (pPair)
			{
			// Write <name>=<value> string
			szDest = URLEncode(szDest, reinterpret_cast<char *>(pPair->m_pKey));
			*szDest++ = '=';
			szDest = URLEncode(szDest, pPair->m_szValue);

			// Advance
			pPair = static_cast<CCookiePair *>(pPair->m_pNext);

			// Append '&' if there's another one following
			if (pPair)
				*szDest++ = '&';
			}

		Assert (*szDest == '\0');	// make sure we are nul-terminated
		return szDest;
		}
	}



/*===================================================================
CCookie::GetCookieHeaderSize

Return the number of bytes required to allocate for the "Set-Cookie" header.

Parameters:
	szName - the name of the cookie (the size of the name is added to the value)

Returns:
	Returns 0 if *this does not contain a cookie value.
===================================================================*/

size_t CCookie::GetCookieHeaderSize(const char *szName)
	{
	int cbCookie = sizeof "Set-Cookie: ";		// initialize and add NUL terminator now

	// Add size of the URL Encoded name, a character for the '=', and the size
	// of the URL Encoded cookie value.  URLEncodeLen, and GetHttpCookieSize
	// compensate for the NUL terminator, so we actually SUBTRACT 1. (-2 for
	// these two function calls, +1 for the '=' sign
	//
	cbCookie += URLEncodeLen(szName) + GetHTTPCookieSize() - 1;
	
	if (m_tExpires != -1)
		cbCookie += (sizeof "; expires=") + DATE_STRING_SIZE - 1;

	// BUG 250 - DBCS External
	// ASP does not URLEncode the domain and path attributes, which was noticed
	// during localizaiton.
	//
	// NOTE: URLEncodeLen and sizeof both add a space for the nul terminator,
	//       so we subtract 2 to compensate.
	//
	if (m_szDomain)
		cbCookie += (sizeof "; domain=") + DBCSEncodeLen(m_szDomain) - 2;

	cbCookie += (sizeof "; path=") + DBCSEncodeLen(m_szPath) - 2;

	if (m_fSecure)
		cbCookie += (sizeof "; secure") - 1;
	
	return cbCookie;
	}



/*===================================================================
CCookie::GetCookieHeader

Construct the appropriate "Set-Cookie" header for a cookie.

Parameters:
	szName - the name of the cookie (the size of the name is added to the value)

Returns:
	Returns 0 if *this does not contain a cookie value.
===================================================================*/

char *CCookie::GetCookieHeader(const char *szName, char *szBuffer)
{
	// write out the cookie name and value
	//
	char *szDest = strcpyExA(szBuffer, "Set-Cookie: ");
	szDest = URLEncode(szDest, szName);
	szDest = strcpyExA(szDest, "=");
	szDest = GetHTTPCookie(szDest);
	
	if (m_tExpires != -1) {
		char szExpires[DATE_STRING_SIZE];
		CTimeToStringGMT(&m_tExpires, szExpires, TRUE);

		szDest = strcpyExA(szDest, "; expires=");
		szDest = strcpyExA(szDest, szExpires);
    }

	if (m_szDomain) {
		szDest = strcpyExA(szDest, "; domain=");
		szDest = DBCSEncode(szDest, m_szDomain);
    }

	szDest = strcpyExA(szDest, "; path=");
	szDest = DBCSEncode(szDest, m_szPath);

	if (m_fSecure)
		szDest = strcpyExA(szDest, "; secure");

	return szDest;
	}



/*------------------------------------------------------------------
 * C C o o k i e P a i r
 */

/*===================================================================
CCookiePair::CCookiePair

constructor
===================================================================*/

CCookiePair::CCookiePair()
	{
	m_fDuplicate = FALSE;
	m_szValue = NULL;
	}



/*===================================================================
CCookiePair::Init

Initialize the cookie pair with a key and a value.  Optionally,
it will copy the strings as well.
===================================================================*/

HRESULT CCookiePair::Init(const char *szKey, const char *szValue, BOOL fDuplicate)
	{
	m_fDuplicate = fDuplicate;
	if (fDuplicate)
		{
		char *szNewKey = (char *)malloc(strlen(szKey) + 1);
		if (szNewKey == NULL)
			return E_OUTOFMEMORY;
		
		char *szNewValue = (char *)malloc(strlen(szValue) + 1);
		if (szNewValue == NULL)
			{
			free(szNewKey);
			return E_OUTOFMEMORY;
			}
		
		if (FAILED(CLinkElem::Init(strcpy(szNewKey, szKey), strlen(szKey))))
			{
			free(szNewKey);
			free(szNewValue);
			return E_FAIL;
			}
	
		m_szValue = strcpy(szNewValue, szValue);
		}
	else
		{
		if (FAILED(CLinkElem::Init(const_cast<char *>(szKey), strlen(szKey))))
			return E_FAIL;
	
		m_szValue = const_cast<char *>(szValue);
		}
	
	return S_OK;
	}



/*===================================================================
CCookiePair::~CCookiePair

destructor
===================================================================*/

CCookiePair::~CCookiePair()
	{
	if (m_fDuplicate)
		{
		if (m_pKey) free(m_pKey);
		if (m_szValue) free(m_szValue);
		}
	}



/*------------------------------------------------------------------
 * C C o o k i e I t e r a t o r
 */

/*===================================================================
CCookieIterator::CCookieIterator

Constructor
===================================================================*/

CCookieIterator::CCookieIterator(CCookie *pCookie)
	{
	m_pCookie	= pCookie;
	m_pCurrent  = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
	m_cRefs		= 1;

	m_pCookie->AddRef();
	}



/*===================================================================
CCookieIterator::CCookieIterator

Destructor
===================================================================*/

CCookieIterator::~CCookieIterator()
	{
	m_pCookie->Release();
	}



/*===================================================================
CCookieIterator::QueryInterface
CCookieIterator::AddRef
CCookieIterator::Release

IUnknown members for CServVarsIterator object.
===================================================================*/

STDMETHODIMP CCookieIterator::QueryInterface(REFIID iid, void **ppvObj)
	{
	if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
		{
		AddRef();
		*ppvObj = this;
		return S_OK;
		}

	*ppvObj = NULL;
	return E_NOINTERFACE;
	}


STDMETHODIMP_(ULONG) CCookieIterator::AddRef()
	{
	return ++m_cRefs;
	}


STDMETHODIMP_(ULONG) CCookieIterator::Release()
	{
	if (--m_cRefs > 0)
		return m_cRefs;

	delete this;
	return 0;
	}



/*===================================================================
CCookieIterator::Clone

Clone this iterator (standard method)
===================================================================*/

STDMETHODIMP CCookieIterator::Clone(IEnumVARIANT **ppEnumReturn)
	{
	CCookieIterator *pNewIterator = new CCookieIterator(m_pCookie);
	if (pNewIterator == NULL)
		return E_OUTOFMEMORY;

	// new iterator should point to same location as this.
	pNewIterator->m_pCurrent = m_pCurrent;

	*ppEnumReturn = pNewIterator;
	return S_OK;
	}



/*===================================================================
CCookieIterator::Next

Get next value (standard method)

To rehash standard OLE semantics:

	We get the next "cElements" from the collection and store them
	in "rgVariant" which holds at least "cElements" items.  On
	return "*pcElementsFetched" contains the actual number of elements
	stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
	otherwise.
===================================================================*/

STDMETHODIMP CCookieIterator::Next(unsigned long cElementsRequested, VARIANT *rgVariant, unsigned long *pcElementsFetched)
	{
	// give a valid pointer value to 'pcElementsFetched'
	//
	unsigned long cElementsFetched;
	if (pcElementsFetched == NULL)
		pcElementsFetched = &cElementsFetched;

	// Loop through the collection until either we reach the end or
	// cElements becomes zero
	//
	unsigned long cElements = cElementsRequested;
	*pcElementsFetched = 0;

	while (cElements > 0 && m_pCurrent != NULL)
		{
       	BSTR bstrT;
       	if (FAILED(SysAllocStringFromSz(reinterpret_cast<char *>(m_pCurrent->m_pKey), 0, &bstrT, m_pCookie->m_lCodePage)))
			return E_OUTOFMEMORY;
		V_VT(rgVariant) = VT_BSTR;
        V_BSTR(rgVariant) = bstrT;

		++rgVariant;
		--cElements;
		++*pcElementsFetched;
		m_pCurrent = static_cast<CCookiePair *>(m_pCurrent->m_pNext);
		}

	// initialize the remaining variants
	//
	while (cElements-- > 0)
		VariantInit(rgVariant++);

	return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
	}



/*===================================================================
CCookieIterator::Skip

Skip items (standard method)

To rehash standard OLE semantics:

	We skip over the next "cElements" from the collection.
	Returns S_FALSE if less than "cElements" were skipped, S_OK
	otherwise.
===================================================================*/

STDMETHODIMP CCookieIterator::Skip(unsigned long cElements)
	{
	/* Loop through the collection until either we reach the end or
	 * cElements becomes zero
	 */
	while (cElements > 0 && m_pCurrent != NULL)
		{
		--cElements;
		m_pCurrent = static_cast<CCookiePair *>(m_pCurrent->m_pNext);
		}

	return (cElements == 0)? S_OK : S_FALSE;
	}



/*===================================================================
CCookieIterator::Reset

Reset the iterator (standard method)
===================================================================*/

STDMETHODIMP CCookieIterator::Reset()
	{
	m_pCurrent = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\dbgcxt.cpp ===
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

File:			dbgcxt.cpp
Maintained by:	DGottner
Component:		Implementation of IDebugDocumentContext for CTemplates
==============================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "dbgcxt.h"
#include "perfdata.h"
#include "memchk.h"

// {5FA45A6C-AB8A-11d0-8EBA-00C04FC34DCC}
const GUID IID_IDenaliTemplateDocumentContext = 
	{ 0x5fa45a6c, 0xab8a, 0x11d0, { 0x8e, 0xba, 0x0, 0xc0, 0x4f, 0xc3, 0x4d, 0xcc } };

// {3AED94BE-ED79-11d0-8F34-00C04FC34DCC}
static const GUID IID_IDenaliIncFileDocumentContext = 
	{ 0x3aed94be, 0xed79, 0x11d0, { 0x8f, 0x34, 0x0, 0xc0, 0x4f, 0xc3, 0x4d, 0xcc } };


/*
 *
 * C T e m p l a t e D o c u m e n t C o n t e x t
 *
 */

/*	============================================================================
	CTemplateDocumentContext::CTemplateDocumentContext
	Constructor
*/
CTemplateDocumentContext::CTemplateDocumentContext
(
CTemplate *pTemplate,
ULONG cchSourceOffset,
ULONG cchText,
IActiveScriptDebug *pDebugScript,
ULONG idEngine,
ULONG cchTargetOffset
)
	{
	Assert (pTemplate != NULL);

	m_pTemplate       = pTemplate;
	m_idEngine        = idEngine;
	m_pDebugScript    = pDebugScript;
	m_cchSourceOffset = cchSourceOffset;
	m_cchTargetOffset = cchTargetOffset;
	m_cchText         = cchText;
	m_cRefs           = 1;

	m_pTemplate->AddRef();

	if (m_pDebugScript)
		{
		m_pDebugScript->AddRef();

		// If they passed in a script, then they must also pass in target offset & engine ID
		Assert (m_idEngine != -1);
		Assert (m_cchTargetOffset != -1);
		}
	}

/*	============================================================================
	CTemplateDocumentContext::~CTemplateDocumentContext
	Destructor
*/
CTemplateDocumentContext::~CTemplateDocumentContext
(
)
	{
	m_pTemplate->Release();

	if (m_pDebugScript)
		m_pDebugScript->Release();
	}

/*	============================================================================
	CTemplateDocumentContext::QueryInterface

	NOTE: QueryInterface here is also used by CTemplate to determine if an
		  arbitrary document context is ours.
*/
HRESULT CTemplateDocumentContext::QueryInterface
(
const GUID &	guid,
void **			ppvObj
)
	{
	if (guid == IID_IUnknown ||
		guid == IID_IDebugDocumentContext ||
		guid == IID_IDenaliTemplateDocumentContext)
		{
		*ppvObj = this;
		AddRef();
		return S_OK;
		}
	else
		{
		*ppvObj = NULL;
		return E_NOINTERFACE;
		}
	}

/*	============================================================================
	CTemplateDocumentContext::AddRef
	CTemplateDocumentContext::Release

	NOTE: Don't know if these need to be protected with Interlocked(In|De)crement.
*/
ULONG CTemplateDocumentContext::AddRef()
	{
	InterlockedIncrement(&m_cRefs);
	return m_cRefs;
	}

ULONG CTemplateDocumentContext::Release()
	{
	if (InterlockedDecrement(&m_cRefs) == 0)
		{
		delete this;
		return 0;
		}

	return m_cRefs;
	}

/*	============================================================================
	CTemplateDocumentContext::GetDocument
	Return the document.
*/
HRESULT CTemplateDocumentContext::GetDocument
(
/* [out] */ IDebugDocument **ppDebugDocument
)
	{
#ifndef PERF_DISABLE
    g_PerfData.Incr_DEBUGDOCREQ();
#endif
	return m_pTemplate->QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDocument));
	}

/*	============================================================================
	CTemplateDocumentContext::EnumCodeContexts
	Convert document offset to script offset and enumerate code contexts
*/

HRESULT CTemplateDocumentContext::EnumCodeContexts
(
/* [out] */ IEnumDebugCodeContexts **ppEnumerator
)
	{
	if (! m_pTemplate->FIsValid())
		return E_FAIL;

	if (m_pDebugScript == NULL)
		{
		// Convert offset
		m_pTemplate->GetTargetOffset(m_pTemplate->GetSourceFileName(), m_cchSourceOffset, &m_idEngine, &m_cchTargetOffset);

		// See if the script ran and template is holding onto it
		CActiveScriptEngine *pScriptEngine = m_pTemplate->GetActiveScript(m_idEngine);
		if (pScriptEngine)
			{
			if (FAILED(pScriptEngine->GetActiveScript()->QueryInterface(IID_IActiveScriptDebug, reinterpret_cast<void **>(&m_pDebugScript))))
				{
				pScriptEngine->Release();
				return E_FAIL;
				}

			pScriptEngine->IsBeingDebugged();
			pScriptEngine->Release();
			}

		// Script may be still running ("stop" statement case)
		if (m_pDebugScript == NULL)
			m_pDebugScript = g_ScriptManager.GetDebugScript(m_pTemplate, m_idEngine);

		// This is probably a bug...
		if (m_pDebugScript == NULL)		// don't have a running script to match this
			return E_FAIL;

		// No need for AddRef(); m_pDebugScript called funtions that AddRef'ed
		}

	return m_pDebugScript->EnumCodeContextsOfPosition(
												m_idEngine, 
												m_cchTargetOffset,
												m_cchText,
												ppEnumerator);
	}

/*
 *
 * C I n c F i l e E n u m C o d e C o n t e x t s
 *
 *
 * For an include file, the corresponding code contexts are the union
 * of all appropriate code contexts in all template objects that are using
 * the include file.  This special enumerator implements the union.
 */
class CIncFileEnumCodeContexts : public IEnumDebugCodeContexts
	{
private:
	CIncFileDocumentContext *	m_pContext;				// context we are providing enumeration for
	IEnumDebugCodeContexts *	m_pEnumCodeContexts;	// Current code context enumerator
	LONG						m_cRefs;				// reference count
	int							m_iTemplate;			// index of current template

	IEnumDebugCodeContexts *GetEnumerator(int *piTemplate);	// Get enumerator for a template

public:
	CIncFileEnumCodeContexts(CIncFileDocumentContext *pIncFileDocumentContext);
	~CIncFileEnumCodeContexts();

	// IUnknown methods

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(const GUID &guid, void **ppvObj);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

	// IEnumDebugCodeContexts methods

	virtual HRESULT STDMETHODCALLTYPE Next(ULONG celt, IDebugCodeContext **pscc, ULONG *pceltFetched);
	virtual HRESULT STDMETHODCALLTYPE Skip(ULONG celt);
	virtual HRESULT STDMETHODCALLTYPE Reset(void);
	virtual HRESULT STDMETHODCALLTYPE Clone(IEnumDebugCodeContexts **ppescc);
	};
        
/*	============================================================================
	CIncFileEnumCodeContexts::CIncFileEnumCodeContexts
	Constructor
*/
CIncFileEnumCodeContexts::CIncFileEnumCodeContexts
(
CIncFileDocumentContext *pDocumentContext
)
	{
	m_pContext = pDocumentContext;
	m_pContext->AddRef();
	m_cRefs = 1;
	Reset();
	}

/*	============================================================================
	CIncFileEnumCodeContexts::~CIncFileEnumCodeContexts
	Destructor
*/
CIncFileEnumCodeContexts::~CIncFileEnumCodeContexts()
	{
	m_pContext->Release();
	if (m_pEnumCodeContexts)
		m_pEnumCodeContexts->Release();
	}

/*	============================================================================
	CIncFileEnumCodeContexts::GetEnumerator
	Get a code context enumerator for the current script engine

	Side Effects:
		piTemplate is incremented to point to the next available template
		(piTemplate is really an "iteration cookie" -- don't think of it as an index)
*/
IEnumDebugCodeContexts *CIncFileEnumCodeContexts::GetEnumerator
(
int *piTemplate
)
	{
	// Get a template from the array - may need to retry if template contains compiler errors
	CTemplate *pTemplate;
	do
		{
		// GetTemplate returns NULL when array index is out of range (which is when iteration is exhaused)
		pTemplate = m_pContext->m_pIncFile->GetTemplate((*piTemplate)++);
		if (pTemplate == NULL)
			return NULL;
		}  
	while (! pTemplate->FIsValid());

	// If we got this far, we got one of the users of this include file.  Convert the offset
	ULONG idEngine, cchTargetOffset;
	pTemplate->GetTargetOffset(m_pContext->m_pIncFile->GetIncFileName(), m_pContext->m_cchSourceOffset, &idEngine, &cchTargetOffset);

	// Now we have the engine ID, see if template is holding onto corresponding engine
	IActiveScriptDebug *pDebugScriptEngine = NULL;
	CActiveScriptEngine *pScriptEngine = pTemplate->GetActiveScript(idEngine);
	if (pScriptEngine)
		{
		if (FAILED(pScriptEngine->GetActiveScript()->QueryInterface(IID_IActiveScriptDebug, reinterpret_cast<void **>(&pDebugScriptEngine))))
			{
			pScriptEngine->Release();
			return NULL;
			}

		pScriptEngine->IsBeingDebugged();
		pScriptEngine->Release();
		}

	// If we could not get the engine that way, the script is likely still in the running state
	if (pDebugScriptEngine == NULL)
		pDebugScriptEngine = g_ScriptManager.GetDebugScript(pTemplate, idEngine);

	// This is probably a bug...
	if (pDebugScriptEngine == NULL)		// don't have a running script to match this
		return NULL;

	IEnumDebugCodeContexts *pEnumerator;
	HRESULT hrGotEnum = pDebugScriptEngine->EnumCodeContextsOfPosition(
																idEngine, 
																cchTargetOffset,
																m_pContext->m_cchText,
																&pEnumerator);


	pDebugScriptEngine->Release();
	return SUCCEEDED(hrGotEnum)? pEnumerator : NULL;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::QueryInterface
*/
HRESULT CIncFileEnumCodeContexts::QueryInterface
(
const GUID &	guid,
void **			ppvObj
)
	{
	if (guid == IID_IUnknown || guid == IID_IEnumDebugCodeContexts)
		{
		*ppvObj = this;
		AddRef();
		return S_OK;
		}
	else
		{
		*ppvObj = NULL;
		return E_NOINTERFACE;
		}
	}

/*	============================================================================
	CIncFileEnumCodeContexts::AddRef
	CIncFileEnumCodeContexts::Release

	NOTE: Don't know if these need to be protected with Interlocked(In|De)crement.
*/
ULONG CIncFileEnumCodeContexts::AddRef()
	{
	InterlockedIncrement(&m_cRefs);
	return m_cRefs;
	}

ULONG CIncFileEnumCodeContexts::Release()
	{
	if (InterlockedDecrement(&m_cRefs) == 0)
		{
		delete this;
		return 0;
		}

	return m_cRefs;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::Clone

	Clone this iterator (standard method)
*/
HRESULT CIncFileEnumCodeContexts::Clone
(
IEnumDebugCodeContexts **ppEnumClone
)
	{
	CIncFileEnumCodeContexts *pClone = new CIncFileEnumCodeContexts(m_pContext);
	if (pClone == NULL)
		return E_OUTOFMEMORY;

	// new iterator should point to same location as this.
	pClone->m_iTemplate = m_iTemplate;
	pClone->m_pEnumCodeContexts = m_pEnumCodeContexts;
	if (m_pEnumCodeContexts)
		m_pEnumCodeContexts->AddRef();

	*ppEnumClone = pClone;
	return S_OK;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::Next

	Get next value (standard method)

	To rehash standard OLE semantics:

		We get the next "cElements" from the collection and store them
		in "rgVariant" which holds at least "cElements" items.  On
		return "*pcElementsFetched" contains the actual number of elements
		stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
		otherwise.
*/
HRESULT CIncFileEnumCodeContexts::Next
(
unsigned long cElementsRequested,
IDebugCodeContext **ppCodeContexts,
unsigned long *pcElementsFetched
)
	{
	// give a valid pointer value to 'pcElementsFetched'
	//
	unsigned long cLocalElementsFetched;
	if (pcElementsFetched == NULL)
		pcElementsFetched = &cLocalElementsFetched;

	// Initialize things
	//
	unsigned long cElements = cElementsRequested;
	*pcElementsFetched = 0;

	// Loop over all templates until we fill the ppCodeContext array or we've exhausted the collection
	//   (when m_pEnumCodeContexts is NULL that means we are done)
	//
	while (cElements > 0 && m_pEnumCodeContexts)
		{
		// Fetch as many contexts as we can from the current iterator
		unsigned long cElementsFetched;
		HRESULT hrEnum = m_pEnumCodeContexts->Next(cElements, ppCodeContexts, &cElementsFetched);
		if (FAILED(hrEnum))
			return hrEnum;

		// If iterator did not fill entire array, advance to next one
		if (cElementsFetched < cElements)
			{
			// Advance - first release the current iterator
			m_pEnumCodeContexts->Release();
			m_pEnumCodeContexts = GetEnumerator(&m_iTemplate);
			}

		*pcElementsFetched += cElementsFetched;
        ppCodeContexts += cElementsFetched;
		cElements -= cElementsFetched;
		}

	// initialize the remaining structures
	while (cElements-- > 0)
		*ppCodeContexts++ = NULL;

	return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::Skip

	Skip items (standard method)

	To rehash standard OLE semantics:

		We skip over the next "cElements" from the collection.
		Returns S_FALSE if less than "cElements" were skipped, S_OK
		otherwise.
*/
HRESULT CIncFileEnumCodeContexts::Skip(unsigned long cElements)
	{
	/* Loop through the collection until either we reach the end or
	 * cElements becomes zero.  Since the iteration logic is
	 * so complex, we do not repeat it here.
	 */
	HRESULT hrElementFetched = S_OK;
	while (cElements > 0 && hrElementFetched == S_OK)
		{
		IDebugCodeContext *pCodeContext;
		hrElementFetched = Next(1, &pCodeContext, NULL);
		pCodeContext->Release();
		--cElements;
		}

	return (cElements == 0)? S_OK : S_FALSE;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::Reset

	Reset the iterator (standard method)
*/
HRESULT CIncFileEnumCodeContexts::Reset()
	{
	m_iTemplate = 0;
	m_pEnumCodeContexts = GetEnumerator(&m_iTemplate);
	return S_OK;
	}

/*
 *
 * C I n c F i l e D o c u m e n t C o n t e x t
 *
 */

/*	============================================================================
	CIncFileDocumentContext::CIncFileDocumentContext
	Constructor
*/
CIncFileDocumentContext::CIncFileDocumentContext
(
CIncFile *pIncFile,
ULONG cchSourceOffset,
ULONG cchText
)
	{
	Assert (pIncFile != NULL);

	m_pIncFile        = pIncFile;
	m_cchSourceOffset = cchSourceOffset;
	m_cchText         = cchText;
	m_cRefs           = 1;

	m_pIncFile->AddRef();
	}

/*	============================================================================
	CIncFileDocumentContext::~CIncFileDocumentContext
	Destructor
*/
CIncFileDocumentContext::~CIncFileDocumentContext
(
)
	{
	m_pIncFile->Release();
	}

/*	============================================================================
	CIncFileDocumentContext::QueryInterface

	NOTE: QueryInterface here is also used by CIncFile to determine if an
		  arbitrary document context is ours.
*/
HRESULT CIncFileDocumentContext::QueryInterface
(
const GUID &	guid,
void **			ppvObj
)
	{
	if (guid == IID_IUnknown ||
		guid == IID_IDebugDocumentContext ||
		guid == IID_IDenaliIncFileDocumentContext)
		{
		*ppvObj = this;
		AddRef();
		return S_OK;
		}
	else
		{
		*ppvObj = NULL;
		return E_NOINTERFACE;
		}
	}

/*	============================================================================
	CIncFileDocumentContext::AddRef
	CIncFileDocumentContext::Release

	NOTE: Don't know if these need to be protected with Interlocked(In|De)crement.
*/
ULONG CIncFileDocumentContext::AddRef()
	{
	InterlockedIncrement(&m_cRefs);
	return m_cRefs;
	}

ULONG CIncFileDocumentContext::Release()
	{
	if (InterlockedDecrement(&m_cRefs) == 0)
		{
		delete this;
		return 0;
		}

	return m_cRefs;
	}

/*	============================================================================
	CIncFileDocumentContext::GetDocument
	Return the document.
*/
HRESULT CIncFileDocumentContext::GetDocument
(
/* [out] */ IDebugDocument **ppDebugDocument
)
	{
#ifndef PERF_DISABLE
    g_PerfData.Incr_DEBUGDOCREQ();
#endif
	return m_pIncFile->QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDocument));
	}

/*	============================================================================
	CIncFileDocumentContext::EnumCodeContexts
	Convert document offset to script offset and enumerate code contexts
*/
HRESULT CIncFileDocumentContext::EnumCodeContexts
(
/* [out] */ IEnumDebugCodeContexts **ppEnumerator
)
	{
	if ((*ppEnumerator = new CIncFileEnumCodeContexts(this)) == NULL)
		return E_OUTOFMEMORY;

	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\denguid.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Denali

File: denguid.cpp

Owner: SteveBr

Contains all guid's created by Denali not in the .odl.
===================================================================*/

DEFINE_GUID(IID_IObjectCover,0xD99A6DA2L,0x485C,0x17CF,0x83,0xBE,0x01,0xD0,0xC9,0x0C,0x2B,0xD8);

// {7F50F880-1230-11d0-B394-00A0C90C2048}
// this is a dummy GUID that is used to identify all Denali intrinsics, 
// its primary intent is to prevent a user from assigning an intrinsic
// object into the session/ application object
DEFINE_GUID(IID_IDenaliIntrinsic, 0x7f50f880, 0x1230, 0x11d0, 0xb3, 0x94, 0x0, 0xa0, 0xc9, 0xc, 0x20, 0x48);

// BUG 1423: We want to be able to identify JavaScript objects.
//				We are NOT supposed to know what this guid is.  We MUST not use this GUID
//				for anything besides QI'ing to see if the object is a JavaScript object
// The GUID used to identify the IJScriptDispatch interface
// {A0AAC450-A77B-11CF-91D0-00AA00C14A7C}
#define szIID_IJScriptDispatch "{A0AAC450-A77B-11CF-91D0-00AA00C14A7C}"
DEFINE_GUID(IID_IJScriptDispatch,  0xa0aac450, 0xa77b, 0x11cf, 0x91, 0xd0, 0x0, 0xaa, 0x0, 0xc1, 0x4a, 0x7c);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\dbgprop.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu May 22 14:24:06 1997
 */
/* Compiler settings for dbgprop.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dbgprop_h__
#define __dbgprop_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDebugProperty_FWD_DEFINED__
#define __IDebugProperty_FWD_DEFINED__
typedef interface IDebugProperty IDebugProperty;
#endif 	/* __IDebugProperty_FWD_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo_FWD_DEFINED__
#define __IEnumDebugPropertyInfo_FWD_DEFINED__
typedef interface IEnumDebugPropertyInfo IEnumDebugPropertyInfo;
#endif 	/* __IEnumDebugPropertyInfo_FWD_DEFINED__ */


#ifndef __IDebugExtendedProperty_FWD_DEFINED__
#define __IDebugExtendedProperty_FWD_DEFINED__
typedef interface IDebugExtendedProperty IDebugExtendedProperty;
#endif 	/* __IDebugExtendedProperty_FWD_DEFINED__ */


#ifndef __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__
#define __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__
typedef interface IEnumDebugExtendedPropertyInfo IEnumDebugExtendedPropertyInfo;
#endif 	/* __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__ */


#ifndef __IPerPropertyBrowsing2_FWD_DEFINED__
#define __IPerPropertyBrowsing2_FWD_DEFINED__
typedef interface IPerPropertyBrowsing2 IPerPropertyBrowsing2;
#endif 	/* __IPerPropertyBrowsing2_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_All_FWD_DEFINED__
#define __IDebugPropertyEnumType_All_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_All IDebugPropertyEnumType_All;
#endif 	/* __IDebugPropertyEnumType_All_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Locals_FWD_DEFINED__
#define __IDebugPropertyEnumType_Locals_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Locals IDebugPropertyEnumType_Locals;
#endif 	/* __IDebugPropertyEnumType_Locals_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Arguments_FWD_DEFINED__
#define __IDebugPropertyEnumType_Arguments_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Arguments IDebugPropertyEnumType_Arguments;
#endif 	/* __IDebugPropertyEnumType_Arguments_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__
#define __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_LocalsPlusArgs IDebugPropertyEnumType_LocalsPlusArgs;
#endif 	/* __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Registers_FWD_DEFINED__
#define __IDebugPropertyEnumType_Registers_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Registers IDebugPropertyEnumType_Registers;
#endif 	/* __IDebugPropertyEnumType_Registers_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_dbgprop_0000
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 







typedef /* [public] */ 
enum __MIDL___MIDL_itf_dbgprop_0000_0001
    {	OBJECT_ATTRIB_NO_ATTRIB	= 0,
	OBJECT_ATTRIB_NO_NAME	= 0x1,
	OBJECT_ATTRIB_NO_TYPE	= 0x2,
	OBJECT_ATTRIB_NO_VALUE	= 0x4,
	OBJECT_ATTRIB_VALUE_IS_INVALID	= 0x8,
	OBJECT_ATTRIB_VALUE_IS_OBJECT	= 0x10,
	OBJECT_ATTRIB_VALUE_IS_ENUM	= 0x20,
	OBJECT_ATTRIB_VALUE_IS_CUSTOM	= 0x40,
	OBJECT_ATTRIB_OBJECT_IS_EXPANDABLE	= 0x70,
	OBJECT_ATTRIB_VALUE_HAS_CODE	= 0x80,
	OBJECT_ATTRIB_TYPE_IS_OBJECT	= 0x100,
	OBJECT_ATTRIB_TYPE_HAS_CODE	= 0x200,
	OBJECT_ATTRIB_TYPE_IS_EXPANDABLE	= 0x100,
	OBJECT_ATTRIB_SLOT_IS_CATEGORY	= 0x400,
	OBJECT_ATTRIB_VALUE_READONLY	= 0x800,
	OBJECT_ATTRIB_ACCESS_PUBLIC	= 0x1000,
	OBJECT_ATTRIB_ACCESS_PRIVATE	= 0x2000,
	OBJECT_ATTRIB_ACCESS_PROTECTED	= 0x4000,
	OBJECT_ATTRIB_ACCESS_FINAL	= 0x8000,
	OBJECT_ATTRIB_STORAGE_GLOBAL	= 0x10000,
	OBJECT_ATTRIB_STORAGE_STATIC	= 0x20000,
	OBJECT_ATTRIB_STORAGE_FIELD	= 0x40000,
	OBJECT_ATTRIB_STORAGE_VIRTUAL	= 0x80000,
	OBJECT_ATTRIB_TYPE_IS_CONSTANT	= 0x100000,
	OBJECT_ATTRIB_TYPE_IS_SYNCHRONIZED	= 0x200000,
	OBJECT_ATTRIB_TYPE_IS_VOLATILE	= 0x400000,
	OBJECT_ATTRIB_HAS_EXTENDED_ATTRIBS	= 0x800000,
	OBJECT_ATTRIB_IS_CLASS	= 0x1000000,
	OBJECT_ATTRIB_IS_FUNCTION	= 0x2000000,
	OBJECT_ATTRIB_IS_VARIABLE	= 0x4000000,
	OBJECT_ATTRIB_IS_PROPERTY	= 0x8000000,
	OBJECT_ATTRIB_IS_MACRO	= 0x10000000,
	OBJECT_ATTRIB_IS_TYPE	= 0x20000000,
	OBJECT_ATTRIB_IS_INHERITED	= 0x40000000,
	OBJECT_ATTRIB_IS_INTERFACE	= 0x80000000
    }	OBJECT_ATTRIB_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_dbgprop_0000_0002
    {	PROP_INFO_NAME	= 0x1,
	PROP_INFO_TYPE	= 0x2,
	PROP_INFO_VALUE	= 0x4,
	PROP_INFO_FULLNAME	= 0x20,
	PROP_INFO_ATTRIBUTES	= 0x8,
	PROP_INFO_DEBUGPROP	= 0x10,
	PROP_INFO_AUTOEXPAND	= 0x8000000
    }	PROP_INFO_FLAGS;

#define	PROP_INFO_STANDARD	( PROP_INFO_NAME | PROP_INFO_TYPE | PROP_INFO_VALUE | PROP_INFO_ATTRIBUTES )

#define	PROP_INFO_ALL	( PROP_INFO_NAME | PROP_INFO_TYPE | PROP_INFO_VALUE | PROP_INFO_FULLNAME | PROP_INFO_ATTRIBUTES | PROP_INFO_DEBUGPROP )

typedef struct  tagDebugPropertyInfo
    {
    DWORD m_dwValidFields;
    BSTR m_bstrName;
    BSTR m_bstrType;
    BSTR m_bstrValue;
    BSTR m_bstrFullName;
    DWORD m_dwAttrib;
    IDebugProperty __RPC_FAR *m_pDebugProp;
    }	DebugPropertyInfo;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_dbgprop_0000_0003
    {	EX_PROP_INFO_ID	= 0x100,
	EX_PROP_INFO_NTYPE	= 0x200,
	EX_PROP_INFO_NVALUE	= 0x400,
	EX_PROP_INFO_LOCKBYTES	= 0x800,
	EX_PROP_INFO_DEBUGEXTPROP	= 0x1000
    }	EX_PROP_INFO_FLAGS;

typedef struct  tagExtendedDebugPropertyInfo
    {
    DWORD m_dwValidFields;
    LPOLESTR m_bstrName;
    LPOLESTR m_bstrType;
    LPOLESTR m_bstrValue;
    LPOLESTR m_bstrFullName;
    DWORD m_dwAttrib;
    IDebugProperty __RPC_FAR *m_pDebugProp;
    DWORD m_nDISPID;
    DWORD m_nType;
    VARIANT m_varValue;
    ILockBytes __RPC_FAR *m_plbValue;
    IDebugExtendedProperty __RPC_FAR *m_pDebugExtProp;
    }	ExtendedDebugPropertyInfo;



extern RPC_IF_HANDLE __MIDL_itf_dbgprop_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dbgprop_0000_v0_0_s_ifspec;

#ifndef __IDebugProperty_INTERFACE_DEFINED__
#define __IDebugProperty_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugProperty
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C50-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugProperty : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetPropertyInfo( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtendedInfo( 
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueAsString( 
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMembers( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugProperty __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyInfo )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedInfo )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValueAsString )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMembers )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IDebugProperty __RPC_FAR * This,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);
        
        END_INTERFACE
    } IDebugPropertyVtbl;

    interface IDebugProperty
    {
        CONST_VTBL struct IDebugPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugProperty_GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)	\
    (This)->lpVtbl -> GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)

#define IDebugProperty_GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)	\
    (This)->lpVtbl -> GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)

#define IDebugProperty_SetValueAsString(This,pszValue,nRadix)	\
    (This)->lpVtbl -> SetValueAsString(This,pszValue,nRadix)

#define IDebugProperty_EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)	\
    (This)->lpVtbl -> EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)

#define IDebugProperty_GetParent(This,ppDebugProp)	\
    (This)->lpVtbl -> GetParent(This,ppDebugProp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDebugProperty_RemoteGetPropertyInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);


void __RPC_STUB IDebugProperty_RemoteGetPropertyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_GetExtendedInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ ULONG cInfos,
    /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
    /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);


void __RPC_STUB IDebugProperty_GetExtendedInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_SetValueAsString_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszValue,
    /* [in] */ UINT nRadix);


void __RPC_STUB IDebugProperty_SetValueAsString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_EnumMembers_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [in] */ REFIID refiid,
    /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);


void __RPC_STUB IDebugProperty_EnumMembers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_GetParent_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);


void __RPC_STUB IDebugProperty_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo_INTERFACE_DEFINED__
#define __IEnumDebugPropertyInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumDebugPropertyInfo
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumDebugPropertyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C51-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugPropertyInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
            /* [out] */ ULONG __RPC_FAR *pcEltsfetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugPropertyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
            /* [out] */ ULONG __RPC_FAR *pcEltsfetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumDebugPropertyInfoVtbl;

    interface IEnumDebugPropertyInfo
    {
        CONST_VTBL struct IEnumDebugPropertyInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugPropertyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugPropertyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugPropertyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugPropertyInfo_Next(This,celt,pi,pcEltsfetched)	\
    (This)->lpVtbl -> Next(This,celt,pi,pcEltsfetched)

#define IEnumDebugPropertyInfo_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugPropertyInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugPropertyInfo_Clone(This,ppepi)	\
    (This)->lpVtbl -> Clone(This,ppepi)

#define IEnumDebugPropertyInfo_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_RemoteNext_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);


void __RPC_STUB IEnumDebugPropertyInfo_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Skip_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugPropertyInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Reset_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This);


void __RPC_STUB IEnumDebugPropertyInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Clone_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);


void __RPC_STUB IEnumDebugPropertyInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_GetCount_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumDebugPropertyInfo_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugPropertyInfo_INTERFACE_DEFINED__ */


#ifndef __IDebugExtendedProperty_INTERFACE_DEFINED__
#define __IDebugExtendedProperty_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugExtendedProperty
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugExtendedProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C52-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugExtendedProperty : public IDebugProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtendedPropertyInfo( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumExtendedMembers( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugExtendedPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugExtendedProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugExtendedProperty __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValueAsString )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMembers )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedPropertyInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumExtendedMembers )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi);
        
        END_INTERFACE
    } IDebugExtendedPropertyVtbl;

    interface IDebugExtendedProperty
    {
        CONST_VTBL struct IDebugExtendedPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExtendedProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugExtendedProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugExtendedProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugExtendedProperty_GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)	\
    (This)->lpVtbl -> GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)

#define IDebugExtendedProperty_GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)	\
    (This)->lpVtbl -> GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)

#define IDebugExtendedProperty_SetValueAsString(This,pszValue,nRadix)	\
    (This)->lpVtbl -> SetValueAsString(This,pszValue,nRadix)

#define IDebugExtendedProperty_EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)	\
    (This)->lpVtbl -> EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)

#define IDebugExtendedProperty_GetParent(This,ppDebugProp)	\
    (This)->lpVtbl -> GetParent(This,ppDebugProp)


#define IDebugExtendedProperty_GetExtendedPropertyInfo(This,dwFieldSpec,nRadix,pExtendedPropertyInfo)	\
    (This)->lpVtbl -> GetExtendedPropertyInfo(This,dwFieldSpec,nRadix,pExtendedPropertyInfo)

#define IDebugExtendedProperty_EnumExtendedMembers(This,dwFieldSpec,nRadix,ppeepi)	\
    (This)->lpVtbl -> EnumExtendedMembers(This,dwFieldSpec,nRadix,ppeepi)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugExtendedProperty_GetExtendedPropertyInfo_Proxy( 
    IDebugExtendedProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo);


void __RPC_STUB IDebugExtendedProperty_GetExtendedPropertyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExtendedProperty_EnumExtendedMembers_Proxy( 
    IDebugExtendedProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi);


void __RPC_STUB IDebugExtendedProperty_EnumExtendedMembers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugExtendedProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__
#define __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumDebugExtendedPropertyInfo
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumDebugExtendedPropertyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C53-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugExtendedPropertyInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugExtendedPropertyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumDebugExtendedPropertyInfoVtbl;

    interface IEnumDebugExtendedPropertyInfo
    {
        CONST_VTBL struct IEnumDebugExtendedPropertyInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugExtendedPropertyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugExtendedPropertyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugExtendedPropertyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugExtendedPropertyInfo_Next(This,celt,rgExtendedPropertyInfo,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgExtendedPropertyInfo,pceltFetched)

#define IEnumDebugExtendedPropertyInfo_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugExtendedPropertyInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugExtendedPropertyInfo_Clone(This,pedpe)	\
    (This)->lpVtbl -> Clone(This,pedpe)

#define IEnumDebugExtendedPropertyInfo_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Next_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Skip_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Reset_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Clone_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_GetCount_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__ */


#ifndef __IPerPropertyBrowsing2_INTERFACE_DEFINED__
#define __IPerPropertyBrowsing2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPerPropertyBrowsing2
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IPerPropertyBrowsing2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C54-CB0C-11d0-B5C9-00A0244A0E7A")
    IPerPropertyBrowsing2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDisplayString( 
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pBstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapPropertyToPage( 
            /* [in] */ DISPID dispid,
            /* [out] */ CLSID __RPC_FAR *pClsidPropPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPredefinedStrings( 
            /* [in] */ DISPID dispid,
            /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
            /* [out] */ CADWORD __RPC_FAR *pCaCookies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPredefinedValue( 
            /* [in] */ DISPID dispid,
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerPropertyBrowsing2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPerPropertyBrowsing2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPerPropertyBrowsing2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayString )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pBstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapPropertyToPage )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ CLSID __RPC_FAR *pClsidPropPage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPredefinedStrings )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
            /* [out] */ CADWORD __RPC_FAR *pCaCookies);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPredefinedValue )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IPerPropertyBrowsing2Vtbl;

    interface IPerPropertyBrowsing2
    {
        CONST_VTBL struct IPerPropertyBrowsing2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerPropertyBrowsing2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPerPropertyBrowsing2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPerPropertyBrowsing2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPerPropertyBrowsing2_GetDisplayString(This,dispid,pBstr)	\
    (This)->lpVtbl -> GetDisplayString(This,dispid,pBstr)

#define IPerPropertyBrowsing2_MapPropertyToPage(This,dispid,pClsidPropPage)	\
    (This)->lpVtbl -> MapPropertyToPage(This,dispid,pClsidPropPage)

#define IPerPropertyBrowsing2_GetPredefinedStrings(This,dispid,pCaStrings,pCaCookies)	\
    (This)->lpVtbl -> GetPredefinedStrings(This,dispid,pCaStrings,pCaCookies)

#define IPerPropertyBrowsing2_SetPredefinedValue(This,dispid,dwCookie)	\
    (This)->lpVtbl -> SetPredefinedValue(This,dispid,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_GetDisplayString_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ BSTR __RPC_FAR *pBstr);


void __RPC_STUB IPerPropertyBrowsing2_GetDisplayString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_MapPropertyToPage_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ CLSID __RPC_FAR *pClsidPropPage);


void __RPC_STUB IPerPropertyBrowsing2_MapPropertyToPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_GetPredefinedStrings_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
    /* [out] */ CADWORD __RPC_FAR *pCaCookies);


void __RPC_STUB IPerPropertyBrowsing2_GetPredefinedStrings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_SetPredefinedValue_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IPerPropertyBrowsing2_SetPredefinedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPerPropertyBrowsing2_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_All_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_All_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_All
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_All;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C55-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_All : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_AllVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_All __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_All __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_All __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_All __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_AllVtbl;

    interface IDebugPropertyEnumType_All
    {
        CONST_VTBL struct IDebugPropertyEnumType_AllVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_All_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_All_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_All_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_All_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugPropertyEnumType_All_GetName_Proxy( 
    IDebugPropertyEnumType_All __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *__MIDL_0016);


void __RPC_STUB IDebugPropertyEnumType_All_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugPropertyEnumType_All_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_Locals
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_Locals;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C56-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Locals : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_LocalsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_LocalsVtbl;

    interface IDebugPropertyEnumType_Locals
    {
        CONST_VTBL struct IDebugPropertyEnumType_LocalsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Locals_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Locals_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Locals_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Locals_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_Arguments
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_Arguments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C57-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Arguments : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_ArgumentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_ArgumentsVtbl;

    interface IDebugPropertyEnumType_Arguments
    {
        CONST_VTBL struct IDebugPropertyEnumType_ArgumentsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Arguments_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Arguments_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Arguments_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Arguments_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_LocalsPlusArgs
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_LocalsPlusArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C58-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_LocalsPlusArgs : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_LocalsPlusArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_LocalsPlusArgsVtbl;

    interface IDebugPropertyEnumType_LocalsPlusArgs
    {
        CONST_VTBL struct IDebugPropertyEnumType_LocalsPlusArgsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_LocalsPlusArgs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_LocalsPlusArgs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_LocalsPlusArgs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_LocalsPlusArgs_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_Registers
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_Registers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C59-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Registers : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_RegistersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_RegistersVtbl;

    interface IDebugPropertyEnumType_Registers
    {
        CONST_VTBL struct IDebugPropertyEnumType_RegistersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Registers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Registers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Registers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Registers_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IDebugProperty_GetPropertyInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDebugProperty_GetPropertyInfo_Stub( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Next_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
    /* [out] */ ULONG __RPC_FAR *pcEltsfetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Next_Stub( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\denpre.cpp ===
#include "denpre.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\connpt.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: IConnectionPoint implementation

File: ConnPt.h

Owner: DGottner

This file contains our implementation of IConnectionPoint
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "ConnPt.h"
#include "memchk.h"


/*------------------------------------------------------------------
 * C C o n n e c t i o n P o i n t
 */

/*===================================================================
CConnectionPoint::CConnectionPoint
CConnectionPoint::~CConnectionPoint

Parameters (Constructor):
	pUnkObj			pointer to the object we're in.
	pUnkOuter		LPUNKNOWN to which we delegate.

NOTE: Code assumes connection point is contained DIRECTLY in the
      container (and thus, does not AddRef 'm_pContainer'
      If not the case, we may be in trouble.
===================================================================*/

CConnectionPoint::CConnectionPoint(IUnknown *pUnkContainer, const GUID &uidEvent)
	{
	m_pUnkContainer = pUnkContainer;
	m_uidEvent = uidEvent;
	m_dwCookieNext = 0xA5B;		// Looks like "ASP"!

	Assert (m_pUnkContainer != NULL);
	}

CConnectionPoint::~CConnectionPoint()
	{
	while (! m_listSinks.FIsEmpty())
		delete m_listSinks.PNext();
	}



/*===================================================================
CConnectionPoint::GetConnectionInterface

Returns the interface of the event source
===================================================================*/

HRESULT
CConnectionPoint::GetConnectionInterface(GUID *puidReturn)
	{
	*puidReturn = m_uidEvent;
	return S_OK;
	}



/*===================================================================
CConnectionPoint::GetConnectionPointContainer

Returns the interface of the event source
===================================================================*/

HRESULT
CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppContainer)
	{
	return m_pUnkContainer->QueryInterface(IID_IConnectionPointContainer, reinterpret_cast<void **>(ppContainer));
	}



/*===================================================================
CConnectionPoint::Advise

Purpose:
 Provides this connection point with a notification sink to
 call whenever the appropriate outgoing function/event occurs.

Parameters:
 pUnkSink        IUnknown to the sink to notify.  The connection
                 point must QueryInterface on this pointer to obtain
                 the proper interface to call.  The connection
                 point must also insure that any pointer held has
                 a reference count (QueryInterface will do it).
 pdwCookie       DWORD * in which to store the connection key for
                 later calls to Unadvise.
===================================================================*/

HRESULT
CConnectionPoint::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
	{
	// Make sure they store the correct interface pointer!
	// NOTE: Storing into the list will AddRef, to we need to Release the
	//       QueryInterface pointer right away.
	//
	void *pvT;
	if (FAILED(pUnkSink->QueryInterface(m_uidEvent, &pvT)))
		return CONNECT_E_CANNOTCONNECT;
	pUnkSink->Release();

	CSinkElem *pSinkElem = new CSinkElem(*pdwCookie = m_dwCookieNext++, pUnkSink);
	if (pSinkElem == NULL)
		return E_OUTOFMEMORY;

	pSinkElem->AppendTo(m_listSinks);
	return S_OK;
	}



/*===================================================================
CConnectionPoint::Unadvise

Purpose:
 Terminates the connection to the notification sink identified
 with dwCookie (that was returned from Advise).  The connection
 point has to Release any held pointers for that sink.

Parameters:
 dwCookie        DWORD connection key from Advise.
===================================================================*/

HRESULT
CConnectionPoint::Unadvise(DWORD dwCookie)
	{
	// Search for the cookie
	for (CSinkElem *pSinkElem = static_cast<CSinkElem *>(m_listSinks.PNext());
		 pSinkElem != &m_listSinks;
		 pSinkElem = static_cast<CSinkElem *>(pSinkElem->PNext()))
		{
		if (dwCookie == pSinkElem->m_dwCookie)
			{
			delete pSinkElem;
			return S_OK;
			}
		}

	return CONNECT_E_NOCONNECTION;
	}



/*===================================================================
CConnectionPoint::EnumConnections

Purpose:
 Creates and returns an enumerator object with the
 IEnumConnections interface that will enumerate the IUnknown
 pointers of each connected sink.

Parameters:
 ppEnum          Output enumerator object
===================================================================*/

HRESULT
CConnectionPoint::EnumConnections(IEnumConnections **ppEnum)
	{
	if ((*ppEnum = new CEnumConnections(this)) == NULL)
		return E_OUTOFMEMORY;

	return S_OK;
	}


/*------------------------------------------------------------------
 * C E n u m C o n n e c t i o n s
 */

/*===================================================================
CEnumConnections::CEnumConnections
CEnumConnections::~CEnumConnections

Parameters (Constructor):
	pCP				pointer to object we're in.
===================================================================*/

CEnumConnections::CEnumConnections(CConnectionPoint *pCP)
	{
	Assert (pCP != NULL);

	m_cRefs = 1;
	m_pCP   = pCP;

	m_pCP->AddRef();
	Reset();
	}

CEnumConnections::~CEnumConnections()
	{
	m_pCP->Release();
	}



/*===================================================================
CEnumConnections::QueryInterface
CEnumConnections::AddRef
CEnumConnections::Release

IUnknown members for CEnumConnections object.
===================================================================*/

HRESULT CEnumConnections::QueryInterface(const GUID &iid, void **ppvObj)
	{
	if (iid == IID_IUnknown || iid == IID_IEnumConnections)
		{
		AddRef();
		*ppvObj = this;
		return S_OK;
		}

	*ppvObj = NULL;
	return E_NOINTERFACE;
	}

ULONG CEnumConnections::AddRef()
	{
	return ++m_cRefs;
	}

ULONG CEnumConnections::Release()
	{
	if (--m_cRefs > 0)
		return m_cRefs;

	delete this;
	return 0;
	}



/*===================================================================
CEnumConnections::Clone

Clone this iterator (standard method)
===================================================================*/

HRESULT CEnumConnections::Clone(IEnumConnections **ppEnumReturn)
	{
	CEnumConnections *pNewIterator = new CEnumConnections(m_pCP);
	if (pNewIterator == NULL)
		return E_OUTOFMEMORY;

	// new iterator should point to same location as this.
	pNewIterator->m_pElemCurr = m_pElemCurr;

	*ppEnumReturn = pNewIterator;
	return S_OK;
	}



/*===================================================================
CEnumConnections::Next

Get next value (standard method)

To rehash standard OLE semantics:

	We get the next "cElements" from the collection and store them
	in "rgVariant" which holds at least "cElements" items.  On
	return "*pcElementsFetched" contains the actual number of elements
	stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
	otherwise.
===================================================================*/

HRESULT CEnumConnections::Next(unsigned long cElementsRequested, CONNECTDATA *rgConnectData, unsigned long *pcElementsFetched)
	{
	// give a valid pointer value to 'pcElementsFetched'
	//
	unsigned long cElementsFetched;
	if (pcElementsFetched == NULL)
		pcElementsFetched = &cElementsFetched;

	// Loop through the collection until either we reach the end or
	// cElements becomes zero
	//
	unsigned long cElements = cElementsRequested;
	*pcElementsFetched = 0;

	while (cElements > 0 && m_pElemCurr != &m_pCP->m_listSinks)
		{
		rgConnectData->dwCookie = static_cast<CConnectionPoint::CSinkElem *>(m_pElemCurr)->m_dwCookie;
		rgConnectData->pUnk = static_cast<CConnectionPoint::CSinkElem *>(m_pElemCurr)->m_pUnkObj;
		rgConnectData->pUnk->AddRef();

		++rgConnectData;
		--cElements;
		++*pcElementsFetched;
		m_pElemCurr = m_pElemCurr->PNext();
		}

	// initialize the remaining structures
	//
	while (cElements-- > 0)
		(rgConnectData++)->pUnk = NULL;

	return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
	}



/*===================================================================
CEnumConnections::Skip

Skip items (standard method)

To rehash standard OLE semantics:

	We skip over the next "cElements" from the collection.
	Returns S_FALSE if less than "cElements" were skipped, S_OK
	otherwise.
===================================================================*/

HRESULT CEnumConnections::Skip(unsigned long cElements)
	{
	/* Loop through the collection until either we reach the end or
	 * cElements becomes zero
	 */
	while (cElements > 0 && m_pElemCurr != &m_pCP->m_listSinks)
		{
		m_pElemCurr = m_pElemCurr->PNext();
		--cElements;
		}

	return (cElements == 0)? S_OK : S_FALSE;
	}



/*===================================================================
CEnumConnections::Reset

Reset the iterator (standard method)
===================================================================*/

HRESULT CEnumConnections::Reset()
	{
	m_pElemCurr = m_pCP->m_listSinks.PNext();        
	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\denver.h ===
#include <winver.h>
#include "ntverp.h"

/*------------------------------------------------------------------------------*/
/* the following section defines values used in the version			*/
/* data structure for all files, and which do not change.			*/
/*------------------------------------------------------------------------------*/
#ifndef VER_FILETYPE
#define VER_FILETYPE                VFT_DLL
#endif

#ifndef DLL_VER
#define VER_FILEDESCRIPTION_STR     "Active Server Pages"
#define VER_INTERNALNAME_STR        "asp.dll"
#define VER_ORIGINALFILENAME_STR    "asp.dll"

#endif //DLL_VER

#include "iisver.h"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\debugger.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: misc

File: debugger.h

Owner: DGottner, DmitryR

This file contains debugger useful utility prototypes.
===================================================================*/

#ifndef _DEBUGGER_H
#define _DEBUGGER_H

#include "activdbg.h"
#include "dbgcxt.h"		// Convienence for users of debugger.h

/*
 * Globals that we advertise
 */

class CViperActivity;

extern IProcessDebugManager *g_pPDM;
extern IDebugApplication *g_pDebugApp;
extern IDebugApplicationNode *g_pDebugAppRoot;
extern CViperActivity *g_pDebugActivity;
extern DWORD g_dwDebugThreadId;

/*
 * Initialize/Uninitialize debugging
 */

extern HRESULT InitDebuggingAndCreateActivity(CIsapiReqInfo *pIReq);
extern HRESULT UnInitDebugging();


/*
 * Get the application node for the virtual server
 */

extern HRESULT GetServerDebugRoot(CIsapiReqInfo *pIReq, IDebugApplicationNode **ppDebugRoot);


/*
 * Query debugging client
 */
BOOL FCaesars();		// TRUE if default JIT debugger is Script Debugger


/*
 * Debugger (or Debugger UI) invocation from a correct thread
 */

#define DEBUGGER_UI_BRING_DOCUMENT_TO_TOP       0x00000001
#define DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP    0x00000002
#define DEBUGGER_EVENT_ON_PAGEBEGIN             0x00000010
#define DEBUGGER_EVENT_ON_PAGEEND               0x00000020
#define DEBUGGER_EVENT_ON_REFRESH_BREAKPOINT	0x00000040
#define DEBUGGER_ON_REMOVE_CHILD                0x00000100
#define DEBUGGER_ON_DESTROY                     0x00000200
#define DEBUGGER_UNUSED_RECORD                  0x80000000  // can reclaim argument space

HRESULT InvokeDebuggerWithThreadSwitch(IDebugApplication *pDebugAppln, DWORD iMethod, void *Arg = NULL);


/*
 * Create/Destroy entire document trees (debugger)
 */

HRESULT CreateDocumentTree(wchar_t *szDocPath, IDebugApplicationNode *pDocParent, IDebugApplicationNode **ppDocRoot, IDebugApplicationNode **ppDocLeaf, wchar_t **pwszLeaf);
void DestroyDocumentTree(IDebugApplicationNode *pDocRoot);


/*===================================================================
  C  F i l e  N o d e

These are used to provide directory nodes in debugger
Used by application mgr & by CreateDocumentTree
===================================================================*/

extern const GUID IID_IFileNode;
struct IFileNode : IDebugDocumentProvider
	{
	//
	// This private interface provides two functions:
	//
	//  * An extra method to retrieve/set the count of documents in
	//    a directory (used to know when we can detach a folder from
	//    the UI
	//
	//  * A way of verifying that an IDebugDocumentProvider is a CFileNode
	//

	STDMETHOD_(DWORD, IncrementDocumentCount)() = 0;
	STDMETHOD_(DWORD, DecrementDocumentCount)() = 0;
	};


class CFileNode : public IFileNode
	{
private:
	DWORD	m_cRefs;			// Reference Count
	DWORD	m_cDocuments;		// # of CTemplates in the directory (and recursively in subdirectories)
	wchar_t *m_wszName;

public:
	CFileNode();
	~CFileNode();
	HRESULT Init(wchar_t *wszName);

	// IUnknown methods
	STDMETHOD(QueryInterface)(const GUID &, void **);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDebugDocumentProvider methods
	STDMETHOD(GetDocument)(/* [out] */ IDebugDocument **ppDebugDoc);

	// IDebugDocumentInfo (also IDebugDocumentProvider) methods
	STDMETHOD(GetName)(
		/* [in] */ DOCUMENTNAMETYPE dnt,
		/* [out] */ BSTR *pbstrName);

	STDMETHOD(GetDocumentClassId)(/* [out] */ CLSID *)
		{
		return E_NOTIMPL;
		}

	STDMETHOD_(DWORD, IncrementDocumentCount)()
		{
		return ++m_cDocuments;
		}

	STDMETHOD_(DWORD, DecrementDocumentCount)()
		{
		return --m_cDocuments;
		}
	};

#endif // _DEBUGGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\denali.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996-1999 Microsoft Corporation. All Rights Reserved.

Component: Main

File: denali.cpp

Owner: AndyMorr

This file contains the  I S A P I   C A L L B A C K   A P I S
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#undef DEFAULT_TRACE_FLAGS
#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include "gip.h"
#include "mtacb.h"
#include "perfdata.h"
#include "activdbg.h"
#include "dlldatax.h"
#include "debugger.h"
#include "dbgutil.h"
#include "randgen.h"
#include "aspdmon.h"
#include "tlbcache.h"
#include "thrdgate.h"
#include "ie449.h"

#include "memcls.h"
#include "memchk.h"

// Globals

BOOL g_fShutDownInProgress = FALSE;
BOOL g_fInitStarted = FALSE;

char g_szExtensionDesc[] = "Microsoft Active Server Pages 2.0";
GLOB gGlob;
BOOL g_fFirstHit = TRUE;
char g_pszASPModuleName[] = "ASP";

DECLARE_DEBUG_PRINTS_OBJECT();
#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#else
#include <initguid.h>
DEFINE_GUID(IisAspGuid, 
0x784d8902, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif
DECLARE_PLATFORM_TYPE();

// Out of process flag
BOOL g_fOOP = FALSE;

// session id cookie
char g_szSessionIDCookieName[CCH_SESSION_ID_COOKIE+1];

CRITICAL_SECTION    g_csEventlogLock;
CRITICAL_SECTION    g_csFirstHitLock;
HINSTANCE           g_hODBC32Lib;

// Added to support CacheExtensions
HINSTANCE           g_hDenali = (HINSTANCE)0;
HINSTANCE           g_hinstDLL = (HINSTANCE)0;

extern LONG g_nSessionObjectsActive;

// Cached BSTRs
BSTR g_bstrApplication = NULL;
BSTR g_bstrRequest = NULL;
BSTR g_bstrResponse = NULL;
BSTR g_bstrServer = NULL;
BSTR g_bstrCertificate = NULL;
BSTR g_bstrSession = NULL;
BSTR g_bstrScriptingNamespace = NULL;
BSTR g_bstrObjectContext = NULL;


// Forward references
HRESULT GlobInit();
HRESULT GlobUnInit();
HRESULT CacheStdTypeInfos();
HRESULT UnCacheStdTypeInfos();
HRESULT InitCachedBSTRs();
HRESULT UnInitCachedBSTRs();
HRESULT ShutDown();
HRESULT SendHtmlSubstitute(CIsapiReqInfo    *pIReq);

void MakeAspCookieName(char *);
BOOL FirstHitInit(CIsapiReqInfo    *pIReq);


// ATL support
#if _IIS_5_1
CWamModule _Module;
#elif _IIS_6_0
CComModule _Module;
#else
#error "Neither _IIS_6_0 nor _IIS_5_1 is defined"
#endif

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


/*===================================================================
DllMain - Moved from clsfctry.cpp

Main entry point into the DLL.  Called by system on DLL load
and unload.

Returns:
    TRUE on success

Side effects:
    None.
===================================================================*/
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)
    {
/* Obsolete
    // Let the Proxy code get a crack at it
    if (!PrxDllMain(hinstDLL, dwReason, lpvReserved))
        return FALSE;
*/

    switch(dwReason)
        {
    case DLL_PROCESS_ATTACH:
        // hang onto the hinstance so we can use it to get to our string resources
        //
        g_hinstDLL = hinstDLL;

        // Here's an interesting optimization:
        // The following tells the system NOT to call us for Thread attach/detach
        // since we dont handle those calls anyway, this will speed things up a bit.
        // If this turns out to be a problem for some reason (cant imagine why),
        // just remove this again.
        DisableThreadLibraryCalls(hinstDLL);
        break;
            
    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

        }
    return TRUE;
    }

/*===================================================================
DWORD HandleHit

Given the CIsapiReqInfo construct a hit object to be queued
for execution

Parameters:
    pIReq  - CIsapiReqInfo 

Returns:
    HSE_STATUS_PENDING if function is successful in queuing request
    HSE_STATUS_ERROR if not successful
===================================================================*/

DWORD HandleHit(CIsapiReqInfo    *pIReq)
    {
    int         errorId   = 0;
    BOOL        fRejected = FALSE;
    BOOL        fCompleted = FALSE;
    HRESULT     hr        = S_OK;
        
    /*
     * We cant read the metabase until we have the WAM_EXEC_INFO, which
     * we dont have at DllInit time.  Therefore, we postpone reading the
     * metabase until now, but we do it only on the first hit.
     */
    if (g_fFirstHit)
        {
        EnterCriticalSection(&g_csFirstHitLock);
        
        // If someone initied while we were waiting for the CS,
        // then noop
        if (g_fFirstHit)
            {
            BOOL fT;
                
            fT = FirstHitInit(pIReq);
            Assert(fT);
            
            g_fFirstHit = FALSE;
            }
            
        LeaveCriticalSection(&g_csFirstHitLock);
        }

#ifndef PERF_DISABLE
    if (!g_fPerfInited) // Init PERFMON data on first request
        {
        // FYI: leverage same CS as first hit lock
        EnterCriticalSection(&g_csFirstHitLock);
        
        // If someone initied while we were waiting for the CS,
        // then noop
        if (!g_fPerfInited)
            {
            if (SUCCEEDED(InitPerfDataOnFirstRequest(pIReq)))
                {
                    g_fPerfInited = TRUE;
                }
                else
                {
                    g_fPerfInited = FALSE;
                    // call this again since InitPerfDataOnFirstRequest will uninit
                    // and erase the criticalsection which will then AV when we try to increment counters
                    PreInitPerfData();
                }
            }
        LeaveCriticalSection(&g_csFirstHitLock);
        }
    g_PerfData.Incr_REQTOTAL();
#endif

    if (Glob(fNeedUpdate))
        {
        if (SUCCEEDED(StartISAThreadBracket(pIReq)))
            {
            // Update uses pIReq - need to bracket
            gGlob.Update(pIReq);
            
            EndISAThreadBracket(pIReq);
            }
        }

    if (IsShutDownInProgress())
        hr = E_FAIL;

    // Enforce the limit of concurrent browser requests
    if (SUCCEEDED(hr) && Glob(dwRequestQueueMax) &&
        (*g_PerfData.PDWCounter(ID_REQCURRENT) >= Glob(dwRequestQueueMax)))
        {
        hr = E_FAIL;
        fRejected = TRUE;
        }

    if (SUCCEEDED(hr))
        hr = CHitObj::NewBrowserRequest(pIReq, &fRejected, &fCompleted, &errorId);

    if (SUCCEEDED(hr))
        return fCompleted ? HSE_STATUS_SUCCESS_AND_KEEP_CONN : HSE_STATUS_PENDING;

    if (fRejected)
        {
        if (Glob(fEnableAspHtmlFallBack))
            {
            // Instead of rejecting the request try to find
            // XXX_ASP.HTM file in the same directory and dump its contents
            hr = SendHtmlSubstitute(pIReq);

            if (hr == S_OK)
                return HSE_STATUS_SUCCESS_AND_KEEP_CONN;      // HTML substitute sent
            else if (FAILED(hr))
                return HSE_STATUS_ERROR;        // error sending
            // HTML substitute not found
            }
 
        errorId = IDE_SERVER_TOO_BUSY;
        
#ifndef PERF_DISABLE
        g_PerfData.Incr_REQREJECTED();
#endif
        }

    if (SUCCEEDED(StartISAThreadBracket(pIReq)))
        {
        // Uses pIReq -- need to bracket
        Handle500Error(errorId, pIReq);
        
        EndISAThreadBracket(pIReq);
        }
    
    return HSE_STATUS_ERROR;
    }

/*===================================================================
BOOL DllInit

Initialize Denali if not invoked by RegSvr32.  Only do inits here
that dont require Glob values loaded from the metabase.  For any
inits that require values loaded into Glob from the metabase, use
FirstHitInit.

Returns:
    TRUE on successful initialization
===================================================================*/
BOOL DllInit()
    {
    HRESULT hr;
    const   CHAR  szASPDebugRegLocation[] =
                        "System\\CurrentControlSet\\Services\\W3Svc\\ASP";

#if _IIS_5_1
    InitializeIISRTL();
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- IISRTL\n"));   
#endif
    
#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( g_pszASPModuleName, IisAspGuid);
#else
    CREATE_DEBUG_PRINT_OBJECT( g_pszASPModuleName);
#endif

    if ( !VALID_DEBUG_PRINT_OBJECT()) 
        {
        return ( FALSE);
        }

#ifdef _NO_TRACING_
    LOAD_DEBUG_FLAGS_FROM_REG_STR(szASPDebugRegLocation, (DEBUG_ERROR));
#endif

#ifdef SCRIPT_STATS
    ReadRegistrySettings();
#endif // SCRIPT_STATS

    // Create ASP RefTrace Logs
    IF_DEBUG(TEMPLATE) CTemplate::gm_pTraceLog = CreateRefTraceLog(5000, 0);
    IF_DEBUG(SESSION) CSession::gm_pTraceLog = CreateRefTraceLog(5000, 0);
    IF_DEBUG(APPLICATION) CAppln::gm_pTraceLog = CreateRefTraceLog(5000, 0);
    IF_DEBUG(FCN) CASPDirMonitorEntry::gm_pTraceLog = CreateRefTraceLog(500, 0);
                     CAppln::gm_pTraceLog = CreateRefTraceLog(5000, 0);

    if (FAILED(PreInitPerfData()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- PerfMon Data PreInit\n")); 

    ErrInitCriticalSection( &g_csEventlogLock, hr );
    if (FAILED(hr))
        return FALSE;
        
    ErrInitCriticalSection( &g_csFirstHitLock, hr );
    if (FAILED(hr))
        return FALSE;

#ifdef DENALI_MEMCHK
    if (FAILED(DenaliMemoryInit()))
        return FALSE;
#else
    if (FAILED(AspMemInit()))
        return FALSE;
#endif
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Denali Memory Init\n"));

    g_pDirMonitor = new CDirMonitor;

    if (g_pDirMonitor == NULL) {
        return FALSE;
    }

#if _IIS_5_1
    if (AtqInitialize(0) == FALSE)
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- ATQ Initialized\n"));
#endif

    if (FAILED(GlobInit()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Glob Init\n"));

    if (FAILED(InitMemCls()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Per-Class Cache Init\n")); 

    if (FAILED(InitCachedBSTRs()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Cached BSTRs Init\n"));

    if (FAILED(TxnSupportInit()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Txn Support Init\n"));

    if (FAILED(CacheStdTypeInfos()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Cache Std TypeInfos\n"));

    if (FAILED(g_TypelibCache.Init()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Typelib Cache Init\n"));

    if (FAILED(ErrHandleInit()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Err Handler Init\n"));

    srand( (unsigned int) time(NULL) );
    if (FAILED(g_SessionIdGenerator.Init()))    // seed session id
        return FALSE;
    // Init new Exposed Session Id variable
    if (FAILED(g_ExposedSessionIdGenerator.Init(g_SessionIdGenerator)))    // seed exposed session id
    	return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- SessionID Generator Init\n"));

    MakeAspCookieName(g_szSessionIDCookieName);

    if (FAILED(InitRandGenerator()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- RandGen Init\n"));

    if (FAILED(g_ApplnMgr.Init()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Appln Mgr Init\n"));

    if (FAILED(Init449()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- 449 Mgr Init\n"));

    // Note: Template cache manager is inited in two phases.  Do first here.
    if (FAILED(g_TemplateCache.Init()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Template Cache Init\n"));

    if (FAILED(g_IncFileMap.Init()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Inc File Users Init\n"));

    if (FIsWinNT())  // No Change notification on Windows 95
    {
        if (FAILED(g_FileAppMap.Init()))
            return FALSE;
        DBGPRINTF((DBG_CONTEXT, "ASP Init -- File-Application Map Init\n"));
    }

    if (FAILED(g_ScriptManager.Init()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Script Manager Init\n"));

    if (FAILED(CTemplate::InitClass()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- CTemplate Init Class\n"));

    if (FIsWinNT())  // No GIPs on Win95
        {
        if (FAILED(g_GIPAPI.Init()))
            return FALSE;
        DBGPRINTF((DBG_CONTEXT, "ASP Init -- Global Interface API Init\n"));
        }

    if (FAILED(InitMTACallbacks()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- MTA Callbacks Init\n"));

    if (!RequestSupportInit())
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Request Support Init\n"));

    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Denali DLL Initialized\n"));
    
#ifdef LOG_FCNOTIFICATIONS
    LfcnCreateLogFile();
#endif //LOG_FCNOTIFICATIONS

    return TRUE;
    }

/*===================================================================
BOOL FirstHitInit

Initialize any ASP values that can not be inited at DllInit time.

Returns:
    TRUE on successful initialization
===================================================================*/
BOOL FirstHitInit
(
CIsapiReqInfo    *pIReq
)
    {
    HRESULT hr;

    /*
     * In the out of proc case, being able to call the metabase relies on having
     * told WAM that we are a "smart" client
     */

    if (SUCCEEDED(StartISAThreadBracket(pIReq)))
        {
        // ReadConfigFromMD uses pIReq - need to bracket
        hr = ReadConfigFromMD(pIReq, NULL, TRUE);
        
        // Initialize Debugging
        if (FIsWinNT() && RevertToSelf())  // No Debugging on Win95
            {
            // Don't care whether debugging initializaiton succeeds or not.  The most likely
            // falure is debugger not installed on the machine.
            //
            if (SUCCEEDED(InitDebuggingAndCreateActivity(pIReq))) 
            {
                DBGPRINTF((DBG_CONTEXT, "FirstHitInit: Debugging Initialized\n"));
            }
            else 
            {
                DBGPRINTF((DBG_CONTEXT, "FirstHitInit: Debugger Initialization Failed\n"));
            }

            DBG_REQUIRE( SetThreadToken(NULL, pIReq->QueryImpersonationToken()) );
            }

        EndISAThreadBracket(pIReq);
        }
    else
        {
        hr = E_FAIL;
        }

    if (FAILED(hr))
        goto LExit;
    DBGPRINTF((DBG_CONTEXT, "FirstHitInit: Metadata loaded successfully\n"));

    // Do FirstHitInit for the Template Cache Manager.  Primarily initializes
    // the Persisted Template Cache
    if (FAILED(hr = g_TemplateCache.FirstHitInit()))
        goto LExit;
    DBGPRINTF((DBG_CONTEXT, "FirstHitInit: Template Cache Initialized\n"));

    // Configure MTS
    if (FAILED(hr = ViperConfigure(Glob(dwProcessorThreadMax), Glob(fAllowOutOfProcCmpnts))))
        goto LExit;
    DBGPRINTF((DBG_CONTEXT, "FirstHitInit: MTS configured\n"));

    // Configure Thread Gate
    THREADGATE_CONFIG tgc;
    tgc.fEnabled             = Glob(fThreadGateEnabled);
    tgc.msTimeSlice          = Glob(dwThreadGateTimeSlice);
    tgc.msSleepDelay         = Glob(dwThreadGateSleepDelay);
    tgc.nSleepMax            = Glob(dwThreadGateSleepMax);
    tgc.nLoadLow             = Glob(dwThreadGateLoadLow);
    tgc.nLoadHigh            = Glob(dwThreadGateLoadHigh);
    tgc.nMinProcessorThreads = 1;
    tgc.nMaxProcessorThreads = Glob(dwProcessorThreadMax);
    if (FAILED(hr = InitThreadGate(&tgc)))
        goto LExit;
    DBGPRINTF((DBG_CONTEXT, "Thread Gate Init\n"));

    DBGPRINTF((DBG_CONTEXT, "ASP First Hit Initialization complete\n"));

LExit:
    Assert(SUCCEEDED(hr));
    return SUCCEEDED(hr);
    }

/*===================================================================
void DllUnInit

UnInitialize Denali DLL if not invoked by RegSvr32

Returns:
    NONE

Side effects:
    NONE
===================================================================*/
void DllUnInit( void )
    {
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- %d Apps %d Sessions %d Requests\n",
                g_nApplications, g_nSessions, g_nBrowserRequests));

    g_fShutDownInProgress = TRUE;

    ShutDown();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- ShutDown Processing\n" ));

    UnInitMTACallbacks();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- MTA Callbacks\n" ));

    UnInitRandGenerator();
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- RandGen\n"));

    UnInitThreadGate();
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- Thread Gate\n"));

    UnInit449();
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- 449 Mgr\n"));
    
    g_ApplnMgr.UnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Application Manager\n" ));

    g_ScriptManager.UnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Script Manager\n" ));
    
    g_TemplateCache.UnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Template Cache\n" ));

    g_IncFileMap.UnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- IncFileMap\n" ));

    if (FIsWinNT()) {
        // No change notification on windows 95
        g_FileAppMap.UnInit();
        DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- File-Application Map\n" ));
        
        if (g_pDirMonitor) {
            g_pDirMonitor->Cleanup();
            DBGPRINTF((DBG_CONTEXT,  "ASP UNInit -- Directory Monitor\n" ));
        }
    }

    CTemplate::UnInitClass();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- CTemplate\n" ));

    g_TypelibCache.UnInit();
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- Typelib Cache\n"));

    UnCacheStdTypeInfos();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- TypeInfos\n" ));

    TxnSupportUnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Txn Support\n" ));

    if (FIsWinNT())
        {
        // No GIPs on Win95
        g_GIPAPI.UnInit();
        DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- GIP\n" ));
        }
        
    ErrHandleUnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- ErrHandler\n" ));

    GlobUnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Glob\n" ));

    UnInitCachedBSTRs();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Cached BSTRs\n" ));

    //////////////////////////////////////////////////////////
    // Wait for the actual session objects to be destroyed. 
    // The g_nSessions global tracks the init/uninit of session
    // objects but not the memory itself.  This presents a 
    // problem when something outside of ASP holds a reference
    // to a session object or one of the contained intrinsics.
    // One case of this is the revoking of a git'd transaction
    // object.  Turns out the revoke can happen asynchronously.
    //
    // NOTE!!! - This needs to be done BEFORE uniniting the 
    // mem classes since these objects are in the acache.

    LONG    lastCount = g_nSessionObjectsActive;
    DWORD   loopCount = 50;

    while( (g_nSessionObjectsActive > 0) && (loopCount--) )
    {
        if (lastCount != g_nSessionObjectsActive) {
            lastCount = g_nSessionObjectsActive;
            loopCount = 50;
        }
        Sleep( 100 );
    }

    UnInitMemCls();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Per-Class Cache\n" ));

#if _IIS_5_1
    AtqTerminate();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- ATQ\n" ));
#endif

    // Destroy ASP RefTrace Logs
    IF_DEBUG(TEMPLATE) DestroyRefTraceLog(CTemplate::gm_pTraceLog);
    IF_DEBUG(SESSION) DestroyRefTraceLog(CSession::gm_pTraceLog);
    IF_DEBUG(APPLICATION) DestroyRefTraceLog(CAppln::gm_pTraceLog);
    IF_DEBUG(FCN) DestroyRefTraceLog(CASPDirMonitorEntry::gm_pTraceLog);

    _Module.Term();

    delete g_pDirMonitor;
    g_pDirMonitor = NULL;

    //  UnInitODBC();
    // Note: the memmgr uses perf counters, so must be uninited before the perf counters are uninited
#ifdef DENALI_MEMCHK
    DenaliMemoryUnInit();
#else
    AspMemUnInit();
#endif
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Memory Manager\n" ));

    UnInitPerfData();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Perf Counters\n" ));

#if _IIS_5_1
    TerminateIISRTL();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- IISRTL\n" ));
#endif

    DBGPRINTF((DBG_CONTEXT,  "ASP Uninitialized\n" ));
    
#ifdef LOG_FCNOTIFICATIONS
    LfcnUnmapLogFile();
#endif //LOG_FCNOTIFICATIONS

    // Deleting the following CS's must be last.  Dont put anything after this
    DeleteCriticalSection( &g_csFirstHitLock );
    DeleteCriticalSection( &g_csEventlogLock );

    DELETE_DEBUG_PRINT_OBJECT();
    }

/*===================================================================
GetExtensionVersion

Mandatory server extension call which returns the version number of
the ISAPI spec that we were built with.

Returns:
    TRUE on success

Side effects:
    None.
===================================================================*/
BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO *pextver)
    {
    // This DLL can be inited only once
    if (g_fShutDownInProgress || 
        InterlockedExchange((LPLONG)&g_fInitStarted, TRUE))
        {
        SetLastError(ERROR_BUSY);
        return FALSE;
        }
        
    if (!DllInit())
        {
        SetLastError(ERROR_BUSY);
        return FALSE;
        }

    pextver->dwExtensionVersion =
            MAKELONG(HSE_VERSION_MAJOR, HSE_VERSION_MINOR);
    strcpy(pextver->lpszExtensionDesc, g_szExtensionDesc);
    return TRUE;
    }

/*===================================================================
HttpExtensionProc

Main entry point into the DLL for the (ActiveX) Internet Information Server.

Returns:
    DWord indicating status of request.  
    HSE_STATUS_PENDING for normal return
        (This indicates that we will process the request, but havent yet.)

Side effects:
    None.
===================================================================*/
DWORD WINAPI HttpExtensionProc(EXTENSION_CONTROL_BLOCK *pECB)
    {
#ifdef SCRIPT_STATS
    InterlockedIncrement(&g_cHttpExtensionsExecuting);
#endif // SCRIPT_STATS

    CIsapiReqInfo   *pIReq = new CIsapiReqInfo(pECB);

    if (pIReq == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return HSE_STATUS_ERROR;
    }

    #ifndef PERF_DISABLE
    g_PerfData.Add_REQTOTALBYTEIN
        (
        pIReq->QueryCchQueryString()
#if _IIS_5_1
        + pIReq->QueryCchPathTranslated()
#elif _IIS_6_0
        + strlen( pIReq->ECB()->lpszPathTranslated )
#endif
        + pIReq->QueryCbTotalBytes()
        );
#endif

    DWORD dw = HandleHit(pIReq);

#ifdef SCRIPT_STATS
    InterlockedDecrement(&g_cHttpExtensionsExecuting);
#endif // SCRIPT_STATS

    pIReq->Release();

    return dw;
    }

/*===================================================================
TerminateExtension

IIS is supposed to call this entry point to unload ISAPI DLLs.

Returns:
    NONE

Side effects:
    Uninitializes the Denali ISAPI DLL if asked to.
===================================================================*/
BOOL WINAPI TerminateExtension( DWORD dwFlag )
    {
    if ( dwFlag == HSE_TERM_ADVISORY_UNLOAD )
        return TRUE;

    if ( dwFlag == HSE_TERM_MUST_UNLOAD )
        {
        // If already shutdown don't uninit twice.
        if (g_fShutDownInProgress)
            return TRUE;

        // make sure this is a CoInitialize()'d thread
        HRESULT hr = CoInitialize(NULL);
        
        if (hr == RPC_E_CHANGED_MODE)
            {
            // already coinitialized MUTLITREADED - OK
            DllUnInit();
            }
        else if (SUCCEEDED(hr))
            {
            DllUnInit();
            
            // need to CoUninit() because CoInit() Succeeded
            CoUninitialize();
            }
            
        return TRUE;
        }
        
    return FALSE;
    }

/*===================================================================
HRESULT ShutDown

ASP Processing ShutDown logic. (Moved from ThreadManager::UnInit())

Returns:
    HRESULT - S_OK on success
    
Side effects:
    May be slow. Kills all requests/sessions/applications
===================================================================*/
HRESULT ShutDown()
    {
    long iT;
    const DWORD dwtLongWait  = 1000;  // 1 sec
    const DWORD dwtShortWait = 100;   // 1/10 sec
        
    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: %d apps (%d restarting), %d sessions\n",
                g_nApplications, g_nApplicationsRestarting, g_nSessions ));

    //////////////////////////////////////////////////////////
    // Stop change notification on files in template cache
    
    if (FIsWinNT())
        {
        g_TemplateCache.ShutdownCacheChangeNotification();
        }

    //////////////////////////////////////////////////////////
    // Shut down debugging, which will have the effect of
    // resuming scripts stopped at a breakpoint.
    //
    // (otherwise stopping running scripts will hang later)

    if (g_pPDM)
        {
        g_TemplateCache.RemoveApplicationFromDebuggerUI(NULL);  // remove all document nodes
        UnInitDebugging();                                      // kill PDM
        DBGPRINTF((DBG_CONTEXT,  "ASP Shutdown: PDM Closed\n" ));
        }

    //////////////////////////////////////////////////////////
    // Drain down all pending browser requests 

    if (g_nBrowserRequests > 0)
        {
        // Give them a little time each
        for (iT = 2*g_nBrowserRequests; g_nBrowserRequests > 0 && iT > 0; iT--)
            Sleep(dwtShortWait);

        if (g_nBrowserRequests > 0)
            {
            // Still there - kill scripts and wait again
            g_ScriptManager.EmptyRunningScriptList();
            
            for (iT = 2*g_nBrowserRequests; g_nBrowserRequests > 0 && iT > 0; iT--)
                Sleep(dwtShortWait);
            }
        }

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Requests drained: %d remaining\n",
                g_nBrowserRequests));

    //////////////////////////////////////////////////////////
    // Kill any remaining engines running scripts
    
    g_ScriptManager.EmptyRunningScriptList();

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Scripts killed\n"));
    
    //////////////////////////////////////////////////////////
    // Wait till there are no appications restarting
    
    g_ApplnMgr.Lock();
    while (g_nApplicationsRestarting > 0)
        {
        g_ApplnMgr.UnLock();
        Sleep(dwtShortWait);
        g_ApplnMgr.Lock();
        }
    g_ApplnMgr.UnLock();

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: 0 applications restarting\n"));

    //////////////////////////////////////////////////////////
    // Make this thread's priority higher than that of worker threads
    
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

    //////////////////////////////////////////////////////////
    // For each application queue up all its sessions for deletion
    
    CApplnIterator ApplnIterator;
    ApplnIterator.Start();
    CAppln *pAppln;
    while (pAppln = ApplnIterator.Next())
        {
        // remove link to ATQ scheduler (even if killing of sessions fails)
        pAppln->PSessionMgr()->UnScheduleSessionKiller();
        
        for (iT = pAppln->GetNumSessions(); iT > 0; iT--)
            {
            pAppln->PSessionMgr()->DeleteAllSessions(TRUE);

            if (pAppln->GetNumSessions() == 0) // all gone?
                break;
                
            Sleep(dwtShortWait);
            }
        }
    ApplnIterator.Stop();

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: All sessions queued up for deletion. nSessions=%d\n",
                g_nSessions));

    //////////////////////////////////////////////////////////
    // Wait till all sessions are gone (UnInited)

    while (g_nSessions > 0)
        {
        // Wait for a maximum of 0.1 sec x # of sessions
        for (iT = g_nSessions; g_nSessions > 0 && iT > 0; iT--)
            Sleep(dwtShortWait);

        if (g_nSessions > 0)
            g_ScriptManager.EmptyRunningScriptList();   // Kill runaway Session_OnEnd scripts
        }

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Finished waiting for sessions to go away. nSessions=%d\n",
                g_nSessions));
    
    //////////////////////////////////////////////////////////
    // Queue up all application objects for deletion

    g_ApplnMgr.DeleteAllApplications();
    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: All applications queued up for deletion. nApplications=%d\n",
                g_nApplications));

    //////////////////////////////////////////////////////////
    // Wait till all applications are gone (UnInited)
    
    while (g_nApplications > 0)
        {
        // Wait for a maximum of 1 sec x # of applications
        for (iT = g_nApplications; g_nApplications > 0 && iT > 0; iT--)
            Sleep(dwtLongWait);

        if (g_nApplications > 0)
            g_ScriptManager.EmptyRunningScriptList();   // Kill runaway Applications_OnEnd scripts
        }

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Finished waiting for applications to go away. nApplications=%d\n",
                g_nApplications));
    
    /////////////////////////////////////////////////////////
    // Wait on the CViperAsyncRequest objects. COM holds the 
    // final reference to these so we need to let the activity
    // threads release any outstanding references before we
    // exit.

    while( g_nViperRequests > 0 )
    {
        Sleep( dwtShortWait );
    }


    //////////////////////////////////////////////////////////
    // Free up libraries to force call of DllCanUnloadNow()
    //    Component writers should put cleanup code in the DllCanUnloadNow() entry point.

    CoFreeUnusedLibraries();

    //////////////////////////////////////////////////////////
    // Kill Debug Activity if any

    if (g_pDebugActivity)
        delete g_pDebugActivity;

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Debug Activity destroyed\n"));

    //////////////////////////////////////////////////////////

    return S_OK;
    }

/*===================================================================
HRESULT GlobInit

Get all interesting global values (mostly from registry)

Returns:
    HRESULT - S_OK on success
    
Side effects:
    fills in glob.  May be slow
===================================================================*/
HRESULT GlobInit()
{
    //
    // BUGBUG - This really needs to be provided either through
    // a server support function or via the wamexec
    //
    
    char szModule[MAX_PATH+1];
    if (GetModuleFileNameA(NULL, szModule, MAX_PATH) > 0)
    {
        int cch = strlen(szModule);
        if (cch > 12 && stricmp(szModule+cch-12, "inetinfo.exe") == 0)
        {
            g_fOOP = FALSE;
        }
        else if ( cch > 8 && stricmp( szModule+cch-8, "w3wp.exe" ) == 0 )
        {
            g_fOOP = FALSE;
        }
        else
        {
            g_fOOP = TRUE;
        }
    }
    
    // Init gGlob
    return gGlob.GlobInit();
}

/*===================================================================
GlobUnInit

It is a macro now. see glob.h

Returns:
    HRESULT - S_OK on success
    
Side effects:
    memory freed.
===================================================================*/
HRESULT GlobUnInit()
    {
    return gGlob.GlobUnInit();
    }

/*===================================================================
InitCachedBSTRs

Pre-create frequently used BSTRs
===================================================================*/
HRESULT InitCachedBSTRs()
    {
    g_bstrApplication        = SysAllocString(WSZ_OBJ_APPLICATION);
    g_bstrRequest            = SysAllocString(WSZ_OBJ_REQUEST);
    g_bstrResponse           = SysAllocString(WSZ_OBJ_RESPONSE);
    g_bstrServer             = SysAllocString(WSZ_OBJ_SERVER);
    g_bstrCertificate        = SysAllocString(WSZ_OBJ_CERTIFICATE);
    g_bstrSession            = SysAllocString(WSZ_OBJ_SESSION);
    g_bstrScriptingNamespace = SysAllocString(WSZ_OBJ_SCRIPTINGNAMESPACE);
    g_bstrObjectContext      = SysAllocString(WSZ_OBJ_OBJECTCONTEXT);

    return
        (
        g_bstrApplication &&
        g_bstrRequest &&
        g_bstrResponse &&
        g_bstrServer &&
        g_bstrCertificate && 
        g_bstrSession &&
        g_bstrScriptingNamespace &&
        g_bstrObjectContext
        )
        ? S_OK : E_OUTOFMEMORY;
    }

/*===================================================================
UnInitCachedBSTRs

Delete frequently used BSTRs
===================================================================*/
HRESULT UnInitCachedBSTRs()
    {
    if (g_bstrApplication)
        {
        SysFreeString(g_bstrApplication);
        g_bstrApplication = NULL;
        }
    if (g_bstrRequest)
        {
        SysFreeString(g_bstrRequest);
        g_bstrRequest = NULL;
        }
    if (g_bstrResponse)
        {
        SysFreeString(g_bstrResponse);
        g_bstrResponse = NULL;
        }
    if (g_bstrServer)
        {
        SysFreeString(g_bstrServer);
        g_bstrServer = NULL;
        }
    if (g_bstrCertificate)
        {
        SysFreeString(g_bstrCertificate);
        g_bstrCertificate = NULL;
        }
    if (g_bstrSession)
        {
        SysFreeString(g_bstrSession);
        g_bstrSession = NULL;
        }
    if (g_bstrScriptingNamespace)
        {
        SysFreeString(g_bstrScriptingNamespace);
        g_bstrScriptingNamespace = NULL;
        }
    if (g_bstrObjectContext)
        {
        SysFreeString(g_bstrObjectContext);
        g_bstrObjectContext = NULL;
        }
    return S_OK;
    }

// Cached typeinfo's
ITypeInfo   *g_ptinfoIDispatch = NULL;              // Cache IDispatch typeinfo
ITypeInfo   *g_ptinfoIUnknown = NULL;               // Cache IUnknown typeinfo
ITypeInfo   *g_ptinfoIStringList = NULL;            // Cache IStringList typeinfo
ITypeInfo   *g_ptinfoIRequestDictionary = NULL;     // Cache IRequestDictionary typeinfo
ITypeInfo   *g_ptinfoIReadCookie = NULL;            // Cache IReadCookie typeinfo
ITypeInfo   *g_ptinfoIWriteCookie = NULL;           // Cache IWriteCookie typeinfo

/*===================================================================
CacheStdTypeInfos

This is kindofa funny OA-threading bug workaround and perf improvement.
Because we know that they typinfo's for IUnknown and IDispatch are
going to be used like mad, we will load them on startup and keep
them addref'ed.  Without this, OA would be loading and unloading
their typeinfos on almost every Invoke.

Also, cache denali's typelib so everyone can get at it, and
cache tye typeinfo's of all our non-top-level intrinsics.

Returns:
    HRESULT - S_OK on success
    
Side effects:
===================================================================*/
HRESULT CacheStdTypeInfos()
    {
    HRESULT hr = S_OK;
    ITypeLib *pITypeLib = NULL;
    CMBCSToWChar    convStr;

    /*
     * Load the typeinfos for IUnk and IDisp
     */
    hr = LoadRegTypeLib(IID_StdOle,
                 STDOLE2_MAJORVERNUM,
                 STDOLE2_MINORVERNUM,
                 STDOLE2_LCID,
                 &pITypeLib);
    if (hr != S_OK)
        {
        hr = LoadTypeLibEx(OLESTR("stdole2.tlb"), REGKIND_DEFAULT, &pITypeLib);
        }

    hr = pITypeLib->GetTypeInfoOfGuid(IID_IDispatch, &g_ptinfoIDispatch);
    if (SUCCEEDED(hr))
        {
        hr = pITypeLib->GetTypeInfoOfGuid(IID_IUnknown, &g_ptinfoIUnknown);
        }

    pITypeLib->Release();
    pITypeLib = NULL;

    if (FAILED(hr))
        goto LFail;

    /*
     * Load denali's typelibs.  Save them in Glob.
     */
     
    /*
     * The type libraries are registered under 0 (neutral),
     * and 9 (English) with no specific sub-language, which
     * would make them 407 or 409 and such.
     * If we become sensitive to sub-languages, then use the
     * full LCID instead of just the LANGID as done here.
     */

    char szPath[MAX_PATH];
        
    // Get the path for denali so we can look for the TLB there.
    if (!GetModuleFileNameA(g_hinstDLL, szPath, sizeof(szPath)/sizeof(char)))
        return E_FAIL;
    
    if (FAILED(hr = convStr.Init(szPath)))
        goto LFail;

    hr = LoadTypeLibEx(convStr.GetString(), REGKIND_DEFAULT, &pITypeLib);

    // Since it's presumably in our DLL, make sure that we loaded it.
    Assert (SUCCEEDED(hr));
    if (FAILED(hr))
        goto LFail;

    // Save it in Glob
    gGlob.m_pITypeLibDenali = pITypeLib;

    /*
     * Now cache the typeinfo's of all non-top-level intrinsics
     * This is for the OA workaround and for performance.
     */
    hr = pITypeLib->GetTypeInfoOfGuid(IID_IStringList, &g_ptinfoIStringList);
    if (FAILED(hr))
        goto LFail;
    hr = pITypeLib->GetTypeInfoOfGuid(IID_IRequestDictionary, &g_ptinfoIRequestDictionary);
    if (FAILED(hr))
        goto LFail;
    hr = pITypeLib->GetTypeInfoOfGuid(IID_IReadCookie, &g_ptinfoIReadCookie);
    if (FAILED(hr))
        goto LFail;
    hr = pITypeLib->GetTypeInfoOfGuid(IID_IWriteCookie, &g_ptinfoIWriteCookie);
    if (FAILED(hr))
        goto LFail;

LFail:
    return(hr);
    }

/*===================================================================
UnCacheStdTypeInfos

Release the typeinfo's we have cached for IUnknown and IDispatch
and the denali typelib and the other cached stuff.

Returns:
    HRESULT - S_OK on success
    
Side effects:
===================================================================*/
HRESULT UnCacheStdTypeInfos()
    {
    ITypeInfo **ppTypeInfo;

    // Release the typeinfos for IUnk and IDisp
    if (g_ptinfoIDispatch)
        {
        g_ptinfoIDispatch->Release();
        g_ptinfoIDispatch = NULL;
        }
    if (g_ptinfoIUnknown)
        {
        g_ptinfoIUnknown->Release();
        g_ptinfoIDispatch = NULL;
        }

    // Let go of the cached Denali typelibs
    Glob(pITypeLibDenali)->Release();

    // Let go of other cached typeinfos
    g_ptinfoIStringList->Release();
    g_ptinfoIRequestDictionary->Release();
    g_ptinfoIReadCookie->Release();
    g_ptinfoIWriteCookie->Release();

    return(S_OK);
    }

/*===================================================================
InitODBC

Based on the registry Entry value for StartConnectionPool
we will initialize the ODBC Connection Pool. 
This initialization requires no un-init call

StartConnectionPool = TRUE - turn on connection pooling
StartConnectionPool = FALSE

Returns:
    Void - no return value
===================================================================*/
/*void InitODBC(void)
    {
        
    if (!Glob(fStartConnectionPool))
        return;
        
    signed short    rc;

    // define the function pointer type     
    typedef signed short(CALLBACK *PFNSQLSetEnvAttr)
                        (
                        DWORD, DWORD, void*, DWORD
                        );  

    // declare the function pointer
    PFNSQLSetEnvAttr pfnSQLSetEnvAttr;
    g_hODBC32Lib = LoadLibrary("odbc32.dll");
    if(g_hODBC32Lib)
        {
        pfnSQLSetEnvAttr = (PFNSQLSetEnvAttr) GetProcAddress(g_hODBC32Lib, "SQLSetEnvAttr");        

        if (pfnSQLSetEnvAttr)
            rc = (*pfnSQLSetEnvAttr)(0UL, 201UL, (void*)2UL, 0UL);      
            // rc = SQLSetEnvAttr(SQL_NULL_HENV, SQL_ATTR_CONNECTION_POOLING, (void*)SQL_CP_ONE_PER_HENV,0)         
            // I did not want to include all of the SQL h files so I hard-coded the values
            // for the constants
            
        }   
    }   
*/
/*===================================================================
UnInitODBC

Based on the registry Entry value for StartConnectionPool
we will free the odbc32.dll that was loaded with InitODBC

StartConnectionPool = TRUE - turn on connection pooling
StartConnectionPool = FALSE


Returns:
    Void - no return value
===================================================================*/
/*      
void UnInitODBC(void)
    {       
    if (!Glob(fStartConnectionPool))
        return;
        
    if (g_hODBC32Lib)
        FreeLibrary(g_hODBC32Lib);  
    }   
*/
/*===================================================================
MakeAspCookieName

Creates the asp cookie name as concatination of standard prefix and
current process id.

This function is called once per ASP.DLL (oon DllInit())

Parameters:
    szCookie        [out] Put cookie name here

Returns:
    NOTHING
===================================================================*/
static void MakeAspCookieName(char *szCookie)
    {
    // Standard prefix
    strcpy(szCookie, SZ_SESSION_ID_COOKIE_PREFIX);
    szCookie += CCH_SESSION_ID_COOKIE_PREFIX;

    // Process ID
    sprintf(szCookie, "%08x", GetCurrentProcessId());

    // Uppercase
    strupr(szCookie);

    // Change digits to letters
    static const char *pszDigitsToLetters[2] = {"GHIJKLMNOP","QRSTUVWXYZ"};
    for (int i = 0; i < 8; i++)
        {
        int ch = szCookie[i];
        if (ch >= '0' && ch <= '9')
            szCookie[i] = pszDigitsToLetters[rand() % 2][ch - '0'];
        }
    }

/*===================================================================
SendHtmlSubstitute

Send the html file named XXX_ASP.HTM instead of rejecting the
request.

Parameters:
    pIReq       CIsapiReqInfo

Returns:
    HRESULT     (S_FALSE = no html substitute found)
===================================================================*/
HRESULT SendHtmlSubstitute(CIsapiReqInfo    *pIReq)
    {
    TCHAR *szAspPath = pIReq->QueryPszPathTranslated();
    DWORD cchAspPath = pIReq->QueryCchPathTranslated();

    // verify file name
    if (cchAspPath < 4 || cchAspPath > MAX_PATH || 
        _tcsicmp(szAspPath + cchAspPath - 4, _T(".asp")) != 0)
        {
        return S_FALSE;
        }

    // construct path of the html file
    TCHAR szHtmPath[MAX_PATH+5];
    DWORD cchHtmPath = cchAspPath + 4;
    _tcscpy(szHtmPath, szAspPath);
    szHtmPath[cchAspPath - 4] = _T('_');
    _tcscpy(szHtmPath + cchAspPath, _T(".htm"));

    // check if the html file exists
    if (FAILED(AspGetFileAttributes(szHtmPath)))
        return S_FALSE;

    return CResponse::SyncWriteFile(pIReq, szHtmPath);
    }
       


#ifdef LOG_FCNOTIFICATIONS
// UNDONE get this from registry
LPSTR   g_szNotifyLogFile = "C:\\Temp\\AspNotify.Log";
HANDLE  g_hfileNotifyLog;
HANDLE  g_hmapNotifyLog;
char*   g_pchNotifyLogStart;
char*   g_pchNotifyLogCurrent;
LPSTR   g_szNotifyPrefix = "File change notification: ";
LPSTR   g_szCreateHandlePrefix = "Create handle: ";

void LfcnCreateLogFile()
    {
    DWORD   dwErrCode;

    if(INVALID_HANDLE_VALUE != (g_hfileNotifyLog = 
                                CreateFile( 
                                            g_szNotifyLogFile,              // file name
                                            GENERIC_READ | GENERIC_WRITE,   // access (read-write) mode
                                            FILE_SHARE_READ,        // share mode
                                            NULL,                   // pointer to security descriptor
                                            CREATE_ALWAYS,          // how to create
                                            FILE_ATTRIBUTE_NORMAL,  // file attributes
                                            NULL                    // handle to file with attributes to copy
                                           )))
        {
        BYTE    rgb[0x10000];
        DWORD   cb = sizeof( rgb );
        DWORD   cbWritten = 0;
//      FillMemory( rgb, cb, 0xAB );

        WriteFile(
                    g_hfileNotifyLog,   // handle to file to write to 
                    rgb,                // pointer to data to write to file 
                    cb,                 // number of bytes to write 
                    &cbWritten,         // pointer to number of bytes written 
                    NULL                // pointer to structure needed for overlapped I/O
                   );

        if(NULL != (g_hmapNotifyLog = 
                    CreateFileMapping(
                                        g_hfileNotifyLog,       // handle to file to map 
                                        NULL,           // optional security attributes 
                                        PAGE_READWRITE,     // protection for mapping object 
                                        0,              // high-order 32 bits of object size  
                                        100,                // low-order 32 bits of object size  
                                        NULL            // name of file-mapping object 
                                    )))
            {
            if(NULL != (g_pchNotifyLogStart = 
                        (char*) MapViewOfFile(
                                                g_hmapNotifyLog,        // file-mapping object to map into address space
                                                FILE_MAP_WRITE, // access mode  
                                                0,              // high-order 32 bits of file offset 
                                                0,              // low-order 32 bits of file offset 
                                                0               // number of bytes to map 
                                            )))
                {
                *g_pchNotifyLogStart = '\0';
                g_pchNotifyLogCurrent = g_pchNotifyLogStart;
                LfcnAppendLog( "ASP change-notifications log file \r\n" );
                LfcnAppendLog( "================================= \r\n" );
                DBGPRINTF((DBG_CONTEXT,  "Notifications log file created and mapped.\r\n" ));
                return;
                }
            }
        }

    dwErrCode = GetLastError();
    DBGERROR((DBG_CONTEXT, "Failed to create notifications log file; last error was %d\r\n", szErrCode));
    }
    
void LfcnCopyAdvance(char** ppchDest, const char* sz)
    {
    // UNDONE make this robust (WriteFile to extend file?)
    strcpy( *ppchDest, sz );
    *ppchDest += strlen( sz );
    }

void LfcnAppendLog(const char* sz)
    {
    LfcnCopyAdvance( &g_pchNotifyLogCurrent, sz );
    DBGPRINTF((DBG_CONTEXT, "%s", sz));
    }

void LfcnLogNotification(char* szFile)
    {
    LfcnAppendLog( g_szNotifyPrefix );
    LfcnAppendLog( szFile );
    LfcnAppendLog( "\r\n" );
    }

void LfcnLogHandleCreation(int i, char* szApp)
    {
    char    szIndex[5];
    _itoa( i, szIndex, 10);

    LfcnAppendLog( g_szCreateHandlePrefix );
    LfcnAppendLog( szIndex );
    LfcnAppendLog( "\t" );
    LfcnAppendLog( szApp );
    LfcnAppendLog( "\r\n" );
    }

void LfcnUnmapLogFile()
    {
    if(g_pchNotifyLogStart != NULL)
        UnmapViewOfFile(g_pchNotifyLogStart);
        
    if(g_hmapNotifyLog!= NULL)
        CloseHandle(g_hmapNotifyLog);
        
    if(g_hfileNotifyLog != NULL && g_hfileNotifyLog != INVALID_HANDLE_VALUE)
        CloseHandle( g_hfileNotifyLog );
        
    g_pchNotifyLogStart = NULL;
    g_hmapNotifyLog = NULL;
    g_hfileNotifyLog = NULL;
    }

#endif  //LOG_FCNOTIFICATIONS

#if _IIS_5_1
LONG CWamModule::Lock()
{
    return CComModule::Lock();
}

LONG CWamModule::Unlock()
{
    return CComModule::Unlock();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\debugger.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: misc

File: util.cpp

Owner: DGottner

This file contains debugger utility functions
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "vector.h"
#include "debugger.h"
#include "iiscnfg.h"
#include "mdcommsg.h"   // for RETURNCODETOHRESULT macro
#include "memchk.h"
#include "vecimpl.h"

/* Win64: This struct is used to package data passed to the thread handler.
 *        (3 DWORDs are too small in 64 bit world.)
 */
struct DebugThreadCallArgs
	{
	DWORD					dwMethod;
	IDebugApplication *		pDebugAppln;
	void *					pvArg;

	DebugThreadCallArgs(DWORD dwMethod = 0, IDebugApplication *pDebugAppln = 0, void *pvArg = 0)
		{
		this->dwMethod = dwMethod;
		this->pDebugAppln = pDebugAppln;
		this->pvArg = pvArg;
		}
	};


// Published globals

IProcessDebugManager *  g_pPDM = NULL;              // instance of debugger for this process.
IDebugApplication *     g_pDebugApp = NULL;         // Root ASP application
IDebugApplicationNode * g_pDebugAppRoot = NULL;     // used to create hierarchy tree
CViperActivity        * g_pDebugActivity = NULL;    // Debugger's activity
DWORD                   g_dwDebugThreadId = 0;      // Thread ID of viper activity

// Globals for debugging

static DWORD    g_dwDenaliAppCookie;            // Cookie to use to remove app
static HANDLE   g_hPDMTermEvent;                // PDM terminate event
static vector<DebugThreadCallArgs> *g_prgThreadCallArgs;    // for new 64 bit interface.

// This hash structure & CS is used by GetServerDebugRoot()

struct CDebugNodeElem : CLinkElem
    {
    IDebugApplicationNode *m_pServerRoot;

    HRESULT Init(char *szKey, int cchKey)
        {
        char *szKeyAlloc = new char [cchKey + 1];
        if (!szKeyAlloc) return E_OUTOFMEMORY;
        return CLinkElem::Init(memcpy(szKeyAlloc, szKey, cchKey + 1), cchKey);
        }

    ~CDebugNodeElem()
        {
        if (m_pKey)
            delete m_pKey;
        }
    };

static CHashTable g_HashMDPath2DebugRoot;
static CRITICAL_SECTION g_csDebugLock;      // Lock for g_hashMDPath2DebugRoot


/*===================================================================
InvokeDebuggerWithThreadSwitch

Invoke Debugger (or Debugger UI) method from a correct thread
using IDebugThreadCall.

Parameters
    IDebugApplication *pDebugAppln      to get to debugger UI
    DWORD              iMethod          which method to call
    void              *Arg              call argument

Returns
    HRESULT
===================================================================*/

// GUIDs for debugger events

static const GUID DEBUGNOTIFY_ONPAGEBEGIN =
            { 0xfd6806c0, 0xdb89, 0x11d0, { 0x8f, 0x81, 0x0, 0x80, 0xc7, 0x3d, 0x6d, 0x96 } };

static const GUID DEBUGNOTIFY_ONPAGEEND =
            { 0xfd6806c1, 0xdb89, 0x11d0, { 0x8f, 0x81, 0x0, 0x80, 0xc7, 0x3d, 0x6d, 0x96 } };

static const GUID DEBUGNOTIFY_ON_REFRESH_BREAKPOINT =
            { 0xffcf4b38, 0xfa12, 0x11d0, { 0x8f, 0x3b, 0x0, 0xc0, 0x4f, 0xc3, 0x4d, 0xcc } };

// Local class that implements IDebugCallback
class CDebugThreadDebuggerCall : public IDebugThreadCall
    {
public:
    STDMETHODIMP         QueryInterface(const GUID &, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP ThreadCallHandler(DWORD_PTR, DWORD_PTR, DWORD_PTR);
    };

HRESULT CDebugThreadDebuggerCall::QueryInterface
(
const GUID &iid,
void **ppv
)
    {
    if (iid == IID_IUnknown || iid == IID_IDebugThreadCall)
        {
        *ppv = this;
        return S_OK;
        }
    else
        {
        *ppv = NULL;
        return E_NOINTERFACE;
        }
    }

ULONG CDebugThreadDebuggerCall::AddRef()
    {
    return 1;
    }

ULONG CDebugThreadDebuggerCall::Release()
    {
    return 1;
    }

HRESULT CDebugThreadDebuggerCall::ThreadCallHandler
(
DWORD_PTR iArg,
DWORD_PTR ,
DWORD_PTR
)
    {
	// Get arguments
	DebugThreadCallArgs *pThreadCallArgs = &(*g_prgThreadCallArgs)[(int)iArg];
    IDebugApplication *  pDebugAppln     = pThreadCallArgs->pDebugAppln;
    DWORD                dwMethod        = pThreadCallArgs->dwMethod;
    void *               pvArg           = pThreadCallArgs->pvArg;

	// we won't reference the argument block again, so free it up now.
	pThreadCallArgs->dwMethod |= DEBUGGER_UNUSED_RECORD;

    BOOL fForceDebugger  = (dwMethod & (DEBUGGER_UI_BRING_DOCUMENT_TO_TOP|DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP)) != 0;
    BOOL fNeedDebuggerUI = (dwMethod & (DEBUGGER_UI_BRING_DOCUMENT_TO_TOP|DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP)) != 0;
    BOOL fNeedNodeEvents = (dwMethod & DEBUGGER_ON_REMOVE_CHILD) != 0;
    BOOL fNeedDebugger   = (dwMethod & ~DEBUGGER_ON_DESTROY) != 0;

    HRESULT hr = S_OK;

    IApplicationDebugger *pDebugger = NULL;
    IApplicationDebuggerUI *pDebuggerUI = NULL;
    IDebugApplicationNodeEvents *pNodeEvents = NULL;

    if (pDebugAppln == NULL)
        return E_POINTER;

    // Get the debugger
    if (fNeedDebugger)
        {
        hr = pDebugAppln->GetDebugger(&pDebugger);

        if (FAILED(hr))
            {
            // Debugger is not currently debugging our application.
            if (!fForceDebugger)
                return E_FAIL; // no debugger

            // Start the debugger and try again.
            hr = pDebugAppln->StartDebugSession();

            if (SUCCEEDED(hr))
                hr = pDebugAppln->GetDebugger(&pDebugger);
            }

        // Debugger UI is needed only for some methods
        if (SUCCEEDED(hr) && fNeedDebuggerUI)
            {
            hr = pDebugger->QueryInterface
                (
                IID_IApplicationDebuggerUI,
                reinterpret_cast<void **>(&pDebuggerUI)
                );
            }

        // Debugger UI is needed only for some methods
        if (SUCCEEDED(hr) && fNeedNodeEvents)
            {
            hr = pDebugger->QueryInterface
                (
                IID_IDebugApplicationNodeEvents,
                reinterpret_cast<void **>(&pNodeEvents)
                );
            }
        }

    // Call the desired method
    if (SUCCEEDED(hr))
        {
        switch (dwMethod)
            {
            case DEBUGGER_EVENT_ON_PAGEBEGIN:
                {
                hr = pDebugger->onDebuggerEvent
                    (
                    DEBUGNOTIFY_ONPAGEBEGIN,
                    static_cast<IUnknown *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_EVENT_ON_PAGEEND:
                {
                hr = pDebugger->onDebuggerEvent
                    (
                    DEBUGNOTIFY_ONPAGEEND,
                    static_cast<IUnknown *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_EVENT_ON_REFRESH_BREAKPOINT:
                {
                hr = pDebugger->onDebuggerEvent
                    (
                    DEBUGNOTIFY_ON_REFRESH_BREAKPOINT,
                    static_cast<IUnknown *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_ON_REMOVE_CHILD:
                {
                hr = pNodeEvents->onRemoveChild
                    (
                    static_cast<IDebugApplicationNode *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_ON_DESTROY:
                {
                hr = static_cast<IDebugDocumentTextEvents *>(pvArg)->onDestroy();
                break;
                }
            case DEBUGGER_UI_BRING_DOCUMENT_TO_TOP:
                {
                hr = pDebuggerUI->BringDocumentToTop
                    (
                    static_cast<IDebugDocumentText *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP:
                {
                hr = pDebuggerUI->BringDocumentContextToTop
                    (
                    static_cast<IDebugDocumentContext *>(pvArg)
                    );
                break;
                }
            default:
                hr = E_FAIL;
                break;
            }
        }

    // Cleanup
    if (pDebuggerUI) pDebuggerUI->Release();
    if (pNodeEvents) pNodeEvents->Release();
    if (pDebugger) pDebugger->Release();

    return hr;
    }

// The function calls using IDebugThreadCall
HRESULT InvokeDebuggerWithThreadSwitch
(
IDebugApplication *pDebugAppln,
DWORD              dwMethod,
void              *pvArg
)
    {
	// take these arguments and package them up in the array.  We will pass the
	// index to the callback handler.
	//
	// first look for a freed up element before creating a new one.

	for (int i = g_prgThreadCallArgs->length() - 1; i >= 0; --i)
		{
		DebugThreadCallArgs *pThreadCallArgs = &(*g_prgThreadCallArgs)[i];
		if (pThreadCallArgs->dwMethod & DEBUGGER_UNUSED_RECORD)
			{
			pThreadCallArgs->dwMethod    = dwMethod;
			pThreadCallArgs->pDebugAppln = pDebugAppln;
			pThreadCallArgs->pvArg       = pvArg;
			break;
			}
		}
	
	if (i < 0)
		{
		HRESULT hr = g_prgThreadCallArgs->append(DebugThreadCallArgs(dwMethod, pDebugAppln, pvArg));
		if (FAILED(hr))
			return hr;

		i = g_prgThreadCallArgs->length() - 1;
		}

    CDebugThreadDebuggerCall Call;
    return pDebugAppln->SynchronousCallInDebuggerThread
        (
        &Call, i, 0, 0
        );
    }


/*===================================================================
FCaesars

Query registry to determine if default debugger is Caesar's
(Script Debugger)
===================================================================*/

BOOL FCaesars()
	{
	static BOOL fCaesars = 0xBADF00D;
	HKEY  hKey = NULL;
	char  szRegPath[_MAX_PATH];
	DWORD dwSize = sizeof szRegPath;

	// Check to see if Ceasers is registered as the JIT debugger on this machine.

	if (fCaesars == 0xBADF00D)
		{
		fCaesars = FALSE;
		if (RegOpenKey(HKEY_CLASSES_ROOT, _T("CLSID\\{834128A2-51F4-11D0-8F20-00805F2CD064}\\LocalServer32"), &hKey) == ERROR_SUCCESS)
			{
			if (RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE) szRegPath, &dwSize) == ERROR_SUCCESS)
				{
				char szFile[_MAX_FNAME];
				_splitpath(szRegPath, NULL, NULL, szFile, NULL);
				if (_stricmp(szFile, "msscrdbg") == 0)
					fCaesars = TRUE;
				}

			CloseHandle (hKey);
			}
		}

	return fCaesars;
	}


/*===================================================================
DestroyDocumentTree

Recursively release all the nodes in a document tree.

Parameters
    IDebugApplication *pDocRoot         root of hierarchy to destroy
===================================================================*/
void
DestroyDocumentTree(IDebugApplicationNode *pDocRoot)
    {
    IEnumDebugApplicationNodes *pEnum;

    if (SUCCEEDED(pDocRoot->EnumChildren(&pEnum)) && pEnum != NULL)
        {
        IDebugApplicationNode *pDocNode;
        while (pEnum->Next(1, &pDocNode, NULL) == S_OK)
            DestroyDocumentTree(pDocNode);

        pEnum->Release();
        }

    // See if this is a directory node
    //
    IFileNode *pFileNode;
    if (SUCCEEDED(pDocRoot->QueryInterface(IID_IFileNode, reinterpret_cast<void **>(&pFileNode))))
        {
        // This is a directory node, only detach when its document count vanishes)
        if (pFileNode->DecrementDocumentCount() == 0)
            {
            pDocRoot->Detach();
            pDocRoot->Close();
            pDocRoot->Release();
            }

        pFileNode->Release();
        }
    else
        {
        // This node is a CTemplate (or one of its include files)
        pDocRoot->Detach();
        pDocRoot->Close();
        pDocRoot->Release();
        }

    }

/*===================================================================
CreateDocumentTree

Takes a path to be rooted at a node "pDocRoot", parses the path,
and creates a node for each component of the path. Returns the
leaf (Since the root is known) as its value.

This function is called from contexts where part of the document
tree may already exist, so EnumChildren is called and nodes are only
created when a child does not exist. When a node exists, we merely
descend into the tree.

NOTE:
    The intermediate nodes are created with a CFileNode document
    implementation.  The leaf node is not given a document provider
    - the caller must provide one.

Parameters
    wchar_t *          szDocPath    path of the document
    IDebugApplication *pDocParent   parent to attach the application tree to
    IDebugApplication **ppDocRoot   returns root of document hierarchy
    IDebugApplication **ppDocLeaf   returns document leaf node.
    wchar_t **        pwszLeaf      name of the leaf node

Returns
    HRESULT
===================================================================*/
HRESULT CreateDocumentTree
(
wchar_t *wszDocPath,
IDebugApplicationNode *pDocParent,
IDebugApplicationNode **ppDocRoot,
IDebugApplicationNode **ppDocLeaf,
wchar_t **pwszLeaf
)
    {
    HRESULT hr;
    BOOL fCreateOnly = FALSE;   // Set to TRUE when there is no need to check for duplicate node
    *ppDocRoot = *ppDocLeaf = NULL;

    // Ignore initial delimiters
    while (wszDocPath[0] == '/')
        ++wszDocPath;

    // Now loop over every component in the path, adding a node for each
    while (wszDocPath != NULL)
        {
        // Get next path component
        *pwszLeaf = wszDocPath;
        wszDocPath = wcschr(wszDocPath, L'/');
        if (wszDocPath)
            *wszDocPath++ = L'\0';

        // Check to see if this component is already a child or not
        BOOL fNodeExists = FALSE;
        if (!fCreateOnly)
            {
            IEnumDebugApplicationNodes *pEnum;
            if (SUCCEEDED(pDocParent->EnumChildren(&pEnum)) && pEnum != NULL)
                {
                IDebugApplicationNode *pDocChild;
                while (!fNodeExists && pEnum->Next(1, &pDocChild, NULL) == S_OK)
                    {
                    BSTR bstrName = NULL;
                    if (FAILED(hr = pDocChild->GetName(DOCUMENTNAMETYPE_APPNODE, &bstrName)))
                        return hr;

                    if (wcscmp(bstrName, *pwszLeaf) == 0)
                        {
                        // The name of this node is equal to the component.  Instead of
                        // creating a new node, descend into the tree.
                        //
                        fNodeExists = TRUE;
                        *ppDocLeaf = pDocChild;

                        // If '*ppDocRoot' hasn't been assigned to yet, this means that
                        // this is the first node found (and hence the root of the tree)
                        //
                        if (*ppDocRoot == NULL)
                            {
                            *ppDocRoot = pDocChild;
                            (*ppDocRoot)->AddRef();
                            }

                        // If this node is a CFileNode structure (we don't require it to be)
                        // then increment its (recursive) containing document count.
                        //
                        IFileNode *pFileNode;
                        if (SUCCEEDED(pDocChild->QueryInterface(IID_IFileNode, reinterpret_cast<void **>(&pFileNode))))
                            {
                            pFileNode->IncrementDocumentCount();
                            pFileNode->Release();
                            }
                        }

                    SysFreeString(bstrName);
                    pDocChild->Release();
                    }

                pEnum->Release();
                }
            }

        // Create a new node if the node was not found above.  Also, at this point,
        // to save time, we always set "fCreateOnly" to TRUE because if we are
        // forced to create a node at this level, we will need to create nodes at
        // all other levels further down
        //
        if (!fNodeExists)
            {
            fCreateOnly = TRUE;

            // Create the node
            if (FAILED(hr = g_pDebugApp->CreateApplicationNode(ppDocLeaf)))
                return hr;

            // Create a doc provider for the node - for intermediate nodes only
            if (wszDocPath != NULL) // intermediate node
                {
                CFileNode *pFileNode = new CFileNode;
                if (pFileNode == NULL ||
                    FAILED(hr = pFileNode->Init(*pwszLeaf)) ||
                    FAILED(hr = (*ppDocLeaf)->SetDocumentProvider(pFileNode)))
                    {
                    (*ppDocLeaf)->Release();
                    return E_OUTOFMEMORY;
                    }

                // New node, only one document (count started at 0, so this will set to 1)
                pFileNode->IncrementDocumentCount();

                // SetDocumentProvider() AddRef'ed
                pFileNode->Release();
                }

                // If '*ppDocRoot' hasn't been assigned to yet, this means that
                // this is the first node created (and hence the root of the tree)
                //
                if (*ppDocRoot == NULL)
                    {
                    *ppDocRoot = *ppDocLeaf;
                    (*ppDocRoot)->AddRef();
                    }

            // Attach the node
            if (FAILED(hr = (*ppDocLeaf)->Attach(pDocParent)))
                return hr;
            }

        // Descend
        pDocParent = *ppDocLeaf;
        }

    if (*ppDocLeaf)
        (*ppDocLeaf)->AddRef();

    return S_OK;
    }

/*===================================================================
Debugger

The purpose of this thread is to create an execution environment for
the Process Debug Manager (PDM). There is only one PDM per process,
and this does not really fit in other threads, so we dedicate a thread to this.

Parameters:
    LPVOID  params
                Points to a BOOL* which will be set to 1 when
                this thread is completely initialized.

Returns:
    0
===================================================================*/
void __cdecl Debugger(void *pvInit)
    {
    HRESULT hr;

    if (FAILED(hr = CoInitializeEx(NULL, COINIT_MULTITHREADED)))
        {
        // Bug 87857: if we get E_INVALIDARG, we need to do a CoUninitialize
        if (hr == E_INVALIDARG)
            CoUninitialize();

        *static_cast<BOOL *>(pvInit) = TRUE;
        return;
        }

    if (FAILED(CoCreateInstance(
                    CLSID_ProcessDebugManager,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IProcessDebugManager,
                    reinterpret_cast<void **>(&g_pPDM))))

        {
        *static_cast<BOOL *>(pvInit) = TRUE;
        CoUninitialize();
        return;
        }

    *static_cast<BOOL *>(pvInit) = TRUE;
    while (TRUE)
        {
        DWORD dwRet = MsgWaitForMultipleObjects(1,
                                                &g_hPDMTermEvent,
                                                FALSE,
                                                INFINITE,
                                                QS_ALLINPUT);

        if (dwRet == WAIT_OBJECT_0)
            break;

        MSG msg;
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            DispatchMessage(&msg);
        }

    g_pPDM->Release();
    CoUninitialize();

    g_pPDM = NULL; // indication that the thread is gone
    }

/*===================================================================
HRESULT StartPDM()

kick off the PDM thread
===================================================================*/

HRESULT StartPDM()
    {
    BOOL fStarted = FALSE;

    g_hPDMTermEvent = IIS_CREATE_EVENT(
                          "g_hPDMTermEvent",
                          &g_hPDMTermEvent,
                          TRUE,
                          FALSE
                          );

    if( g_hPDMTermEvent == NULL )
        return E_FAIL;

    _beginthread(Debugger, 0, &fStarted);
    while (!fStarted)
        Sleep(100);

    if (g_pPDM == NULL)     // could not create the PDM for some reason
        {
        CloseHandle(g_hPDMTermEvent);
        g_hPDMTermEvent = NULL;
        return E_FAIL;
        }

    return S_OK;
    }

/*===================================================================
HRESULT InitDebuggingAndCreateActivity

Initialize everything we need for debugging

NOTE: The long name here is meant to emphasize the different
      behaviors between Init & UnInit.  Namely, the creation of
      the viper activity along with everything else.
===================================================================*/
HRESULT InitDebuggingAndCreateActivity
(
CIsapiReqInfo *pIReq
)
    {
    HRESULT hr;

    // Start the PDM
    if (FAILED(hr = StartPDM()))
        return hr;

    Assert (g_pPDM);    // StartPDM succeeds ==> g_pPDM <> NULL

    ErrInitCriticalSection(&g_csDebugLock, hr);
    if (FAILED(hr))
        return hr;

    // Create the debug application & give it a name
    if (FAILED(hr = g_pPDM->CreateApplication(&g_pDebugApp)))
        goto LErrorCleanup;

    // WinSE 23918: tripple buffer size for friendly app names 
    wchar_t wszDebugAppName[180];

    wcscpy(wszDebugAppName, L"Microsoft Active Server Pages");   // DO NOT LOCALIZE THIS STRING

    if (g_fOOP) {

        // Bug 154300: If a friendly app. name exists, use it along with the PID for
        //             WAM identification.
        // WinSE 23918: avoid buffer overrun. use (..., pid) when friendly app name
        //             is too long (about 120 chars or more). use(?, pid) when
        //             failed to read friendly name. use (-, pid) when szAppMDPath
        //             is empty. We may also return (, pid) when the app name
        //             is set to empty string.
        //
        // Declare some temporaries
        //
        DWORD dwApplMDPathLen;
        DWORD dwRequiredBuffer = 0;
        DWORD cchPrefix = wcslen(wszDebugAppName);
        wchar_t *pFriendlyAppName = wszDebugAppName + cchPrefix;

       	*pFriendlyAppName++ = ' ';
       	*pFriendlyAppName++ = '(';
    
        TCHAR *szApplMDPath = pIReq->QueryPszApplnMDPath();

        // get friendly name from metabase
        hr = pIReq->GetAspMDData(
                        szApplMDPath,
                        MD_APP_FRIENDLY_NAME,
                        METADATA_INHERIT,
                        ASP_MD_UT_APP,
                        STRING_METADATA,
                        sizeof(wszDebugAppName) - (cchPrefix+20)*sizeof(wchar_t),
                        0,
                        (BYTE*)pFriendlyAppName,
                        &dwRequiredBuffer);

        if (hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
        {
            wcscpy(pFriendlyAppName, L"...");   // friendly app name too long
        }
        else if (FAILED(hr))
        {
            wcscpy(pFriendlyAppName, L"?");    // can't read friendly app name
        }
            
        pFriendlyAppName += wcslen(pFriendlyAppName);

        // append process id
        *pFriendlyAppName++ = ',';
        *pFriendlyAppName++ = ' ';
        _itow(GetCurrentProcessId(), pFriendlyAppName, 10);

        wcscat(pFriendlyAppName, L")");
    }

    if (FAILED(hr = g_pDebugApp->SetName(wszDebugAppName)))
        goto LErrorCleanup;

    if (FAILED(hr = g_pPDM->AddApplication(g_pDebugApp, &g_dwDenaliAppCookie)))
        goto LErrorCleanup;

    if (FAILED(hr = g_pDebugApp->GetRootNode(&g_pDebugAppRoot)))
        goto LErrorCleanup;

    // Create Viper Activity for debugging
    g_pDebugActivity = new CViperActivity;
    if (g_pDebugActivity == NULL) {
        hr = E_OUTOFMEMORY;
        goto LErrorCleanup;
    }

    if (FAILED(hr = g_pDebugActivity->Init()))
        goto LErrorCleanup;

    // Init the hash table used for Keeping track of virtual server roots
    if (FAILED(hr = g_HashMDPath2DebugRoot.Init()))
        goto LErrorCleanup;

	// Create the array for passing data to debug thread
	if ((g_prgThreadCallArgs = new vector<DebugThreadCallArgs>) == NULL) {
		hr = E_OUTOFMEMORY;
		goto LErrorCleanup;
    }

    return S_OK;

LErrorCleanup:
    // Clean up some globals (some thing may be NULL and some not)
    if (g_pDebugAppRoot) {
        g_pDebugAppRoot->Release();
        g_pDebugAppRoot = NULL;
    }

    if (g_pDebugApp) {
        g_pDebugApp->Release();
        g_pDebugApp = NULL;
    }

    if (g_pDebugActivity) {
        delete g_pDebugActivity;
        g_pDebugActivity = NULL;
    }

    // Kill PDM thread if we started it up.
    if (g_pPDM) {
        SetEvent(g_hPDMTermEvent);

        while (g_pPDM)
            Sleep(100);

        CloseHandle(g_hPDMTermEvent);
        g_pPDM = NULL;
    }

    return hr;
}

/*===================================================================
UnInitDebugging

Uninitialize debugging

NOTE: WE DO NOT RELEASE THE VIPER DEBUG ACTIVITY.
      (EVEN THOUGH INIT CREATES IT)

      THIS IS BECAUSE UNINIT MUST BE INVOKED WHILE SCRIPTS ON THE
      ACTIVITY ARE STILL RUNNING!
===================================================================*/
HRESULT UnInitDebugging()
    {
    // Clear and UnInit the hash tables (containing the application nodes)
    CDebugNodeElem *pNukeDebugNode = static_cast<CDebugNodeElem *>(g_HashMDPath2DebugRoot.Head());
    while (pNukeDebugNode != NULL)
        {
        CDebugNodeElem *pNext = static_cast<CDebugNodeElem *>(pNukeDebugNode->m_pNext);
        pNukeDebugNode->m_pServerRoot->Detach();
        pNukeDebugNode->m_pServerRoot->Close();
        pNukeDebugNode->m_pServerRoot->Release();
        delete pNukeDebugNode;
        pNukeDebugNode = pNext;
        }
    g_HashMDPath2DebugRoot.UnInit();

    DeleteCriticalSection(&g_csDebugLock);

    // Unlink the top node
    if (g_pDebugAppRoot)
        {
        g_pDebugAppRoot->Detach();
        g_pDebugAppRoot->Close();
        g_pDebugAppRoot->Release();
        }

    // Delete the application
    if (g_pDebugApp)
        {
        Assert (g_pPDM != NULL);

        // EXPLICITLY ignore failure result here:
        //     if Init() failed earlier, then RemoveApplication will fail here.
        g_pPDM->RemoveApplication(g_dwDenaliAppCookie);
        g_pDebugApp->Close();
        g_pDebugApp->Release();
        g_pDebugApp = NULL;
        }

    // Tell the PDM to suicide
    if (g_pPDM)
        {
        SetEvent(g_hPDMTermEvent);

        while (g_pPDM)
            Sleep(100);

        CloseHandle(g_hPDMTermEvent);
        }

	// delete the argument buffer
	delete g_prgThreadCallArgs;

    return S_OK;
    }

/*===================================================================
GetServerDebugRoot

Each virtual server has its own root in the application tree.

    (i.e. the tree looks like
            Microsoft ASP
                <Virtual Server 1 Name>
                    <Denali Application Name>
                        <Files>
                <Virtual Server 2 Name>
                    <Denali Application>
                        ...

Since there may be multiple applications per each server, the
server nodes are managed at one central location (here) so that
new applications get added to the correct nodes.
===================================================================*/
HRESULT GetServerDebugRoot
(
CIsapiReqInfo   *pIReq,
IDebugApplicationNode **ppDebugRoot
)
    {
    HRESULT hr = E_FAIL;

    STACK_BUFFER( tempMDData, 2048 );
    *ppDebugRoot = NULL;

    // Get the metabase path for this virtual server from the CIsapiReqInfo
    DWORD dwInstanceMDPathLen;
    char *szInstanceMDPath;

    STACK_BUFFER( instPathBuf, 128 );

    if (!SERVER_GET(pIReq, "INSTANCE_META_PATH", &instPathBuf, &dwInstanceMDPathLen))
        return HRESULT_FROM_WIN32(GetLastError());

    szInstanceMDPath = (char *)instPathBuf.QueryPtr();

    // See if we already have a node for this path - If not then create it and add to hash table

    EnterCriticalSection(&g_csDebugLock);
    CDebugNodeElem *pDebugNode = static_cast<CDebugNodeElem *>(g_HashMDPath2DebugRoot.FindElem(szInstanceMDPath, dwInstanceMDPathLen - 1));

    if (!pDebugNode)
        {
        // Node does not exist, so create a new application node.
        pDebugNode = new CDebugNodeElem;
        if (pDebugNode == NULL)
            {
            hr = E_OUTOFMEMORY;
            goto LExit;
            }

        if (FAILED(hr = pDebugNode->Init(szInstanceMDPath, dwInstanceMDPathLen - 1)))
            goto LExit;

        // Look up server name in metabase.
        BYTE *prgbData = (BYTE *)tempMDData.QueryPtr();
        DWORD dwRequiredBuffer = 0;
        hr = pIReq->GetAspMDDataA(
                            szInstanceMDPath,
                            MD_SERVER_COMMENT,
                            METADATA_INHERIT,
                            IIS_MD_UT_SERVER,
                            STRING_METADATA,
                            tempMDData.QuerySize(),
                            0,
                            prgbData,
                            &dwRequiredBuffer);

        if (hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {

            if (tempMDData.Resize(dwRequiredBuffer) == FALSE) {
                hr = E_OUTOFMEMORY;
            }
            else {
                prgbData = reinterpret_cast<BYTE *>(tempMDData.QueryPtr());
                hr = pIReq->GetAspMDDataA(
                                    szInstanceMDPath,
                                    MD_SERVER_COMMENT,
                                    METADATA_INHERIT,
                                    IIS_MD_UT_SERVER,
                                    STRING_METADATA,
                                    dwRequiredBuffer,
                                    0,
                                    prgbData,
                                    &dwRequiredBuffer);
            }
        }
        if (FAILED(hr))
            {
            // ServerComment does not exist, so construct using server name and port

            STACK_BUFFER( serverNameBuff, 16 );
            DWORD cbServerName;
            STACK_BUFFER( serverPortBuff, 10 );
            DWORD cbServerPort;
            STACK_BUFFER( debugNodeBuff, 30 );

            if (!SERVER_GET(pIReq, "LOCAL_ADDR", &serverNameBuff, &cbServerName)
                || !SERVER_GET(pIReq, "SERVER_PORT", &serverPortBuff, &cbServerPort)) {
                hr = E_FAIL;
                goto LExit;
            }

            char *szServerName = (char *)serverNameBuff.QueryPtr();
            char *szServerPort = (char*)serverPortBuff.QueryPtr();

            // resize the debugNodeBuff to hold <serverIP>:<port>'\0'.
            if (!debugNodeBuff.Resize(cbServerName + cbServerPort + 2)) {
                hr = E_OUTOFMEMORY;
                goto LExit;
            }
            // Syntax is <serverIP:port>
            char *szDebugNode = (char *)debugNodeBuff.QueryPtr();
            strcpyExA(strcpyExA(strcpyExA(szDebugNode, szServerName), ":"), szServerPort);

            // Convert to Wide Char
            hr = MultiByteToWideChar(CP_ACP, 0, szDebugNode, -1, reinterpret_cast<wchar_t *>(prgbData), tempMDData.QuerySize() / 2);
            if (FAILED(hr))
                goto LExit;
            }

        // We've got the metadata (ServerComment), create a debug node with this name
        IDebugApplicationNode *pServerRoot;
        if (FAILED(hr = g_pDebugApp->CreateApplicationNode(&pServerRoot)))
            goto LExit;

        // Create a doc provider for the node
        CFileNode *pFileNode = new CFileNode;
        if (pFileNode == NULL)
            {
            hr = E_OUTOFMEMORY;
            goto LExit;
            }

        if (FAILED(hr = pFileNode->Init(reinterpret_cast<wchar_t *>(prgbData))))
            goto LExit;

        if (FAILED(hr = pServerRoot->SetDocumentProvider(pFileNode)))
            goto LExit;

        // pFileNode has been AddRef'ed and we don't need it now.
        pFileNode->Release();

        // Attach to the UI
        if (FAILED(pServerRoot->Attach(g_pDebugAppRoot)))
            goto LExit;

        // OK, Now add this item to the hashtable (this eats the reference from creation)
        pDebugNode->m_pServerRoot = pServerRoot;
        g_HashMDPath2DebugRoot.AddElem(pDebugNode);
        }

    *ppDebugRoot = pDebugNode->m_pServerRoot;
    (*ppDebugRoot)->AddRef();
    hr = S_OK;

LExit:
    LeaveCriticalSection(&g_csDebugLock);
    return hr;
    }

/*===================================================================
  C  F i l e  N o d e

Implementation of CFileNode - trivial class
===================================================================*/

const GUID IID_IFileNode =
            { 0x41047bd2, 0xfe1e, 0x11d0, { 0x8f, 0x3f, 0x0, 0xc0, 0x4f, 0xc3, 0x4d, 0xcc } };

CFileNode::CFileNode() : m_cRefs(1), m_cDocuments(0), m_wszName(NULL) {}
CFileNode::~CFileNode() { delete[] m_wszName; }


HRESULT
CFileNode::Init(wchar_t *wszName)
    {
    if ((m_wszName = new wchar_t [wcslen(wszName) + 1]) == NULL)
        return E_OUTOFMEMORY;

    wcscpy(m_wszName, wszName);
    return S_OK;
    }


HRESULT
CFileNode::QueryInterface(const GUID &uidInterface, void **ppvObj)
    {
    if (uidInterface == IID_IUnknown ||
        uidInterface == IID_IDebugDocumentProvider ||
        uidInterface == IID_IFileNode)
        {
        *ppvObj = this;
        AddRef();
        return S_OK;
        }
    else
        return E_NOINTERFACE;
    }


ULONG
CFileNode::AddRef()
    {
    InterlockedIncrement(reinterpret_cast<long *>(&m_cRefs));
    return m_cRefs;
    }


ULONG
CFileNode::Release()
{
    if (InterlockedDecrement(reinterpret_cast<long *>(&m_cRefs)) == 0)
        {
        delete this;
        return 0;
        }

    return m_cRefs;
}


HRESULT
CFileNode::GetDocument(IDebugDocument **ppDebugDoc)
    {
    return QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDoc));
    }


HRESULT
CFileNode::GetName(DOCUMENTNAMETYPE, BSTR *pbstrName)
    {
    return ((*pbstrName = SysAllocString(m_wszName)) == NULL)? E_OUTOFMEMORY : S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\dispatch.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: IDispatch implementation

File: Dispatch.h

Owner: DGottner

This file contains our implementation of IDispatch
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "dispatch.h"
#include "asptlb.h"

#include "memchk.h"

#ifdef USE_LOCALE
extern DWORD	 g_dwTLS;
#endif

/*===================================================================
CDispatch::CDispatch
CDispatch::~CDispatch

Parameters (Constructor):
	pUnkObj			pointer to the object we're in.
	pUnkOuter		LPUNKNOWN to which we delegate.
===================================================================*/

CDispatch::CDispatch()
	{
	m_pITINeutral = NULL;
	m_pITypeLib = NULL;
	m_pGuidDispInterface = NULL;
	}

void CDispatch::Init
(
const GUID &GuidDispInterface,
const ITypeLib *pITypeLib		// = NULL
)
	{
	m_pGuidDispInterface = &GuidDispInterface;
	m_pITypeLib = const_cast<ITypeLib *>(pITypeLib);
	}

CDispatch::~CDispatch(void)
	{
	ReleaseInterface(m_pITINeutral);
	return;
	}


/*===================================================================
CDispatch::GetTypeInfoCount

Returns the number of type information (ITypeInfo) interfaces
that the object provides (0 or 1).

Parameters:
	pcInfo		UINT * to the location to receive
				the count of interfaces.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/

STDMETHODIMP CDispatch::GetTypeInfoCount(UINT *pcInfo)
	{
	// We implement GetTypeInfo so return 1

	*pcInfo = 1;
	return S_OK;
	}


/*===================================================================
CDispatch::GetTypeInfo

Retrieves type information for the automation interface.	This
is used anywhere that the right ITypeInfo interface is needed
for whatever LCID is applicable.	Specifically, this is used
from within GetIDsOfNames and Invoke.

Parameters:
	itInfo			UINT reserved.	Must be zero.
	lcid			LCID providing the locale for the type
					information.	If the object does not support
					localization, this is ignored.
	ppITypeInfo		ITypeInfo ** in which to store the ITypeInfo
					interface for the object.

Return Value:
	HRESULT			S_OK or a general error code.
===================================================================*/

STDMETHODIMP CDispatch::GetTypeInfo(
	UINT itInfo,
	LCID lcid,
	ITypeInfo **ppITypeInfo
)
	{
	HRESULT hr;
	ITypeInfo **ppITI = NULL;

	if (0 != itInfo)
		return ResultFromScode(TYPE_E_ELEMENTNOTFOUND);

	if (NULL == ppITypeInfo)
		return ResultFromScode(E_POINTER);

	*ppITypeInfo = NULL;

    // We don't internationalize the type library, so
    // we always return the same one, regardless of the locale.
    
	ppITI = &m_pITINeutral;

	//Load a type lib if we don't have the information already.
	if (NULL == *ppITI)
		{
		ITypeLib *pITL;
		
		// If a specific TypeLib was given at init time use that, otherwise default to the main one
		if (m_pITypeLib == NULL)
			pITL = Glob(pITypeLibDenali);
		else
			pITL = m_pITypeLib;
		Assert(pITL != NULL);
			
		hr = pITL->GetTypeInfoOfGuid(*m_pGuidDispInterface, ppITI);

		if (FAILED(hr))
			return hr;

		// Save the type info in a class member, so we don't have
		// go through all this work again;
		m_pITINeutral = *ppITI;
		}

	/*
	 * Note: the type library is still loaded since we have
	 * an ITypeInfo from it.
	 */
	(*ppITI)->AddRef();
	*ppITypeInfo = *ppITI;
	return S_OK;
	}


/*===================================================================
CDispatch::GetIDsOfNames

Converts text names into DISPIDs to pass to Invoke

Parameters:
	riid			REFIID reserved. Must be IID_NULL.
	rgszNames		OLECHAR ** pointing to the array of names to be mapped.
	cNames			UINT number of names to be mapped.
	lcid			LCID of the locale.
	rgDispID		DISPID * caller allocated array containing IDs
					corresponging to those names in rgszNames.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/

STDMETHODIMP CDispatch::GetIDsOfNames
(
	REFIID riid,
	OLECHAR **rgszNames,
	UINT cNames,
	LCID lcid,
	DISPID *rgDispID
)
	{
	HRESULT hr;
	ITypeInfo *pTI;

	if (IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

	//Get the right ITypeInfo for lcid.
	hr = GetTypeInfo(0, lcid, &pTI);

	if (SUCCEEDED(hr))
		{
		hr = DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID);
		pTI->Release();
		}

	return hr;
	}


/*===================================================================
CDispatch::Invoke

Calls a method in the dispatch interface or manipulates a property.

Parameters:
	dispID			DISPID of the method or property of interest.
	riid			REFIID reserved, must be IID_NULL.
	lcid			LCID of the locale.
	wFlags			USHORT describing the context of the invocation.
	pDispParams		DISPPARAMS * to the array of arguments.
	pVarResult		VARIANT * in which to store the result.	Is
					NULL if the caller is not interested.
	pExcepInfo		EXCEPINFO * to exception information.
	puArgErr		UINT * in which to store the index of an
					invalid parameter if DISP_E_TYPEMISMATCH
					is returned.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/

STDMETHODIMP CDispatch::Invoke
(
DISPID dispID,
REFIID riid,
LCID lcid,
unsigned short wFlags,
DISPPARAMS *pDispParams,
VARIANT *pVarResult,
EXCEPINFO *pExcepInfo,
UINT *puArgErr
)
	{
	HRESULT hr;
	ITypeInfo *pTI;
	LANGID langID = PRIMARYLANGID(lcid);

	// riid is supposed to be IID_NULL always
	if (IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

	// Get the ITypeInfo for lcid
	hr = GetTypeInfo(0, lcid, &pTI);

	if (FAILED(hr))
		return hr;

#ifdef USE_LOCALE
	// This saves the language ID for this thread
	TlsSetValue(g_dwTLS, &langID);
#endif

	// Clear exceptions
	SetErrorInfo(0L, NULL);

	// VBScript does not distinguish between a propget and a method
	// implement that behavior for other languages.
	//
	if (wFlags & (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
		wFlags |= DISPATCH_METHOD | DISPATCH_PROPERTYGET;

	// This is exactly what DispInvoke does--so skip the overhead.
	// With dual interface, "this" is the address of the object AND its dispinterface
	//
	hr = pTI->Invoke(this, dispID, wFlags, 
					pDispParams, pVarResult, pExcepInfo, puArgErr);

	// Exception handling is done within ITypeInfo::Invoke

	pTI->Release();
	return hr;
	}


/*===================================================================
CSupportErrorInfo::CSupportErrorInfo

Default constructor so that the Init method can be used.

Parameters (Constructor):
	pObj			PCResponse of the object we're in.
	pUnkOuter		LPUNKNOWN to which we delegate.
===================================================================*/
CSupportErrorInfo::CSupportErrorInfo(void)
:	m_pUnkObj(NULL),
	m_pUnkOuter(NULL)
	{
	}

/*===================================================================
CSupportErrorInfo::CSupportErrorInfo

Parameters (Constructor):
	pObj				PCResponse of the object we're in.
	pUnkOuter			LPUNKNOWN to which we delegate.
	GuidDispInterface	GUID of dispatch interface.
===================================================================*/

CSupportErrorInfo::CSupportErrorInfo(IUnknown *pUnkObj, IUnknown *pUnkOuter, const GUID &GuidDispInterface)
	{
	m_pUnkObj = pUnkObj;
	m_pUnkOuter = (pUnkOuter == NULL)? pUnkObj : pUnkOuter;
	m_pGuidDispInterface = &GuidDispInterface;
	}

/*===================================================================
void CSupportErrorInfo::Init

Parameters:
	pObj				PCResponse of the object we're in.
	pUnkOuter			LPUNKNOWN to which we delegate.
	GuidDispInterface	GUID of dispatch interface.

Returns:
	Nothing
===================================================================*/

void CSupportErrorInfo::Init(IUnknown *pUnkObj, IUnknown *pUnkOuter, const GUID &GuidDispInterface)
	{
	m_pUnkObj = pUnkObj;
	m_pUnkOuter = (pUnkOuter == NULL)? pUnkObj : pUnkOuter;
	m_pGuidDispInterface = &GuidDispInterface;
	}

/*===================================================================
CSupportErrorInfo::QueryInterface
CSupportErrorInfo::AddRef
CSupportErrorInfo::Release

IUnknown members for CSupportErrorInfo object.
===================================================================*/

STDMETHODIMP CSupportErrorInfo::QueryInterface(const GUID &Iid, void **ppvObj)
	{
	return m_pUnkOuter->QueryInterface(Iid, ppvObj);
	}

STDMETHODIMP_(ULONG) CSupportErrorInfo::AddRef(void)
	{
	return m_pUnkOuter->AddRef();
	}

STDMETHODIMP_(ULONG) CSupportErrorInfo::Release(void)
	{
	return m_pUnkOuter->Release();
	}



/*===================================================================
CSupportErrorInfo::InterfaceSupportsErrorInfo

Informs a caller whether or not a specific interface
supports exceptions through the Set/GetErrorInfo mechanism.

Parameters:
	riid			REFIID of the interface in question.

Return Value:
	HRESULT			S_OK if a call to GetErrorInfo will succeed
					for callers of riid. S_FALSE if not.
===================================================================*/
STDMETHODIMP CSupportErrorInfo::InterfaceSupportsErrorInfo
(
REFIID riid
)
	{
	if (IID_IDispatch == riid || *m_pGuidDispInterface == riid)
		return S_OK;

	return ResultFromScode(S_FALSE);
	}



/*===================================================================
Exception

Raises an exception using the CreateErrorInfo API and the
ICreateErrorInfo interface.

Note that this method doesn't allow for deferred filling
of an EXCEPINFO structure.

Parameters:
	strSource	LPOLESTR the exception source
	strDescr	LPOLESTR the exception description

Returns:
	Nothing
===================================================================*/

void Exception
(
REFIID ObjID,
LPOLESTR strSource,
LPOLESTR strDescr
)
	{
	HRESULT hr;
	ICreateErrorInfo *pICreateErr;
	IErrorInfo *pIErr;
	LANGID langID = LANG_NEUTRAL;

#ifdef USE_LOCALE
	LANGID *pLangID;
	
	pLangID = (LANGID *)TlsGetValue(g_dwTLS);

	if (NULL != pLangID)
		langID = *pLangID;
#endif

	/*
	 * Thread-safe exception handling means that we call
	 * CreateErrorInfo which gives us an ICreateErrorInfo pointer
	 * that we then use to set the error information (basically
	 * to set the fields of an EXCEPINFO structure.	We then
	 * call SetErrorInfo to attach this error to the current
	 * thread.	ITypeInfo::Invoke will look for this when it
	 * returns from whatever function was invokes by calling
	 * GetErrorInfo.
	 */

	//Not much we can do if this fails.
	if (FAILED(CreateErrorInfo(&pICreateErr)))
		return;

	/*
	 * CONSIDER: Help file and help context?
	 */
	pICreateErr->SetGUID(ObjID);
	pICreateErr->SetHelpFile(L"");
	pICreateErr->SetHelpContext(0L);
	pICreateErr->SetSource(strSource);
	pICreateErr->SetDescription(strDescr);

	hr = pICreateErr->QueryInterface(IID_IErrorInfo, (PPVOID)&pIErr);

	if (SUCCEEDED(hr))
		{
		SetErrorInfo(0L, pIErr);
		pIErr->Release();
		}

	//SetErrorInfo holds the object's IErrorInfo
	pICreateErr->Release();
	return;
	}

/*===================================================================
ExceptionId

Raises an exception using the CreateErrorInfo API and the
ICreateErrorInfo interface.

Note that this method doesn't allow for deferred filling
of an EXCEPINFO structure.

Parameters:
	SourceID	Resource ID for the source string
	DescrID		Resource ID for the description string

Returns:
	Nothing
===================================================================*/

void ExceptionId
(
REFIID ObjID,
UINT SourceID,
UINT DescrID,
HRESULT	hrCode
)
	{
	HRESULT hr;
	ICreateErrorInfo *pICreateErr;
	IErrorInfo *pIErr;
	LANGID langID = LANG_NEUTRAL;

#ifdef USE_LOCALE
	LANGID *pLangID;
	
	pLangID = (LANGID *)TlsGetValue(g_dwTLS);

	if (NULL != pLangID)
		langID = *pLangID;
#endif

	/*
	 * Thread-safe exception handling means that we call
	 * CreateErrorInfo which gives us an ICreateErrorInfo pointer
	 * that we then use to set the error information (basically
	 * to set the fields of an EXCEPINFO structure.	We then
	 * call SetErrorInfo to attach this error to the current
	 * thread.	ITypeInfo::Invoke will look for this when it
	 * returns from whatever function was invokes by calling
	 * GetErrorInfo.
	 */

	//Not much we can do if this fails.
	if (FAILED(CreateErrorInfo(&pICreateErr)))
		return;

	/*
	 * CONSIDER: Help file and help context?
	 */
	DWORD cch;
	WCHAR strSource[MAX_RESSTRINGSIZE];
	WCHAR strDescr[MAX_RESSTRINGSIZE];
	WCHAR strHRESULTDescr[256];
	WCHAR strDescrWithHRESULT[MAX_RESSTRINGSIZE];

	pICreateErr->SetGUID(ObjID);
	pICreateErr->SetHelpFile(L"");
	pICreateErr->SetHelpContext(0L);

	cch = CwchLoadStringOfId(SourceID, strSource, MAX_RESSTRINGSIZE);
	if (cch > 0)
		pICreateErr->SetSource(strSource);
	
	cch = CwchLoadStringOfId(DescrID, strDescr, MAX_RESSTRINGSIZE);
	if (cch > 0) 
		{
		//Bug Fix 91847 use a FormatMessage() based description
		HResultToWsz(hrCode, strHRESULTDescr, 256);

		_snwprintf(strDescrWithHRESULT, MAX_RESSTRINGSIZE, strDescr, strHRESULTDescr);
		strDescrWithHRESULT[MAX_RESSTRINGSIZE - 1] = L'\0';
	
		pICreateErr->SetDescription(strDescrWithHRESULT);
		}

	hr = pICreateErr->QueryInterface(IID_IErrorInfo, (PPVOID)&pIErr);

	if (SUCCEEDED(hr))
		{
		SetErrorInfo(0L, pIErr);
		pIErr->Release();
		}

	//SetErrorInfo holds the object's IErrorInfo
	pICreateErr->Release();
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\eventlog.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: NT Event logging

File: eventlog.h

Owner: jhittle

This is the header file for eventlog.cpp
===================================================================*/

#ifndef EVENTLOG_H
#define EVENTLOG_H

#define MAX_MSG_LENGTH	512
#define MSG_ID_MASK		0x0000FFFF
#define MAX_INSERT_STRS 8

		STDAPI	RegisterEventLog( void );
		STDAPI	UnRegisterEventLog( void );
		STDAPI 	ReportAnEvent(DWORD dwIdEvent, WORD wEventlog_Type, WORD cStrings, LPCSTR *pszStrings);


extern void		MSG_DenaliStarted(void);
extern void		MSG_DenaliStoped(void);
extern void 	MSG_Error( LPCSTR );
extern void 	MSG_Error( UINT );
extern void 	MSG_Error( UINT, UINT );
extern void 	MSG_Error( UINT, UINT  UINT );
extern void 	MSG_Error( UINT, UINT, UINT, UINT );
extern void 	MSG_Warning( LPCSTR );
extern void 	MSG_Warning( UINT );
extern void 	MSG_Warning( UINT, UINT );
extern void 	MSG_Warning( UINT, UINT, UINT );
extern void 	MSG_Warning( UINT, UINT, UINT, UINT );
extern void		MSG_Warning( UINT, UINT, CHAR **);

// support function
//extern void queryEventLog(void);

#endif  //EVENTLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\denpre.h ===
#pragma warning(disable:4237)
#pragma warning(disable:4162)
#undef _WIN32_WINNT
#define _WIN32_WINNT    0x0400
#define _CRYPT32_

#include <ctype.h>
#include <stdlib.h>     // for itow
#include <string.h>
#include <mbstring.h>   // string functions (DBCS)
#include <crtdbg.h>
#include <malloc.h>
#include <time.h>
#include <stdio.h>
#include <limits.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <wtypes.h>
#include <process.h>

#include <rpc.h>
#include <rpcndr.h>
#include <ole2.h>
#include <olectl.h>
#include <oleauto.h>
#include <cguid.h>      // for GUID_NULL
#include <new.h>

#include <iis64.h>
#include <iisextp.h>

#if _IIS_6_0
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#endif

#include <dbgutil.h>

#include "except.h"
#include "isapireq.h"
#include "Denali.h"
#include "applmgr.h"
#include "sessmgr.h"
#include "hitobj.h"
#include "debug.h"
#include "error.h"
#include "eventlog.h"
#include "resource.h"
#include "compcol.h"
#include "scrptmgr.h"
#include "template.h"
#include "cachemgr.h"
#include "glob.h"
#include "scrptmgr.h"
#include "fileapp.h"
#include "util.h"
#include "txnsupp.h"
#include "fileapp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\disptch2.h ===
#ifndef __DISPTCH2_H__
#define __DISPTCH2_H__

#include "dispatch.h"

template <class T>
class ATL_NO_VTABLE CDispatchImpl : public T
{
public:
// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{
		*pctinfo = 1;
		return S_OK;
	}
	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
		return gm_tih.GetTypeInfo(itinfo, lcid, pptinfo);
	}
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{
		return gm_tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
	}
	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
		// VBScript does not distinguish between a propget and a method
		// implement that behavior for other languages.
		//
		if (wFlags & (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
			wFlags |= DISPATCH_METHOD | DISPATCH_PROPERTYGET;

		return gm_tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
                           wFlags, pdispparams, pvarResult, pexcepinfo,
                           puArgErr);
	}
protected:
	static CComTypeInfoHolder gm_tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
		return gm_tih.GetTI(lcid, ppInfo);
	}
};

// LIBID_ASPTypeLibrary is version 3.0
template <class T>
CComTypeInfoHolder CDispatchImpl<T>::gm_tih =
{&__uuidof(T), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};

typedef CDispatchImpl<IApplicationObject>   IApplicationObjectImpl;
typedef CDispatchImpl<IASPError>            IASPErrorImpl;
typedef CDispatchImpl<IReadCookie>          IReadCookieImpl;
typedef CDispatchImpl<IRequest>             IRequestImpl;
typedef CDispatchImpl<IRequestDictionary>   IRequestDictionaryImpl;
typedef CDispatchImpl<IResponse>            IResponseImpl;
typedef CDispatchImpl<IScriptingContext>    IScriptingContextImpl;
typedef CDispatchImpl<IServer>              IServerImpl;
typedef CDispatchImpl<ISessionObject>       ISessionObjectImpl;
typedef CDispatchImpl<IStringList>          IStringListImpl;
typedef CDispatchImpl<IVariantDictionary>   IVariantDictionaryImpl;
typedef CDispatchImpl<IWriteCookie>         IWriteCookieImpl;

#endif // __DISPTCH2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\except.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Exception Handling

File: Except.h

Owner: DGottner

Exception handling macros implemented via Win32 structured exceptions.

Usage:

	TRY
		<try block>

	CATCH (<exception variable>)
		<exception handler>

	END_TRY

To throw an exception use "THROW (<integer expression>)"

To set up a termination handler use:

	TRY
		<try block>

	FINALLY
		<termination handler>

	END_TRY

Rationale:
	This macro package offers a strict subset of Win32 structured exception
	handling. There is no support for exception filters (you have to rethrow
	exceptions), and no support for the resumption model of exception handling
	(though Win32 supports the resumption model)

	The purpose for these restrictions is to make it very easy to rewrite the
	exception handling macros for use with other exception throwing mechanisms.
	It would be easy to use this same interface with C++ exceptions or
	setjmp/longjmp.

	The braces with TRY, CATCH, and FINALLY are optional. Since this code is
	structured using self-bracketing constructs, the braces seem redundant.

	There is no need to declare the datatype of the <exception variable>
	because it is always an integer.
-----------------------------------------------------------------------------*/

#ifndef _EXCEPT_H
#define _EXCEPT_H

// Pragmas --------------------------------------------------------------------
//
// Turn off the "signed/unsigned conversion" warning off because it we get this
// all the time that we throw an HRESULT. (which is a harmless thing)  The
// warning is usually benign anyway.


#pragma warning(disable: 4245)


// Macros ---------------------------------------------------------------------

#define TRY	               __try {
#define CATCH(nException)  } __except(1) { DWORD nException = GetExceptionCode();
#define FINALLY            } __finally {
#define END_TRY            }

#define THROW(nException)  RaiseException(nException, 0, 0, NULL)

#endif // _EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\dispatch.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: IDispatch implementation

File: Dispatch.h

Owner: DGottner

This file contains our implementation of IDispatch
===================================================================*/

#ifndef _Dispatch_H
#define _Dispatch_H

/*
 * C D i s p a t c h
 *
 * IDispatch interface implementation for OLE objects
 *
 * This class contains the basic four IDispatch members.  The Big Three
 * (QueryInterface, AddRef, Release) are left as pure virtual, as this
 * class is designed as an intermediate class for further derivation.
 *
 * This also means that we no longer need a pointer to the controlling unknown.
 */

class CDispatch : public IDispatch
	{
private:
	const GUID *	m_pGuidDispInterface;
	ITypeLib *		m_pITypeLib;
	ITypeInfo *		m_pITINeutral;

public:

	CDispatch();
	~CDispatch();

	// Do this in Init because OLE interfaces in general do not take
	// parameters in the constructor.  This call CANNOT fail, however.
	//
	void Init(const IID &GuidDispInterface, const ITypeLib *pITypeLib = NULL);
	void SetTypeLib(ITypeLib *);

	// IDispatch members
	//
	STDMETHODIMP GetTypeInfoCount(UINT *);
	STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
	STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
	STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD,
						DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);
	};

inline void CDispatch::SetTypeLib(ITypeLib *pITypeLib) { m_pITypeLib = pITypeLib; return; };


/*
 * C S u p p o r t E r r o r I n f o
 *
 * Implemention of ISupportErrorInfo for Denali classes
 */

class CSupportErrorInfo : public ISupportErrorInfo
	{
private:
	IUnknown *	m_pUnkObj;
	IUnknown *	m_pUnkOuter;
	const GUID *m_pGuidDispInterface;

public:
	CSupportErrorInfo(void);
	CSupportErrorInfo(IUnknown *pUnkObj, IUnknown *pUnkOuter, const IID &GuidDispInterface);
	void Init(IUnknown *pUnkObj, IUnknown *pUnkOuter, const GUID &GuidDispInterface);

	// IUnknown members that delegate to m_pUnkOuter.
	//
	STDMETHODIMP		 QueryInterface(REFIID, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// ISupportErrorInfo members
	//
	STDMETHODIMP InterfaceSupportsErrorInfo(REFIID);
	};


extern void Exception(REFIID ObjID, LPOLESTR strSource, LPOLESTR strDescr);
extern void ExceptionId(REFIID ObjID, UINT SourceID, UINT DescrID, HRESULT hrCode = S_OK);

#endif /* _Dispatch_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\exec.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Executive

File:	Executor.h

Owner: DGottner

Executor API definition
-----------------------------------------------------------------------------*/

#ifndef _EXECUTOR_H
#define _EXECUTOR_H

// Includes -------------------------------------------------------------------

#include "HitObj.h"


// Forward References ---------------------------------------------------------

class CResponse;
class CRequest;
class CServer;
class CScriptingNamespace;


// Error codes ----------------------------------------------------------------

#define E_PAGE_HAS_SESSAPP_OBJECTS		0x8000E001L


// Types and Constants --------------------------------------------------------

class CIntrinsicObjects
	{
private:
    BOOL                    m_fIsChild;
	CResponse *				m_pResponse;
	CRequest *				m_pRequest;
	CServer *				m_pServer;
	CScriptingNamespace *	m_pScriptingNamespace;

public:
	inline CResponse *			PResponse() const { return m_pResponse; }
	inline CRequest *			PRequest()  const { return m_pRequest; }
	inline CServer *			PServer()   const { return m_pServer; }
	inline CScriptingNamespace *PScriptingNamespace() const { return m_pScriptingNamespace; }
	
    CIntrinsicObjects()
        {
        m_fIsChild = FALSE;
    	m_pResponse = NULL;
	    m_pRequest = NULL;
        m_pServer = NULL;
        m_pScriptingNamespace = NULL;
        }
        
    ~CIntrinsicObjects()
        {
        Cleanup();
        }

    HRESULT Prepare(CSession *pSession);
    HRESULT PrepareChild(CResponse *pResponse, CRequest *pRequest, CServer *pServer);
    HRESULT Cleanup();
	};

struct TemplateGoodies
	{
	int				iScriptBlock;
	CTemplate *		pTemplate;
	};

// CONSIDER: declare pScriptEngine to be a CActiveScriptEngine, because that's its
//           actual type.
//
struct ScriptingInfo
	{
	CHAR *				szScriptEngine;		// name of this scripting engine
	PROGLANG_ID *		pProgLangId;		// ptr to prog lang id of the script engine
	CScriptEngine *		pScriptEngine;		// pointer to scripting engine
	TemplateGoodies		LineMapInfo;		// used to map lines back to VBScript
	};

struct ActiveEngineInfo
	{
	int cEngines;           // required engines
	int cActiveEngines;     // successfully instantiated engines
	
	ScriptingInfo *rgActiveEngines; // pointer to array of engines
	
	// when only one engine rgActiveEngines points to here
	ScriptingInfo siOneActiveEngine;
	};

 
// Prototypes -----------------------------------------------------------------

HRESULT Execute
    (
    CTemplate *pTemplate,
    CHitObj *pHitObj,
    const CIntrinsicObjects &intrinsics,
    BOOL fChild = FALSE
    );

HRESULT LoadTemplate
    (
    const TCHAR *szFile,
    CHitObj *pHitObj, 
    CTemplate **ppTemplate,
	const CIntrinsicObjects &intrinsics,
	BOOL fGlobalAsa,
	BOOL *pfTemplateInCache
	);

#endif // _EXECUTOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\error.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Error handling

File: Error.cpp

Owner: AndrewS

This file contains general error reporting routines for Denali.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include <psapi.h>

#include "debugger.h"
#include "asperror.h"
#include "memchk.h"

#define DELIMITER	"~"
#define MAX_HEADERSIZE			128
#define	MAX_TEMPLATELEN			128

//The order of ErrTemplate_Index should be exactly the same order as the IDS_BROWSER_TEMPLATE 
//in the resource.h, and as the same order we output the template to the browser.
//Implementation will loop through the index and picking the string from the resource file.
//Implementation will also loop through the index and write the string to browser.
#define ErrTemplate_BEGIN			0
#define ErrTemplate_ENGINE_BEGIN	1
#define ErrTemplate_ENGINE_END		2
#define ErrTemplate_ERROR_BEGIN		3
#define ErrTemplate_ERROR_END		4
#define ErrTemplate_SHORT_BEGIN		5
#define ErrTemplate_SHORT_END		6
#define ErrTemplate_FILE_BEGIN		7
#define ErrTemplate_FILE_END		8
#define ErrTemplate_LINE_BEGIN		9
#define ErrTemplate_LINE_END		10
#define ErrTemplate_CODE_BEGIN		11
#define ErrTemplate_CODE_END		12
#define ErrTemplate_LONG_BEGIN		13
#define ErrTemplate_LONG_END		14
#define ErrTemplate_END				15
#define ErrTemplateMAX				16

const 	DWORD	dwDefaultMask				= 0x6;	// toNTLog(OFF), toIISLog(ON), toBrowser(ON)

CHAR			g_szErrTemplate[ErrTemplateMAX][MAX_TEMPLATELEN];
const	LPSTR	szErrSysTemplate[]			= { "<html><body><h1> HTTP/1.1 ",
												"</h1></body></html>"};
CErrInfo		g_ErrInfoOOM, g_ErrInfoUnExpected;	
CHAR			szIISErrorPrefix[20]; 
DWORD			cszIISErrorPrefix;
CPINFO			g_SystemCPInfo;		// global System CodePage default info.

static char s_szContentTypeTextHtml[] = "Content-type: text/html\r\n\r\n";

CHAR *SzScodeToErrorCode(HRESULT hrError);
void FreeNullifySz(CHAR **szIn);
BOOL FIsResStrFormatted(char *szIn);

/*===================================================================
FreeNullifySz

Free the memory allocated in szIn, and Nullify the szIn.
===================================================================*/
void FreeNullifySz(CHAR **szIn)
{
	if(*szIn)
		{
		free(*szIn);
		*szIn = NULL;
		}
}

/*===================================================================
ErrHandleInit

PreLoad strings for 
	1> OOM 
	2> Browser Output Template
Returns:
	HRESULT
===================================================================*/
HRESULT ErrHandleInit(void)
{
	INT	iEntry, iEntryID;
	HRESULT	hr;

	// Retrieve global system codepage and stores it.
	GetCPInfo(CP_ACP, &g_SystemCPInfo);

	//Init g_szErrTemplate
	//Loop through, and load strings from resource file.
	for (iEntry = ErrTemplate_BEGIN, iEntryID = IDS_BROWSER_TEMPLATE_BEGIN; 
			iEntry < ErrTemplateMAX; iEntry ++, iEntryID++)
		{
		CchLoadStringOfId(iEntryID, (CHAR *)g_szErrTemplate[iEntry], MAX_TEMPLATELEN);
		}

	g_ErrInfoOOM.m_szItem[Im_szErrorCode] = (CHAR *)malloc(sizeof(CHAR)*20*g_SystemCPInfo.MaxCharSize);
	g_ErrInfoOOM.m_szItem[Im_szShortDescription] = (CHAR *)malloc(sizeof(CHAR)*256*g_SystemCPInfo.MaxCharSize);
	g_ErrInfoOOM.m_szItem[Im_szLongDescription] = (CHAR *)malloc(sizeof(CHAR)*512*g_SystemCPInfo.MaxCharSize);

    if (!g_ErrInfoOOM.m_szItem[Im_szErrorCode]        ||
        !g_ErrInfoOOM.m_szItem[Im_szShortDescription] || 
        !g_ErrInfoOOM.m_szItem[Im_szLongDescription])
        {
        return E_OUTOFMEMORY;
        }
	
	hr = LoadErrResString(IDE_OOM, 
						&g_ErrInfoOOM.m_dwMask,
						g_ErrInfoOOM.m_szItem[Im_szErrorCode],
						g_ErrInfoOOM.m_szItem[Im_szShortDescription],
						g_ErrInfoOOM.m_szItem[Im_szLongDescription]);

	
	g_ErrInfoUnExpected.m_szItem[Im_szErrorCode] = (CHAR *)malloc(sizeof(CHAR)*20*g_SystemCPInfo.MaxCharSize);
	g_ErrInfoUnExpected.m_szItem[Im_szShortDescription] = (CHAR *)malloc(sizeof(CHAR)*256*g_SystemCPInfo.MaxCharSize);
	g_ErrInfoUnExpected.m_szItem[Im_szLongDescription] = (CHAR *)malloc(sizeof(CHAR)*512*g_SystemCPInfo.MaxCharSize);

    if (!g_ErrInfoUnExpected.m_szItem[Im_szErrorCode]        ||
        !g_ErrInfoUnExpected.m_szItem[Im_szShortDescription] || 
        !g_ErrInfoUnExpected.m_szItem[Im_szLongDescription])
        {
        return E_OUTOFMEMORY;
        }
	
	hr = LoadErrResString(IDE_UNEXPECTED, 
						&g_ErrInfoUnExpected.m_dwMask,
						g_ErrInfoUnExpected.m_szItem[Im_szErrorCode],
						g_ErrInfoUnExpected.m_szItem[Im_szShortDescription],
						g_ErrInfoUnExpected.m_szItem[Im_szLongDescription]);

	cszIISErrorPrefix = CchLoadStringOfId(IDS_IISLOG_PREFIX , szIISErrorPrefix, 20);
	return hr;
}
/*===================================================================
 ErrHandleUnInit

 Unit the global err-handling data.

 Free up the OOM CErrInfo.

 Side Effect:

 Free up memory.
===================================================================*/
HRESULT ErrHandleUnInit(void)
{
	FreeNullifySz((CHAR **)&g_ErrInfoOOM.m_szItem[Im_szErrorCode]);
	FreeNullifySz((CHAR **)&g_ErrInfoOOM.m_szItem[Im_szShortDescription]);
	FreeNullifySz((CHAR **)&g_ErrInfoOOM.m_szItem[Im_szLongDescription]);

	FreeNullifySz((CHAR **)&g_ErrInfoUnExpected.m_szItem[Im_szErrorCode]);
	FreeNullifySz((CHAR **)&g_ErrInfoUnExpected.m_szItem[Im_szShortDescription]);
	FreeNullifySz((CHAR **)&g_ErrInfoUnExpected.m_szItem[Im_szLongDescription]);
	return S_OK;
}
/*===================================================================
Constructor

===================================================================*/
CErrInfo::CErrInfo()
{
	for (UINT iErrInfo = 0; iErrInfo < Im_szItemMAX; iErrInfo++)
		m_szItem[iErrInfo] = NULL;
	m_bstrLineText = NULL;
	m_nColumn = -1;

	m_dwMask 	= 0;
	m_pIReq		= NULL;
	m_pHitObj	= NULL;

	m_dwHttpErrorCode = 0;
    m_dwHttpSubErrorCode = 0;
}

/*===================================================================
CErrInfo::ParseResourceString

Parse Resource String to get default mask, error type, short description, 
and long description.  

Assume resource string is proper formmated.
Format of resource string
DefaultMask~errortype~shortdescription~longdescription

In case we can not allocate szResourceString(szResourceString), we use default.
Returns:
	Nothing
===================================================================*/
HRESULT	CErrInfo::ParseResourceString(CHAR *szResourceString)
{
	CHAR 	*szToken 	= NULL;
	INT		cfield		= 0;
	INT		iItem		= 0;
	INT		iIndex		= 0;
	INT		rgErrInfoIndex[3] = {Im_szErrorCode, Im_szShortDescription, Im_szLongDescription};

	if(NULL == szResourceString)
		{
		m_dwMask = dwDefaultMask;
		for(iItem = 0, iIndex = 0; iIndex < 3; iIndex++)
			{
			iItem = rgErrInfoIndex[iIndex];
			m_szItem[iItem]	= g_ErrInfoUnExpected.m_szItem[iItem];
			}
		return S_OK;
		}
	//Mask
	szToken = (char *)_mbstok((unsigned char *)szResourceString, (unsigned char *)DELIMITER);
	if(szToken != NULL)
		{
		m_dwMask = atoi(szToken);
		cfield++;
		}
	else
		{
		m_dwMask = dwDefaultMask;
		}

	//3 String Items, ErrorCode,ShortDescription,LongDescription
	for(iItem = 0, iIndex = 0; iIndex < 3; iIndex++)
		{
		szToken = (char *)_mbstok(NULL, (unsigned char *)DELIMITER);
		iItem = rgErrInfoIndex[iIndex];
		if (szToken != NULL)
			{
			m_szItem[iItem]	= szToken;
			cfield++;
			}
		else
			{
			// Long Description is optional.
			if (Im_szLongDescription != iItem)
			    {
    			m_szItem[iItem]	= g_ErrInfoUnExpected.m_szItem[iItem];
    			}
			cfield++;
			}
		}

	//check wether we have wrong format of resource string.
	Assert(cfield == 4);

	return S_OK;
}

/*===================================================================
CErrInfo::LogError(void)

Perform all the switch logic in this functions. Send error to NT Log,
IIS Log, or Browser.
When reach this point, we assume all the strings have allocated, and will not be used after this
function.

Side effects:

Returns:
	HRESULT
===================================================================*/
HRESULT	CErrInfo::LogError(void)
{
	HRESULT	hr 		= S_OK;
	HRESULT hr_ret	= S_OK;
	UINT	iEInfo	= 0;
	BOOL	fIISLogFailed, fDupToNTLog;

#if DBG
	// Print details about the error to debug window; don't bother if
	// info is NULL (happens for things like 404 not found, etc.)

	if (m_szItem[Im_szEngine] != NULL && m_szItem[Im_szFileName] != NULL)
		{
		DBGERROR((DBG_CONTEXT, "%s error in %s at line %s\n",
								m_szItem[Im_szEngine],
								m_szItem[Im_szFileName],
								m_szItem[Im_szLineNum]? m_szItem[Im_szLineNum] : "?"));

		DBGPRINTF((DBG_CONTEXT, "  %s: %s\n",
								m_szItem[Im_szErrorCode],
								m_szItem[Im_szShortDescription]));
		}
	else
		DBGERROR((DBG_CONTEXT, "ASP Error: %s\n", m_szItem[Im_szShortDescription]));
#endif

	// Attach ASP error to HitObj (if exists and in 'executing' state)
	if (m_pHitObj && m_pHitObj->FExecuting())
	    {
	    CASPError *pASPError = new CASPError(this);
	    if (pASPError)
    	    m_pHitObj->SetASPError(pASPError);
	    }
	
	hr = LogErrortoIISLog(&fIISLogFailed, &fDupToNTLog);
	if (FAILED(hr))
		{
		hr_ret = hr;
		}

	//fIISLogFailed, if it is TRUE, then, this error was upgraded, and should be a WARNING type in 
	//NT event log.
	hr = LogErrortoNTEventLog(fIISLogFailed, fDupToNTLog);
	if (FAILED(hr))
		{
		hr_ret = hr;
		}
		
	hr = LogErrortoBrowserWrapper();
	
	if (FAILED(hr))
		{
		hr_ret = hr;
		}
		
	if (m_pHitObj)
		{
		m_pHitObj->SetExecStatus(eExecFailed);
		}
	//In case of an error, hr_ret is the last error reported from the 3 logging functions.
	return hr_ret;
	
}

/*===================================================================
CErrInfo::LogErrortoNTEventLog

Log Error/Event to NT Event Log.

Returns:
	Nothing
===================================================================*/
HRESULT CErrInfo::LogErrortoNTEventLog
(
BOOL fIISLogFailed,
BOOL fDupToNTLog
)
{
	CHAR szErrNTLogEntry[4096]; 
	CHAR szStringTemp[MAX_PATH];
	INT	cch = 0;

	if(Glob(fLogErrorRequests))
		{
		//Is the error serious enough to get into NT log
		if(ERR_FLogtoNT(m_dwMask) || fIISLogFailed || fDupToNTLog)
			{
			szErrNTLogEntry[0] = '\0';

			if (fIISLogFailed)
				{
				cch = CchLoadStringOfId(IDS_LOG_IISLOGFAILED, szStringTemp, MAX_PATH);
				strncat(szErrNTLogEntry, szStringTemp, cch);
				}
				
			if (m_szItem[Im_szFileName] != NULL)
				{
				cch = CchLoadStringOfId(IDS_LOGTOEVENTLOG_FILE, szStringTemp, MAX_PATH);
				strncat(szErrNTLogEntry, szStringTemp, cch);
				strncat(szErrNTLogEntry, m_szItem[Im_szFileName], 512);	
				}
			strncat(szErrNTLogEntry, " ", 1);

			if (m_szItem[Im_szLineNum] != NULL)
				{
				cch = CchLoadStringOfId(IDS_LOGTOEVENTLOG_LINE, szStringTemp, MAX_PATH);
				strncat(szErrNTLogEntry, szStringTemp, cch);
				strncat(szErrNTLogEntry, m_szItem[Im_szLineNum], 48);	
				}
			strncat(szErrNTLogEntry, " ", 1);
			
			//Ok, do we have something to log.
			if (m_szItem[Im_szShortDescription] != NULL)
				{
				// ShortDescription does not have ". " at the end.
				// Therefore, the next strncat need to concatenate two sentences together with
				// a period ". ".
				char szTempPeriod[] = ". ";
				
				strncat(szErrNTLogEntry, m_szItem[Im_szShortDescription], 512);
				strncat(szErrNTLogEntry, szTempPeriod, 512);
				}
			else
				{
				DWORD dwMask;
				CHAR szDenaliNotWorking[MAX_PATH];
				
				LoadErrResString(IDE_UNEXPECTED, &dwMask, NULL, szDenaliNotWorking, NULL); 
				strncat(szErrNTLogEntry, szDenaliNotWorking, strlen(szDenaliNotWorking));
				}

			//Ok, do we have something to log.
			if (m_szItem[Im_szLongDescription] != NULL)
				{
				strncat(szErrNTLogEntry, m_szItem[Im_szLongDescription], 512);
				}

			if (fIISLogFailed || fDupToNTLog)
				MSG_Warning((LPCSTR)szErrNTLogEntry);
			else
				MSG_Error((LPCSTR)szErrNTLogEntry);
			}
		}

	return S_OK;
}

/*===================================================================
CErrInfo::LogErrortoIISLog

Log Error/Event to IIS Log.

If we fail to log the message then upgrade logging to NT event Log
with entries indicate the error and the IIS log failed.

Also do the upgrade if the global setting says so.

Returns:
	Nothing
===================================================================*/
HRESULT	CErrInfo::LogErrortoIISLog
(
BOOL *pfIISLogFailed,
BOOL *pfDupToNTLog
)
{
	HRESULT			hr				= S_OK;
	const	LPSTR	szIISDelimiter	= "|";
	const	DWORD	cszIISDelimiter = 1; // strlen("|");
	const	LPSTR	szIISNoInfo		= "-";
	const	DWORD	cszIISNoInfo	= 1; // strlen("-");
	const	CHAR	chProxy			= '_';
	CIsapiReqInfo  *pIReq = NULL;

	*pfIISLogFailed = FALSE;
	*pfDupToNTLog = FALSE;
	
	if (m_pIReq == NULL && m_pHitObj == NULL)
		return S_OK;
	
	//Try to write to IISLog via pIReq->QueryPszLogData()
	if (ERR_FLogtoIIS(m_dwMask))
		{
		//get pIReq
		if (m_pHitObj)
			{
			pIReq = m_pHitObj->PIReq();
			}

		if (NULL == pIReq)
			{
			pIReq = m_pIReq;
			}

		if (pIReq == NULL)
			{
			*pfIISLogFailed = TRUE;
			return E_FAIL;
			}

		// Setup the sub-string array
		const DWORD crgsz = 3;
		LPSTR rgsz[crgsz];

		rgsz[0] = m_szItem[Im_szLineNum];
		rgsz[1] = m_szItem[Im_szErrorCode];
		rgsz[2] = m_szItem[Im_szShortDescription];

		// Allocate the log entry string
		CHAR *szLogEntry = NULL;
		DWORD cszLogEntry = (cszIISDelimiter * crgsz) + 1;
		DWORD dwIndex;

		for (dwIndex = 0; dwIndex < crgsz; dwIndex++) 
			{
			if (rgsz[dwIndex]) 
				cszLogEntry += strlen(rgsz[dwIndex]);
			else
				cszLogEntry += cszIISNoInfo;
			}

		szLogEntry = new CHAR[cszLogEntry];
		if (NULL == szLogEntry) {
			return E_OUTOFMEMORY;
		}

		// Copy the entry, proxy bad characters
		CHAR *szSource = NULL;
		CHAR *szDest = szLogEntry;

		// Start with a delimiter to separate us from
        // the request query
        memcpy(szDest, szIISDelimiter, cszIISDelimiter);
		szDest += cszIISDelimiter;
 
		for (dwIndex = 0; dwIndex < crgsz; dwIndex++)
			{
			szSource = rgsz[dwIndex];
			if (szSource) 
				{
				while (*szSource) 
					{
					if (isleadbyte(*szSource)) 
						{
						*szDest++ = *szSource++;
						*szDest++ = *szSource++;
						}
					else if ((*szSource == ',') ||
							 (*szSource == ' ') ||
							 (*szSource == '\r') ||
							 (*szSource == '\n') ||
							 (*szSource == '\"'))
						{
						*szDest++ = chProxy;
						szSource++;
						}
					else 
						*szDest++ = *szSource++;
					}
				}
			else
				{
				memcpy(szDest, szIISNoInfo, cszIISNoInfo);
				szDest += cszIISNoInfo;
				}

			if ((dwIndex + 1) < crgsz)
				{
				// Another sub-string comming, use a delimiter
				memcpy(szDest, szIISDelimiter, cszIISDelimiter);
				szDest += cszIISDelimiter;
				}
			}
		*szDest = '\0';
		
		// Log it		
		BOOL fResult = TRUE;

        fResult = SUCCEEDED(pIReq->AppendLogParameter(szLogEntry));

		// Set "500" error in log.
		if (pIReq->ECB()->dwHttpStatusCode == 200)   // error content sent, OK, but really an error
			pIReq->ECB()->dwHttpStatusCode = 500;

		// Release log string
		delete [] szLogEntry;
			
		// If any error occurred while writing to log, upgrade to NT Event log
		if (!fResult)
			{
			m_dwMask = ERR_SetLogtoNT(m_dwMask);
			*pfIISLogFailed = TRUE;
			}
			
		// Even if successful we might still want the message
		// in the NT event log if the global setting to do so is on.
	    else if (Glob(fDupIISLogToNTLog))
	        {
	        if (!ERR_FLogtoNT(m_dwMask))
	            {
                // Need to remember the flag in order to insert
                // the upgraded IIS log error as NT log warnings.
                // The errors already destined for NT log should
                // stay as errors.
    			m_dwMask = ERR_SetLogtoNT(m_dwMask);
    			*pfDupToNTLog = TRUE;
    			}
			}
			
		hr = S_OK;
		}
		
	return(hr);
}

/*===================================================================
CErrInfo::LogErrortoBrowserWrapper

Just a Wrapper around Log Error/Event to Browser.  

In this function, pIReq or pResponse is resolved.

NOTE:
Unfortunately, this function can not tell pResponse is inited or not.
In case when pResponse has not been inited, pResponse is not NULL, but things
in pResponse are invalid.
Therefore, caller need to provide pIReq in case where pResponse has not been inited. 

Returns:
	HRESULT
===================================================================*/
HRESULT	CErrInfo::LogErrortoBrowserWrapper()
{
	HRESULT hr = S_OK;
	
	// Must have passed in either an CIsapiReqInfo or a HITOBJ.  Otherwise, there is nothing we can do.
	if (m_pIReq == NULL && m_pHitObj == NULL)
		{
		Assert(FALSE);
		return E_FAIL;
		}

    // Remember response object if any	    
    CResponse *pResponse = m_pHitObj ? m_pHitObj->PResponse() : NULL;

	CIsapiReqInfo *pIReq = 
	    (m_pHitObj && pResponse && m_pHitObj->PIReq()) ? 
	        m_pHitObj->PIReq() : m_pIReq;
	if (!pIReq)
	    return E_FAIL;

    // Do custom errors only if response headers aren't written already
    // ALSO: No custom error if called from global.asa, with intrinsic objects hidden.
    //   (Appln_OnStart & Session_OnStart)
    //
    // for errors in Appln_OnEnd or Session_OnEnd, these are not browser requests
    // and so pResponse == NULL in this case.

    if (!pResponse || !pResponse->FHeadersWritten())
        {
        BOOL fIntrinsicsWereHidden = FALSE;
        if (m_pHitObj)
       	    {
       	    fIntrinsicsWereHidden = m_pHitObj->FRequestAndResponseIntrinsicsHidden();
       	    m_pHitObj->UnHideRequestAndResponseIntrinsics();
       	    }

        BOOL fCustom = FALSE;
        hr = LogCustomErrortoBrowser(pIReq, &fCustom);

        if (fIntrinsicsWereHidden)
        	m_pHitObj->HideRequestAndResponseIntrinsics();

        if (fCustom)
            return hr;
        }

	// No custom error - do regular error from this object

	if (m_szItem[Im_szHeader])
		{
	    BOOL fRet = pIReq->SendHeader
	        (
			m_szItem[Im_szHeader],
			strlen(m_szItem[Im_szHeader]) + 1,
			s_szContentTypeTextHtml,
			sizeof(s_szContentTypeTextHtml),
			FALSE
			);

        if (!fRet)					
			return E_FAIL;
		}

	if (pResponse)
		hr = LogErrortoBrowser(pResponse);
	else
		hr = LogErrortoBrowser(pIReq);
		
	return hr;
}

/*===================================================================
CErrInfo::LogCustomErrortoBrowser

Called by LogErrortoBrowserWrapper.  

Parameters
    pIReq
    pfCustomErrorProcessed

Returns:
	HRESULT
===================================================================*/
HRESULT	CErrInfo::LogCustomErrortoBrowser
(
CIsapiReqInfo *pIReq,
BOOL *pfCustomErrorProcessed
)
    {
    // Custom errors when HttpErrorCode is specified (404 or 500),
    // or '500;100' ASP scripting error case
    BOOL fTryErrorTransfer = FALSE;
    DWORD dwCode, dwSubCode;

    if (m_dwHttpErrorCode == 404 || m_dwHttpErrorCode == 500 || m_dwHttpErrorCode == 401)
        {
        dwCode = m_dwHttpErrorCode;
        dwSubCode = m_dwHttpSubErrorCode;
        }
    else if (m_dwHttpErrorCode == 0 && m_pHitObj &&
             m_pHitObj->FHasASPError() &&               // there's an error on this page
             m_pHitObj->FExecuting() &&                 // while executing
             !m_pHitObj->FInTransferOnError() &&        // not inside transfer-on-error already
             m_pHitObj->PAppln() && m_pHitObj->PResponse() && m_pHitObj->PServer() &&
			 m_pHitObj->PAppln()->QueryAppConfig()->pCLSIDDefaultEngine())   // engine in the registry is valid
        {
        dwCode = 500;
        dwSubCode = 100;
        fTryErrorTransfer = TRUE;
        }
    else
        {
        // no need to try
        *pfCustomErrorProcessed = FALSE;
        return S_OK;
        }

    // Get custom error from W3SVC
        

    STACK_BUFFER( tempParamBuf, MAX_PATH );
    TCHAR *szBuf = (TCHAR *)tempParamBuf.QueryPtr();
    DWORD dwLen = MAX_PATH;
    BOOL fIsFileError;
    
    BOOL fRet = pIReq->GetCustomError(dwCode, dwSubCode, dwLen, szBuf, &dwLen, &fIsFileError);
    if (!fRet && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        if (tempParamBuf.Resize(dwLen) == TRUE) {
            szBuf = (TCHAR *)tempParamBuf.QueryPtr();
            fRet = pIReq->GetCustomError(dwCode, dwSubCode, dwLen, szBuf, &dwLen, &fIsFileError);
        }
    }
    if (fRet)
        {
        if (fIsFileError)
            {
            // Verify that the error file can be read
            if (FAILED(AspGetFileAttributes(szBuf)))
                fRet = FALSE;
            }
        else
            {
            // Avoid circular client redirections
            // (check if the current URL is the same as error URL
            if (_tcsicmp(szBuf, pIReq->QueryPszPathInfo()) == 0)
                fRet = FALSE;
            }
        }
    if (!fRet)
        {
        // no custom error found
        *pfCustomErrorProcessed = FALSE;
        return S_OK;
        }

    // There's a custom error - use it

    HRESULT hr = S_OK;
        
    if (fIsFileError)
        {
        // in case of file errors mime type follows the file path
        // in the returned buffer
        hr = WriteCustomFileError(pIReq, szBuf, szBuf+_tcslen(szBuf)+1);
        }
    else if (fTryErrorTransfer)
        {
        // transfer to URL 

        // need to Map Path first
    	TCHAR szTemplate[MAX_PATH];
        WCHAR   *pErrorURL;
#if UNICODE
        pErrorURL = szBuf;
#else
        CMBCSToWChar    convStr;
        if (FAILED(convStr.Init(szBuf))) {
            *pfCustomErrorProcessed = FALSE;
            return S_OK;
        }
        pErrorURL = convStr.GetString();
#endif

        if (FAILED(m_pHitObj->PServer()->MapPathInternal(0, pErrorURL, szTemplate))) {
            // could use custom error
            *pfCustomErrorProcessed = FALSE;
            return S_OK;
        }
        Normalize(szTemplate);

        // do the transfer
        m_pHitObj->SetInTransferOnError();
        hr = m_pHitObj->ExecuteChildRequest(TRUE, szTemplate, szBuf);

        if (FAILED(hr))
            {
            // error while reporting error -- report both
            LogErrortoBrowser(m_pHitObj->PResponse());
            }
        }
    else
        {
        // client redirect to URL
        hr = WriteCustomURLError(pIReq, szBuf);
        }

    if (fIsFileError || !fTryErrorTransfer)
        {
        // suppress all output through intrinsic
        if (m_pHitObj && m_pHitObj->PResponse())
             m_pHitObj->PResponse()->SetIgnoreWrites();
        }

    *pfCustomErrorProcessed = TRUE;
    return hr;
    }

/*===================================================================
CErrInfo::WriteCustomFileError

Dumps the content of a custom error file to the browser

Returns:
	NONE.
===================================================================*/
HRESULT CErrInfo::WriteCustomFileError
(
CIsapiReqInfo   *pIReq,
TCHAR *szPath, 
TCHAR *szMimeType
)
{
    HRESULT hr = S_OK;
    char *szStatus = m_szItem[Im_szHeader];
    char *pszMBCSMimeType;

#if UNICODE
    CWCharToMBCS    convStr;
    
    if (FAILED(hr = convStr.Init(szMimeType, 65001))) {
        return hr;
    }
    else {
        pszMBCSMimeType = convStr.GetString();
    }
#else
    pszMBCSMimeType = szMimeType;
#endif

    if (szStatus == NULL) {
        // no status set -- get it from the response object if available
        CResponse *pResponse = m_pHitObj ? m_pHitObj->PResponse() : NULL;
        if (pResponse)
            szStatus = pResponse->PCustomStatus();
    }
    
    hr = CResponse::SyncWriteFile(pIReq, 
                                  szPath, 
                                  pszMBCSMimeType, 
                                  szStatus);        // NULL is OK - means 200

    return hr;
}
    
/*===================================================================
CErrInfo::WriteCustomURLError

Sends client redirect to the custom URL error

Returns:
	NONE.
===================================================================*/
HRESULT CErrInfo::WriteCustomURLError(
CIsapiReqInfo   *pIReq, 
TCHAR           *sztURL)
{
    // Header is
    // Location: redirect_URL?code;http://original_url

    HRESULT         hr = S_OK;
    char            *szURL;
#if UNICODE
    CWCharToMBCS    convRedirURL;

    if (FAILED(hr = convRedirURL.Init(sztURL,65001))) {
        return hr;
    }

    szURL = convRedirURL.GetString();
#else
    szURL = sztURL;
#endif

    // code
    char szCode[8];
    if (m_dwHttpErrorCode > 0 && m_dwHttpErrorCode < 1000)
        ltoa(m_dwHttpErrorCode, szCode, 10);
    else
        return E_FAIL;

    // get the current URL
    char szServer[128];
    DWORD dwServerSize = sizeof(szServer);

    STACK_BUFFER( tempHeader, 256 );
    if (!pIReq->GetServerVariableA("SERVER_NAME", szServer, &dwServerSize))
        return E_FAIL; // shouldn't happen
    char  *szOrigURL;
#if UNICODE
    CWCharToMBCS    convOrigStr;

    if (FAILED(hr = convOrigStr.Init(pIReq->QueryPszPathInfo(), 65001))) {
        return hr;
    }

    szOrigURL = convOrigStr.GetString();
#else
    szOrigURL = pIReq->QueryPszPathInfo();
#endif

    // estimate of the length
    DWORD cchHeaderMax = strlen(szURL) 
                       + strlen(szServer)
                       + strlen(szOrigURL)
                       + 80;    // decorations

    if (tempHeader.Resize(cchHeaderMax) == FALSE) {
        return E_OUTOFMEMORY;
    }
    char *szHeader = (char *)tempHeader.QueryPtr();

    // construct the redirection header
    char *szBuf = szHeader;
    szBuf = strcpyExA(szBuf, "Location: ");
    szBuf = strcpyExA(szBuf, szURL);
    szBuf = strcpyExA(szBuf, "?");
    szBuf = strcpyExA(szBuf, szCode);
    szBuf = strcpyExA(szBuf, ";http://");
    szBuf = strcpyExA(szBuf, szServer);
    szBuf = strcpyExA(szBuf, szOrigURL);
    szBuf = strcpyExA(szBuf, "\r\n\r\n");
    Assert(strlen(szHeader) < cchHeaderMax);

    // set the status
    static char s_szRedirected[] = "302 Object moved";
	pIReq->SetDwHttpStatusCode(302);

    // send the header
    BOOL fRet = pIReq->SendHeader(s_szRedirected,
		                          sizeof(s_szRedirected),
		                          szHeader,
		                          strlen(szHeader) + 1,
		                          FALSE);
    
    return (fRet ? S_OK : E_FAIL);
}

/*===================================================================
CErrInfo::WriteHTMLEncodedErrToBrowser

Log Error/Event to Browser with HTMLEncoded via either pResponse or pIReq.

Either pResponse or pIReq must be valid.

Returns:
	NONE.
===================================================================*/
void CErrInfo::WriteHTMLEncodedErrToBrowser
    (
    const CHAR *StrIn, 
    CResponse *pResponse, 
    CIsapiReqInfo   *pIReq
    )
{
CHAR szHTMLEncoded[2*MAX_RESSTRINGSIZE];
LPSTR pszHTMLEncoded = NULL;
LPSTR pStartszHTMLEncoded = NULL;
DWORD	nszHTMLEncoded = 0;
BOOL fStrAllocated = FALSE;

	nszHTMLEncoded = HTMLEncodeLen(StrIn, CP_ACP, FALSE);
	

	if (nszHTMLEncoded > 0)
		{
		if (nszHTMLEncoded > 2 * MAX_RESSTRINGSIZE)
			{
			pszHTMLEncoded = new char[nszHTMLEncoded+2]; 
			if (pszHTMLEncoded)
				{
				fStrAllocated = TRUE;
				}
			else
				{
				HandleOOMError(NULL, NULL);
				return;
				}
			}
		else
			pszHTMLEncoded = &szHTMLEncoded[0];

		pStartszHTMLEncoded = pszHTMLEncoded;
		pszHTMLEncoded = HTMLEncode(pszHTMLEncoded, StrIn, CP_ACP, FALSE);
		
		nszHTMLEncoded--;		// take out the count for '\0'.
		if (pResponse)
			pResponse->WriteSz((CHAR *)pStartszHTMLEncoded, nszHTMLEncoded);
		else
			CResponse::SyncWrite(pIReq, pStartszHTMLEncoded, nszHTMLEncoded);
		}

	if (fStrAllocated)
		delete [] pStartszHTMLEncoded;

	return;
}

/*===================================================================
CErrInfo::LogErrortoBrowser

Log Error/Event to Browser via pResponse.  

We will output 
	1> default ScriptErrorMessage or
	2> Error Info/Default Template/has long description available or
	3> Error Info/Default Template/no long description available

Returns:
	HRESULT
===================================================================*/
HRESULT CErrInfo::LogErrortoBrowser(CResponse *pResponse)
{
	INT	cch 	= 0;
	INT	cLine	= 0;
	INT iErrTemplate = 0;
	
	Assert(NULL != pResponse);

	// When the error code is zero, then it's coming from a 500 error code path.
	//   (HandleSysError presets the code to 404 or 204.)
	//
	if (!pResponse->FHeadersWritten() && (m_dwHttpErrorCode == 500 || m_dwHttpErrorCode == 0))
		pResponse->put_Status(L"500 Internal Server Error");

	if(ERR_FIsSysFormat(m_dwMask))
		{
		DWORD	cChHeader	= strlen(szErrSysTemplate[0]);
		DWORD	cChTail		= strlen(szErrSysTemplate[1]);
			
		pResponse->WriteSz((CHAR *)szErrSysTemplate[0], cChHeader);
		WriteHTMLEncodedErrToBrowser((CHAR *)m_szItem[Im_szShortDescription], pResponse, NULL);
		pResponse->WriteSz((CHAR *)szErrSysTemplate[1], cChTail);
		return S_OK;
		}
		
	if (!(m_pHitObj->QueryAppConfig())->fScriptErrorsSentToBrowser())
		{
        cch = strlen((CHAR *)((m_pHitObj->QueryAppConfig())->szScriptErrorMessage()));
		GlobStringUseLock();
        pResponse->WriteSz((CHAR *)((m_pHitObj->QueryAppConfig())->szScriptErrorMessage()),cch);
		GlobStringUseUnLock();
		}
	else
		{
		// line 0 is the begin line.
		cch = strlen((CHAR *)g_szErrTemplate[ErrTemplate_BEGIN]);
		pResponse->WriteSz((CHAR *)g_szErrTemplate[ErrTemplate_BEGIN], cch);

		//7 standard items(file, line, engine, error#, short description, code, long description) 
		//If any info missing(is NULL), we skip.
		for (cLine = 0; cLine < 7; cLine++)
			{
			if (NULL == m_szItem[cLine])
	  	 		continue;
			
			iErrTemplate = cLine * 2 + 1;
			/*	BUG 78782 (IIS Active) */
	  		//WriteHTMLEncodedErrToBrowser((CHAR *)g_szErrTemplate[iErrTemplate], pResponse, NULL);
	  		pResponse->WriteSz((CHAR *)g_szErrTemplate[iErrTemplate], strlen((CHAR *)g_szErrTemplate[iErrTemplate]));
	  		
	  		
	  	 	WriteHTMLEncodedErrToBrowser((CHAR *)m_szItem[cLine], pResponse, NULL);
	  	 	
	  	 	iErrTemplate++;
	  	 	/*	BUG 78782 (IIS Active) */
	  		//WriteHTMLEncodedErrToBrowser((CHAR *)g_szErrTemplate[iErrTemplate], pResponse, NULL);
	  		pResponse->WriteSz((CHAR *)g_szErrTemplate[iErrTemplate], strlen((CHAR *)g_szErrTemplate[iErrTemplate]));
	  	 	}

		//ouput the end line
		cch = strlen((CHAR *)g_szErrTemplate[ErrTemplate_END]);
		pResponse->WriteSz((CHAR *)g_szErrTemplate[ErrTemplate_END], cch);
		}	
	return S_OK;
}

/*===================================================================
CErrInfo::LogErrortoBrowser

Log Error/Event to Browser via pIReq.  

We will output 
	1> default ScriptErrorMessage or
	2> Error Info/Default Template/has long description available or
	3> Error Info/Default Template/no long description available

Returns:
	HRESULT
===================================================================*/
HRESULT CErrInfo::LogErrortoBrowser(CIsapiReqInfo  *pIReq)
{
	INT			cLine	= 0;
	INT			iErrTemplate 	= 0;
	
	Assert(NULL != pIReq);

	//HTTP type error, 204, 404, 500
	//mimic IIS error reporting
	//And send out the header.
	if(ERR_FIsSysFormat(m_dwMask))
		{
		CResponse::SyncWrite(pIReq, szErrSysTemplate[0]);
		WriteHTMLEncodedErrToBrowser((CHAR *)m_szItem[Im_szShortDescription], NULL, pIReq);
		CResponse::SyncWrite(pIReq, szErrSysTemplate[1]);
		return S_OK;
		}

	if (!(m_pHitObj->QueryAppConfig())->fScriptErrorsSentToBrowser())
		{
		GlobStringUseLock();
        CResponse::SyncWrite(pIReq, (CHAR *)((m_pHitObj->QueryAppConfig())->szScriptErrorMessage()));
		GlobStringUseUnLock();
		}
	else
		{
		// line 0 is the begin line.
		CResponse::SyncWrite(pIReq, g_szErrTemplate[ErrTemplate_BEGIN]);

		//7 standard items(file, line, engine, error#, short description, code, long description) 
		//If any info missing(is NULL), we skip.
		for (cLine = 0; cLine < 5; cLine++)
			{
			if (NULL == m_szItem[cLine])
	  	 		continue;
			
			iErrTemplate = cLine * 2 + 1;
	  		WriteHTMLEncodedErrToBrowser((CHAR *)g_szErrTemplate[iErrTemplate], NULL, pIReq);
	  		
	  	 	WriteHTMLEncodedErrToBrowser((CHAR *)m_szItem[cLine], NULL, pIReq);

	  	 	iErrTemplate++;
	  		WriteHTMLEncodedErrToBrowser((CHAR *)g_szErrTemplate[iErrTemplate], NULL, pIReq);
	  	 	}

		//ouput the end line
		CResponse::SyncWrite(pIReq, g_szErrTemplate[ErrTemplate_END]);
		}

	return S_OK;
}


/*===================================================================
CchLoadStringOfId

Loads a string from the string table.

Returns:
	sz - the returned string
	INT - 0 if string load failed, otherwise number of characters loaded.
===================================================================*/
INT CchLoadStringOfId
(
UINT id,
CHAR *sz,
INT cchMax
)
	{
	INT cchRet;
	
	// The handle to the DLL instance should have been set up when we were loaded
	if (g_hinstDLL == (HINSTANCE)0)
		{
		// Totally bogus
		Assert(FALSE);
		return(0);
		}

	cchRet = LoadStringA(g_hinstDLL, id, sz, cchMax);

    IF_DEBUG(ERROR)
        {
    	// For debugging purposes, if we get back 0, get the last error info
    	if (cchRet == 0)
    		{
    		DWORD err = GetLastError();
    		DBGERROR((DBG_CONTEXT, "Failed to load string resource.  Id = %d, error = %d\n", id, err));
    		DBG_ASSERT(FALSE);
    		}
		}

	return(cchRet);
	}


/*===================================================================
CwchLoadStringOfId

Loads a string from the string table as a UNICODE string.

Returns:
	sz - the returned string
	INT - 0 if string load failed, otherwise number of characters loaded.
===================================================================*/
INT CwchLoadStringOfId
(
UINT id,
WCHAR *sz,
INT cchMax
)
	{
	INT cchRet;
	
	// The handle to the DLL instance should have been set up when we were loaded
	if (g_hinstDLL == (HINSTANCE)0)
		{
		// Totally bogus
		Assert(FALSE);
		return(0);
		}

	if (FIsWinNT())
		{
		cchRet = LoadStringW(g_hinstDLL, id, sz, cchMax);
		}
	else
		{
		//LoadStringW returns ERROR_CALL_NOT_IMPLEMENTED in Win95, work around
		CHAR szTemp[MAX_RESSTRINGSIZE];
		cchRet = CchLoadStringOfId(id, szTemp, cchMax);
		if (cchRet > 0)
			{
            CMBCSToWChar    convStr;
            convStr.Init(szTemp);
			sz = convStr.GetString(TRUE);
            cchRet = convStr.GetStringLen();
			}
		}

    IF_DEBUG(ERROR)
        {
    	// For debugging purposes, if we get back 0, get the last error info
    	if (cchRet == 0)
    		{
    		DWORD err = GetLastError();
    		DBGERROR((DBG_CONTEXT, "Failed to load string resource.  Id = %d, error = %d\n", id, err));
    		DBG_ASSERT(FALSE);
    		}
		}

	return(cchRet);
	}

/*===================================================================
HandleSysError

Dumps the error to the client and/or to the log
Loads a string from the string table as a UNICODE string.

Returns:
	sz - the returned string
	INT - 0 if string load failed, otherwise number of characters loaded.
===================================================================*/
HRESULT HandleSysError(	DWORD dwHttpError,
                        DWORD dwHttpSubError,
                        UINT ErrorID,
						UINT ErrorHeaderID,
						CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj)
{
	CErrInfo	SysErrInfo;
	CErrInfo	*pErrInfo;
	CHAR		szResourceStr[MAX_RESSTRINGSIZE];
	CHAR		szHeader[MAX_HEADERSIZE];
	INT			cch;
	
	pErrInfo = (CErrInfo *)&SysErrInfo;

	pErrInfo->m_pHitObj = pHitObj;
	pErrInfo->m_pIReq	= pIReq;
	if (ErrorHeaderID != 0)
		{
		cch = CchLoadStringOfId(ErrorHeaderID, szHeader, MAX_HEADERSIZE);
		pErrInfo->m_szItem[Im_szHeader] = szHeader;
		}
	else
		{
		pErrInfo->m_szItem[Im_szHeader] = NULL;
		}
		
	if (ErrorID != 0)
		cch = CchLoadStringOfId(ErrorID, szResourceStr, MAX_RESSTRINGSIZE);
		
	pErrInfo->ParseResourceString(szResourceStr);

	pErrInfo->m_dwMask = ERR_SetSysFormat(pErrInfo->m_dwMask);

    pErrInfo->m_dwHttpErrorCode = dwHttpError;
    pErrInfo->m_dwHttpSubErrorCode = dwHttpSubError;
	
	pErrInfo->LogError();

	return S_OK;
}

/*===================================================================
Handle500Error

Based on ErrorID determines headerID, code, sub-code, and
calls HandleSysError()

Returns:
	HRESULT
===================================================================*/
HRESULT Handle500Error( UINT errorId, 
                        CIsapiReqInfo   *pIReq)
{
    UINT  headerId;
    DWORD dwHttpSubError;
    
    switch (errorId)
        {
        case IDE_SERVER_TOO_BUSY:
            headerId = IDH_500_SERVER_ERROR;
    		dwHttpSubError = SUBERRORCODE500_SERVER_TOO_BUSY;
            break;

        case IDE_SERVER_SHUTTING_DOWN:
            headerId = IDH_500_SERVER_ERROR;
       		dwHttpSubError = SUBERRORCODE500_SHUTTING_DOWN;
       		break;
        
        case IDE_GLOBAL_ASA_CHANGED:
            headerId = IDH_500_SERVER_ERROR;
            dwHttpSubError = SUBERRORCODE500_RESTARTING_APP;    
            break;
            
        case IDE_INVALID_APPLICATION:
    		headerId = IDH_500_SERVER_ERROR;
	    	dwHttpSubError = SUBERRORCODE500_INVALID_APP;
	    	break;

        case IDE_GLOBAL_ASA_FORBIDDEN:
    		headerId = IDH_500_SERVER_ERROR;
	    	dwHttpSubError = SUBERRORCODE500_GLOBALASA_FORBIDDEN;
	    	break;

        default:
            headerId = IDH_500_SERVER_ERROR;
    		dwHttpSubError = SUBERRORCODE500_SERVER_ERROR;
    		break;
		}

    pIReq->SetDwHttpStatusCode(500);
    return HandleSysError(500, dwHttpSubError, errorId, headerId, pIReq, NULL);
}

/*===================================================================
HandleOOMError

Handle OOM error with special care, because we can not do any dynamic allocation.

if pIReq or pHitObj is NULL, nothing will be reported to browser

Returns:
	Nothing
===================================================================*/
HRESULT HandleOOMError(	CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj)
{
	CErrInfo OOMErrInfo;
	CErrInfo *pErrInfo;

	pErrInfo = (CErrInfo *)&OOMErrInfo;

	pErrInfo->m_pIReq 	= pIReq;
	pErrInfo->m_pHitObj	= pHitObj;
	pErrInfo->m_dwMask	= g_ErrInfoOOM.m_dwMask;
	pErrInfo->m_szItem[Im_szErrorCode] = g_ErrInfoOOM.m_szItem[Im_szErrorCode];
	pErrInfo->m_szItem[Im_szShortDescription] = g_ErrInfoOOM.m_szItem[Im_szShortDescription];
	pErrInfo->m_szItem[Im_szLongDescription] = g_ErrInfoOOM.m_szItem[Im_szLongDescription];

	pErrInfo->LogError();

	return S_OK;
}
/*===================================================================
HandleError

Handle reporting of errors given ErrorID, FileName, and LineNum.

If Caller provide ErrCode or LongDescription, the default value will be overwriten.

Strings passed in will be freed.  That is, consider the function as a sink.  Caller
should not use strings after the call.

Returns:
	Nothing
===================================================================*/
HRESULT	HandleError(	UINT ErrorID,
						CHAR *szFileName, 
						CHAR *szLineNum, 
						CHAR *szEngine,
						CHAR *szErrCode,
						CHAR *szLongDes,
						CIsapiReqInfo   *pIReq, 
						CHitObj *pHitObj,
                        va_list *pArgs)
{
	CErrInfo	SysErrInfo;
	CErrInfo	*pErrInfo;
	CHAR		szResourceStr[MAX_RESSTRINGSIZE];
    CHAR        szUnformattedResStr[MAX_RESSTRINGSIZE];
	HRESULT		hr = S_OK;

	pErrInfo = (CErrInfo *)&SysErrInfo;

	pErrInfo->m_szItem[Im_szFileName] 	= szFileName;
	pErrInfo->m_szItem[Im_szLineNum]	= szLineNum;
	pErrInfo->m_szItem[Im_szEngine]		= szEngine;

	pErrInfo->m_pHitObj	= pHitObj;
	pErrInfo->m_pIReq	= pIReq;

	//Load resource string according to the resource ID.

    if (pArgs) {
	    CchLoadStringOfId(ErrorID, szUnformattedResStr, MAX_RESSTRINGSIZE);
        vsprintf(szResourceStr, szUnformattedResStr, *pArgs);
    }
    else {
	    CchLoadStringOfId(ErrorID, szResourceStr, MAX_RESSTRINGSIZE);
    }

	pErrInfo->ParseResourceString(szResourceStr);

	//NOTE: if ErrorCode/LongDescription not NULL, caller want to overwrite.
	if (szErrCode)
		{
		pErrInfo->m_szItem[Im_szErrorCode] = szErrCode;
		}
	if(szLongDes)
		{
		pErrInfo->m_szItem[Im_szLongDescription] = szLongDes;
		}
		
	hr = pErrInfo->LogError();

	//free up the inputs
	FreeNullifySz((CHAR **)&szFileName);
	FreeNullifySz((CHAR **)&szLineNum);
	FreeNullifySz((CHAR **)&szEngine);
	FreeNullifySz((CHAR **)&szErrCode);
	FreeNullifySz((CHAR **)&szLongDes);
	
	return hr;
}
/*===================================================================
HandleError

Handle reporting of errors given all the info.

This is basically a cover over HandleErrorSz which called from OnScriptError.

Strings passed in will be freed.  That is, consider the function as a sink.  Caller
should not use strings after the call.

Returns:
	Nothing
===================================================================*/
HRESULT HandleError(	CHAR *szShortDes,
						CHAR *szLongDes,
						DWORD dwMask,
						CHAR *szFileName, 
						CHAR *szLineNum, 
						CHAR *szEngine, 
						CHAR *szErrCode,
						CIsapiReqInfo   *pIReq, 
						CHitObj *pHitObj)
{
	CErrInfo	SysErrInfo;
	CErrInfo	*pErrInfo;
	HRESULT		hr = S_OK;
	
	pErrInfo = (CErrInfo *)&SysErrInfo;
		
	pErrInfo->m_dwMask 					= dwMask;

	pErrInfo->m_szItem[Im_szHeader]		= NULL;		// Caller has already sent out header
	pErrInfo->m_szItem[Im_szFileName] 	= szFileName;
	pErrInfo->m_szItem[Im_szLineNum]	= szLineNum;
	pErrInfo->m_szItem[Im_szEngine]		= szEngine;
	pErrInfo->m_szItem[Im_szErrorCode]	= szErrCode;
	pErrInfo->m_szItem[Im_szShortDescription]	= szShortDes;
	pErrInfo->m_szItem[Im_szLongDescription]	= szLongDes;
	
	pErrInfo->m_pHitObj	= pHitObj;
	pErrInfo->m_pIReq	= pIReq;

	hr = pErrInfo->LogError();	

	//free up the inputs
	FreeNullifySz((CHAR **)&szFileName);
	FreeNullifySz((CHAR **)&szLineNum);
	FreeNullifySz((CHAR **)&szEngine);
	FreeNullifySz((CHAR **)&szErrCode);
	FreeNullifySz((CHAR **)&szShortDes);
	FreeNullifySz((CHAR **)&szLongDes);
		
	return hr;
}
/*===================================================================
HandleError

Handle reporting of errors given the IActiveScriptError and PFNLINEMAP.

This is basically a cover over HandleErrorSz which called from OnScriptError.

Returns:
	Nothing
===================================================================*/
HRESULT HandleError( IActiveScriptError *pscripterror,
					 CTemplate *pTemplate,
					 DWORD dwEngineID,
					 CIsapiReqInfo  *pIReq, 
					 CHitObj *pHitObj )
	{
	UINT        cchBuf = 0;
	CHAR        *szOrigin = NULL;
	CHAR        *szDesc = NULL;
	CHAR        *szLine = NULL;
	CHAR        *szPrefix = NULL;
	UINT        cchOrigin = 0;
	UINT        cchDesc = 0;
	UINT        cchLineNum = 0;
	UINT        cchLine = 0;
	EXCEPINFO   excepinfo = {0};
	CHAR        *szResult = NULL;
	BSTR        bstrLine = NULL;
	HRESULT     hr;
	DWORD       dwSourceContext = 0;		// Don't trust this one
	ULONG       ulLineError = 0;
	BOOLB       fGuessedLine = FALSE;		// see bug 379
	CHAR        *szLineNumT = NULL;
	LPTSTR      szPathInfo = NULL;
	LPTSTR      szPathTranslated = NULL;
	LONG        ichError = -1;
	CErrInfo	SysErrInfo;
	CErrInfo	*pErrInfo;
    wchar_t     wszUnknownException[128];
    wchar_t     wszUnknownEngine[32];
    CWCharToMBCS  convStr;
	
	pErrInfo = (CErrInfo *)&SysErrInfo;

	pErrInfo->m_pIReq 	= pIReq;
	pErrInfo->m_pHitObj	= pHitObj;

	if (pscripterror == NULL)
		return E_POINTER;

	hr = pscripterror->GetExceptionInfo(&excepinfo);
	if (FAILED(hr))
		goto LExit;

	// bug 99543 If details are deferrred, use the callback to get
	// detailed information.
	if (excepinfo.pfnDeferredFillIn)
		excepinfo.pfnDeferredFillIn(&excepinfo);

	hr = pscripterror->GetSourcePosition(&dwSourceContext, &ulLineError, &ichError);
	if (FAILED(hr))
		goto LExit;

	// Intentionally ignore any error
	(VOID)pscripterror->GetSourceLineText(&bstrLine);

	if (pTemplate == NULL)
		goto LExit;

	// call GetScriptSourceInfo to get path-info (of file) and actual line number where error occurred
	// bug 379: if GetScriptSourceInfo returns fGuessedLine = TRUE, it means we gave it a non-authored line,
	// so we adjust below by not printing bstrLine in the error msg
	if (ulLineError > 0)
		pTemplate->GetScriptSourceInfo(dwEngineID, ulLineError, &szPathInfo, &szPathTranslated, &ulLineError, NULL, &fGuessedLine);
	else
		{
		// ulLineError was zero - no line # specified, so assume main file (usually this will be "out of memory"
		// so effect will be to display the script that was running when this occurred.
		//
		szPathInfo = pTemplate->GetSourceFileName(SOURCEPATHTYPE_VIRTUAL);
		szPathTranslated = pTemplate->GetSourceFileName(SOURCEPATHTYPE_PHYSICAL);
		}

    // if we have HitObj use it to get the virtual path to avoid
    // displaying of wrong path for shared templates
    //
    // first verify that PathTranslated == main file path; this file could be
    // an include file, in which case PszPathInfo is incorrect.
    //
    if (!pTemplate->FGlobalAsa() && _tcscmp(szPathTranslated, pTemplate->GetSourceFileName()) == 0 && pHitObj != NULL && pHitObj->PIReq())
        szPathInfo = pHitObj->PSzCurrTemplateVirtPath();

#if UNICODE
    pErrInfo->m_szItem[Im_szFileName] = StringDupUTF8(szPathInfo);
#else
	pErrInfo->m_szItem[Im_szFileName] = StringDupA(szPathInfo);
#endif
	szLineNumT = (CHAR *)malloc(10*sizeof(CHAR));
	if (szLineNumT)
		{
		// convert the line number
		_ltoa(ulLineError, szLineNumT, 10);
		}
	pErrInfo->m_szItem[Im_szLineNum] = szLineNumT;

	
	// is the scode one of the VBScript of JavaScript errors (this needs to be lang independent)
	// excepinfo.bstrDescription now has the formatted error string.
	if (excepinfo.bstrSource && excepinfo.bstrDescription)
		{
		// Bug 81954: Misbehaved objects may throw an exception without providing any information
		wchar_t *wszDescription;
		if (excepinfo.bstrDescription[0] == L'\0')
			{
			HRESULT hrError;

			if (0 == excepinfo.wCode)
				hrError = excepinfo.scode;
			else
				hrError = excepinfo.wCode;
            
            wszUnknownException[0] = '\0';
			// Bug 91847 Attempt to get a description via FormatMessage()
			if (!HResultToWsz(hrError, wszUnknownException, 128))
				CwchLoadStringOfId(IDE_SCRIPT_UNKNOWN, wszUnknownException, sizeof(wszUnknownException)/sizeof(WCHAR));
			wszDescription = wszUnknownException;
			}
		else
			wszDescription = excepinfo.bstrDescription;

		wchar_t *wszSource;
		if (excepinfo.bstrSource[0] == L'\0')
			{
            wszUnknownEngine[0] = '\0';
			CwchLoadStringOfId(IDS_DEBUG_APP, wszUnknownEngine, sizeof(wszUnknownEngine)/sizeof(WCHAR));
			wszSource = wszUnknownEngine;
			}
		else
			wszSource = excepinfo.bstrSource;

		CHAR *ch = NULL;
		
		// convert the Source to ascii

        if (convStr.Init(wszSource) != NO_ERROR) {
            szOrigin = NULL;
        }
        else {
            szOrigin = convStr.GetString(TRUE);
        }
		if (NULL != szOrigin) 
			{
			// Remove the word "error"from  the string, if any, because we will 
			//print out "error" when we print out the errorID
			cchOrigin = strlen(szOrigin);
			if (cchOrigin > 5) // 5 is strlen("error")
				{
				ch = szOrigin + cchOrigin - 5;
				if (!strncmp(ch, "error", 5))
					{// we found the word "error", truncate the szOrigin by null out the word "error"
					*ch = '\0';
					}
			  	}
			  	ch = NULL;
			} 	
		pErrInfo->m_szItem[Im_szEngine] = szOrigin;

        
		// convert the sDescription to ascii
        if (convStr.Init(wszDescription) != NO_ERROR) {
            szDesc = NULL;
        }
        else {
            szDesc = convStr.GetString(TRUE);
        }
					
		//check whether the szDesc is Denali/formatted error resource string or other unformatted string
		if (FALSE == FIsResStrFormatted(szDesc))
			{
			//unformatted string.
			pErrInfo->m_dwMask 	= dwDefaultMask;
			if (0 == excepinfo.wCode)
				pErrInfo->m_szItem[Im_szErrorCode] 		= SzScodeToErrorCode(excepinfo.scode);
			else
				pErrInfo->m_szItem[Im_szErrorCode] 		= SzScodeToErrorCode(excepinfo.wCode);
				
			pErrInfo->m_szItem[Im_szShortDescription] 	= StringDupA(szDesc);
			pErrInfo->m_szItem[Im_szLongDescription]	= NULL;
			}
		else
			{
			pErrInfo->ParseResourceString(szDesc);

			char *szTempErrorCode 		= SzScodeToErrorCode(excepinfo.scode);
			char *szTempErrorASPCode	= StringDupA(pErrInfo->m_szItem[Im_szErrorCode]);
			int nstrlen					= strlen(szTempErrorCode) + strlen(szTempErrorASPCode); 
			
			pErrInfo->m_szItem[Im_szErrorCode] = new char[nstrlen+4];
			
			if(pErrInfo->m_szItem[Im_szErrorCode])			
				sprintf(pErrInfo->m_szItem[Im_szErrorCode], "%s : %s", szTempErrorASPCode, szTempErrorCode); 

			if (szTempErrorCode)
				delete [] szTempErrorCode; 
				
			if(szTempErrorASPCode)	
				delete [] szTempErrorASPCode;
			
			//pErrInfo->m_szItem[Im_szErrorCode] = StrDup(pErrInfo->m_szItem[Im_szErrorCode]);
			pErrInfo->m_szItem[Im_szShortDescription] 	= StringDupA(pErrInfo->m_szItem[Im_szShortDescription]);
			pErrInfo->m_szItem[Im_szLongDescription]	= StringDupA(pErrInfo->m_szItem[Im_szLongDescription]);
			}

		/*
		 * If we didnt guess a line, and we have a line of source code to display
		 * then attempt to display it and hopefully a line of ------^ to point to the error
		 */
		if (!fGuessedLine && bstrLine != NULL)
			{
			INT cchDBCS = 0;		// Number of DBCS characters in source line
			CHAR *pszTemp = NULL;	// Temp sz pointer used to calculate cchDBCS
			// convert the source code line

            if (FAILED(hr = convStr.Init(bstrLine))) {
                goto LExit;
            }
            szLine = convStr.GetString();
				
			cchLine = strlen(szLine);
			if (0 == cchLine)
				goto LExit;

			// Check for DBCS character, and cchLine -= NumberofDBCScharacter, such that 
			// the ----^ will point to the right position.
			pszTemp = szLine;
			while(*pszTemp != NULL)
				{
					if (IsDBCSLeadByte(*pszTemp))
					{
						cchDBCS++;
						pszTemp += 2;	// skip 2 bytes
					}
					else
					{
						pszTemp++;		// single byte
					}
				}

			// compute the size of the source code indicator:
			// "<source line> + '\r\n' + <error pos>*'-' + '^'
			// 3 chars. without source line and '-'
			LONG ichErrorT = ichError;
			cchBuf += cchLine + ichErrorT + 3;

			// allocate the result buffer
			szResult = new(char[cchBuf + 2]);
			if (szResult == NULL)
				goto LExit;

			// fill up the buffer
			ch = szResult;

			// append the <PRE>
			// bug 87118, moved to template for a proper HTML encoding

			// <source line>
			if (cchLine)
				strncpy(ch, szLine, cchLine);
			ch += cchLine;

			// stick the "----^" string on the end
			if (ichErrorT > -1)
				{
				// prepend the '\n'
				strncpy(ch, "\r\n", 2);
				ch += 2;
				// put in the "---"'s, and shrink "---" by #ofDBCS
				ichErrorT -= cchDBCS;
				while (ichErrorT-- > 0)
					*ch++ = '-';

				*ch++ = '^';
				}

			// append the </PRE>
			// bug 87118, moved to template for a proper HTML encoding

			// terminate the string
			*ch++ = '\0';
			pErrInfo->m_szItem[Im_szCode] = szResult;

			// add line and column to error object
			pErrInfo->m_nColumn = ichError;
			pErrInfo->m_bstrLineText = bstrLine;
			}
		}
	else
		{
		// Not VBS or other Engine errors/Unknown error
		// Load Default
		// try to compute a specific error message
		HRESULT hr_def;
		hr_def = GetSpecificError(pErrInfo, excepinfo.scode);
		CHAR *szShortDescription = new CHAR[256];

		// if that failed try to compute a generic error
		if (FAILED(hr_def))
			{
			pErrInfo->m_dwMask							= dwDefaultMask;
			if (0 == excepinfo.wCode)
				{
				pErrInfo->m_szItem[Im_szErrorCode] 		= SzScodeToErrorCode(excepinfo.scode);
				// Bug 91847 Attempt to get a description via FormatMessage()
				if ((szShortDescription != NULL) && 
					!HResultToSz(excepinfo.scode, szShortDescription, 256)) 
					{
					// Displaying the error number twice would be redundant, delete it
					delete [] szShortDescription;
					szShortDescription = NULL;
					}
				}
			else
				{
				pErrInfo->m_szItem[Im_szErrorCode] 		= SzScodeToErrorCode(excepinfo.wCode);
				// Bug 91847 Attempt to get a description via FormatMessage()
				if ((szShortDescription != NULL) && 
					!HResultToSz(excepinfo.wCode, szShortDescription, 256)) 
					{
					// Displaying the error number twice would be redundant, delete it
					delete [] szShortDescription;
					szShortDescription = NULL;
					}
				}
			pErrInfo->m_szItem[Im_szEngine] 			= NULL;
			pErrInfo->m_szItem[Im_szShortDescription] 	= szShortDescription;
			pErrInfo->m_szItem[Im_szLongDescription]	= NULL;
			}
		}

LExit:
	if (excepinfo.bstrSource)
		{
		SysFreeString(excepinfo.bstrSource);
		}

	if (excepinfo.bstrDescription)
		{
		SysFreeString(excepinfo.bstrDescription);
		}

	if (excepinfo.bstrHelpFile)
		{
		SysFreeString(excepinfo.bstrHelpFile);
		}

	pErrInfo->LogError();

	if (bstrLine)
		{
		SysFreeString(bstrLine);
		}

	FreeNullifySz((CHAR **)&szDesc);

	for(INT iErrInfo = 0; iErrInfo < Im_szItemMAX; iErrInfo++)
		{
		FreeNullifySz((CHAR **)&pErrInfo->m_szItem[iErrInfo]);
		}
	
	return S_OK;
	}
	
/*===================================================================
LoadErrResString

Loads an error string(formatted) from the string table.

Returns:
		pdwMask
		szErrorCode
		szShortDes
		szLongDes

if any of the szVariable is NULL, that particular string value will not be loaded.

		S_OK	if successes.
		E_FAIL	if fails.
Side Effect
		NONE
===================================================================*/
HRESULT	LoadErrResString(
UINT ErrID/*IN*/, 
DWORD *pdwMask, 
CHAR *szErrorCode, 
CHAR *szShortDes, 
CHAR *szLongDes)
{
	CHAR 	*szToken 	= NULL;
	CHAR 	szResTemp[2*MAX_RESSTRINGSIZE];	//ResourceTempString
	INT		cch			= 0;

	cch = CchLoadStringOfId(ErrID, szResTemp, MAX_RESSTRINGSIZE);

	//Mask
	szToken = (char *)_mbstok((unsigned char *)szResTemp, (unsigned char *)DELIMITER);
	if (NULL != szToken)
		*pdwMask = atoi(szToken);
	else
		Assert(FALSE);

	//ErrorCode
	szToken = (char *)_mbstok(NULL, (unsigned char *)DELIMITER);
	if (NULL != szToken && NULL != szErrorCode)
		{
		cch = strlen(szToken);
		memcpy(szErrorCode, szToken, cch);
		szErrorCode[cch] = '\0';
		}

	//ShortDescription
	szToken = (char *)_mbstok(NULL, (unsigned char *)DELIMITER);
	if (NULL != szToken && NULL != szShortDes)
		{
		cch = strlen(szToken);
		memcpy(szShortDes, szToken, cch);
		szShortDes[cch] = '\0';
		}

	//LongDescription
	szToken = (char *)_mbstok(NULL, (unsigned char *)DELIMITER);
	if (NULL != szToken && NULL != szLongDes)
		{
		cch = strlen(szToken);
		memcpy(szLongDes, szToken, cch);
		szLongDes[cch] = '\0';
		}

	return S_OK;
}

/*===================================================================
SzScodeToErrorCode

Conver Scode to string

Returns:
	Composed string

Side Effects:
	***ALLOCATES MEMORY -- CALLER MUST FREE***
===================================================================*/
CHAR *SzScodeToErrorCode
(
HRESULT hrError
)
	{
	CHAR *szResult = NULL;
	CHAR szBuf[17];
	CHAR *szNumber;
	CHAR *szError;
	INT iC;
	INT cch;
	
	// put a bunch of zeros into the buffer
	for (iC = 0; iC < 16; ++iC)
		szBuf[iC] = '0';

	// szNumber points half way into the buffer
	szNumber = &szBuf[8];

	// get the error szNumber as a hex string
	_ltoa(hrError, szNumber, 16);

	// back up szNumber to allow a total of 8 digits
	szNumber -= 8 - strlen(szNumber);

	cch = strlen(szNumber) + 1;

	szError = new(CHAR[cch]);
	if (szError != NULL)
		{
		szError[0] = '\0';
		strcat(szError, szNumber);
		szResult = szError;
		}
	else
		{
		HandleOOMError(NULL, NULL);
		}

	return(szResult);
	}

/*===================================================================
SzComposeSpecificError

Compose a specific error for an HRESULT of the form:
	<string> <error-number>

This is our last resort if there is not more useful information to be had.

Returns:
	Composed string

Side Effects:
	***ALLOCATES MEMORY -- CALLER MUST FREE***
===================================================================*/
HRESULT GetSpecificError
(
CErrInfo *pErrInfo,
HRESULT hrError
)
	{
	HRESULT hr_return = E_FAIL;
	UINT idErr;

	switch (hrError)
		{
		case DISP_E_MEMBERNOTFOUND:
			idErr = IDE_SCRIPT_METHOD_NOT_FOUND;
			break;

		case DISP_E_UNKNOWNNAME:
			idErr = IDE_SCRIPT_UNKNOWN_NAME;
			break;

		case DISP_E_UNKNOWNINTERFACE:
			idErr = IDE_SCRIPT_UNKNOWN_INTERFACE;
			break;

		case DISP_E_PARAMNOTOPTIONAL:
			idErr = IDE_SCRIPT_MISSING_PARAMETER;
			break;

		default:
			// Not one of the errors we know how to handle specially.  E_FAIL will be returned.
			idErr = 0;
			break;
		}

	// build a szResult string if we find a match
	if (idErr != 0)
		{
		hr_return = LoadErrResString(idErr, 
									&(pErrInfo->m_dwMask),
									pErrInfo->m_szItem[Im_szErrorCode],
									pErrInfo->m_szItem[Im_szShortDescription],
									pErrInfo->m_szItem[Im_szLongDescription]
									);
		}

	return(hr_return);
	}

/*===================================================================
HResultToWsz

Tranlates a HRESULT to a description string of the HRESULT.  Attempts
to use FormatMessage() to get a 

Parameters:
	hrIn	The error to lookup
	wszOut	String to output the description to
	cdwOut	Number of WCHARs wszOut can hold

Returns:
	TRUE if a description string was found
	FALSE if the error number was output instead

Notes:
	Added to resolve bug 91847.  When unexpected errors are processed
	the naked error number was output, which developers would then 
	have to look up in winerror.h.
===================================================================*/
BOOL HResultToWsz(HRESULT hrIn, WCHAR *wszOut, DWORD cdwOut) 
	{
	LANGID langID = LANG_NEUTRAL;
    DWORD   dwFound = 0;
    HMODULE  hMsgModule = NULL;

#ifdef USE_LOCALE
	LANGID *pLangID;
	
	pLangID = (LANGID *)TlsGetValue(g_dwTLS);

	if (NULL != pLangID)
		langID = *pLangID;
#endif

    if (HRESULT_FACILITY(hrIn) == (HRESULT)FACILITY_INTERNET)
        hMsgModule = GetModuleHandleA("METADATA");
    else
        hMsgModule = GetModuleHandleA("ASP");
    
    dwFound = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
					    hMsgModule,
					    hrIn,
					    langID,
					    wszOut,
					    cdwOut,
					    NULL);


	if (!dwFound) 
		{
		// Error not found, make a string out of the error number
		WCHAR *wszResult = NULL;
		WCHAR wszBuf[17];
		WCHAR *wszNumber;
		WCHAR *wszError;
		INT iC;
	
		// put a bunch of zeros into the buffer
		for (iC = 0; iC < 16; ++iC)
			wszBuf[iC] = L'0';

		// wszNumber points half way into the buffer
		wszNumber = &wszBuf[8];

		// get the error wszNumber as a hex string
		_ltow(hrIn, wszNumber, 16);

		// back up szNumber to allow a total of 8 digits
		wszNumber -= 8 - wcslen(wszNumber);

		// Copy the result to wszOut
		wcsncpy(wszOut, wszNumber, cdwOut);

		return FALSE;
		}
	else
		return TRUE;
	}

HMODULE GetModuleHandleForHRESULT(HRESULT  hrIn)
{
    char        szModuleName[MAX_PATH];
    DWORD       pathLen = 0;
    char       *pch;

    szModuleName[0] = '\0';

    if (g_fOOP) {

            strcat(szModuleName, "INETSRV\\");
    }

    if (HRESULT_FACILITY(hrIn) == (HRESULT)FACILITY_INTERNET)
        strcat(szModuleName, "METADATA.DLL");       
    else
        strcat(szModuleName, "ASP.DLL");       

    return(LoadLibraryExA(szModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE));
}    

/*===================================================================
HResultToSz

Tranlates a HRESULT to a description string of the HRESULT.  Attempts
to use FormatMessage() to get a 

Parameters:
	hrIn	The error to lookup
	szOut	String to output the description to
	cdwOut	Number of WCHARs wszOut can hold

Returns:
	TRUE if a description string was found
	FALSE if the error number was output instead

Notes:
	Added to resolve bug 91847.  When unexpected errors are processed
	the naked error number was output, which developers would then 
	have to look up in winerror.h.
===================================================================*/
BOOL HResultToSz(HRESULT hrIn, CHAR *szOut, DWORD cdwOut) 
	{
	LANGID langID = LANG_NEUTRAL;
    HMODULE  hMsgModule = NULL;
    BOOL     bFound = FALSE;

#ifdef USE_LOCALE
	LANGID *pLangID;
	
	pLangID = (LANGID *)TlsGetValue(g_dwTLS);

	if (NULL != pLangID)
		langID = *pLangID;
#endif

    hMsgModule = GetModuleHandleForHRESULT(hrIn);

    HRESULT hr = GetLastError();

    bFound = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
					    hMsgModule,
					    hrIn,
					    langID,
					    szOut,
					    cdwOut,
					    NULL);

    // make one additional check before giving up.  If the facility of the error is
    // WIN32, then retry the call after masking out the facility code to get standard
    // WIN32 errors. I.E. 80070005 is really just 5 - access denied

    if (!bFound && (HRESULT_FACILITY(hrIn) == (HRESULT)FACILITY_WIN32)) {

        bFound = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
					    NULL,
					    hrIn & 0xffff,
					    langID,
					    szOut,
					    cdwOut,
					    NULL);
    }

    if (hMsgModule)
        FreeLibrary(hMsgModule);

	if (!bFound ) 
		{
		// Error not found, make a string out of the error number
		CHAR *szResult = NULL;
		CHAR szBuf[17];
		CHAR *szNumber;
		CHAR *szError;
		INT iC;
	
		// put a bunch of zeros into the buffer
		for (iC = 0; iC < 16; ++iC)
			szBuf[iC] = L'0';

		// wszNumber points half way into the buffer
		szNumber = &szBuf[8];

		// get the error wszNumber as a hex string
		_ltoa(hrIn, szNumber, 16);

		// back up szNumber to allow a total of 8 digits
		szNumber -= 8 - strlen(szNumber);

		// Copy the result to wszOut
		strncpy(szOut, szNumber, cdwOut);

		return FALSE;
		}
	else
		return TRUE;
	}

/*===================================================================
FIsResStrFormatted

Check for formatted resource string.

RETURN:
	TRUE/FALSE
===================================================================*/
BOOL FIsResStrFormatted(char *szIn)
{
	BOOL  freturn = FALSE;
	UINT  cDelimiter = 0;
	CHAR  *pch;

	if(szIn)
		{
			pch = szIn;
			while(*pch)
			{
			if ('~' == *pch)
				cDelimiter++;
			pch = CharNextA(pch);
			}

			if(3 == cDelimiter)
				return TRUE;
		}
	return freturn;
	
}

/*===================================================================
HandleErrorMissingFilename

In several circumstances we want to report an error, but
we have no filename, and the normal method for getting
the filename from the template wont work because we have
no line number info either (e.g. Script timeout, GPF, control GPF, etc)

Get the filename from the CIsapiReqInfo (if possible) and report the error.

Returns:
	Nothing
===================================================================*/
VOID HandleErrorMissingFilename
(
UINT errorID,
CHitObj *pHitObj,
BOOL    fAddlInfo /* = FALSE */,
...
)
	{
    va_list args;

    if (fAddlInfo)
        va_start(args, fAddlInfo);

	CHAR *szFileName = NULL;

	if (pHitObj && pHitObj->PSzCurrTemplateVirtPath())
		{
#if UNICODE
        szFileName = StringDupUTF8(pHitObj->PSzCurrTemplateVirtPath());
#else
   		szFileName = StringDupA(pHitObj->PSzCurrTemplateVirtPath());
#endif
		}
		
	char szEngine[64];
	CchLoadStringOfId(IDS_ENGINE, szEngine, sizeof szEngine);

	char *pszEngine = new char [strlen(szEngine) + 1];
	if (pszEngine)
		{
		// If the alloc failed, we will pass NULL to HandleError for pszEngine, which is fine.
		// (old code used to pass NULL)  All that will happen is that the AspError.Category == "". Oh Well.
		// TODO: change this function to return an HRESULT.
		//
		strcpy(pszEngine, szEngine);
		}

	HandleError(errorID, szFileName, NULL, pszEngine, NULL, NULL, NULL, pHitObj, fAddlInfo ? &args : NULL);
	}

/*===================================================================
DebugError

Handle a script error by invoking the debugger.

Returns:
	fails if debugger cannot be invoked.
	If this function fails, no other action is taken.
	  (Therefore, the caller should make sure error is reported in
	   some other way)
===================================================================*/
HRESULT DebugError(IActiveScriptError *pScriptError, CTemplate *pTemplate, DWORD dwEngineID, IDebugApplication *pDebugApp)
	{
	EXCEPINFO excepinfo = {0};
	BSTR bstrLine = NULL;
	DWORD dwSourceContext = 0;
	ULONG ulLineError = 0;
	ULONG ichLineError = 0;			// character offset of the line in the source
	ULONG cchLineError = 0;			// length of the source line
	BOOLB fGuessedLine = FALSE;		// see bug 379
	LPTSTR szPathInfo = NULL;
	LPTSTR szPathTranslated = NULL;
	LONG ichError = -1;
	HRESULT hr = S_OK;
	IDebugDocumentContext *pDebugContext = NULL;
	wchar_t *wszErrNum, *wszShortDesc, *wszLongDesc;	// Used to tokenize resource strings
	
	if (pScriptError == NULL || pTemplate == NULL || pDebugApp == NULL)
		return E_POINTER;

	if (FAILED(pScriptError->GetSourcePosition(&dwSourceContext, &ulLineError, &ichError)))
		return E_FAIL;

	if (FAILED(pScriptError->GetExceptionInfo(&excepinfo)))
		return E_FAIL;

	// call template object to get line number and character offset where error occurred
	// (It returns both - caller discards whichever it does not want)
	// bug 379: if pTemplate returns fGuessedLine == TRUE, it means we gave it a non-authored
	// line, so we adjust below by not printing bstrLine in the error msg
	pTemplate->GetScriptSourceInfo(dwEngineID, ulLineError, &szPathInfo, &szPathTranslated, NULL, &ichLineError, NULL);

	// Create a new document context for this statement
	// CONSIDER: character count that we return is bogus - however our debugging
	//           client (Caesar's) does not use this information anyway.
	//
	// If this is in the main file, create a document context based on the CTemplate compiled source
	if (_tcscmp(szPathTranslated, pTemplate->GetSourceFileName()) == 0)
		pDebugContext = new CTemplateDocumentContext(pTemplate, ichLineError, 1);

	// source refers to an include file, so create a documet context based on cached CIncFile dependency graph
	else
		{
		CIncFile *pIncFile;
		if (FAILED(g_IncFileMap.GetIncFile(szPathTranslated, &pIncFile)))
			{
			hr = E_FAIL;
			goto LExit;
			}

		pDebugContext = new CIncFileDocumentContext(pIncFile, ichLineError, 1);
		pIncFile->Release();
		}

	if (pDebugContext == NULL)
		{
		hr = E_OUTOFMEMORY;
		goto LExit;
		}

	// Yes it does, bring up the debugger on this line
    hr =  InvokeDebuggerWithThreadSwitch
        (
        pDebugApp,
        DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP,
        pDebugContext
        );
	if (FAILED(hr))
		goto LExit;
	

	// pop up a message box with the error description
	// Bug 81954: Misbehaved objects may throw an exception without providing any information
	wchar_t wszExceptionBuffer[256];
	wchar_t *wszDescription;
	if (excepinfo.bstrDescription == NULL || excepinfo.bstrDescription[0] == L'\0')
		{
		HRESULT hrError;

		if (0 == excepinfo.wCode)
			hrError = excepinfo.scode;
		else
			hrError = excepinfo.wCode;

		// Bug 91847 Attempt to get a description via FormatMessage()
		if (!HResultToWsz(hrError, wszExceptionBuffer, 128))
			CwchLoadStringOfId(IDE_SCRIPT_UNKNOWN, wszExceptionBuffer, sizeof(wszExceptionBuffer)/sizeof(WCHAR));
		wszDescription = wszExceptionBuffer;
		}
	else
		wszDescription = excepinfo.bstrDescription;

	wchar_t wszSource[35];
	CwchLoadStringOfId(IDS_SCRIPT_ERROR, wszSource, sizeof(wszSource)/sizeof(WCHAR));

	// See if this is resource formatted string, and if it is, get pointers to short & long string
	// resource formatted strings are delimited by '~' characters  There are three '~' characters
	// in the resource formatted string
	//
	wszErrNum = wcschr(wszDescription, L'~');
	if (wszErrNum)
		{
		wszShortDesc = wcschr(wszErrNum + 1, L'~');
		if (wszShortDesc)
			{
			wszLongDesc = wcschr(wszShortDesc + 1, L'~');

			// OK. If all three tests succeeded, we know this is a resource formatted string,
			// and we have pointers to all three segments. Replace each '~' with two newlines.
			// First: Load resource strings

			wchar_t wszErrorBegin[20], wszErrorEnd[5];
			wchar_t *pwchEnd;

			CwchLoadStringOfId(IDS_DEBUGGER_TEMPLATE_BEGIN, wszErrorBegin, sizeof(wszErrorBegin)/sizeof(WCHAR));
			CwchLoadStringOfId(IDS_DEBUGGER_TEMPLATE_END, wszErrorEnd, sizeof(wszErrorEnd)/sizeof(WCHAR));

			// Tokenize string by setting '~' characters to NULL and incrementing ptrs

			*wszErrNum++ = *wszShortDesc++ = *wszLongDesc++ = L'\0';

			// Build the string

			pwchEnd = strcpyExW(wszExceptionBuffer, excepinfo.bstrSource);
			*pwchEnd++ = L' ';
			pwchEnd = strcpyExW(pwchEnd, wszErrorBegin);
			pwchEnd = strcpyExW(pwchEnd, wszErrNum);
			pwchEnd = strcpyExW(pwchEnd, wszErrorEnd);
			*pwchEnd++ = L'\n';
			*pwchEnd++ = L'\n';

			pwchEnd = strcpyExW(pwchEnd, wszShortDesc);
			*pwchEnd++ = L'\n';
			*pwchEnd++ = L'\n';

			pwchEnd = strcpyExW(pwchEnd, wszLongDesc);

			wszDescription = wszExceptionBuffer;
			}
		}

	// Win95 does not support MessageBoxW()  -- moot since debugging not supported on Win95
	Assert (FIsWinNT());
	MessageBoxW(NULL, wszDescription, wszSource, MB_SERVICE_NOTIFICATION | MB_TOPMOST | MB_OK | MB_ICONEXCLAMATION);

LExit:
	if (pDebugContext)
		pDebugContext->Release();

	if (excepinfo.bstrSource)
		SysFreeString(excepinfo.bstrSource);

	if (excepinfo.bstrDescription)
		SysFreeString(excepinfo.bstrDescription);

	if (excepinfo.bstrHelpFile)
		SysFreeString(excepinfo.bstrHelpFile);

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\fileapp.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: File/Application mapping

File: CFileApp.h

Owner: CGrant

File/Application mapping definition
-----------------------------------------------------------------------------*/

#ifndef _CFILEAPP_H
#define _CFILEAPP_H

// Includes -------------------------------------------------------------------
#include "applmgr.h"
#include "hashing.h"
#include "idhash.h"
#include "memcls.h"

#define    NUM_FILEAPP_HASHING_BUCKETS	17

/*****************************************************************************
Class:  CFileApplicationMap
Synopsis:   Maintains a database relating files to the applications that
            must be shut down if the file changes. The key for the hash table
            is the full file name
*/  
class CFileApplicationMap : public CHashTable
{
    // Flags
    DWORD m_fInited : 1;                // Are we initialized?
    DWORD m_fHashTableInited : 1;       // Need to UnInit hash table?
    DWORD m_fCriticalSectionInited : 1; // Need to delete CS?

    // Critical section for locking
    CRITICAL_SECTION m_csLock;

public:

    CFileApplicationMap();
    ~CFileApplicationMap();
    void Lock();
    void UnLock();
    HRESULT Init();
    HRESULT UnInit();
    HRESULT AddFileApplication(const TCHAR *pszFileName, CAppln *pAppln);
    BOOL ShutdownApplications(const TCHAR *pszFile);
};

inline void CFileApplicationMap::Lock()
    {
    Assert(m_fInited);
    EnterCriticalSection(&m_csLock);
    }
    
inline void CFileApplicationMap::UnLock()
    {
    Assert(m_fInited);
    LeaveCriticalSection( &m_csLock ); 
    }
    
/*****************************************************************************
Class:  CFileApplnList
Synopsis:   Maintains a list of applications that
            must be shut down if a file changes
*/
class CFileApplnList : public CLinkElem
{

friend class CFileApplicationMap;

    TCHAR*      m_pszFilename;
    CPtrArray   m_rgpvApplications; // the list of applications
    BOOL        m_fInited;          // flag indicating initialization

public:

    CFileApplnList();
    ~CFileApplnList();

    HRESULT Init(const TCHAR* pszFilename);
    HRESULT UnInit();

    HRESULT AddApplication(void *pApplication);
    HRESULT RemoveApplication(void *pApplication);
    VOID    GetShutdownApplications(CPtrArray *prgpapplnRestartList);

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
};

/*===================================================================
  Globals
===================================================================*/

extern CFileApplicationMap    g_FileAppMap;

#endif // _CFILEAPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\ftm.cpp ===
/*===================================================================
Microsoft ASP

Microsoft Confidential.
Copyright 1996, 1997, 1998 Microsoft Corporation. All Rights Reserved.

Component: Free Threaded Marshaller Base Class

File: ftm.cpp

Owner: Lei Jin

This is the free threaded marshaller base class implementation.
===================================================================*/
#include "denpre.h"
#pragma hdrstop
#include "ftm.h"
#include "memchk.h"

IMarshal* CFTMImplementation::m_pUnkFTM     = NULL;

STDMETHODIMP 
CFTMImplementation::GetUnmarshalClass
( 
/* [in] */ REFIID riid,
/* [unique][in] */ void __RPC_FAR *pv,
/* [in] */ DWORD dwDestContext,
/* [unique][in] */ void __RPC_FAR *pvDestContext,
/* [in] */ DWORD mshlflags,
/* [out] */ CLSID __RPC_FAR *pCid
)
    {
    
    DBG_ASSERT(m_pUnkFTM != NULL);
    
    return m_pUnkFTM->GetUnmarshalClass(riid, pv, dwDestContext, pvDestContext, mshlflags, pCid);

    }

STDMETHODIMP 
CFTMImplementation::GetMarshalSizeMax( 
/* [in] */ REFIID riid,
/* [unique][in] */ void __RPC_FAR *pv,
/* [in] */ DWORD dwDestContext,
/* [unique][in] */ void __RPC_FAR *pvDestContext,
/* [in] */ DWORD mshlflags,
/* [out] */ DWORD __RPC_FAR *pSize)
    {
    DBG_ASSERT(m_pUnkFTM != NULL);
    return m_pUnkFTM->GetMarshalSizeMax(riid, pv, dwDestContext, pvDestContext, mshlflags, pSize);
    }

STDMETHODIMP
CFTMImplementation::MarshalInterface( 
/* [unique][in] */ IStream __RPC_FAR *pStm,
/* [in] */ REFIID riid,
/* [unique][in] */ void __RPC_FAR *pv,
/* [in] */ DWORD dwDestContext,
/* [unique][in] */ void __RPC_FAR *pvDestContext,
/* [in] */ DWORD mshlflags)
    {
    DBG_ASSERT(m_pUnkFTM != NULL);
    return m_pUnkFTM->MarshalInterface(pStm, riid, pv, dwDestContext, pvDestContext, mshlflags);
    }

STDMETHODIMP 
CFTMImplementation::UnmarshalInterface
( 
/* [unique][in] */ IStream __RPC_FAR *pStm,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
    {
    DBG_ASSERT(m_pUnkFTM != NULL);
    return m_pUnkFTM->UnmarshalInterface(pStm, riid, ppv);
    }

STDMETHODIMP 
CFTMImplementation::ReleaseMarshalData
( 
/* [unique][in] */ IStream __RPC_FAR *pStm
)
    {
    DBG_ASSERT(m_pUnkFTM != NULL);
    return m_pUnkFTM->ReleaseMarshalData(pStm);
    }

STDMETHODIMP 
CFTMImplementation::DisconnectObject
( 
/* [in] */ DWORD dwReserved
)
    {
    DBG_ASSERT(m_pUnkFTM != NULL);
    return m_pUnkFTM->DisconnectObject(dwReserved);
    }

HRESULT			
CFTMImplementation::Init
(
void
)
    {
    IUnknown *pUnkFTMTemp = NULL;
    HRESULT hr;
    
    hr = CoCreateFreeThreadedMarshaler(NULL, (IUnknown**)&pUnkFTMTemp);

    DBG_ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
        {
        hr = pUnkFTMTemp->QueryInterface(IID_IMarshal, reinterpret_cast<void **>(&m_pUnkFTM));
        DBG_ASSERT(SUCCEEDED(hr) && m_pUnkFTM != NULL);
        pUnkFTMTemp->Release();
        }
        
    return hr;
    }

    
HRESULT			
CFTMImplementation::UnInit
(
void
)
    {
    DBG_ASSERT(m_pUnkFTM != NULL);

    m_pUnkFTM->Release();
    m_pUnkFTM = NULL;
    
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\ftm.h ===
/*===================================================================
Microsoft ASP

Microsoft Confidential.
Copyright 1996, 1997, 1998 Microsoft Corporation. All Rights Reserved.

Component: Free Threaded Marshaller Base Class

File: ftm.h

Owner: Lei Jin

This is the free threaded marshaller base class header file.
===================================================================*/
#ifndef _FTM_GLOBAL_H
#define _FTM_GLOBAL_H

#include <objbase.h>
#include "debug.h"
#include "util.h"

class CFTMImplementation : public IMarshal 
{
public:

    STDMETHODIMP GetUnmarshalClass( 
		    /* [in] */ REFIID riid,
		    /* [unique][in] */ void __RPC_FAR *pv,
		    /* [in] */ DWORD dwDestContext,
		    /* [unique][in] */ void __RPC_FAR *pvDestContext,
		    /* [in] */ DWORD mshlflags,
		    /* [out] */ CLSID __RPC_FAR *pCid);

    STDMETHODIMP GetMarshalSizeMax( 
	        /* [in] */ REFIID riid,
	        /* [unique][in] */ void __RPC_FAR *pv,
	        /* [in] */ DWORD dwDestContext,
	        /* [unique][in] */ void __RPC_FAR *pvDestContext,
	        /* [in] */ DWORD mshlflags,
	        /* [out] */ DWORD __RPC_FAR *pSize);
    
    STDMETHODIMP MarshalInterface( 
	        /* [unique][in] */ IStream __RPC_FAR *pStm,
	        /* [in] */ REFIID riid,
	        /* [unique][in] */ void __RPC_FAR *pv,
	        /* [in] */ DWORD dwDestContext,
	        /* [unique][in] */ void __RPC_FAR *pvDestContext,
	        /* [in] */ DWORD mshlflags);
    
    STDMETHODIMP UnmarshalInterface( 
	        /* [unique][in] */ IStream __RPC_FAR *pStm,
	        /* [in] */ REFIID riid,
	        /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
    
    STDMETHODIMP ReleaseMarshalData( 
	        /* [unique][in] */ IStream __RPC_FAR *pStm);
    
    STDMETHODIMP DisconnectObject( 
	        /* [in] */ DWORD dwReserved);

	static	HRESULT			Init();
	static	HRESULT			UnInit();
	
private:
	// Global FTM pointer
	static	IMarshal *		m_pUnkFTM; 
};

#endif _FTM_GLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\gip.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Global Interface Pointer API support

File: Gip.cpp

Owner: DmitryR

This is the GIP source file.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "gip.h"
#include "memchk.h"

/*===================================================================
  Globals
===================================================================*/

CGlobalInterfaceAPI g_GIPAPI;

/*===================================================================
  C  G l o b a l  I n t e r f a c e  A P I
===================================================================*/

/*===================================================================
CGlobalInterfaceAPI::CGlobalInterfaceAPI

CGlobalInterfaceAPI constructor

Parameters:

Returns:
===================================================================*/	
CGlobalInterfaceAPI::CGlobalInterfaceAPI() 
    : m_fInited(FALSE), m_pGIT(NULL)
    {
    }
    
/*===================================================================
CGlobalInterfaceAPI::~CGlobalInterfaceAPI

CGlobalInterfaceAPI destructor

Parameters:

Returns:
===================================================================*/	
CGlobalInterfaceAPI::~CGlobalInterfaceAPI()
    {
    UnInit();
    }

/*===================================================================
CGlobalInterfaceAPI::Init

Creates instance of GlobalInterfaceTable

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CGlobalInterfaceAPI::Init()
    {
    Assert(!m_fInited); // don't init twice
    
    HRESULT hr = CoCreateInstance
        (
        CLSID_StdGlobalInterfaceTable,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IGlobalInterfaceTable,
        (void **)&m_pGIT
        );
        
    if (SUCCEEDED(hr))
        m_fInited = TRUE;
    else
        m_pGIT = NULL;

    return hr;
    }

/*===================================================================
CGlobalInterfaceAPI::UnInit

Releases instance of GlobalInterfaceTable

Parameters:

Returns:
    HRESULT (S_OK)
===================================================================*/	
HRESULT CGlobalInterfaceAPI::UnInit()
    {
    if (m_pGIT)
        {
        m_pGIT->Release();
        m_pGIT = NULL;
        }

    m_fInited = FALSE;
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\gip.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Global Interface Pointer API support

File: Gip.h

Owner: DmitryR

This is the GIP header file.
===================================================================*/

#ifndef _ASP_GIP_H
#define _ASP_GIP_H

/*===================================================================
  Includes
===================================================================*/

#include "debug.h"

/*===================================================================
  Defines
===================================================================*/

#define NULL_GIP_COOKIE  0xFFFFFFFF

/*===================================================================
  C  G l o b a l  I n t e r f a c e  A P I
===================================================================*/

class CGlobalInterfaceAPI
    {
private:
    // Is inited?
    DWORD m_fInited : 1;
    
    // Pointer to the COM object
    IGlobalInterfaceTable *m_pGIT;

public:
    CGlobalInterfaceAPI();
    ~CGlobalInterfaceAPI();

    HRESULT Init();
    HRESULT UnInit();

    // inlines for the real API calls:
    HRESULT Register(IUnknown *pUnk, REFIID riid, DWORD *pdwCookie);
    HRESULT Get(DWORD dwCookie, REFIID riid, void **ppv);
    HRESULT Revoke(DWORD dwCookie);
    
public:
#ifdef DBG
	inline void AssertValid() const
	    {
        Assert(m_fInited);
        Assert(m_pGIT);
	    }
#else
	inline void AssertValid() const {}
#endif
    };

/*===================================================================
  CGlobalInterfaceAPI inlines
===================================================================*/

inline HRESULT CGlobalInterfaceAPI::Register
(
IUnknown *pUnk,
REFIID riid,
DWORD *pdwCookie
)
    {
    Assert(m_fInited);
    Assert(m_pGIT);
    return m_pGIT->RegisterInterfaceInGlobal(pUnk, riid, pdwCookie);
    }

inline HRESULT CGlobalInterfaceAPI::Get
(
DWORD dwCookie,
REFIID riid, 
void **ppv
)
    {
    Assert(m_fInited);
    Assert(m_pGIT);
    return m_pGIT->GetInterfaceFromGlobal(dwCookie, riid, ppv);
    }
        
inline HRESULT CGlobalInterfaceAPI::Revoke
(
DWORD dwCookie
)
    {
    Assert(m_fInited);
    Assert(m_pGIT);
    return m_pGIT->RevokeInterfaceFromGlobal(dwCookie);
    }

/*===================================================================
  Globals
===================================================================*/

extern CGlobalInterfaceAPI g_GIPAPI;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\hashing.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Link list and Hash table

File: Hashing.h

Owner: PramodD

This is the Link list and Hash table class header file.
===================================================================*/

#ifndef HASHING_H
#define HASHING_H

// General purpose hash function
typedef DWORD (*HashFunction)( const BYTE *pBytes, int cBytes );

// Default hash function
extern DWORD DefaultHash( const BYTE *pBytes, int cBytes );

// unicode hash function, based on algorithm used by ::DefaultHash, CASE INSENSITIVE
extern DWORD UnicodeUpcaseHash( const BYTE *pKey, int cbKey );

// multi-byte ucase hash function, based on algorithm used by ::DefaultHash, CASE INSENSITIVE
extern DWORD MultiByteUpcaseHash( const BYTE *pKey, int cbKey );

// Cache pointers. The 4-byte address is the DWORD.
extern DWORD PtrHash( const BYTE *pKey, int );

// CLSID hashing.
extern DWORD CLSIDHash( const BYTE *pKey, int );

/*
The CLinkElem class is intended to be used as a base class for
other link lists and/or hash table implementations.

The name is used for identification and search purposes.

The previous and next pointers are used for traversal.

The Info member is the number of elements in bucket following
this element.

*/

struct CLinkElem
{
	BYTE *		m_pKey;		// Unique key - unknown datatype
	short		m_cbKey;	// length of the key
	short		m_Info;		// Link list element info
	CLinkElem *	m_pPrev;	// Previous element in link list
	CLinkElem *	m_pNext;	// Next element in link list

			CLinkElem();
	virtual	~CLinkElem() {} // Did not allocate so we do not delete
	HRESULT	Init(void *pKey, int cKeyLen);
};

/*
This Hash Table class is used to store and find Named elements
of the type CLinkElem. Classes derived from CLinkElem can use
this class.

The principal requirements for the implementation are:
	Speed of search
	Forward and backward traversal through stored elements

The expected use of this class is as follows.

The user calls the Init method with a size argument to indicate
the number of buckets.

CLinkElems are added to the Hash table using AddElem()

CLinkElems are searched for by name using FindElemByName()

CLinkElems are searched for by index using FindElemByIndex()

CLinkElems are removed by name using DeleteElem()

Reference counting should be implemented by the class derived
from CLinkElem.
*/

#define PREALLOCATED_BUCKETS_MAX    25

class CHashTable
{
protected:
	DWORD				m_fInited : 1;
	DWORD               m_fBucketsAllocated : 1;
	CLinkElem *			m_pHead;
	CLinkElem *			m_pTail;
	CLinkElem **		m_rgpBuckets;
	HashFunction		m_pfnHash;
	UINT				m_cBuckets;
	UINT				m_Count;
	CLinkElem *         m_rgpBucketsBuffer[PREALLOCATED_BUCKETS_MAX];

protected:
    HRESULT             AllocateBuckets();
	virtual BOOL		FIsEqual( const void * pKey1, int cbKey1, const void * pKey2, int cbKey2 );

// inline access functions
public:
	CLinkElem *			Head(void);
	CLinkElem *			Tail(void);
	UINT				Buckets(void);
	UINT				Count(void);

public:
						CHashTable(HashFunction = DefaultHash);
	virtual				~CHashTable(void); // We allocate and need a destructor
	HRESULT				Init(UINT cBuckets = 11);
	HRESULT				UnInit(void);
	void				ReInit();
	CLinkElem *			AddElem(CLinkElem *pElem, BOOL fTestDups = TRUE);
	CLinkElem *			FindElem(const void *pKey, int cKeyLen);
	CLinkElem *			DeleteElem(const void *pKey, int cKeyLen);
	CLinkElem * 		RemoveElem( CLinkElem *pLE );

	void				AssertValid() const;
};

inline CLinkElem *	CHashTable::Head(void) { return m_pHead; }
inline CLinkElem *	CHashTable::Tail(void) { return m_pTail; }
inline UINT			CHashTable::Buckets(void) { return m_cBuckets; }
inline UINT			CHashTable::Count(void) { return m_Count; }

#ifndef DBG
inline void CHashTable::AssertValid() const {}
#endif


/*
 * CHashTableStr
 *
 * This is exactly the same as a CHashTable, but the elements are understood to be pointers
 * to Unicode strings, and the string compares are done **CASE INSENSITIVE**
 */
class CHashTableStr : public CHashTable
{
protected:
	BOOL				FIsEqual( const void * pKey1, int cbKey1, const void * pKey2, int cbKey2 );

public:
						CHashTableStr(HashFunction = UnicodeUpcaseHash);

};


/*
 * CHashTableMBStr
 *
 * This is exactly the same as a CHashTable, but the elements are understood to be pointers
 * to multi-byte strings, and the string compares are done **CASE INSENSITIVE**
 */
class CHashTableMBStr : public CHashTable
{
protected:
	BOOL				FIsEqual( const void * pKey1, int cbKey1, const void * pKey2, int cbKey2 );

public:
						CHashTableMBStr(HashFunction = MultiByteUpcaseHash);

};

/*
 * CHashTablePtr
 *
 * CHashTable where but the elements are hashed by pointers
 * used as DWORD hash values
 */
class CHashTablePtr : public CHashTable
{
protected:
	BOOL FIsEqual(const void *pKey1, int, const void *pKey2, int);

public:
	CHashTablePtr(HashFunction = PtrHash);
};

/*
 * CHashTableCLSID
 *
 * CHashTable where but the elements are hashed by CLSIDs
 */
class CHashTableCLSID : public CHashTable
{
protected:
	BOOL FIsEqual(const void *pKey1, int, const void *pKey2, int);

public:
	CHashTableCLSID(HashFunction = CLSIDHash);
};

#endif // HASHING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\glob.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Globals

File: glob.cpp

Owner: LeiJin

Implementation of Glob class functions
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "iiscnfgp.h"
#include "debugger.h"
#include "appcnfg.h"
#include "memchk.h"
#include "ftm.h"

HRESULT	ReadConfigFromMD(CIsapiReqInfo   *pIReq, CAppConfig *pAppConfig, BOOL fLoadGlob);
HRESULT MDUnRegisterProperties();
HRESULT MDRegisterProperties(void);

#define DEFAULTSTRSIZE 1024

#define dwUnlimited 0xFFFFFFFF
const DWORD dwMDDefaultTimeOut	= 2000;
enum eConfigType { eDLLConfig = 0, eAppConfig };

/*========================================================================================
The following array definition is for D1 to D2 migration only.  It contains the necessary
information reads from D1 ASP settings in registry.

=========================================================================================*/
typedef struct _D1propinfo
	{
	CHAR *szName;			// Name of the property in the registry
	DWORD dwType;			// Type (e.g. REG_DWORD, REG_SZ, etc)
	DWORD cbData;			// How long is the value
	VOID *pData;
	BOOL fSuccess;			// Load from registry successful or not.
	} D1PROPINFO;

#define NUM_D1PROP_NeedMigrated	18
// This index should be match the index in D1PropInfo.
enum D1PropIndex {
	D1Prop_NotExist	= -1,
	D1Prop_BufferingOn = 0,
	D1Prop_LogErrorRequests,
	D1Prop_ScriptErrorsSentToBrowser,
	D1Prop_ScriptErrorMessage,
	D1Prop_ScriptFileCacheSize,
	D1Prop_ScriptEngineCacheMax,
	D1Prop_ScriptTimeout,
	D1Prop_SessionTimeout,
//	D1Prop_MemFreeFactor,
//	D1Prop_MinUsedBlocks,
	D1Prop_AllowSessionState,
	D1Prop_DefaultScriptLanguage,
//	D1Prop_StartConnectionPool,
	D1Prop_AllowOutOfProcCmpnts,
	D1Prop_EnableParentPaths,
// IIS5.0 (from IIS4.0)
	D1Prop_EnableAspHtmlFallback,
	D1Prop_EnableChunkedEncoding,
	D1Prop_EnableTypelibCache,
	D1Prop_ErrorsToNtLog, 
	D1Prop_ProcessorThreadMax,
	D1Prop_RequestQueueMax
	};

// This flag is used only in setup time.
BOOL	g_fD1ConfigExist = FALSE;
// The index is defined in D1PropIndex.				
D1PROPINFO	D1PropInfo[] =
	{
	{	"BufferingOn", REG_DWORD, 0, 0, FALSE},
	{	"LogErrorRequests", REG_DWORD, 0, 0, FALSE},
	{	"ScriptErrorsSentToBrowser", REG_DWORD, 0, 0, FALSE},
	{	"ScriptErrorMessage", REG_SZ, 0, 0, FALSE},
	{	"ScriptFileCacheSize", REG_DWORD, 0, 0, FALSE},
	{	"ScriptEngineCacheMax", REG_DWORD, 0, 0, FALSE},
	{	"ScriptTimeout", REG_DWORD, 0, 0, FALSE},
	{	"SessionTimeout", REG_DWORD, 0, 0, FALSE},
	{	"AllowSessionState", REG_DWORD, 0, 0, FALSE},
	{	"DefaultScriptLanguage", REG_SZ, 0, 0, FALSE},
	{	"AllowOutOfProcCmpnts", REG_DWORD, 0, 0, FALSE},
	{	"EnableParentPaths", REG_DWORD, 0, 0, FALSE},
// IIS5.0 (from IIS4.0)
	{	"EnableAspHtmlFallback", REG_DWORD, 0, 0, FALSE},
	{	"EnableChunkedEncoding", REG_DWORD, 0, 0, FALSE},
	{	"EnableTypelibCache", REG_DWORD, 0, 0, FALSE},
	{	"ErrorsToNTLog", REG_DWORD, 0, 0, FALSE},
	{	"ProcessorThreadMax", REG_DWORD, 0, 0, FALSE},
	{	"RequestQueueMax", REG_DWORD, 0, 0, FALSE}
	
	};


/*
 * The following array contains all the info we need to create and load
 * all of the registry entries for denali.  See the above PROPINFO structure for details on each of the fields.
 *
 * NOTE: There is an odd thing about initializers and unions.  You must initialize a union with the value of
 * the type of the first element in the union.  In the anonymous union in the PROPINFO structure, we have defined
 * the first type to be DWORD.  Thus, for non-DWORD registry entries, the default value must be cast to a DWORD
 * before being initialized, or initialized using a more explicit mechanism.
 */
/*
 * Info about our properties used by Metabase
 */
typedef struct _MDpropinfo
	{
	INT	id;					// Identifier used in Glob if UserType is IIS_MD_UT_WAM,
							// Identifier used in AppConfig if UserType is ASP_MD_UT_APP.
	INT	iD1PropIndex;		// Index in D1PropInfo. if equals to -1, that it does not exist in D1.
	BOOL fAdminConfig;		// Admin Configurable
	DWORD dwMDIdentifier;	// Metabase identifier
	DWORD dwUserType;		// IIS_MD_UT_WAM(data per Dll) or ASP_MD_UT_APP(data per App)
	DWORD dwType;
	DWORD cbData;
	union					// Default Value
		{
		DWORD dwDefault;	// Default value for DWORDs
		INT idDefault;		// Default value for strings -- the id of the string in the resource
		BYTE *pbDefault;	// Pointer to arbitrary default value
		};
	DWORD dwValueMin;		// For DWORD registry entries, min value allowed
	DWORD dwValueMax;		// For DWORD registry entries, max value allowed
	} MDPROPINFO;

//Some default settings for ASP Metabase
#define ASP_MD_DAttributes	METADATA_INHERIT

const MDPROPINFO rgMDPropInfo[] =
				{

#define THREADGATING_DFLT 0L
#define BUFFERING_DFLT    1L
    //          ID                              D1PropIndex         AdminConfig?        Metabase ID                   UserType      Data Type           cbData    Def, Min, Max  

	// Glob Settings
	// -------------
	
	{ IGlob_LogErrorRequests,           D1Prop_LogErrorRequests,        TRUE,   MD_ASP_LOGERRORREQUESTS,            IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
    { IGlob_ScriptFileCacheSize,        D1Prop_ScriptFileCacheSize,     TRUE,   MD_ASP_SCRIPTFILECACHESIZE,         IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 250L, 0L, dwUnlimited},
	{ IGlob_ScriptEngineCacheMax,       D1Prop_ScriptEngineCacheMax,    TRUE,   MD_ASP_SCRIPTENGINECACHEMAX,        IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 125L, 0L, dwUnlimited},
				
//	{ IGlob_MemFreeFactor, D1Prop_MemFreeFactor, TRUE, MD_ASP_MEMFREEFACTOR, IIS_MD_UT_WAM, DWORD_METADATA, sizeof(DWORD), 50L, 1L, dwUnlimited},
//	{ IGlob_MinUsedBlocks, D1Prop_MinUsedBlocks, TRUE, MD_ASP_MINUSEDBLOCKS, IIS_MD_UT_WAM, DWORD_METADATA, sizeof(DWORD), 10L, 1L, dwUnlimited},
//	{ IGlob_StartConnectionPool, D1Prop_StartConnectionPool, FALSE, MD_ASP_STARTCONNECTIONPOOL, IIS_MD_UT_WAM, DWORD_METADATA, sizeof(DWORD), 0L, 0L, 1L},

	{ IGlob_ExceptionCatchEnable,       D1Prop_NotExist,                TRUE,   MD_ASP_EXCEPTIONCATCHENABLE,        IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IGlob_TrackThreadingModel,        D1Prop_NotExist,                TRUE,   MD_ASP_TRACKTHREADINGMODEL,         IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IGlob_AllowOutOfProcCmpnts,       D1Prop_AllowOutOfProcCmpnts,    FALSE,  MD_ASP_ALLOWOUTOFPROCCMPNTS,        IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	
	// IIS5.0
	{ IGlob_EnableAspHtmlFallback,      D1Prop_EnableAspHtmlFallback,   TRUE,   MD_ASP_ENABLEASPHTMLFALLBACK,       IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IGlob_EnableChunkedEncoding,      D1Prop_EnableChunkedEncoding,   TRUE,   MD_ASP_ENABLECHUNKEDENCODING,       IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IGlob_EnableTypelibCache,         D1Prop_EnableTypelibCache,      TRUE,   MD_ASP_ENABLETYPELIBCACHE,          IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IGlob_ErrorsToNtLog,              D1Prop_ErrorsToNtLog,           TRUE,   MD_ASP_ERRORSTONTLOG,               IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IGlob_ProcessorThreadMax,         D1Prop_ProcessorThreadMax,      TRUE,   MD_ASP_PROCESSORTHREADMAX,          IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 25L, 0L, dwUnlimited},
	{ IGlob_RequestQueueMax,            D1Prop_RequestQueueMax,         TRUE,   MD_ASP_REQEUSTQUEUEMAX,             IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 3000L, 0L, dwUnlimited},
	// thread gating
	{ IGlob_ThreadGateEnabled,          D1Prop_NotExist,                TRUE,   MD_ASP_THREADGATEENABLED,           IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), THREADGATING_DFLT, 0L, 1L},
	{ IGlob_ThreadGateTimeSlice,        D1Prop_NotExist,                TRUE,   MD_ASP_THREADGATETIMESLICE,         IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1000L, 100L, dwUnlimited},
	{ IGlob_ThreadGateSleepDelay,       D1Prop_NotExist,                TRUE,   MD_ASP_THREADGATESLEEPDELAY,        IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 100L, 10L, dwUnlimited},
	{ IGlob_ThreadGateSleepMax,         D1Prop_NotExist,                TRUE,   MD_ASP_THREADGATESLEEPMAX,          IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 50L, 1L, dwUnlimited},
	{ IGlob_ThreadGateLoadLow,          D1Prop_NotExist,                TRUE,   MD_ASP_THREADGATELOADLOW,           IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 50L, 0L, 100L},
	{ IGlob_ThreadGateLoadHigh,         D1Prop_NotExist,                TRUE,   MD_ASP_THREADGATELOADHIGH,          IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 80L, 0L, 100L},

    // Persisted Template Cache
	{ IGlob_PersistTemplateMaxFiles,    D1Prop_NotExist,                TRUE,   MD_ASP_MAXDISKTEMPLATECACHEFILES,   IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1000L,   0L, dwUnlimited},
    { IGlob_PersistTemplateDir,         D1Prop_NotExist,                TRUE,   MD_ASP_DISKTEMPLATECACHEDIRECTORY,  IIS_MD_UT_WAM, EXPANDSZ_METADATA, dwUnlimited, IDS_DEFAULTPERSISTDIR, 0L, dwUnlimited},
	

    // Application settings
	// --------------------
	
	{ IApp_AllowSessionState,           D1Prop_AllowSessionState,       TRUE,   MD_ASP_ALLOWSESSIONSTATE,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IApp_BufferingOn,                 D1Prop_BufferingOn,             TRUE,   MD_ASP_BUFFERINGON,                 ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), BUFFERING_DFLT, 0L, 1L},
	{ IApp_ScriptLanguage,              D1Prop_DefaultScriptLanguage,   TRUE,   MD_ASP_SCRIPTLANGUAGE,              ASP_MD_UT_APP, STRING_METADATA, dwUnlimited, IDS_SCRIPTLANGUAGE, 0L, dwUnlimited},
	{ IApp_EnableParentPaths,           D1Prop_EnableParentPaths,       TRUE,   MD_ASP_ENABLEPARENTPATHS,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IApp_ScriptErrorMessage,          D1Prop_ScriptErrorMessage,      TRUE,   MD_ASP_SCRIPTERRORMESSAGE,          ASP_MD_UT_APP, STRING_METADATA, dwUnlimited, IDS_DEFAULTMSG_ERROR, 0L, dwUnlimited},
	{ IApp_SessionTimeout,              D1Prop_SessionTimeout,          TRUE,   MD_ASP_SESSIONTIMEOUT,              ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 20L, 1L, dwUnlimited},
	{ IApp_QueueTimeout,                D1Prop_NotExist,                TRUE,   MD_ASP_QUEUETIMEOUT,                ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), dwUnlimited, 1L, dwUnlimited},
	{ IApp_CodePage,                    D1Prop_NotExist,                TRUE,   MD_ASP_CODEPAGE,                    ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), CP_ACP, 0L, dwUnlimited},
	{ IApp_ScriptTimeout,               D1Prop_ScriptTimeout,           TRUE,   MD_ASP_SCRIPTTIMEOUT,               ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 90L, 1L, dwUnlimited},
	{ IApp_ScriptErrorsSenttoBrowser,   D1Prop_ScriptErrorsSentToBrowser, TRUE, MD_ASP_SCRIPTERRORSSENTTOBROWSER,   ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IApp_AllowDebugging,              D1Prop_NotExist,                TRUE,   MD_ASP_ENABLESERVERDEBUG,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IApp_AllowClientDebug,            D1Prop_NotExist,                TRUE,   MD_ASP_ENABLECLIENTDEBUG,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IApp_KeepSessionIDSecure,        D1Prop_NotExist,                TRUE,   MD_ASP_KEEPSESSIONIDSECURE,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},	

	// IIS5.0
	{ IApp_EnableApplicationRestart,    D1Prop_NotExist,                TRUE,   MD_ASP_ENABLEAPPLICATIONRESTART,    ASP_MD_UT_APP, DWORD_METADATA, sizeof(DWORD), 1L, 0L, 1L},
	{ IApp_QueueConnectionTestTime,     D1Prop_NotExist,                TRUE,   MD_ASP_QUEUECONNECTIONTESTTIME,     ASP_MD_UT_APP, DWORD_METADATA, sizeof(DWORD), 3L, 1L, dwUnlimited},
	{ IApp_SessionMax,                  D1Prop_NotExist,                TRUE,   MD_ASP_SESSIONMAX,                  ASP_MD_UT_APP, DWORD_METADATA, sizeof(DWORD), dwUnlimited, 1L, dwUnlimited},

    // IIS5.1
	{ IApp_ExecuteInMTA,                D1Prop_NotExist,                TRUE,   MD_ASP_EXECUTEINMTA,                ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1},
    { IApp_LCID,                        D1Prop_NotExist,                TRUE,   MD_ASP_LCID,                        ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), LOCALE_SYSTEM_DEFAULT, 0L, dwUnlimited}

	};

const DWORD rgdwMDObsoleteIdentifiers[] =
    {MD_ASP_MEMFREEFACTOR,
     MD_ASP_MINUSEDBLOCKS
    };
    
const UINT cPropsMax = sizeof(rgMDPropInfo) / sizeof(MDPROPINFO);


/*===================================================================
ReadAndRemoveOldD1PropsFromRegistry

Reads whatever old D1 properties are in the registry and
stores the values into D1PropInfo[] global array.
Removes the old properties found from the registry.

Returns:
	HRESULT	- S_OK on success

Side effects:
	Fills in values in Glob
===================================================================*/
BOOL ReadAndRemoveOldD1PropsFromRegistry()
{
	HKEY		hkey = NULL;
	DWORD		iValue;
	BYTE		cTrys = 0;
	DWORD		dwType;
	BYTE		bData[DEFAULTSTRSIZE];			// Size???
	BYTE		*lpRegString = NULL;			// need to use dynamic allocation when we have ERROR_MORE_DATA
	DWORD		cbData;
	HRESULT 	hr = S_OK;

	// Open the key for W3SVC\ASP\Parameters
	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\W3SVC\\ASP\\Parameters", 0, KEY_READ|KEY_WRITE, &hkey) != ERROR_SUCCESS)
		return(FALSE);

	// Load each of the values
	for (iValue = 0; iValue < NUM_D1PROP_NeedMigrated; iValue++)
		{
		LONG err;
		D1PROPINFO *pPropInfo;

		pPropInfo = &D1PropInfo[iValue];

		cbData = sizeof(bData);
		err = RegQueryValueExA(hkey, pPropInfo->szName, 0, &dwType, bData, &cbData);

		if (err == ERROR_MORE_DATA)
			{
			lpRegString = (BYTE *)GlobalAlloc(GPTR, cbData);
			err = RegQueryValueExA(hkey, pPropInfo->szName, 0, &dwType, lpRegString, &cbData);
			}

		// if get an error, or not the type we expect, then use the default
		if (err != ERROR_SUCCESS || dwType != pPropInfo->dwType)
			{
			pPropInfo->fSuccess = FALSE;
			continue;
			}
			
		// Success : Got the data, copy it into Glob
		// But first, if this is a DWORD type, make sure it is within allowed Max/Min range
		switch (pPropInfo->dwType)
			{
			case REG_DWORD:
				Assert(cbData == sizeof(DWORD));
				if (cbData == sizeof(DWORD))
					{
					pPropInfo->cbData = cbData;
					pPropInfo->pData = (VOID *)UIntToPtr((*(DWORD *)bData));
					pPropInfo->fSuccess = TRUE;
					}
				break;

			case REG_SZ:		
				if (lpRegString == NULL)
					{	// The string fit into default allocation
					lpRegString = (BYTE *)GlobalAlloc(GPTR, cbData * sizeof(WCHAR));
					if (lpRegString == NULL)
						return FALSE;

					MultiByteToWideChar(CP_ACP, 0, (LPCSTR)bData, -1, (LPWSTR)lpRegString, cbData);
					}
					
				pPropInfo->cbData = cbData * sizeof(WCHAR);
				pPropInfo->pData = (VOID *)lpRegString;
				pPropInfo->fSuccess = TRUE;
				lpRegString = NULL;
				break;
			}

		// remove the value from the registry
		RegDeleteValueA(hkey, pPropInfo->szName);
		}

    // remove some old properties that 'get lost' in the upgrade
	RegDeleteValueA(hkey, "CheckForNestedVroots");
	RegDeleteValueA(hkey, "EventLogDirection");
	RegDeleteValueA(hkey, "ScriptFileCacheTTL");
	RegDeleteValueA(hkey, "StartConnectionPool");
	RegDeleteValueA(hkey, "NumInitialThreads");
	RegDeleteValueA(hkey, "ThreadCreationThreshold");
	RegDeleteValueA(hkey, "MinUsedBlocks");
	RegDeleteValueA(hkey, "MemFreeFactor");
	RegDeleteValueA(hkey, "MemClsFreeFactor");
	RegDeleteValueA(hkey, "ThreadDeleteDelay");
	RegDeleteValueA(hkey, "ViperRequestQueueMax");

	RegCloseKey(hkey);

	// remove the W3SVC\ASP\Paramaters key
	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\W3SVC\\ASP", 0, KEY_READ|KEY_WRITE, &hkey) == ERROR_SUCCESS)
	    {
        RegDeleteKeyA(hkey, "Parameters");
    	RegCloseKey(hkey);
	    }
	    
	// remove the W3SVC\ASP key
	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\W3SVC", 0, KEY_READ|KEY_WRITE, &hkey) == ERROR_SUCCESS)
	    {
        RegDeleteKeyA(hkey, "ASP");
    	RegCloseKey(hkey);
	    }
	
	return TRUE;
}

/*==================================================================
MDRegisterProperties
Register info about our properties in the metabase.  This funtion is
called during regsvr32, self-registration time.

Returns:
	HRESULT	- S_OK on success

Side effects:
	Registers denali properties in the metabase
===================================================================*/
HRESULT MDRegisterProperties(void)
{
	HRESULT	hr = S_OK;
	DWORD	iValue;
	IMSAdminBase	*pMetabase = NULL;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	BYTE	szDefaultString[2*DEFAULTSTRSIZE];
	HRESULT	hrT = S_OK;
	BOOL	fNeedMigrated;

	fNeedMigrated = ReadAndRemoveOldD1PropsFromRegistry();

	hr = CoInitialize(NULL);
	if (FAILED(hr))
		{
		return hr;
		}

	hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_SERVER, IID_IMSAdminBase, (void **)&pMetabase);
	if (FAILED(hr))
		{
		CoUninitialize();
		return hr;
		}
		
	// Open key to the Web service, and get a handle of \LM\w3svc
	hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)(L"\\LM\\W3SVC"),
							METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
							dwMDDefaultTimeOut, &hMetabase);
	if (FAILED(hr))
		{
		goto LExit;
		}

    //
    // Remove obsolete metabase settings
    // See rgdwMDObsoleteIdentifiers structure for detail list of properties
    //
    for (iValue = 0; iValue < sizeof(rgdwMDObsoleteIdentifiers)/sizeof(DWORD);
        iValue++)
        {
        hr = pMetabase->DeleteData( hMetabase,
                                    NULL,
                                    rgdwMDObsoleteIdentifiers[iValue],
                                    0);
        if (FAILED(hr))
            {
            if (hr == MD_ERROR_DATA_NOT_FOUND)
                {
                hr = S_OK;
                }
            else
                {
                Assert(FALSE);
                }
            }
        }

    //
    // Set metabase properties
    //
	recMetaData.dwMDDataTag = 0;	// this parameter is not used when setting data
	for (iValue = 0; iValue < cPropsMax; iValue++)
		{
		INT	    cch;
		BYTE    aByte[4]; // Temporary buffer
		DWORD   dwLen;
		D1PROPINFO *pD1PropInfo;
		recMetaData.dwMDIdentifier = rgMDPropInfo[iValue].dwMDIdentifier;
		recMetaData.dwMDAttributes = METADATA_INHERIT;
		recMetaData.dwMDUserType = rgMDPropInfo[iValue].dwUserType;
		recMetaData.dwMDDataType = rgMDPropInfo[iValue].dwType;

        dwLen = 0;
        recMetaData.dwMDDataLen = 0;
		recMetaData.pbMDData = (unsigned char *)aByte;

        HRESULT hrGetData = pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwLen);
		
		if (hrGetData == MD_ERROR_DATA_NOT_FOUND)
		    {
		    switch (rgMDPropInfo[iValue].dwType)
    			{
    			case DWORD_METADATA:
    			
    				if (fNeedMigrated && rgMDPropInfo[iValue].iD1PropIndex != D1Prop_NotExist )
    					{
    					pD1PropInfo = &D1PropInfo[rgMDPropInfo[iValue].iD1PropIndex];
    					if (pD1PropInfo->fSuccess == TRUE)
    						{
    						recMetaData.dwMDDataLen = pD1PropInfo->cbData;
    						recMetaData.pbMDData = (unsigned char *)&(pD1PropInfo->pData);
    						break;
    						}
    					}
    				// Did not migrated.		
    				recMetaData.dwMDDataLen = rgMDPropInfo[iValue].cbData;
    				recMetaData.pbMDData = (unsigned char *)&(rgMDPropInfo[iValue].dwDefault);
    				break;
    				
                case EXPANDSZ_METADATA:
    			case STRING_METADATA:
    				if (fNeedMigrated && rgMDPropInfo[iValue].iD1PropIndex != D1Prop_NotExist )
    					{
    					pD1PropInfo = &D1PropInfo[rgMDPropInfo[iValue].iD1PropIndex];
    					if (pD1PropInfo->fSuccess == TRUE)
    						{
    						recMetaData.dwMDDataLen = pD1PropInfo->cbData;
    						recMetaData.pbMDData = (unsigned char *)(pD1PropInfo->pData);
    						break;
    						}
    					}

    				// Did not migrated
    				cch = CwchLoadStringOfId(rgMDPropInfo[iValue].idDefault, (LPWSTR)szDefaultString, DEFAULTSTRSIZE);
    				if (cch == 0)
    					{
    					DBGPRINTF((DBG_CONTEXT, "LoadString failed, id = %d\n", rgMDPropInfo[iValue].idDefault));
    					}
    				recMetaData.dwMDDataLen = (cch + 1)*sizeof(WCHAR);
    				recMetaData.pbMDData = szDefaultString;
    				break;
    				
    			default:
    				// So far, DWORD and STRING are the only 2 types.
    				// Never reach this code path.
    				Assert(FALSE);
    				continue;
    			}
    			
    		// not found - then set
    		hr = pMetabase->SetData(hMetabase, NULL,  &recMetaData);
    		}
        else
            {
    		// don't change if the data is already in the metabase
            hr = S_OK;
            }
            
    	if (FAILED(hr))
	    	{
	    	DBGPRINTF((DBG_CONTEXT, "Metabase SetData failed, identifier = %08x.\n", rgMDPropInfo[iValue].dwMDIdentifier));
		    }
		}
	hrT = pMetabase->CloseKey(hMetabase);

	if (fNeedMigrated)
		{
		if (D1PropInfo[D1Prop_DefaultScriptLanguage].pData != NULL)
			{
			GlobalFree(D1PropInfo[D1Prop_DefaultScriptLanguage].pData);
			}
			
		if (D1PropInfo[D1Prop_ScriptErrorMessage].pData != NULL)
			{
			GlobalFree(D1PropInfo[D1Prop_ScriptErrorMessage].pData);
			}
		}
	//
LExit:
	if (pMetabase)
		pMetabase->Release();

	CoUninitialize();
	
	return hr;
}

/*===================================================================
SetConfigToDefaults

Before loading values from the Metabase, set up default values
in case anything goes wrong.

Parameters:
	CAppConfig	Application Config Object / per application
	fLoadGlob	if fLoadGlob is TRUE, load glob data, otherwise, load data into AppConfig object.

Returns:
	HRESULT	- S_OK on success

Side effects:
===================================================================*/
HRESULT	SetConfigToDefaults(CAppConfig *pAppConfig, BOOL fLoadGlob)
{
	HRESULT 			hr = S_OK;
	DWORD				dwMDUserType = 0;
	BYTE				*szRegString	= NULL;
	UINT 				iEntry = 0;

	if (fLoadGlob)
		{
		dwMDUserType = IIS_MD_UT_WAM;
		}
	else
		{
		dwMDUserType = ASP_MD_UT_APP;
		}

	for(iEntry = 0; iEntry < cPropsMax; iEntry++)
		{
		if (rgMDPropInfo[iEntry].dwUserType != dwMDUserType)
			continue;

		// After metabase has been read once, data with fAdminConfig = FALSE cant be changed on the fly.
		// so we dont bother to reset it
		if (fLoadGlob)
			{
			if (TRUE == Glob(fMDRead) && FALSE == rgMDPropInfo[iEntry].fAdminConfig)
				{
				continue;
				}
			}
		else
			{
			if (TRUE == pAppConfig->fInited() && FALSE == rgMDPropInfo[iEntry].fAdminConfig)
				{
				continue;
				}
			}
			
		switch (rgMDPropInfo[iEntry].dwType)
			{
			case DWORD_METADATA:
				if (fLoadGlob)
					gGlob.SetGlobValue(rgMDPropInfo[iEntry].id, (BYTE *)&rgMDPropInfo[iEntry].dwDefault);
				else
					hr = pAppConfig->SetValue(rgMDPropInfo[iEntry].id, (BYTE *)&rgMDPropInfo[iEntry].dwDefault);
				break;
				
			case STRING_METADATA:
            case EXPANDSZ_METADATA:
				szRegString = (BYTE *)GlobalAlloc(GPTR, DEFAULTSTRSIZE);
                if (szRegString == NULL) {
                    hr = E_OUTOFMEMORY;
                    break;
                }
				CchLoadStringOfId(rgMDPropInfo[iEntry].idDefault, (LPSTR)szRegString, DEFAULTSTRSIZE);
                if (rgMDPropInfo[iEntry].dwType == EXPANDSZ_METADATA) {
                    BYTE  *pszExpanded = (BYTE *)GlobalAlloc(GPTR, DEFAULTSTRSIZE);
                    if (pszExpanded == NULL) {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    INT result = ExpandEnvironmentStringsA((LPCSTR)szRegString,
                                                           (LPSTR)pszExpanded,
                                                           DEFAULTSTRSIZE);   
                    if ((result <= DEFAULTSTRSIZE) && (result > 0)) {
                        GlobalFree(szRegString);
                        szRegString = pszExpanded;
                    }
                }                                                         
				if (fLoadGlob)
					gGlob.SetGlobValue(rgMDPropInfo[iEntry].id, (BYTE *)(&szRegString));
				else
					hr = pAppConfig->SetValue(rgMDPropInfo[iEntry].id, (BYTE *)(&szRegString));
				break;
				
			default:
				Assert(FALSE);
				break;
			}
		}

	// Disable caching in Win95
	// Registry get read only once in the Init time in Win95.
	// So, set those caching related values here.
	if(!gGlob.m_fWinNT)
		{
		gGlob.m_dwScriptFileCacheSize = 0;
		gGlob.m_dwScriptEngineCacheMax = 0;
		}

	return hr;
}

/*===================================================================
ReadConfigFromMD

Read our properties from the registry.  If our props are missing, the
registry is messed up, try to re-register.  If our props are there, but
one or more values is missing, use the defaults.

Parameters:
	CAppConfig	Application Config Object / per application
	fLoadGlob	if fLoadGlob is TRUE, load glob data, otherwise, load data into AppConfig object.

Returns:
	HRESULT	- S_OK on success

Side effects:
===================================================================*/
HRESULT	ReadConfigFromMD
(
CIsapiReqInfo   *pIReq,
CAppConfig *pAppConfig,
BOOL fLoadGlob
)
{
	HRESULT 			hr = S_OK;
	HRESULT 			hrT = S_OK;
	DWORD				dwNumDataEntries = 0;
	DWORD				cbRequired = 0;
	DWORD				dwMDUserType = 0;
	DWORD        		cbBuffer;
	BYTE				bBuffer[2000];
	BYTE				*pBuffer = NULL;
	BYTE				*szRegString	= NULL;
	BOOL				fAllocBuffer = FALSE;
	CHAR				szMDOORange[DEFAULTSTRSIZE];
	TCHAR				szMDGlobPath[] = _T("\\LM\\W3SVC");
	TCHAR				*szMDPath = NULL;
	UINT 				iEntry = 0;
	METADATA_GETALL_RECORD	*pMDGetAllRec;
	
	if (fLoadGlob)
		{
		// BUGs 88902, 105745:
		// If we are InProc, then use the "root" path for global values
		// If OutOfProc, then use the app path for global values
		if (pIReq->FInPool())
	    	szMDPath = szMDGlobPath;
	    else
	    	szMDPath = pIReq->QueryPszApplnMDPath();

   		dwMDUserType = IIS_MD_UT_WAM;
		}
	else
		{
		dwMDUserType = ASP_MD_UT_APP;
		szMDPath = pAppConfig->SzMDPath();
		}

	Assert(szMDPath != NULL);

	// PreLoad config data with default, in case anything failed.
    hr = SetConfigToDefaults(pAppConfig, fLoadGlob);
    if (FAILED(hr))
        {
        Assert(FALSE);
        DBGPRINTF((DBG_CONTEXT,"ReadConfigFromMD: Setting defaults failed with %x\n",hr));
		return hr;
		}

	// Set flags.
	//
	BOOL fConfigLoaded[cPropsMax];
	for (iEntry = 0; iEntry < cPropsMax; iEntry++) {
		fConfigLoaded[iEntry] = FALSE;
    }

	pBuffer = bBuffer;
    hr = pIReq->GetAspMDAllData(szMDPath, 
								dwMDUserType,
								sizeof(bBuffer),
								(unsigned char *)pBuffer,
								&cbRequired,
								&dwNumDataEntries
								);
								
    if (hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
		pBuffer = (BYTE *)GlobalAlloc(GPTR, cbRequired);
		if (pBuffer == NULL)
			return E_OUTOFMEMORY;

		fAllocBuffer = TRUE;
		cbBuffer = cbRequired;
        hr = pIReq->GetAspMDAllData(szMDPath, 
								    dwMDUserType,
								    cbRequired,
								    (unsigned char *)pBuffer,
								    &cbRequired,
								    &dwNumDataEntries);
    }

	if (FAILED(hr)) {
        DBGPRINTF((DBG_CONTEXT,"ReadConfigFromMD: GetAspMDAllData failed with %x\n",hr));
		return hr;
    }
    else {
		INT	cProps = 0;
		
		pMDGetAllRec = (METADATA_GETALL_RECORD *)pBuffer;
		for (UINT iValue = 0; iValue < dwNumDataEntries; iValue ++)
			{
			DWORD dwData;
			DWORD iTemp;
			DWORD cbStr;
			CHAR szMDOORangeFormat[DEFAULTSTRSIZE];

			// Init iEntry to be -1, -1 is invalid for rgMDPropInfo[] Array Index.
			iEntry = -1;
			for (iTemp = 0; iTemp < cPropsMax; iTemp++) {
				if (rgMDPropInfo[iTemp].dwMDIdentifier == pMDGetAllRec->dwMDIdentifier) {
					iEntry = iTemp;
					break;
                }
            }

			// Not found
			if (iEntry == -1) {
				pMDGetAllRec++;
				continue;
            }

			// Do found the entry in rgMDPropInfo, but datatype does not match.
			// Should never happen.
			if (rgMDPropInfo[iEntry].dwUserType != dwMDUserType) {	// GetAllData should filter out the unwanted UserType.
				Assert(FALSE);
				pMDGetAllRec++;
				continue;
            }

			cProps++;
			
			// After metabase has been read once, data with fAdminConfig = FALSE cant be changed on the fly.
			// so we dont bother to reread it
			if (fLoadGlob) {
				if (TRUE == Glob(fMDRead) && FALSE == rgMDPropInfo[iEntry].fAdminConfig) {
					pMDGetAllRec++;
					continue;
                }
			}
			else {
				if (TRUE == pAppConfig->fInited() && FALSE == rgMDPropInfo[iEntry].fAdminConfig) {
					pMDGetAllRec++;
					continue;
                }
            }
				
			switch(pMDGetAllRec->dwMDDataType) {
				case DWORD_METADATA:
					Assert(pMDGetAllRec->dwMDDataLen == sizeof(DWORD));

					dwData = *(UNALIGNED64 DWORD *)(pBuffer + pMDGetAllRec->dwMDDataOffset);

                    if (dwData > rgMDPropInfo[iEntry].dwValueMax) {
						szMDOORange[0] = '\0';
						CchLoadStringOfId(IDS_MDOORANGE_FORMAT, szMDOORangeFormat, DEFAULTSTRSIZE);
						sprintf(szMDOORange, szMDOORangeFormat,
							rgMDPropInfo[iEntry].dwMDIdentifier,	
							rgMDPropInfo[iEntry].dwValueMax);
						MSG_Warning((LPCSTR)szMDOORange);

						dwData = rgMDPropInfo[iEntry].dwValueMax;
                    }

					if (dwData < rgMDPropInfo[iEntry].dwValueMin) {
						szMDOORange[0] = '\0';
						CchLoadStringOfId(IDS_MDOORANGE_FORMAT, szMDOORangeFormat, DEFAULTSTRSIZE);
						sprintf(szMDOORange, szMDOORangeFormat,
							rgMDPropInfo[iEntry].dwMDIdentifier,	
							rgMDPropInfo[iEntry].dwValueMin);
						MSG_Warning((LPCSTR)szMDOORange);

						dwData = rgMDPropInfo[iEntry].dwValueMin;
                    }
					
					if (fLoadGlob)
						gGlob.SetGlobValue(rgMDPropInfo[iEntry].id, (BYTE *)&dwData);
					else
						pAppConfig->SetValue(rgMDPropInfo[iEntry].id, (BYTE *)&dwData);

					fConfigLoaded[iEntry] = TRUE;

					break;
					
				case STRING_METADATA:
                case EXPANDSZ_METADATA:
					// bug fix 102010 DBCS fixes (& 99806)
					//cbStr = (pMDGetAllRec->dwMDDataLen) / sizeof(WCHAR);
					cbStr = pMDGetAllRec->dwMDDataLen;
					szRegString = (BYTE *)GlobalAlloc(GPTR, cbStr);
                    if (szRegString == NULL) {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
					WideCharToMultiByte(CP_ACP, 0, (LPWSTR)(pBuffer + pMDGetAllRec->dwMDDataOffset), -1,
						(LPSTR)szRegString, cbStr, NULL, NULL);
                    if (pMDGetAllRec->dwMDDataType == EXPANDSZ_METADATA) {
                        BYTE  *pszExpanded = (BYTE *)GlobalAlloc(GPTR, DEFAULTSTRSIZE);
                        if (pszExpanded == NULL) {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        INT result = ExpandEnvironmentStringsA((LPCSTR)szRegString,
                                                               (LPSTR)pszExpanded,
                                                               DEFAULTSTRSIZE);   
                        if ((result <= DEFAULTSTRSIZE) && (result > 0)) {
                            GlobalFree(szRegString);
                            szRegString = pszExpanded;
                        }
                    }                                                         
					if (fLoadGlob)
						gGlob.SetGlobValue(rgMDPropInfo[iEntry].id, (BYTE *)(&szRegString));
					else
						pAppConfig->SetValue(rgMDPropInfo[iEntry].id, (BYTE *)(&szRegString));

					fConfigLoaded[iEntry] = TRUE;
					szRegString = NULL;
					break;
					
				default:
					Assert(FALSE);
					break;
			}
            pMDGetAllRec++;
        }
    }

	BOOL fHasLoadError;
	for (iEntry = 0, fHasLoadError = FALSE; iEntry < cPropsMax && fHasLoadError == FALSE; iEntry++) {
		//
		// Check LoadError in Glob config settings when fLoadGlob is TRUE
		// Check LoadError in App Config settings when fLoadGlob is FALSE
		//
		if ((fLoadGlob && rgMDPropInfo[iEntry].dwUserType == IIS_MD_UT_WAM) ||
			(!fLoadGlob && rgMDPropInfo[iEntry].dwUserType ==ASP_MD_UT_APP)) {
			fHasLoadError = (fConfigLoaded[iEntry]) ? FALSE : TRUE;
        }
    }

	if (fHasLoadError) {			
		// Reuse szMDOORange as the error logging buffer
		szMDOORange[0] = '\0';
		CchLoadStringOfId(IDS_RE_REGSVR_ASP, szMDOORange, DEFAULTSTRSIZE);
		MSG_Error((LPCSTR)szMDOORange);
		//hr = E_FAIL;
    }
	
    if (SUCCEEDED(hr) && !gGlob.m_fMDRead &fLoadGlob)
        gGlob.m_fMDRead = TRUE;

	if (fAllocBuffer == TRUE) {
		GlobalFree(pBuffer);
    }

	return hr;
}

/*==================================================================
CMDGlobConfigSink::QueryInterface

Returns:
	HRESULT	- S_OK on success

Side effects:
===================================================================*/
STDMETHODIMP CMDGlobConfigSink::QueryInterface(REFIID iid, void **ppv)
	{
	*ppv = NULL;
	
	if (iid == IID_IUnknown || iid == IID_IMSAdminBaseSink)
		*ppv = (IMSAdminBaseSink *)this;
	else
		return ResultFromScode(E_NOINTERFACE);

	((IUnknown *)*ppv)->AddRef();
	return S_OK;
	}

/*==================================================================
CMDGlobConfigSink::AddRef

Returns:
	ULONG	- The new ref counter of object

Side effects:
===================================================================*/
STDMETHODIMP_(ULONG) CMDGlobConfigSink::AddRef(void)
	{
	LONG  cRefs = InterlockedIncrement((long *)&m_cRef);
	return cRefs;
	}

/*==================================================================
CMDGlobConfigSink::Release

Returns:
	ULONG	- The new ref counter of object

Side effects: Delete object if ref counter is zero.
===================================================================*/
STDMETHODIMP_(ULONG) CMDGlobConfigSink::Release(void)
	{
	LONG  cRefs = InterlockedDecrement((long *)&m_cRef);
	if (cRefs == 0)
		{
		delete this;
		}
	return cRefs;
	}

/*==================================================================
CMDGlobConfigSink::SinkNotify

Returns:
	HRESULT	- S_OK on success

Side effects: Set fNeedUpdate to TRUE, and glob data will gets update next time a request coming in.
===================================================================*/
STDMETHODIMP	CMDGlobConfigSink::SinkNotify(
				DWORD	dwMDNumElements,
				MD_CHANGE_OBJECT_W	__RPC_FAR	pcoChangeList[])
	{
    if (IsShutDownInProgress())
        return S_OK;
        
        
	UINT	iEventNum = 0;
	DWORD	iDataIDNum = 0;
	WCHAR	wszMDPath[] = L"/LM/W3SVC/";
	UINT	cSize = 0;


	cSize = wcslen(wszMDPath);
	for (iEventNum = 0; iEventNum < dwMDNumElements; iEventNum++)
		{
		if (0 == wcsnicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath, cSize + 1))
			{
			for (iDataIDNum = 0; iDataIDNum < pcoChangeList[iEventNum].dwMDNumDataIDs; iDataIDNum++)
				{
				if (pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] >= ASP_MD_SERVER_BASE
					&& pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] <= MD_ASP_ID_LAST)
					{
					gGlob.NotifyNeedUpdate();
					return S_OK;
					}

				}
			}
		}

	return S_OK;
	}

/*===================================================================
MDUnRegisterProperties

Remove info about our properties in the Metabase.

Returns:
	HRESULT	- S_OK on success

Side effects:
	Removes denali properties in the Metabase

	// to settings per dll.
===================================================================*/
HRESULT MDUnRegisterProperties(void)
{
	HRESULT	hr = S_OK;
	DWORD	iValue;
	IMSAdminBase	*pMetabase = NULL;
	METADATA_HANDLE hMetabase = NULL;
	BYTE	szDefaultString[DEFAULTSTRSIZE];
	BOOL	fMDSaveData = TRUE;
	HRESULT	hrT = S_OK;

	hr = CoInitialize(NULL);
	if (FAILED(hr))
		{
		return hr;
		}

	hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_SERVER, IID_IMSAdminBase, (void **)&pMetabase);
	if (FAILED(hr))
		{
		CoUninitialize();
		return hr;
		}
		
	// Open key to the Web service, and get a handle of \LM\w3svc
	hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)L"\\LM\\W3SVC",
										METADATA_PERMISSION_WRITE, dwMDDefaultTimeOut, &hMetabase);
	if (FAILED(hr))
		{
		goto LExit;
		}

	for (iValue = 0; iValue < cPropsMax; iValue++)
		{
		hr = pMetabase->DeleteData(	hMetabase,
									NULL,
									rgMDPropInfo[iValue].dwMDIdentifier,
									0);
		if (FAILED(hr))
			{
			if (hr == MD_ERROR_DATA_NOT_FOUND)
				{
				hr = S_OK;
				}
			else
				{
				Assert(FALSE);
				}
			}
		}

	hrT = pMetabase->CloseKey(hMetabase);
	// Add data to W3SVC
LExit:
	if (pMetabase)
		pMetabase->Release();

	CoUninitialize();
	
	return hr;
}
/*===================================================================
Cglob::CGlob

Constructor.  Fill glob with some default values.

in:

returns:

Side effects:
===================================================================*/
CGlob::CGlob()
	:
	m_pITypeLibDenali(NULL),	
	m_fWinNT(TRUE),			
    m_dwNumberOfProcessors(1),
	m_fInited(FALSE),
	m_fMDRead(FALSE),
	m_fNeedUpdate(TRUE),			
	m_dwScriptEngineCacheMax(120),
	m_dwScriptFileCacheSize(dwUnlimited),
	m_fLogErrorRequests(TRUE),
	m_fExceptionCatchEnable(TRUE),
	m_fAllowOutOfProcCmpnts(FALSE),
	m_fAllowDebugging(FALSE),
	m_fTrackThreadingModel(FALSE),
	m_dwMDSinkCookie(0),
	m_pMetabaseSink(NULL),
    m_pMetabase(NULL),
	m_fEnableAspHtmlFallBack(FALSE),
	m_fEnableTypelibCache(TRUE),
	m_fEnableChunkedEncoding(TRUE),  // UNDONE: temp.
	m_fDupIISLogToNTLog(FALSE),
	m_dwRequestQueueMax(500),        // default limit on # of requests
	m_dwProcessorThreadMax(10),
	m_fThreadGateEnabled(FALSE),
	m_dwThreadGateTimeSlice(1000),
	m_dwThreadGateSleepDelay(100),
	m_dwThreadGateSleepMax(50),
	m_dwThreadGateLoadLow(75),
	m_dwThreadGateLoadHigh(90),
    m_dwPersistTemplateMaxFiles(1000),
    m_pszPersistTemplateDir(NULL)
	{
	OSVERSIONINFO osv;
	SYSTEM_INFO	si;
	BOOL fT;
	
	// Check the OS we are running on
	osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	fT = GetVersionEx( &osv );
	Assert( fT );
	m_fWinNT = ( osv.dwPlatformId == VER_PLATFORM_WIN32_NT );

	// Find out how many processors are on this machine
	GetSystemInfo(&si);
	m_dwNumberOfProcessors = si.dwNumberOfProcessors;
	if (m_dwNumberOfProcessors <= 0)
		{
		m_dwNumberOfProcessors = 1;		// Just in case!
		}
	}

/*===================================================================
Cglob::SetGlobValue

Set global values.

in:
	int 	index		the index in the propinfo[]
	BYTE*	pData		lp to the Data being copied/assigned in the glob.

returns:
	BOOL	TRUE/FALSE

Side effects:
	Free old string memory and allocate new memory for string.
===================================================================*/
HRESULT	CGlob::SetGlobValue(unsigned int iValue, BYTE *pData)
{
	Assert((iValue < IGlob_MAX) && (pData != NULL));
	
	switch(iValue) {
		case IGlob_LogErrorRequests:
			InterlockedExchange((LPLONG)&m_fLogErrorRequests, *(LONG *)pData);
			break;

		case IGlob_ScriptFileCacheSize:
			InterlockedExchange((LPLONG)&m_dwScriptFileCacheSize, *(LONG *)pData);
			break;
			
		case IGlob_ScriptEngineCacheMax:
			InterlockedExchange((LPLONG)&m_dwScriptEngineCacheMax, *(LONG *)pData);
			break;

//		case IGlob_MemFreeFactor:
//			InterlockedExchange((LPLONG)&m_dwMemFreeFactor, *(LONG *)pData);
//			break;

//		case IGlob_MinUsedBlocks:
//			InterlockedExchange((LPLONG)&m_dwMinUsedBlocks, *(LONG *)pData);
//			break;

//		case IGlob_StartConnectionPool:
//			InterlockedExchange((LPLONG)&m_fStartConnectionPool, *(LONG *)pData);
//			break;

		case IGlob_ExceptionCatchEnable:
			InterlockedExchange((LPLONG)&m_fExceptionCatchEnable, *(LONG *)pData);
			break;

		case IGlob_TrackThreadingModel:
			InterlockedExchange((LPLONG)&m_fTrackThreadingModel, *(LONG *)pData);
			break;
			
		case IGlob_AllowOutOfProcCmpnts:
			InterlockedExchange((LPLONG)&m_fAllowOutOfProcCmpnts, *(LONG *)pData);
			break;

        case IGlob_EnableAspHtmlFallback:
			InterlockedExchange((LPLONG)&m_fEnableAspHtmlFallBack, *(LONG *)pData);
            break;
            
        case IGlob_EnableChunkedEncoding:
			InterlockedExchange((LPLONG)&m_fEnableChunkedEncoding, *(LONG *)pData);
            break;
            
        case IGlob_EnableTypelibCache:
			InterlockedExchange((LPLONG)&m_fEnableTypelibCache, *(LONG *)pData);
            break;
            
        case IGlob_ErrorsToNtLog:
			InterlockedExchange((LPLONG)&m_fDupIISLogToNTLog, *(LONG *)pData);
            break;
            
        case IGlob_ProcessorThreadMax:
			InterlockedExchange((LPLONG)&m_dwProcessorThreadMax, *(LONG *)pData);
            break;
            
        case IGlob_RequestQueueMax:
			InterlockedExchange((LPLONG)&m_dwRequestQueueMax, *(LONG *)pData);
            break;
            
        case IGlob_ThreadGateEnabled:
			InterlockedExchange((LPLONG)&m_fThreadGateEnabled, *(LONG *)pData);
            break;
            
        case IGlob_ThreadGateTimeSlice:
			InterlockedExchange((LPLONG)&m_dwThreadGateTimeSlice, *(LONG *)pData);
            break;
            
        case IGlob_ThreadGateSleepDelay:
			InterlockedExchange((LPLONG)&m_dwThreadGateSleepDelay, *(LONG *)pData);
            break;
            
        case IGlob_ThreadGateSleepMax:
			InterlockedExchange((LPLONG)&m_dwThreadGateSleepMax, *(LONG *)pData);
            break;
            
        case IGlob_ThreadGateLoadLow:
			InterlockedExchange((LPLONG)&m_dwThreadGateLoadLow, *(LONG *)pData);
            break;
            
        case IGlob_ThreadGateLoadHigh:
			InterlockedExchange((LPLONG)&m_dwThreadGateLoadHigh, *(LONG *)pData);
            break;
			
        case IGlob_PersistTemplateMaxFiles:
			InterlockedExchange((LPLONG)&m_dwPersistTemplateMaxFiles, *(LONG *)pData);
            break;
			
		case IGlob_PersistTemplateDir:
			GlobStringUseLock();
			if (m_pszPersistTemplateDir != NULL) {
				GlobalFree(m_pszPersistTemplateDir);
			}
			m_pszPersistTemplateDir = *(LPSTR *)pData;
			GlobStringUseUnLock();
			break;

		default:
			break;
	}

	return S_OK;
}

/*===================================================================
HRESULT	CGlob::GlobInit

Get all interesting global values (mostly from registry)

Returns:
	HRESULT - S_OK on success
	
Side effects:
	fills in glob.  May be slow
===================================================================*/
HRESULT CGlob::GlobInit(void)
	{
	HRESULT hr = S_OK;

	m_fInited = FALSE;
	
	ErrInitCriticalSection(&m_cs, hr);
	if (FAILED(hr))
		return(hr);

    hr = CFTMImplementation::Init();
    if (FAILED(hr))
        return(hr);
        
	hr = MDInit();
	if (FAILED(hr))
		return hr;

	// Disable caching in Win95
	// Registry get read only once in the Init time in Win95.
	// So, set those caching related values here.
	if(!m_fWinNT)
		{
		m_dwScriptFileCacheSize 	= 0;
		m_dwScriptEngineCacheMax	= 0;
		}

	//Finish loading, any registry change from this moment requires Admin Configurable(TRUE) to take
	//affect.  Other registry changes need to have IIS be stopped and restarted.
	m_fInited = TRUE;
	m_fNeedUpdate = FALSE;

	return(hr);
	}

/*===================================================================
GlobUnInit

Free all GlobalString Values.

Returns:
	HRESULT - S_OK on success
	
Side effects:
	memory freed.
===================================================================*/
HRESULT CGlob::GlobUnInit(void)
	{
	HRESULT hr = S_OK;

	MDUnInit();
	
    CFTMImplementation::UnInit();
        
	DeleteCriticalSection(&m_cs);

	return(hr);
	}

static HRESULT GetMetabaseIF(IMSAdminBase **hMetabase)
{
	IClassFactory 					*pcsfFactory = NULL;
    HRESULT                         hr;

	hr = CoGetClassObject(
			CLSID_MSAdminBase,
			CLSCTX_SERVER,
			NULL,
			IID_IClassFactory,
			(void **)&pcsfFactory);

	if (FAILED(hr)) {
        DBGPRINTF((DBG_CONTEXT,"MDInit: CoGetClassObject failed with %x\n",hr));
        return hr;
    }

	hr = pcsfFactory->CreateInstance(
			NULL,
			IID_IMSAdminBase,
			(void **) hMetabase);

	pcsfFactory->Release();
	
	if (FAILED(hr)) {
        DBGPRINTF((DBG_CONTEXT,"MDInit: CreateInstance failed with %x\n",hr));
		goto LExit;
    }
		
	Assert(*hMetabase != NULL);
	if (FAILED(hr))
		{
		(*hMetabase)->Release();
		(*hMetabase) = NULL;
		goto LExit;
		}
LExit:
    return(hr);
}

/*==================================================================
CGlob::MDInit

1. Create Metabase interface.
2. Load Glob configuration Settings from Metabase
2. Register SinkNotify() callback function through Metabase connectionpoint interface.

Returns:
	HRESULT	- S_OK on success

Side effects: Register SinkNotify().
===================================================================*/
HRESULT CGlob::MDInit(void)
{
	HRESULT 						hr = S_OK;
	IConnectionPointContainer		*pConnPointContainer = NULL;
	IConnectionPoint				*pConnPoint = NULL;

    if (FAILED(hr = GetMetabaseIF(&m_pMetabase))) {
        goto LExit;
    }

	m_pMetabaseSink = new CMDGlobConfigSink();
	if (!m_pMetabaseSink)
	    return E_OUTOFMEMORY;
	    
	m_dwMDSinkCookie = 0;

	// Init the Glob structure with defaults.  The metabase will actually be read later
	hr = SetConfigToDefaults(NULL, TRUE);
	if (SUCCEEDED(hr)) {
		// Advise Metabase about SinkNotify().
		hr = m_pMetabase->QueryInterface(IID_IConnectionPointContainer, (void **)&pConnPointContainer);
		if (pConnPointContainer != NULL)
			{
			//Find the requested Connection Point.  This AddRef's the return pointer.
			hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);
			pConnPointContainer->Release();

			if (pConnPoint != NULL)
				{
				hr = pConnPoint->Advise((IUnknown *)m_pMetabaseSink, &m_dwMDSinkCookie);
				pConnPoint->Release();
				}
			}
	} else {
        DBGPRINTF((DBG_CONTEXT,"MDInit: SetConfigToDefaults failed with %x\n",hr));
    }
		
	if (FAILED(hr))	//Advise failed
		{
        DBGPRINTF((DBG_CONTEXT,"MDInit: Advise failed with %x\n",hr));
		m_pMetabase->Release();
		m_pMetabase = NULL;
		}

LExit:

	return hr;
}

/*==================================================================
CGlob::MDUnInit

1. UnRegister SinkNofity() from Metabase connectionpoint interface.
2. delete m_pMetabaseSink.
3. release interface pointer of m_pMetabase.

Returns:
	HRESULT	- S_OK on success

Side effects: release interface pointer of m_pMetabase
===================================================================*/
HRESULT CGlob::MDUnInit(void)
{
	HRESULT 						hr 						= S_OK;
	IConnectionPointContainer		*pConnPointContainer	= NULL;
	IConnectionPoint				*pConnPoint 			= NULL;
	IClassFactory 					*pcsfFactory            = NULL;

    if (m_pMetabase != NULL)
		{
		//Advise Metabase about SinkNotify().
		hr = m_pMetabase->QueryInterface(IID_IConnectionPointContainer, (void **)&pConnPointContainer);
		if (pConnPointContainer != NULL)
			{
			//Find the requested Connection Point.  This AddRef's the return pointer.
			hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);
			pConnPointContainer->Release();
			if (pConnPoint != NULL)
				{
				hr = pConnPoint->Unadvise(m_dwMDSinkCookie);
				if (FAILED(hr))
					{
                    DBGPRINTF((DBG_CONTEXT, "UnAdvise Glob Config Change Notify failed.\n"));
					}
				pConnPoint->Release();
				m_dwMDSinkCookie = 0;
				}
			}
		m_pMetabase->Release();
		m_pMetabase = NULL;
		}

	if (m_pMetabaseSink)
		m_pMetabaseSink->Release();

	return hr;
}

/*==================================================================
CMDAppConfigSink::QueryInterface

Returns:
	HRESULT	- S_OK on success

Side effects:
===================================================================*/
STDMETHODIMP CMDAppConfigSink::QueryInterface(REFIID iid, void **ppv)
	{
	*ppv = 0;
	
	if (iid == IID_IUnknown || iid == IID_IMSAdminBaseSink)
		*ppv = (IMSAdminBaseSink *)this;
	else
		return ResultFromScode(E_NOINTERFACE);

	((IUnknown *)*ppv)->AddRef();
	return S_OK;
	}

/*==================================================================
CMDAppConfigSink::AddRef

Returns:
	ULONG	- The new ref counter of object

Side effects:
===================================================================*/
STDMETHODIMP_(ULONG) CMDAppConfigSink::AddRef(void)
	{
	LONG  cRefs = InterlockedIncrement((long *)&m_cRef);
	return cRefs;
	}

/*==================================================================
CMDGlobConfigSink::Release

Returns:
	ULONG	- The new ref counter of object

Side effects: Delete object if ref counter is zero.
===================================================================*/
STDMETHODIMP_(ULONG) CMDAppConfigSink::Release(void)
	{
	LONG cRefs = InterlockedDecrement((long *)&m_cRef);
	if (cRefs == 0)
		{
		delete this;
		}
	return cRefs;
	}

/*==================================================================
CMDAppConfigSink::SinkNotify

Returns:
	HRESULT	- S_OK on success

Side effects: Set fNeedUpdate to TRUE, and glob data will gets update next time a request coming in.
===================================================================*/
STDMETHODIMP	CMDAppConfigSink::SinkNotify(
				DWORD	dwMDNumElements,
				MD_CHANGE_OBJECT_W	__RPC_FAR	pcoChangeList[])
{
    if (IsShutDownInProgress())
        return S_OK;

	UINT	iEventNum = 0;
	DWORD	iDataIDNum = 0;
	WCHAR 	*wszMDPath = NULL;
    BOOL    fWszMDPathAllocd = FALSE;
	UINT	cSize = 0;

#if UNICODE
    wszMDPath = m_pAppConfig->SzMDPath();
    cSize = wcslen(wszMDPath);
	// Tag on a trailing '/'because the directories in pszMDPath will have one
	if (wszMDPath[cSize - 1] != L'/') {
        wszMDPath = new WCHAR[cSize+2];
        if (wszMDPath == NULL) {
            return E_OUTOFMEMORY;
        }
        fWszMDPathAllocd = TRUE;
        wcscpy(wszMDPath, m_pAppConfig->SzMDPath());
		wszMDPath[cSize] = L'/';
	    wszMDPath[cSize + 1] = 0;
    }
#else
	CHAR * 	szMDPathT = m_pAppConfig->SzMDPath();

	Assert(szMDPathT != NULL);
	DWORD cbStr = strlen(szMDPathT);
	
	wszMDPath = new WCHAR[cbStr + 2]; // Allow for adding trailing '/' and '\0'
	if (wszMDPath == NULL) {
		return E_OUTOFMEMORY;
    }
    fWszMDPathAllocd = TRUE;
	cSize = MultiByteToWideChar(CP_ACP, 0, szMDPathT, cbStr, wszMDPath, cbStr + 2);
	if (cSize == 0) {
	    return HRESULT_FROM_WIN32(GetLastError());
    }

	wszMDPath[cSize] = 0;
	wszMDPath[cSize + 1] = 0;

	// Tag on a trailing '/'because the directories in pszMDPath will have one
	if (wszMDPath[cSize - 1] != L'/') {
		wszMDPath[cSize] = L'/';
    }
#endif

	for (iEventNum = 0; iEventNum < dwMDNumElements; iEventNum++)
		{
		DWORD dwMDChangeType = pcoChangeList[iEventNum].dwMDChangeType;
		if ((dwMDChangeType == MD_CHANGE_TYPE_DELETE_OBJECT) || (dwMDChangeType == MD_CHANGE_TYPE_RENAME_OBJECT))
		    {
		    if (wcsicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath) == 0)
		        {
                m_pAppConfig->m_pAppln->AddRef();
		        HANDLE hnd = CreateThread(NULL, 0, RestartAppln, m_pAppConfig->m_pAppln, 0, NULL);
                if (hnd == NULL) {
                    m_pAppConfig->m_pAppln->Release();
                }
                else {
		            CloseHandle(hnd);
                }
    	        break;
		        }
		    }
		if (0 == wcsnicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath, cSize + 1))
			{
			for (iDataIDNum = 0; iDataIDNum < pcoChangeList[iEventNum].dwMDNumDataIDs; iDataIDNum++)
				{
				if (pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] == MD_VR_PATH)
					{
				    if (wcsicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath) == 0)
				        {
                        m_pAppConfig->m_pAppln->AddRef();
		                HANDLE hnd = CreateThread(NULL, 0, RestartAppln, m_pAppConfig->m_pAppln, 0, NULL);
                        if (hnd == NULL) {
                            m_pAppConfig->m_pAppln->Release();
                        }
                        else {
		                    CloseHandle(hnd);
                        }
				        break;
				        }
					}

				if (pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] >= ASP_MD_SERVER_BASE
					&& pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] <= MD_ASP_ID_LAST)
					{
                    if (m_pAppConfig->fNeedUpdate() == FALSE)
					    m_pAppConfig->NotifyNeedUpdate();
                    if ((pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] == MD_ASP_ENABLEAPPLICATIONRESTART) 
                        && (wcsicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath) == 0))
                        {
                        m_pAppConfig->NotifyRestartEnabledUpdated();
					    goto LExit;
                        }
					}
				}
			}
		}

LExit:
    if (fWszMDPathAllocd)
	    delete [] wszMDPath;
	return S_OK;
}
/*===================================================================
CAppConfig::CAppConfig

Returns:
	Nothing

Side Effects:
	None.
===================================================================*/
CAppConfig::CAppConfig()
	: 
    m_dwScriptTimeout(45),
    m_dwSessionTimeout(10),
    m_dwQueueTimeout(0xffffffff),
    m_fScriptErrorsSentToBrowser(TRUE),
    m_fBufferingOn(TRUE),
    m_fEnableParentPaths(TRUE),
    m_fAllowSessionState(TRUE),
    m_fAllowOutOfProcCmpnts(FALSE),
    m_fAllowDebugging(FALSE),
    m_fAllowClientDebug(FALSE),
    m_fExecuteInMTA(FALSE),
    m_fEnableApplicationRestart(TRUE),
    m_dwQueueConnectionTestTime(3),
    m_dwSessionMax(0xffffffff),
	m_fInited(FALSE),
    m_fRestartEnabledUpdated(FALSE),
	m_uCodePage(CP_ACP),
	m_fIsValidProglangCLSID(FALSE),
    m_pMetabase(NULL),
    m_pMetabaseSink(NULL)
{
	for (UINT cMsg = 0; cMsg < APP_CONFIG_MESSAGEMAX; cMsg++)
		m_szString[cMsg] = 0;
}

/*===================================================================
CAppConfig::Init

Init the CAppConfig.	Only called once.

in:
	CAppln	pAppln	The backpointer to Application.

Side effects:
	Allocate CMDAppConfigSink. Register metabase sink. etc.
===================================================================*/
HRESULT CAppConfig::Init
(
CIsapiReqInfo   *pIReq,
CAppln *pAppln
)
{

	HRESULT 						hr = S_OK;
	IConnectionPointContainer		*pConnPointContainer = NULL;
	IConnectionPoint				*pConnPoint = NULL;
	IClassFactory 					*pcsfFactory = NULL;

    if (FAILED(hr = GetMetabaseIF(&m_pMetabase))) {
        return hr;
    }

	m_pMetabaseSink = new CMDAppConfigSink(this);
	if (!m_pMetabaseSink)
		return E_OUTOFMEMORY;

	m_pAppln = pAppln;
	m_dwMDSinkCookie = 0;

	// Read info into Glob structure
	hr = ReadConfigFromMD(pIReq, this, FALSE);
    
    if (SUCCEEDED(hr))
        {
        hr = g_ScriptManager.ProgLangIdOfLangName((LPCSTR)m_szString[IAppMsg_SCRIPTLANGUAGE],
		    								      &m_DefaultScriptEngineProgID);
		// BUG 295239
		// If it failed, we still should create an application because the error message
		// "New Application Failed" is too confusing for the user.  This is not a fatal error
		// because it is still (theoretically) possible to run scripts (those with explicit language
		// attributes)  Therefore, we reset the hr to S_OK.

		m_fIsValidProglangCLSID = SUCCEEDED(hr);
		hr = S_OK;
		}

	//Advise Metabase about SinkNotify().
	hr = m_pMetabase->QueryInterface(IID_IConnectionPointContainer, (void **)&pConnPointContainer);
	if (pConnPointContainer != NULL)
		{
		//Find the requested Connection Point.  This AddRef's the return pointer.
		hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);
		pConnPointContainer->Release();

		if (pConnPoint != NULL)
			{
			hr = pConnPoint->Advise((IUnknown *)m_pMetabaseSink, &m_dwMDSinkCookie);
			pConnPoint->Release();
			}
		}

    if (FAILED(hr)) {
        m_pMetabase->Release();
        m_pMetabase = NULL;
    }

	m_fInited = TRUE;
	m_fNeedUpdate = FALSE;

	return hr;
}

/*===================================================================
CAppConfig::UnInit

UnInit the CAppConfig.	Only called once.

in:
	None.

Side effects:
	DeAllocate CMDAppConfigSink. disconnect metabase sink. etc.
===================================================================*/
HRESULT CAppConfig::UnInit(void)
{
	HRESULT 						hr 						= S_OK;
	IConnectionPointContainer		*pConnPointContainer	= NULL;
	IConnectionPoint				*pConnPoint 			= NULL;
    CHAR                            szErr[256];

    if (m_pMetabase) {

        //Advise Metabase about SinkNotify().
	    hr = m_pMetabase->QueryInterface(IID_IConnectionPointContainer, (void **)&pConnPointContainer);
	    if (pConnPointContainer != NULL)
		    {
		    //Find the requested Connection Point.  This AddRef's the return pointer.
		    hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);

		    if (FAILED(hr))
		        {
                DBGPRINTF((DBG_CONTEXT, "FindConnectionPoint failed. hr = %08x\n", hr));
                Assert(SUCCEEDED(hr));
                }
            
		    pConnPointContainer->Release();
		    if (pConnPoint != NULL)
			    {
			    hr = pConnPoint->Unadvise(m_dwMDSinkCookie);
			    if (FAILED(hr))
				    {
				    DBGPRINTF((DBG_CONTEXT, "UnAdvise App Config Change Notify failed. hr = %08x\n", hr));
				    }
			    hr = S_OK; // benign failure if Advise was not called (happens with unknown script lang)
			    pConnPoint->Release();
			    m_dwMDSinkCookie = 0;
			    }
		    }
	    else
	        {
	        DBGPRINTF((DBG_CONTEXT, "QueryInterface failed. hr = %08x\n", hr));
            Assert(SUCCEEDED(hr));
	        }
        m_pMetabase->Release();
        m_pMetabase = NULL;
    }

	if (m_pMetabaseSink)
		m_pMetabaseSink->Release();

	for (int iStr = 0; iStr < APP_CONFIG_MESSAGEMAX; iStr++)
		{
		if (m_szString[iStr] != NULL)
			{
			GlobalFree(m_szString[iStr]);
			m_szString[iStr] = NULL;
			}
		}

	return hr;
}

/*===================================================================
AppConfigUnInit

BUG 89144: Uninit AppConfig but do it from the MTA
When AppConfig is inited, it is done on a WAM thread.  WAM
threads are MTA threads.  At that time we register an event
sink to get Metabase change notifications.  Now, during shutdown,
we are running on an ASP worker thread, which is an STA thread.
That means we will get an RPC_E_WRONGTHREAD error shutting down.  The 
fix is to make the uninit call happen on an MTA thread.
This cover is used to do the work in the MTA.

in:
    pAppConfig

Side effects:
===================================================================*/
HRESULT AppConfigUnInit(void *pv1, void *pv2)
{
    Assert(pv1 != NULL);
    Assert(pv2 != NULL);

	HRESULT hr = static_cast<CAppConfig *>(pv1)->UnInit();
	SetEvent(reinterpret_cast<HANDLE>(pv2));
	return hr;
}


/*===================================================================
CAppConfig::szMDPath


in:
	None

returns:
	LPTSTR: ptr to szmetabsekey

Side effects:
	Get MetabaseKey
===================================================================*/
LPTSTR CAppConfig::SzMDPath()
{
	return m_pAppln->GetMetabaseKey();
}

/*===================================================================
CAppConfig::SetValue


in:
	int 	index		the index in the propinfo[]
	BYTE*	pData		lp to the Data being copied/assigned in the glob.

returns:
	BOOL	TRUE/FALSE

Side effects:
	Free old string memory and allocate new memory for string.
===================================================================*/
HRESULT CAppConfig::SetValue(unsigned int iValue, BYTE *pData)
{
    HRESULT hr = S_OK;

	Assert((iValue < IApp_MAX) && (pData != NULL));
	
	switch(iValue) {
		case IApp_CodePage:
			InterlockedExchange((LPLONG)&m_uCodePage, *(LONG *)pData);
			break;
			
		case IApp_BufferingOn:
			InterlockedExchange((LPLONG)&m_fBufferingOn, *(LONG *)pData);
			break;

		case IApp_ScriptErrorsSenttoBrowser:
			InterlockedExchange((LPLONG)&m_fScriptErrorsSentToBrowser, *(LONG *)pData);
			break;
			
		case IApp_ScriptErrorMessage:
			GlobStringUseLock();
			if (m_szString[IAppMsg_SCRIPTERROR] != NULL) {
				GlobalFree(m_szString[IAppMsg_SCRIPTERROR]);
			}
			m_szString[IAppMsg_SCRIPTERROR] = *(LPSTR *)pData;
			GlobStringUseUnLock();
			break;

		case IApp_ScriptTimeout:
			InterlockedExchange((LPLONG)&m_dwScriptTimeout, *(LONG *)pData);
			break;
			
		case IApp_SessionTimeout:
			InterlockedExchange((LPLONG)&m_dwSessionTimeout, *(LONG *)pData);
			break;

		case IApp_QueueTimeout:
			InterlockedExchange((LPLONG)&m_dwQueueTimeout, *(LONG *)pData);
			break;

		case IApp_EnableParentPaths:
			InterlockedExchange((LPLONG)&m_fEnableParentPaths, !*(LONG *)pData);
			break;

		case IApp_AllowSessionState:
			InterlockedExchange((LPLONG)&m_fAllowSessionState, *(LONG *)pData);
			break;

		case IApp_ScriptLanguage:
			GlobStringUseLock();
			if (m_szString[IAppMsg_SCRIPTLANGUAGE] != NULL)
				{
				GlobalFree(m_szString[IAppMsg_SCRIPTLANGUAGE] );
				}
			m_szString[IAppMsg_SCRIPTLANGUAGE] = *(LPSTR *)pData;
			if (m_szString[IAppMsg_SCRIPTLANGUAGE] != NULL)
				{
				if('\0' == m_szString[IAppMsg_SCRIPTLANGUAGE][0])
					{
					MSG_Error("No Default Script Language specified, using VBScript as default.");
					GlobalFree(m_szString[IAppMsg_SCRIPTLANGUAGE] );
					m_szString[IAppMsg_SCRIPTLANGUAGE] = (LPSTR)GlobalAlloc(GPTR, 128);
					CchLoadStringOfId(IDS_SCRIPTLANGUAGE, (LPSTR)m_szString[IAppMsg_SCRIPTLANGUAGE], 128);
					}
				}
        		hr = g_ScriptManager.ProgLangIdOfLangName((LPCSTR)m_szString[IAppMsg_SCRIPTLANGUAGE],
		   											      &m_DefaultScriptEngineProgID);
				GlobStringUseUnLock();
			break;

		case IApp_AllowClientDebug:
			InterlockedExchange((LPLONG)&m_fAllowClientDebug, *(LONG *)pData);
			break;

		case IApp_AllowDebugging:
			InterlockedExchange((LPLONG)&m_fAllowDebugging, *(LONG *)pData);
			break;

		case IApp_EnableApplicationRestart:
			InterlockedExchange((LPLONG)&m_fEnableApplicationRestart, *(LONG *)pData);
			break;

		case IApp_QueueConnectionTestTime:
			InterlockedExchange((LPLONG)&m_dwQueueConnectionTestTime, *(LONG *)pData);
			break;

		case IApp_SessionMax:
			InterlockedExchange((LPLONG)&m_dwSessionMax, *(LONG *)pData);
			break;

		case IApp_ExecuteInMTA:
			InterlockedExchange((LPLONG)&m_fExecuteInMTA, *(LONG *)pData);
			break;

		case IApp_LCID:
			InterlockedExchange((LPLONG)&m_uLCID, *(LONG *)pData);
			break;

        case IApp_KeepSessionIDSecure:
            InterlockedExchange((LPLONG)&m_fKeepSessionIDSecure, *(LONG *)pData);
            break;

		default:
			break;
	}

	return hr;
}

/*===================================================================
CAppConfig::Update
Update settings in CAppConfig.

in:

returns:
	HRESULT

Side effects:
	Update CAppConfig settings.
===================================================================*/
HRESULT CAppConfig::Update(CIsapiReqInfo    *pIReq)
{
	Glob(Lock);
	if (m_fNeedUpdate == TRUE)
		{
		InterlockedExchange((LPLONG)&m_fNeedUpdate, 0);
        m_fRestartEnabledUpdated = FALSE;
		}
	else
		{
		Glob(UnLock);
		return S_OK;
		}
	Glob(UnLock);
	return ReadConfigFromMD(pIReq, this, FALSE);
}

/*===================================================================
RestartAppln
Restarts the application passed in as a pointer.

returns:
	HRESULT

Note
    This is a helper function for CMDAppConfigSink::SinkNotify.
    Restarting an application is a time consuming process, and we
    don't want to wait in in SinkNotify while carrying it out.
    Therefore, SinkNotify launches a new thread which whil execute this
    function and exit.
    
Side effects:
	Deletes all sessions for this application.
	Will indirectly result in Session_OnEnd and Application_OnEnd
	being called
===================================================================*/
DWORD RestartAppln(VOID *pArg)
    {
    DWORD   retval;
    CAppln  *pAppln = reinterpret_cast<CAppln *>(pArg);

    retval = pAppln->Restart(TRUE);
    pAppln->Release();

    return retval;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\glob.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Globals

File: glob.h

Owner: AndrewS

Useful globals
===================================================================*/

#ifndef __Glob_H
#define __Glob_H

#include "util.h"
#include <schnlsp.h>
#include <wincrypt.h>
#include <iadmw.h>

extern "C" {

#define SECURITY_WIN32
#include <sspi.h>           // Security Support Provider APIs

}

class CMDGlobConfigSink : public IMSAdminBaseSinkW
        {
        private:
        INT                     m_cRef;
        public:

        CMDGlobConfigSink ()                    {m_cRef = 1;};

        HRESULT STDMETHODCALLTYPE       QueryInterface(REFIID riid, void **ppv);
        ULONG   STDMETHODCALLTYPE       AddRef(void);
        ULONG   STDMETHODCALLTYPE       Release(void);

        HRESULT STDMETHODCALLTYPE       SinkNotify(
                        DWORD   dwMDNumElements,
                        MD_CHANGE_OBJECT        __RPC_FAR       pcoChangeList[]);

        HRESULT STDMETHODCALLTYPE ShutdownNotify( void)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }

        };
#define IGlob_LogErrorRequests                                  0x0
#define IGlob_ScriptFileCacheSize                               0x1
#define IGlob_ScriptEngineCacheMax                              0x2
//#define IGlob_MemFreeFactor                                   0x3
//#define IGlob_MinUsedBlocks                                   0x4
//#define IGlob_StartConnectionPool                             0x5
#define IGlob_ExceptionCatchEnable                              0x3
#define IGlob_TrackThreadingModel                               0x4
#define IGlob_AllowOutOfProcCmpnts                              0x5
// IIS5.0
#define IGlob_EnableAspHtmlFallback                             0x6
#define IGlob_EnableChunkedEncoding                             0x7
#define IGlob_EnableTypelibCache                                0x8
#define IGlob_ErrorsToNtLog                                     0x9
#define IGlob_ProcessorThreadMax                                0xa
#define IGlob_RequestQueueMax                                   0xb
#define IGlob_ThreadGateEnabled                                 0xc
#define IGlob_ThreadGateTimeSlice                               0xd
#define IGlob_ThreadGateSleepDelay                              0xe
#define IGlob_ThreadGateSleepMax                                0xf
#define IGlob_ThreadGateLoadLow                                 0x10
#define IGlob_ThreadGateLoadHigh                                0x11
#define IGlob_PersistTemplateMaxFiles                           0x12
#define IGlob_PersistTemplateDir                                0x13
#define IGlob_MAX                                               0x14

//forward declaration
class CAppConfig;
//      Glob data object
class CGlob
        {
private:
        // Friends that can access the private data, they are the functions setting the global data.
        friend          HRESULT CacheStdTypeInfos();
        friend          HRESULT ReadConfigFromMD(CIsapiReqInfo  *pIReq, CAppConfig *pAppConfig, BOOL fLoadGlob);
        friend          HRESULT SetConfigToDefaults(CAppConfig *pAppConfig, BOOL fLoadGlob);

        //Private Data
        ITypeLib                        *m_pITypeLibDenali;     // Denali's type library
        BOOL                            m_fWinNT;               // TRUE if this is Windows NT; false otherwise
        DWORD                           m_dwNumberOfProcessors;
        BOOL                            m_fInited;
        BOOL                            m_fMDRead;				// Has Metadata been read at least once
        BOOL                            m_fNeedUpdate;          // FALSE, needs reload config data from metabase

        // Metadata configuration settings per dll
        DWORD                           m_dwScriptEngineCacheMax;
        DWORD                           m_dwScriptFileCacheSize;
        BOOL                            m_fLogErrorRequests;
        BOOL                            m_fExceptionCatchEnable;
        BOOL                            m_fAllowDebugging;
        BOOL                            m_fAllowOutOfProcCmpnts;
        BOOL                            m_fTrackThreadingModel;
        DWORD                           m_dwMDSinkCookie;
        CMDGlobConfigSink              *m_pMetabaseSink;
        IMSAdminBase                   *m_pMetabase;

        BOOL    m_fEnableAspHtmlFallBack;
		BOOL    m_fEnableTypelibCache;
		BOOL    m_fEnableChunkedEncoding;
		BOOL    m_fDupIISLogToNTLog;
        DWORD   m_dwRequestQueueMax;
		DWORD   m_dwProcessorThreadMax;
            
		BOOL    m_fThreadGateEnabled;
		DWORD   m_dwThreadGateTimeSlice;
		DWORD   m_dwThreadGateSleepDelay;
		DWORD   m_dwThreadGateSleepMax;
		DWORD   m_dwThreadGateLoadLow;
		DWORD   m_dwThreadGateLoadHigh;

        LPSTR   m_pszPersistTemplateDir;
        DWORD   m_dwPersistTemplateMaxFiles;
        

        CRITICAL_SECTION        m_cs;                           // Glob Strings need to be protected by CriticalSection

                                                                                    // Functions Pointers for WINNT & WIN95 singal binary compatibility
        //Private functions
        HRESULT         SetGlobValue(unsigned int index, BYTE *lpByte);

public:
        CGlob();

        HRESULT         MDInit(void);
        HRESULT         MDUnInit(void);


public:
        ITypeLib*       pITypeLibDenali()                       {return m_pITypeLibDenali;};            // Denali's type library
        BOOL            fWinNT()                                {return m_fWinNT;};                                     // TRUE if this is Windows NT; false otherwise
	    DWORD           dwNumberOfProcessors()                  {return m_dwNumberOfProcessors;};
    	BOOL            fNeedUpdate()                           {return (BOOLB)m_fNeedUpdate;};
        void            NotifyNeedUpdate();
        DWORD           dwScriptEngineCacheMax()                {return m_dwScriptEngineCacheMax;};
        DWORD           dwScriptFileCacheSize()                 {return m_dwScriptFileCacheSize;};
        BOOLB           fLogErrorRequests()                     {return (BOOLB)m_fLogErrorRequests;};
        BOOLB           fInited()                               {return (BOOLB)m_fInited;};
        BOOLB           fMDRead()                               {return (BOOLB)m_fMDRead;};
        BOOLB           fTrackThreadingModel()                  {return (BOOLB)m_fTrackThreadingModel;};
        BOOLB     		fExceptionCatchEnable()	    		    {return (BOOLB)m_fExceptionCatchEnable;};
        BOOLB     		fAllowOutOfProcCmpnts() 	        	{return (BOOLB)m_fAllowOutOfProcCmpnts;};

        BOOL    fEnableAspHtmlFallBack()   { return m_fEnableAspHtmlFallBack; }
		BOOL    fEnableTypelibCache()      { return m_fEnableTypelibCache; }
		BOOL    fEnableChunkedEncoding()   { return m_fEnableChunkedEncoding; }  // UNDONE: temp.
		BOOL    fDupIISLogToNTLog()        { return m_fDupIISLogToNTLog; }
        DWORD   dwRequestQueueMax()        { return m_dwRequestQueueMax; }
		DWORD   dwProcessorThreadMax()     { return m_dwProcessorThreadMax; }
            
		BOOL    fThreadGateEnabled()       { return m_fThreadGateEnabled; }
		DWORD   dwThreadGateTimeSlice()    { return m_dwThreadGateTimeSlice; }
		DWORD   dwThreadGateSleepDelay()   { return m_dwThreadGateSleepDelay; }
		DWORD   dwThreadGateSleepMax()     { return m_dwThreadGateSleepMax; }
		DWORD   dwThreadGateLoadLow()      { return m_dwThreadGateLoadLow; }
		DWORD   dwThreadGateLoadHigh()     { return m_dwThreadGateLoadHigh; }

        DWORD   dwPersistTemplateMaxFiles(){ return m_dwPersistTemplateMaxFiles; }
        LPSTR   pszPersistTemplateDir()    { return m_pszPersistTemplateDir; }

        void            Lock()                                  {EnterCriticalSection(&m_cs);};
        void            UnLock()                                {LeaveCriticalSection(&m_cs);};
        HRESULT         GlobInit(void);
        HRESULT         GlobUnInit(void);

        //Used in Scriptmgr for hashing table setup.
        DWORD           dwThreadMax()                                   {return 10;};
        //Used in ScriptKiller for script killer thread to wake up, might rename this to be
        //ScriptCleanupInterval.
        DWORD           dwScriptTimeout()                               {return 90;};

        HRESULT                     Update(CIsapiReqInfo  *pIReq);

};

inline HRESULT CGlob::Update(CIsapiReqInfo  *pIReq)
{
        Lock();
        if (m_fNeedUpdate == TRUE)
                {
                InterlockedExchange((LPLONG)&m_fNeedUpdate, 0);
                }
        else
                {
                UnLock();
                return S_OK;
                }
        UnLock();
        return ReadConfigFromMD(pIReq, NULL, TRUE);
}

inline void CGlob::NotifyNeedUpdate(void)
{
        InterlockedExchange((LPLONG)&m_fNeedUpdate, 1);
}

typedef class CGlob GLOB;
extern class CGlob gGlob;


//      General Access functions.(Backward compatibility).
//      Any non-friends functions should use and only use the following methods. Same macros as before.
//      If elem is a glob string, then, GlobStringUseLock() should be called before the string usage.
//      And GlobStringUseUnLock() should be called after.  The critical section is supposed to protect
//      not only the LPTSTR of global string, but also the memory that LPTSTR points to.
//      Making local copy of global string is recommended.
#define Glob(elem)                              (gGlob.elem())
#define GlobStringUseLock()             (gGlob.Lock())
#define GlobStringUseUnLock()   (gGlob.UnLock())
#define FIsWinNT()                              (Glob(fWinNT))

DWORD __stdcall RestartAppln(VOID *pAppln);
#endif // __Glob_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\fileapp.cpp ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: File/Application map

File: CFileApp.cpp

Owner: cgrant

File/Application mapping implementation
-----------------------------------------------------------------------------*/

#include "denpre.h"
#pragma hdrstop

#include "dbgutil.h"
#include "memchk.h"

CFileApplicationMap g_FileAppMap;

/*===================================================================
CFileApplnList::CFileApplnList

Constructor

Parameters:
    None

Returns:
    Nothing
===================================================================*/	
CFileApplnList::CFileApplnList() :
    m_pszFilename(NULL),
    m_fInited(FALSE)
{

}


/*===================================================================
CFileApplnList::~CFileApplnList

Destructor

Parameters:
    None

Returns:
    Nothing
===================================================================*/	
CFileApplnList::~CFileApplnList()
{
    // We should have no applications in our list
    DBG_ASSERT(m_rgpvApplications.Count() == 0);

    // Free the string used as the hash key
    if (m_pszFilename)
    {
        delete [] m_pszFilename;
        m_pszFilename = NULL;
    }
}

/*===================================================================
CFileApplnList::Init

Initialize the file application list by setting the key to file name

Parameters:
    pApplication    pointer to the applicaiton
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplnList::Init(const TCHAR* pszFilename)
{
    HRESULT hr = S_OK;

    DBG_ASSERT(pszFilename);

    // Make a copy of the file name to 
    // use as the hash key
    DWORD cch = _tcslen(pszFilename);
    m_pszFilename = new TCHAR[cch+1];
    if (!m_pszFilename)
    {
        return E_OUTOFMEMORY;
    }
    _tcscpy(m_pszFilename, pszFilename);

    if (FAILED(CLinkElem::Init(m_pszFilename, cch*sizeof(TCHAR))))
    {
        return E_FAIL;
    }

    m_fInited = TRUE;
    return hr;
}

/*===================================================================
CFileApplnList::UnInit

Clean up the application list

Parameters:
    pApplication    pointer to the applicaiton
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplnList::UnInit(void)
{
    HRESULT hr = S_OK;

    DBG_ASSERT(m_fInited);
    
    while(m_rgpvApplications.Count())
    {
        CAppln* pAppln = static_cast<CAppln *>(m_rgpvApplications[0]);

        DBG_ASSERT(pAppln);

        // Remove this appliation from the array
        m_rgpvApplications.Remove(pAppln);

        // Release the array's refcount on the application
        // This may result in the application being deleted
        pAppln->Release();
    }

    m_rgpvApplications.Clear();
    m_fInited = FALSE;
    return hr;
}


/*===================================================================
CFileApplnList::AddApplication

Add an application pointer to the list of applications

Parameters:
    pApplication    pointer to the applicaiton
    
Returns:
    S_OK if successful

Comments

    The caller should hold a lock on the hash table containing
    the element    
===================================================================*/	
HRESULT CFileApplnList::AddApplication(void *pApplication)
{
    DBG_ASSERT(m_fInited);
    DBG_ASSERT(pApplication);
    
    HRESULT hr = S_OK;
    int index;
    
    // See if the application is alreay in the list
    hr = m_rgpvApplications.Find(pApplication, &index);
    if (hr == S_FALSE)
    {
       // Not found, add it.
       
       // We are going to hold a reference to the application
       static_cast<CAppln *>(pApplication)->AddRef();

       // Add the application to the list
       if (FAILED(hr = m_rgpvApplications.Append(pApplication)))
       {
            // We failed so give back the refcount we took.
            static_cast<CAppln *>(pApplication)->Release();
       }
    }
    return hr;
}

/*===================================================================
CFileApplnList::RemoveApplication

Removes an application pointer from the list of applications

Parameters:
    pApplication    pointer to the applicaiton
    
Returns:
    S_OK if successful

Comments

    The caller should hold a lock on the hash table containing
    the element
===================================================================*/	
HRESULT CFileApplnList::RemoveApplication(void *pApplication)
{
    DBG_ASSERT(m_fInited);
    DBG_ASSERT(pApplication);
    
    HRESULT hr = S_OK;
    int index;

#ifdef DBG_NOTIFICATION
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "Removing Application entry for %S\n", reinterpret_cast<CAppln *>(pApplication)->GetApplnPath()));
#else
    DBGPRINTF((DBG_CONTEXT, "Removing Application entry for %s\n", reinterpret_cast<CAppln *>(pApplication)->GetApplnPath()));
#endif
#endif // DBG_NOTIFICATION

    // Remove the application from the list
    hr = m_rgpvApplications.Remove(pApplication);

    // If the count of applications in the list goes
    // to 0, remove the element from the hash table 
    // and delete it
    if (m_rgpvApplications.Count() == 0)
    {
#ifdef DBG_NOTIFICATION
#if UNICODE
        DBGPRINTF((DBG_CONTEXT, "Deleting File/Application entry for %s\n", m_pszFilename));
#else
        DBGPRINTF((DBG_CONTEXT, "Deleting File/Application entry for %s\n", m_pszFilename));
#endif
#endif // DBG_NOTIFICATION
        g_FileAppMap.RemoveElem(this);
        delete this;
    }

    // If we found the application to remove it
    // we need to release a ref count on the application
    if (hr == S_OK)
    {
        static_cast<CAppln *>(pApplication)->Release();
    }

    return hr;
}

/*===================================================================
CFileApplnList::GetShutdownApplications

Obtain a list of applications to shut down

Parameters:
    None

===================================================================*/	
VOID CFileApplnList::GetShutdownApplications(CPtrArray *prgpapplnRestartList)
{
    DBG_ASSERT(m_fInited);

    HRESULT hr = S_OK;

#ifdef DBG_NOTIFICATION
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "[CFileApplnList] Shutting down %d applications depending on %S.\n", m_rgpvApplications.Count(), m_pszFilename));
#else
    DBGPRINTF((DBG_CONTEXT, "[CFileApplnList] Shutting down %d applications depending on %s.\n", m_rgpvApplications.Count(), m_pszFilename));
#endif
#endif // DBG_NOTIFICATION
    
    for  (int i = m_rgpvApplications.Count() - 1; i >= 0; i--)
    {
        CAppln* pAppln = static_cast<CAppln *>(m_rgpvApplications[i]);
        DBG_ASSERT(pAppln);
        
        // If not already tombstoned, shut the application down.
        // When the application is uninited it will remove itself
        // from this list
        if (!pAppln->FTombstone())
        {
            pAppln->AddRef();
            prgpapplnRestartList->Append(pAppln);
        }
    }
}

/*===================================================================
CFileApplicationMap::CFileApplicationMap

Constructor

Parameters:
    None

Returns:
    Nothing
===================================================================*/	
CFileApplicationMap::CFileApplicationMap()
    : m_fInited(FALSE),
      m_fHashTableInited(FALSE), 
      m_fCriticalSectionInited(FALSE)
{
}

/*===================================================================
CFileApplicationMap::~CFileApplicationMap

Destructor

Parameters:
    None

Returns:
    Nothing
===================================================================*/	
CFileApplicationMap::~CFileApplicationMap()
{
    if (m_fInited)
    {
        UnInit();
    }
}

/*===================================================================
CFileApplicationMap::Init

Initialize the hash table and critical section

Parameters:
    None
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplicationMap::Init()
{
    HRESULT hr = S_OK;
    
    Assert(!m_fInited);

    hr = CHashTable::Init(NUM_FILEAPP_HASHING_BUCKETS);
    if (FAILED(hr))
    {
        return hr;
    }
    m_fHashTableInited = TRUE;

    // Init critical section

    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
    {
        return(hr);
    }
    m_fCriticalSectionInited = TRUE;

    m_fInited = TRUE;
    return S_OK;
}

/*===================================================================
CFileApplicationMap::UnInit

Uninitialize the hash table and critical section
Free any applications lists remaining in the hash
table elements

Parameters:
    None
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplicationMap::UnInit()
{
    if (m_fHashTableInited)
    {
        // Delete any elements remaining in the hash table
        
        CFileApplnList *pNukeElem = static_cast<CFileApplnList *>(Head());

        while (pNukeElem != NULL)
        {
            CFileApplnList *pNext = static_cast<CFileApplnList *>(pNukeElem->m_pNext);
            pNukeElem->UnInit();
            delete pNukeElem;
            pNukeElem = pNext;
        }

        // Uninit the hash table
        CHashTable::UnInit();
        m_fHashTableInited = FALSE;
    }

    if (m_fCriticalSectionInited)
    {
        DeleteCriticalSection(&m_csLock);
        m_fCriticalSectionInited = FALSE;
    }
        
    m_fInited = FALSE;
    return S_OK;
}

/*===================================================================
CFileApplicationMap::AddFileApplication

Add a file-application pair to the hash table

Parameters:
    pszFilename     pointer to string containing name of the file
    pAppln          pointer to the application associated with the file
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplicationMap::AddFileApplication(const TCHAR* pszFilename, CAppln* pAppln)
{
    // We must have both a file and an application
    DBG_ASSERT(pszFilename);
    DBG_ASSERT(pAppln);

    HRESULT hr = S_OK;
    
    Lock();

#ifdef DBG_NOTIFICATION
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "Adding File/Application entry for %S\n", pszFilename));
#else
    DBGPRINTF((DBG_CONTEXT, "Adding File/Application entry for %s\n", pszFilename));
#endif
#endif // DBG_NOTIFICATION
    
    // See if the file already has an entry
    CFileApplnList* pFileApplns = static_cast<CFileApplnList *>(CHashTable::FindElem(pszFilename, _tcslen(pszFilename)*sizeof(TCHAR)));
    if (pFileApplns == NULL)
    {
    
        // Not found, create new CFileApplnList object
    
        pFileApplns = new CFileApplnList;
    
        if (!pFileApplns)
        {
            hr = E_OUTOFMEMORY;
            goto LExit;
        }

        // Init CFileApplnList object

        hr = pFileApplns->Init(pszFilename);

        if (FAILED(hr))
        {
            delete pFileApplns;
            goto LExit;
        }

        // Add FileApplns object to hash table
    
        if (!CHashTable::AddElem(pFileApplns))
        {
            delete pFileApplns;
            hr = E_FAIL;
            goto LExit;
        }
     }

     // Add the application to the list associated with this file
     hr = pFileApplns->AddApplication(pAppln);

     // Keep this file mapping in the application
     // The application will remove itself from this list
     // when it is uninited.
     
     pAppln->AddFileApplnEntry(pFileApplns);
     
LExit:
    UnLock();
    return hr;
}

/*===================================================================
CFileApplicationMap::ShutdownApplications

Shutdown the applications associated with a file

Parameters:
    pszFilename     pointer to string containing name of the file
    
Returns:
    TRUE if an application was shutdown, FALSE otherwise
===================================================================*/	
BOOL CFileApplicationMap::ShutdownApplications(const TCHAR *pszFilename)
{
    DBG_ASSERT(pszFilename);

    BOOL fResult = TRUE;
    
    Lock();
    
    CFileApplnList* pFileApplns = static_cast<CFileApplnList *>(CHashTable::FindElem(pszFilename, _tcslen(pszFilename)*sizeof(TCHAR)));

    if (pFileApplns)
    {
        // Get a list of applications we need to shutdown
        
        CPtrArray rgpapplnRestartList;
        pFileApplns->GetShutdownApplications(&rgpapplnRestartList);


        // Now that we have the list of applications we need to shut down
        // we can release the lock
        
        UnLock();

        for (int i = 0; i < rgpapplnRestartList.Count(); i++)
        {
            CAppln *pAppln = (CAppln *)rgpapplnRestartList[i];
            pAppln->Restart();
            pAppln->Release();
        }

		// Flush the script cache if any applications were restarted
		if (rgpapplnRestartList.Count())
			g_ScriptManager.FlushAll();
    }
    else
    {
        // No applications to shut down, release the lock
        UnLock();
        fResult = FALSE;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\eventlog.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: NT Event logging

File: Eventlog.cpp

Owner: Jhittle

This file contains general event logging routines for Denali.
===================================================================*/ 

#include "denpre.h"
#pragma hdrstop
#include <direct.h>
#include "denevent.h"
#include "memchk.h"

extern HINSTANCE g_hinstDLL;
extern CRITICAL_SECTION g_csEventlogLock;

/*===================================================================
STDAPI  UnRegisterEventLog( void )

UnRegister the event log.

Returns:
	HRESULT S_OK or E_FAIL
	
Side effects:
	Removes denali NT eventlog entries from the registry
===================================================================*/
STDAPI UnRegisterEventLog( void )
	{
	HKEY		hkey = NULL;
	DWORD		iKey;
	CHAR		szKeyName[255];
	DWORD		cbKeyName;
	static const char szDenaliKey[] = "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\Active Server Pages";	

	// Open the HKEY_CLASSES_ROOT\CLSID\{...} key so we can delete its subkeys
	if	(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szDenaliKey, 0, KEY_READ | KEY_WRITE, &hkey) != ERROR_SUCCESS)
		goto LErrExit;

	// Enumerate all its subkeys, and delete them
	for (iKey=0;;iKey++)
		{
		cbKeyName = sizeof(szKeyName);
		if (RegEnumKeyExA(hkey, iKey, szKeyName, &cbKeyName, 0, NULL, 0, NULL) != ERROR_SUCCESS)
			break;

		if (RegDeleteKeyA(hkey, szKeyName) != ERROR_SUCCESS)
			goto LErrExit;
		}

	// Close the key, and then delete it
	if (RegCloseKey(hkey) != ERROR_SUCCESS)
		return E_FAIL;
			
	if (RegDeleteKeyA(HKEY_LOCAL_MACHINE, szDenaliKey) != ERROR_SUCCESS)
		return E_FAIL;

	return S_OK;

LErrExit:
	RegCloseKey(hkey);
	return E_FAIL;
	}

/*===================================================================
STDAPI  RegisterEventLog(void)

Register the NT event log.

Returns:
	HRESULT S_OK or E_FAIL
	
Side effects:
	Sets up denali dll in the Eventlog registry for resolution of
	NT eventlog message strings
===================================================================*/
STDAPI RegisterEventLog( void )
	{

	HKEY	hk;                      // registry key handle 
	DWORD	dwData;					
	BOOL	bSuccess;
	//char	szMsgDLL[MAX_PATH];	

	char    szPath[MAX_PATH];
	char    *pch;

	// Get the path and name of Denali
	if (!GetModuleFileNameA(g_hinstDLL, szPath, sizeof(szPath)/sizeof(char)))
		return E_FAIL;
		
	// BUG FIX: 102010 DBCS code changes
	//
	//for (pch = szPath + lstrlen(szPath); pch > szPath && *pch != TEXT('\\'); pch--)
	//	;
	//	
	//if (pch == szPath)
	//	return E_FAIL;

	pch = (char*) _mbsrchr((const unsigned char*)szPath, '\\');
	if (pch == NULL)	
		return E_FAIL;
		
		
	strcpy(pch + 1, ASP_DLL_NAME);		
	
  	
	// When an application uses the RegisterEventSource or OpenEventLog
	// function to get a handle of an event log, the event loggging service
	// searches for the specified source name in the registry. You can add a
	// new source name to the registry by opening a new registry subkey
	// under the Application key and adding registry values to the new
	// subkey. 

	// Create a new key for our application 
	bSuccess = RegCreateKeyA(HKEY_LOCAL_MACHINE,
		"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\Active Server Pages", &hk);

	if(bSuccess != ERROR_SUCCESS)
		return E_FAIL;

	// Add the Event-ID message-file name to the subkey. 
	bSuccess = RegSetValueExA(hk,  	// subkey handle         
		"EventMessageFile",       	// value name            
		0,                        	// must be zero          
		REG_EXPAND_SZ,            	// value type            
		(LPBYTE) szPath,        	// address of value data 
		strlen(szPath) + 1);   		// length of value data  
		
	if(bSuccess != ERROR_SUCCESS)
		goto LT_ERROR;
	

	// Set the supported types flags and addit to the subkey. 
	dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
	bSuccess = RegSetValueExA(hk,	// subkey handle                
		"TypesSupported",         	// value name                   
		0,                        	// must be zero                 
		REG_DWORD,                	// value type                   
		(LPBYTE) &dwData,         	// address of value data        
		sizeof(DWORD));           	// length of value data         

	if(bSuccess != ERROR_SUCCESS)
		goto LT_ERROR;

	RegCloseKey(hk);	
	return S_OK;

	LT_ERROR:

	RegCloseKey(hk);	
	return E_FAIL;
	}

/*===================================================================
STDAPI  reportAnEvent(DWORD, WORD, LPSTR); 

Register report an event to the NT event log

INPUT: 
	the event ID to report in the log, the number of insert    
    strings, and an array of null-terminated insert strings
    
Returns:
	HRESULT S_OK or E_FAIL
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
STDAPI ReportAnEvent(DWORD dwIdEvent, WORD wEventlog_Type, WORD cStrings, LPCSTR  *pszStrings)
	{
  	HANDLE	hAppLog;
  	BOOL	bSuccess;
  	HRESULT hr = S_OK;

  	

  	// Get a handle to the Application event log 
  	hAppLog = RegisterEventSourceA(NULL,   		// use local machine      
    	  "Active Server Pages");                   	// source name                 
      
	if(hAppLog == NULL)
		return E_FAIL;

	  // Now report the event, which will add this event to the event log 
	bSuccess = ReportEventA(hAppLog,        		// event-log handle            
    	wEventlog_Type,				    		// event type                  
      	0,		                       			// category zero               
      	dwIdEvent,		              			// event ID                    
      	NULL,					     			// no user SID                 
      	cStrings,								// number of substitution strings     
	  	0,	                       				// no binary data              
      	pszStrings,                				// string array                
      	NULL);                     				// address of data             

	if(!bSuccess)
		hr = E_FAIL;
		
	DeregisterEventSource(hAppLog);
  	return hr;
	}

/*===================================================================
void MSG_DenaliStarted(void) 

report an event to the NT event log

INPUT: 
	None
	
Returns:
	Nonw
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_DenaliStarted(void)
	{
	ReportAnEvent( (DWORD) MSG_DENALI_SERVICE_STARTED, (WORD) EVENTLOG_INFORMATION_TYPE, (WORD) 0, (LPCSTR *) NULL );	
	}  

/*===================================================================
void MSG_DenaliStoped(void) 

report an event to the NT event log

INPUT: 
	None
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_DenaliStoped(void)
	{
	ReportAnEvent( (DWORD) MSG_DENALI_SERVICE_STOPPED, (WORD) EVENTLOG_INFORMATION_TYPE, (WORD) 0, (LPCSTR *) NULL );  	
	return;
	}  

/*===================================================================
void MSG_Error( LPCSTR sz )

report an event to the NT event log

INPUT: 
	ptr to null-terminated string
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( LPCSTR strSource )
	{
	static char	szLastError[MAX_MSG_LENGTH];

	EnterCriticalSection(&g_csEventlogLock);
	if (strcmp(strSource, szLastError) == 0)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}
		
	strncpy(szLastError,strSource, MAX_MSG_LENGTH);
	szLastError[MAX_MSG_LENGTH-1] = '\0';
	LeaveCriticalSection(&g_csEventlogLock);
	
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_1, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 1, &strSource /*aInsertStrs*/ );  	
	}  

/*===================================================================
void MSG_Error( UINT ustrID )

report an event to the NT event log

INPUT: 
	string table string ID
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( UINT SourceID1 )
	{
	static unsigned int nLastSourceID1;

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}
	nLastSourceID1 = SourceID1;
	LeaveCriticalSection(&g_csEventlogLock);
	
	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char	*aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
	cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_1, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 1, (LPCSTR *) aInsertStrs );  	
	return;
	}  


/*===================================================================
void MSG_Error( UINT SourcID1, UINT SourceID2 ) 

report an event to the NT event log

INPUT: 
	two part message of string table string ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( UINT SourceID1, UINT SourceID2 )
	{
	static unsigned int nLastSourceID1;
	static unsigned int nLastSourceID2;

	// if this is a repeat of the last reported message then return
	// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}
		
	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	LeaveCriticalSection(&g_csEventlogLock);
	
	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[1] = (char*) strSource;                                     
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_2, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 2, (LPCSTR *) aInsertStrs );  	
	return;
	}  

/*===================================================================
void MSG_Error( const char* pszError1, const char* pszError2, const char* pszError3) 

report an event to the NT event log

INPUT: 
	three part message string
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( UINT SourceID1, UINT SourceID2, UINT SourceID3 )
	{
	static unsigned int nLastSourceID1;
	static unsigned int nLastSourceID2;
	static unsigned int nLastSourceID3;

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2 && SourceID3 == nLastSourceID3)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	nLastSourceID3 = SourceID3;
	LeaveCriticalSection(&g_csEventlogLock);

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[1] = (char*) strSource;                                     
	cch = CchLoadStringOfId(SourceID3, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[2] = (char*) strSource;                                     	
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_3, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 3, (LPCSTR *) aInsertStrs );  	
	return;
	}  

/*===================================================================
void MSG_Error( UINT SourcID1, UINT SourceID2, UINT SourceID3, UINT SourceID4 )

report an event to the NT event log

INPUT: 
	four String table ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( UINT SourceID1, UINT SourceID2, UINT SourceID3, UINT SourceID4 )
	{
	static unsigned int nLastSourceID1;
	static unsigned int nLastSourceID2;
	static unsigned int nLastSourceID3;
	static unsigned int nLastSourceID4;

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2 && SourceID3 == nLastSourceID3 && SourceID4 == nLastSourceID4)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	nLastSourceID3 = SourceID3;
	nLastSourceID4 = SourceID4;
	LeaveCriticalSection(&g_csEventlogLock);	

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[1] = (char*) strSource;                                     
	cch = CchLoadStringOfId(SourceID3, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[2] = (char*) strSource;
	cch = CchLoadStringOfId(SourceID4, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[3] = (char*) strSource;
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_4, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 4, (LPCSTR *) aInsertStrs );  	
	return;
	}  

/*===================================================================
void MSG_Warning( LPCSTR strSource )

report an event to the NT event log

INPUT: 
	ptr to null-terminated string
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( LPCSTR strSource )
{
	static char	szLastError[MAX_MSG_LENGTH];

	EnterCriticalSection(&g_csEventlogLock);
	if (strcmp(strSource, szLastError) == 0)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}
	szLastError[0] = '\0';
	strncat(szLastError,strSource, MAX_MSG_LENGTH-1);
	LeaveCriticalSection(&g_csEventlogLock);

		ReportAnEvent( (DWORD) MSG_DENALI_WARNING_1, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 1, &strSource /*aInsertStrs*/ ); 
}
/*===================================================================
void MSG_Warning( UINT SourceID1)

report an event to the NT event log

INPUT: 
	String table message ID
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT SourceID1 )
	{

	static unsigned int nLastSourceID1;
	
	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	LeaveCriticalSection(&g_csEventlogLock);	
	
	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];	
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_1, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 1, (LPCSTR *) aInsertStrs );  	
	return;
	}  

/*===================================================================
void MSG_Warning( UINT, SOurceID1, UINT SourceID2 )

report an event to the NT event log

INPUT: 
	two string tabel message ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT SourceID1, UINT SourceID2 )
	{
	static unsigned int nLastSourceID1;
	static unsigned int nLastSourceID2;
	
	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	LeaveCriticalSection(&g_csEventlogLock);	

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[1] = (char*) strSource;                                     
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_2, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 2, (LPCSTR *) aInsertStrs );  	
	return;
	}  

/*===================================================================
void MSG_Warning( UINT SourceID1, UINT SourceID2, UINT SourceID3 )

report an event to the NT event log

INPUT: 
	three string table message ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT SourceID1, UINT SourceID2, UINT SourceID3)
	{

	static unsigned int nLastSourceID1;
	static unsigned int nLastSourceID2;
	static unsigned int nLastSourceID3;
	
	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2 && SourceID3 == nLastSourceID3)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	nLastSourceID3 = SourceID3;
	LeaveCriticalSection(&g_csEventlogLock);	

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[1] = (char*) strSource;                                     
	cch = CchLoadStringOfId(SourceID3, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[2] = (char*) strSource;
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_3, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 3, (LPCSTR *) aInsertStrs );  	
	return;
	}  

/*===================================================================
void MSG_Warning(  UINT SourceID1, UINT SourceID2, UINT SourceID3, UINT SourceID4 )

report an event to the NT event log

INPUT: 
	four String table message ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT SourceID1, UINT SourceID2, UINT SourceID3, UINT SourceID4 )
	{

	static unsigned int nLastSourceID1;
	static unsigned int nLastSourceID2;
	static unsigned int nLastSourceID3;
	static unsigned int nLastSourceID4;

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2 && SourceID3 == nLastSourceID3 && SourceID4 == nLastSourceID4)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	nLastSourceID3 = SourceID3;
	nLastSourceID4 = SourceID4;
	LeaveCriticalSection(&g_csEventlogLock);	

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[1] = (char*) strSource;                                     
	cch = CchLoadStringOfId(SourceID3, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[2] = (char*) strSource;
	cch = CchLoadStringOfId(SourceID4, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[3] = (char*) strSource;
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_4, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 4, (LPCSTR *) aInsertStrs );  	
	return;
	}

/*===================================================================
void MSG_Warning(  UINT ErrId, UINT cItem, CHAR **szItems )

report an event to the NT event log

INPUT: 
	four String table message ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT ErrId, UINT cItem, CHAR **szItems )
{
	static unsigned int LastErrId;
	
	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (ErrId == LastErrId)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	LastErrId = ErrId;
	LeaveCriticalSection(&g_csEventlogLock);
	
	MSG_Warning(ErrId);
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_4, (WORD) EVENTLOG_WARNING_TYPE, (WORD) cItem, (LPCSTR *) szItems );  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\error.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Error handling

File: Error.h

Owner: AndrewS

Include file for general error reporting routines for Denali.
===================================================================*/

#ifndef __ERROR_H
#define __ERROR_H

#include "hitobj.h"
#include "scrptmgr.h"




#define MAX_RESSTRINGSIZE		1024
// bug 840: must use these in both HandleErrorSz and CTemplate
#define	SZ_BREAKBOLD	"<BR><B>"
#define	SZ_UNBREAKBOLD	"<BR></B>"
const UINT	CCH_BREAKBOLD = strlen(SZ_BREAKBOLD);
const UINT	CCH_UNBREAKBOLD = strlen(SZ_UNBREAKBOLD);


/* format of default mask

32 bits

	31				16		8	4	0

	bit 0 - 4	default sink/output places.
	bit 0		NT Event Log
	bit 1		IIS log
	bit 2		Browser
	bit 3		Reserved

	bit 5 - 8	default predefined messages.(from registry)
	bit 5		use generic AccessDenied Message
	bit 6		use generic ScriptError Message
	bit 7 - 8	Reserved

	bit 9 - 10	to browser templates.(4 templates available)
				0x00	Default Script Template
				0x01	Empty Template/No Template
				0x10	System Template(mimic IIS style to Browser on HTTP errors, 204, 404, 500)
				0x11	Reserved
				
	bit 11 - 31	Reserved

*/
#define		ERR_LOGTONT					0x00000001
#define		ERR_LOGTOIIS				0x00000002
#define		ERR_LOGTOBROWSER			0x00000004

//Format(Script style is default, SYS style is for System error, 204, 404 and 500)
#define		ERR_FMT_SCRIPT				0x00000000
#define		ERR_FMT_SYS					0x00000200

#define		ERR_SetNoLogtoNT(x)			((x) & 0xfffffffe)
#define		ERR_SetNoLogtoIIS(x)		((x) & 0xfffffffd)
#define		ERR_SetNoLogtoBrowser(x)	((x) & 0xfffffffb)

#define		ERR_SetLogtoNT(x)			((x) | ERR_LOGTONT)
#define		ERR_SetLogtoIIS(x)			((x) | ERR_LOGTOIIS)
#define		ERR_SetLogtoBrowser(x)		((x) | ERR_LOGTOBROWSER)

#define		ERR_FLogtoNT(x)				((x) & ERR_LOGTONT)
#define		ERR_FLogtoIIS(x)			((x) & ERR_LOGTOIIS)
#define		ERR_FLogtoBrowser(x)		((x) & ERR_LOGTOBROWSER)
#define		ERR_FIsSysFormat(x)			((x) & ERR_FMT_SYS)

#define		ERR_SetSysFormat(x)			((x) | ERR_FMT_SYS)

//The order of the index is the order we send to the browser.(exclude header).
#define 	Im_szEngine				0
#define		Im_szErrorCode			1
#define 	Im_szShortDescription	2
#define 	Im_szFileName			3
#define 	Im_szLineNum			4
#define		Im_szCode				5
#define		Im_szLongDescription	6
#define		Im_szHeader				7
#define		Im_szItemMAX			8

// ASP HTTP sub-error codes for custom 500 errors
#define     SUBERRORCODE500_SERVER_ERROR             0
#define     SUBERRORCODE500_SHUTTING_DOWN           11
#define     SUBERRORCODE500_RESTARTING_APP          12
#define     SUBERRORCODE500_SERVER_TOO_BUSY         13
#define     SUBERRORCODE500_INVALID_APP             14
#define     SUBERRORCODE500_GLOBALASA_FORBIDDEN     15

class CErrInfo
	{
	friend HRESULT ErrHandleInit(void);
	friend HRESULT ErrHandleUnInit(void);
	friend HRESULT GetSpecificError(CErrInfo *pErrInfo,
									HRESULT hrError);
									
	friend HRESULT HandleSysError(	DWORD dwHttpError,
                                    DWORD dwHttpSubError,
	                                UINT ErrorID,
									UINT ErrorHeaderID,
									CIsapiReqInfo   *pIReq,
									CHitObj *pHitObj);

	friend HRESULT HandleOOMError(	CIsapiReqInfo   *pIReq,
									CHitObj *pHitObj);

	friend HRESULT HandleError(	CHAR *szShortDes,
								CHAR *szLongDes,
								DWORD mask,
								CHAR *szFileName, 
								CHAR *szLineNum, 
								CHAR *szEngine, 
								CHAR *szErrCode,
								CIsapiReqInfo   *pIReq, 
								CHitObj *pHitObj);

	friend HRESULT HandleError( IActiveScriptError *pscripterror,
								CTemplate *pTemplate,
								DWORD dwEngineID,
								CIsapiReqInfo   *pIReq, 
								CHitObj *pHitObj);

	friend HRESULT HandleError(	UINT ErrorID,
								CHAR *szFileName, 
								CHAR *szLineNum, 
								CHAR *szEngine,
								CHAR *szErrCode,
								CHAR *szLongDes,
								CIsapiReqInfo   *pIReq, 
								CHitObj *pHitObj,
                                va_list *pArgs = NULL);
	public:
		CErrInfo();

		inline LPSTR GetItem(DWORD iItem) { return m_szItem[iItem]; }
		inline void   GetLineInfo(BSTR *pbstrLineText, int *pnColumn)
			{ *pbstrLineText = m_bstrLineText, *pnColumn = m_nColumn; }

	private:
		//sink, either via CResponse(also use CIsapiReqInfo), or via WAM_EXEC_INFO
		CIsapiReqInfo               *m_pIReq;
		CHitObj						*m_pHitObj;

		// HTTP error code (404, 500, etc.) and sub error code
		DWORD                       m_dwHttpErrorCode;
		DWORD                       m_dwHttpSubErrorCode;
		
		//mask
		DWORD						m_dwMask;

		//data
		LPSTR						m_szItem[Im_szItemMAX];

		//line data (don't use m_szItem[] because data is BSTR
		BSTR						m_bstrLineText;
		int							m_nColumn;
		
		HRESULT						LogError();
		HRESULT						LogError(DWORD dwMask, LPSTR *szErrorString);
		
		HRESULT						LogErrortoNTEventLog(BOOL, BOOL);
		HRESULT						LogErrortoIISLog(BOOL *, BOOL *);
		HRESULT						LogErrortoBrowserWrapper();
		HRESULT						LogErrortoBrowser(CResponse *pResponse);
		HRESULT						LogErrortoBrowser(CIsapiReqInfo   *pIReq);
        HRESULT	                    LogCustomErrortoBrowser(CIsapiReqInfo   *pIReq, BOOL *pfCustomErrorProcessed);
		void						WriteHTMLEncodedErrToBrowser(const CHAR *StrIn, CResponse *pResponse, CIsapiReqInfo   *pIReq);
        HRESULT                     WriteCustomFileError(CIsapiReqInfo   *pIReq, TCHAR *szPath, TCHAR *szMimeType);
        HRESULT                     WriteCustomURLError(CIsapiReqInfo   *pIReq, TCHAR *szURL);
		
		HRESULT						ParseResourceString(CHAR *sz);
	};


//Error Handling APIs
//Case 1.a: Runtime Script Error(From Denali, VBS, JavaScript, or anyother Engines).
//example. Called by OnScriptError.
HRESULT HandleError( IActiveScriptError *pscripterror,
					 CTemplate *pTemplate,
					 DWORD dwEngineID,
					 CIsapiReqInfo   *pIReq, 
					 CHitObj *pHitObj );

//Case 1.b: Runtime Script Error(From Denali, VBS, JavaScript, or anyother Engines).
// Show error in debugger rather than the standard error logging.
HRESULT DebugError( IActiveScriptError *pScriptError, CTemplate *pTemplate, DWORD dwEngineID, IDebugApplication *pDebugApp);

//Case 2: Compiling time Script Error, 
//Also, this function is the most generic HandleError.
HRESULT HandleError(	CHAR *szShortDes,
						CHAR *szLongDes,
						DWORD dwMask,
						CHAR *szFileName, 
						CHAR *szLineNum, 
						CHAR *szEngine, 
						CHAR *szErrCode,
						CIsapiReqInfo   *pIReq, 
						CHitObj *pHitObj);

//Case 3: Predefined Error ID
HRESULT	HandleError(	UINT ErrorID,
						CHAR *szFileName, 
						CHAR *szLineNum, 
						CHAR *szEngine,
						CHAR *szErrCode,
						CHAR *szLongDes,
						CIsapiReqInfo   *pIReq, 
						CHitObj *pHitObj,
                        va_list *pArgs);
						
//Case 4: SystemDefined Error(so far, only 204, 404, and 500 can use this call)
//		 Implementation of this call will first send out the header, if ErrorHeaderID is not 0.
HRESULT HandleSysError(	DWORD dwHttpError,
                        DWORD dwHttpSubError,
                        UINT ErrorID,
						UINT ErrorHeaderID,
						CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj);

// 500 Error processing calls HandleSysError()
HRESULT Handle500Error( UINT ErrorID, CIsapiReqInfo   *pIReq);
						
//OOM, special attention, because Heap is full, and therefore, no dynamic allocation						
HRESULT HandleOOMError(	CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj);

//FileName missing
//		The caller has no file name, nor any other info about where or when
//		the error occurred.  Trys to get the filename from the hitobj
VOID HandleErrorMissingFilename(UINT    errorID, 
                                CHitObj *pHitObj,
                                BOOL    fVarArgs = FALSE,
                                ...);

//The following 2 calls are discouraged for error-handling usage.  
//Use one of the Error Handling APIs instead.
//Ok when loading other strings from resource file.
INT CchLoadStringOfId(UINT id, CHAR *sz, INT cchMax);
INT CwchLoadStringOfId(UINT id, WCHAR *sz, INT cchMax);


HRESULT ErrHandleInit(void);
HRESULT ErrHandleUnInit(void);

HRESULT	LoadErrResString(UINT ErrID/*IN*/, DWORD *dwMask, CHAR *szErrorCode, CHAR *szShortDes, CHAR *LongDes);
CHAR *SzScodeToErrorCode(HRESULT hrError);

BOOL HResultToWsz(HRESULT hrIn, WCHAR *wszOut, DWORD cdwOut);
BOOL HResultToSz(HRESULT hrIn, CHAR *szOut, DWORD cdwOut);


#endif __ERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\hostinfo.h ===
#ifndef HOST_INFO_H_INCLUDED
#define HOST_INFO_H_INCLUDED

// {1D044690-8923-11d0-ABD2-00A0C911E8B2}
const GUID IID_IHostInfoUpdate =
{ 0x1d044690, 0x8923, 0x11d0, { 0xab, 0xd2, 0x0, 0xa0, 0xc9, 0x11, 0xe8, 0xb2 } };

enum hostinfo
{
	hostinfoLocale = 0,
	hostinfoCodePage = 1
};

class IHostInfoUpdate : public IUnknown
{

	public:

	// *** IUnknown Methods ***
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj) = 0;
	STDMETHOD_(ULONG,AddRef)(void) = 0;
	STDMETHOD_(ULONG,Release)(void) = 0;

	// *** IHostInfoUpdate Methods ***

	STDMETHOD(UpdateInfo)(hostinfo hostinfoNew) = 0;
};

// {F8418AE0-9A5D-11d0-ABD4-00A0C911E8B2}
const GUID IID_IHostInfoProvider =
{ 0xf8418ae0, 0x9a5d, 0x11d0, { 0xab, 0xd4, 0x0, 0xa0, 0xc9, 0x11, 0xe8, 0xb2 } };

class IHostInfoProvider : public IUnknown
{

	public:

	// *** IUnknown Methods ***
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj) = 0;
	STDMETHOD_(ULONG,AddRef)(void) = 0;
	STDMETHOD_(ULONG,Release)(void) = 0;

	// *** IHostInfoProvider Methods ***

	STDMETHOD(GetHostInfo)(hostinfo hostinfoRequest, void * * ppvInfo) = 0;
};

#endif // HOST_INFO_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\hitobj.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: Hitobj.cpp

Owner: DmitryR


This file contains the CHitObj class implementation.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "context.h"
#include "exec.h"
#include "mtacb.h"
#include "perfdata.h"
#include "debugger.h"
#include "asperror.h"
#include "thrdgate.h"

#include "memchk.h"

//resource failure globals
#include "rfs.h"
#ifdef _RFS
MemRFS memrfs;
#endif


#ifdef SCRIPT_STATS

# define REG_ASP_DEBUG_LOCATION "System\\CurrentControlSet\\Services\\W3Svc\\ASP"

# define REG_STR_QUEUE_DEBUG_THRESHOLD "QueueDebugThreshold"
# define REG_DEF_QUEUE_DEBUG_THRESHOLD 25
DWORD g_dwQueueDebugThreshold = 0; // REG_DEF_QUEUE_DEBUG_THRESHOLD;

# define REG_STR_SEND_SCRIPTLESS_ON_ATQ_THREAD "SendScriptlessOnAtqThread"
# define REG_DEF_SEND_SCRIPTLESS_ON_ATQ_THREAD 1
DWORD g_fSendScriptlessOnAtqThread = REG_DEF_SEND_SCRIPTLESS_ON_ATQ_THREAD;


void
ReadRegistrySettings()
{
    HKEY hkey = NULL;
    DWORD dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_ASP_DEBUG_LOCATION,
                               0, KEY_READ, &hkey);
    if (dwErr == NO_ERROR)
    {
        DWORD dwType, dwBuffer;
        DWORD cbBuffer = sizeof(dwBuffer);

        dwErr = RegQueryValueEx(hkey, REG_STR_QUEUE_DEBUG_THRESHOLD,
                                NULL, &dwType, (LPBYTE) &dwBuffer, &cbBuffer);
        if (dwErr == NO_ERROR)
            g_dwQueueDebugThreshold = dwBuffer;

        dwErr = RegQueryValueEx(hkey, REG_STR_SEND_SCRIPTLESS_ON_ATQ_THREAD,
                                NULL, &dwType, (LPBYTE) &dwBuffer, &cbBuffer);
        if (dwErr == NO_ERROR)
            g_fSendScriptlessOnAtqThread = dwBuffer;

        RegCloseKey(hkey);
    }

    char szTemp[200];
    sprintf(szTemp, "RRS, err = %d, QueueDebugThreshold = %d, SendScriptlessOnAtqThread = %d\n",
            dwErr, g_dwQueueDebugThreshold, g_fSendScriptlessOnAtqThread);
    OutputDebugString(szTemp);
}


CSmallSpinLock g_lockRequestStats;
LONG           g_cRequests = 0;
LONG           g_cScriptlessRequests = 0;
LONG           g_cHttpExtensionsExecuting = 0;
LONG           g_cConcurrentScriptlessRequests = 0;
LONG           g_cMaxConcurrentScriptlessRequests = 0;
LONGLONG       g_nSumConcurrentScriptlessRequests = 0;
LONGLONG       g_nSumExecTimeScriptlessRequests = 0;
LONG           g_nAvgConcurrentScriptlessRequests = 0;
LONG           g_nAvgExecTimeScriptlessRequests = 0;

#endif // SCRIPT_STATS

DWORD g_nBrowserRequests = 0;
DWORD g_nSessionCleanupRequests = 0;
DWORD g_nApplnCleanupRequests = 0;

IGlobalInterfaceTable *g_pGIT = NULL;

/*===================================================================
CHitObj::CHitObj

Constructor 

Parameters:
    NONE

Returns:
    NONE
===================================================================*/   
CHitObj::CHitObj()
  : m_fInited(FALSE),
    m_ehtType(ehtUnInitedRequest),
    m_hImpersonate(hNil),
    m_pIReq(NULL),
    m_pResponse(NULL),
    m_pRequest(NULL),
    m_pServer(NULL),
    m_punkScriptingNamespace(NULL),
    m_dwObjectContextCookie(NULL_GIP_COOKIE),
    m_pPageCompCol(NULL),
    m_pPageObjMgr(NULL),
    m_pActivity(NULL),
    m_ecsActivityScope(csUnknown),
    m_SessionId(INVALID_ID, 0, 0),
    m_pSession(NULL),
    m_pAppln(NULL),
    m_fRunGlobalAsa(FALSE),
    m_fStartSession(FALSE),
    m_fNewCookie(FALSE),
    m_fStartApplication(FALSE),
    m_fApplnOnStartFailed(FALSE),
    m_fClientCodeDebug(FALSE),
    m_fCompilationFailed(FALSE),
    m_fExecuting(FALSE),
    m_fHideRequestAndResponseIntrinsics(FALSE),
    m_fHideSessionIntrinsic(FALSE),
    m_fDoneWithSession(FALSE),
    m_fRejected(FALSE),
    m_f449Done(FALSE),
    m_fInTransferOnError(FALSE),
    m_pScriptingContext(NULL),
    m_nScriptTimeout(0),
    m_eExecStatus(eExecSucceeded),
    m_eEventState(eEventNone),
    m_uCodePage(CP_ACP),
    m_lcid(LOCALE_SYSTEM_DEFAULT),
    m_dwtTimestamp(0),
    m_pEngineInfo(NULL),
    m_pdispTypeLibWrapper(NULL),
    m_szCurrTemplateVirtPath(NULL),
    m_szCurrTemplatePhysPath(NULL),
    m_pASPError(NULL),
    m_pTemplate(NULL),
    m_fSecure(FALSE)
    {
    }

/*===================================================================
CHitObj::~CHitObj

Destructor

Parameters:
    None 

Returns:
    None
===================================================================*/
CHitObj::~CHitObj( void )
    {
    Assert(!m_fExecuting); // no deletes while still executing

    if (FIsBrowserRequest())
        {
        if (m_hImpersonate != hNil)
            m_hImpersonate = hNil;
            
        if (m_pSession)
            DetachBrowserRequestFromSession();
        }

    if (m_pASPError) // Error object
        {
        m_pASPError->Release();
        m_pASPError = NULL;
        }
        
    if (m_pActivity) // page-level Viper activity
        {
        delete m_pActivity;
        m_pActivity = NULL;
        }

    StopComponentProcessing();

    if (m_pdispTypeLibWrapper)
        m_pdispTypeLibWrapper->Release();

    // update request counters in application and session manager
    
    if (m_pAppln)
        {
        if (FIsBrowserRequest())
            {
            m_pAppln->DecrementRequestCount();
            }
        else if (FIsSessionCleanupRequest() && m_pAppln->PSessionMgr())
            {
            m_pAppln->PSessionMgr()->DecrementSessionCleanupRequestCount();
            }
        }

    if (m_pTemplate)
        m_pTemplate->Release();

    // update global request counters
    
    if (FIsBrowserRequest())
        InterlockedDecrement((LPLONG)&g_nBrowserRequests);
    else if (FIsSessionCleanupRequest())
        InterlockedDecrement((LPLONG)&g_nSessionCleanupRequests);
    else if (FIsApplnCleanupRequest())
        InterlockedDecrement((LPLONG)&g_nApplnCleanupRequests);

    if (m_pIReq)
        m_pIReq->Release();
    }

/*===================================================================
CHitObj::NewBrowserRequest

Static method. Creates, Inits, Posts new browser request

Parameters:
    pIReq           CIsapiReqInfo
    pfRejected      [out] TRUE if rejected  (optional)
    pfCompeleted    [out] TRUE if comleted  (optional)
    piErrorId       [out] error id          (optional)

Returns:
    S_OK on success
    E_FAIL  on failure
===================================================================*/
HRESULT CHitObj::NewBrowserRequest
(
CIsapiReqInfo *pIReq,
BOOL *pfRejected,
BOOL *pfCompleted,
int  *piErrorId
)
    {
    HRESULT hr = S_OK;
    BOOL fRejected = FALSE;
    BOOL fCompleted = FALSE;
    int  iError = 0;

    CHitObj *pHitObj = new CHitObj;
    if (!pHitObj)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        {
        // Bracket BrowserRequestInit

        if (SUCCEEDED(StartISAThreadBracket(pIReq)))
            {
            hr = pHitObj->BrowserRequestInit(pIReq, &iError);

            if (SUCCEEDED(hr))
                {
                if (pHitObj->FDoneWithSession())
                    {
                    // finished while on I/O thread
                    fCompleted = TRUE;
                    delete pHitObj;
                    pHitObj = NULL;
                    }
                }
            else // if FAILED
                {
                if (iError == IDE_SERVER_TOO_BUSY)
                    fRejected = TRUE;
                }
            
            EndISAThreadBracket(pIReq);
            }
        else
            {
            hr = E_FAIL;
            }
        }

    // Post into Viper
    if (SUCCEEDED(hr) && !fCompleted)
        {
        hr = pHitObj->PostViperAsyncCall();

        if (FAILED(hr))
            fRejected = TRUE;
        }

    if (FAILED(hr) && pHitObj)
        {
        // Bracket HitObj destructor
        
        // This code is only executed if PostViperAsyncCall either
        // failed or was never called -- thus we don't worry about
        // everlapping bracketing with the worker thread.
        
        if (SUCCEEDED(StartISAThreadBracket(pIReq)))
            {
            pHitObj->m_fRejected = TRUE;
            delete pHitObj;
            
            EndISAThreadBracket(pIReq);
            }
        }

    if (pfRejected)
        *pfRejected = fRejected;
    if (pfCompleted)
        *pfCompleted = fCompleted;
    if (piErrorId)
        *piErrorId = iError;
    
    return hr;
}

/*===================================================================
HRESULT CHitObj::SetCodePage

Set Runtime CodePage, if fAllowSessionState is On, this will set 
Session.CodePage and we should always use Session.CodePage when we
call HitObj.GetCodePage when fAllowSessionState on.

HitObj.CodePage is only set when fAllowSessionState is off or 
ApplicationCleanup, because we don't have Session.CodePage anymore, session
does not even exist.

Parameters:
    UINT    uCodePage

Returns:
    S_OK on success
    E_FAIL  on failure
===================================================================*/
HRESULT CHitObj::SetCodePage(UINT uCodePage)
{
    HRESULT hr = S_OK;
    
    if (uCodePage == CP_ACP || IsValidCodePage(uCodePage))
        {
        m_uCodePage = uCodePage;

        // If engine info is available, notify the scripts engines that the code
        // page has changed
        if (m_pEngineInfo)
            {
            for (int i = 0; i < m_pEngineInfo->cActiveEngines; i++)
                {
                Assert(m_pEngineInfo->rgActiveEngines[i].pScriptEngine != NULL);
                m_pEngineInfo->rgActiveEngines[i].pScriptEngine->UpdateLocaleInfo(hostinfoCodePage); 
                }
            }

        return hr;
        }

    return E_FAIL;
}

/*===================================================================
HRESULT CHitObj::SetLCID

Set Runtime LCID, if fAllowSessionState is On, this will set 
Session.LCID and we should always use Session.LCID when we
call HitObj.LCID when fAllowSessionState on.

HitObj.LCID is only set when fAllowSessionState is off or 
ApplicationCleanup, because we don't have Session.CodePage anymore, session
does not even exist.

Parameters:
    LCID    lcid

Returns:
    S_OK on success
    E_FAIL  on failure
===================================================================*/
HRESULT CHitObj::SetLCID(LCID lcid)
{
    HRESULT hr = S_OK;

    if ((LOCALE_SYSTEM_DEFAULT == lcid) || IsValidLocale(lcid, LCID_INSTALLED))
        {
        m_lcid = lcid;

        // If engine info is available, notify the scripts engines that the
        // lcid has changed
        if (m_pEngineInfo)
            {
            for (int i = 0; i < m_pEngineInfo->cActiveEngines; i++)
                {
                Assert(m_pEngineInfo->rgActiveEngines[i].pScriptEngine != NULL);
                m_pEngineInfo->rgActiveEngines[i].pScriptEngine->UpdateLocaleInfo(hostinfoLocale); 
                }
            }

        return hr;
        }

    return E_FAIL;
}

/*===================================================================
HRESULT CHitObj::BrowserRequestInit

Initialize the request object

Parameters:
    CIsapiReqInfo   *pIReq
    int *pErrorId

Returns:
    S_OK on success
    E_FAIL  on failure
===================================================================*/
HRESULT CHitObj::BrowserRequestInit
(
CIsapiReqInfo   *pIReq,
int  *pErrorId 
)
    {
    HRESULT hr;

    m_pIReq = pIReq;

    m_pIReq->AddRef();

    m_ehtType = ehtBrowserRequest;
    InterlockedIncrement((LPLONG)&g_nBrowserRequests);

#ifdef SCRIPT_STATS
    InterlockedIncrement(&g_cRequests);
#endif // SCRIPT_STATS

    STACK_BUFFER( serverPortSecureBuff, 8 );
    DWORD cbServerPortSecure;
    if( !SERVER_GET (pIReq,"SERVER_PORT_SECURE", &serverPortSecureBuff, &cbServerPortSecure))
    {
        if (GetLastError() == E_OUTOFMEMORY) 
        {
            return E_OUTOFMEMORY;
        }
    }
    char *szServerPortSecure = (char *)serverPortSecureBuff.QueryPtr();
    m_fSecure = (szServerPortSecure[0] == '1' );

    // Ask W3SVC for the impersonation token so we can later impersonate on Viper's thread
    if (FIsWinNT())
        m_hImpersonate = m_pIReq->QueryImpersonationToken();

    // Uppercase path - BUGBUG - can't Normalize in place!!!!
    Normalize(m_pIReq->QueryPszPathTranslated());

    // Reject direct requests for global.asa file
    if (FIsGlobalAsa(m_pIReq->QueryPszPathTranslated(), m_pIReq->QueryCchPathTranslated()))
        {
        *pErrorId = IDE_GLOBAL_ASA_FORBIDDEN;
        return E_FAIL;
        }

    // Create page component collection
    hr = InitComponentProcessing();
    if (FAILED(hr))
        {
        *pErrorId = (hr == E_OUTOFMEMORY) ? IDE_OOM : IDE_INIT_PAGE_LEVEL_OBJ;
        return hr;
        }

    // Attach to application (or create a new one)
    BOOL fApplnRestarting = FALSE;
    hr = AssignApplnToBrowserRequest(&fApplnRestarting);
    if (FAILED(hr))
        {
		*pErrorId = fApplnRestarting ? IDE_GLOBAL_ASA_CHANGED
									 : IDE_ADD_APPLICATION;
        return E_FAIL;
        }

    // Get Session cookie, and misc flags from http header
    hr = ParseCookiesForSessionIdAndFlags();
    if (FAILED(hr)) // no cookie is not an error -- failed here means OOM
        return hr;

    // Remember script timeout value
    m_nScriptTimeout = m_pAppln->QueryAppConfig()->dwScriptTimeout();

    // Check if the session is needed
    BOOL fAllowSessions = m_pAppln->QueryAppConfig()->fAllowSessionState();
    BOOL fNeedSession = fAllowSessions;

    // Look if the template is cached
    CTemplate *pTemplate = NULL;

    // Find in cache - don't load if not in cache already
    hr = g_TemplateCache.FindCached
        (
        m_pIReq->QueryPszPathTranslated(),
        DWInstanceID(),
        &pTemplate
        );

    if (hr == S_OK)
        {
        Assert(pTemplate);
        
        // store the template away for later use...
        //pTemplate->AddRef();
        //m_pTemplate = pTemplate;

        if (fAllowSessions)
            {
            // check for session-less templates
            fNeedSession = pTemplate->FSession();
            }
        else
            {
#ifdef SCRIPT_STATS
            if (pTemplate->FScriptless())
                InterlockedIncrement(&g_cScriptlessRequests);
#endif // SCRIPT_STATS

            // check for scipt-less templates to be
            // completed on the I/O thread (when no debugging)
            if (
#ifdef SCRIPT_STATS
                g_fSendScriptlessOnAtqThread &&
#endif // SCRIPT_STATS
                pTemplate->FScriptless() && !m_pAppln->FDebuggable())
                {
#ifdef SCRIPT_STATS
                LONG c = InterlockedIncrement(&g_cConcurrentScriptlessRequests);
                DWORD dwTime = GetTickCount();
#endif // SCRIPT_STATS

                if (SUCCEEDED(CResponse::SyncWriteScriptlessTemplate(m_pIReq, pTemplate)))
                    {
#ifndef PERF_DISABLE
                    g_PerfData.Incr_REQPERSEC();
                    g_PerfData.Incr_REQSUCCEEDED();
#endif
                    m_fDoneWithSession = TRUE;  // do not post to MTS
                    }

#ifdef SCRIPT_STATS
                dwTime = GetTickCount() - dwTime;
                InterlockedDecrement(&g_cConcurrentScriptlessRequests);
                
                g_lockRequestStats.WriteLock();
                    g_nSumExecTimeScriptlessRequests += dwTime;

                    if (c > g_cMaxConcurrentScriptlessRequests)
                        g_cMaxConcurrentScriptlessRequests = c;
                    g_nSumConcurrentScriptlessRequests += c;

                    g_nAvgConcurrentScriptlessRequests = (LONG)
                        (g_nSumConcurrentScriptlessRequests
                         / g_cScriptlessRequests);
                    g_nAvgExecTimeScriptlessRequests = (LONG)
                        (g_nSumExecTimeScriptlessRequests
                         / g_cScriptlessRequests);
                g_lockRequestStats.WriteUnlock();
#endif // SCRIPT_STATS
                }
            }

        // When possible, generate 449 cookies while on I/O thread
        if (!m_fDoneWithSession)
            {
                if (!SUCCEEDED(pTemplate->Do449Processing(this)))
                    g_TemplateCache.Flush(m_pIReq->QueryPszPathTranslated(), DWInstanceID());
            }

        pTemplate->Release();
        }

    // initialize CodePage and LCID to the app defaults...

    m_uCodePage = PAppln()->QueryAppConfig()->uCodePage();

    m_lcid = PAppln()->QueryAppConfig()->uLCID();

    if (!fNeedSession || m_fDoneWithSession)
    {
        m_fInited = TRUE;
        return S_OK;
    }

    // Attach to session or create a new one
    BOOL fNewSession, fNewCookie;
    hr = AssignSessionToBrowserRequest(&fNewSession, &fNewCookie, pErrorId);

    if (FAILED(hr))
        return E_FAIL;

    Assert(m_pSession);
    
    // Move from inside "if (fNewSesson)"
    if (fNewCookie)
        m_fNewCookie = TRUE;

    if (fNewSession)
        {
        m_fStartSession = TRUE;

        if (m_pAppln->FHasGlobalAsa())
            m_fRunGlobalAsa = TRUE;
        }

    m_fInited = TRUE;
    return S_OK;
    }

/*===================================================================
CHitObj::AssignApplnToBrowserRequest

Find or create a new appln for this browser request
Does the appln manager locking

Parameters:
    pfApplnRestarting   [out] flag - failed because the appln
                                     found is restarting

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::AssignApplnToBrowserRequest
(
BOOL *pfApplnRestarting
)
    {
    HRESULT hr;
    
    Assert(pfApplnRestarting);
    *pfApplnRestarting = FALSE;
    
    Assert(!m_pAppln);

    TCHAR *szAppMDPath = m_pIReq->QueryPszApplnMDPath();
    if (!szAppMDPath)
        return E_FAIL;
        
    // Lock the application manager
    g_ApplnMgr.Lock();

    // Find by application by metabase key
    CAppln *pAppln;
    hr = g_ApplnMgr.FindAppln(szAppMDPath, &pAppln);

    if (hr == S_OK)
        {
        // Reject requests for restarting applications
        if (pAppln->FGlobalChanged())
            {
            *pfApplnRestarting = TRUE;
            g_ApplnMgr.UnLock();
            return E_FAIL;
            }
        // Update appln config from metabase if needed
        else if (pAppln->FConfigNeedsUpdate())
            {
            // If debugging flag has changed, then restart the application
            BOOL fRestartAppln = FALSE;
            BOOL fFlushAll = FALSE;
            pAppln->UpdateConfig(m_pIReq, &fRestartAppln, &fFlushAll);

            if (fRestartAppln)
                {
                pAppln->Restart(TRUE);      // force a restart
                pAppln = NULL;

                if (fFlushAll)  // flush all can only happen when restart is TRUE
                    {
                    // do flush while unlocked
                    g_ApplnMgr.UnLock();
                    g_TemplateCache.FlushAll();
                    g_ApplnMgr.Lock();
                    }
                
                // Find again
                hr = g_ApplnMgr.FindAppln(szAppMDPath, &pAppln);

                // Reject if still restarting
                if (hr == S_OK && pAppln->FGlobalChanged())
                    {
                    *pfApplnRestarting = TRUE;
                    g_ApplnMgr.UnLock();
                    return E_FAIL;
                    }
                }
            else
                {
                // adjust sctipt killer timeout
                g_ScriptManager.AdjustScriptKillerTimeout
                    (
                    // application timeout / 2 (in ms)
                    pAppln->QueryAppConfig()->dwScriptTimeout() * 500
                    );
                }
            }
        }
        
    if (hr != S_OK) // Application NOT found
        {
        TCHAR *szAppPhysicalPath = GetSzAppPhysicalPath();
        if (!szAppPhysicalPath)
            {
            g_ApplnMgr.UnLock();
            return E_FAIL;
            }

        // try to create a new one
        hr = g_ApplnMgr.AddAppln
            (
            szAppMDPath, // metabase key 
            szAppPhysicalPath, 
            m_pIReq,
            m_hImpersonate,
            &pAppln
            );

        if (FAILED(hr))
            {
            g_ApplnMgr.UnLock();
            free (szAppPhysicalPath);
            return hr;
            }

        // Check for GLOBAL.ASA

        TCHAR szGlobalAsaPath[MAX_PATH*2];
        DWORD cchPath = _tcslen(szAppPhysicalPath);
        _tcscpy(szGlobalAsaPath, szAppPhysicalPath);

        // BUG FIX: 102010 DBCS code fixes
        //if (szGlobalAsaPath[cchPath-1] != '\\')
        if ( *CharPrev(szGlobalAsaPath, szGlobalAsaPath + cchPath) != _T('\\'))
            szGlobalAsaPath[cchPath++] = _T('\\');
            
        _tcscpy(szGlobalAsaPath+cchPath, SZ_GLOBAL_ASA);

        // Check if GLOBAL.ASA exists
        BOOL fGlobalAsaExists = FALSE;
        if (SUCCEEDED(AspGetFileAttributes(szGlobalAsaPath)))
            {
            fGlobalAsaExists = TRUE;
            }
        else if (GetLastError() == ERROR_ACCESS_DENIED)
            {
            // If the current user doesn't have access (could happen when
            // there's an ACL on directory) try under SYSTEM user
            
            if (m_hImpersonate)
                {
                RevertToSelf();
                if (SUCCEEDED(AspGetFileAttributes(szGlobalAsaPath)))
                    fGlobalAsaExists = TRUE;
                HANDLE hThread = GetCurrentThread();
                SetThreadToken(&hThread, m_hImpersonate);
                }
            }

        if (fGlobalAsaExists)
            pAppln->SetGlobalAsa(szGlobalAsaPath);

        // Start monitoring application directory to
        // catch changes to GLOBAL.ASA even if it's not there
        if (FIsWinNT())
            {
            g_FileAppMap.AddFileApplication(szGlobalAsaPath, pAppln);
            CASPDirMonitorEntry *pDME = NULL;
            if (RegisterASPDirMonitorEntry(szAppPhysicalPath, &pDME, TRUE))
                pAppln->AddDirMonitorEntry(pDME);
            }

        free(szAppPhysicalPath);
        szAppPhysicalPath = NULL;

        // Update config from registry - don't care about restart
        // application is fresh baked
        pAppln->UpdateConfig(m_pIReq);

        // Adjust script killer timeout to current application
        g_ScriptManager.AdjustScriptKillerTimeout
            (
            // application timeout / 2 (in ms)
            pAppln->QueryAppConfig()->dwScriptTimeout() * 500
            );
        }

    // We have an application at this point
    Assert(pAppln);
    m_pAppln = pAppln;

    // Increment request count before releasing ApplMgr lock
    // to make sure it will not remove the app from under us
    m_pAppln->IncrementRequestCount();

    // Unlock the application manager
    g_ApplnMgr.UnLock();

    return S_OK;
    }
    
/*===================================================================
CHitObj::AssignSessionToBrowserRequest

Find or create a new session for this browser request
Does the session manager locking

Parameters:
    pfNewSession        [out] flag - new session created
    pfNewCookie         [out] flag - new cookie crated
    pErrorId            [out] -- error ID if failed

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::AssignSessionToBrowserRequest
(
BOOL *pfNewSession,
BOOL *pfNewCookie,
int  *pErrorId
)
    {
    Assert(pfNewSession);
    Assert(pfNewCookie);
    
    Assert(!m_pSession);

    // Local vars

    BOOL fTooManySessions = FALSE;
    BOOL fUseNewSession = FALSE;
    BOOL fUseOldSession = FALSE;
    BOOL fUseNewCookie = FALSE;
    
    CSession *pNewSession = NULL; // newly created
    CSession *pOldSession = NULL; // existing session that is found
    
    BOOL fReuseIdAndCookie = FALSE;
    BOOL fValidId = g_SessionIdGenerator.IsValidId(m_SessionId.m_dwId);

    HRESULT hr = S_OK;

    CSessionMgr *pSessionMgr = m_pAppln->PSessionMgr();

    while (1)
        {
        // Try to find session by Id

        if (fValidId)
            {
            pSessionMgr->LockMaster();
            
            pOldSession = NULL;
            HRESULT hrFind = pSessionMgr->FindInMasterHash
                (
                m_SessionId,
                &pOldSession
                );

            // Good old Session?
            if (hrFind == NOERROR) // QFE has this condition as hrFind == NOERROR  
                {
                Assert(pOldSession);

                // If AspKeepSessionIDSecure is set in metabase and
                // they are going from a nonsecure to a secure connection then 
                // transition the user from their old http sessionid to their
                // new https secure session id
                if (QueryAppConfig()->fKeepSessionIDSecure() &&
                    FSecure() &&
                    !pOldSession->FSecureSession()
                    )
                {
                    // Generate New Cookie
                    hr = pSessionMgr->GenerateIdAndCookie
                        (
                        &m_SessionId,
                        m_szSessionCookie
                        );
                            
                    if (SUCCEEDED(hr))
                    {
                        hr = pSessionMgr->ChangeSessionId(pOldSession,m_SessionId);
                    }            

                    if (FAILED(hr))
                    {
                        pSessionMgr->UnLockMaster();
                        break;
                    }

                    pOldSession->SetSecureSession(TRUE);
                    fUseNewCookie = TRUE;                    
                }
                
                // Increment request count before unlock to avoid 
                // deletion of the session by other threads
                pOldSession->IncrementRequestsCount();
                pSessionMgr->UnLockMaster();
                fUseOldSession = TRUE;
                break;
                }

            // Bad old Session?
            else if (pOldSession)
                {
                pSessionMgr->UnLockMaster();
                fValidId = FALSE;
                }

            // No old session and we have a new session to insert?
            else if (pNewSession)
                {
                hr = pSessionMgr->AddToMasterHash(pNewSession);
                    
                if (SUCCEEDED(hr))
                    {
                    // Increment request count before unlock to avoid 
                    // deletion of the session by other threads
                    pNewSession->IncrementRequestsCount();
                    fUseNewSession = TRUE;
                    }
                pSessionMgr->UnLockMaster();
                break;
                }

            // No old session and no new session
            else
                {
                pSessionMgr->UnLockMaster();

                if (FSecure () && QueryAppConfig()->fKeepSessionIDSecure())
                    {
                        fValidId = FALSE;
                    }                
                }
            }

        // Generate id and cookie when needed

        if (!fValidId)  // 2nd time generate new id
            {
            hr = pSessionMgr->GenerateIdAndCookie
                (
                &m_SessionId,
                m_szSessionCookie
                );
            if (FAILED(hr))
                break;
            fValidId = TRUE;
            fUseNewCookie = TRUE;
            }
        
        // Create new session object if needed

        if (!pNewSession)
            {
            // Enforce the session limit for the application
            DWORD dwSessionLimit = m_pAppln->QueryAppConfig()->dwSessionMax();
            if (dwSessionLimit != 0xffffffff && dwSessionLimit != 0 &&
                m_pAppln->GetNumSessions() >= dwSessionLimit)
                {
                fTooManySessions = TRUE;
                hr = E_FAIL;
                break;
                }

            hr = pSessionMgr->NewSession(m_SessionId, &pNewSession);
            if (FAILED(hr))
                break;
            }
        else
            {
            // Assign new id to already created new session
            pNewSession->AssignNewId(m_SessionId);
            }

        // continue with the loop
        }

    // the results

    if (fUseNewSession)
        {
        Assert(SUCCEEDED(hr));
        Assert(pNewSession);

        m_pSession = pNewSession;
        m_pSession->SetSecureSession(FSecure());
        pNewSession = NULL;  // not to be deleted later
        }
    else if (fUseOldSession)
        {
        Assert(SUCCEEDED(hr));
        Assert(pOldSession);
        
        m_pSession = pOldSession;
        }
    else
        {
        Assert(FAILED(hr));
        
        *pErrorId = fTooManySessions ? IDE_TOO_MANY_USERS : IDE_ADD_SESSION;
        }
        
    // cleanup new session if unused
    if (pNewSession)
        {
        pNewSession->UnInit();
        pNewSession->Release();
        pNewSession = NULL;
        }

    if (m_pSession && m_pSession->FCodePageSet()) {
        m_uCodePage = m_pSession->GetCodePage();
    }
    else {
        m_uCodePage = PAppln()->QueryAppConfig()->uCodePage();
    }

    if (m_pSession && m_pSession->FLCIDSet()) {
        m_lcid = m_pSession->GetLCID();
    }
    else {
        m_lcid = PAppln()->QueryAppConfig()->uLCID();
    }

    // return flags
    *pfNewSession = fUseNewSession;
    *pfNewCookie  = fUseNewCookie;
    return hr;
    }

/*===================================================================
CHitObj::DetachBrowserRequestFromSession

Removes session from browser request.
Does session clean-up when needed

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::DetachBrowserRequestFromSession()
    {
    Assert(m_pSession);
    Assert(m_pSession->PAppln());

    if (IsShutDownInProgress() || m_pSession->FInTOBucket())
        {
        // nothing fancy on shutdown
        
        // or if the session is still in the timeout bucket
        // (could happen for rejected requests)
        
        m_pSession->DecrementRequestsCount();
        m_pSession = NULL;
        return S_OK;
        }
        
    CSessionMgr *pSessionMgr = m_pSession->PAppln()->PSessionMgr();
    Assert(pSessionMgr);

     // try to delete this session if this is the last pending request
    if (m_pSession->GetRequestsCount() == 1)
        {
        // convert to lightweight if possible
        m_pSession->MakeLightWeight();

        // check if need to delete now
        if (m_pSession->FShouldBeDeletedNow(TRUE))
            {
            pSessionMgr->LockMaster();

            // check if still need to delete now after locking
            if (m_pSession->FShouldBeDeletedNow(TRUE))
                {
                pSessionMgr->RemoveFromMasterHash(m_pSession);
                pSessionMgr->UnLockMaster();
                
                m_pSession->DecrementRequestsCount();
                pSessionMgr->DeleteSession(m_pSession, TRUE);
                m_pSession = NULL;
                return S_OK;
                }

            pSessionMgr->UnLockMaster();
            }
        }

    // We can end up here for a rejected requests only if there are
    // other (non-rejected) requests for this session.
    //
    // The category of rejected here does not include rejected because
    // of the RequestQueueMax. This only applies to real OOM situations.
    //
    // In case of rejected request or if there are other pending
    // requests for this, session these other requests will take
    // care of reinserting the session into the timeout bucket.
    //
    // Rejected requests are NOT serialized -- they don't run on Viper
    // threads. Inserting the session into a timeout bucket for a
    // rejected request might create a race condition with regular requests.
    
    if (!m_fRejected && m_pSession->GetRequestsCount() == 1)
        {
        // Insert into proper timeout bucket
        if (pSessionMgr->FIsSessionKillerScheduled())
            {
            pSessionMgr->UpdateSessionTimeoutTime(m_pSession);
            pSessionMgr->AddSessionToTOBucket(m_pSession);
            }
        }
    
    m_pSession->DecrementRequestsCount();

    // session is no longer attached to the request
    m_pSession = NULL;
    
    return S_OK;
    }

/*===================================================================
void CHitObj::SessionCleanupInit

Initialize a request object for session cleanup

Parameters:
    CSession *pSession      Session object context

Returns:
    NONE
===================================================================*/
void CHitObj::SessionCleanupInit
(
CSession * pSession
)
    {
    m_ehtType = ehtSessionCleanup;
    InterlockedIncrement((LPLONG)&g_nSessionCleanupRequests);

    HRESULT hr = InitComponentProcessing();
    if (FAILED(hr))
        {
        if (hr == E_OUTOFMEMORY)
            HandleOOMError(NULL, NULL);
        }

    m_pSession      = pSession;
    m_pAppln        = pSession->PAppln();
    m_fRunGlobalAsa = TRUE;
    m_pIReq          = NULL;

    if (m_pAppln->PSessionMgr())
        m_pAppln->PSessionMgr()->IncrementSessionCleanupRequestCount();

    m_fInited = TRUE;
    }

/*===================================================================
void CHitObj::ApplicationCleanupInit

Initializes a request object for application cleanup

Parameters:
    CAppln *        pAppln      Application object context

Returns:
    NONE
===================================================================*/
void CHitObj::ApplicationCleanupInit( CAppln * pAppln )
{
    m_ehtType = ehtApplicationCleanup;
    InterlockedIncrement((LPLONG)&g_nApplnCleanupRequests);

    // If OOM here, then cleanup request does not get a server object.
    HRESULT hr = InitComponentProcessing();
    if (FAILED(hr))
        {
        if (hr == E_OUTOFMEMORY)
            HandleOOMError(NULL, NULL);
        }
        
    m_pAppln = pAppln;
    m_fRunGlobalAsa = TRUE;
    m_pIReq = NULL;

    m_fInited = TRUE;
}

/*===================================================================
CHitObj::ReassignAbandonedSession

Reassign ID of a the session being abandonded thus
detaching it from the client

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::ReassignAbandonedSession()
    {
    HRESULT hr = E_FAIL;
    
    Assert(m_pSession);
    Assert(m_pAppln);
    m_pAppln->AssertValid();

    hr = m_pAppln->PSessionMgr()->GenerateIdAndCookie
        (
        &m_SessionId,
        m_szSessionCookie
        );

    if (SUCCEEDED(hr))
        {
        hr = m_pAppln->PSessionMgr()->ChangeSessionId
            (
            m_pSession,
            m_SessionId
            );
        }
                            
    return hr;
    }

/*===================================================================
void CHitObj::FObjectTag

Check if the object passed in as argument is an object tag
created object.

Parameters:
    IDispatch * pDispatch   pointer to object

Returns:
    TRUE    Is a object tag created object
    FALSE   Otherwise
===================================================================*/
BOOL CHitObj::FObjectTag( IDispatch * pDispatch )
{
    if (!m_pPageObjMgr)
        return FALSE;
        
    BOOL fRet = TRUE;

    CComponentObject *pObj = NULL;
    HRESULT hr = m_pPageObjMgr->
        FindAnyScopeComponentByIDispatch(pDispatch, &pObj);

    return (SUCCEEDED(hr) && pObj);
}

/*  buffer allows space for: <user cookie>  +    CCH_SESSION_ID_COOKIE  +   =   +   <cookie>        +   '\0')
                                50          +       20                  +   1   +   SESSIONID_LEN   +   1
    NOTE we arbitrarily allow 50 bytes for <user cookie>
    NOTE if CCH_SESSION_ID_COOKIE changes, CCH_BUFCOOKIES_DEFAULT must be changed accordingly
*/
#define CCH_BUFCOOKIES_DEFAULT  72 + SESSIONID_LEN

/*===================================================================
CHitObj::ParseCookiesForSessionIdAndFlags

Extracts Cookie from CIsapiReqInfo.

Parameters:

Side Effects:
    Initializes m_SessionId, m_SessionIdR1, m_SessionIdR2 and
                m_szSessionCookie
    Sets m_fClientCodeDebug flag

Returns:
    S_OK        Extracted cookie value successfully
    S_FALSE     Success, but no cookie found
    other       error
===================================================================*/
HRESULT CHitObj::ParseCookiesForSessionIdAndFlags()
    {
    Assert(m_pAppln);
    CAppConfig *pAppConfig = m_pAppln->QueryAppConfig();
    
    // Are we interested in ANY cookies?

    if (!pAppConfig->fAllowSessionState() && 
        !pAppConfig->fAllowClientDebug())
        return S_OK;

    // If session cookie is needed init it

    if (pAppConfig->fAllowSessionState())
        {
        m_SessionId.m_dwId = INVALID_ID;
        m_szSessionCookie[0] = '\0';
        }

    // Get cookies from WAM_EXEC_INFO
    char *szBufCookies = m_pIReq->QueryPszCookie();
    if (!szBufCookies || !*szBufCookies)
        return S_OK; // no cookies

    // Obtain Session Cookie (and ID) if needed
        
    if (pAppConfig->fAllowSessionState())
        {
        char *pT;

        if (pT = strstr(szBufCookies, g_szSessionIDCookieName))
            {
            pT += CCH_SESSION_ID_COOKIE;
            if (*pT == '=')
                {
                pT++;
                if (strlen( pT ) >= SESSIONID_LEN)
                    {
                    memcpy(m_szSessionCookie, pT, SESSIONID_LEN);
                    m_szSessionCookie[SESSIONID_LEN] = '\0';
                    }
                }
            }

        // validate and try to decode the session id cookie
        if (m_szSessionCookie[0] != '\0')
            {
            if (FAILED(DecodeSessionIdCookie
                    (
                    m_szSessionCookie,
                    &m_SessionId.m_dwId, 
                    &m_SessionId.m_dwR1,
                    &m_SessionId.m_dwR2
                    )))
                {
                m_SessionId.m_dwId = INVALID_ID;
                m_szSessionCookie[0] = '\0';
                }
            }
        }

    // Look for Client Debug enabling cookie

    if (pAppConfig->fAllowClientDebug())
        {
        if (strstr(szBufCookies, SZ_CLIENT_DEBUG_COOKIE"="))
            m_fClientCodeDebug = TRUE;
        }

    return S_OK;
    }

/*===================================================================
BOOL CHitObj::GetSzAppPhysicalPath

Extracts application directory from WAM_EXEC_INFO

Parameters:

Side Effects:
On success, allocate memory for pszAppPhysicalPath

Returns:
    TRUE        AppPhysicalPath
    FALSE       NULL
===================================================================*/
TCHAR *CHitObj::GetSzAppPhysicalPath()
{
    DWORD  dwSizeofBuffer = 265*sizeof(TCHAR);
    TCHAR  *pszAppPhysicalPathLocal = (TCHAR *)malloc(dwSizeofBuffer);
    CHAR   *pszApplPhysPathVarName;

    if (!pszAppPhysicalPathLocal)
        return NULL;

#if UNICODE
    pszApplPhysPathVarName = "UNICODE_APPL_PHYSICAL_PATH";
#else
    pszApplPhysPathVarName = "APPL_PHYSICAL_PATH";
#endif

    BOOL fFound = m_pIReq->GetServerVariable
        (
        pszApplPhysPathVarName, 
        pszAppPhysicalPathLocal, 
        &dwSizeofBuffer
        );

    if (!fFound)
        {
        DWORD dwErr = GetLastError();

        if (ERROR_INSUFFICIENT_BUFFER == dwErr)
            {
            // Not Enough Buffer
            free(pszAppPhysicalPathLocal);
            pszAppPhysicalPathLocal = (TCHAR *)malloc(dwSizeofBuffer);
            if (pszAppPhysicalPathLocal)
                {
                // Try again
                fFound = m_pIReq->GetServerVariable
                    (
                    pszApplPhysPathVarName, 
                    pszAppPhysicalPathLocal, 
                    &dwSizeofBuffer
                    );
                }
            }
        }

    if (!fFound) {
        if (pszAppPhysicalPathLocal) {
            free(pszAppPhysicalPathLocal);
            pszAppPhysicalPathLocal = NULL;
        }
    }
    else
        {
        Assert(pszAppPhysicalPathLocal);
        Normalize(pszAppPhysicalPathLocal);
        }

    return pszAppPhysicalPathLocal;
    }

/*===================================================================
CHitObj::InitComponentProcessing

Creates and inits component collection and page object manager

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::InitComponentProcessing()
    {
    Assert(!m_pPageCompCol);
    Assert(!m_pPageObjMgr);

    HRESULT hr = S_OK;

    // Page component collection

    m_pPageCompCol = new CComponentCollection;
    if (!m_pPageCompCol)
        return E_OUTOFMEMORY;

    hr = m_pPageCompCol->Init(csPage);
    if (FAILED(hr))
        return hr;

    // Page object manager
        
    m_pPageObjMgr = new CPageComponentManager;
    if (!m_pPageObjMgr)
        return E_OUTOFMEMORY;

    hr = m_pPageObjMgr->Init(this);
    if (FAILED(hr))
        return hr;

    return S_OK;
    }

/*===================================================================
CHitObj::StopComponentProcessing

Deletes component collection and page object manager

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::StopComponentProcessing()
    {
    if (m_pPageObjMgr)
        {
        delete m_pPageObjMgr;
        m_pPageObjMgr = NULL;
        }

    if (m_pPageCompCol)
        {
        delete m_pPageCompCol;
        m_pPageCompCol = NULL;
        }

    if (m_punkScriptingNamespace)
        {
        m_punkScriptingNamespace->Release();
        m_punkScriptingNamespace = NULL;
        }
        
    if (m_dwObjectContextCookie != NULL_GIP_COOKIE)
        {
        RemoveObjectContext();
        }

    return S_OK;
    }
    
/*===================================================================
CHitObj::GetPageComponentCollection

Returns component collection for page

Parameters:
    CComponentCollection **ppCollection     output

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::GetPageComponentCollection
(
CComponentCollection **ppCollection
)
    {
    *ppCollection = m_pPageCompCol;
    return (*ppCollection) ? S_OK : TYPE_E_ELEMENTNOTFOUND;
    }

/*===================================================================
CHitObj::GetSessionComponentCollection

Returns component collection for session

Parameters:
    CComponentCollection **ppCollection     output

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::GetSessionComponentCollection
(
CComponentCollection **ppCollection
)
    {
    if (m_pSession)
        {
        *ppCollection = m_pSession->PCompCol();

        if (*ppCollection == NULL             &&  // no collection
            m_eEventState != eEventAppOnStart &&  // not an application
            m_eEventState != eEventAppOnEnd)      //       level event
            {
            // init session collection on demand
            HRESULT hr = m_pSession->CreateComponentCollection();
            if (SUCCEEDED(hr))
                *ppCollection = m_pSession->PCompCol();
            }
        }
    else
        *ppCollection = NULL;
        
    return (*ppCollection) ? S_OK : TYPE_E_ELEMENTNOTFOUND;
    }

/*===================================================================
CHitObj::GetApplnComponentCollection

Returns component collection for application

Parameters:
    CComponentCollection **ppCollection     output

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::GetApplnComponentCollection
(
CComponentCollection **ppCollection
)
    {
    if (m_pAppln)
        *ppCollection = m_pAppln->PCompCol();
    else
        *ppCollection = NULL;
        
    return (*ppCollection) ? S_OK : TYPE_E_ELEMENTNOTFOUND;
    }

/*===================================================================
CHitObj::AddComponent

Adds uninstantiated tagged object to appropriate
component collection

Parameters:
    CompType  type
    const CLSID &clsid
    CompScope scope
    CompModel model
    LPWSTR     pwszName
    IUnknown  *pUnk

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::AddComponent
(
CompType  type,
const CLSID &clsid,
CompScope scope,
CompModel model,
LPWSTR    pwszName,
IUnknown *pUnk
)
    {
    Assert(m_pPageObjMgr);
    m_pPageObjMgr->AssertValid();
 
    Assert(type == ctTagged);
    
    HRESULT hr = m_pPageObjMgr->AddScopedTagged
        (
        scope, 
        pwszName,
        clsid,
        model
        );

    return hr;
    }

/*===================================================================
CHitObj::GetComponent

Finds CComponentObject by scope and name

Parameters:
    CompScope         scope        can be csUnknown
    LPWSTR            pwszName     name to find
    DWORD             cbName       name length (in bytes)
    CComponentObject **ppObj       (out) object found

Returns:
    HRESULT     S_OK on success
                TYPE_E_ELEMENTNOTFOUND if the object wasnt found
                Other HRESULT if object fails to instantiate
===================================================================*/
HRESULT CHitObj::GetComponent
(
CompScope          scope, 
LPWSTR             pwszName, 
DWORD              cbName,
CComponentObject **ppObj
)
    {
    Assert(ppObj);
    *ppObj = NULL;

    if (!m_pPageObjMgr)
        return TYPE_E_ELEMENTNOTFOUND;
    
    BOOL fNewInstance = FALSE;
    HRESULT hr = m_pPageObjMgr->GetScopedObjectInstantiated
        (
        scope,
        pwszName,
        cbName,
        ppObj,
        &fNewInstance
        );

	if (FAILED(hr))
		return hr;

    // If an object that restricts threading has been instantiateed
    // as the session's tagged <OBJECT>, and the session's activity
    // runs this request, then bind the session's activity to thread

    if ((*ppObj)->GetScope() == csSession  && // session scope component
        m_ecsActivityScope == csSession    && // session scope activity
        SUCCEEDED(hr)                      && // get object succeeded
        fNewInstance                       && // object was just instantiated
        *ppObj && !(*ppObj)->FAgile())      // the object is thread-locked
        {
        m_pSession->PActivity()->BindToThread();
        }

    return hr;
    }

/*===================================================================
CHitObj::GetIntrinsic

Finds Intrinsic by name

Parameters:
    LPWSTR            pwszName     name to find
    DWORD             cbName       name length (in bytes)
    IUnknown        **ppUnk        (out) object found

Returns:
    HRESULT     S_OK on success
                S_FALSE name of the instrinsic but it's missing
                TYPE_E_ELEMENTNOTFOUND if the object not found
===================================================================*/
HRESULT CHitObj::GetIntrinsic
(
LPWSTR     pwszName, 
DWORD      cbName,
IUnknown **ppUnk
)
    {
    Assert(ppUnk);
    *ppUnk = NULL;


    // Lookup table based on (wszName[0] - cbName) % 32
    // Works for both uppper and lower case names

    static enum IntrinsicType
        {
        itUnknown = 0,
        itObjContext,
        itNamespace,
        itAppln,
        itSession,
        itRequest,
        itResponse,
        itServer,
        itASPPageTLB,
        itASPGlobalTLB
        }
    rgitLookupEntries[] =
        {
        /* 0-1   */     itUnknown, itUnknown,
        /* 2     */ itResponse,
        /* 3     */     itUnknown,
        /* 4     */ itRequest,
        /* 5     */ itSession,
        /* 6     */     itUnknown,
        /* 7     */ itServer,
        /* 8     */     itUnknown,
        /* 9     */ itASPGlobalTLB,
        /* 10    */     itUnknown,
        /* 11    */ itAppln,
        /* 12    */     itUnknown,
        /* 13    */ itASPPageTLB,
        /* 14    */     itUnknown,
        /* 15    */ itNamespace,
        /* 16-20 */     itUnknown, itUnknown, itUnknown, itUnknown, itUnknown,
        /* 21    */ itObjContext,
        /* 22-31 */     itUnknown, itUnknown, itUnknown, itUnknown, itUnknown,
                        itUnknown, itUnknown, itUnknown, itUnknown, itUnknown
        };

    IntrinsicType itType = rgitLookupEntries
        [
        (pwszName[0] - cbName) & 0x1f   // &1f same as %32
        ];

    if (itType == itUnknown)  // most likely
        return TYPE_E_ELEMENTNOTFOUND;

    // Do the string comparison
    BOOL fNameMatch = FALSE;
    
    switch (itType)
        {
    case itNamespace:
        if (_wcsicmp(pwszName, WSZ_OBJ_SCRIPTINGNAMESPACE) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = m_punkScriptingNamespace;
            }
        break;

    case itResponse:
        if (_wcsicmp(pwszName, WSZ_OBJ_RESPONSE) == 0)
            {
            fNameMatch = TRUE;
            if (!m_fHideRequestAndResponseIntrinsics)
                *ppUnk = static_cast<IResponse *>(m_pResponse);
            }
        break;

    case itRequest:
        if (_wcsicmp(pwszName, WSZ_OBJ_REQUEST) == 0)
            {
            fNameMatch = TRUE;
            if (!m_fHideRequestAndResponseIntrinsics)
                *ppUnk = static_cast<IRequest *>(m_pRequest);
            }
        break;
        
    case itSession:
        if (_wcsicmp(pwszName, WSZ_OBJ_SESSION) == 0)
            {
            fNameMatch = TRUE;
            if (!m_fHideSessionIntrinsic)
                *ppUnk = static_cast<ISessionObject *>(m_pSession);
            }
        break;
        
    case itServer:
        if (_wcsicmp(pwszName, WSZ_OBJ_SERVER) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = static_cast<IServer *>(m_pServer);
            }
        break;
        
    case itAppln:
        if (_wcsicmp(pwszName, WSZ_OBJ_APPLICATION) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = static_cast<IApplicationObject *>(m_pAppln);
            }
        break;
        
    case itObjContext:
        if (_wcsicmp(pwszName, WSZ_OBJ_OBJECTCONTEXT) == 0)
            {
            IASPObjectContext* pASPObjectContext = NULL;

            // WARNING. We're making two assumptions here. First, we
            //   assume that the GIT holds a reference to the object.
            //   Second, we assume that this script runs in the context
            //   that owns the object, so, the release won't destroy a
            //   proxy or anything. The problem is, the code we're
            //   replacing counted on the reference passed back to the
            //   script was also held here. There's obviously nobody
            //   "up there" that's releasing it, so, we have to do it
            //   here to simulate the old code.
            UseObjectContext(&pASPObjectContext);
			if (pASPObjectContext == NULL)
				{
				Assert (FALSE);
				return E_FAIL;		// should never happen...
				}

            *ppUnk = pASPObjectContext;
            pASPObjectContext->Release();
            fNameMatch = TRUE;
            }
            break;

    case itASPPageTLB:
        if (_wcsicmp(pwszName, WSZ_OBJ_ASPPAGETLB) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = m_pdispTypeLibWrapper;
            }
        break;

    case itASPGlobalTLB:
        if (_wcsicmp(pwszName, WSZ_OBJ_ASPGLOBALTLB) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = m_pAppln->PGlobTypeLibWrapper();
            }
        break;
        }

    if      (*ppUnk)        return S_OK;
    else if (fNameMatch)    return S_FALSE;
    else                    return TYPE_E_ELEMENTNOTFOUND;
    }

/*===================================================================
CHitObj::CreateComponent

Server.CreateObject calls this

Parameters:
    clsid       create of this CLSID
    ppDisp      return IDispatch*

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::CreateComponent
(
const CLSID &clsid,
IDispatch **ppDisp
)
    {
    Assert(m_pPageObjMgr);

    CComponentObject *pObj = NULL;
    
    HRESULT hr = m_pPageObjMgr->AddScopedUnnamedInstantiated
        (
        csPage, 
        clsid, 
        cmUnknown,
        NULL,
        &pObj
        );
    if (FAILED(hr))
        {
        *ppDisp = NULL;
        return hr;
        }

    Assert(pObj);

    hr = pObj->GetAddRefdIDispatch(ppDisp);

    if (SUCCEEDED(hr))
        {
        // don't keep the object around unless needed
        if (pObj->FEarlyReleaseAllowed())
            m_pPageObjMgr->RemoveComponent(pObj);
        }

    return hr;
    }

/*===================================================================
CHitObj::SetPropertyComponent

Sets property value to variant

Parameters:
    CompScope         scope        property scope
    LPWSTR             pwszName     property name
    VARIANT            pVariant     property value to set

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::SetPropertyComponent
(
CompScope scope,
LPWSTR     pwszName, 
VARIANT   *pVariant
)
    {
    if (!m_pPageObjMgr)
        return TYPE_E_ELEMENTNOTFOUND;

    CComponentObject *pObj = NULL;
    HRESULT hr = m_pPageObjMgr->AddScopedProperty(scope, pwszName, 
                                                  pVariant, &pObj);

    // If an object that restricts threading has been assigned as
    // the session property, and the session's activity runs this
    // request, then bind the session's activity to thread

    if (scope == csSession               && // session scope property
        m_ecsActivityScope == csSession  && // session scope activity
        SUCCEEDED(hr)                    && // set property succeed
        pObj && !pObj->FAgile())            // the object is thread-locked
        {
        m_pSession->PActivity()->BindToThread();
        }
        
    return hr;
    }

/*===================================================================
CHitObj::GetPropertyComponent

Finds property CComponentObject by scope and name

Parameters:
    CompScope         scope        wher to find
    LPWSTR             pwszName     name to find
    CComponentObject **ppObj        (out) object found

Returns:
    HRESULT     S_OK on success
                TYPE_E_ELEMENTNOTFOUND if the object wasnt found
                Other HRESULT
===================================================================*/
HRESULT CHitObj::GetPropertyComponent
(
CompScope         scope, 
LPWSTR             pwszName, 
CComponentObject **ppObj
)
    {
    *ppObj = NULL;
    
    if (!m_pPageObjMgr)
        return TYPE_E_ELEMENTNOTFOUND;

    return m_pPageObjMgr->GetScopedProperty(scope, pwszName, ppObj);
    }

/*===================================================================
CHitObj::SetActivity

Remember activity with CHitObj

Parameters
    CViperActivity *pActivity       Viper activity to remember
                                    (and later delete)

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::SetActivity
(
CViperActivity *pActivity
)
    {
    Assert(!m_pActivity);
    m_pActivity = pActivity;
    return S_OK;
    }

/*===================================================================
CHitObj::PCurrentActivity

Returns Viper Activity, the current HitObj is running under

Parameters

Returns:
    CViperActivity *
===================================================================*/
CViperActivity *CHitObj::PCurrentActivity()
    {
    CViperActivity *pActivity = NULL;

    switch (m_ecsActivityScope)
        {
        case csPage:
            pActivity = m_pActivity;
            break;
        case csSession:
            Assert(m_pSession);
            pActivity = m_pSession->PActivity();
            break;
        case csAppln:
            Assert(m_pAppln);
            pActivity = m_pAppln->PActivity();
            break;
        }

    return pActivity;
    }

/*===================================================================
CHitObj::PostViperAsyncCall

Asks Viper to calls us back from the right thread to execute
the request.

Used instead of queueing

Returns:
    HRESULT

Side effects:
===================================================================*/
HRESULT CHitObj::PostViperAsyncCall()
    {
#ifndef PERF_DISABLE
    BOOL fDecrOnFail = FALSE;
    if (FIsBrowserRequest())
        {
        DWORD dwRequestQueued = g_PerfData.Incr_REQCURRENT();
#if 0 && defined(SCRIPT_STATS)
        if (g_dwQueueDebugThreshold != 0
            &&  dwRequestQueued >= g_dwQueueDebugThreshold)
            DebugBreak();
#endif
        fDecrOnFail = TRUE;
        }
#endif

    UpdateTimestamp();  // before posting into queue

    CViperActivity *pApplnAct = m_pAppln ?
        m_pAppln->PActivity() : NULL;
        
    CViperActivity *pSessnAct = m_pSession ?
        m_pSession->PActivity() : NULL;

    HRESULT hr;

    if (pApplnAct)
        {
        m_ecsActivityScope = csAppln;
        hr = pApplnAct->PostAsyncRequest(this);
        }
    else if (pSessnAct)
        {
        m_ecsActivityScope = csSession;
        hr = pSessnAct->PostAsyncRequest(this);
        }
    else
        {
        m_ecsActivityScope = csPage;
        hr = CViperActivity::PostGlobalAsyncRequest(this);
        }
        
#ifndef PERF_DISABLE
    if (FAILED(hr) && fDecrOnFail)
        g_PerfData.Decr_REQCURRENT();
#endif    

    return hr;
    }

/*===================================================================
CHitObj::ViperAsyncCallback

Viper calls us back from the right thread to execute
the request.

Used instead of queueing

Parameters
    BOOL       *pfRePosted   [out] flag TRUE if request re-posted
                             under diff activity (don't delete it)
  
Returns:
    HRESULT

Side effects:
===================================================================*/
HRESULT CHitObj::ViperAsyncCallback
(
BOOL *pfRePosted
)
    {
    HRESULT hr = S_OK;
    BOOL fTemplateInCache;
    
    *pfRePosted = FALSE;

    Assert(!m_fExecuting); // no nested executions of the same request
    m_fExecuting = TRUE;
    
    Assert(FIsValidRequestType());

    DWORD dwtWaitTime = ElapsedTimeSinceTimestamp();
    UpdateTimestamp();  // received from the queue

#ifndef PERF_DISABLE
    if (FIsBrowserRequest())
        {
        g_PerfData.Decr_REQCURRENT();
        g_PerfData.Set_REQWAITTIME(dwtWaitTime);
        }
#endif

    ///////////////////
    // Reject browser requests in certain situations
    
    if (FIsBrowserRequest())
        {
        BOOL fRejected = FALSE;
        RejectBrowserRequestWhenNeeded(dwtWaitTime, &fRejected);
        if (fRejected)
            return S_OK;
        }

    ///////////////////
    // Pass through the thread gate
    
    EnterThreadGate(m_dwtTimestamp);

    ///////////////////
    // Reject browser requests in certain situations
    
    if (FIsBrowserRequest() && IsShutDownInProgress())
        {
        BOOL fRejected = FALSE;
        RejectBrowserRequestWhenNeeded(dwtWaitTime, &fRejected);
        if (fRejected)
            return S_OK;
        }

    ///////////////////
    // Remove the session from it's timeout bucket 
    // while executing the request

    if (m_pSession && m_pSession->FInTOBucket())
        m_pAppln->PSessionMgr()->RemoveSessionFromTOBucket(m_pSession);

    ///////////////////
    // If there's an application level activity we need to make
    // sure this activity is bound to a thread. Could not bind it
    // before because it has to be Viper thread to bind to.

    CViperActivity *pApplnActivity = m_pAppln->PActivity();

    if (pApplnActivity && !pApplnActivity->FThreadBound())
        pApplnActivity->BindToThread();

    ///////////////////
    // Take care of first application request with GLOBAL.ASA
    // Lock application if needed

    BOOL fApplnLocked = FALSE;
    BOOL fFirstAppRequest = FALSE;

    if (FIsBrowserRequest() && m_pAppln->FHasGlobalAsa() &&
                              !m_pAppln->FFirstRequestRun())
        {
        m_pAppln->InternalLock();
        fApplnLocked = TRUE;

        if (!m_pAppln->FFirstRequestRun())
            {
            m_fStartApplication = TRUE;
            m_fRunGlobalAsa = TRUE;
            fFirstAppRequest = TRUE;
            }
        else
            {
            m_pAppln->InternalUnLock();
            fApplnLocked = FALSE;
            }
        }

    ///////////////////
    // Repost under a different activity if needed
    // (do it only after the first app request finished)

    if (!fApplnLocked) // if not processing first app request
        {
        CViperActivity *pSessnAct, *pApplnAct;
        CViperActivity *pRepostToActivity = NULL;
            
        switch (m_ecsActivityScope)
            {
            case csPage:
                // repost to session activity if any
                pSessnAct = m_pSession ? m_pSession->PActivity() : NULL;
                if (pSessnAct)
                    pRepostToActivity = pSessnAct;
                    
                // no break;
            case csSession:
                // repost to application activity if any
                pApplnAct = m_pAppln ? m_pAppln->PActivity() : NULL;
                if (pApplnAct)
                    pRepostToActivity = pApplnAct;
                    
                // no break;
            case csAppln:
                // never repost application activity request
                break;
            }

        if (pRepostToActivity)
            {
            LeaveThreadGate();   // notify the thead gate
            m_fExecuting = FALSE;  // before reposting to avoid nesting
            hr = pRepostToActivity->PostAsyncRequest(this);
            *pfRePosted = SUCCEEDED(hr);
            return hr;
            }
        }

    ///////////////////
    // Cleanup any scripting engines that need to be shut
    // down on this thread, if we are on a thread enabled
    // for debugging
 
    if (m_pAppln->FDebuggable() && FIsBrowserRequest())
        {
        Assert(m_ecsActivityScope == csAppln);
        g_ApplnMgr.CleanupEngines();
        if (!g_dwDebugThreadId)
            g_dwDebugThreadId = GetCurrentThreadId();
        }

    ///////////////////
    // Prepare intrinsics

    CIntrinsicObjects intrinsics;

    m_pServer = NULL;
    m_pResponse = NULL;
    m_pRequest = NULL;
    m_fHideRequestAndResponseIntrinsics = FALSE;
    m_fHideSessionIntrinsic = FALSE;
    m_punkScriptingNamespace = NULL;
    m_dwObjectContextCookie = NULL_GIP_COOKIE;

    hr = intrinsics.Prepare(m_pSession);

    if (FAILED(hr))  // couldn't setup intrinsics
        {
        if (fApplnLocked)
            m_pAppln->InternalUnLock();
            
#ifndef PERF_DISABLE
        g_PerfData.Incr_REQFAILED();
        g_PerfData.Incr_REQERRORPERSEC();
#endif            
        LeaveThreadGate();   // notify the thead gate
        m_fExecuting = FALSE;
        
        if (FIsBrowserRequest())
            ReportServerError(IDE_SERVER_TOO_BUSY);
            
        return hr;
        }

    if (FIsBrowserRequest())
        {
        m_pResponse = intrinsics.PResponse();
        m_pRequest  = intrinsics.PRequest();
        }
        
    m_pServer = intrinsics.PServer();
    
    Assert(!FIsBrowserRequest() || m_pResponse);

    ///////////////////
    // Point session to this hit object

    if (m_pSession)
        m_pSession->SetHitObj(this);
        
    ///////////////////
    // Impersonate
    
    HANDLE hThread = GetCurrentThread();

    if (FIsBrowserRequest())
        {
        if (FIsWinNT())
            {
            if (!SetThreadToken(&hThread, m_hImpersonate))
                {
#ifdef DBG
                // for debug purposes, it is interesting to know what the error was
                DWORD err = GetLastError();
#endif

                ReportServerError(IDE_IMPERSONATE_USER);
                m_eExecStatus = eExecFailed;
                hr = E_FAIL;
                }
            }
        }

    ///////////////////
    // Make Scripting Context

    if (SUCCEEDED(hr))
        {
        Assert(!m_pScriptingContext);
        
        m_pScriptingContext = new CScriptingContext
            (
            m_pAppln,
            m_pSession,
            m_pRequest,
            m_pResponse,
            m_pServer
            );
            
        if (!m_pScriptingContext)
            hr = E_OUTOFMEMORY;
        }

    ///////////////////
    // Attach to Viper context flow
    
    if (SUCCEEDED(hr))
        {
        hr = ViperAttachIntrinsicsToContext
            (
            m_pAppln,
            m_pSession,
            m_pRequest,
            m_pResponse,
            m_pServer
            );
        }

    ///////////////////
    // Execute

    BOOL fSkipExecute = FALSE; // (need to skip if session-less)

    if (SUCCEEDED(hr))
        {
        CTemplate *pTemplate = NULL;

        if (FIsBrowserRequest())
            {
#ifndef PERF_DISABLE
            g_PerfData.Incr_REQBROWSEREXEC();
#endif
            // Init Response and Server for compiler errors
            m_pResponse->ReInit(m_pIReq, NULL, m_pRequest, NULL, NULL, this);
            m_pRequest->ReInit(m_pIReq, this);
            m_pServer->ReInit(m_pIReq, this);
            
            // Load the script - cache will AddRef
            hr = LoadTemplate(m_pIReq->QueryPszPathTranslated(), this, 
                              &pTemplate, intrinsics,
                              FALSE /* !GlobalAsa */, &fTemplateInCache);

            // In case of ACL on the file (or directory) make sure
            // we don't assume that AppOnStart succeeded on the
            // first try (without the correct impersonation). Setting
            // m_fApplnOnStartFailed will force another try, with the
            // correct impersonation.
            if (fFirstAppRequest && FAILED(hr))
                m_fApplnOnStartFailed = TRUE;

            // Take care of is session-less templates
            if (SUCCEEDED(hr) && !pTemplate->FSession())
                {
                
                // UNDONE - Remove the reposting logic. Bug 301311.
                //
                // The problem is that we will leak the wam request and 
                // cause all sorts of trouble with keep alives. It seems 
                // like a marginal cost to just allow the first request to
                // run on the session activity. We could also remove the
                // StartISAThreadBracket restriction on nesting, but that
                // seems like it might open up the door to making some
                // real errors.

                /*
                // The problem only occurs the first time the
                // template is loaded. After that there's a
                // look-ahead in BrowserRequestInit()
                
                // if the template wasn't cached before we could
                // be running on session activity
                if (m_ecsActivityScope == csSession)
                    {
                    // Repost with it's own activity
                    hr = NewBrowserRequest(m_pIReq);
                    fSkipExecute = TRUE;

                    // Mark this request as DONE_WITH_SESSION so that
                    // it will not be forced later. We don't need it
                    // because we posted another HitObj with the
                    // same WAM_EXEC_INFO
                    m_fDoneWithSession = TRUE;
                    }
                else 
                */
                
                if (m_pSession)
                    {
                    // Activity is alright (most likely 
                    // application level) but still there's
                    // a session attached -> hide it
                    m_fHideSessionIntrinsic = TRUE;
                    }
                }
                
            // Take care of the 449 processing (most likely already done on I/O thread)
            if (SUCCEEDED(hr) && !m_fDoneWithSession)
                {
                pTemplate->Do449Processing(this);
                if (m_fDoneWithSession)
                    fSkipExecute = TRUE;  // 449 sent the response
                }
            }

        if (SUCCEEDED(hr) && !fSkipExecute)
            {
            // Execute script
            MFS_START(memrfs)
            hr = Execute(pTemplate, this, intrinsics);
            MFS_END_HR(memrfs)
            
            // OnEndPage
            if (m_pPageObjMgr)
                m_pPageObjMgr->OnEndPageAllObjects();
            }

        // Release the template
        if (pTemplate)
            pTemplate->Release();

        if (FIsBrowserRequest())
            {
            if (!fSkipExecute)
                {
                // Flush response after completing execution
                m_pResponse->FinalFlush(hr);
                }

#ifndef PERF_DISABLE
            g_PerfData.Decr_REQBROWSEREXEC();
#endif
            }
        else if (FIsSessionCleanupRequest())
            {
            // Remove session
            if (m_pSession)
                {
                m_pSession->UnInit();
                m_pSession->Release();
                m_pSession = NULL;
                }
            }
        else if (FIsApplnCleanupRequest())
            {
            // Remove application
            if ( m_pAppln )
                {
                m_pAppln->UnInit();
                m_pAppln->Release();
                m_pAppln = NULL;
                }
            }
        }

    ///////////////////
    // Release Scripting Context
    
    if (m_pScriptingContext)
        {
        m_pScriptingContext->Release();
        m_pScriptingContext = NULL;
        }
        
    ///////////////////
    // Do The Perf Counters

#ifndef PERF_DISABLE
    DWORD dwtExecTime = ElapsedTimeSinceTimestamp();

    if (!fSkipExecute && FIsBrowserRequest())
        {
        g_PerfData.Incr_REQPERSEC();
        g_PerfData.Set_REQEXECTIME(dwtExecTime);
    
        switch (m_eExecStatus)
            {
        case eExecSucceeded:
            if (m_pResponse->FWriteClientError())
                {
                g_PerfData.Incr_REQCOMFAILED();
                g_PerfData.Incr_REQERRORPERSEC();
                }
            else
                {
                g_PerfData.Incr_REQSUCCEEDED();
                }
            break;
            
        case eExecFailed:
            if (hr == E_USER_LACKS_PERMISSIONS)
                {
                g_PerfData.Incr_REQNOTAUTH();
                }
            else if (FIsPreprocessorError(hr))
                {
                g_PerfData.Incr_REQERRPREPROC();
                }
            else if (m_fCompilationFailed)
                {
                g_PerfData.Incr_REQERRCOMPILE();
                }
            else
                {
                g_PerfData.Incr_REQERRRUNTIME();
                }
        
            g_PerfData.Incr_REQFAILED();
            g_PerfData.Incr_REQERRORPERSEC();
            break;
            
        case eExecTimedOut:
            g_PerfData.Incr_REQTIMEOUT();
            break;
            }
        }
#endif    

    ///////////////////
    // Cleanup after first application request
    
    if (fFirstAppRequest && !m_fApplnOnStartFailed && !fSkipExecute)
        m_pAppln->SetFirstRequestRan();

    if (fApplnLocked)
        m_pAppln->InternalUnLock();
    
    ///////////////////
    // make sure script didn't leave application locked

    if (!FIsApplnCleanupRequest())
        m_pAppln->UnLockAfterRequest();

    ///////////////////
    // In order not to refer to intrinsics later
    // remove page component collection
    
    StopComponentProcessing();

	// Unset the impersonation
	if (FIsWinNT())
		SetThreadToken(&hThread, NULL);
                
    ///////////////////
    // Point session to NULL HitObj

    if (m_pSession)
        m_pSession->SetHitObj(NULL);

    LeaveThreadGate();   // notify the thead gate
    m_fExecuting = FALSE;
    
    return hr;
    }

/*===================================================================
CHitObj::ExecuteChildRequest

Executes child browser request

Parameters:
    fTransfer       -- flag -- End execution after this
    szTemplate      -- filename of the template to execute
    szVirtTemplate  -- virt path to template

Returns:
    S_OK
===================================================================*/
HRESULT CHitObj::ExecuteChildRequest
(
BOOL fTransfer, 
TCHAR *szTemplate,
TCHAR *szVirtTemplate
)
    {
    HRESULT hr = S_OK;

    // Prepare the new intrinsics structure (with the new scripting namespace)
    CIntrinsicObjects intrinsics;
    intrinsics.PrepareChild(m_pResponse, m_pRequest, m_pServer);
    
    TCHAR *saved_m_szCurrTemplateVirtPath = m_szCurrTemplateVirtPath;
    TCHAR *saved_m_szCurrTemplatePhysPath = m_szCurrTemplatePhysPath;
    // these two fields used for compilation and error reporting
    m_szCurrTemplateVirtPath = szVirtTemplate;
    m_szCurrTemplatePhysPath = szTemplate;
    
    // Load the template from cache
    CTemplate *pTemplate = NULL;
    BOOL fTemplateInCache;
    hr = g_TemplateCache.Load(FALSE, szTemplate, DWInstanceID(), this, &pTemplate, &fTemplateInCache);

    if (FAILED(hr))
        {
        if (pTemplate)
            {
            pTemplate->Release();
            pTemplate = NULL;
            }

        m_szCurrTemplateVirtPath = saved_m_szCurrTemplateVirtPath;
        m_szCurrTemplatePhysPath = saved_m_szCurrTemplatePhysPath;

        // to tell the server object to display the correct error message
        return E_COULDNT_OPEN_SOURCE_FILE;
        }

    // Save HitObj's execution state info
    CComponentCollection  *saved_m_pPageCompCol           = m_pPageCompCol;
    CPageComponentManager *saved_m_pPageObjMgr            = m_pPageObjMgr;
    IUnknown              *saved_m_punkScriptingNamespace = m_punkScriptingNamespace;
    DWORD                 saved_m_dwObjectContextCookie   = m_dwObjectContextCookie;
    ActiveEngineInfo      *saved_m_pEngineInfo            = m_pEngineInfo;
    IDispatch             *saved_m_pdispTypeLibWrapper    = m_pdispTypeLibWrapper;

    CTemplate *saved_pTemplate = m_pResponse->SwapTemplate(pTemplate);
    void *saved_pvEngineInfo   = m_pResponse->SwapScriptEngineInfo(NULL);

    // Re-Init the saved state
    m_pPageCompCol = NULL;
    m_pPageObjMgr = NULL;
    m_punkScriptingNamespace = NULL;
    m_dwObjectContextCookie = NULL_GIP_COOKIE;
    m_pEngineInfo = NULL;
    m_pdispTypeLibWrapper = NULL;

    // Create child request components framework
    hr = InitComponentProcessing();

    // Execute
    if (SUCCEEDED(hr))
        {
		// Set status code to 500 in error cases.
		if (FHasASPError())
			m_pResponse->put_Status(L"500 Internal Server Error");

        // Execute [child] script
        hr = ::Execute(pTemplate, this, intrinsics, TRUE);
        
        // OnEndPage
        if (m_pPageObjMgr)
            m_pPageObjMgr->OnEndPageAllObjects();
        }

    // Clean-out new components framework
    StopComponentProcessing();

    // Restore HitObj's execution state info
    m_pPageCompCol           = saved_m_pPageCompCol;
    m_pPageObjMgr            = saved_m_pPageObjMgr;
    m_punkScriptingNamespace = saved_m_punkScriptingNamespace;
    m_dwObjectContextCookie  = saved_m_dwObjectContextCookie;
    m_pEngineInfo            = saved_m_pEngineInfo;
    SetTypeLibWrapper(saved_m_pdispTypeLibWrapper);
    m_pResponse->SwapTemplate(saved_pTemplate);
    m_pResponse->SwapScriptEngineInfo(saved_pvEngineInfo);
    m_szCurrTemplateVirtPath = saved_m_szCurrTemplateVirtPath;
    m_szCurrTemplatePhysPath = saved_m_szCurrTemplatePhysPath;

    // Cleanup
    if (pTemplate)
        pTemplate->Release();

    if (m_pResponse->FResponseAborted() || fTransfer || FHasASPError())
        {
        // propagate Response.End up the script engine chain
        m_pResponse->End();
        }

    // Done
    return hr;
    }

/*===================================================================
CHitObj::GetASPError

Get ASP Error object. Used for Server.GetLastError()

Parameters
    ppASPError  [out] addref'd error object (new or old)
    
Returns
    HRESULT
===================================================================*/
HRESULT CHitObj::GetASPError
(
IASPError **ppASPError
)
    {
    Assert(ppASPError);
    
    if (m_pASPError == NULL)
        {
        // return bogus one
        *ppASPError = new CASPError;
        return (*ppASPError != NULL) ? S_OK : E_OUTOFMEMORY;
        }
        
    m_pASPError->AddRef();      // return addref'd
    *ppASPError = m_pASPError;
    return S_OK;
    }

/*===================================================================
CHitObj::RejectBrowserRequestWhenNeeded

Request reject-before-execution-started logic

Parameters:
    dwtQueueWaitTime    time request waited in the queue, ms
    pfRejected          OUT flag -- TRUE if rejected

Returns:
    S_OK
===================================================================*/
HRESULT CHitObj::RejectBrowserRequestWhenNeeded
(
DWORD dwtQueueWaitTime,
BOOL *pfRejected
)
    {
    Assert(FIsBrowserRequest());
    
    UINT wError = 0;
    
    // If shutting down
    if (IsShutDownInProgress())
        {
        wError = IDE_SERVER_SHUTTING_DOWN;
        }
        
    // If waited long enough need to check if still connected
    if (wError == 0)
        {
        DWORD dwConnTestSec = m_pAppln->QueryAppConfig()->dwQueueConnectionTestTime();
        
        if (dwConnTestSec != 0xffffffff && dwConnTestSec != 0)
            {
            if (dwtQueueWaitTime > (dwConnTestSec * 1000))
                {
                BOOL fConnected = TRUE;
                if (m_pIReq)
                    m_pIReq->TestConnection(&fConnected);

                // if client disconnected -- respond with 'Server Error'
                if (!fConnected)
                    {
                    wError = IDE_500_SERVER_ERROR;
#ifndef PERF_DISABLE
                    g_PerfData.Incr_REQCOMFAILED();
#endif                    
                    }
                }
            }
        }
    
    // If waited too long -- reject
    if (wError == 0)
        {
        DWORD dwTimeOutSec = m_pAppln->QueryAppConfig()->dwQueueTimeout();
        
        if (dwTimeOutSec != 0xffffffff && dwTimeOutSec != 0)
            {
            if (dwtQueueWaitTime > (dwTimeOutSec * 1000))
                {
                wError = IDE_SERVER_TOO_BUSY;
#ifndef PERF_DISABLE
                g_PerfData.Incr_REQREJECTED();
#endif
                }
            }
        }

    if (wError)
        {
        m_fExecuting = FALSE; // before 'report error' to disable transfer
        ReportServerError(wError);
        *pfRejected = TRUE;
        }
    else
        {
        *pfRejected = FALSE;
        }

    return S_OK;
    }

/*===================================================================
CHitObj::ReportServerError

Report server error without using the response object

Parameters:
    ErrorID     error message id

Returns:

Side effects:
    None.
===================================================================*/
HRESULT CHitObj::ReportServerError
(
UINT ErrorId
)
    {
    // do nothing on non-browser requests or if no WAM_EXEC_INFO
    if (!FIsBrowserRequest() || m_pIReq == NULL)
        return S_OK;

    DWORD dwRequestStatus = HSE_STATUS_ERROR;

    if (ErrorId)
        {
        Handle500Error(ErrorId, m_pIReq);
        }
            
    m_pIReq->ServerSupportFunction
        (
        HSE_REQ_DONE_WITH_SESSION,
        &dwRequestStatus,
        0,
        NULL
        );

    SetDoneWithSession();
    return S_OK;
    }

#ifdef DBG
/*===================================================================
CHitObj::AssertValid

Test to make sure that the CHitObj object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
    None.
===================================================================*/
VOID CHitObj::AssertValid() const
    {
    Assert(m_fInited);
    Assert(FIsValidRequestType());
    if (FIsBrowserRequest())
        {
        Assert(m_pIReq != NULL);
        Assert(m_pPageCompCol != NULL );
        Assert(m_pPageObjMgr != NULL);
        }
    }
#endif // DBG

/*===================================================================
CHitObj::AddObjectContext
===================================================================*/
void CHitObj::AddObjectContext(IASPObjectContext *pASPObjContext)
    {
    HRESULT hr = S_OK;  
    Assert(m_dwObjectContextCookie == NULL_GIP_COOKIE);
    Assert(pASPObjContext);

    if (g_pGIT == 0) {
        hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable, 0, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void**) &g_pGIT);
        Assert(hr == S_OK);
    }
    hr = g_pGIT->RegisterInterfaceInGlobal(pASPObjContext, IID_IASPObjectContext, &m_dwObjectContextCookie);
	if (hr != S_OK)
		DBGPRINTF((DBG_CONTEXT, "RegisterInterfaceInGlobal failed, hr = 0x%08X\n", hr));

    Assert(hr == S_OK);
    Assert(m_dwObjectContextCookie != NULL_GIP_COOKIE);
    }
    
/*===================================================================
CHitObj::RemoveObjectContext
===================================================================*/
void CHitObj::RemoveObjectContext()
    {
    HRESULT hr = S_OK;  
    if (m_dwObjectContextCookie != NULL_GIP_COOKIE)
        {
        hr = g_pGIT->RevokeInterfaceFromGlobal(m_dwObjectContextCookie);
		if (hr != S_OK)
			DBGPRINTF((DBG_CONTEXT, "RevokeInterfaceFromGlobal failed, hr = 0x%08X\n", hr));
        m_dwObjectContextCookie = NULL_GIP_COOKIE;
        }
    }

/*===================================================================
CHitObj::UseObjectContext
===================================================================*/
void CHitObj::UseObjectContext(IASPObjectContext** ppASPObjectContext)
    {
    HRESULT hr = S_OK;  
    if (m_dwObjectContextCookie != NULL_GIP_COOKIE)
        {
        hr = g_pGIT->GetInterfaceFromGlobal(m_dwObjectContextCookie, IID_IASPObjectContext, (void**) ppASPObjectContext);
        if (hr != S_OK) 
            {
			DBGPRINTF((DBG_CONTEXT, "GetInterfaceFromGlobal failed, hr = 0x%08X\n", hr));
            *ppASPObjectContext = NULL;
            }
        }
    else
        {
        DBG_ASSERT( g_pIASPObjectContextZombie );

        hr = g_pIASPObjectContextZombie->QueryInterface(
                    IID_IASPObjectContext,
                    reinterpret_cast<void **>(ppASPObjectContext)
                    );
        
        DBG_ASSERT(SUCCEEDED(hr));
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\idgener.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: ID Generator

File: Idgener.cpp

Owner: DmitryR

This is the ID Generator source file.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "Idgener.h"

#include "memchk.h"

/*===================================================================
CIdGenerator::CIdGenerator

NOTE: Constructor

Parameters:

Returns:
===================================================================*/
CIdGenerator::CIdGenerator()
    : m_fInited(FALSE),
      m_dwStartId(0), 
      m_dwLastId(0)
    {
    }

/*===================================================================
CIdGenerator::~CIdGenerator()

NOTE: Destructor

Parameters:

Returns:
===================================================================*/
CIdGenerator::~CIdGenerator()
    {
	if ( m_fInited )
		DeleteCriticalSection( &m_csLock );
    }
		
/*===================================================================
HRESULT CIdGenerator::Init()

NOTE: Seed new starting Id

Parameters:

Returns: HRESULT (could fail to create critical section)
===================================================================*/
HRESULT CIdGenerator::Init()
    {
    Assert(!m_fInited);
    
    /*===
    
    Seed the starting id
    The starting Id should be:
        1) random
        2) not to close to recently generated starting ids
    To accomplish the above, starting Id is in the 
    following (binary) format:
    
        00TT.TTTT TTTT.TTTT TTT1.RRRR RRRR.RRRR
        
        RRR is random number to introduce some
            randomness
            
        1   is needed to make sure the id is far
            enough from 0
            
        TTT is current time() in 4 second increments.
            This means that 4 second in server restart
            delay translates into 8,192 difference in
            the starting Id (122880 sessions / minute).
            17 bits of 4 sec intervals make a roll over
            time of about 145 hours, hopefully longer
            than a client's connection lifetime (not
            that it REALLY matters).
            
        00  in the highest bits is to make sure it
            doesn't reach 0xffffffff too soon
            
    ===*/
    
    DWORD dwRRR = rand() & 0x00000FFF;
    DWORD dwTTT = (((DWORD)time(NULL)) >> 2) & 0x0001FFFF;
    
    m_dwStartId = (dwTTT << 13) | (1 << 12) | dwRRR;
    m_dwLastId  = m_dwStartId;


    HRESULT hr = S_OK;
	ErrInitCriticalSection( &m_csLock, hr );
	if ( FAILED( hr ) )
		return hr;
			
	m_fInited = TRUE;
	return S_OK;
}

/*===================================================================
HRESULT CIdGenerator::Init(CIdGenerator StartId)   

NOTE: Seed new starting Id with Id passed in

Parameters:

Returns: HRESULT (could fail to create critical section)
===================================================================*/
HRESULT CIdGenerator::Init(CIdGenerator & StartId)
    {
    Assert(!m_fInited);
    
    m_dwStartId = StartId.m_dwStartId;
    m_dwLastId  = m_dwStartId;

    HRESULT hr = NOERROR;
    ErrInitCriticalSection( &m_csLock, hr );
    if ( FAILED( hr ) )
        return hr;
			
    m_fInited = TRUE;
    return NOERROR;
}

/*===================================================================
DWORD CIdGenerator::NewId()

NOTE: Generates new ID

Parameters:

Returns: generated ID
===================================================================*/
DWORD CIdGenerator::NewId()
    {
    Assert(m_fInited);
    
    DWORD dwId;

    EnterCriticalSection(&m_csLock);
    dwId = ++m_dwLastId;
    LeaveCriticalSection(&m_csLock);
        
    if (dwId == INVALID_ID)
        {
        // doesn't happen very often do critical section again
        // to make the above critical section shorter
        
        EnterCriticalSection(&m_csLock);
        
        // check again in case other thread changed it
        if (m_dwLastId == INVALID_ID)
            m_dwLastId = m_dwStartId;  // roll over
        m_dwLastId++;
        
        LeaveCriticalSection(&m_csLock);
        
        dwId = m_dwLastId;
        }

    return dwId;
    }

/*===================================================================
BOOL CIdGenerator::IsValidId(DWORD dwId)

NOTE: Checks if the given Id is valid (with start-last range)

Parameters:
    DWORD dwId      Id value to check

Returns: generated ID
===================================================================*/
BOOL CIdGenerator::IsValidId
(
DWORD dwId
)
    {
    Assert(m_fInited);
    return (dwId > m_dwStartId && dwId <= m_dwLastId);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\idgener.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: ID Generator

File: IdGener.h

Owner: DmitryR

This file contains the declarations for the ID Generator class
===================================================================*/
#ifndef IDGENER_H
#define IDGENER_H

#define INVALID_ID      0xFFFFFFFF

class CIdGenerator
    {
private:
	BOOL              m_fInited;    // Initialized?
	CRITICAL_SECTION  m_csLock;		// Synchronize access
    DWORD             m_dwStartId;  // Starting (seed) Id
	DWORD			  m_dwLastId;   // Last Generated Id
		
public:	
	CIdGenerator();
	~CIdGenerator();
	
public:
	HRESULT Init();
	HRESULT Init(CIdGenerator & StartId);      
	DWORD   NewId();
	BOOL    IsValidId(DWORD dwId);
    };

#endif // IDGENER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\exec.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Executor

Owner: DGottner

File: executor.cpp

This file contains the executor, whose job is to co-ordinate the
execution of Denali scripts.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "exec.h"
#include "response.h"
#include "request.h"
#include "perfdata.h"
#include "memchk.h"


// Local declarations
HRESULT ExecuteGlobal(CHitObj *pHitObj,
                        const CIntrinsicObjects &intrinsics,
                        ActiveEngineInfo *pEngineInfo);
HRESULT ExecuteRequest(CTemplate *pTemplate, CHitObj *pHitObj,
                        const CIntrinsicObjects &intrinsics,
                        ActiveEngineInfo *pEngineInfo);
HRESULT ReInitIntrinsics(CHitObj *pHitObj, const CIntrinsicObjects &intrinsics,
                            ActiveEngineInfo *pEngineInfo, BOOL fPostGlobal);
HRESULT AllocAndLoadEngines(CHitObj *pHitObj, CTemplate *pTemplate, ActiveEngineInfo *pEngineInfo,
                            CScriptingNamespace *pScriptingNamespace, BOOL fGlobalAsa);
VOID DeAllocAndFreeEngines(ActiveEngineInfo *pEngineInfo, CAppln *pAppln, IASPObjectContextCustom *);
CScriptEngine *GetScriptEngine(int iScriptEngine, void *pvData);
HRESULT CallScriptFunctionOfEngine(ActiveEngineInfo &engineInfo, short iScriptBlock, wchar_t *strFunction,
                                    IASPObjectContextCustom *pTxnScriptContextCustom, BOOLB *pfAborted);
HRESULT CallScriptFunction(ActiveEngineInfo &engineInfo, wchar_t *strFunction,
                                    IASPObjectContextCustom *pTxnScriptContextCustom, BOOLB *pfAborted);
HRESULT TestScriptFunction(ActiveEngineInfo &engineInfo, wchar_t *strFunction);

/*===================================================================
Execute

Execute a request:
    First determine if Global needs to be called
    then invoke actual requested template

Parameters:
    pTemplate       - pointer to loaded template (could be NULL)
    pHitObj         - pointer to the hit object
    intrinsics      - pointers to the intrinsic IUnknown pointers.
    fChild          - flag: TRUE when child request (Server.Execute())

Returns:
    S_OK on success
===================================================================*/
HRESULT Execute
(
CTemplate *pTemplate,
CHitObj *pHitObj,
const CIntrinsicObjects &intrinsics,
BOOL fChild
)
    {
    HRESULT hr = S_OK;
    ActiveEngineInfo engineInfo;
    BOOL fRanGlobal = FALSE;
    
    // The hit obj must be valid
    Assert(pHitObj != NULL);
    pHitObj->AssertValid();

	// Check for valid Session codepage.  We do it here, rather than in CSession::Init in
	// order to avoid generic "New Session Failed" message.
	if (pHitObj->GetCodePage() != CP_ACP && !IsValidCodePage(pHitObj->GetCodePage()))
		{
		HandleErrorMissingFilename(IDE_BAD_CODEPAGE_IN_MB, pHitObj);
		return E_FAIL;
		}

    // Give the engine list to the hitobject
    pHitObj->SetActiveEngineInfo(&engineInfo);
        
    /*
     * If there is a Global.ASA, call it
     */
    if (pHitObj->GlobalAspPath() && !fChild)
        {
        // Clear out the engine info
        engineInfo.cEngines = 0;
        engineInfo.cActiveEngines = 0;
        engineInfo.rgActiveEngines = NULL;

        // Init the intrinsics
        hr = ReInitIntrinsics(pHitObj, intrinsics, &engineInfo, /* fPostGlobal*/ FALSE);
        if (FAILED(hr))
            return(hr);

        hr = ExecuteGlobal(pHitObj, intrinsics, &engineInfo);

        if (intrinsics.PResponse() && intrinsics.PResponse()->FResponseAborted())
            {
            hr = S_OK;
            goto LExit;
            }

        if (E_SOURCE_FILE_IS_EMPTY == hr)
            // bug 977: silently ignore empty global.asa file
            hr = S_OK;
        else if (FAILED(hr))
            {
            // Bug 481: If global.asa fails due to Response.End (or Response.Redirect),
            //      then halt execution of the calling script.  If the
            //      script fails due to Response.End, then return OK status
            //
            if (hr == DISP_E_EXCEPTION)
                hr = S_OK;

            // In any case, blow out of here
            goto LExit;
            }

        // Running Global.asa added the scripting namespace to the hitobj.  This will cause us problems
        // later, remove it.
        pHitObj->RemoveScriptingNamespace();

        fRanGlobal = TRUE;
        }

    /*
     * If this is not a browser request, then we are done
     * For non-browser requests, we do want to run Global.asa (if any), but there is no real template to run.
     */
    if (!pHitObj->FIsBrowserRequest())
        {
        hr = S_OK;
        goto LExit;
        }

    // Clear out (or re-clear out) the engine info
    engineInfo.cEngines = 0;
    engineInfo.cActiveEngines = 0;
    engineInfo.rgActiveEngines = NULL;

    // Init or Re-Init the intrinsics
    ReInitIntrinsics(pHitObj, intrinsics, &engineInfo, fRanGlobal || fChild);

    if (!fChild)
        {
        // For non-child requests hand new Template to Response object
        // (for child requests already done)
        intrinsics.PResponse()->ReInitTemplate(pTemplate, pHitObj->PSzNewSessionCookie());
        }
    else
        {
        // For child requests hand new engine info to the response object
        intrinsics.PResponse()->SwapScriptEngineInfo(&engineInfo);
        }

    // Run the main template
    if (pTemplate->FScriptless() && !pHitObj->PAppln()->FDebuggable())
        {
        // special case scriptless pages
        hr = intrinsics.PResponse()->WriteBlock(0);
        }
    else
        {
        hr = ExecuteRequest(pTemplate, pHitObj, intrinsics, &engineInfo);
        }
        
LExit:
	intrinsics.PResponse()->SwapScriptEngineInfo(NULL);
	pHitObj->SetActiveEngineInfo(NULL);
    return hr;
    }

/*===================================================================
ExecRequest

Execute a request for an actual template (not Global.asa)

execute a request by
    - getting the script name
    - loading the script into memory
    - interpreting the opcodes

Parameters:
    pTemplate       - pointer to loaded template
    pHitObj         - pointer to the hit object
    intrinsics      - pointers to the intrinsic IUnknown pointers.
    pEngineInfo     - pointers to engine info

Returns:
    S_OK on success
===================================================================*/
HRESULT ExecuteRequest
(
CTemplate *pTemplate,
CHitObj *pHitObj,
const CIntrinsicObjects &intrinsics,
ActiveEngineInfo *pEngineInfo
)
    {
    HRESULT hr = S_OK;
    IASPObjectContextCustom *pTxnScriptContextCustom = NULL;
    IASPObjectContext *pTxnScriptContext = NULL;
    BOOLB fAborted = FALSE;
    BOOLB fDebuggerNotifiedOnStart = FALSE;

#ifndef PERF_DISABLE
    BOOLB fPerfTransPending = FALSE;
#endif      

    // The template must be valid
    Assert(pTemplate);

    // The hit obj must be valid
    Assert(pHitObj != NULL);
    pHitObj->AssertValid();

    // This function should never be called on a non-browser request
    Assert(pHitObj->FIsBrowserRequest());

    // Remember template's type library wrapper with the HitObj
    if (pTemplate->PTypeLibWrapper())
        pHitObj->SetTypeLibWrapper(pTemplate->PTypeLibWrapper());

    /*
     * Bug 86404: If this script is transacted, then create a new "real" ASP ObjectContext object
     * and add it to the objects list.  If the page is not transacted, then
     * CHitObj::UseObjectContext will use pre-instantiated "zombie" ObjectContext object.
     */
    if (pTemplate->FTransacted())
        {
        IObjectContext *pContext;

        if (FAILED(hr = GetObjectContext(&pContext)))
            goto LExit;

        /*
         * Incredibly obscure bug in OLE32.  If OLE needs to spin up an MTA thread in order to
         * create the class factory for the ASPObjectContext object, then the thread needs to be
         * created by the unimpersonated user.
         * NOTE: This can be removed after the new OLE32 ships in NT4 SP4
         */
        RevertToSelf();
        
        hr = pContext->CreateInstance
            (
            CLSIDObjectContextFromTransType(pTemplate->GetTransType()),
            IID_IASPObjectContextCustom,
            reinterpret_cast<void **>(&pTxnScriptContextCustom)
            );

        // Restore Impersonation
        HANDLE hThread = GetCurrentThread();
        SetThreadToken(&hThread, pHitObj->HImpersonate());

        pContext->Release();
        if (FAILED(hr))
            goto LExit;

        hr = pTxnScriptContextCustom->QueryInterface(IID_IASPObjectContext,
                                            reinterpret_cast<void **>(&pTxnScriptContext));
        if (FAILED(hr))
            goto LExit;

        pHitObj->AddObjectContext(pTxnScriptContext);
        pTxnScriptContext->Release();

#ifndef PERF_DISABLE
        g_PerfData.Incr_TRANSTOTAL();
        g_PerfData.Incr_TRANSPENDING();
        fPerfTransPending = TRUE;
#endif      
        }

	// load script engines
	hr = AllocAndLoadEngines(pHitObj, pTemplate, pEngineInfo, intrinsics.PScriptingNamespace(), /* fGlobalAsa */FALSE);
	if (FAILED(hr))
	    {
	    pHitObj->SetCompilationFailed();
		goto LExit;
		}

    // If debugging, notify debugger ONPAGESTART
    // BUG 138773: Notify debugger AFTER scripts load
    //    (script must be in running state when AttachTo() is called because debugger may want a code context)
    //
    if (pHitObj->PAppln()->FDebuggable())
        {
		pTemplate->AttachTo(pHitObj->PAppln());
        if (SUCCEEDED(pTemplate->NotifyDebuggerOnPageEvent(TRUE)))
            fDebuggerNotifiedOnStart = TRUE;
        }
		
	// bug 1009: if no script engines, do not attempt to do anything
	if(0 == pTemplate->CountScriptEngines())
		goto LExit;

    // run the script by calling primary script engine's global code
    hr = CallScriptFunctionOfEngine(
                                        *pEngineInfo,   // engine-info
                                        0,              // primary script engine
                                        NULL,           // call the engine's global code
                                        pTxnScriptContextCustom,
                                        &fAborted
                                    );
    if (FAILED(hr) && hr != CONTEXT_E_ABORTED)
        {
        /*
         * The cryptically named CONTEXT_E_OLDREF error in this case means that
         * we are trying to run a transacted web page, but DTC isnt running.
         * CONTEXT_E_TMNOTAVAILABLE means the same thing.  God knows why
         */
        if (hr == CONTEXT_E_OLDREF || hr == CONTEXT_E_TMNOTAVAILABLE)
            {
            HandleErrorMissingFilename(IDE_EXECUTOR_DTC_NOT_RUNNING, pHitObj);
            }

        // Regardless of the error, exit
        goto LExit;
        }

    /*
     * If this is a transacted web page, then run either the OnTransactionCommit
     * or OnTransactionAbort method in the script, if any.
     *
     * If the script writer did an explicit SetAbort, or a component run by the script
     * did a SetAbort, then we run OnTransactionAbort, otherwise run OnTransactionCommit
     */
    if (pTemplate->FTransacted())
        {
#ifndef PERF_DISABLE
        g_PerfData.Incr_TRANSPERSEC();
#endif

        if (hr == CONTEXT_E_ABORTED || fAborted)
            {
            // Reset the error... dont communicate this back to the caller as an actual error
            hr = S_OK;

            hr = CallScriptFunction(*pEngineInfo, L"OnTransactionAbort", NULL, &fAborted);

#ifndef PERF_DISABLE
            g_PerfData.Incr_TRANSABORTED();
#endif
            }
        else
            {
            hr = CallScriptFunction(*pEngineInfo, L"OnTransactionCommit", NULL, &fAborted);

#ifndef PERF_DISABLE
            g_PerfData.Incr_TRANSCOMMIT();
#endif
            }

        // Ignore UNKNOWNNAME -- this means the author didnt write the method, which is fine
        if (hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND)
            hr = S_OK;
            
        if (FAILED(hr))
            goto LExit;
        }

LExit:

#ifndef PERF_DISABLE
    if (fPerfTransPending)
        g_PerfData.Decr_TRANSPENDING();
#endif

    // Uninit the scripting namespace
    (VOID)intrinsics.PScriptingNamespace()->UnInit();

    // Return the engine(s) to cache
    DeAllocAndFreeEngines(pEngineInfo, pHitObj->PAppln(), pTxnScriptContextCustom);

    // If debugging, notify debugger ONPAGEDONE
    if (fDebuggerNotifiedOnStart)
        {
        Assert(pHitObj->PAppln()->FDebuggable());
        pTemplate->NotifyDebuggerOnPageEvent(FALSE);
        }

    // Remove the ASP ObjectContext object from the namespace, and dealloc it if we allocated one
    pHitObj->RemoveObjectContext();
    
    if (pTxnScriptContextCustom)
        {
        pTxnScriptContextCustom->Release();
        }

    return hr;
    }

/*===================================================================
ExecuteGlobal

UNDONE: handle script engine the same manner as mainline script engines
        with respect to debugging.

Execute code in Global.ASA as part of application or session start or end.

Parameters:
    pHitObj         - pointer to the hit object
    intrinsics      - pointers to the intrinsic IUnknown pointers.
    pEngineInfo     - pointers to engine info
    pfDeleteSession - true if global.asa failed, and therefore the caller should

Returns:
    S_OK on success
===================================================================*/
HRESULT ExecuteGlobal
(
CHitObj *pHitObj,
const CIntrinsicObjects &intrinsics,
ActiveEngineInfo *pEngineInfo
)
    {
    HRESULT hr = S_OK;
    CTemplate *pTemplate = NULL;
    IASPObjectContextCustom *pTxnScriptContextCustom = NULL;
    IASPObjectContext *pTxnScriptContext = NULL;
    WORD iEng;
    BOOLB fAborted = FALSE;
    BOOLB fDebuggerNotifiedOnStart = FALSE;

    BOOL fUnHideRequestAndResponse = FALSE;

    BOOL fOnStartAppln = FALSE;
    BOOL fOnEndAppln = FALSE;
    BOOL fOnEndSession = FALSE;
    BOOL fGlobalAsaInCache;
    BOOL fApplnStarted = FALSE;

    // The hit obj must be there, be valid, & have a global.asa name
    Assert(pHitObj != NULL);
    pHitObj->AssertValid();
    Assert(pHitObj->GlobalAspPath() != NULL && *(pHitObj->GlobalAspPath()) != '\0');

    // Other arg's must be right
    Assert(pEngineInfo != NULL);

    // Load the script - cache will AddRef
    // bug 1051: load template before possibly removing response object (in switch block, below),
    // so error reporting to browser will work
    hr = LoadTemplate(pHitObj->GlobalAspPath(), pHitObj, &pTemplate, intrinsics, /* fGlobalAsa */ TRUE, &fGlobalAsaInCache);
    if (FAILED(hr))
        goto LExit;

    Assert(pTemplate != NULL);

    // Remember GLOBAL.ASA's type library wrapper with the application
    // on the first request

    if (pHitObj->FStartApplication() && pTemplate->PTypeLibWrapper())
        {
        pHitObj->PAppln()->SetGlobTypeLibWrapper(pTemplate->PTypeLibWrapper());
        }

    /*
     * Bug 86404: If this script is transacted, then create a new "real" ASP ObjectContext object
     * and add it to the objects list.  If the page is not transacted, then 
     * CHitObj::UseObjectContext will use pre-instantiated "zombie" ObjectContext.
     */
    if (pTemplate->FTransacted())
        {
        IObjectContext *pContext;

        if (FAILED(hr = GetObjectContext(&pContext)))
            goto LExit;
        /*
         * Incredibly obscure bug in OLE32.  If OLE needs to spin up an MTA thread in order to
         * create the class factory for the ASPObjectContext object, then the thread needs to be
         * created by the unimpersonated user.
         * NOTE: This can be removed after the new OLE32 ships in NT4 SP4
         */
        RevertToSelf();
        
        hr = pContext->CreateInstance
            (
            CLSIDObjectContextFromTransType(pTemplate->GetTransType()),
            IID_IASPObjectContextCustom,
            reinterpret_cast<void **>(&pTxnScriptContextCustom)
            );

        // Restore Impersonation
        HANDLE hThread = GetCurrentThread();
        SetThreadToken(&hThread, pHitObj->HImpersonate());
        pContext->Release();
        if (FAILED(hr))
            goto LExit;

        hr = pTxnScriptContextCustom->QueryInterface(IID_IASPObjectContext, reinterpret_cast<void **>(&pTxnScriptContext));
        if (FAILED(hr))
            goto LExit;

        // add to namespace
        pHitObj->AddObjectContext(pTxnScriptContext);
        pTxnScriptContext->Release();
        }
        
    Assert(pHitObj->FIsValidRequestType());

    // Figure out which events to trigger
    if (pHitObj->FIsBrowserRequest())
        {
        fOnStartAppln = pHitObj->FStartApplication();

        if (fOnStartAppln)
            {
            // Hide response and request intrinsics from namespace
            pHitObj->HideRequestAndResponseIntrinsics();

            // Flag that intrinsics need to be un-hidden back in.
            fUnHideRequestAndResponse = TRUE;
            }
        }
    else if (pHitObj->FIsSessionCleanupRequest())
        {
        fOnEndSession = TRUE;
        }
    else if (pHitObj->FIsApplnCleanupRequest())
        {
        fOnEndAppln = TRUE;
        }

    // If debugging, notify debugger ONPAGESTART
    if (pHitObj->PAppln()->FDebuggable())
        {
        if (SUCCEEDED(pTemplate->NotifyDebuggerOnPageEvent(TRUE)))
            fDebuggerNotifiedOnStart = TRUE;
        }
        
    hr = AllocAndLoadEngines(pHitObj, pTemplate, pEngineInfo, intrinsics.PScriptingNamespace(), /* fGlobalAsa */TRUE);
    if (FAILED(hr))
        goto LExit;

    // BUG 93991: Defer registration of new document with debugger until after script engines have
    //            been loaded
    //
    if (!fGlobalAsaInCache && pHitObj->PAppln()->FDebuggable())
        pTemplate->AttachTo(pHitObj->PAppln());

    // bug 975: if no script engines, do not attempt to call event functions
    if(0 == pTemplate->CountScriptEngines())
        goto LExit;
        
    /*
     * Call event functions as required
     * bug 459: event functions may be in any script engine
     */
    
    // First run Application_OnStart
    if (fOnStartAppln)
        {           
        pHitObj->SetEventState(eEventAppOnStart);
        
        hr = CallScriptFunction(*pEngineInfo, L"Application_OnStart", pTxnScriptContextCustom, &fAborted);
        
        if (SUCCEEDED(hr) || hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND ||
            intrinsics.PResponse()->FResponseAborted())
            {
            if (fUnHideRequestAndResponse)
                {
                pHitObj->UnHideRequestAndResponseIntrinsics();
                fUnHideRequestAndResponse = FALSE;
                }
                
            fApplnStarted = TRUE;               
            hr = S_OK;
            }
        else
            {
            goto LExit;
            }
        }
    
    if (pHitObj->FStartSession())
        {
    // If application on start was run, add Response and Request names to script engines
        if (fOnStartAppln)
            {
            for (iEng = 0; iEng < pEngineInfo->cActiveEngines; ++iEng)
                {   
                if (FAILED(hr = pEngineInfo->rgActiveEngines[iEng].pScriptEngine->AddAdditionalObject(WSZ_OBJ_RESPONSE, FALSE)))
                    goto LExit;
                
                if (FAILED(hr = pEngineInfo->rgActiveEngines[iEng].pScriptEngine->AddAdditionalObject(WSZ_OBJ_REQUEST, FALSE)))
                    goto LExit;
                }
            }

        pHitObj->SetEventState(eEventSesOnStart);
        hr = CallScriptFunction(*pEngineInfo, L"Session_OnStart", pTxnScriptContextCustom, &fAborted);
        
        if (FAILED(hr) && hr != DISP_E_UNKNOWNNAME && hr != DISP_E_MEMBERNOTFOUND &&
            !intrinsics.PResponse()->FResponseAborted())
            {
            // Mark session as on-start-failed - to be deleted soon
            pHitObj->SessionOnStartFailed();
            }   
        else
            {
            if (SUCCEEDED(hr))
                {
                // Mark as on-start-invoked -- need to wait for timeout
                pHitObj->SessionOnStartInvoked();
                }

            // Check if Session_OnEnd Present
            if (SUCCEEDED(TestScriptFunction(*pEngineInfo, L"Session_OnEnd")))
                {
                // Mark as on-end-present -- need to execute OnEnd later
                pHitObj->SessionOnEndPresent();
                }

            hr = S_OK;
            }

        goto LExit;
        }

    if (fOnEndSession)
        {
        pHitObj->SetEventState(eEventSesOnEnd);
        hr = CallScriptFunction(*pEngineInfo, L"Session_OnEnd", pTxnScriptContextCustom, &fAborted);
        // We are failing silently here, since there is no corrective action we could take
        }

        
    if (fOnEndAppln)
        {
        pHitObj->SetEventState(eEventAppOnEnd);
        hr = CallScriptFunction(*pEngineInfo, L"Application_OnEnd", pTxnScriptContextCustom, &fAborted);
        // We are failing silently here, since there is no corrective action we could take
        }
            
LExit:

    if (fUnHideRequestAndResponse)
        {
        pHitObj->UnHideRequestAndResponseIntrinsics();
        }

    if (FAILED(hr) && (hr != E_SOURCE_FILE_IS_EMPTY) && pHitObj->FStartApplication() && !fApplnStarted)
        {
        pHitObj->ApplnOnStartFailed();
        }

    pHitObj->SetEventState(eEventNone);
        
    // Uninit the scripting namespace
    (VOID)intrinsics.PScriptingNamespace()->UnInit();

    // Release the template
    if (pTemplate)
        {

        // bug 975: if no script engines, do not do this
        if(pTemplate->CountScriptEngines() > 0)
            // Return the engine(s) to cache
            DeAllocAndFreeEngines(pEngineInfo, pHitObj->PAppln(), pTxnScriptContextCustom);

        // If debugging, notify debugger ONPAGEDONE
        if (fDebuggerNotifiedOnStart)
            {
            Assert(pHitObj->PAppln()->FDebuggable());
            pTemplate->NotifyDebuggerOnPageEvent(FALSE);
            }

        pTemplate->Release();
        }

    // Remove the ASP ObjectContext object from the namespace, and dealloc it if we allocated one
    pHitObj->RemoveObjectContext();

    if (pTxnScriptContextCustom)
        {
        pTxnScriptContextCustom->Release();
        }

    // It is OK if the event function was not found in global.asa
    if (hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND)
        {
        hr = S_OK;
        }

    return hr;
    }

/*===================================================================
CIntrinsicObjects::Prepare

Prepare intrinsics for the request processing

Parameters:
    pSession        session holding the instrinsics (can be NULL)

Returns:
    HRESULT
===================================================================*/
HRESULT CIntrinsicObjects::Prepare
(
CSession *pSession
)
    {
    HRESULT hr = S_OK;

    if (pSession)
        {
        // get request, response, server from session

        if (SUCCEEDED(hr))
            {
            m_pRequest = pSession->PRequest();
            if (m_pRequest)
                m_pRequest->AddRef();
            else
                hr = E_FAIL;
            }

        if (SUCCEEDED(hr))
            {
            m_pResponse = pSession->PResponse();
            if (m_pResponse)
                m_pResponse->AddRef();
            else
                hr = E_FAIL;
            }

        if (SUCCEEDED(hr))
            {
            m_pServer = pSession->PServer();
            if (m_pServer)
                m_pServer->AddRef();
            else
                hr = E_FAIL;
            }
        }
    else
        {
        // create new request, response, server

        if (SUCCEEDED(hr))
            {
            m_pRequest = new CRequest;
            if (!m_pRequest)
                hr = E_OUTOFMEMORY;
            }

        if (SUCCEEDED(hr))
            {
            m_pResponse = new CResponse;
            if (!m_pResponse)
                hr = E_OUTOFMEMORY;
            }

        if (SUCCEEDED(hr))
            {
            m_pServer = new CServer;
            if (!m_pServer)
                hr = E_OUTOFMEMORY;
            }
        }

    // init request, response, server

    if (SUCCEEDED(hr))
        {
        Assert(m_pRequest);
        hr = m_pRequest->Init();
        }

    if (SUCCEEDED(hr))
        {
        Assert(m_pResponse);
        hr = m_pResponse->Init();
        }

    if (SUCCEEDED(hr))
        {
        Assert(m_pServer);
        hr = m_pServer->Init();
        }

    // create the scripting namespace

    if (SUCCEEDED(hr))
        {
        m_pScriptingNamespace = new CScriptingNamespace;
        if (!m_pScriptingNamespace)
            hr = E_OUTOFMEMORY;
        }

    // cleanup on error

    if (FAILED(hr))
        Cleanup();

    m_fIsChild = FALSE;
    return hr;
    }

/*===================================================================
CIntrinsicObjects::PrepareChild

Prepare intrinsics structure for a child request

Parameters:
    pResponse       parent intrinsic
    pRequest        parent intrinsic
    pServer         parent intrinsic

Returns:
    HRESULT
===================================================================*/
HRESULT CIntrinsicObjects::PrepareChild
(
CResponse *pResponse,
CRequest *pRequest,
CServer *pServer
)
    {
    HRESULT hr = S_OK;

    if (!pResponse || !pRequest || !pServer)
        {
        hr = E_FAIL;
        }

    if (SUCCEEDED(hr))
        {
        m_pResponse = pResponse;
        m_pResponse->AddRef();

        m_pRequest = pRequest;
        m_pRequest->AddRef();

        m_pServer = pServer;
        m_pServer->AddRef();

        m_fIsChild = TRUE;
        }

    if (SUCCEEDED(hr))
        {
        m_pScriptingNamespace = new CScriptingNamespace;
        if (!m_pScriptingNamespace)
            hr = E_OUTOFMEMORY;
        }

    if (FAILED(hr))
        Cleanup();

    return hr;
    }

/*===================================================================
CIntrinsicObjects::Cleanup

Cleanup the intrinsics after the request processing

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CIntrinsicObjects::Cleanup()
    {
    if (m_pRequest)
        {
        if (!m_fIsChild)
            m_pRequest->UnInit();
        m_pRequest->Release();
        m_pRequest = NULL;
        }

    if (m_pResponse)
        {
        if (!m_fIsChild)
            m_pResponse->UnInit();
        m_pResponse->Release();
        m_pResponse = NULL;
        }

    if (m_pServer)
        {
        if (!m_fIsChild)
            m_pServer->UnInit();
        m_pServer->Release();
        m_pServer = NULL;
        }

    if (m_pScriptingNamespace)
        {
        m_pScriptingNamespace->Release();
        m_pScriptingNamespace = NULL;
        }

    return S_OK;
    }

/*===================================================================
ReInitIntrinsics

Call re-init on each of the intrinsics that require it
to run a new page.

Parameters:
    pHitObj         - pointer to the hit object
    intrinsics      - pointers to the intrinsic IUnknown pointers.
    pEngineInfo     - some engine info
    fPostGlobal     - Is this a reinit after running global.asa?

Returns:
    S_OK on success
===================================================================*/
HRESULT ReInitIntrinsics
(
CHitObj *pHitObj,
const CIntrinsicObjects &intrinsics,
ActiveEngineInfo *pEngineInfo,
BOOL fPostGlobal
)
    {
    HRESULT hr;

    Assert(pHitObj != NULL);
    pHitObj->AssertValid();
    Assert(pEngineInfo != NULL);
    
    // Hand the new CIsapiReqInfo to the Server object
    // Note on bug 682: We do always need to re-init CServer because it takes the phitobj
    if (FAILED(hr = intrinsics.PServer()->ReInit(pHitObj->PIReq(), pHitObj)))
        goto LExit;

    if (FAILED(hr = intrinsics.PScriptingNamespace()->Init()))
        goto LExit;
        
    /*
     * Bug 682 & 671 (better fix to 452 & 512)
     * Dont re-init the Request & response objects after running a Global.Asa
     * because, the running of global.asa may have set cookies into request (bug 671), that reinit
     * would wipe, and the global.asa may have output headers (or other stuff) which impacts the response
     * object (bug 512) that we dont want to reset.
     */
    if (!fPostGlobal)
        {
        if (FAILED(hr = intrinsics.PRequest()->ReInit(pHitObj->PIReq(), pHitObj)))
            goto LExit;
            
        if (FAILED(hr = intrinsics.PResponse()->ReInit(
                                                pHitObj->PIReq(),
                                                pHitObj->PSzNewSessionCookie(),
                                                intrinsics.PRequest(),
                                                GetScriptEngine,
                                                pEngineInfo,
                                                pHitObj
                                                )))
            goto LExit;
        }
            
LExit:
    return(hr);
    }

/*===================================================================
LoadTemplate

Load a template, cleanup and give appropriate errors on failure.

Parameters:
    szFile          - the file to load a template for
    pHitObj         - pointer to the hit object
    ppTemplate      - The returned loaded template
    fGlobalAsa      - is this for Global.asa?

Returns:
    S_OK on success
===================================================================*/
HRESULT LoadTemplate
(
const TCHAR                 *szFile,
      CHitObj               *pHitObj,
      CTemplate             **ppTemplate,
const CIntrinsicObjects     &intrinsics,
      BOOL                  fGlobalAsa,
      BOOL                  *pfTemplateInCache)
{
    HRESULT hr;

    Assert(pHitObj != NULL);
    pHitObj->AssertValid();
    Assert(ppTemplate != NULL);

    // Load the script - cache will AddRef
    if (FAILED(hr = g_TemplateCache.Load(
    							fGlobalAsa,
    							szFile,
    							pHitObj->DWInstanceID(),
    							pHitObj,
    							ppTemplate,
    							pfTemplateInCache)))
        {
        // CONSIDER moving this cleanup into Template.Load
        if (hr == E_COULDNT_OPEN_SOURCE_FILE || hr == E_SOURCE_FILE_IS_EMPTY)
            {
            // Load error string from string table
            // BUG 731: added if to retrieve the correct header

            WCHAR   szwErr[128];
            
            if (hr == E_COULDNT_OPEN_SOURCE_FILE)
                {
                CwchLoadStringOfId(IDH_404_OBJECT_NOT_FOUND, szwErr, 128);
                intrinsics.PResponse()->put_Status( szwErr );
                HandleSysError(404, 0, IDE_404_OBJECT_NOT_FOUND, NULL, NULL, pHitObj);
#ifndef PERF_DISABLE
                g_PerfData.Incr_REQNOTFOUND();
#endif
                }
            // bug 977: silently ignore empty global.asa file
            else if ((E_SOURCE_FILE_IS_EMPTY == hr) && !fGlobalAsa)
                {
                CwchLoadStringOfId(IDH_204_NO_CONTENT, szwErr, 128);
                intrinsics.PResponse()->put_Status( szwErr );
                HandleSysError(204, 0, IDE_204_NO_CONTENT, NULL, NULL, pHitObj);
                }
            }
        // fix for bug 371
        if (*ppTemplate)
            {
            (*ppTemplate)->Release();
            *ppTemplate = NULL;
            }

		if (hr == E_OUTOFMEMORY)
			{
			DBGPRINTF((DBG_CONTEXT, "Loading template returned E_OUTOFMEMORY.  Flushing template & Script Cache.\n"));
			g_TemplateCache.FlushAll();
			g_ScriptManager.FlushAll();
			}
        }

    return(hr);
    }

/*===================================================================
AllocAndLoadEngines

Allocate and load all the engines we need

Parameters:
    pHitObj             - The hit object
    pTemplate           - The template we're gonna run
    pEngineInfo         - Engine info to fill in
    pScriptingNamespace - scripting namespace
    fGlobalAsa          - Are we loading engines to run global.asa?

Returns:
    S_OK on success
===================================================================*/
HRESULT AllocAndLoadEngines
(
CHitObj *pHitObj,
CTemplate *pTemplate,
ActiveEngineInfo *pEngineInfo,
CScriptingNamespace *pScriptingNamespace,
BOOL fGlobalAsa
)
    {
    HRESULT hr = S_OK;
    int iObj;
    WORD iEng;
    WORD iScriptBlock;
    WORD cEngines = pTemplate->CountScriptEngines();

    Assert(pHitObj != NULL);
    pHitObj->AssertValid();
    Assert(pTemplate != NULL);
    Assert(pEngineInfo != NULL);
    Assert(pScriptingNamespace != NULL);

    // Load objects from template into hit object
    for (iObj = pTemplate->Count(tcompObjectInfo) - 1; iObj >= 0; --iObj)
        {
        CHAR      *szObjectName = NULL;
        CLSID      clsid;
        CompScope scope;
        CompModel model;
        CMBCSToWChar    convStr;
        
        // get object-info from template and add to hitobj's list of objects
        hr = pTemplate->GetObjectInfo(iObj, &szObjectName, &clsid, &scope, &model);
        if(FAILED(hr))
            goto LExit;

        hr = convStr.Init(szObjectName);

        if (FAILED(hr))
            goto LExit;

        // ignore error ?
        pHitObj->AddComponent(ctTagged, clsid, scope, model, convStr.GetString());
        }

    // bug 975: if no script engines, exit now
    if(cEngines == 0)
        goto LExit;
    
    // Allocate space for script engines
    //
    // NOTE: There is a timing problem here in that the response object needs to
    //      be instantiated before we instantiate the script engines, but the
    //      response object needs to be able to access the list of active script
    //      engines, because it may need to halt execution.  To accomplish this,
    //      the response object is passed a pointer to the "EngineInfo" structure
    //      as a pointer, and then we modify the contents of the pointer right under
    //      its nose.  We pass an accessor function via pointer so that response just
    //      sees a void pointer.
    //

    if (cEngines == 1)
        {
        // don't do allocations in case of one engine
        pEngineInfo->rgActiveEngines = & (pEngineInfo->siOneActiveEngine);
        }
    else
        {
        pEngineInfo->rgActiveEngines = new ScriptingInfo[cEngines];
        if (pEngineInfo->rgActiveEngines == NULL)
            {
            hr = E_OUTOFMEMORY;
            goto LExit;
            }
        }

    pEngineInfo->cEngines = cEngines;
    pEngineInfo->cActiveEngines = 0;    // number of SUCCESSFULLY instantiated engines

    // Load all of the script engines in advance.
    for (iScriptBlock = 0; iScriptBlock < cEngines; ++iScriptBlock)
        {
        LPCOLESTR       wstrScript;
        SCRIPTSTATE     nScriptState;

        ScriptingInfo *pScriptInfo = &pEngineInfo->rgActiveEngines[iScriptBlock];
        pTemplate->GetScriptBlock(
                                iScriptBlock,
                                &pScriptInfo->szScriptEngine,
                                &pScriptInfo->pProgLangId,
                                &wstrScript);

        // Populate information required for the line mapping callback.
        //
        pScriptInfo->LineMapInfo.iScriptBlock = iScriptBlock;
        pScriptInfo->LineMapInfo.pTemplate = pTemplate;

        // acquire a script engine by:
        //
        //  getting an engine from the template object (if it has one)
        //  else from the script manager.
        //
        // If we are in debug mode, the templates tend to be greedy and hold
        // onto script engines.  (See notes in scrptmgr.h)
        //
        pScriptInfo->pScriptEngine = NULL;
        
        if (pHitObj->PAppln()->FDebuggable())
            {
            pScriptInfo->pScriptEngine = pTemplate->GetActiveScript(iScriptBlock);
            
            if (pScriptInfo->pScriptEngine)
                {
                // If we got one, we don't need to re-init the engine
                nScriptState = SCRIPTSTATE_INITIALIZED;
                hr = static_cast<CActiveScriptEngine *>(pScriptInfo->pScriptEngine)->ReuseEngine(pHitObj, NULL, iScriptBlock, pHitObj->DWInstanceID());
                }
            }
            
        if (pScriptInfo->pScriptEngine == NULL)
            {
            hr = g_ScriptManager.GetEngine(LOCALE_SYSTEM_DEFAULT,
                                            *(pScriptInfo->pProgLangId),
                                            pTemplate->GetSourceFileName(),
                                            pHitObj,
                                            &pScriptInfo->pScriptEngine,
                                            &nScriptState,
                                            pTemplate,
                                            iScriptBlock);
            }
        if (FAILED(hr))
            goto LExit;

        // BUG 252: Keep track of how many engines we actually instantiate
        ++pEngineInfo->cActiveEngines;

        if (nScriptState == SCRIPTSTATE_UNINITIALIZED || fGlobalAsa)
            {
            if (FAILED(hr = pScriptInfo->pScriptEngine->AddObjects(!fGlobalAsa)))
                goto LExit;
            }

        if (nScriptState == SCRIPTSTATE_UNINITIALIZED)
            {
            if (FAILED(hr = pScriptInfo->pScriptEngine->AddScriptlet(wstrScript)))
                goto LExit;
            }

        // Add the engine to the scripting namespace
        if (FAILED(hr = pScriptingNamespace->AddEngineToNamespace(
                                                (CActiveScriptEngine *)pScriptInfo->pScriptEngine)))
                goto LExit;

		// Update locale & code page (in case they are different om this page)
		pScriptInfo->pScriptEngine->UpdateLocaleInfo(hostinfoLocale);
		pScriptInfo->pScriptEngine->UpdateLocaleInfo(hostinfoCodePage);
        }

    // Add the scripting namespace to each script engine. Because all engines might not
    // implement "lazy instantiation", this code requires all
    // engines are pre-instantiated (which means we can't do it in the above loop.)
    // Add the scripting namespace to the hitobj first
    pHitObj->AddScriptingNamespace(pScriptingNamespace);
        
    for (iEng = 0; iEng < pEngineInfo->cActiveEngines; ++iEng)
        pEngineInfo->rgActiveEngines[iEng].pScriptEngine->AddScriptingNamespace();

    /*
     * Bug 735:
     * Bring all engines except the "primary engine" (engine 0) to runnable state
     * in the order in which script for the given language was found in the script file
     */
    for (iEng = 1; iEng < pEngineInfo->cActiveEngines; ++iEng)
        {
        hr = pEngineInfo->rgActiveEngines[iEng].pScriptEngine->MakeEngineRunnable();
        if (FAILED(hr))
            goto LExit;
        }
    
LExit:
    return(hr);
    }

/*===================================================================
DeAllocAndFreeEngines

Deallocate and free any loaded engines

Parameters:
    pEngineInfo         - Engine info to release

Returns:
    Nothing
===================================================================*/
VOID DeAllocAndFreeEngines
(
ActiveEngineInfo *pEngineInfo,
CAppln *pAppln,
IASPObjectContextCustom *pTxnScriptContextCustom
)
    {
    WORD iEng;

    Assert(pEngineInfo != NULL);

    if (pEngineInfo->cActiveEngines > 0) {
        if (pEngineInfo->rgActiveEngines == NULL) {
            Assert(pEngineInfo->rgActiveEngines);
        }
        else {
            for (iEng = 0; iEng < pEngineInfo->cActiveEngines; ++iEng)
                g_ScriptManager.ReturnEngineToCache(&pEngineInfo->rgActiveEngines[iEng].pScriptEngine, pAppln, pTxnScriptContextCustom);
            pEngineInfo->cActiveEngines = 0;
        }
    }
    if (pEngineInfo->cEngines > 1)
        {
        delete pEngineInfo->rgActiveEngines;
        }

    pEngineInfo->cEngines = 0;
    pEngineInfo->rgActiveEngines = NULL;
    }

/*===================================================================
GetScriptEngine

Get a script engine based on index. Return NULL if the index
is not in range.  (this is a callback)

The AllocAndLoadEngines function will create an array of ScriptingInfo
structures that are defined here.  It contains all the infomation
needed to 1. set up the MapScript2SourceLine callback,
2. merge namespaces, 3. set up this callback.

Parameters:
    iScriptEngine - the script engine to retrieve
    pvData      - instance data for the function

Returns:
    The requested script engine or NULL if not such engine
    
Side effects:
    None
===================================================================*/   
CScriptEngine *GetScriptEngine
(
INT iScriptEngine,
VOID *pvData
)
    {
    ActiveEngineInfo *pInfo = static_cast<ActiveEngineInfo *>(pvData);
    if (unsigned(iScriptEngine) >= unsigned(pInfo->cActiveEngines))
        {
        // Note: the caller has no idea how many script engines there are.
        // if the caller asks for an engine out of range, return NULL so they
        // know they have asked for more than there are
        return NULL;
        }

    return(pInfo->rgActiveEngines[iScriptEngine].pScriptEngine);
    }

/*===================================================================
CallScriptFunctionOfEngine

Calls a script engine to execute one of its functions

Returns:
    S_OK on success
    
Side effects:
    None
===================================================================*/
HRESULT CallScriptFunctionOfEngine
(
ActiveEngineInfo &engineInfo,
short iScriptBlock,
wchar_t *strFunction,
IASPObjectContextCustom *pTxnScriptContextCustom,
BOOLB *pfAborted
)
    {
    HRESULT hr;

    Assert(engineInfo.rgActiveEngines != NULL);
    Assert(engineInfo.rgActiveEngines[iScriptBlock].pScriptEngine != NULL);
    Assert(pfAborted != NULL);

    *pfAborted = FALSE;

    /*
     * If they want a transaction, then we create a TransactedScript object
     * and tell it to call the engine
     */
    if (pTxnScriptContextCustom)
        {
        hr = pTxnScriptContextCustom->Call(
#ifdef _WIN64
        // Win64 fix -- use UINT64 instead of LONG_PTR since LONG_PTR is broken for Win64 1/21/2000
        (UINT64)engineInfo.rgActiveEngines[iScriptBlock].pScriptEngine,strFunction, pfAborted);
#else
        (LONG_PTR)engineInfo.rgActiveEngines[iScriptBlock].pScriptEngine,strFunction, pfAborted);
#endif
        }
    else
        {
        hr = engineInfo.rgActiveEngines[iScriptBlock].pScriptEngine->Call(strFunction);
        }

    return hr;
    }

/*===================================================================
CallScriptFunction

Calls each script engine in turn to execute a script function;
exits when an engine succeeds or we run out of engines.

Returns:
    S_OK on success
    
Side effects:
    None
===================================================================*/
HRESULT CallScriptFunction
(
ActiveEngineInfo &engineInfo,
wchar_t *strFunction,
IASPObjectContextCustom *pTxnScriptContextCustom,
BOOLB *pfAborted
)
    {
    HRESULT hr = E_FAIL;
    int     i;
    
    for (i = 0; i < engineInfo.cActiveEngines; i++)
        {
        // if execution succeeds, bail
        if (SUCCEEDED(hr = CallScriptFunctionOfEngine(engineInfo, (SHORT)i, strFunction,
                                                pTxnScriptContextCustom, pfAborted)))
            goto LExit;

        // if execution fails with exception other then unknown name, bail
        if (hr != DISP_E_UNKNOWNNAME && hr != DISP_E_MEMBERNOTFOUND)
            goto LExit;
        }

LExit:
    return hr;
    }

/*===================================================================
TestScriptFunction

Tests each script engine in turn to test [the existance of] a script
function; exits when an engine succeeds or we run out of engines.

Parameters
    ActiveEngineInfo &engineInfo
    wchar_t          *strFunction       functions name


Returns:
    S_OK if exists
    
Side effects:
    None
===================================================================*/
HRESULT TestScriptFunction
(
ActiveEngineInfo &engineInfo,
wchar_t *strFunction
)
    {
    HRESULT hr = E_FAIL;
    
    for (int i = 0; i < engineInfo.cActiveEngines; i++)
        {
        hr = engineInfo.rgActiveEngines[i].pScriptEngine->
            CheckEntryPoint(strFunction);

        // if execution succeeds, bail
        if (SUCCEEDED(hr))
            break;

        // if fails with result other then unknown name, bail
        if (hr != DISP_E_UNKNOWNNAME && hr != DISP_E_MEMBERNOTFOUND)
            break;
        }

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\ie449.h ===
/*===================================================================
Microsoft IIS 5.0 (ASP)

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: 449 negotiations w/IE

File: ie449.h

Owner: DmitryR

This file contains the definitons for the 449 negotiations w/IE
===================================================================*/

#ifndef IE449_H
#define IE449_H

#include "hashing.h"
#include "aspdmon.h"
#include "memcls.h"

// forward declr
class CHitObj;
class C449Cookie;
class C449File;

/*===================================================================
The API
===================================================================*/

// init/uninit on dll level
HRESULT Init449();
HRESULT UnInit449();

// create a new cookie
HRESULT Create449Cookie(char *szName, TCHAR *szFile, C449Cookie **pp449);

// do the work
HRESULT Do449Processing
    (
    CHitObj *pHitObj, 
    C449Cookie **rgpCookies, 
    DWORD cCookies
    );

// change notification processing
HRESULT Do449ChangeNotification(TCHAR *szFile = NULL);

/*===================================================================
C449File class definition
    files are hashed
===================================================================*/
class C449File : public IUnknown, public CLinkElem
    {
private:
    LONG  m_cRefs;              // ref count
    LONG  m_fNeedLoad;          // flag when need to reload (Interlocked)
    TCHAR *m_szFile;             // file name with script
    char *m_szBuffer;           // file contents
    DWORD m_cbBuffer;           // file contents length
    CDirMonitorEntry *m_pDME;   // for change notification support

    C449File();       // should be done using Create449Cookie()
    ~C449File();      // should be done using Release()

    HRESULT Init(TCHAR *szFile);

public:
    // public constructor
    static HRESULT Create449File(TCHAR *szFile, C449File **ppFile);

    HRESULT Load();

    inline char *SzBuffer() { return m_szBuffer; }
    inline DWORD CbBuffer() { return m_cbBuffer; }

    inline void SetNeedLoad() { InterlockedExchange(&m_fNeedLoad, 1); }

    // IUnknown implementation
	STDMETHODIMP		 QueryInterface(REFIID, VOID**);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
        
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*===================================================================
C449FileMgr class definition
    file manager keeps the hash table of files
===================================================================*/
class C449FileMgr
    {
private:
    CRITICAL_SECTION m_csLock;
    CHashTableMBStr  m_ht449Files;

    inline void Lock()    { EnterCriticalSection(&m_csLock); }
    inline void UnLock()  { LeaveCriticalSection(&m_csLock); }

public:
    C449FileMgr();
    ~C449FileMgr();
    
    HRESULT Init();

    // find or create a new one
    HRESULT GetFile(TCHAR *szFile, C449File **ppFile);

    // change notification
    HRESULT Flush(TCHAR *szFile);
    HRESULT FlushAll();
    };

/*===================================================================
C449Cookie class definition
    cookie is a cookie -- file pair
===================================================================*/
class C449Cookie : public IUnknown
    {
private:
    LONG      m_cRefs;      // ref count
    char     *m_szName;     // cookie name to check
    DWORD     m_cbName;     // cookie name length
    C449File *m_pFile;      // related file

    C449Cookie();       // should be done using Create449Cookie()
    ~C449Cookie();      // should be done using Release()

    HRESULT Init(char *szName, C449File *pFile);

public:
    // public constructor
    static HRESULT Create449Cookie(char *szName, C449File *pFile, C449Cookie **pp449);

    inline char *SzCookie() { return m_szName; }
    inline DWORD CbCookie() { return m_cbName; }

    inline HRESULT LoadFile() { return m_pFile ? m_pFile->Load() : E_FAIL; }
    inline char   *SzBuffer() { return m_pFile ? m_pFile->SzBuffer() : NULL; }
    inline DWORD   CbBuffer() { return m_pFile ? m_pFile->CbBuffer() : 0; }

    // IUnknown implementation
	STDMETHODIMP		 QueryInterface(REFIID, VOID**);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
        
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

#endif // IE449_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\hashing.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Link list and Hash table

File: Hashing.cpp

Owner: PramodD

This is the Link list and Hash table source file.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "memchk.h"


/*===================================================================
::DefaultHash

this is a hash algorithm that is highly recommended by Aho,
Seth, and Ulman from the dragon book. (THE compiler reference)

Parameters:
    BYTE *  pbKey
    int     cbKey

Returns:
    Hashed DWORD value.
===================================================================*/

DWORD DefaultHash(const BYTE *pbKey, int cbKey)
{
    const unsigned WORD_BITS            = CHAR_BIT * sizeof(unsigned);
    const unsigned SEVENTY_FIVE_PERCENT = WORD_BITS * 3 / 4;
    const unsigned ONE_EIGHTH           = WORD_BITS / 8;
    const unsigned HIGH_BITS            = ~(unsigned(~0) >> ONE_EIGHTH);

    register unsigned uT, uResult = 0;
    register const BYTE *pb = pbKey;

    while (cbKey-- > 0)
    {
        uResult = (uResult << ONE_EIGHTH) + *pb++;
        if ((uT = uResult & HIGH_BITS) != 0)
            uResult = (uResult ^ (uT >> SEVENTY_FIVE_PERCENT)) & ~HIGH_BITS;
    }

    return uResult;
}



/*===================================================================
::UnicodeUpcaseHash

This is Aho, Seth, and Ulman's hash algorithm adapted for wide
character strings.  Their algorithm was not designed for cases
where every other character is 0 (which is how a unicode string
looks if you pretend it's ascii)  Therefore, performance
qualities are unknown for that case.

NOTE: for real Unicode, (not unicode that is merely ANSI converted)
      I have no idea how good a distribution this algorithm will
      produce. (since we are shifting in values > 8 bits now)

Parameters:
    BYTE *  pbKey
    int     cbKey

Returns:
    Hashed DWORD value.
===================================================================*/

#define toupper(x)  WORD(CharUpper(LPSTR(WORD(x))))

DWORD UnicodeUpcaseHash(const BYTE *pbKey, int cbKey)
{
    // PERF hash on last CCH_HASH chars only
    const unsigned WORD_BITS            = CHAR_BIT * sizeof(unsigned);
    const unsigned SEVENTY_FIVE_PERCENT = WORD_BITS * 3 / 4;
    const unsigned ONE_EIGHTH           = WORD_BITS / 8;
    const unsigned HIGH_BITS            = ~(unsigned(~0) >> ONE_EIGHTH);
    const unsigned CCH_HASH             = 8;

    register unsigned uT, uResult = 0;

    Assert ((cbKey & 1) == 0);      // cbKey better be even!
    int cwKey = unsigned(cbKey) >> 1;

    register const WORD *pw = reinterpret_cast<const WORD *>(pbKey) + cwKey;

    cwKey = min(cwKey, CCH_HASH);

    if (FIsWinNT())
    {
        WCHAR awcTemp[CCH_HASH];

        // copy last cwKey WCHARs of pbKey to last cwKey WCHARs of awcTemp
        wcsncpy(awcTemp + CCH_HASH - cwKey, pw - cwKey, cwKey);
        CharUpperBuffW(awcTemp + CCH_HASH - cwKey, cwKey);

        pw = awcTemp + CCH_HASH;

        while (cwKey-- > 0)
        {
            uResult = (uResult << ONE_EIGHTH) + *--pw;
            if ((uT = uResult & HIGH_BITS) != 0)
                uResult = (uResult ^ (uT >> SEVENTY_FIVE_PERCENT)) & ~HIGH_BITS;
        }
    }
    else
    {
        // CharUpperBuffW does nothing on Windows 95, so we use CharUpperBuffA
        // instead.  Chances are that the top eight bits are zero anyway,
        // and even if they aren't, this will still give us a halfway-decent
        // distribution.

        CHAR achTemp[CCH_HASH];

        for (int i = 0;  i < cwKey;  ++i)
            achTemp[i] = (CHAR) *(pw - cwKey + i);
        CharUpperBuffA(achTemp, cwKey);

        while (cwKey-- > 0)
        {
            uResult = (uResult << ONE_EIGHTH) + achTemp[cwKey];
            if ((uT = uResult & HIGH_BITS) != 0)
                uResult = (uResult ^ (uT >> SEVENTY_FIVE_PERCENT)) & ~HIGH_BITS;
        }
    }

    return uResult;
}

DWORD MultiByteUpcaseHash(const BYTE *pbKey, int cbKey)
{
    // PERF hash on first CCH_HASH chars only
    const unsigned WORD_BITS            = CHAR_BIT * sizeof(unsigned);
    const unsigned SEVENTY_FIVE_PERCENT = WORD_BITS * 3 / 4;
    const unsigned ONE_EIGHTH           = WORD_BITS / 8;
    const unsigned HIGH_BITS            = ~(unsigned(~0) >> ONE_EIGHTH);
    const unsigned CCH_HASH             = 8;

    register unsigned uT, uResult = 0;

    unsigned char achTemp[CCH_HASH + 1];

    // For performance we only HASH on at most CCH_HASH characters.
    cbKey = min(cbKey, CCH_HASH);

    // Copy cbKey chacters into temporary buffer
    memcpy(achTemp, pbKey, cbKey);

    // Add terminating null character
    achTemp[cbKey] = 0;

    // Convert to upper case
    _mbsupr(achTemp);

    while (cbKey-- > 0)
    {
        uResult = (uResult << ONE_EIGHTH) + achTemp[cbKey];
        if ((uT = uResult & HIGH_BITS) != 0)
            uResult = (uResult ^ (uT >> SEVENTY_FIVE_PERCENT)) & ~HIGH_BITS;
    }

    return uResult;
}

/*===================================================================
::PtrHash

Hash function that returns the pointer itself as the
DWORD hash value


Parameters:
    BYTE *  pbKey
    int     cbKey (not used)

Returns:
    Hashed DWORD value.
===================================================================*/
DWORD PtrHash
(
const BYTE *pbKey,
int /* cbKey */
)
    {
    return *(reinterpret_cast<DWORD *>(&pbKey));
    }


/*===================================================================
CLSIDHash

CLSID hash. Uses xor of the first and last DWORD

Parameters:
    BYTE *  pbKey
    int     cbKey

Returns:
    Hashed DWORD value.
===================================================================*/
DWORD CLSIDHash
(
const BYTE *pbKey,
int cbKey
)
    {
    Assert(cbKey == 16);
    DWORD *pdwKey = (DWORD *)pbKey;
    return (pdwKey[0] ^ pdwKey[3]);
    }

/*===================================================================
CLinkElem::CLinkElem

The Constructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CLinkElem::CLinkElem(void)
: m_pKey(NULL),
  m_cbKey(0),
  m_Info(0),
  m_pPrev(NULL),
  m_pNext(NULL)
{
}

/*===================================================================
HRESULT CLinkElem::Init

Initializes class members

Parameters:
    void *  pKey
    int     cbKey

Returns:
    S_OK     Success
    E_FAIL      Error
===================================================================*/
HRESULT CLinkElem::Init( void *pKey, int cbKey )
{
    m_pPrev = NULL;
    m_pNext = NULL;
    m_Info = 0;

    if ( pKey == NULL || cbKey == 0 )
        return E_FAIL;

    m_pKey = static_cast<BYTE *>(pKey);
    m_cbKey = (short)cbKey;

    return S_OK;
}

/*===================================================================
CHashTable::CHashTable

Constructor for CHashTable

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CHashTable::CHashTable( HashFunction pfnHash )
: m_fInited(FALSE),
  m_fBucketsAllocated(FALSE),
  m_pHead(NULL),
  m_pTail(NULL),
  m_rgpBuckets(NULL),
  m_pfnHash(pfnHash),
  m_cBuckets(0),
  m_Count(0)
{
}

/*===================================================================
CHashTable::~CHashTable

Destructor for CHashTable. Frees allocated bucket array.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CHashTable::~CHashTable( void )
{
    if (m_fBucketsAllocated)
    {
        Assert(m_rgpBuckets);
        delete [] m_rgpBuckets;
    }
}

/*===================================================================
HRESULT CHashTable::UnInit

Frees allocated bucket array.

Parameters:
    NONE

Returns:
    S_OK     Always
===================================================================*/
HRESULT CHashTable::UnInit( void )
{
    if (m_fBucketsAllocated)
    {
        Assert(m_rgpBuckets);
        delete [] m_rgpBuckets;
        m_fBucketsAllocated = FALSE;
    }

    m_rgpBuckets = NULL;
    m_pHead      = NULL;
    m_pTail      = NULL;
    m_cBuckets   = 0;
    m_Count      = 0;
    m_fInited    = FALSE;

    return S_OK;
}

/*===================================================================
void CHashTable::AssertValid

Verify integrity of the data structure.

NOTE: This function does very deep integrity checks and thus is
      very slow.

Checks performed:

        verify that m_Count is valid
        verify that each element is in the right bucket
        verify prev, next links and info fields
===================================================================*/

#ifdef DBG
void CHashTable::AssertValid() const
{
    CLinkElem *pElem;       // pointer to current link element
    unsigned i;             // index into current bucket
    unsigned cItems = 0;    // actual number of items in the table

    Assert(m_fInited);

    if (m_Count == 0)
    {
        if (m_rgpBuckets)
        {
            BOOL fAllNulls = TRUE;
            // empty hash table - make sure that everything reflects this
            Assert(m_pHead == NULL);
            Assert (m_pTail == NULL);

            for (i = 0; i < m_cBuckets; i++)
            {
                if (m_rgpBuckets[i] != NULL)
                {
                    fAllNulls = FALSE;
                    break;
                }
            }

            Assert(fAllNulls);
        }
        return;
    }

    // If m_Count > 0
    Assert(m_pHead);
    Assert(m_pHead->m_pPrev == NULL);
    Assert(m_pTail != NULL && m_pTail->m_pNext == NULL);
    Assert(m_rgpBuckets);

    // Now verify each entry
    for (i = 0; i < m_cBuckets; ++i)
    {
        pElem = m_rgpBuckets[i];
        while (pElem != NULL)
        {
            // Verify hashing
            Assert ((m_pfnHash(pElem->m_pKey, pElem->m_cbKey) % m_cBuckets) == i);

            // Verify links
            if (pElem->m_pPrev)
                {
                Assert (pElem->m_pPrev->m_pNext == pElem);
                }
            else
                {
                Assert (m_pHead == pElem);
                }
                
            if (pElem->m_pNext)
                {
                Assert (pElem->m_pNext->m_pPrev == pElem);
                }
            else
                {
                Assert (m_pTail == pElem);
                }

            // Verify info fields
            Assert (pElem->m_Info >= 0);
            if (pElem != m_rgpBuckets[i])
                {
                Assert (pElem->m_Info == pElem->m_pPrev->m_Info - 1);
                }

            // Prepare for next iteration, stopping when m_Info is zero.
            ++cItems;
            if (pElem->m_Info == 0)
                break;

            pElem = pElem->m_pNext;
        }
    }

    // Verify count
    Assert (m_Count == cItems);
}
#endif



/*===================================================================
HRESULT CHashTable::Init

Initialize CHashTable by allocating the bucket array and
and initializing the bucket link lists.

Parameters:
    UINT    cBuckets    Number of buckets

Returns:
    HRESULT S_OK
            E_OUTOFMEMORY
===================================================================*/
HRESULT CHashTable::Init( UINT cBuckets )
{
    m_cBuckets = cBuckets;
    m_Count = 0;
    m_rgpBuckets = NULL;  // created on demand

    m_fInited = TRUE;
    return S_OK;
}

/*===================================================================
HRESULT CHashTable::ReInit

Reinitialize CHashTable by deleting everything in it.  - client
is responsible for making the hashtable empty first

Parameters:
    None

Returns:
    None
===================================================================*/
void CHashTable::ReInit()
{
    Assert( m_fInited );

    if (m_rgpBuckets)
        memset(m_rgpBuckets, 0, m_cBuckets * sizeof(CLinkElem *));

    m_Count = 0;
    m_pHead = NULL;
    m_pTail = NULL;
}

/*===================================================================
HRESULT CHashTable::AllocateBuckets()

Allocates hash table buckets on demand

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHashTable::AllocateBuckets()
{
    Assert(m_rgpBuckets == NULL);
    Assert(m_fInited);
    Assert(m_cBuckets > 0);

    if (m_cBuckets <= PREALLOCATED_BUCKETS_MAX)
    {
        m_rgpBuckets = m_rgpBucketsBuffer;
    }
    else
    {
        m_rgpBuckets = new CLinkElem * [m_cBuckets];
        if (m_rgpBuckets == NULL)
            return E_OUTOFMEMORY;
        m_fBucketsAllocated = TRUE;
    }

    memset(m_rgpBuckets, 0, m_cBuckets * sizeof(CLinkElem *));
    return S_OK;
}

/*===================================================================
BOOL CHashTable::FIsEqual

compare two keys using their lengths and memcmp()

Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key
    const void *pKey2       second key
    int         cbKey2      length of second key

Returns:
    Pointer to element added/found.
===================================================================*/
BOOL CHashTable::FIsEqual( const void * pKey1,
              int           cbKey1,
              const void *  pKey2,
              int           cbKey2 )
{
    if (cbKey1 != cbKey2)
        return FALSE;

    return memcmp(pKey1, pKey2, cbKey1) == 0;
}

#pragma optimize("g", off)
/*===================================================================
CHashTable::AddElem

Adds a CLinkElem to Hash table.
User is responsible for allocating the Element to be added.

Parameters:
    CLinkElem * pElem       Object to be added
    BOOL        fTestDups   Look for duplicates if true

Returns:
    Pointer to element added/found.
===================================================================*/
CLinkElem *CHashTable::AddElem( CLinkElem *pElem, BOOL fTestDups )
{
    if (m_rgpBuckets == NULL)
    {
        if (FAILED(AllocateBuckets()))
            return NULL;
    }

    if (pElem == NULL)
        return NULL;

    BOOL        fNew = TRUE;
    DWORD       iT = m_pfnHash( pElem->m_pKey, pElem->m_cbKey ) % m_cBuckets;
    CLinkElem * pT = m_rgpBuckets[iT];
    BOOL        fDebugTestDups = FALSE;

#ifdef DBG
    // In retail, if fTestDups is false, it means that
    // there shouldnt be any dups, so dont bother testing.  Under debug, however
    // we want to be able to assert that there isnt a dup (since there isnt supposed to be one).
    fDebugTestDups = !fTestDups;
#endif

    if (fTestDups || fDebugTestDups)
    {
        while ( pT && fNew )
        {
            if ( FIsEqual( pT->m_pKey, pT->m_cbKey, pElem->m_pKey, pElem->m_cbKey ) )
                fNew = FALSE;
            else if ( pT->m_Info > 0 )
                pT = pT->m_pNext;
            else
                break;
        }
    }

#ifdef DBG
    // If there arent supposed to be any dups, then make sure this element is seen as "new"
    if (fDebugTestDups)
        Assert(fNew);
#endif

#ifdef DUMP_HASHING_INFO
    static DWORD cAdds = 0;
    FILE *logfile = NULL;

    if (cAdds++ > 1000000 && m_Count > 100)
        {
        cAdds = 0;
        if (logfile = fopen("C:\\Temp\\hashdump.Log", "a+"))
            {
            DWORD cZero = 0;
            short iMax = 0;
            DWORD cGte3 = 0;
            DWORD cGte5 = 0;
            DWORD cGte10 = 0;

            fprintf(logfile, "Hash dump: # elements = %d\n", m_Count);
            for (UINT iBucket = 0; iBucket < m_cBuckets; iBucket++)
                {
                if (m_rgpBuckets[iBucket] == NULL)
                    cZero++;
                else
                    {
                    short Info = m_rgpBuckets[iBucket]->m_Info;
                    if (Info > iMax)
                        iMax = Info;
                    if (Info >= 10) cGte10++;
                    else if (Info >= 5) cGte5++;
                    else if (Info >= 3) cGte3++;
                    }
                }
            fprintf(logfile, "Max chain = %d, # 0 chains = %d, # >= 3 = %d, # >= 5 = %d, # >= 10 = %d\n",
                        (DWORD)iMax, cZero, cGte3, cGte5, cGte10);
            fflush(logfile);
            fclose(logfile);
            }
        }
#endif

    if ( fNew )
    {
        if ( pT )
        {
            // There are other elements in bucket
            pT = m_rgpBuckets[iT];
            m_rgpBuckets[iT] = pElem;
            pElem->m_Info = pT->m_Info + 1;
            pElem->m_pNext = pT;
            pElem->m_pPrev = pT->m_pPrev;
            pT->m_pPrev = pElem;
            if ( pElem->m_pPrev == NULL )
                m_pHead = pElem;
            else
                pElem->m_pPrev->m_pNext = pElem;
        }
        else
        {
            // This is the first element in the bucket
            m_rgpBuckets[iT] = pElem;
            pElem->m_pPrev = NULL;
            pElem->m_pNext = m_pHead;
            pElem->m_Info = 0;
            if ( m_pHead )
                m_pHead->m_pPrev = pElem;
            else
                m_pTail = pElem;
            m_pHead = pElem;
        }
        m_Count++;

        AssertValid();
        return pElem;
    }

    AssertValid();
    return pT;
}
#pragma optimize("g", on)

#pragma optimize("g", off)
/*===================================================================
CLinkElem * CHashTable::FindElem

Finds an object in the hash table based on the name.

Parameters:
    void *  pKey
    int     cbKey

Returns:
    Pointer to CLinkElem if found, otherwise NULL.
===================================================================*/
CLinkElem * CHashTable::FindElem( const void *pKey, int cbKey )
{
    AssertValid();

    if ( m_rgpBuckets == NULL || pKey == NULL )
        return NULL;

    DWORD       iT = m_pfnHash( static_cast<const BYTE *>(pKey), cbKey ) % m_cBuckets;
    CLinkElem * pT = m_rgpBuckets[iT];
    CLinkElem * pRet = NULL;

    while ( pT && pRet == NULL )
    {
        if ( FIsEqual( pT->m_pKey, pT->m_cbKey, pKey, cbKey ) )
            pRet = pT;
        else if ( pT->m_Info > 0 )
            pT = pT->m_pNext;
        else
            break;
    }

    return pRet;
}
#pragma optimize("g", on)

#pragma optimize("g", off)
/*===================================================================
CHashTable::DeleteElem

Removes a CLinkElem from Hash table.
The user should delete the freed link list element.

Parameters:
    void *  pbKey       key
    int     cbKey       length of key

Returns:
    Pointer to element removed, NULL if not found
===================================================================*/
CLinkElem * CHashTable::DeleteElem( const void *pKey, int cbKey )
{
    if ( m_rgpBuckets == NULL || pKey == NULL )
        return NULL;

    CLinkElem * pRet = NULL;
    DWORD       iT = m_pfnHash( static_cast<const BYTE *>(pKey), cbKey ) % m_cBuckets;
    CLinkElem * pT = m_rgpBuckets[iT];

    while ( pT && pRet == NULL )// Find it !
    {
        if ( FIsEqual( pT->m_pKey, pT->m_cbKey, pKey, cbKey ) )
            pRet = pT;
        else if ( pT->m_Info > 0 )
            pT = pT->m_pNext;
        else
            break;
    }
    if ( pRet )
    {
        pT = m_rgpBuckets[iT];

        if ( pRet == pT )
        {
            // Update bucket head
            if ( pRet->m_Info > 0 )
                m_rgpBuckets[iT] = pRet->m_pNext;
            else
                m_rgpBuckets[iT] = NULL;
        }
        // Update counts in bucket link list
        while ( pT != pRet )
        {
            pT->m_Info--;
            pT = pT->m_pNext;
        }
        // Update link list
        if ( pT = pRet->m_pPrev )
        {
            // Not the Head of the link list
            if ( pT->m_pNext = pRet->m_pNext )
                pT->m_pNext->m_pPrev = pT;
            else
                m_pTail = pT;
        }
        else
        {
            // Head of the link list
            if ( m_pHead = pRet->m_pNext )
                m_pHead->m_pPrev = NULL;
            else
                m_pTail = NULL;
        }
        m_Count--;
    }

    AssertValid();
    return pRet;
}
#pragma optimize("g", on)

/*===================================================================
CHashTable::RemoveElem

Removes a given CLinkElem from Hash table.
The user should delete the freed link list element.

Parameters:
    CLinkElem * pLE     Element to remove

Returns:
    Pointer to element removed
===================================================================*/
CLinkElem * CHashTable::RemoveElem( CLinkElem *pLE )
{
    CLinkElem *pLET;

    if ( m_rgpBuckets == NULL || pLE == NULL )
        return NULL;

    // Remove this item from the linked list
    pLET = pLE->m_pPrev;
    if (pLET)
        pLET->m_pNext = pLE->m_pNext;
    pLET = pLE->m_pNext;
    if (pLET)
        pLET->m_pPrev = pLE->m_pPrev;
    if (m_pHead == pLE)
        m_pHead = pLE->m_pNext;
    if (m_pTail == pLE)
        m_pTail = pLE->m_pPrev;

    /*
     * If this was the first item in a bucket, then fix up the bucket.
     * Otherwise, decrement the count of items in the bucket for each item
     * in the bucket prior to this item
     */
    if (pLE->m_pPrev == NULL || pLE->m_pPrev->m_Info == 0)
        {
        UINT iBucket;

        // This item is head of a bucket.  Need to find out which bucket!
        for (iBucket = 0; iBucket < m_cBuckets; iBucket++)
            if (m_rgpBuckets[iBucket] == pLE)
                break;
        Assert(iBucket < m_cBuckets && m_rgpBuckets[iBucket] == pLE);

        if (pLE->m_Info == 0)
            m_rgpBuckets[iBucket] = NULL;
        else
            m_rgpBuckets[iBucket] = pLE->m_pNext;
        }
    else
        {
        // This item is in the middle of a bucket chain.  Update counts in preceeding items
        pLET = pLE->m_pPrev;
        while (pLET != NULL && pLET->m_Info != 0)
            {
            pLET->m_Info--;
            pLET = pLET->m_pPrev;
            }
        }

    // Decrement count of total number of items
    m_Count--;

    AssertValid();
    return pLE;
}

/*===================================================================
CHashTableStr::CHashTableStr

Constructor for CHashTableStr

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CHashTableStr::CHashTableStr( HashFunction pfnHash )
    : CHashTable( pfnHash )
{
}

/*===================================================================
BOOL CHashTableStr::FIsEqual

compare two keys using their lengths, treating the keys
as Unicode and doing case insensitive compare.


Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key
    const void *pKey2       second key
    int         cbKey2      length of second key

Returns:
    Pointer to element added/found.
===================================================================*/
BOOL CHashTableStr::FIsEqual( const void *  pKey1,
              int           cbKey1,
              const void *  pKey2,
              int           cbKey2 )
{
    if ( cbKey1 != cbKey2 )
        return FALSE;

    return _wcsnicmp(static_cast<const wchar_t *>(pKey1), static_cast<const wchar_t *>(pKey2), cbKey1) == 0;
}


/*===================================================================
CHashTableMBStr::CHashTableMBStr

Constructor for CHashTableMBStr

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CHashTableMBStr::CHashTableMBStr( HashFunction pfnHash )
    : CHashTable( pfnHash )
{
}

/*===================================================================
BOOL CHashTableMBStr::FIsEqual

compare two keys using their lengths, treating the keys
as multi-byte strings and doing case insensitive compare.


Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key
    const void *pKey2       second key
    int         cbKey2      length of second key

Returns:
    Pointer to element added/found.
===================================================================*/
BOOL CHashTableMBStr::FIsEqual( const void *    pKey1,
              int           cbKey1,
              const void *  pKey2,
              int           cbKey2 )
{
    if ( cbKey1 != cbKey2 )
        return FALSE;

    return _mbsnicmp(static_cast<const unsigned char *>(pKey1), static_cast<const unsigned char *>(pKey2), cbKey1) == 0;
}

/*===================================================================
CHashTablePtr::CHashTablePtr

Constructor for CHashTableStr

Parameters:
    HashFunction pfnHash    has function (PtrHash is default)

Returns:
    NONE
===================================================================*/
CHashTablePtr::CHashTablePtr
(
    HashFunction pfnHash
)
    : CHashTable(pfnHash)
    {
    }

/*===================================================================
BOOL CHashTablePtr::FIsEqual

Compare two pointers.
Used by CHashTable to find elements

Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key (unused)
    const void *pKey2       second key
    int         cbKey2      length of second key (unused)

Returns:
    BOOL (true when equal)
===================================================================*/
BOOL CHashTablePtr::FIsEqual
(
const void *pKey1,
int        /* cbKey1 */,
const void *pKey2,
int         /* cbKey2 */
)
    {
    return (pKey1 == pKey2);
    }

/*===================================================================
CHashTableCLSID::CHashTableCLSID

Constructor for CHashTableCLSID

Parameters:
    HashFunction pfnHash    has function (CLSIDHash is default)

Returns:
    NONE
===================================================================*/
CHashTableCLSID::CHashTableCLSID
(
    HashFunction pfnHash
)
    : CHashTable(pfnHash)
    {
    }

/*===================================================================
BOOL CHashTableCLSID::FIsEqual

Compare two CLSIDs.

Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key
    const void *pKey2       second key
    int         cbKey2      length of second key

Returns:
    BOOL (true when equal)
===================================================================*/
BOOL CHashTableCLSID::FIsEqual
(
const void *pKey1,
int         cbKey1,
const void *pKey2,
int         cbKey2
)
    {
    Assert(cbKey1 == sizeof(CLSID) && cbKey2 == sizeof(CLSID));
    return IsEqualCLSID(*((CLSID *)pKey1), *((CLSID *)pKey2));
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\initguid.c ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Script Manager

File: InitGuid.cpp

Owner: AndrewS

Init all guids used by Denali in one place.
We are only allowed to #include objbase with INITGUID set once,
and after that we need to create all our GUIDs.  Otherwise, the
linker complains about redefeined symbols.  We do it here.
===================================================================*/

#define CINTERFACE
#include <objbase.h>
#include <initguid.h>
#include "_asptlb.h"
#include "activscp.h"
#include "activdbg.h"
#include "wraptlib.h"
#include "denguid.h"

#if _IIS_5_1
#include <iadm.h>
#elif _IIS_6_0
#include <iadmw.h>
#else
#error "Neither _IIS_6_0 nor _IIS_5_1 is defined"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\htmldump.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: ASP Status Html Dump

File: htmldump.cpp

Owner: dmitryr

This file contains the ASP status html dump code
used from IISPROBE.DLL 
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "gip.h"
#include "mtacb.h"
#include "perfdata.h"
#include "activdbg.h"
#include "dlldatax.h"
#include "txnscrpt.h"
#include "debugger.h"
#include "dbgutil.h"
#include "randgen.h"
#include "aspdmon.h"

#include "memcls.h"
#include "memchk.h"

/*===================================================================
Helper classes and functions
===================================================================*/
class CAspDump
    {
private:
    char *m_szBuffer;
    DWORD m_dwMaxSize;
    DWORD m_dwActSize;

public:
    CAspDump(char *szBuffer, DWORD dwMaxSize)
        {
        m_szBuffer = szBuffer;
        m_dwMaxSize = dwMaxSize;
        m_dwActSize = 0;
        }

    inline void __cdecl Dump(LPCSTR fmt, ...)
        {
        char szStr[512];
        
        va_list marker;
        va_start(marker, fmt);
        vsprintf(szStr, fmt, marker);
        va_end(marker);
        
        DWORD len = strlen(szStr);
            
        if (len > 0 && len < (m_dwMaxSize-m_dwActSize))
            {
            memcpy(m_szBuffer+m_dwActSize, szStr, len+1);
            m_dwActSize += len;
            }
        }

    DWORD GetSize()
        {
        return m_dwActSize;
        }
    };


/*===================================================================
AspStatusHtmlDump

Function called from IISPROBE.DLL
Fills in the buffer with the ASP status as HTML

Parameters:
    szBuffer        buffer to fill in
    pwdSize         in  - max buffer len
                    out - actual buffer len filled

Returns:
    TRUE
===================================================================*/
extern "C"
BOOL WINAPI AspStatusHtmlDump(char *szBuffer, DWORD *pdwSize)
    {
    CAspDump dump(szBuffer, *pdwSize);


    dump.Dump("<table border=1>\r\n");
    
    dump.Dump("<tr><td align=center colspan=2><b>Misc. Globals</b>\r\n");

    dump.Dump("<tr><td>fShutDownInProgress<td>%d\r\n",      g_fShutDownInProgress);
    dump.Dump("<tr><td>nApplications<td>%d\r\n",            g_nApplications);
    dump.Dump("<tr><td>nApplicationsRestarting<td>%d\r\n",  g_nApplicationsRestarting);
    dump.Dump("<tr><td>nSessions<td>%d\r\n",                g_nSessions);
    dump.Dump("<tr><td>nBrowserRequests<td>%d\r\n",         g_nBrowserRequests);
    dump.Dump("<tr><td>nSessionCleanupRequests<td>%d\r\n",  g_nSessionCleanupRequests);
    dump.Dump("<tr><td>nApplnCleanupRequests<td>%d\r\n",    g_nApplnCleanupRequests);
    dump.Dump("<tr><td>pPDM (debugger)<td>%08p\r\n",        g_pPDM);


    dump.Dump("<tr><td align=center colspan=2><b>Selected PerfMon Counters</b>\r\n");

    dump.Dump("<tr><td>Last request's execution time, ms<td>%d\r\n",        *g_PerfData.PLCounter(ID_REQEXECTIME));
    dump.Dump("<tr><td>Last request's wait time, ms<td>%d\r\n",             *g_PerfData.PLCounter(ID_REQWAITTIME));
    dump.Dump("<tr><td>Number of executing requests<td>%d\r\n",             *g_PerfData.PLCounter(ID_REQBROWSEREXEC));
    dump.Dump("<tr><td>Number of requests waiting in the queue<td>%d\r\n",  *g_PerfData.PLCounter(ID_REQCURRENT));
    dump.Dump("<tr><td>Number of rejected requests<td>%d\r\n",              *g_PerfData.PLCounter(ID_REQREJECTED));
    dump.Dump("<tr><td>Total number of requests<td>%d\r\n",                 *g_PerfData.PLCounter(ID_REQTOTAL));
    dump.Dump("<tr><td>Last session's duration, ms<td>%d\r\n",              *g_PerfData.PLCounter(ID_SESSIONLIFETIME));
    dump.Dump("<tr><td>Current number of sessions<td>%d\r\n",               *g_PerfData.PLCounter(ID_SESSIONCURRENT));
    dump.Dump("<tr><td>Total number of sessions<td>%d\r\n",                 *g_PerfData.PLCounter(ID_SESSIONSTOTAL));
    dump.Dump("<tr><td>Number of cached templates<td>%d\r\n",               *g_PerfData.PLCounter(ID_TEMPLCACHE));
    dump.Dump("<tr><td>Number of pending transactions<td>%d\r\n",           *g_PerfData.PLCounter(ID_TRANSPENDING));


    dump.Dump("<tr><td align=center colspan=2><b>Applications</b>\r\n");

	CApplnIterator ApplnIterator;
    ApplnIterator.Start();
    CAppln *pAppln;
    while (pAppln = ApplnIterator.Next())
        {
        
        dump.Dump("<tr><td colspan=2>%08p\r\n",                         pAppln);
        dump.Dump("<tr><td align=right>metabase key<td>%s\r\n",         pAppln->GetMetabaseKey());
        dump.Dump("<tr><td align=right>physical path<td>%s\r\n",        pAppln->GetApplnPath(SOURCEPATHTYPE_PHYSICAL));
        dump.Dump("<tr><td align=right>virtual path<td>%s\r\n",         pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL));
        dump.Dump("<tr><td align=right>number of sessions<td>%d\r\n",   pAppln->GetNumSessions());
        dump.Dump("<tr><td align=right>number of requests<td>%d\r\n",   pAppln->GetNumRequests());
#if 0
        dump.Dump("<tr><td align=right>global.asa path<td>%s\r\n",      pAppln->FHasGlobalAsa() ? pAppln->GetGlobalAsa() : "n/a");
#endif
        dump.Dump("<tr><td align=right>global changed?<td>%d\r\n",      pAppln->FGlobalChanged());
        dump.Dump("<tr><td align=right>tombstone?<td>%d\r\n",           pAppln->FTombstone());
        dump.Dump("<tr><td align=right>debuggable?<td>%d\r\n",          pAppln->FDebuggable());

        CSessionMgr *pSessionMgr = pAppln->PSessionMgr();

        dump.Dump("<tr><td align=right>session manager<td>%08p\r\n", pSessionMgr);

        if (pSessionMgr)
            {
            
            dump.Dump("<tr><td align=right>session killer scheduled?<td>%d\r\n", pSessionMgr->FIsSessionKillerScheduled());
            dump.Dump("<tr><td align=right>session cleanup requests<td>%d\r\n",  pSessionMgr->GetNumSessionCleanupRequests());
            
            }
        else
            {
            }
        }
    ApplnIterator.Stop();


    dump.Dump("</table>\r\n");

    *pdwSize = dump.GetSize();
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\ie449.cpp ===
/*===================================================================
Microsoft IIS 5.0 (ASP)

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: 449 negotiations w/IE

File: ie449.cpp

Owner: DmitryR

This file contains the implementation of the 449 negotiations w/IE
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "ie449.h"
#include "memchk.h"

/*===================================================================
Globals
===================================================================*/

C449FileMgr *m_p449FileMgr = NULL;

/*===================================================================
Internal funcitons
===================================================================*/
inline BOOL FindCookie
(
char *szCookiesBuf,
char *szCookie,
DWORD cbCookie
)
    {
    char *pch = szCookiesBuf;
    if (pch == NULL || *pch == '\0')
        return FALSE;

    while (1)
        {
        if (strnicmp(pch, szCookie, cbCookie) == 0)
            {
            if (pch[cbCookie] == '=')  // next char must be '='
                return TRUE;
            }
            
        // next cookie
        pch = strchr(pch, ';');
        if (pch == NULL)
            break;
        while (*(++pch) == ' ') // skip ; and any spaces
            ;
        }

    return FALSE;
    }


/*===================================================================
The API
===================================================================*/

/*===================================================================
Init449
===================================================================*/
HRESULT Init449()
    {
    // init hash table
    m_p449FileMgr = new C449FileMgr;
    if (m_p449FileMgr == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = m_p449FileMgr->Init();
    if (FAILED(hr))
        {
        delete m_p449FileMgr;
        m_p449FileMgr = NULL;
        return hr;
        }
    
    return S_OK;
    }
    
/*===================================================================
UnInit449
===================================================================*/
HRESULT UnInit449()
    {
    if (m_p449FileMgr != NULL)
        {
        delete m_p449FileMgr;
        m_p449FileMgr = NULL;
        }
        
    return S_OK;
    }

/*===================================================================
Create449Cookie

Get an existing 449 cookie from cache or create a new one

Parameters
    szName  cookie name
    szFile  script file
    pp449   [out] the cookie

Returns
    HRESULT
===================================================================*/
HRESULT Create449Cookie
(
char *szName, 
TCHAR *szFile, 
C449Cookie **pp449
)
    {
    HRESULT hr = S_OK;
    
    // Get the file first
    C449File *pFile = NULL;
    hr = m_p449FileMgr->GetFile(szFile, &pFile);
    if (FAILED(hr))
        return hr;

    // Create the cookie
    hr = C449Cookie::Create449Cookie(szName, pFile, pp449);
    if (FAILED(hr))
        pFile->Release();  // GetFile gave it addref'd
    
    return hr;
    }

/*===================================================================
Do449Processing

Check
    if the browser is IE5+
    there's no echo-reply: header
    all the cookies are present
    
Construct and send 449 response if needed

When the response is sent, HitObj is marked as 'done with session'
    
Parameters
    pHitObj             the request
    rgpCookies          array of cookie requirements
    cCookies            number of cookie requirements

Returns
    HRESULT
===================================================================*/
HRESULT Do449Processing
(
CHitObj *pHitObj, 
C449Cookie **rgpCookies, 
DWORD cCookies
)
    {
    HRESULT  hr = S_OK;

    if (cCookies == 0)
        return hr;
    
    //////////////////////////////////////////
    // check the browser

    BOOL fBrowser = FALSE;
    char *szBrowser = pHitObj->PIReq()->QueryPszUserAgent();
    if (szBrowser == NULL || szBrowser[0] == '\0')
        return S_OK; // bad browser
    
    char *szMSIE = strstr(szBrowser, "MSIE ");
    if (szMSIE)
        {
        char chVersion = szMSIE[5];
        if (chVersion >= '5' && chVersion <= '9')
            fBrowser = TRUE;
        }

#ifdef TINYGET449
    if (strcmp(szBrowser, "WBCLI") == 0)
        fBrowser = TRUE;
#endif

    if (!fBrowser)  // bad browser
        return S_OK;

    //////////////////////////////////////////
    // check the cookies
    
    char *szCookie = pHitObj->PIReq()->QueryPszCookie();

    // collect the arrays of pointers and sizes for not found cookies.
    // arrays size to at most number of cookies in the template.
    DWORD cNotFound = 0;
    DWORD cbNotFound = 0;
    STACK_BUFFER( tempCookiePtrs, 128 );
    STACK_BUFFER( tempCookieCBs, 128 );

    if (!tempCookiePtrs.Resize(cCookies * sizeof(void *))
        || !tempCookieCBs.Resize(cCookies * sizeof(DWORD))) {
        return E_OUTOFMEMORY;
    }
    void **rgpvNotFound = (void **)tempCookiePtrs.QueryPtr();
    DWORD *rgcbNotFound = (DWORD *)tempCookieCBs.QueryPtr();
    
    for (DWORD i = 0; SUCCEEDED(hr) && (i < cCookies); i++)
        {
        if (!FindCookie(szCookie, rgpCookies[i]->SzCookie(), rgpCookies[i]->CbCookie()))
            {
            // cookie not found -- append to the list

            hr = rgpCookies[i]->LoadFile();
            if (SUCCEEDED(hr)) // ignore bad files
                {
                rgpvNotFound[cNotFound] = rgpCookies[i]->SzBuffer();
                rgcbNotFound[cNotFound] = rgpCookies[i]->CbBuffer();
                cbNotFound += rgpCookies[i]->CbBuffer();
                cNotFound++;
                }
            }
        }

    if (!SUCCEEDED(hr))
        return hr;

    if (cNotFound == 0)
        return S_OK;    // everything's found    

    //////////////////////////////////////////
    // check echo-reply header

    char szEcho[80];
    DWORD dwEchoLen = sizeof(szEcho);
	if (pHitObj->PIReq()->GetServerVariableA("HTTP_MS_ECHO_REPLY", szEcho, &dwEchoLen) 
	    || GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	    {
		return S_OK;   // already in response cycle
		}
    
    //////////////////////////////////////////
    // send the 449 response

    CResponse::SyncWriteBlocks
        (
        pHitObj->PIReq(),    // WAM_EXEC_INFO
        cNotFound,          // number of blocks
        cbNotFound,         // total number of bytes in blocks
        rgpvNotFound,       // array of block pointers
        rgcbNotFound,       // array of block sizes
        NULL,               // text/html
        "449 Retry with",   // status
        "ms-echo-request: execute opaque=\"0\" location=\"BODY\"\r\n"  // extra header
        );

    //////////////////////////////////////////
    // tell HitObj no to write anything else

    if (pHitObj->FExecuting()) // on MTS worker thread?
        {
		DWORD dwRequestStatus = HSE_STATUS_SUCCESS_AND_KEEP_CONN;
        pHitObj->PIReq()->ServerSupportFunction
            (
		    HSE_REQ_DONE_WITH_SESSION,
    		&dwRequestStatus,
        	0,
		    NULL
    		);
  		}
    pHitObj->SetDoneWithSession();

    return S_OK;
    }

/*===================================================================
Do449ChangeNotification

Change notification processing
    
Parameters
    szFile  file changed or NULL for all
    
Returns
    HRESULT
===================================================================*/
HRESULT Do449ChangeNotification
(
TCHAR *szFile
)
    {
    if (szFile)
        return m_p449FileMgr->Flush(szFile);
    else
        return m_p449FileMgr->FlushAll();
    }


/*===================================================================
Class C449File
===================================================================*/

/*===================================================================
C449File::C449File

Constructor
===================================================================*/
C449File::C449File()
    {
    m_cRefs = 0;
    m_fNeedLoad = 0;
    m_szFile = NULL;
    m_szBuffer = NULL;
    m_cbBuffer = 0;
    m_pDME = NULL;
    }

/*===================================================================
C449File::~C449File

Destructor
===================================================================*/
C449File::~C449File()
    {
    Assert(m_cRefs == 0);
    if (m_szFile)
        free(m_szFile);
    if (m_szBuffer)
        free(m_szBuffer);
    if (m_pDME)
        m_pDME->Release();
    }

/*===================================================================
C449File::Init

Init strings, 
Load file for the first time,
Start change notifications
===================================================================*/
HRESULT C449File::Init
(
TCHAR *szFile
)
    {
    // remember the name
    m_szFile = StringDup(szFile);
    if (m_szFile == NULL)
        return E_OUTOFMEMORY;

    // init link element
    CLinkElem::Init(m_szFile, _tcslen(m_szFile)*sizeof(TCHAR));

    // load
    m_fNeedLoad = 1;
    HRESULT hr = Load();
    if (FAILED(hr))
        return hr;

    // start directory notifications
    TCHAR *pch = _tcsrchr(m_szFile, _T('\\')); // last backslash
    if (pch == NULL)
        return E_FAIL; // bogus filename?
    CASPDirMonitorEntry *pDME = NULL;
    *pch = _T('\0');
    RegisterASPDirMonitorEntry(m_szFile, &pDME);
    *pch = _T('\\');
    m_pDME = pDME;
    
    // done
    return S_OK;    
    }
    
/*===================================================================
C449File::Load

Load the file if needed
===================================================================*/
HRESULT C449File::Load()
    {
    HRESULT hr = S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    BYTE *pbBytes = NULL;
    DWORD dwSize = 0;

    // check if this thread needs to load the file
    if (InterlockedExchange(&m_fNeedLoad, 0) == 0)
        return S_OK;
        
    // cleanup the existing data if any
    if (m_szBuffer)
        free(m_szBuffer);
    m_szBuffer = NULL;        
    m_cbBuffer = 0;
        
    // open the file
    if (SUCCEEDED(hr))
        {
        hFile = CreateFile(
            m_szFile,
            GENERIC_READ,          // access (read-write) mode
            FILE_SHARE_READ,       // share mode
            NULL,                  // pointer to security descriptor
            OPEN_EXISTING,         // how to create
            FILE_ATTRIBUTE_NORMAL, // file attributes
            NULL                   // handle to file with attributes to copy
    		);
        if (hFile == INVALID_HANDLE_VALUE)
            hr = E_FAIL;
        }

    // get file size
    if (SUCCEEDED(hr))
        {
        dwSize = GetFileSize(hFile, NULL);
        if (dwSize == 0 || dwSize == 0xFFFFFFFF)
            hr = E_FAIL;
        }

    // create mapping
    if (SUCCEEDED(hr))
        {
        hMap = CreateFileMapping(
            hFile, 		    // handle to file to map 
            NULL,           // optional security attributes 
            PAGE_READONLY,  // protection for mapping object 
            0,              // high-order 32 bits of object size  
            0,              // low-order 32 bits of object size  
            NULL            // name of file-mapping object 
            );
        if (hMap == NULL)
            hr = E_FAIL;
        }
        
    // map the file
    if (SUCCEEDED(hr))
        {
        pbBytes = (BYTE *)MapViewOfFile(
            hMap,           // file-mapping object to map into address space
            FILE_MAP_READ,  // access mode 	
            0,              // high-order 32 bits of file offset 
            0,              // low-order 32 bits of file offset 
            0               // number of bytes to map 
			);
        if (pbBytes == NULL)
            hr = E_FAIL;
        }

    // remember the bytes
    if (SUCCEEDED(hr))
        {
        m_szBuffer = (char *)malloc(dwSize);
        if (m_szBuffer != NULL)
            {
            memcpy(m_szBuffer, pbBytes, dwSize);
            m_cbBuffer = dwSize;
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }

    // cleanup
    if (pbBytes != NULL)
        UnmapViewOfFile(pbBytes);
    if (hMap != NULL)
        CloseHandle(hMap);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    if (!SUCCEEDED(hr))
        SetNeedLoad();

    return hr;
    }

/*===================================================================
C449File::Create449File

static constructor
===================================================================*/
HRESULT C449File::Create449File
(
TCHAR *szFile,
C449File **ppFile
)
    {
    HRESULT hr = S_OK;
    C449File *pFile = new C449File;
    if (pFile == NULL)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        {
        hr = pFile->Init(szFile);
        }
        
    if (SUCCEEDED(hr))
        {
        pFile->AddRef();
        *ppFile = pFile;
        }
    else if (pFile)
        {
        delete pFile;
        }
    return hr;
    }

/*===================================================================
C449File::QueryInterface
C449File::AddRef
C449File::Release

IUnknown members for C449File object.
===================================================================*/
STDMETHODIMP C449File::QueryInterface(REFIID riid, VOID **ppv)
	{
	// should never be called
	Assert(FALSE);
	*ppv = NULL;
	return E_NOINTERFACE;
	}
	
STDMETHODIMP_(ULONG) C449File::AddRef()
	{
	return InterlockedIncrement(&m_cRefs);
	}
	
STDMETHODIMP_(ULONG) C449File::Release()
	{
    LONG cRefs = InterlockedDecrement(&m_cRefs);
	if (cRefs)
		return cRefs;
	delete this;
	return 0;
	}


/*===================================================================
Class C449FileMgr
===================================================================*/

/*===================================================================
C449FileMgr::C449FileMgr

Constructor
===================================================================*/
C449FileMgr::C449FileMgr()
    {
    INITIALIZE_CRITICAL_SECTION(&m_csLock);
    }

/*===================================================================
C449FileMgr::~C449FileMgr

Destructor
===================================================================*/
C449FileMgr::~C449FileMgr()
    {
    FlushAll();
    m_ht449Files.UnInit();
    DeleteCriticalSection(&m_csLock);
    }

/*===================================================================
C449FileMgr::Init

Initialization
===================================================================*/
HRESULT C449FileMgr::Init()
    {
    return m_ht449Files.Init(199);
    }

/*===================================================================
C449FileMgr::GetFile

Find file in the hash table, or create a new one
===================================================================*/
HRESULT C449FileMgr::GetFile
(
TCHAR *szFile, 
C449File **ppFile
)
    {
    C449File *pFile = NULL;
    CLinkElem *pElem;

    Lock();
    
    pElem = m_ht449Files.FindElem(szFile, _tcslen(szFile)*sizeof(TCHAR));
    
    if (pElem)
        {
        // found
        pFile = static_cast<C449File *>(pElem);
        if (!SUCCEEDED(pFile->Load()))
            pFile = NULL;
        else 
            pFile->AddRef();    // 1 ref to hand out
        }
    else if (SUCCEEDED(C449File::Create449File(szFile, &pFile)))
        {
        if (m_ht449Files.AddElem(pFile))
            pFile->AddRef();    // 1 for hash table + 1 to hand out
        }

    UnLock();
    
    *ppFile = pFile;
    return (pFile != NULL) ? S_OK : E_FAIL;
    }

/*===================================================================
C449FileMgr::Flush

Change notification for a single file
===================================================================*/
HRESULT C449FileMgr::Flush
(
TCHAR *szFile
)
    {
    Lock();
    
    CLinkElem *pElem = m_ht449Files.FindElem(szFile, _tcslen(szFile)*sizeof(TCHAR));
    if (pElem)
        {
        C449File *pFile = static_cast<C449File *>(pElem);
        pFile->SetNeedLoad(); // next time reload
        }

    UnLock();
    return S_OK;
    }
    
/*===================================================================
C449FileMgr::FlushAll

Remove all files
FlushAll is always together with template flush
===================================================================*/
HRESULT C449FileMgr::FlushAll()
    {
    // Unlink from hash table first
    Lock();
    CLinkElem *pElem = m_ht449Files.Head();
    m_ht449Files.ReInit();
    UnLock();

    // Walk the list to remove all
    while (pElem)
        {
        C449File *pFile = static_cast<C449File *>(pElem);
        pElem = pElem->m_pNext;
        pFile->Release();
        }
    
    return S_OK;
    }

/*===================================================================
Class C449Cookie
===================================================================*/

/*===================================================================
C449Cookie::C449Cookie

Constructor
===================================================================*/
C449Cookie::C449Cookie()
    {
    m_cRefs = 0;
    m_szName = NULL;
    m_cbName = 0;
    m_pFile = NULL;
    }

/*===================================================================
C449Cookie::~C449Cookie

Destructor
===================================================================*/
C449Cookie::~C449Cookie()
    {
    Assert(m_cRefs == 0);
    if (m_szName)
        free(m_szName);
    if (m_pFile)
        m_pFile->Release();
    }

/*===================================================================
C449Cookie::Init

Initialize
===================================================================*/
HRESULT C449Cookie::Init
(
char *szName, 
C449File *pFile
)
    {
    m_szName = StringDupA(szName);
    if (m_szName == NULL)
        return E_OUTOFMEMORY;
    m_cbName = strlen(m_szName);
    
    m_pFile = pFile;
    return S_OK;
    }

/*===================================================================
C449Cookie::Create449Cookie

static constructor
===================================================================*/
HRESULT C449Cookie::Create449Cookie
(
char *szName, 
C449File *pFile,
C449Cookie **pp449Cookie
)
    {
    HRESULT hr = S_OK;
    C449Cookie *pCookie = new C449Cookie;
    if (pCookie == NULL)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        {
        hr = pCookie->Init(szName, pFile);
        }
        
    if (SUCCEEDED(hr))
        {
        pCookie->AddRef();
        *pp449Cookie = pCookie;
        }
    else if (pCookie)
        {
        delete pCookie;
        }
        
    return hr;
    }

/*===================================================================
C449Cookie::QueryInterface
C449Cookie::AddRef
C449Cookie::Release

IUnknown members for C449Cookie object.
===================================================================*/
STDMETHODIMP C449Cookie::QueryInterface(REFIID riid, VOID **ppv)
	{
	// should never be called
	Assert(FALSE);
	*ppv = NULL;
	return E_NOINTERFACE;
	}
	
STDMETHODIMP_(ULONG) C449Cookie::AddRef()
	{
	return InterlockedIncrement(&m_cRefs);
	}
	
STDMETHODIMP_(ULONG) C449Cookie::Release()
	{
    LONG cRefs = InterlockedDecrement(&m_cRefs);
	if (cRefs)
		return cRefs;
	delete this;
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\largeint.h ===
/*--

Module Name:

    largeint.h

Abstract:

    Include file for sample Large Integer Arithmetic routines.  
    This file includes all of the prototypes for the routines found in 
    largeint.lib.  For complete descriptions of these functions, see the
    largeint.s source file for MIPS, or the divlarge.c and largeint.asm 
    source files for x86. 

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

//
//Large integer arithmetic routines.
//

//
// Large integer add - 64-bits + 64-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
LargeIntegerAdd (
    LARGE_INTEGER Addend1,
    LARGE_INTEGER Addend2
    );

//
// Enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
EnlargedIntegerMultiply (
    LONG Multiplicand,
    LONG Multiplier
    );

//
// Unsigned enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
EnlargedUnsignedMultiply (
    ULONG Multiplicand,
    ULONG Multiplier
    );

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

ULONG
WINAPI
EnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    );

//
// Extended large integer magic divide - 64-bits / 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
ExtendedMagicDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER MagicDivisor,
    CCHAR ShiftCount
    );

//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
ExtendedLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder
    );

//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
LargeIntegerDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER Divisor,
    PLARGE_INTEGER Remainder
    );

//
// Extended integer multiply - 32-bits * 64-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
ExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    );

//
// Large integer negation - -(64-bits)
//

LARGE_INTEGER
WINAPI
LargeIntegerNegate (
    LARGE_INTEGER Subtrahend
    );

//
// Large integer subtract - 64-bits - 64-bits -> 64-bits.
//

LARGE_INTEGER
WINAPI
LargeIntegerSubtract (
    LARGE_INTEGER Minuend,
    LARGE_INTEGER Subtrahend
    );

//
// Large integer and - 64-bite & 64-bits -> 64-bits.
//

#define LargeIntegerAnd(Result, Source, Mask)   \
        {                                           \
            Result.HighPart = Source.HighPart & Mask.HighPart; \
            Result.LowPart = Source.LowPart & Mask.LowPart; \
        }


//
// Large integer conversion routines.
//

//
// Convert signed integer to large integer.
//

LARGE_INTEGER
WINAPI
ConvertLongToLargeInteger (
    LONG SignedInteger
    );

//
// Convert unsigned integer to large integer.
//

LARGE_INTEGER
WINAPI
ConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    );


//
// Large integer shift routines.
//

LARGE_INTEGER
WINAPI
LargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

LARGE_INTEGER
WINAPI
LargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

LARGE_INTEGER
WINAPI
LargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

#define LargeIntegerGreaterThan(X,Y) (                              \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart > (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                      \
)

#define LargeIntegerGreaterThanOrEqualTo(X,Y) (                      \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart >= (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                       \
)

#define LargeIntegerEqualTo(X,Y) (                              \
    !(((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define LargeIntegerNotEqualTo(X,Y) (                          \
    (((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define LargeIntegerLessThan(X,Y) (                                 \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart < (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                      \
)

#define LargeIntegerLessThanOrEqualTo(X,Y) (                         \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart <= (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                       \
)

#define LargeIntegerGreaterThanZero(X) (       \
    (((X).HighPart == 0) && ((X).LowPart > 0)) || \
    ((X).HighPart > 0 )                           \
)

#define LargeIntegerGreaterOrEqualToZero(X) ( \
    (X).HighPart >= 0                            \
)

#define LargeIntegerEqualToZero(X) ( \
    !((X).LowPart | (X).HighPart)       \
)

#define LargeIntegerNotEqualToZero(X) ( \
    ((X).LowPart | (X).HighPart)           \
)

#define LargeIntegerLessThanZero(X) ( \
    ((X).HighPart < 0)                   \
)

#define LargeIntegerLessOrEqualToZero(X) (           \
    ((X).HighPart < 0) || !((X).LowPart | (X).HighPart) \
)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\linkhash.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash tables with LRU threading 

File: LinkHash.cpp

Owner: DGottner

This is the Link list and Hash table for use by any classes which
also need LRU access to items. (This includes cache manager,
script manager, and session deletion code)
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "LinkHash.h"
#include "memchk.h"



/*------------------------------------------------------------------
 * C L i n k H a s h
 */

/*===================================================================
CLinkHash::CLinkHash

Constructor for CLinkHash

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CLinkHash::CLinkHash( HashFunction pfnHash )
    : CHashTable( pfnHash )
{
}

/*===================================================================
CLinkHash::AddElem

Parameters:
    pElem - item to add to the table.  The item is marked as the most
            recently accessed.

Returns:
    Returns a pointer to the item added
===================================================================*/

CLruLinkElem *CLinkHash::AddElem(CLruLinkElem *pElem, BOOL fTestDups)
    {
    AssertValid();

    CLruLinkElem *pElemAdded = static_cast<CLruLinkElem *>(CHashTable::AddElem(pElem, fTestDups));
    pElemAdded->PrependTo(m_lruHead);

    AssertValid();
    return pElemAdded;
    }



/*===================================================================
CLinkHash::FindElem

Parameters:
    pvKey - pointer to the key to insert
    cbKey - number of bytes in the key

Returns:
    NULL if the key is not in the hash table, otherwise it returns
    a pointer to the key's record.  If the key is found, it is
    moved to the front of the list.
===================================================================*/

CLruLinkElem *CLinkHash::FindElem(const void *pvKey, int cbKey)
    {
    AssertValid();

    CLruLinkElem *pElemFound = static_cast<CLruLinkElem *>(CHashTable::FindElem(pvKey, cbKey));
    if (pElemFound)
        {
        pElemFound->PrependTo(m_lruHead);
        AssertValid();
        }

    return pElemFound;
    }



/*===================================================================
CLinkHash::DeleteElem

Parameters:
    pvKey - pointer to the key to delete
    cbKey - number of bytes in the key

Returns:
    NULL if the key is not in the hash table, otherwise it returns
    a pointer to the key's record.  If the key is found, it is
    removed from the hash table and the LRU list.
===================================================================*/

CLruLinkElem *CLinkHash::DeleteElem(const void *pvKey, int cbKey)
    {
    AssertValid();

    CLruLinkElem *pElemFound = static_cast<CLruLinkElem *>(CHashTable::DeleteElem(pvKey, cbKey));
    if (pElemFound)
        pElemFound->UnLink();

    AssertValid();
    return pElemFound;
    }



/*===================================================================
CLinkHash::RemoveElem

Parameters:
    pvKey - pointer to the key to delete
    cbKey - number of bytes in the key

Returns:
    NULL if the key is not in the hash table, otherwise it returns
    a pointer to the key's record.  If the key is found, it is
    removed from the hash table and the LRU list.
===================================================================*/

CLruLinkElem *CLinkHash::RemoveElem(CLruLinkElem *pElem)
    {
    AssertValid();

    CLruLinkElem *pElemRemoved = static_cast<CLruLinkElem *>(CHashTable::RemoveElem(pElem));

    Assert (pElemRemoved);
    pElemRemoved->UnLink();

    AssertValid();
    return pElemRemoved;
    }



/*===================================================================
CLinkHash::AssertValid

verify the integrity of the data structure
===================================================================*/

#ifdef DBG
void CLinkHash::AssertValid() const
    {
    // NOTE: avoid calling CHashTable::AssertValid as long as hash table primitives are calling it.
    //  CHashTable::AssertValid();

    m_lruHead.AssertValid();
    for (CDblLink *pLink = m_lruHead.PNext(); pLink != &m_lruHead; pLink = pLink->PNext())
        pLink->AssertValid();
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\hitobj.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hit Object

File: Hitobj.h

Owner: PramodD

This is the Hit Object header file.
===================================================================*/
#ifndef HITOBJ_H
#define HITOBJ_H

#include "Compcol.h"
#include "Sessmgr.h"
#include "Applmgr.h"
#include "Context.h"
#include "Resource.h"
#include "exec.h"
#include "glob.h"
#include "memcls.h"
#include "txnsupp.h"
#include "gip.h"

#define hNil            (HANDLE)0
#define SESSIONID_LEN   24

// HitObj type
#define EHitType                DWORD
#define ehtUnInitedRequest      0x00000000
#define ehtBrowserRequest       0x00000001
#define ehtSessionCleanup       0x00000002
#define ehtApplicationCleanup   0x00000004

// Execution status (result)
#define EExecStatus             DWORD
#define eExecFailed             0x00000000
#define eExecSucceeded          0x00000001
#define eExecTimedOut           0x00000002

// Current execution state
#define EEventState             DWORD
#define eEventNone              0x00000000
#define eEventAppOnStart        0x00000001
#define eEventSesOnStart        0x00000002
#define eEventAppOnEnd          0x00000004
#define eEventSesOnEnd          0x00000008

// Global interface table
extern IGlobalInterfaceTable *g_pGIT;

/*===================================================================
  C H i t O b j
  
The Hit Manager runs in the context of an IIS thread.
It packages up a request, calls Viper async. and 
on callback executes the request
===================================================================*/

class CHitObj
    {
private:
    // Flags and other bit-fields
    DWORD m_fInited : 1;                // Are we initialized?
    DWORD m_fRunGlobalAsa : 1;          // Should we run global.asa
    DWORD m_fStartSession : 1;          // New session
    DWORD m_fNewCookie : 1;             // Is New session cookie?
    DWORD m_fStartApplication : 1;      // New application
    DWORD m_fClientCodeDebug : 1;       // Client code debug enabled?
    DWORD m_fApplnOnStartFailed : 1;    // Application_OnStart failed
    DWORD m_fCompilationFailed : 1;     // Script Compilation error?
    DWORD m_fExecuting : 1;             // Currently inside Viper callback
    DWORD m_fHideRequestAndResponseIntrinsics : 1;  // TRUE while instrinsics are hidden
    DWORD m_fHideSessionIntrinsic : 1;  // TRUE if session intrinsic's hidden
    DWORD m_fDoneWithSession : 1;       // TRUE after DONE_WITH_SESSION
    DWORD m_fRejected : 1;              // TRUE if rejected (not posted)
    DWORD m_f449Done : 1;               // 449 processing done for this request
    DWORD m_fInTransferOnError : 1;     // doing transfer on error (to break infinite)
    DWORD m_fSecure : 1;                // Secure Connection

    EHitType    m_ehtType : 4;          // Type of the request
    EExecStatus m_eExecStatus : 4;      // Error Status // for Perf Counter only
    EEventState m_eEventState : 4;      // Current Event
    CompScope   m_ecsActivityScope : 4; // Which activity running this request?

    // Intrinsics set from inside HitObj
    CSession  *m_pSession;
    CAppln    *m_pAppln;
    CResponse *m_pResponse;
    CRequest  *m_pRequest;
    CServer   *m_pServer;

    // IsapiReqInfo

    CIsapiReqInfo   *m_pIReq;

    // Intrinsics set from outside HitObj (to be ref. counted)
    IUnknown *m_punkScriptingNamespace;
    DWORD m_dwObjectContextCookie;

    // Component collection of extrinsic objects
    CComponentCollection  *m_pPageCompCol;
    CPageComponentManager *m_pPageObjMgr;

    // Impersonation handle
    HANDLE m_hImpersonate;

    // Viper page-level activity (if no session)
    CViperActivity *m_pActivity;

    // Current session info
    char        m_szSessionCookie[SESSIONID_LEN+4]; // +4 to keep DWORD boundary
    CSessionId  m_SessionId;

    // Context object (for OnStartPage)
    CScriptingContext * m_pScriptingContext;

    // Misc
    long                m_nScriptTimeout;   // Maximum number of seconds script should run
    UINT                m_uCodePage;        // RunTime CodePage
    LCID                m_lcid;             // RunTime LCID
    ActiveEngineInfo   *m_pEngineInfo;      // List of active engines for this hit objext
    IDispatch          *m_pdispTypeLibWrapper;  // Page-level typelib wrapper
    DWORD               m_dwtTimestamp;     // Timestamp for wait time and perf calcs

    // Used to reffer to the current template during the compilation
    TCHAR              *m_szCurrTemplatePhysPath;
    TCHAR              *m_szCurrTemplateVirtPath;

    // ASP Error object
    IASPError          *m_pASPError;

    // Store a pointer to the associated template so as to avoid redundant
    // FindTemplate calls.
    
    CTemplate          *m_pTemplate;

    // Private interfaces
    HRESULT             ParseCookiesForSessionIdAndFlags();
    // Request rejection logic
    HRESULT             RejectBrowserRequestWhenNeeded(DWORD dwtQueueWaitTime, BOOL *pfRejected);


// Public Interfaces
public: 
                        CHitObj();
    virtual             ~CHitObj();

    static HRESULT      NewBrowserRequest(CIsapiReqInfo   *pIReq, 
                                          BOOL *pfRejected = NULL, 
                                          BOOL *pfCompleted = NULL,
                                          int  *piErrorId  = NULL);
                                          
    HRESULT             BrowserRequestInit(CIsapiReqInfo   *pIReq, int * dwId);
    HRESULT             AssignApplnToBrowserRequest(BOOL *pfApplnRestarting);
    HRESULT             AssignSessionToBrowserRequest(BOOL *pfNewSession, BOOL *pfNewCookie, int *pErrorId);
    HRESULT             DetachBrowserRequestFromSession();
    HRESULT             ReassignAbandonedSession();
    
    void                SessionCleanupInit(CSession *pSession);
    void                ApplicationCleanupInit(CAppln *pAppln);
    
    BOOL                SendHeader(const char *szStatus);
    BOOL                SendError(const char *szError);
    
    TCHAR*              GetSzAppPhysicalPath(void);
    void                ApplnOnStartFailed();
    void                SessionOnStartFailed();
    void                SessionOnStartInvoked();
    void                SessionOnEndPresent();
    void                SetEventState(EEventState eEvent);
    EEventState         EventState();

    // Report server error without response object
    HRESULT ReportServerError(UINT ErrorId);

// Component Collection Interfaces

    HRESULT InitComponentProcessing();
    HRESULT StopComponentProcessing();
    
    HRESULT GetPageComponentCollection(CComponentCollection **ppCollection);
    HRESULT GetSessionComponentCollection(CComponentCollection **ppCollection);
    HRESULT GetApplnComponentCollection(CComponentCollection **ppCollection);

    HRESULT AddComponent(CompType type, const CLSID &clsid, CompScope scope,
                         CompModel model, LPWSTR pwszName = NULL,
                         IUnknown *pUnk = NULL);
    HRESULT GetComponent(CompScope scope, LPWSTR pwszName, DWORD cbName,
                         CComponentObject **ppObj);
    HRESULT GetIntrinsic(LPWSTR pwszName, DWORD cbName, IUnknown **ppUnk);
    HRESULT CreateComponent(const CLSID &clsid, IDispatch **ppDisp);
    HRESULT SetPropertyComponent(CompScope scope, LPWSTR pwszName,
                          VARIANT *pVariant);
    HRESULT GetPropertyComponent(CompScope scope, LPWSTR pwszName,
                        CComponentObject **ppObj);

// Viper Integration

    CViperActivity *PActivity();
    CViperActivity *PCurrentActivity();
    HRESULT SetActivity(CViperActivity *pActivity);

    HRESULT PostViperAsyncCall();
    HRESULT ViperAsyncCallback(BOOL *pfRePosted);

// Execute / Transfer

    HRESULT ExecuteChildRequest(BOOL fTransfer, TCHAR *szTemplate, TCHAR *szVirtTemplate);

    HRESULT     GetASPError(IASPError **ppASPError);
    inline void SetASPError(IASPError *pASPError);
    inline BOOL FHasASPError();
    
// inline functions
public:
    CIsapiReqInfo      *PIReq();
    HANDLE              HImpersonate();
    CResponse *         PResponse();
    CRequest *          PRequest();
    CServer *           PServer();
    CAppln *            PAppln();
    CSession *          PSession();
    CPageComponentManager * PPageComponentManager();
    BOOL                FIsBrowserRequest() const;
    BOOL                FIsSessionCleanupRequest() const;
    BOOL                FIsApplnCleanupRequest() const;
    BOOL                FIsValidRequestType() const;
    const char *        PSzNewSessionCookie() const;
    DWORD               SessionId() const;
    CScriptingContext * PScriptingContextGet();
    BOOL                FStartApplication();
    BOOL                FStartSession();
    BOOL                FNewCookie();
    BOOL                FObjectTag(IDispatch * pDispatch);
    BOOL                FHasSession();
    BOOL                FClientCodeDebug();
    BOOL                FDoneWithSession();
    BOOL                FExecuting();
    BOOL                F449Done();
    BOOL                FInTransferOnError();
    BOOL                FSecure();

    void                SetScriptTimeout(long nScriptTimeout);
    long                GetScriptTimeout();
    void                SetExecStatus(EExecStatus status);
    EExecStatus         ExecStatus();
    void                SetActiveEngineInfo(ActiveEngineInfo *);
    void                SetCompilationFailed();
    void                SetDoneWithSession();
    void                Set449Done();
    void                SetInTransferOnError();
    
    TCHAR *             GlobalAspPath();
    HRESULT             SetCodePage(UINT uCodePage);    // Proxy function, CodePage is stored in m_pSession
    UINT                GetCodePage();                  // same as above
    HRESULT             SetLCID(LCID lcid);             // Proxy function, LCID is stored in m_pSession
    LCID                GetLCID();                  // same as above

    CAppConfig *        QueryAppConfig();

    TCHAR *              PSzCurrTemplatePhysPath();
    TCHAR *              PSzCurrTemplateVirtPath();
    DWORD               DWInstanceID();

    CTemplate          *GetTemplate();
    void                SetTemplate(CTemplate *);

    // Instead of add/remove to/from component collection use these:
    void HideRequestAndResponseIntrinsics();
    void UnHideRequestAndResponseIntrinsics();
    BOOL FRequestAndResponseIntrinsicsHidden();
    void AddScriptingNamespace(IUnknown *punkNamespace);
    void RemoveScriptingNamespace();
    void AddObjectContext(IASPObjectContext *pASPObjContext);
    void RemoveObjectContext();
    void UseObjectContext(IASPObjectContext **ppASPObjContext);

    // Typelib wrapper support
    IDispatch *PTypeLibWrapper();
    void SetTypeLibWrapper(IDispatch *pdisp);

    // Timestamp manipulation
    void  UpdateTimestamp();
    DWORD ElapsedTimeSinceTimestamp();

#ifdef DBG
    virtual void AssertValid() const;
#else
    virtual void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*===================================================================
  CHitObj inlines
===================================================================*/

inline CIsapiReqInfo   *CHitObj::PIReq()
    {
    return m_pIReq; 
    }
    
inline BOOL CHitObj::FIsBrowserRequest() const
    {
    return (m_ehtType == ehtBrowserRequest);
    }

inline BOOL CHitObj::FIsSessionCleanupRequest() const
    {
    return (m_ehtType == ehtSessionCleanup);
    }
    
inline BOOL CHitObj::FIsApplnCleanupRequest() const
    {
    return (m_ehtType == ehtApplicationCleanup);
    }

inline BOOL CHitObj::FIsValidRequestType() const
    {
    return (FIsBrowserRequest() || 
            FIsSessionCleanupRequest() ||
            FIsApplnCleanupRequest());
    }
    
inline HANDLE CHitObj::HImpersonate()
    {
    return m_hImpersonate; 
    }

inline DWORD CHitObj::SessionId() const 
    {
    return m_SessionId.m_dwId; 
    }

inline const char *CHitObj::PSzNewSessionCookie() const 
    {
    return (m_fNewCookie ? m_szSessionCookie : NULL); 
    }

inline BOOL CHitObj::FStartApplication()
    {
    return m_fStartApplication; 
    }

inline BOOL CHitObj::FStartSession()
    {
    return m_fStartSession; 
    }

inline BOOL CHitObj::FNewCookie() 
    {
    return m_fNewCookie; 
    }

inline BOOL CHitObj::FHasSession()
    {
    return (m_pSession != NULL && !m_fHideSessionIntrinsic);
    }

inline BOOL CHitObj::FClientCodeDebug()
    {
    return m_fClientCodeDebug;
    }

inline BOOL CHitObj::FDoneWithSession()
    {
    return m_fDoneWithSession;
    }

inline BOOL CHitObj::FExecuting()
    {
    return m_fExecuting;
    }

inline BOOL CHitObj::F449Done()
    {
    return m_f449Done;
    }

inline BOOL CHitObj::FInTransferOnError()
    {
    return m_fInTransferOnError;
    }

inline BOOL CHitObj::FSecure()
    {
    return m_fSecure;
    }

inline void CHitObj::SessionOnStartFailed() 
    {
    Assert(m_pSession);
    m_pSession->SetOnStartFailedFlag();
    }
    
inline void CHitObj::ApplnOnStartFailed() 
    {
    m_fApplnOnStartFailed = TRUE;
    
    if (m_pSession)
        SessionOnStartFailed();
    }
    
inline void CHitObj::SessionOnStartInvoked()
    {
    Assert(m_pSession); 
    m_pSession->SetOnStartInvokedFlag(); 
    }

inline void CHitObj::SessionOnEndPresent()
    {
    Assert(m_pSession); 
    m_pSession->SetOnEndPresentFlag(); 
    }

inline DWORD CHitObj::DWInstanceID()
    {
    return (m_pIReq) ? m_pIReq->QueryInstanceId() : 0;
    }

inline CViperActivity *CHitObj::PActivity()
    {
    return m_pActivity; 
    }
    
inline CScriptingContext *CHitObj::PScriptingContextGet()
    {
    return m_pScriptingContext; 
    }
    
inline CResponse *CHitObj::PResponse()
    {
    return m_pResponse; 
    }

inline CRequest *CHitObj::PRequest()
    {
    return m_pRequest; 
    }

inline CServer *CHitObj::PServer()
    {
    return m_pServer; 
    }

inline CAppln *CHitObj::PAppln()
    {
    return m_pAppln;
    }

inline CSession *CHitObj::PSession()
    {
    return m_pSession;
    }

inline CPageComponentManager *CHitObj::PPageComponentManager()
    {
    return m_pPageObjMgr;
    }

inline TCHAR *CHitObj::GlobalAspPath()
    {
    if ( m_fRunGlobalAsa )
        return m_pAppln->GetGlobalAsa();
    else
        return NULL;
    }

inline void CHitObj::SetScriptTimeout(long nScriptTimeout)
    {
    m_nScriptTimeout = nScriptTimeout; 
    }
    
inline long CHitObj::GetScriptTimeout()
    {
    return m_nScriptTimeout; 
    }

inline void CHitObj::SetExecStatus(EExecStatus status)
    {
    m_eExecStatus = status;
    }
    
inline EExecStatus CHitObj::ExecStatus()
    {
    return m_eExecStatus;
    }
    
inline EEventState CHitObj::EventState()
    {
    return m_eEventState;
    }

inline void CHitObj::SetEventState(EEventState eState)
    {
    m_eEventState = eState;
    }

inline CAppConfig * CHitObj::QueryAppConfig(void)
    {
    return m_pAppln->QueryAppConfig();
    }
    
inline UINT CHitObj::GetCodePage(void)
    {
    return m_uCodePage;
    }

inline LCID CHitObj::GetLCID()
    {
    return m_lcid;
    }

inline  VOID CHitObj::SetActiveEngineInfo(ActiveEngineInfo *pActiveEngineInfo)
    {
    m_pEngineInfo = pActiveEngineInfo;
    }

inline void CHitObj::SetCompilationFailed()
    {
    m_fCompilationFailed = TRUE;
    }

inline void CHitObj::SetDoneWithSession()
    {
    Assert(!m_fDoneWithSession);
    m_fDoneWithSession = TRUE;
    }

inline void CHitObj::Set449Done()
    {
    Assert(!m_f449Done);
    m_f449Done = TRUE;
    }

inline void CHitObj::SetInTransferOnError()
    {
    Assert(!m_fInTransferOnError);
    m_fInTransferOnError = TRUE;
    }

inline void CHitObj::HideRequestAndResponseIntrinsics()
    {
    m_fHideRequestAndResponseIntrinsics = TRUE;
    }
    
inline void CHitObj::UnHideRequestAndResponseIntrinsics()
    {
    m_fHideRequestAndResponseIntrinsics = FALSE;
    }

inline BOOL CHitObj::FRequestAndResponseIntrinsicsHidden()
    {
    return m_fHideRequestAndResponseIntrinsics;
    }

inline void CHitObj::AddScriptingNamespace(IUnknown *punkNamespace)
    {
    Assert(m_punkScriptingNamespace == NULL);
    Assert(punkNamespace);
    m_punkScriptingNamespace = punkNamespace;
    m_punkScriptingNamespace->AddRef();
    }
    
inline void CHitObj::RemoveScriptingNamespace()
    {
    if (m_punkScriptingNamespace)
        {
        m_punkScriptingNamespace->Release();
        m_punkScriptingNamespace = NULL;
        }
    }
    
inline IDispatch *CHitObj::PTypeLibWrapper()
    {
    return m_pdispTypeLibWrapper;
    }
    
inline void CHitObj::SetTypeLibWrapper(IDispatch *pdisp)
    {
    if (m_pdispTypeLibWrapper)
        m_pdispTypeLibWrapper->Release();
        
    m_pdispTypeLibWrapper = pdisp;
    
    if (m_pdispTypeLibWrapper)
        m_pdispTypeLibWrapper->AddRef();
    }

inline void CHitObj::UpdateTimestamp() 
    {
    m_dwtTimestamp = GetTickCount();
    }
    
inline DWORD CHitObj::ElapsedTimeSinceTimestamp() 
    {
    DWORD dwt = GetTickCount();
    if (dwt >= m_dwtTimestamp)
        return (dwt - m_dwtTimestamp);
    else
        return ((0xffffffff - m_dwtTimestamp) + dwt);
    }

inline TCHAR *CHitObj::PSzCurrTemplatePhysPath()
    {
    if (m_szCurrTemplatePhysPath != NULL) 
        return m_szCurrTemplatePhysPath;
    else if (m_pIReq != NULL)
        return m_pIReq->QueryPszPathTranslated();
    else
        return NULL;
    }
    
inline TCHAR *CHitObj::PSzCurrTemplateVirtPath()
    {
    if (m_szCurrTemplateVirtPath != NULL) 
        return m_szCurrTemplateVirtPath;
    else if (m_pIReq != NULL)
        return m_pIReq->QueryPszPathInfo();
    else
        return NULL;
    }

inline void CHitObj::SetASPError(IASPError *pASPError)
    {
    if (m_pASPError)
        m_pASPError->Release();
    m_pASPError = pASPError;  // passed addref'd
    }

inline BOOL CHitObj::FHasASPError()
    {
    return (m_pASPError != NULL);
    }

inline CTemplate *CHitObj::GetTemplate()
    {
    return m_pTemplate;
    }

inline void CHitObj::SetTemplate(CTemplate *pTemplate)
{
    m_pTemplate = pTemplate;
}

/*===================================================================
  Globals
===================================================================*/

extern DWORD g_nBrowserRequests;
extern DWORD g_nSessionCleanupRequests;
extern DWORD g_nApplnCleanupRequests;


#undef  SCRIPT_STATS

#ifdef SCRIPT_STATS
# include <locks.h>

void
ReadRegistrySettings();

extern CSmallSpinLock g_lockRequestStats;
extern DWORD          g_dwQueueDebugThreshold;
extern DWORD          g_fSendScriptlessOnAtqThread;
extern LONG           g_cRequests;
extern LONG           g_cScriptlessRequests;
extern LONG           g_cHttpExtensionsExecuting;
extern LONG           g_cConcurrentScriptlessRequests;
extern LONG           g_cMaxConcurrentScriptlessRequests;
extern LONGLONG       g_nSumConcurrentScriptlessRequests;
extern LONGLONG       g_nSumExecTimeScriptlessRequests;
extern LONG           g_nAvgConcurrentScriptlessRequests;
extern LONG           g_nAvgExecTimeScriptlessRequests;
#endif // SCRIPT_STATS

#endif // HITOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\linkhash.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash table for Script Manager

File: LinkHash.h

Owner: DGottner

This is the Link list and Hash table for use by any classes which
also need LRU access to items. (This includes cache manager,
script manager, and session deletion code)
===================================================================*/

#ifndef LINKHASH_H
#define LINKHASH_H

#include "hashing.h"
#include "DblLink.h"



/* C L r u L i n k E l e m
 *
 * CLruLink is a CLinkElem with extra links to maintain a circular LRU queue
 *
 * NOTE: Both the CLinkElem list and the CDblLink lists are intrusive.
 *       therefore, we need to use multiple inheritance to make sure that
 *       downcasts from CLruLinkElem will work on both CLinkElem pointers
 *       and CDblLink pointers.  See the ARM, p. 221
 */

class CLruLinkElem : public CLinkElem, public CDblLink
	{
	};



/*
 * C L i n k H a s h
 *
 * CLinkHash differs from CHashTable in that it maintains some extra pointers to
 * maintain a threaded lru queue.
 */

class CLinkHash : public CHashTable
	{
public:
	CLinkHash(HashFunction = DefaultHash);
	
	CLruLinkElem *AddElem(CLruLinkElem *pElem, BOOL fTestDups = TRUE);
	CLruLinkElem *FindElem(const void *pvKey, int cbKeyLen);
	CLruLinkElem *DeleteElem(const void *pvKey, int cbKeyLen);
	CLruLinkElem *RemoveElem(CLruLinkElem *pElem);

	// you CANNOT compare LRU nodes to NULL to know if you are at the end
	// of the list!  Instead use this member.
	//
	BOOL FLruElemIsEmpty(CLruLinkElem *pElem)
		{
		pElem->AssertValid();
		return pElem == &m_lruHead;
		}

	CLruLinkElem *Begin()		// return pointer to last referenced item
		{
		return static_cast<CLruLinkElem *>(m_lruHead.PNext());
		}

	CLruLinkElem *End()			// return pointer to least recently accessed item
		{
		return static_cast<CLruLinkElem *>(m_lruHead.PPrev());
		}

	void AssertValid() const;

protected:

	CDblLink	m_lruHead;
	};

#ifndef DBG
	inline void CLinkHash::AssertValid() const {}
#endif
	
#endif // LINKHASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\magic.h ===
#define SZ_MAGICKEY	"Denali rocks!"

void* xor(void* pData, const int cbData, const void* pKey, const int cbKey)
	{
	void*	pRet = pData;
	int		iKeyPos = 0;
	BYTE*	pbData = (BYTE*) pData;
	BYTE*	pbKey = (BYTE*) pKey;
	
	for(int i = 0; i < cbData; i++)
		{
		*pbData++ ^= *(pbKey + iKeyPos++);
		iKeyPos %= cbKey;
		}
	
	return pRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\idhash.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

File: idhash.cpp

Owner: DmitryR

Source file for the new hashing stuff
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "idhash.h"
#include "memcls.h"

#include "memchk.h"

/*===================================================================
  C  P t r  A r r a y
===================================================================*/

HRESULT CPtrArray::Insert
(
int iPos,
void *pv
)
    {
    if (!m_rgpvPtrs) // empty?
        {
        m_rgpvPtrs = (void **)malloc(m_dwInc * sizeof(void *));
        if (!m_rgpvPtrs)
            return E_OUTOFMEMORY;
        m_dwSize = m_dwInc;
        m_cPtrs = 0;
        }
    else if (m_cPtrs == m_dwSize) // full?
        {
        void **pNewPtrs = (void **)realloc
            (
            m_rgpvPtrs,
            (m_dwSize + m_dwInc) * sizeof(void *)
            );
        if (!pNewPtrs)
            return E_OUTOFMEMORY;
        m_rgpvPtrs = pNewPtrs;
        m_dwSize += m_dwInc;
        }

    if (iPos < 0)
        iPos = 0;
    if ((DWORD)iPos >= m_cPtrs) // append?
        {
        m_rgpvPtrs[m_cPtrs++] = pv;
        return S_OK;
        }

    memmove
        (
        &m_rgpvPtrs[iPos+1],
        &m_rgpvPtrs[iPos],
        (m_cPtrs-iPos) * sizeof(void *)
        );

    m_rgpvPtrs[iPos] = pv;
    m_cPtrs++;
    return S_OK;
    }

HRESULT CPtrArray::Find
(
void *pv,
int *piPos
)
    const
    {
    Assert(piPos);

    for (DWORD i = 0; i < m_cPtrs; i++)
        {
        if (m_rgpvPtrs[i] == pv)
            {
            *piPos = i;
            return S_OK;
            }
        }

     // not found
    *piPos = -1;
    return S_FALSE;
    }

HRESULT CPtrArray::Remove
(
void *pv
)
    {
    HRESULT hr = S_FALSE;

    for (DWORD i = 0; i < m_cPtrs; i++)
        {
        if (m_rgpvPtrs[i] == pv)
            hr = Remove(i);
        }

    return hr;
    }

HRESULT CPtrArray::Remove
(
int iPos
)
    {
    Assert(iPos >= 0 && (DWORD)iPos < m_cPtrs);
    Assert(m_rgpvPtrs);

    // remove the element
    DWORD dwMoveSize = (m_cPtrs - iPos - 1) * sizeof(void *);
    if (dwMoveSize)
        memmove(&m_rgpvPtrs[iPos], &m_rgpvPtrs[iPos+1], dwMoveSize);
    m_cPtrs--;

    if (m_dwSize > 4*m_dwInc && m_dwSize > 8*m_cPtrs)
        {
        // collapse to 1/4 if size > 4 x increment and less < 1/8 full

        void **pNewPtrs = (void **)realloc
            (
            m_rgpvPtrs,
            (m_dwSize / 4) * sizeof(void *)
            );

        if (pNewPtrs)
            {
            m_rgpvPtrs = pNewPtrs;
            m_dwSize /= 4;
            }
        }

    return S_OK;
    }

HRESULT CPtrArray::Clear()
    {
    if (m_rgpvPtrs)
        free(m_rgpvPtrs);

    m_dwSize = 0;
    m_rgpvPtrs = NULL;
    m_cPtrs = 0;
    return S_OK;
    }

/*===================================================================
  C  I d  H a s h  U n i t
===================================================================*/

// Everything is inline for this structure. See the header file.

/*===================================================================
  C  I d  H a s h  A r r a y
===================================================================*/

/*===================================================================
For some hardcoded element counts (that relate to session hash),
ACACHE is used for allocations
This is wrapped in the two functions below.
===================================================================*/
ACACHE_FSA_EXTERN(MemBlock128)
ACACHE_FSA_EXTERN(MemBlock256)
static inline void *AcacheAllocIdHashArray(DWORD cElems)
    {
/* removed because in 64bit land it doesn't work because of padding
    void *pvMem;
    if      (cElems == 13) { pvMem = ACACHE_FSA_ALLOC(MemBlock128); }
    else if (cElems == 31) { pvMem = ACACHE_FSA_ALLOC(MemBlock256); }
   else { pvMem = malloc(2*sizeof(USHORT) + cElems*sizeof(CIdHashElem)); }
*/

    return malloc(offsetof(CIdHashArray, m_rgElems) + cElems*sizeof(CIdHashElem));
    }

static inline void AcacheFreeIdHashArray(CIdHashArray *pArray)
    {
/* removed because in 64bit land it doesn't work because of padding
    if (pArray->m_cElems == 13)      { ACACHE_FSA_FREE(MemBlock128, pArray); }
    else if (pArray->m_cElems == 31) { ACACHE_FSA_FREE(MemBlock256, pArray); }
    else                             { free(pArray); }
*/
    free(pArray);
    }

/*===================================================================
CIdHashArray::Alloc

Static method.
Allocates CIdHashArray as a memory block containing var length array.

Parameters:
    cElems          # of elements in the array

Returns:
    Newly created CIdHashArray
===================================================================*/
CIdHashArray *CIdHashArray::Alloc
(
DWORD cElems
)
    {
    CIdHashArray *pArray = (CIdHashArray *)AcacheAllocIdHashArray(cElems);
    if (!pArray)
        return NULL;

    pArray->m_cElems = (USHORT)cElems;
    pArray->m_cNotNulls = 0;
    memset(&(pArray->m_rgElems[0]), 0, cElems * sizeof(CIdHashElem));
    return pArray;
    }

/*===================================================================
CIdHashArray::Alloc

Static method.
Frees allocated CIdHashArray as a memory block.
Also frees any sub-arrays.

Parameters:
    pArray          CIdHashArray object to be freed

Returns:
===================================================================*/
void CIdHashArray::Free
(
CIdHashArray *pArray
)
    {
    if (pArray->m_cNotNulls > 0)
        {
        for (DWORD i = 0; i < pArray->m_cElems; i++)
            {
            if (pArray->m_rgElems[i].FIsArray())
                Free(pArray->m_rgElems[i].PArray());
            }
        }

    AcacheFreeIdHashArray(pArray);
    }

/*===================================================================
CIdHashArray::Find

Searches this array and any sub-arrays for an objects with the
given id.

Parameters:
    dwId            id to look for
    ppvObj          object found (if any)

Returns:
    S_OK = found, S_FALSE = not found
===================================================================*/
HRESULT CIdHashArray::Find
(
DWORD_PTR dwId,
void **ppvObj
)
    const
    {
    DWORD i = (DWORD)(dwId % m_cElems);

    if (m_rgElems[i].DWId() == dwId)
        {
        if (ppvObj)
            *ppvObj = m_rgElems[i].PObject();
        return S_OK;
        }

    if (m_rgElems[i].FIsArray())
        return m_rgElems[i].PArray()->Find(dwId, ppvObj);

    // Not found
    if (ppvObj)
        *ppvObj = NULL;
    return S_FALSE;
    }

/*===================================================================
CIdHashArray::Add

Adds an object to this (or sub-) array by Id.
Creates new sub-arrays as needed.

Parameters:
    dwId            object id
    pvObj           object to add
    rgusSizes       array of sizes (used when creating sub-arrays)

Returns:
    HRESULT (S_OK = added)
===================================================================*/
HRESULT CIdHashArray::Add
(
DWORD_PTR dwId,
void *pvObj,
USHORT *rgusSizes
)
{
    DWORD i = (DWORD)(dwId % m_cElems);

    if (m_rgElems[i].FIsEmpty()) {
        m_rgElems[i].SetToObject(dwId, pvObj);
        m_cNotNulls++;
        return S_OK;
    }

    // Advance array of sizes one level deeper
    if (rgusSizes[0]) // not at the end
        ++rgusSizes;

    if (m_rgElems[i].FIsObject()) {

        // this array logic can't handle adding the same ID twice.  It will
        // loop endlessly.  So, if an attempt is made to add the same
        // ID a second, return an error
        if (m_rgElems[i].DWId() == dwId) {
            return E_INVALIDARG;
        }

        // Old object already taken the slot - need to create new array
        // the size of first for three levels is predefined
        // increment by 1 thereafter
        CIdHashArray *pArray = Alloc (rgusSizes[0] ? rgusSizes[0] : m_cElems+1);
        if (!pArray)
            return E_OUTOFMEMORY;

        // Push the old object down into the array
        HRESULT hr = pArray->Add(m_rgElems[i].DWId(),
                                 m_rgElems[i].PObject(),
                                 rgusSizes);
        if (FAILED(hr))
            return hr;

        // Put array into slot
        m_rgElems[i].SetToArray(pArray);
    }

    Assert(m_rgElems[i].FIsArray());
    return m_rgElems[i].PArray()->Add(dwId, pvObj, rgusSizes);
}

/*===================================================================
CIdHashArray::Remove

Removes an object by id from this (or sub-) array.
Removes empty sub-arrays.

Parameters:
    dwId            object id
    ppvObj          object removed (out, optional)

Returns:
    HRESULT (S_OK = removed, S_FALSE = not found)
===================================================================*/
HRESULT CIdHashArray::Remove
(
DWORD_PTR dwId,
void **ppvObj
)
    {
    DWORD i = (DWORD)(dwId % m_cElems);

    if (m_rgElems[i].DWId() == dwId)
        {
        if (ppvObj)
            *ppvObj = m_rgElems[i].PObject();
        m_rgElems[i].SetToEmpty();
        m_cNotNulls--;
        return S_OK;
        }

    if (m_rgElems[i].FIsArray())
        {
        HRESULT hr = m_rgElems[i].PArray()->Remove(dwId, ppvObj);
        if (hr == S_OK && m_rgElems[i].PArray()->m_cNotNulls == 0)
            {
            Free(m_rgElems[i].PArray());
            m_rgElems[i].SetToEmpty();
            }
        return hr;
        }

    // Not found
    if (ppvObj)
        *ppvObj = NULL;
    return S_FALSE;
    }

/*===================================================================
CIdHashArray::Iterate

Calls a supplied callback for each object in the array and sub-arrays.

Parameters:
    pfnCB               callback
    pvArg1, pvArg2      args to path to the callback

Returns:
    IteratorCallbackCode  what to do next?
===================================================================*/
IteratorCallbackCode CIdHashArray::Iterate
(
PFNIDHASHCB pfnCB,
void *pvArg1,
void *pvArg2
)
    {
    IteratorCallbackCode rc = iccContinue;

    for (DWORD i = 0; i < m_cElems; i++)
        {
        if (m_rgElems[i].FIsObject())
            {
            rc = (*pfnCB)(m_rgElems[i].PObject(), pvArg1, pvArg2);

            // remove if requested
            if (rc & (iccRemoveAndContinue|iccRemoveAndStop))
                {
                m_rgElems[i].SetToEmpty();
                m_cNotNulls--;
                }
            }
        else if (m_rgElems[i].FIsArray())
            {
            rc = m_rgElems[i].PArray()->Iterate(pfnCB, pvArg1, pvArg2);

            // remove sub-array if empty
            if (m_rgElems[i].PArray()->m_cNotNulls == 0)
                {
                Free(m_rgElems[i].PArray());
                m_rgElems[i].SetToEmpty();
                }
            }
        else
            {
            continue;
            }

        // stop if requested
        if (rc & (iccStop|iccRemoveAndStop))
            {
            rc = iccStop;
            break;
            }
        }

    return rc;
    }

#ifdef DBG
/*===================================================================
CIdHashTable::Dump

Dump hash table to a file (for debugging).

Parameters:
    szFile      file name where to dump

Returns:
===================================================================*/
void CIdHashArray::DumpStats
(
FILE *f,
int   nVerbose,
DWORD iLevel,
DWORD &cElems,
DWORD &cSlots,
DWORD &cArrays,
DWORD &cDepth
)
    const
    {
    if (nVerbose > 0)
        {
        for (DWORD t = 0; t < iLevel; t++) fprintf(f, "\t");
        fprintf(f, "Array (level=%d addr=%p) %d slots, %d not null:\n",
            iLevel, this, m_cElems, m_cNotNulls);
        }

    cSlots += m_cElems;
    cArrays++;

    if (iLevel > cDepth)
        cDepth = iLevel;

    for (DWORD i = 0; i < m_cElems; i++)
        {
        if (nVerbose > 1)
            {
            for (DWORD t = 0; t < iLevel; t++) fprintf(f, "\t");
            fprintf(f, "%[%08x:%p@%04d] ", m_rgElems[i].m_dw, m_rgElems[i].m_pv, i);
            }

        if (m_rgElems[i].FIsEmpty())
            {
            if (nVerbose > 1)
                fprintf(f, "NULL\n");
            }
        else if (m_rgElems[i].FIsObject())
            {
            if (nVerbose > 1)
                fprintf(f, "Object\n");
            cElems++;
            }
        else if (m_rgElems[i].FIsArray())
            {
            if (nVerbose > 1)
                fprintf(f, "Array:\n");
            m_rgElems[i].PArray()->DumpStats(f, nVerbose, iLevel+1,
                cElems, cSlots, cArrays, cDepth);
            }
        else
            {
            if (nVerbose > 1)
                fprintf(f, "BAD\n");
            }
        }
    }
#endif
/*===================================================================
  C  I d  H a s h  T a b l e
===================================================================*/

/*===================================================================
CIdHashTable::Init

Initialize id hash table. Does not allocate anything.

Parameters:
    usSize1         size of the first level array
    usSize2         size of the 2nd level arrays (optional)
    usSize3         size of the 3rd level arrays (optional)

Returns:
    S_OK
===================================================================*/
HRESULT CIdHashTable::Init
(
USHORT usSize1,
USHORT usSize2,
USHORT usSize3
)
    {
    Assert(!FInited());
    Assert(usSize1);

    m_rgusSizes[0] = usSize1;   // size of first level array
    m_rgusSizes[1] = usSize2 ? usSize2 : 7;
    m_rgusSizes[2] = usSize3 ? usSize3 : 11;
    m_rgusSizes[3] = 0;         // last one stays 0 to indicate
                                // the end of predefined sizes
    m_pArray = NULL;
    return S_OK;
    }

/*===================================================================
CIdHashTable::UnInit

Uninitialize id hash table. Frees all arrays.

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CIdHashTable::UnInit()
    {
    if (!FInited())
        {
        Assert(!m_pArray);
        return S_OK;
        }

    if (m_pArray)
        CIdHashArray::Free(m_pArray);

    m_pArray = NULL;
    m_rgusSizes[0] = 0;
    return S_OK;
    }

#ifdef DBG
/*===================================================================
CIdHashTable::AssertValid

Validates id hash table.

Parameters:

Returns:
===================================================================*/
void CIdHashTable::AssertValid() const
    {
    Assert(FInited());
    }

/*===================================================================
CIdHashTable::Dump

Dump hash table to a file (for debugging).

Parameters:
    szFile      file name where to dump

Returns:
===================================================================*/
void CIdHashTable::Dump
(
const char *szFile
)
    const
    {
    Assert(FInited());
    Assert(szFile);

    FILE *f = fopen(szFile, "a");
    if (!f)
        return;

    fprintf(f, "ID Hash Table Dump:\n");

    DWORD cElems = 0;
    DWORD cSlots = 0;
    DWORD cArrays = 0;
    DWORD cDepth = 0;

    if (m_pArray)
        m_pArray->DumpStats(f, 1, 1, cElems, cSlots, cArrays, cDepth);

    fprintf(f, "Total %d Objects in %d Slots, %d Arrays, %d Max Depth\n\n",
        cElems, cSlots, cArrays, cDepth);
    fclose(f);
    }
#endif

/*===================================================================
  C  H a s h  L o c k
===================================================================*/

/*===================================================================
CHashLock::Init

Initialize the critical section.

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CHashLock::Init()
    {
    Assert(!m_fInited);

    HRESULT hr;
    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
        return hr;

    m_fInited = TRUE;
    return S_OK;
    }

/*===================================================================
CHashLock::UnInit

Uninitialize the critical section.

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CHashLock::UnInit()
    {
    if (m_fInited)
        {
        DeleteCriticalSection(&m_csLock);
        m_fInited = FALSE;
        }
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\memchk.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Memory Management

File: Memchk.cpp

Owner: PramodD

TODO: restore the IIS5 debug heap wrappers

This is the Memory Manager source file
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "perfdata.h"
#include "memchk.h"

HANDLE g_hDenaliHeap = NULL;

/*===================================================================
int ::DenaliMemIsValid

Global function which validates an allocated memory pointer

Parameters:
	NONE

Returns:
	1		Valid pointer
	0		Invalid pointer
===================================================================*/
int DenaliMemIsValid( void * pvIn )
{
    return 1;
}

/*===================================================================
::DenaliMemInit

Initializes the memory manager

Parameters:
	const char *	szFile		Source file in which this was called
	int				lineno		The line number in the source file

Returns:
	S_OK on success
===================================================================*/
HRESULT DenaliMemInit( const char *szFile, int lineno )
{

    g_hDenaliHeap = ::HeapCreate( 0, 0, 0 );

	return S_OK;
}

/*===================================================================
void ::DenaliMemUnInit

Uninitializes the memory manager

Parameters:
	const char *	szFile		Source file in which this was called
	int				lineno		The line number in the source file

Returns:
	NONE
===================================================================*/
void DenaliMemUnInit( const char *szFile, int lineno )
{
    if (g_hDenaliHeap)
    {
        ::HeapDestroy(g_hDenaliHeap);
        g_hDenaliHeap = NULL;
    }
}

/*===================================================================
void ::DenaliLogCall

Writes source file and line number for log message to log file

Parameters:
	const char *	szLog		Log message
	const char *	szFile		Source file in which this was called
	int				lineno		The line number in the source file

Returns:
	NONE
===================================================================*/
void DenaliLogCall( const char * szLog, const char *szFile, int lineno )
{
    return;
}

/*===================================================================
void ::DenaliMemDiagnostics

Diagnostics for the memory manager

Parameters:
	const char *	szFile		Source file in which this was called
	int				lineno		The line number in the source file

Returns:
	NONE
===================================================================*/
void DenaliMemDiagnostics( const char *szFile, int lineno )
{
    return;
}


/*===================================================================
void * ::DenaliMemAlloc

Allocates a block of memory.

Parameters:
	size_t			cSize		Size in bytes to be allocated
	const char *	szFile		Source file in which function is called
	int				lineno		Line number at which function is called

Returns:
	NONE
===================================================================*/
void * DenaliMemAlloc( size_t cSize, const char *szFile, int lineno )
{
    return ::HeapAlloc( g_hDenaliHeap, 0, cSize );
}

/*===================================================================
void ::DenaliMemFree

Validates and frees a block of allocated memory.

Parameters:
	BYTE *			pIn			Pointer to free
	const char *	szFile		Source file in which function is called
	int				lineno		Line number at which function is called

Returns:
	NONE
===================================================================*/
void DenaliMemFree( void * pIn, const char *szFile, int lineno )
{
    ::HeapFree( g_hDenaliHeap, 0, pIn );
}


/*===================================================================
void * ::DenaliMemCalloc

Allocates and clears a block of memory.

Parameters:
	size_t			cNum		Number of elements to be allocated
	size_t			cbSize		Size in bytes of each element
	const char *	szFile		Source file in which function is called
	int				lineno		Line number at which function is called

Returns:
	NONE
===================================================================*/
void * DenaliMemCalloc(size_t cNum, size_t cbSize,
                       const char *szFile, int lineno )
{
    return ::HeapAlloc( g_hDenaliHeap, HEAP_ZERO_MEMORY, cNum * cbSize );
}


/*===================================================================
void ::DenaliMemReAlloc

Validates and frees a block of allocated memory.

Parameters:
	BYTE *			pIn			Pointer memory to ReAllocate
	size_t			cSize		Number of bytes to allocate
	const char *	szFile		Source file in which function is called
	int				lineno		Line number at which function is called

Returns:
	Pointer to allocated block
===================================================================*/
void * DenaliMemReAlloc( void * pIn, size_t cSize, const char *szFile, int lineno )
{
    return ::HeapReAlloc( g_hDenaliHeap, 0, pIn, cSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\makevers.cpp ===
/*
 * Program to make verdep.h
 
   Owner:
   Lei Jin(leijin)
   
   Borrowed from Access team.(Andrew)
 */
#pragma hdrstop
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "windows.h"

main()
	{
	// need to collect the current date, the version number, the version
	// type, and the volume label.
	struct tm *tmTime;
	char szVersNum[120];
	char szbuf[256];
	char *szMakeType, *szUserName;
	time_t tt;

	static char *szMonth[] =
		{
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December"
		};


	// Get the time
	time(&tt);
	tmTime = localtime(&tt);
  

	// Get the types from environment
	szMakeType = getenv("MAKETYPE");

	if (!szMakeType)
		szMakeType = "Unknown";


	// Get the user name
	szUserName = getenv("USERNAME");

	if (!szUserName)
		{
		//unsigned long dw;

		if (!GetVolumeInformation(NULL, szbuf, 255, NULL, NULL, NULL, NULL, 0))
			szUserName = "NOBODY";
		else
			szUserName = szbuf;
		}

	// Get the version number from stdin
	//gets(szVersNum);
	sprintf(szVersNum, "2");	
	

	printf("#define vszMakeDate\t\"%s %d, 19%d\"\n", szMonth[tmTime->tm_mon], tmTime->tm_mday, tmTime->tm_year);
	printf("#define vszMakeVers\t\"Version %s - %s - %s\"\n", szVersNum, szMakeType, szUserName);
	printf("#define vszVersNum\t\"%s\"\n", szVersNum, szMakeType);
	printf("#define vszCopyright\t\"Copyright \251 1996 Microsoft Corp.\"\n");
	printf("#define vszVersName\t\"%s (%s)\"\n", szUserName, szMakeType);
	printf("#define vszMakeSerial\t\"%02d-%02d-%02d-%02d%02d%02d\"\n", tmTime->tm_mon + 1, tmTime->tm_mday, tmTime->tm_year, 
		tmTime->tm_hour, tmTime->tm_min, tmTime->tm_sec);
	printf("#define vszDenaliVersion\t%s.%02d.%02d.0\n", szVersNum, (tmTime->tm_year - 96)*12 + tmTime->tm_mon + 1, tmTime->tm_mday);
	printf("#define vszDenaliVersionNULL\t\"%s.%02d.%02d.0\\0\"\n", szVersNum, (tmTime->tm_year - 96)*12 + tmTime->tm_mon + 1, tmTime->tm_mday);
	
	// the following block is for the version stamp resource
	{
	#include <string.h>
	char *sz;
	// major
	if(sz = strtok(szVersNum, ".\n \t"))
		printf("#define rmj\t\t%0u\n", atoi(sz));
	// minor
	if(sz = strtok(NULL, ".\n \t"))
		printf("#define rmm\t\t%01u\n", atoi(sz));
	else
		printf("#define rmm\t\t0\n");
	// release
	if(sz = strtok(NULL, ""))
		printf("#define rup\t\t%0u\n", atoi(sz));
	else
		printf("#define rup\t\t0\n");
	}

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\memchk.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Memory Management

File: Memchk.h

Owner: PramodD

This is the Memory Manager header file
===================================================================*/

#ifndef MEMCHK_H
#define MEMCHK_H

#define DENALI_MEMCHK

// Always use these macros, DO NOT ever use DenaliMemXX functions directly

// Function names that SHOULD BE used

#define malloc(x)			DenaliMemAlloc( x, __FILE__, __LINE__ )
#define calloc(x,y)			DenaliMemCalloc( x, y, __FILE__, __LINE__ )
#define realloc(x,y)		DenaliMemReAlloc( x, y, __FILE__, __LINE__ )
#define free(x)				DenaliMemFree( x, __FILE__, __LINE__ )
#define DenaliMemoryInit()	DenaliMemInit( __FILE__, __LINE__ )
#define DenaliMemoryUnInit() DenaliMemUnInit( __FILE__, __LINE__ )
#define DenaliDiagnostics()	DenaliMemDiagnostics( __FILE__, __LINE__ )
#define DenaliIsValid(x)	DenaliMemIsValid(x)

// Functions that are actually linked

extern HRESULT				DenaliMemInit(const char *szFile, int lineno);
extern void					DenaliMemUnInit(const char *szFile, int lineno);
extern void					DenaliMemDiagnostics(const char *szFile, int lineno);
extern void					DenaliLogCall(const char *szLog, const char *szFile, int lineno);
extern void *				DenaliMemAlloc(size_t cSize, const char *szFile, int lineno );
extern void *				DenaliMemCalloc(size_t cNum, size_t cbSize, const char *szFile, int lineno );
extern void					DenaliMemFree(void * p, const char *szFile, int lineno);
extern void *				DenaliMemReAlloc(void * p, size_t cSize, const char *szFile, int lineno);
extern int					DenaliMemIsValid(void * p);

// Redefinition of global operators new and delete
#ifdef __cplusplus

// override for the default operator new
inline void * __cdecl operator new(size_t cSize) 
	{
	return DenaliMemAlloc(cSize, NULL, 0); 
	}

// override for the custom operator new with 3 args
inline void * operator new(size_t cSize, const char *szFile, int lineno)
	{
	return DenaliMemAlloc(cSize, szFile, lineno); 
	}

// override for the default operator delete
inline void __cdecl operator delete(void * p) 
    {
    DenaliMemFree(p, NULL, 0); 
    }

// Macro to grab source file and line number information

#define new					new( __FILE__, __LINE__ )

/*
#define delete DenaliLogCall( "Calling delete operator", __FILE__, __LINE__ ), delete
*/

#endif // __cplusplus

#endif // MEMCHK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\idhash.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

File: idhash.h

Owner: DmitryR

Header file for the new hashing stuff
===================================================================*/

#ifndef ASP_IDHASH_H
#define ASP_IDHASH_H

// forward declarations

class  CPtrArray;

class  CHashLock;

struct CIdHashElem;
struct CIdHashArray;
class  CIdHashTable;
class  CIdHashTableWithLock;

struct CObjectListElem;
class  CObjectList;
class  CObjectListWithLock;


// defines for the iterator callback return codes

#define IteratorCallbackCode   DWORD
#define iccContinue            0x00000001  // goto next object
#define iccStop                0x00000002  // stop iterating
#define iccRemoveAndContinue   0x00000004  // remove this, goto next
#define iccRemoveAndStop       0x00000008  // remove this and stop


// typedefs for the iterator callback
typedef IteratorCallbackCode (*PFNIDHASHCB)
                           (void *pvObj, void *pvArg1, void *pvArg2);

/*===================================================================
  C  P t r  A r r a y

Self-reallocating array of void pointers
===================================================================*/
class CPtrArray
    {
private:
    DWORD  m_dwSize;    // allocated size
    DWORD  m_dwInc;     // allocation increment
    void **m_rgpvPtrs;  // array of void pointers
    DWORD  m_cPtrs;     // pointers in the array

public:
    CPtrArray(DWORD dwInc = 8); // 8 pointers is the default increment
    ~CPtrArray();

    // # of elements
    int Count() const;

    // get pointer at position
    void *Get(int i) const;
    // same as operator []
    void *operator[](int i) const;

    // append to array
    HRESULT Append(void *pv);
    // prepend to array
    HRESULT Prepend(void *pv);
    // insert into given position
    HRESULT Insert(int iPos, void *pv);

    // find first position of a pointer
    HRESULT Find(void *pv, int *piPos) const;
    // same as operator []
    int operator[](void *pv) const;

    // remove by position
    HRESULT Remove(int iPos);
    // remove by pointer (all occurances)
    HRESULT Remove(void *pv);

    // remove all
    HRESULT Clear();
    };

// inlines

inline CPtrArray::CPtrArray(DWORD dwInc)
    : m_dwSize(0), m_dwInc(dwInc), m_rgpvPtrs(NULL), m_cPtrs(0)
    {
    Assert(m_dwInc > 0);
    }

inline CPtrArray::~CPtrArray()
    {
    Clear();
    }

inline int CPtrArray::Count() const
    {
    return m_cPtrs;
    }

inline void *CPtrArray::Get(int i) const
    {
    Assert(i >= 0 && (DWORD)i < m_cPtrs);
    Assert(m_rgpvPtrs);
    return m_rgpvPtrs[i];
    }

inline void *CPtrArray::operator[](int i) const
    {
    return Get(i);
    }

inline HRESULT CPtrArray::Append(void *pv)
    {
    return Insert(m_cPtrs, pv);
    }

inline HRESULT CPtrArray::Prepend(void *pv)
    {
    return Insert(0, pv);
    }

inline int CPtrArray::operator[](void *pv) const
    {
    int i;
    if (Find(pv, &i) == S_OK)
        return i;
    return -1; // not found
    }


/*===================================================================
  C  H a s h  L o c k

A wrapper around CRITICAL_SECTION.
===================================================================*/

class CHashLock
    {
private:
    DWORD m_fInited : 1;
    CRITICAL_SECTION m_csLock;

public:
    CHashLock();
    ~CHashLock();

    HRESULT Init();
    HRESULT UnInit();

    void Lock();
    void UnLock();
    };

// inlines

inline CHashLock::CHashLock()
    : m_fInited(FALSE)
    {
    }

inline CHashLock::~CHashLock()
    {
    UnInit();
    }

inline void CHashLock::Lock()
    {
    Assert(m_fInited);
    EnterCriticalSection(&m_csLock);
    }

inline void CHashLock::UnLock()
    {
    Assert(m_fInited);
    LeaveCriticalSection( &m_csLock );
    }


/*===================================================================
  C  I d  H a s h  U n i t

8-byte structure -- one element of hash array. Could be:
1) empty, 2) point to an object, 3) point to sub-array
===================================================================*/

struct CIdHashElem
    {
    DWORD_PTR m_dw;
    void *m_pv;

    BOOL FIsEmpty() const;
    BOOL FIsObject() const;
    BOOL FIsArray() const;

    DWORD_PTR DWId() const;
    void *PObject() const;
    CIdHashArray *PArray() const;

    void SetToEmpty();
    void SetToObject(DWORD_PTR dwId, void *pvObj);
    void SetToArray(CIdHashArray *pArray);
    };

// inlines

inline BOOL CIdHashElem::FIsEmpty() const
    {
    return (m_pv == NULL);
    }

inline BOOL CIdHashElem::FIsObject() const
    {
    return (m_dw != 0);
    }

inline BOOL CIdHashElem::FIsArray() const
    {
    return (m_pv != NULL && m_dw == 0);
    }

inline DWORD_PTR CIdHashElem::DWId() const
    {
    return m_dw;
    }

inline void *CIdHashElem::PObject() const
    {
    return m_pv;
    }

inline CIdHashArray *CIdHashElem::PArray() const
    {
    return reinterpret_cast<CIdHashArray *>(m_pv);
    }

inline void CIdHashElem::SetToEmpty()
    {
    m_dw = 0;
    m_pv = NULL;
    }

inline void CIdHashElem::SetToObject
(
DWORD_PTR dwId,
void *pvObj
)
    {
    m_dw = dwId;
    m_pv = pvObj;
    }

inline void CIdHashElem::SetToArray
(
CIdHashArray *pArray
)
    {
    m_dw = 0;
    m_pv = pArray;
    }

/*===================================================================
  C  I d  H a s h  A r r a y

Structure to consisting of DWORD (# of elems) and the array of Elems
===================================================================*/

struct CIdHashArray
    {
    USHORT m_cElems;            // total number of elements
    USHORT m_cNotNulls;         // number of not NULL elements
    CIdHashElem m_rgElems[1];   // 1 doesn't matter

    static CIdHashArray *Alloc(DWORD cElems);
    static void Free(CIdHashArray *pArray);

    HRESULT Find(DWORD_PTR dwId, void **ppvObj) const;
    HRESULT Add(DWORD_PTR dwId, void *pvObj, USHORT *rgusSizes);
    HRESULT Remove(DWORD_PTR dwId, void **ppvObj);
    IteratorCallbackCode Iterate(PFNIDHASHCB pfnCB, void *pvArg1, void *pvArg2);

#ifdef DBG
    void DumpStats(FILE *f, int nVerbose, DWORD iLevel,
        DWORD &cElems, DWORD &cSlots, DWORD &cArrays, DWORD &cDepth) const;
#else
    inline void DumpStats(FILE *, int, DWORD,
        DWORD &, DWORD &,  DWORD &, DWORD &) const {}
#endif
    };

/*===================================================================
  C  I d  H a s h  T a b l e

Remembers sizes of arrays on all levels and has a pointer to the
first level array of CIdHashElem elements.
===================================================================*/

class CIdHashTable
    {
private:
    USHORT        m_rgusSizes[4]; // Sizes of arrays on first 4 levels
    CIdHashArray *m_pArray;       // Pointer to first level array

    inline BOOL FInited() const { return (m_rgusSizes[0] != 0); }

public:
    CIdHashTable();
    CIdHashTable(USHORT usSize1, USHORT usSize2 = 0, USHORT usSize3 = 0);
    ~CIdHashTable();

    HRESULT Init(USHORT usSize1, USHORT usSize2 = 0, USHORT usSize3 = 0);
    HRESULT UnInit();

    HRESULT FindObject(DWORD_PTR dwId, void **ppvObj = NULL) const;
    HRESULT AddObject(DWORD_PTR dwId, void *pvObj);
    HRESULT RemoveObject(DWORD_PTR dwId, void **ppvObj = NULL);
    HRESULT RemoveAllObjects();

    HRESULT IterateObjects
        (
        PFNIDHASHCB pfnCB,
        void *pvArg1 = NULL,
        void *pvArg2 = NULL
        );

public:
#ifdef DBG
    void AssertValid() const;
    void Dump(const char *szFile) const;
#else
    inline void AssertValid() const {}
    inline void Dump(const char *) const {}
#endif
    };

// inlines

inline CIdHashTable::CIdHashTable()
    {
    m_rgusSizes[0] = 0; // mark as UnInited
    m_pArray = NULL;
    }

inline CIdHashTable::CIdHashTable
(
USHORT usSize1,
USHORT usSize2,
USHORT usSize3
)
    {
    m_rgusSizes[0] = 0; // mark as UnInited
    m_pArray = NULL;

    Init(usSize1, usSize2, usSize3);  // use Init to initialize
    }

inline CIdHashTable::~CIdHashTable()
    {
    UnInit();
    }

inline HRESULT CIdHashTable::FindObject
(
DWORD_PTR dwId,
void **ppvObj
)
    const
    {
    Assert(FInited());
    Assert(dwId);

    if (!m_pArray)
        {
        if (ppvObj)
            *ppvObj = NULL;
        return S_FALSE;
        }

    return m_pArray->Find(dwId, ppvObj);
    }

inline HRESULT CIdHashTable::AddObject
(
DWORD_PTR dwId,
void *pvObj
)
    {
    Assert(FInited());
    Assert(dwId);
    Assert(pvObj);

    if (!m_pArray)
        {
        m_pArray = CIdHashArray::Alloc(m_rgusSizes[0]);
        if (!m_pArray)
            return E_OUTOFMEMORY;
        }

    return m_pArray->Add(dwId, pvObj, m_rgusSizes);
    }

inline HRESULT CIdHashTable::RemoveObject
(
DWORD_PTR dwId,
void **ppvObj
)
    {
    Assert(FInited());
    Assert(dwId);

    if (!m_pArray)
        {
        if (ppvObj)
            *ppvObj = NULL;
        return S_FALSE;
        }

    return m_pArray->Remove(dwId, ppvObj);
    }

inline HRESULT CIdHashTable::RemoveAllObjects()
    {
    if (m_pArray)
        {
        CIdHashArray::Free(m_pArray);
        m_pArray = NULL;
        }
    return S_OK;
    }

inline HRESULT CIdHashTable::IterateObjects
(
PFNIDHASHCB pfnCB,
void *pvArg1,
void *pvArg2
)
    {
    Assert(FInited());
    Assert(pfnCB);

    if (!m_pArray)
        return S_OK;

    return m_pArray->Iterate(pfnCB, pvArg1, pvArg2);
    }

/*===================================================================
  C  I d  H a s h  T a b l e  W i t h  L o c k

CIdHashTable + CRITICAL_SECTION.
===================================================================*/

class CIdHashTableWithLock : public CIdHashTable, public CHashLock
    {
public:
    CIdHashTableWithLock();
    ~CIdHashTableWithLock();

    HRESULT Init(USHORT usSize1, USHORT usSize2 = 0, USHORT usSize3 = 0);
    HRESULT UnInit();
    };

// inlines

inline CIdHashTableWithLock::CIdHashTableWithLock()
    {
    }

inline CIdHashTableWithLock::~CIdHashTableWithLock()
    {
    UnInit();
    }

inline HRESULT CIdHashTableWithLock::Init
(
USHORT usSize1,
USHORT usSize2,
USHORT usSize3
)
    {
    HRESULT hr = CIdHashTable::Init(usSize1, usSize2, usSize3);
    if (SUCCEEDED(hr))
        hr = CHashLock::Init();

    return hr;
    }

inline HRESULT CIdHashTableWithLock::UnInit()
    {
    CIdHashTable::UnInit();
    CHashLock::UnInit();
    return S_OK;
    }


/*===================================================================
  C  O b j e c t  L i s t  E l e m

Double linked list element
===================================================================*/

struct CObjectListElem
    {
    CObjectListElem *m_pNext;
    CObjectListElem *m_pPrev;

    CObjectListElem();

    void Insert(CObjectListElem *pPrevElem, CObjectListElem *pNextElem);
    void Remove();

    void *PObject(DWORD dwFieldOffset);
    };

inline CObjectListElem::CObjectListElem()
    : m_pNext(NULL), m_pPrev(NULL)
    {
    }

inline void CObjectListElem::Insert
(
CObjectListElem *pPrevElem,
CObjectListElem *pNextElem
)
    {
    Assert(!pPrevElem || (pPrevElem->m_pNext == pNextElem));
    Assert(!pNextElem || (pNextElem->m_pPrev == pPrevElem));

    m_pPrev = pPrevElem;
    m_pNext = pNextElem;

    if (pPrevElem)
        pPrevElem->m_pNext = this;

    if (pNextElem)
        pNextElem->m_pPrev = this;
    }

inline void CObjectListElem::Remove()
    {
    if (m_pPrev)
        m_pPrev->m_pNext = m_pNext;

    if (m_pNext)
        m_pNext->m_pPrev = m_pPrev;

    m_pPrev = m_pNext = NULL;
    }

inline void *CObjectListElem::PObject(DWORD dwFieldOffset)
    {
    return ((BYTE *)this - dwFieldOffset);
    }

// Macro to get the byte offset of a field in a class
#define OBJECT_LIST_ELEM_FIELD_OFFSET(type, field) \
        (PtrToUlong(&(((type *)0)->field)))

inline CObjectListElem *PListElemField
(
void *pvObj,
DWORD dwFieldOffset
)
    {
    if (!pvObj)
        return NULL;
    return (CObjectListElem *)((BYTE *)pvObj + dwFieldOffset);
    }

/*===================================================================
  C  O b j e c t  L i s t

Double linked list of objects
===================================================================*/

class CObjectList
    {
private:
    CObjectListElem m_Head;   // list head
    DWORD m_dwFieldOffset;    // offset to CObjectListElem member field

public:
    CObjectList();
    ~CObjectList();

    HRESULT Init(DWORD dwFieldOffset = 0);
    HRESULT UnInit();

    HRESULT AddObject(void *pvObj);
    HRESULT RemoveObject(void *pvObj);
    HRESULT RemoveAllObjects();

    // iteration
    void *PFirstObject();
    void *PNextObject(void *pvObj);
    };

// inlines

inline CObjectList::CObjectList()
    : m_dwFieldOffset(0)
    {
    }

inline CObjectList::~CObjectList()
    {
    UnInit();
    }

inline HRESULT CObjectList::Init(DWORD dwFieldOffset)
    {
    m_dwFieldOffset = dwFieldOffset;
    m_Head.m_pPrev = m_Head.m_pNext = NULL;
    return S_OK;
    }

inline HRESULT CObjectList::UnInit()
    {
    RemoveAllObjects();
    return S_OK;
    }

inline HRESULT CObjectList::AddObject(void *pvObj)
    {
    Assert(pvObj);
    // insert between head and its next
    PListElemField(pvObj, m_dwFieldOffset)->Insert(&m_Head, m_Head.m_pNext);
    return S_OK;
    }

inline HRESULT CObjectList::RemoveObject(void *pvObj)
    {
    Assert(pvObj);
    PListElemField(pvObj, m_dwFieldOffset)->Remove();
    return S_OK;
    }

inline HRESULT CObjectList::RemoveAllObjects()
    {
    if (m_Head.m_pNext)
        m_Head.m_pNext = NULL;
    return S_OK;
    }

inline void *CObjectList::PFirstObject()
    {
    return m_Head.m_pNext ? m_Head.m_pNext->PObject(m_dwFieldOffset) : NULL;
    }

inline void *CObjectList::PNextObject(void *pvObj)
    {
    CObjectListElem *pNextElem =
        pvObj ? PListElemField(pvObj, m_dwFieldOffset)->m_pNext : NULL;
    return pNextElem ? pNextElem->PObject(m_dwFieldOffset) : NULL;
    }

/*===================================================================
  C  O b j e c t  L i s t  W i t h  L o c k

CObjectList + CRITICAL_SECTION.
===================================================================*/

class CObjectListWithLock : public CObjectList, public CHashLock
    {
public:
    CObjectListWithLock();
    ~CObjectListWithLock();

    HRESULT Init(DWORD dwFieldOffset = 0);
    HRESULT UnInit();
    };

// inlines

inline CObjectListWithLock::CObjectListWithLock()
    {
    }

inline CObjectListWithLock::~CObjectListWithLock()
    {
    UnInit();
    }

inline HRESULT CObjectListWithLock::Init(DWORD dwFieldOffset)
    {
    HRESULT hr = CObjectList::Init(dwFieldOffset);
    if (SUCCEEDED(hr))
        hr = CHashLock::Init();
    return hr;
    }

inline HRESULT CObjectListWithLock::UnInit()
    {
    CObjectList::UnInit();
    CHashLock::UnInit();
    return S_OK;
    }

#endif // ifndef ASP_IDHASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\isapireq.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: CIsapiReqInfo Object

File: IsapiReq.h

Owner: AndyMorr

===================================================================*/
#ifndef ISAPIREQ_H
#define ISAPIREQ_H

#include <iadmw.h>

#if _IIS_5_1
#include <wamxinfo.hxx>
#else
#include <string.hxx>
#endif

#include "memcls.h"

/*
    Mappings of CIsapiReqInfo methods to the proper routines based
    on the UNICODE setting
*/
#ifdef UNICODE
#define QueryPszPathInfo        QueryPszPathInfoW
#define QueryCchPathInfo        QueryCchPathInfoW
#define QueryPszPathTranslated  QueryPszPathTranslatedW
#define QueryCchPathTranslated  QueryCchPathTranslatedW
#define QueryPszApplnMDPath     QueryPszApplnMDPathW
#define QueryCchApplnMDPath     QueryCchApplnMDPathW
#define MapUrlToPath            MapUrlToPathW
#define GetCustomError          GetCustomErrorW
#define GetAspMDData            GetAspMDDataW
#define GetAspMDAllData         GetAspMDAllDataW
#define GetServerVariable       GetServerVariableW
#else
#define QueryPszPathInfo        QueryPszPathInfoA
#define QueryCchPathInfo        QueryCchPathInfoA
#define QueryPszPathTranslated  QueryPszPathTranslatedA
#define QueryCchPathTranslated  QueryCchPathTranslatedA
#define QueryPszApplnMDPath     QueryPszApplnMDPathA
#define QueryCchApplnMDPath     QueryCchApplnMDPathA
#define MapUrlToPath            MapUrlToPathA
#define GetCustomError          GetCustomErrorA
#define GetAspMDData            GetAspMDDataA
#define GetAspMDAllData         GetAspMDAllDataA
#define GetServerVariable       GetServerVariableA
#endif

/*===================================================================
  C I s a p i R e q I n f o
  
Class which encapsulates Request info we need from the ISAPI interface.
Information either comes from the public ISAPI interfaces (SSE and
ServerVariables) or from the private WAM_EXEC_INFO.

===================================================================*/

class CIsapiReqInfo {

private:

    LONG    m_cRefs;
#if _IIS_5_1
    // Associated WAM_EXEC_INFO (for browser requests)
    WAM_EXEC_INFO   *m_pWXI;
#endif

    EXTENSION_CONTROL_BLOCK *m_pECB;

    int     m_cchQueryString;
    int     m_cchApplnMDPathA;
    int     m_cchPathTranslatedA;
    int     m_cchPathInfoA;
    int     m_cchApplnMDPathW;
    int     m_cchPathTranslatedW;
    int     m_cchPathInfoW;

    DWORD   m_fApplnMDPathAInited    : 1;
    DWORD   m_fApplnMDPathWInited    : 1;
    DWORD   m_fPathInfoWInited       : 1;
    DWORD   m_fPathTranslatedWInited : 1;
    DWORD   m_fCookieInited          : 1;
    DWORD   m_fUserAgentInited       : 1;
    DWORD   m_fInstanceIDInited      : 1;
    DWORD   m_fVersionInited         : 1;
    DWORD   m_fFKeepConnInited       : 1;

    DWORD   m_dwInstanceID;

    DWORD   m_dwVersionMajor;
    DWORD   m_dwVersionMinor;

    BOOL    m_fKeepConn;

    BUFFER  m_ApplnMDPathA;
    BUFFER  m_ApplnMDPathW;
    BUFFER  m_PathInfoW;
    BUFFER  m_PathTranslatedW;
    BUFFER  m_Cookie;
    BUFFER  m_UserAgent;

    IMSAdminBase    *m_pIAdminBase;

public:

    CIsapiReqInfo(EXTENSION_CONTROL_BLOCK *pECB) {

        m_cRefs = 1;

        m_fApplnMDPathAInited = 0;
        m_fApplnMDPathWInited = 0;
        m_fPathInfoWInited    = 0;
        m_fPathTranslatedWInited    = 0;
        m_fCookieInited       = 0;
        m_fUserAgentInited    = 0;
        m_fInstanceIDInited   = 0;
        m_fVersionInited      = 0;
        m_fFKeepConnInited    = 0;

        m_dwInstanceID        = 0;
        
        m_dwVersionMajor      = 1;
        m_dwVersionMinor      = 0;

        m_cchQueryString      = -1;
        m_cchApplnMDPathA     = -1;
        m_cchPathTranslatedA  = -1;
        m_cchPathInfoA        = -1;
        m_cchApplnMDPathW     = -1;
        m_cchPathTranslatedW  = -1;
        m_cchPathInfoW        = -1;

        m_fKeepConn           = FALSE;

        m_pIAdminBase         = NULL;

#if _IIS_5_1
        m_pWXI                = QueryPWAM_EXEC_INFOfromPECB(pECB);
#endif

        m_pECB                = pECB;
    }

    ~CIsapiReqInfo() {
        if (m_pIAdminBase != NULL) {
            m_pIAdminBase->Release();
            m_pIAdminBase = NULL;
        }
    }

    LONG    AddRef() {
        return InterlockedIncrement(&m_cRefs);
    }

    LONG    Release() {
        LONG    cRefs = InterlockedDecrement(&m_cRefs);
        if (cRefs == 0) {
            delete this;
        }
        return cRefs;
    }

#if _IIS_5_1
    EXTENSION_CONTROL_BLOCK     *ECB() { return &m_pWXI->ecb; }
#else
    EXTENSION_CONTROL_BLOCK     *ECB() { return m_pECB; }
#endif

    LPSTR QueryPszQueryString();

    DWORD QueryCchQueryString();

    LPSTR QueryPszApplnMDPathA();

    DWORD QueryCchApplnMDPathA();

    LPWSTR QueryPszApplnMDPathW();

    DWORD QueryCchApplnMDPathW();

    LPSTR QueryPszPathInfoA();

    DWORD QueryCchPathInfoA();

    LPWSTR QueryPszPathInfoW();

    DWORD QueryCchPathInfoW();

    LPSTR QueryPszPathTranslatedA();
    
    DWORD QueryCchPathTranslatedA();

    LPWSTR QueryPszPathTranslatedW();
    
    DWORD QueryCchPathTranslatedW();

    LPSTR QueryPszCookie();

    VOID  SetDwHttpStatusCode( DWORD dwStatus );

    LPBYTE QueryPbData();

    DWORD QueryCbAvailable();

    DWORD QueryCbTotalBytes();

    LPSTR QueryPszContentType();

    LPSTR QueryPszMethod();

    LPSTR QueryPszUserAgent();

    DWORD QueryInstanceId();

    BOOL  IsChild();

    BOOL FInPool();

    DWORD QueryHttpVersionMajor();

    DWORD QueryHttpVersionMinor();

    HRESULT ISAThreadNotify( BOOL fStart );

    HRESULT GetAspMDDataA(CHAR          * pszMDPath,
                          DWORD           dwMDIdentifier,
                          DWORD           dwMDAttributes,
                          DWORD           dwMDUserType,
                          DWORD           dwMDDataType,
                          DWORD           dwMDDataLen,
                          DWORD           dwMDDataTag,
                          unsigned char * pbMDData,
                          DWORD *         pdwRequiredBufferSize);

    HRESULT GetAspMDDataW(WCHAR         * pszMDPath,
                          DWORD           dwMDIdentifier,
                          DWORD           dwMDAttributes,
                          DWORD           dwMDUserType,
                          DWORD           dwMDDataType,
                          DWORD           dwMDDataLen,
                          DWORD           dwMDDataTag,
                          unsigned char * pbMDData,
                          DWORD *         pdwRequiredBufferSize);

    HRESULT GetAspMDAllDataA(CHAR  * pszMDPath,
                             DWORD   dwMDUserType,
                             DWORD   dwDefaultBufferSize,
                             LPVOID  pvBuffer,
                             DWORD * pdwRequiredBufferSize,
                             DWORD * pdwNumDataEntries);

    HRESULT GetAspMDAllDataW(WCHAR  * pszMDPath,
                             DWORD   dwMDUserType,
                             DWORD   dwDefaultBufferSize,
                             LPVOID  pvBuffer,
                             DWORD * pdwRequiredBufferSize,
                             DWORD * pdwNumDataEntries);

    BOOL GetCustomErrorA(DWORD dwError,
                         DWORD dwSubError,
                         DWORD dwBufferSize,
                         CHAR  *pvBuffer,
                         DWORD *pdwRequiredBufferSize,
                         BOOL  *pfIsFileError);

    BOOL GetCustomErrorW(DWORD dwError,
                         DWORD dwSubError,
                         DWORD dwBufferSize,
                         WCHAR *pvBuffer,
                         DWORD *pdwRequiredBufferSize,
                         BOOL  *pfIsFileError);

    HANDLE QueryImpersonationToken();

    HRESULT AppendLogParameter( LPSTR szExtraParam );

    BOOL SendHeader(LPVOID pvStatus,
                    DWORD  cchStatus,
                    LPVOID pvHeader,
                    DWORD  cchHeader,
                    BOOL   fIsaKeepConn);

    BOOL GetServerVariableA(LPSTR   szVarName, 
                            LPSTR   pBuffer, 
                            LPDWORD pdwSize );

    BOOL GetServerVariableW(LPSTR   szVarName,
                            LPWSTR  pBuffer,
                            LPDWORD pdwSize);

    BOOL ServerSupportFunction(DWORD   dwHSERequest,
                               LPVOID  pvData, 
                               LPDWORD pdwSize, 
                               LPDWORD pdwDataType);

    BOOL SendEntireResponseOop(IN HSE_SEND_ENTIRE_RESPONSE_INFO * pHseResponseInfo);

    BOOL SendEntireResponse(IN HSE_SEND_ENTIRE_RESPONSE_INFO * pHseResponseInfo);

    BOOL TestConnection(BOOL  *pfIsConnected);

    BOOL MapUrlToPathA(LPSTR pBuffer, LPDWORD pdwBytes);

    BOOL MapUrlToPathW(LPWSTR pBuffer, LPDWORD pdwBytes);

    BOOL SyncReadClient(LPVOID pvBuffer, LPDWORD pdwBytes );

    BOOL SyncWriteClient(LPVOID pvBuffer, LPDWORD pdwBytes);

private:

    void             InitVersionInfo();

    IMSAdminBase    *GetMetabaseIF();

    BOOL             InternalGetServerVariable(LPSTR  pszVar, BUFFER  *pBuffer);

    BOOL             FKeepConn();

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\memcls.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Per-Class Memory Management

File: Memcls.h

Owner: dmitryr

This file contains #defines to access ATQ memory cache on per
class basis
===================================================================*/

#ifndef MEMCLS_H
#define MEMCLS_H

// ATQ memory cache
#include <acache.hxx>

// To resolve Assert()
#include "debug.h"

// Prototypes

HRESULT InitMemCls();
HRESULT UnInitMemCls();

/*===================================================================
  M A C R O S  to make a class use ACACHE allocator
===================================================================*/

/*===================================================================
  I n s t r u c t i o n s

    To add a class named CFoo to the per-class basis follow these
    four simple steps:

    1) Inside the class definition include ACACHE_INCLASS_DEFINITIONS():

            class CFoo
                {
                ...


                ACACHE_INCLASS_DEFINITIONS()    // <-add this line
                };

    2) In a source file add the ACACHE_CODE macro outside
       any function body:
       
            ACACHE_CODE(CFoo)                   // <-add this line

    3) In a DLL initialization routine add ACACHE_INIT macro:

            ACACHE_INIT(CFoo, 13, hr)           // <-add this line

       where 13 is the threshold. Use the desired number instead.
       

    4) In a DLL uninitialization routine add ACACHE_UNINIT macro:

            ACACHE_UNINIT(CFoo)                 // <-add this line
            

===================================================================*/

/*

The following macro should be used inside class definition to
enable per-class caching.

The second operator new is needed in case memchk.h [#define]'s new
to this expanded form.

*/

#define ACACHE_INCLASS_DEFINITIONS()                            \
    public:                                                     \
        static void * operator new(size_t);                     \
        static void * operator new(size_t, const char *, int);  \
        static void   operator delete(void *);                  \
        static ALLOC_CACHE_HANDLER *sm_pach;

/*

The following macro should be used once per class in a source
file outside of any functions. The argument is the class name.

*/

#define ACACHE_CODE(C)                                          \
    ALLOC_CACHE_HANDLER *C::sm_pach;                            \
    void *C::operator new(size_t s)                             \
        { Assert(s == sizeof(C)); Assert(sm_pach);              \
        return sm_pach->Alloc(); }                              \
    void *C::operator new(size_t s, const char *, int)          \
        { Assert(s == sizeof(C)); Assert(sm_pach);              \
        return sm_pach->Alloc(); }                              \
    void C::operator delete(void *pv)                           \
        { Assert(pv); if (sm_pach) sm_pach->Free(pv); }

/*

The following macro should be used once per class in the
DLL initialization routine.
Arguments: class name, cache size, HRESULT var name

*/

#define ACACHE_INIT(C, T, hr)                                   \
    { if (SUCCEEDED(hr)) { Assert(!C::sm_pach);                 \
    ALLOC_CACHE_CONFIGURATION acc = { 1, T, sizeof(C) };        \
    C::sm_pach = new ALLOC_CACHE_HANDLER("ASP:" #C, &acc);      \
    hr = C::sm_pach ? S_OK : E_OUTOFMEMORY; } }

#define ACACHE_INIT_EX(C, T, F, hr)                                   \
    { if (SUCCEEDED(hr)) { Assert(!C::sm_pach);                 \
    ALLOC_CACHE_CONFIGURATION acc = { 1, T, sizeof(C) };        \
    C::sm_pach = new ALLOC_CACHE_HANDLER("ASP:" #C, &acc, F);      \
    hr = C::sm_pach ? S_OK : E_OUTOFMEMORY; } }

/*

The following macro should be used once per class in the
DLL uninitialization routine. The argument is the class name.

*/

#define ACACHE_UNINIT(C)                                        \
    { if (C::sm_pach) { delete C::sm_pach; C::sm_pach = NULL; } }


/*===================================================================
  M A C R O S  to create a fixes size allocator
===================================================================*/

/*===================================================================
  I n s t r u c t i o n s

    To add a fixed size allocator for 1K buffers named Foo
    to the code follow these simple steps:

    1) In a header file include extern definition

            ACACHE_FSA_EXTERN(Foo)

    2) In a source file the actual definition outside
       any function body:
       
            ACACHE_FSA_DEFINITION(Foo)

    3) In a DLL initialization routine add INIT macro:

            ACACHE_FSA_INIT(Foo, 1024, 13, hr)

       where 1024 is the size and 13 is the threshold.
       Use the desired numbers instead.
       
    4) In a DLL uninitialization routine add UNINIT macro:

            ACACHE_FSA_UNINIT(CFoo)

    5) To allocate, do:

            void *pv = ACACHE_FSA_ALLOC(Foo)

    6) To free, do:

            ACACHE_FSA_FREE(Foo, pv)

===================================================================*/

#define ACACHE_FSA_EXTERN(C)                                    \
    extern ALLOC_CACHE_HANDLER *g_pach##C;

#define ACACHE_FSA_DEFINITION(C)                                \
    ALLOC_CACHE_HANDLER *g_pach##C = NULL;

#define ACACHE_FSA_INIT(C, S, T, hr)                            \
    { if (SUCCEEDED(hr)) { Assert(!g_pach##C);                  \
    ALLOC_CACHE_CONFIGURATION acc = { 1, T, S };                \
    g_pach##C = new ALLOC_CACHE_HANDLER("ASP:" #C, &acc);       \
    hr = g_pach##C ? S_OK : E_OUTOFMEMORY; } }

#define ACACHE_FSA_UNINIT(C)                                    \
    { if (g_pach##C) { delete g_pach##C; g_pach##C = NULL; } }

#define ACACHE_FSA_ALLOC(C)                                     \
    ( g_pach##C ? g_pach##C->Alloc() : NULL )

#define ACACHE_FSA_FREE(C, pv)                                  \
    { Assert(pv); if (g_pach##C) g_pach##C->Free(pv); }
    
#endif // MEMCLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\ntsec.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: NT/OLE Security

File: NTSec.cpp

Owner: AndrewS

This file contains code related to NT security on Desktops

BUG 87164: This whole code path is unused.  I'm leaving this around
in case we ever need it.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "ntsec.h"

// Globals
HDESK ghDesktop = NULL;
HDESK ghdeskPrev = NULL;

// Local Defines
// Note: This name is deliberately obscure so no one will guess it
#define SZ_DEN_DESKTOP	"__A8D9S1_42_D"

#define DESKTOP_ALL (DESKTOP_READOBJECTS     | DESKTOP_CREATEWINDOW     | \
                     DESKTOP_CREATEMENU      | DESKTOP_HOOKCONTROL      | \
                     DESKTOP_JOURNALRECORD   | DESKTOP_JOURNALPLAYBACK  | \
                     DESKTOP_ENUMERATE       | DESKTOP_WRITEOBJECTS     | \
                     DESKTOP_SWITCHDESKTOP   | STANDARD_RIGHTS_REQUIRED)

/*===================================================================
InitDesktop

Create a desktop for ASP threads to use & tells Viper to call
us back on every thread create so we can set the desktop

Parameters:

Returns:
	HRESULT		S_OK on success

Side effects
	Sets global variables
===================================================================*/
HRESULT InitDesktop()
	{
	HRESULT hr = S_OK;
	DWORD err;
	HDESK hDesktop = NULL;

	// Only applies to NT
	if (!Glob(fWinNT))
		return(S_OK);

	// Save the old desktop because we might need it later for an obscure error condition
	if ((ghdeskPrev = GetThreadDesktop(GetCurrentThreadId())) == NULL)
		goto LErr;

	// Create a desktop for denali to use
	if ((hDesktop = CreateDesktop(SZ_DEN_DESKTOP, NULL, NULL, 0, DESKTOP_ALL, NULL)) == NULL)
		goto LErr;

	// store this handle in the global
	ghDesktop = hDesktop;

#ifdef UNUSED
	hr = SetViperThreadEvents();
	Assert(SUCCEEDED(hr));
#endif

	return(hr);
	
LErr:
	Assert(FALSE);

	if (hDesktop != NULL)
		CloseDesktop(hDesktop);

	err = GetLastError();
	hr = HRESULT_FROM_WIN32(err);
	return(hr);
	}
	
/*===================================================================
UnInitDesktop

Destroy the ASP desktop 

Parameters:
	None
	
Returns:
	Nothing

Side effects
	Sets global variables
===================================================================*/
VOID UnInitDesktop()
	{
	BOOL fClosed;

	if (ghDesktop != NULL)
		{
		BOOL fRetried = FALSE;
LRetry:
		Assert(ghDesktop != NULL);
		fClosed = CloseDesktop(ghDesktop);
		// If this fails, it probably means that we are in the obscure case where
		// IIS's CacheExtensions registry setting is 0.  In this case, we are shutting
		// down in a worker thread.  This worker thread is using the desktop, so
		// it cant be closed.  In this case, attempt to set the desktop back to the
		// original IIS desktop, and then retry closing the desktop.  Only retry once.
		if (!fClosed && !fRetried)
			{
			fRetried = TRUE;
			if (!SetThreadDesktop(ghdeskPrev))
				Assert(FALSE);
			goto LRetry;
			}
        // BUG 86775: Begning assert	
		// Assert(fClosed);
		
		ghDesktop = NULL;
		}
		
	return;
	}

/*===================================================================
SetDesktop

Set the desktop for the calling thread

Parameters:
	None
	
Returns:
	S_OK on success

Side effects:
	Sets desktop
===================================================================*/
HRESULT SetDesktop()
	{
	DWORD err;

	if (Glob(fWinNT) && ghDesktop != NULL)
		{
		if (!SetThreadDesktop(ghDesktop))
			goto LErr;
		}

	return(S_OK);
	
LErr:
	Assert(FALSE);

	err = GetLastError();
	return(HRESULT_FROM_WIN32(err));
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\mtacb.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MTA Callback

File: mtacb.h

Owner: DmitryR

This file contains the definitons for MTA Callback
===================================================================*/

#ifndef MTACALLBACK_H
#define MTACALLBACK_H

// To be called from DllInit()
HRESULT InitMTACallbacks();

// To be called from DllUnInit()
HRESULT UnInitMTACallbacks();

// The callback function to be called from an MTA thread
typedef HRESULT (__stdcall *PMTACALLBACK)(void *, void *);

HRESULT CallMTACallback
    (
    PMTACALLBACK pMTACallback,          // call this function
    void        *pvContext,             // pass this to it
    void        *pvContext2             // extra arg
    );

#endif // MTACALLBACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\ntsec.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: NT/OLE Security

File: NTSec.h

Owner: AndrewS

This file contains code related to NT security on Desktops
===================================================================*/

#ifndef __NTSec_h
#define __NTSec_h

HRESULT InitDesktop();
VOID UnInitDesktop();
HRESULT SetDesktop();

#endif //__NTSec_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\perfdata.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: perfdata.cpp

Owner: DmitryR

PERFMON related data in asp.dll -- source file
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "perfdata.h"
#include "memchk.h"

// to access metabase
#include <iiscnfg.h>
#include <iwamreg.h>

#ifndef PERF_DISABLE

BOOL g_fPerfInited = FALSE;
CPerfMainBlock g_PerfMain;
CPerfData      g_PerfData;

/*===================================================================
GetCurrentClsId

Static function to find the current WAM CLSID in the metabase

Parameters
    pIReq            to retrieve WAM CLSID from the metabase
    pClsId          [out] CLSID

Returns:
    HRESULT
===================================================================*/
static HRESULT GetCurrentClsId
(
CIsapiReqInfo   *pIReq,
CLSID *pClsId
)
    {
    HRESULT hr = S_OK;

    Assert(pClsId);

    TCHAR *szMDPath = pIReq->QueryPszApplnMDPath();
    if (!szMDPath)
        {
        *pClsId = CLSID_NULL;
        return E_FAIL;
        }

    CLSID ClsId = CLSID_NULL;

    // Bracket ISA thread

    if (SUCCEEDED(StartISAThreadBracket(pIReq)))
        {
        WCHAR wszClsBuffer[80];
    	DWORD dwRequiredLen, dwAppMode;
        // Find the application mode, inproc, out-of-proc, or pooled OOP
        hr = pIReq->GetAspMDData(szMDPath,
                                 MD_APP_ISOLATED,
                                 METADATA_INHERIT,
                                 IIS_MD_UT_WAM,
                                 DWORD_METADATA,
                                 sizeof(DWORD),
                                 0,
                                 (unsigned char*) &dwAppMode,
                                 &dwRequiredLen);
    	if (SUCCEEDED(hr))
        {
            switch (dwAppMode)
            {
            case eAppRunInProc:
                // preconfigured WAM CLSID for all inproc apps
                wcscpy(wszClsBuffer,
                       L"{99169CB0-A707-11d0-989D-00C04FD919C1}");
                break;
            case eAppRunOutProcIsolated:
                // custom WAM CLSID for non-pooled OOP apps
                hr = pIReq->GetAspMDData(szMDPath,
                                         MD_APP_WAM_CLSID,
                                         METADATA_INHERIT,
                                         IIS_MD_UT_WAM,
                                         STRING_METADATA,
                                         sizeof(wszClsBuffer) / sizeof(WCHAR),
                                         0,
                                         (unsigned char *)wszClsBuffer,
                                         &dwRequiredLen);
                break;
            case eAppRunOutProcInDefaultPool:
                // preconfigured WAM CLSID for the pooled OOP apps
                wcscpy(wszClsBuffer,
                       L"{3D14228D-FBE1-11d0-995D-00C04FD919C1}");
                break;
            default:
                Assert(!"unknown AppMode");
                hr = E_FAIL;
                break;
            }
        }
                            
    	if (SUCCEEDED(hr))
    	    {
    	    // Convert string to CLSID
    		hr = CLSIDFromString(wszClsBuffer, &ClsId);
    	    }

        EndISAThreadBracket(pIReq);
        }
    else
        {
        hr = E_FAIL;
        }

    if (SUCCEEDED(hr) && g_fOOP) // always CLSID_NULL if inproc
        *pClsId = ClsId;
    else
        *pClsId = CLSID_NULL;
    
    return hr;
    }

/*===================================================================
PreInitPerfData

Initialize from DllInit
Creates critical sections

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT PreInitPerfData()
    {
    HRESULT hr = S_OK;

    hr = g_PerfData.InitCriticalSections();

    return hr;
    }

/*===================================================================
InitPerfDataOnFirstRequest

Initialize PERFMON related ASP data from first request

Parameters
    pIReq    to retrieve WAM CLSID from the metabase

Returns:
    HRESULT
===================================================================*/
HRESULT InitPerfDataOnFirstRequest
(
CIsapiReqInfo   *pIReq
)
    {
    // Get CLSID from metabase
    CLSID ClsId;
    HRESULT hr = GetCurrentClsId(pIReq, &ClsId);

    // Check HRESULT from GetCurrentClsId
    if (FAILED(hr))
        return hr;

    // access main shared memory
    if (SUCCEEDED(hr))
        hr = g_PerfMain.Init();

    // access shared memory of this process
    if (SUCCEEDED(hr))
        hr = g_PerfData.Init(ClsId);

    // add this process data to main shared memory
    if (SUCCEEDED(hr))
        hr = g_PerfMain.AddProcess(ClsId);

    if (FAILED(hr))
        {
        g_PerfData.UnInit();
        g_PerfMain.UnInit();
        }

    return hr;
    }

/*===================================================================
UnInitPerfData

UnInitialize PERFMON related ASP data

Returns:
    HRESULT
===================================================================*/
HRESULT UnInitPerfData()
    {
    // remove this process data from main shared memory
    if (g_PerfData.FValid())
        g_PerfMain.RemoveProcess(g_PerfData.ClsId());

    // stop accessing process shared memory
    g_PerfData.UnInit();
    
    // stop accessing main shared memory
    g_PerfMain.UnInit();

    return S_OK;
    }

#endif  // PERF_DISABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\randgen.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Random number generator

File: randgen.cpp

Owner: DmitryR

This file contains the implementation of the random number
generator.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "randgen.h"
#include "memchk.h"

/*===================================================================
  Random DWORD using rand()
===================================================================*/
#define RAND_DWORD()  (((rand() & 0xffff) << 16) | (rand() & 0xffff))

/*===================================================================
  Random number generator class
===================================================================*/
class CRandomGenerator
    {
private:
    DWORD m_fInited   : 1;  // inited?
    DWORD m_fCSInited : 1;  // critical section inited?

    HCRYPTPROV        m_hCryptProvider;     // crypt provider
    CRITICAL_SECTION  m_csLock;             // critical section

    DWORD m_cItems;     // number of items in the array
    DWORD *m_pdwItems;  // pointer to the array of random DWORDs
    DWORD m_iItem;      // next random item index

public:
    CRandomGenerator()
        :
        m_fInited(FALSE),
        m_fCSInited(FALSE),
        m_hCryptProvider(NULL),
        m_cItems(0),
        m_pdwItems(NULL),
        m_iItem(0)
        {
        }
        
    ~CRandomGenerator()
        {
        UnInit();
        }

    HRESULT Init(DWORD cItems = 128)
        {
        Assert(!m_fInited);
        
        m_hCryptProvider = NULL;
        
        if (cItems > 0 &&   gGlob.fWinNT())
            {
            CryptAcquireContext
                (
                &m_hCryptProvider, 
                NULL,
                NULL, 
                PROV_RSA_FULL, 
                CRYPT_VERIFYCONTEXT
                );
            }

        if (!m_hCryptProvider)
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }

        HRESULT hr;
        ErrInitCriticalSection(&m_csLock, hr);
      	if (FAILED(hr))
      	    return hr;
      	m_fCSInited = TRUE;

      	m_pdwItems = new DWORD[cItems];
      	if (!m_pdwItems)
      	    return E_OUTOFMEMORY;
      	m_cItems = cItems;
      	m_iItem  = cItems;  // to start with new chunk

        m_fInited = TRUE;
        return S_OK;
        }

    HRESULT UnInit()
        {
        if (m_hCryptProvider)
            {
            CryptReleaseContext(m_hCryptProvider, 0);
            m_hCryptProvider = NULL;
            }

        if (m_fCSInited)
            {
     		DeleteCriticalSection(&m_csLock);
            m_fCSInited = FALSE;
            }
        
        if (m_pdwItems)
            {
            delete [] m_pdwItems;
            m_pdwItems = NULL;
            }
        m_cItems = 0;
        m_iItem = 0;

        m_fInited = FALSE;
        return S_OK;
        }

    HRESULT Generate(DWORD *pdwDwords, DWORD cDwords)
        {
        Assert(pdwDwords);
        Assert(cDwords > 0);
        
        Assert(m_fInited);

        DWORD i;
        
        // use CryptGenRandom

        Assert(cDwords <= m_cItems); // requested # of items < m_cItems
        Assert(m_fCSInited);
            
        EnterCriticalSection(&m_csLock);

        if (m_iItem+cDwords-1 >= m_cItems)
            {
            
            BOOL fSucceeded = CryptGenRandom
                (
                m_hCryptProvider, 
                m_cItems * sizeof(DWORD),
                reinterpret_cast<BYTE *>(m_pdwItems)
                );

            if (!fSucceeded)
                {
                // Failed -> use rand()
                // Dont use rand() instead throw an error.
                return HRESULT_FROM_WIN32(GetLastError());
                }

            m_iItem = 0; // start over
            }

        for (i = 0; i < cDwords; i++)
            pdwDwords[i] = m_pdwItems[m_iItem++];
        
        LeaveCriticalSection(&m_csLock);

        return S_OK;
        }
    };

// Pointer to the sole instance of the above
static CRandomGenerator *gs_pRandomGenerator = NULL;

/*===================================================================
  E x t e r n a l  A P I
===================================================================*/

/*===================================================================
InitRandGenerator

To be called from DllInit()

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT InitRandGenerator()
    {
    gs_pRandomGenerator = new CRandomGenerator;
    if (!gs_pRandomGenerator)
        return E_OUTOFMEMORY;

    return gs_pRandomGenerator->Init();
    }

/*===================================================================
UnInitRandGenerator

To be called from DllUnInit()

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT UnInitRandGenerator()
    {
    if (gs_pRandomGenerator)
        {
        gs_pRandomGenerator->UnInit();
        delete gs_pRandomGenerator;
        }
    return S_OK;
    }

/*===================================================================
GenerateRandomDword

Returns random DWORD

Parameters

Returns:
    Random number
===================================================================*/
DWORD GenerateRandomDword()
    {
    DWORD dw;
    Assert(gs_pRandomGenerator);
    gs_pRandomGenerator->Generate(&dw, 1);
    return dw;
    }

/*===================================================================
GenerateRandomDwords

Returns random DWORDs

Parameters
    pdwDwords     array of DWORDs to fill
    cDwords       # of DWORDs

Returns:
    Random number
===================================================================*/
HRESULT GenerateRandomDwords
(
DWORD *pdwDwords, 
DWORD  cDwords
)
    {
    Assert(gs_pRandomGenerator);
    return gs_pRandomGenerator->Generate(pdwDwords, cDwords);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\randgen.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Random number generator

File: randgen.h

Owner: DmitryR

This file contains the definitons for the random number
generator.
===================================================================*/

#ifndef RANDGEN_H
#define RANDGEN_H

// To be called from DllInit()
HRESULT InitRandGenerator();

// To be called from DllUnInit()
HRESULT UnInitRandGenerator();

// The generator funcions
DWORD GenerateRandomDword();
HRESULT GenerateRandomDwords(DWORD *pdwDwords, DWORD cDwords);

#endif // RANDGEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\isapireq.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: CIsapiReqInfo implementation....

File: IsapiReq.cpp

Owner: AndyMorr

===================================================================*/
#include "denpre.h"
#pragma hdrstop

// undef these here so that we can call the WXI and ECB functions with
// the same name and not be victims of the substituition.
 
#undef MapUrlToPath           
#undef GetCustomError         
#undef GetAspMDData           
#undef GetAspMDAllData        
#undef GetServerVariable      

VOID AspDoRevertHack( HANDLE * phToken );
VOID AspUndoRevertHack( HANDLE * phToken );

/*===================================================================
CIsapiReqInfo::QueryPszQueryString
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszQueryString()
{
    return m_pECB->lpszQueryString;
}

/*===================================================================
CIsapiReqInfo::QueryCchQueryString
===================================================================*/
DWORD CIsapiReqInfo::QueryCchQueryString()
{
    if (m_cchQueryString == -1) {
        m_cchQueryString = QueryPszQueryString() ? strlen(QueryPszQueryString()) : 0;
    }

    return m_cchQueryString;
}

/*===================================================================
CIsapiReqInfo::QueryPszApplnMDPathA
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszApplnMDPathA()
{
    if (m_fApplnMDPathAInited == FALSE) {
        *((LPSTR)m_ApplnMDPathA.QueryPtr()) = '\0';
        m_fApplnMDPathAInited = InternalGetServerVariable("APPL_MD_PATH", &m_ApplnMDPathA);
    }

    ASSERT(m_fApplnMDPathAInited);

    return (LPSTR)m_ApplnMDPathA.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchApplnMDPathA
===================================================================*/
DWORD CIsapiReqInfo::QueryCchApplnMDPathA()
{
    if (m_cchApplnMDPathA == -1) {
        m_cchApplnMDPathA = QueryPszApplnMDPathA() 
                                ? strlen(QueryPszApplnMDPathA())
                                : 0;
    }
    
    return(m_cchApplnMDPathA);
}

/*===================================================================
CIsapiReqInfo::QueryPszApplnMDPathW
===================================================================*/
LPWSTR CIsapiReqInfo::QueryPszApplnMDPathW()
{
    if (m_fApplnMDPathWInited == FALSE) {
        *((LPWSTR)m_ApplnMDPathW.QueryPtr()) = L'\0';
        m_fApplnMDPathWInited = InternalGetServerVariable("UNICODE_APPL_MD_PATH", &m_ApplnMDPathW);
    }

    ASSERT(m_fApplnMDPathWInited);

    return (LPWSTR)m_ApplnMDPathW.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchApplnMDPathW
===================================================================*/
DWORD CIsapiReqInfo::QueryCchApplnMDPathW()
{
    if (m_cchApplnMDPathW == -1) {
        m_cchApplnMDPathW = QueryPszApplnMDPathW() 
                                ? wcslen(QueryPszApplnMDPathW())
                                : 0;
    }
    
    return(m_cchApplnMDPathW);
}

/*===================================================================
CIsapiReqInfo::QueryPszPathInfoA
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszPathInfoA()
{
    return m_pECB->lpszPathInfo;
}

/*===================================================================
CIsapiReqInfo::QueryCchPathInfoA
===================================================================*/
DWORD CIsapiReqInfo::QueryCchPathInfoA()
{
    if (m_cchPathInfoA == -1) {
        m_cchPathInfoA = QueryPszPathInfoA()
                            ? strlen(QueryPszPathInfoA())
                            : 0;
    }
    return m_cchPathInfoA;
}

/*===================================================================
CIsapiReqInfo::QueryPszPathInfoW
===================================================================*/
LPWSTR CIsapiReqInfo::QueryPszPathInfoW()
{
    if (m_fPathInfoWInited == FALSE) {
        *((LPWSTR)m_PathInfoW.QueryPtr()) = L'\0';
        m_fPathInfoWInited = InternalGetServerVariable("UNICODE_PATH_INFO", &m_PathInfoW);
    }

    ASSERT(m_fPathInfoWInited);

    return (LPWSTR)m_PathInfoW.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchPathInfoW
===================================================================*/
DWORD CIsapiReqInfo::QueryCchPathInfoW()
{
    if (m_cchPathInfoW == -1) {
        m_cchPathInfoW = QueryPszPathInfoW()
                            ? wcslen(QueryPszPathInfoW())
                            : 0;
    }
    return m_cchPathInfoW;
}

/*===================================================================
CIsapiReqInfo::QueryPszPathTranslatedA
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszPathTranslatedA()
{
    return m_pECB->lpszPathTranslated;
}

/*===================================================================
CIsapiReqInfo::QueryCchPathTranslatedA
===================================================================*/
DWORD CIsapiReqInfo::QueryCchPathTranslatedA()
{
    if (m_cchPathTranslatedA == -1) {
        m_cchPathTranslatedA = QueryPszPathTranslatedA() 
                                ? strlen(QueryPszPathTranslatedA())
                                : 0;
    }

    return m_cchPathTranslatedA;
}

/*===================================================================
CIsapiReqInfo::QueryPszPathTranslatedW
===================================================================*/
LPWSTR CIsapiReqInfo::QueryPszPathTranslatedW()
{
    if (m_fPathTranslatedWInited == FALSE) {
        *((LPWSTR)m_PathTranslatedW.QueryPtr()) = L'\0';
        m_fPathTranslatedWInited = InternalGetServerVariable("UNICODE_PATH_TRANSLATED", &m_PathTranslatedW);
    }

    ASSERT(m_fPathTranslatedWInited);

    return (LPWSTR)m_PathTranslatedW.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchPathTranslatedW
===================================================================*/
DWORD CIsapiReqInfo::QueryCchPathTranslatedW()
{
    if (m_cchPathTranslatedW == -1) {
        m_cchPathTranslatedW = QueryPszPathTranslatedW() 
                                ? wcslen(QueryPszPathTranslatedW())
                                : 0;
    }

    return m_cchPathTranslatedW;
}

/*===================================================================
CIsapiReqInfo::QueryPszCookie
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszCookie()
{
    if (m_fCookieInited == FALSE) {
        *((LPSTR)m_Cookie.QueryPtr()) = '\0';
        InternalGetServerVariable("HTTP_COOKIE", &m_Cookie);
        m_fCookieInited = TRUE;
    }

    return (LPSTR)m_Cookie.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::SetDwHttpStatusCode
===================================================================*/
VOID CIsapiReqInfo::SetDwHttpStatusCode(DWORD  dwStatus)
{
    m_pECB->dwHttpStatusCode = dwStatus;
}

/*===================================================================
CIsapiReqInfo::QueryPbData
===================================================================*/
LPBYTE CIsapiReqInfo::QueryPbData()
{
    return m_pECB->lpbData;
}

/*===================================================================
CIsapiReqInfo::QueryCbAvailable
===================================================================*/
DWORD CIsapiReqInfo::QueryCbAvailable()
{
    return m_pECB->cbAvailable;
}

/*===================================================================
CIsapiReqInfo::QueryCbTotalBytes
===================================================================*/
DWORD CIsapiReqInfo::QueryCbTotalBytes()
{
    return m_pECB->cbTotalBytes;
}

/*===================================================================
CIsapiReqInfo::QueryPszContentType
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszContentType()
{
    return m_pECB->lpszContentType;
}

/*===================================================================
CIsapiReqInfo::QueryPszMethod
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszMethod()
{
    return m_pECB->lpszMethod;
}

/*===================================================================
CIsapiReqInfo::QueryPszUserAgent
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszUserAgent()
{
    if (m_fUserAgentInited == FALSE) {
        *((LPSTR)m_UserAgent.QueryPtr()) = '\0';
        InternalGetServerVariable("HTTP_USER_AGENT", &m_UserAgent);
    }

    return (LPSTR)m_UserAgent.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryInstanceId
===================================================================*/
DWORD CIsapiReqInfo::QueryInstanceId()
{
    if (m_fInstanceIDInited == FALSE) {
        BUFFER  instanceID;
        m_fInstanceIDInited = InternalGetServerVariable("INSTANCE_ID", &instanceID);
        if (m_fInstanceIDInited == TRUE) {
            m_dwInstanceID = atoi((char *)instanceID.QueryPtr());
        }
        else {
            m_dwInstanceID = 1;
        }
    }

    return m_dwInstanceID;
}

/*===================================================================
CIsapiReqInfo::IsChild
===================================================================*/
BOOL CIsapiReqInfo::IsChild()
{

#if _IIS_5_1
    return m_pWXI->IsChild();
#else
    // BUGBUG: This needs to be implemented
#endif

    return FALSE;
}

/*===================================================================
CIsapiReqInfo::FInPool
===================================================================*/
BOOL CIsapiReqInfo::FInPool()
{
#if _IIS_5_1
    return m_pWXI->FInPool();
#else
    DWORD   dwAppFlag;

    if (ServerSupportFunction(HSE_REQ_IS_IN_PROCESS,
                              &dwAppFlag,
                              NULL,
                              NULL) == FALSE) {

        // BUGBUG:  Need to enable this Assert in future builds.
        //Assert(0);

        // if error, the best we can do is return TRUE here so
        // that ASP picks up its settings from the service level
        return TRUE;
    }
    return !(dwAppFlag == HSE_APP_FLAG_ISOLATED_OOP);
#endif

}

/*===================================================================
CIsapiReqInfo::QueryHttpVersionMajor
===================================================================*/
DWORD CIsapiReqInfo::QueryHttpVersionMajor()
{
    InitVersionInfo();

    return m_dwVersionMajor;
}

/*===================================================================
CIsapiReqInfo::QueryHttpVersionMinor
===================================================================*/
DWORD CIsapiReqInfo::QueryHttpVersionMinor()
{
    InitVersionInfo();

    return m_dwVersionMinor;
}

/*===================================================================
CIsapiReqInfo::ISAThreadNotify
===================================================================*/
HRESULT CIsapiReqInfo::ISAThreadNotify(BOOL  fStart)
{
#if _IIS_5_1
    return m_pWXI->ISAThreadNotify(fStart);
#else
    //BUGBUG: Obsolete?
    return S_OK;
#endif
}

/*===================================================================
CIsapiReqInfo::GetAspMDData
===================================================================*/
HRESULT CIsapiReqInfo::GetAspMDDataA(CHAR          * pszMDPath,
                                     DWORD           dwMDIdentifier,
                                     DWORD           dwMDAttributes,
                                     DWORD           dwMDUserType,
                                     DWORD           dwMDDataType,
                                     DWORD           dwMDDataLen,
                                     DWORD           dwMDDataTag,
                                     unsigned char * pbMDData,
                                     DWORD *         pdwRequiredBufferSize)
{
#if _IIS_5_1
    return m_pWXI->GetAspMDData((UCHAR *)pszMDPath,
                                dwMDIdentifier,
                                dwMDAttributes,
                                dwMDUserType,
                                dwMDDataType,
                                dwMDDataLen,
                                dwMDDataTag,
                                pbMDData,
                                pdwRequiredBufferSize);
#else
    return E_NOTIMPL;
#endif
}

/*===================================================================
CIsapiReqInfo::GetAspMDData
===================================================================*/
HRESULT CIsapiReqInfo::GetAspMDDataW(WCHAR         * pszMDPath,
                                     DWORD           dwMDIdentifier,
                                     DWORD           dwMDAttributes,
                                     DWORD           dwMDUserType,
                                     DWORD           dwMDDataType,
                                     DWORD           dwMDDataLen,
                                     DWORD           dwMDDataTag,
                                     unsigned char * pbMDData,
                                     DWORD *         pdwRequiredBufferSize)
{
    IMSAdminBase       *pMetabase;
    METADATA_HANDLE     hKey = NULL;
    METADATA_RECORD     MetadataRecord;
    DWORD               dwTimeout = 2000;
    HRESULT             hr;

    HANDLE hCurrentUser = INVALID_HANDLE_VALUE;
    AspDoRevertHack( &hCurrentUser );

    pMetabase = GetMetabaseIF();

    ASSERT(pMetabase);

    hr = pMetabase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                             pszMDPath,
                             METADATA_PERMISSION_READ,
                             dwTimeout,
                             &hKey
                             );

    ASSERT(SUCCEEDED(hr));

    if( SUCCEEDED(hr) )
    {
        MetadataRecord.dwMDIdentifier = dwMDIdentifier;
        MetadataRecord.dwMDAttributes = dwMDAttributes;
        MetadataRecord.dwMDUserType = dwMDUserType;
        MetadataRecord.dwMDDataType = dwMDDataType;
        MetadataRecord.dwMDDataLen = dwMDDataLen;
        MetadataRecord.pbMDData = pbMDData;
        MetadataRecord.dwMDDataTag = dwMDDataTag;

        hr = pMetabase->GetData( hKey,
                                 L"",
                                 &MetadataRecord,
                                 pdwRequiredBufferSize);

        ASSERT(SUCCEEDED(hr));

        pMetabase->CloseKey( hKey );
    }

    AspUndoRevertHack( &hCurrentUser );

    return hr;
}

/*===================================================================
CIsapiReqInfo::GetAspMDAllData
===================================================================*/
HRESULT CIsapiReqInfo::GetAspMDAllDataA(LPSTR   pszMDPath,
                                        DWORD   dwMDUserType,
                                        DWORD   dwDefaultBufferSize,
                                        LPVOID  pvBuffer,
                                        DWORD * pdwRequiredBufferSize,
                                        DWORD * pdwNumDataEntries)
{
#if _IIS_5_1
    return m_pWXI->GetAspMDAllData(pszMDPath,
                                   dwMDUserType,
                                   dwDefaultBufferSize,
                                   pvBuffer,
                                   pdwRequiredBufferSize,
                                   pdwNumDataEntries);
#else
    return E_NOTIMPL;
#endif
}
    
/*===================================================================
CIsapiReqInfo::GetAspMDAllData
===================================================================*/
HRESULT CIsapiReqInfo::GetAspMDAllDataW(LPWSTR  pwszMDPath,
                                        DWORD   dwMDUserType,
                                        DWORD   dwDefaultBufferSize,
                                        LPVOID  pvBuffer,
                                        DWORD * pdwRequiredBufferSize,
                                        DWORD * pdwNumDataEntries)
{
    
    HRESULT             hr = S_OK;
    IMSAdminBase       *pMetabase;
    METADATA_HANDLE     hKey = NULL;
    DWORD               dwTimeout = 2000;
    DWORD               dwDataSet;

    HANDLE hCurrentUser = INVALID_HANDLE_VALUE;
    AspDoRevertHack( &hCurrentUser );

    //
    // Wide-ize the metabase path
    //

    pMetabase = GetMetabaseIF();

    ASSERT(pMetabase);

    hr = pMetabase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                             pwszMDPath,
                             METADATA_PERMISSION_READ,
                             dwTimeout,
                             &hKey);

    if( SUCCEEDED(hr) ) {
        hr = pMetabase->GetAllData( hKey,
                                    L"",
                                    METADATA_INHERIT,
                                    dwMDUserType,
                                    ALL_METADATA,
                                    pdwNumDataEntries,
                                    &dwDataSet,
                                    dwDefaultBufferSize,
                                    (UCHAR *)pvBuffer,
                                    pdwRequiredBufferSize);
        
        ASSERT(SUCCEEDED(hr));

        pMetabase->CloseKey( hKey );
    }

    AspUndoRevertHack( &hCurrentUser );

    return hr;
}

/*===================================================================
CIsapiReqInfo::GetCustomErrorA
===================================================================*/
BOOL CIsapiReqInfo::GetCustomErrorA(DWORD dwError,
                                    DWORD dwSubError,
                                    DWORD dwBufferSize,
                                    CHAR  *pvBuffer,
                                    DWORD *pdwRequiredBufferSize,
                                    BOOL  *pfIsFileError)
{
#if _IIS_5_1
    return m_pWXI->GetCustomError(dwError,
                                  dwSubError,
                                  dwBufferSize,
                                  pvBuffer,
                                  pdwRequiredBufferSize,
                                  pfIsFileError);
#else
    return E_NOTIMPL;
#endif
}

/*===================================================================
CIsapiReqInfo::GetCustomErrorW
===================================================================*/
BOOL CIsapiReqInfo::GetCustomErrorW(DWORD dwError,
                                    DWORD dwSubError,
                                    DWORD dwBufferSize,
                                    WCHAR *pvBuffer,
                                    DWORD *pdwRequiredBufferSize,
                                    BOOL  *pfIsFileError)
{
#if _IIS_5_1

    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return FALSE;

#else

    BOOL                        fRet;
    HSE_CUSTOM_ERROR_PAGE_INFO  cei;

    STACK_BUFFER(ansiBuf, 1024);

    cei.dwError = dwError;
    cei.dwSubError = dwSubError;
    cei.dwBufferSize = ansiBuf.QuerySize();
    cei.pBuffer = (CHAR *)ansiBuf.QueryPtr();
    cei.pdwBufferRequired = pdwRequiredBufferSize;
    cei.pfIsFileError = pfIsFileError;

    fRet = ServerSupportFunction(HSE_REQ_GET_CUSTOM_ERROR_PAGE,
                                 &cei,
                                 NULL,
                                 NULL);

    if (!fRet) {
        DWORD   dwErr = GetLastError();

        if (dwErr == ERROR_INSUFFICIENT_BUFFER) {

            if (ansiBuf.Resize(*pdwRequiredBufferSize) == FALSE) {
                SetLastError(ERROR_OUTOFMEMORY);
                return FALSE;
            }

            cei.dwBufferSize = ansiBuf.QuerySize();
            cei.pBuffer = (CHAR *)ansiBuf.QueryPtr();

            fRet = ServerSupportFunction(HSE_REQ_GET_CUSTOM_ERROR_PAGE,
                                         &cei,
                                         NULL,
                                         NULL);
        }

        if (!fRet) {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }
    }

    CMBCSToWChar convError;

    if (FAILED(convError.Init((LPCSTR)ansiBuf.QueryPtr()))) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    *pdwRequiredBufferSize = (convError.GetStringLen()+1)*sizeof(WCHAR);
    
    if (*pdwRequiredBufferSize > dwBufferSize) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    memcpy(pvBuffer, convError.GetString(), *pdwRequiredBufferSize);

    if (*pfIsFileError) {

        CMBCSToWChar    convMime;
        DWORD           fileNameLen = *pdwRequiredBufferSize;

        if (FAILED(convMime.Init((LPCSTR)ansiBuf.QueryPtr()+strlen((LPCSTR)ansiBuf.QueryPtr())+1))) {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        *pdwRequiredBufferSize += (convMime.GetStringLen()+1)*sizeof(WCHAR);

        if (*pdwRequiredBufferSize > dwBufferSize) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        memcpy(&((BYTE *)pvBuffer)[fileNameLen], convMime.GetString(), (convMime.GetStringLen()+1)*sizeof(WCHAR));
    }

    return TRUE;

#endif // _IIS_5_1

}

/*===================================================================
CIsapiReqInfo::QueryImpersonationToken
===================================================================*/
HANDLE CIsapiReqInfo::QueryImpersonationToken()
{
    HANDLE  hToken = INVALID_HANDLE_VALUE;

    ServerSupportFunction(HSE_REQ_GET_IMPERSONATION_TOKEN,
                          &hToken,
                          NULL,
                          NULL);

    return hToken;

}

/*===================================================================
CIsapiReqInfo::AppendLogParameter
===================================================================*/
HRESULT CIsapiReqInfo::AppendLogParameter(LPSTR extraParam)
{
    if (ServerSupportFunction(HSE_APPEND_LOG_PARAMETER,
                              extraParam,
                              NULL,
                              NULL) == FALSE) {

        return HRESULT_FROM_WIN32(GetLastError());
    }
    return S_OK;
}

/*===================================================================
CIsapiReqInfo::SendHeader
===================================================================*/
BOOL CIsapiReqInfo::SendHeader(LPVOID pvStatus,
                               DWORD  cchStatus,
                               LPVOID pvHeader,
                               DWORD  cchHeader,
                               BOOL   fIsaKeepConn)
{
    HSE_SEND_HEADER_EX_INFO     HeaderInfo;

    HeaderInfo.pszStatus = (LPCSTR)pvStatus;
    HeaderInfo.cchStatus = cchStatus;
    HeaderInfo.pszHeader = (LPCSTR) pvHeader;
    HeaderInfo.cchHeader = cchHeader;
    HeaderInfo.fKeepConn = fIsaKeepConn;

    return ServerSupportFunction( HSE_REQ_SEND_RESPONSE_HEADER_EX, 
                                  &HeaderInfo, 
                                  NULL, 
                                  NULL ); 
}

/*===================================================================
CIsapiReqInfo::GetServerVariableA
===================================================================*/
BOOL CIsapiReqInfo::GetServerVariableA(LPSTR   szVarName, 
                                       LPSTR   pBuffer, 
                                       LPDWORD pdwSize )
{
    return m_pECB->GetServerVariable( (HCONN)m_pECB->ConnID,
                                      szVarName,
                                      pBuffer,
                                      pdwSize );
}

/*===================================================================
CIsapiReqInfo::GetServerVariableW
===================================================================*/
BOOL CIsapiReqInfo::GetServerVariableW(LPSTR   szVarName, 
                                       LPWSTR  pBuffer, 
                                       LPDWORD pdwSize )
{
    return m_pECB->GetServerVariable( (HCONN)m_pECB->ConnID,
                                      szVarName,
                                      pBuffer,
                                      pdwSize );
}

/*===================================================================
CIsapiReqInfo::ServerSupportFunction
===================================================================*/
BOOL CIsapiReqInfo::ServerSupportFunction(DWORD   dwHSERequest,
                                          LPVOID  pvData, 
                                          LPDWORD pdwSize, 
                                          LPDWORD pdwDataType)
{
    return m_pECB->ServerSupportFunction( (HCONN)m_pECB->ConnID,
                                           dwHSERequest,
                                           pvData, 
                                           pdwSize, 
                                           pdwDataType );
}

/*===================================================================
CIsapiReqInfo::SendEntireResponseOop
===================================================================*/
BOOL CIsapiReqInfo::SendEntireResponseOop(IN HSE_SEND_ENTIRE_RESPONSE_INFO * pHseResponseInfo)
{
#if _IIS_5_1
    return m_pWXI->SendEntireResponseOop(pHseResponseInfo);
#elif _IIS_6_0
    return SendEntireResponse(pHseResponseInfo);
#else
#error "Neither _IIS_5_1 nor _IIS_6_0 is defined"
#endif
}

/*===================================================================
CIsapiReqInfo::SendEntireResponse
===================================================================*/
BOOL CIsapiReqInfo::SendEntireResponse(IN HSE_SEND_ENTIRE_RESPONSE_INFO * pResponseInfo)
{
#if _IIS_5_1
    return m_pWXI->SendEntireResponse(pResponseInfo);
#elif _IIS_6_0


    HRESULT             hr              = S_OK;
    DWORD               nElementCount;
    HSE_VECTOR_ELEMENT  *pVectorElement = NULL;
    HSE_RESPONSE_VECTOR respVector;
    HANDLE              hCurrentUser    = INVALID_HANDLE_VALUE;
    BOOL                fKeepConn;

    STACK_BUFFER ( buffResp, 512);

    //
    // Set the keep connection flag.  It can only be TRUE if the
    // ISAPI and the client both want keep alive.
    //

    fKeepConn = FKeepConn() && pResponseInfo->HeaderInfo.fKeepConn;

    //
    // Munge the input structure into something that IIsapiCore can
    // understand.  Note that ASP sets the number of buffer to be one more
    // than actual and the first buffer is not valid
    //

    nElementCount = pResponseInfo->cWsaBuf - 1;
    if (!buffResp.Resize(nElementCount * sizeof(HSE_VECTOR_ELEMENT)))
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Exit;
    }
    ZeroMemory(buffResp.QueryPtr(),
               nElementCount * sizeof(HSE_VECTOR_ELEMENT));

    pVectorElement = (HSE_VECTOR_ELEMENT *)buffResp.QueryPtr();

    for (DWORD i = 0; i < nElementCount; i++)
    {
        pVectorElement[i].pBuffer = (LPBYTE)pResponseInfo->rgWsaBuf[i+1].buf;
        pVectorElement[i].cbSize = pResponseInfo->rgWsaBuf[i+1].len;
    }

    respVector.dwFlags          = HSE_IO_SYNC
                                    | (!fKeepConn ? HSE_IO_DISCONNECT_AFTER_SEND : 0)
                                    | HSE_IO_SEND_HEADERS;
    respVector.pszStatus        = (LPSTR)pResponseInfo->HeaderInfo.pszStatus;
    respVector.pszHeaders       = (LPSTR)pResponseInfo->HeaderInfo.pszHeader;
    respVector.nElementCount    = nElementCount;
    respVector.lpElementArray   = pVectorElement;

    //
    // Send it
    //

    if (ServerSupportFunction(HSE_REQ_VECTOR_SEND,
                              &respVector,
                              NULL,
                              NULL) == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

 Exit:

    if (FAILED(hr))
    {
        SetLastError((HRESULT_FACILITY(hr) == (HRESULT)FACILITY_WIN32) 
            ? HRESULT_CODE(hr) 
            : ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
#else
#error "Neither _IIS_5_1 nor _IIS_6_0 is defined"
#endif
}

/*===================================================================
CIsapiReqInfo::TestConnection
===================================================================*/
BOOL CIsapiReqInfo::TestConnection(BOOL  *pfIsConnected)
{
    BOOL bRet = TRUE;

    ServerSupportFunction(HSE_REQ_IS_CONNECTED,
                          &bRet,
                          NULL,
                          NULL);
    return bRet;
}

/*===================================================================
CIsapiReqInfo::MapUrlToPathA
===================================================================*/
BOOL CIsapiReqInfo::MapUrlToPathA(LPSTR pBuffer, LPDWORD pdwBytes)
{
    return ServerSupportFunction( HSE_REQ_MAP_URL_TO_PATH, 
                                  pBuffer, 
                                  pdwBytes, 
                                  NULL );
}

/*===================================================================
CIsapiReqInfo::MapUrlToPathW
===================================================================*/
BOOL CIsapiReqInfo::MapUrlToPathW(LPWSTR pBuffer, LPDWORD pdwBytes)
{
    return ServerSupportFunction( HSE_REQ_MAP_UNICODE_URL_TO_PATH, 
                                  pBuffer, 
                                  pdwBytes, 
                                  NULL );
}

/*===================================================================
CIsapiReqInfo::SyncReadClient
===================================================================*/
BOOL CIsapiReqInfo::SyncReadClient(LPVOID pvBuffer, LPDWORD pdwBytes )
{
    return m_pECB->ReadClient(m_pECB->ConnID, pvBuffer, pdwBytes);
}

/*===================================================================
CIsapiReqInfo::SyncWriteClient
===================================================================*/
BOOL CIsapiReqInfo::SyncWriteClient(LPVOID pvBuffer, LPDWORD pdwBytes)
{
    return m_pECB->WriteClient(m_pECB->ConnID, pvBuffer, pdwBytes, HSE_IO_SYNC);
}


/*********************************************************************
PRIVATE FUNCTIONS
*********************************************************************/

/*===================================================================
CIsapiReqInfo::InitVersionInfo
===================================================================*/
void CIsapiReqInfo::InitVersionInfo()
{
    if (m_fVersionInited == FALSE) {

        BUFFER  version;

        m_fVersionInited = TRUE;
        m_dwVersionMajor = 1;
        m_dwVersionMinor = 0;

        if (InternalGetServerVariable("SERVER_PROTOCOL", &version)) {

            char *pVersionStr = (char *)version.QueryPtr();

            if ((strlen(pVersionStr) >= 8)
                && (isdigit((UCHAR)pVersionStr[5]))
                && (isdigit((UCHAR)pVersionStr[7]))) {

                m_dwVersionMajor = pVersionStr[5] - '0';
                m_dwVersionMinor = pVersionStr[7] - '0';
            }
        }
    }
}

/*===================================================================
CIsapiReqInfo::InternalGetServerVariable
===================================================================*/
BOOL CIsapiReqInfo::InternalGetServerVariable(LPSTR pszVarName, BUFFER  *pBuf)
{
    BOOL    bRet;
    DWORD   dwRequiredBufSize = pBuf->QuerySize();

    bRet = m_pECB->GetServerVariable(m_pECB->ConnID,
                                     pszVarName,
                                     pBuf->QueryPtr(),
                                     &dwRequiredBufSize);

    if ((bRet == FALSE) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        if (!pBuf->Resize(dwRequiredBufSize)) {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        bRet = m_pECB->GetServerVariable(m_pECB->ConnID,
                                         pszVarName,
                                         pBuf->QueryPtr(),
                                         &dwRequiredBufSize);
    }

    return(bRet);
}

/*===================================================================
CIsapiReqInfo::FKeepConn
===================================================================*/
BOOL CIsapiReqInfo::FKeepConn()
{
    if (m_fFKeepConnInited == FALSE) {

        m_fFKeepConnInited = TRUE;
        m_fKeepConn = FALSE;

        InitVersionInfo();

        if (m_dwVersionMajor == 1) {

            if (m_dwVersionMinor == 1) {
                m_fKeepConn = TRUE;
            }

            BUFFER  connectStr;

            if (InternalGetServerVariable("HTTP_CONNECTION", &connectStr)) {

                if (m_dwVersionMinor == 0) {

                    m_fKeepConn = !(_stricmp((char *)connectStr.QueryPtr(), "keep-alive"));
                }
                else if (m_dwVersionMinor == 1) {

                    m_fKeepConn = !!(_stricmp((char *)connectStr.QueryPtr(), "close"));
                }
            }
        }
    }

    return m_fKeepConn;
}

/*===================================================================
CIsapiReqInfo::GetMetabaseIF
===================================================================*/
IMSAdminBase   *CIsapiReqInfo::GetMetabaseIF()
{
    if (m_pIAdminBase == NULL) {
        HRESULT hr = CoCreateInstance(CLSID_MSAdminBase,
                                      NULL,
                                      CLSCTX_ALL,
                                      IID_IMSAdminBase,
                                      (void**)&m_pIAdminBase);

        ASSERT(SUCCEEDED(hr));
    }
    return m_pIAdminBase;
}
//
// Lifted directly from IIS 5.x...
// 
// (Un)DoRevertHack
//
// To prevent RPC token cache from growing without limit (and aging), we
// need to revert to self before calling back to inetinfo.exe.
//
// Now there is a new need to do this. As it turns out the performance
// hit we take from RPC caching these tokens is very significant.
// Ultimately we might want to implement a caching scheme ourselves so
// that the token we use is always the same for the same user identity,
// but that is a big change and this (although ugly as hell) works
// and has been tested for months.
//

VOID AspDoRevertHack( HANDLE * phToken )
{
    if ( OpenThreadToken( GetCurrentThread(),
                          TOKEN_IMPERSONATE,
                          TRUE,
                          phToken ) )
    {
        RevertToSelf();
    }
    else
    {
/*        
        DBGPRINTF((
            DBG_CONTEXT,
            "[DoRevertHack] OpenThreadToken failed.  Error %d.\r\n",
            GetLastError()
            ));
*/
        *phToken = INVALID_HANDLE_VALUE;
    }
}

VOID AspUndoRevertHack( HANDLE * phToken )
{
    if ( !*phToken || ( *phToken == INVALID_HANDLE_VALUE ) )
    {
        return;
    }

    SetThreadToken( NULL,
                    *phToken );

    CloseHandle( *phToken );

    *phToken = INVALID_HANDLE_VALUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\memcls.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Per-Class Memory Management

File: Memcls.cpp

Owner: dmitryr

This file contains the code to access ATQ memory cache on per
class basis
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "asperror.h"
#include "clcert.h"
#include "context.h"
#include "cookies.h"
#include "request.h"
#include "response.h"
#include "server.h"
#include "strlist.h"
#include "tlbcache.h"
#include "memcls.h"

// Don't #include "memchk.h" in this file

/*===================================================================
  DEBUG only

  gs_cTotalObjectsLeaked counts memory leaks

  DebugCheckLeaks() outputs the ATQ cache memory
  leaks into denmem.log

  DEBUG_ACACHE_UNINIT() and DEBUG_ACACHE_FSA_UNINIT() call
  DebugCheckLeaks() in DEBUG mode only
===================================================================*/

#ifdef DBG

static DWORD gs_cTotalObjectsLeaked = 0;

#define SZ_MEMCLS_LOG_FILE  "C:\\TEMP\\MEMCLS.LOG"

static void DebugCheckLeaks(ALLOC_CACHE_HANDLER *pach, const char *szClass)
    {
    ALLOC_CACHE_STATISTICS acStats;
    pach->QueryStats(&acStats);
    DWORD cLeaked = acStats.nTotal - acStats.nFreeEntries;

    if (cLeaked > 0)
        {
        gs_cTotalObjectsLeaked += cLeaked;
        
        DebugFilePrintf
            (
            SZ_MEMCLS_LOG_FILE, 
            "MEMCLS: ATQ allocation cache leak: %d of %s objects.\n",
            cLeaked,
            szClass
            );
        }
    }

#define DEBUG_ACACHE_UNINIT(C)      { DebugCheckLeaks(C::sm_pach, #C);  \
                                      ACACHE_UNINIT(C) }
#define DEBUG_ACACHE_FSA_UNINIT(C)  { DebugCheckLeaks(g_pach##C, #C);   \
                                      ACACHE_FSA_UNINIT(C) }
#else

#define DEBUG_ACACHE_UNINIT(C)      ACACHE_UNINIT(C)
#define DEBUG_ACACHE_FSA_UNINIT(C)  ACACHE_FSA_UNINIT(C)

#endif

/*===================================================================
  For each class with ACACHE_INCLASS_DEFINITIONS() inside add
  here ACACHE_CODE macro.
===================================================================*/

ACACHE_CODE(C449Cookie)
ACACHE_CODE(C449File)
ACACHE_CODE(CASEElem)
ACACHE_CODE(CActiveScriptEngine)
ACACHE_CODE(CAppln)
ACACHE_CODE(CApplnVariants)
ACACHE_CODE(CASPError)
ACACHE_CODE(CClCert)
ACACHE_CODE(CComponentCollection)
ACACHE_CODE(CComponentObject)
ACACHE_CODE(CCookie)
ACACHE_CODE(CDebugResponseBuffer)
ACACHE_CODE(CEngineDispElem)
ACACHE_CODE(CFileApplnList)
ACACHE_CODE(CHitObj)
ACACHE_CODE(CHTTPHeader)
ACACHE_CODE(CIsapiReqInfo)
ACACHE_CODE(CPageComponentManager)
ACACHE_CODE(CPageObject)
ACACHE_CODE(CRequest)
ACACHE_CODE(CRequestData)
ACACHE_CODE(CRequestHit)
ACACHE_CODE(CResponse)
ACACHE_CODE(CResponseBuffer)
ACACHE_CODE(CResponseData)
ACACHE_CODE(CScriptingNamespace)
ACACHE_CODE(CScriptingContext)
ACACHE_CODE(CServer)
ACACHE_CODE(CServerData)
ACACHE_CODE(CSession)
ACACHE_CODE(CSessionVariants)
ACACHE_CODE(CStringList)
ACACHE_CODE(CStringListElem)
ACACHE_CODE(CTemplate)
//ACACHE_CODE(CTemplate::CBuffer)
ACACHE_CODE(CTemplate::CFileMap)
ACACHE_CODE(CTypelibCacheEntry)
ACACHE_CODE(CVariantsIterator)
ACACHE_CODE(CViperActivity)
ACACHE_CODE(CViperAsyncRequest)

/*===================================================================
  For each fixed size allocator add here ACACHE_FSA_DEFINITION macro.
===================================================================*/

ACACHE_FSA_DEFINITION(MemBlock128)
ACACHE_FSA_DEFINITION(MemBlock256)
ACACHE_FSA_DEFINITION(ResponseBuffer)

/*===================================================================
  Defines for cache threshold of each kind
===================================================================*/
#define HARDCODED_PER_APPLN_CACHE_MAX     128
#define HARDCODED_PER_REQUEST_CACHE_MAX   1024
#define HARDCODED_PER_QUEUEITEM_CACHE_MAX 8192
#define HARDCODED_PER_SESSION_CACHE_MAX   8192
#define HARDCODED_PER_SCRPTENG_CACHE_MAX  256
#define HARDCODED_PER_TEMPLATE_CACHE_MAX  2048
#define HARDCODED_PER_RESPONSE_BUFFER_MAX 64
#define HARDCODED_PER_SIZE_BUFFER_MAX     4096

// do scaling per registry setting
DWORD dwMemClsScaleFactor;

#define PER_APPLN_CACHE_MAX     ((HARDCODED_PER_APPLN_CACHE_MAX     * dwMemClsScaleFactor) / 100)
#define PER_REQUEST_CACHE_MAX   ((HARDCODED_PER_REQUEST_CACHE_MAX   * dwMemClsScaleFactor) / 100)
#define PER_QUEUEITEM_CACHE_MAX ((HARDCODED_PER_QUEUEITEM_CACHE_MAX * dwMemClsScaleFactor) / 100)
#define PER_SESSION_CACHE_MAX   ((HARDCODED_PER_SESSION_CACHE_MAX   * dwMemClsScaleFactor) / 100)
#define PER_SCRPTENG_CACHE_MAX  ((HARDCODED_PER_SCRPTENG_CACHE_MAX  * dwMemClsScaleFactor) / 100)
#define PER_TEMPLATE_CACHE_MAX  ((HARDCODED_PER_TEMPLATE_CACHE_MAX  * dwMemClsScaleFactor) / 100)
#define PER_RESPONSE_BUFFER_MAX ((HARDCODED_PER_RESPONSE_BUFFER_MAX * dwMemClsScaleFactor) / 100)
#define PER_SIZE_BUFFER_MAX     ((HARDCODED_PER_SIZE_BUFFER_MAX     * dwMemClsScaleFactor) / 100)

/*===================================================================
InitMemCls

To be called from DllInit(). Creates per-class ATQ memory allocators.

For each class with ACACHE_INCLASS_DEFINITIONS() inside add
here ACACHE_INIT macro.

For each ACACHE_FSA_DEFINITION() add here ACACHE_FSA_INIT macro.

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT InitMemCls()
    {
    // Set the scaling to normal
    dwMemClsScaleFactor = 100;

    // Init the allocators
    
    HRESULT hr = S_OK;

    ACACHE_INIT(C449Cookie,             PER_TEMPLATE_CACHE_MAX/4, hr)
    ACACHE_INIT(C449File,               PER_TEMPLATE_CACHE_MAX/4, hr)
    ACACHE_INIT(CASEElem,               PER_SCRPTENG_CACHE_MAX, hr)
    ACACHE_INIT(CActiveScriptEngine,    PER_SCRPTENG_CACHE_MAX, hr)
    ACACHE_INIT_EX(CAppln,              PER_APPLN_CACHE_MAX,    FALSE, hr)
    ACACHE_INIT(CApplnVariants,         PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CASPError,              PER_RESPONSE_BUFFER_MAX,hr)
    ACACHE_INIT(CClCert,                PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CComponentCollection,   PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CComponentObject,     2*PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CCookie,                PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CDebugResponseBuffer,   PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CEngineDispElem,        PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CFileApplnList,       2*PER_APPLN_CACHE_MAX,    hr)
    ACACHE_INIT(CHitObj,                PER_QUEUEITEM_CACHE_MAX,hr)
    ACACHE_INIT(CHTTPHeader,          2*PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CIsapiReqInfo,          PER_QUEUEITEM_CACHE_MAX,hr)
    ACACHE_INIT(CPageComponentManager,  PER_QUEUEITEM_CACHE_MAX,hr)
    ACACHE_INIT(CPageObject,            PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CRequest,               PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CRequestData,           PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CRequestHit,            PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CResponse,              PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CResponseBuffer,        PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CResponseData,          PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CScriptingContext,      PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CScriptingNamespace,    PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CServer,                PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CServerData,            PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT_EX(CSession,            PER_SESSION_CACHE_MAX,  FALSE, hr)
    ACACHE_INIT(CSessionVariants,       PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CStringList,            PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CStringListElem,      2*PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CTemplate,              PER_TEMPLATE_CACHE_MAX, hr)
//    ACACHE_INIT(CTemplate::CBuffer,     PER_TEMPLATE_CACHE_MAX, hr)
    ACACHE_INIT(CTemplate::CFileMap,    PER_TEMPLATE_CACHE_MAX, hr)
    ACACHE_INIT(CTypelibCacheEntry,     PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CVariantsIterator,      PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CViperActivity,         PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CViperAsyncRequest,     PER_QUEUEITEM_CACHE_MAX,hr)
    
    ACACHE_FSA_INIT(MemBlock128,    128,                  PER_SIZE_BUFFER_MAX,     hr)
    ACACHE_FSA_INIT(MemBlock256,    256,                  PER_SIZE_BUFFER_MAX,     hr)
    ACACHE_FSA_INIT(ResponseBuffer, RESPONSE_BUFFER_SIZE, PER_RESPONSE_BUFFER_MAX, hr)

#ifdef DBG
    unlink(SZ_MEMCLS_LOG_FILE);

    DebugFilePrintf
        (
        SZ_MEMCLS_LOG_FILE, 
        "MEMCLS: ATQ allocation cache inited with HRESULT=%08x.\n",
        hr
        );
#endif

    return hr;
    }

/*===================================================================
UnInitMemCls

To be called from DllInit(). Deletes per-class ATQ memory allocators.

For each class with ACACHE_INCLASS_DEFINITIONS() inside add
here ACACHE_UNINIT macro.

For each ACACHE_FSA_DEFINITION() add here ACACHE_FSA_UNINIT macro.

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT UnInitMemCls()
    {
#ifdef DBG
    gs_cTotalObjectsLeaked = 0;
#endif

    DEBUG_ACACHE_UNINIT(C449Cookie)
    DEBUG_ACACHE_UNINIT(C449File)
    DEBUG_ACACHE_UNINIT(CASEElem)
    DEBUG_ACACHE_UNINIT(CActiveScriptEngine)
    DEBUG_ACACHE_UNINIT(CAppln)
    DEBUG_ACACHE_UNINIT(CApplnVariants)
    DEBUG_ACACHE_UNINIT(CASPError)
    DEBUG_ACACHE_UNINIT(CClCert)
    DEBUG_ACACHE_UNINIT(CComponentCollection)
    DEBUG_ACACHE_UNINIT(CComponentObject)
    DEBUG_ACACHE_UNINIT(CCookie)
    DEBUG_ACACHE_UNINIT(CDebugResponseBuffer)
    DEBUG_ACACHE_UNINIT(CEngineDispElem)
    DEBUG_ACACHE_UNINIT(CFileApplnList)
    DEBUG_ACACHE_UNINIT(CHitObj)
    DEBUG_ACACHE_UNINIT(CHTTPHeader)
    DEBUG_ACACHE_UNINIT(CIsapiReqInfo)
    DEBUG_ACACHE_UNINIT(CPageComponentManager)
    DEBUG_ACACHE_UNINIT(CPageObject)
    DEBUG_ACACHE_UNINIT(CRequest)
    DEBUG_ACACHE_UNINIT(CRequestData)
    DEBUG_ACACHE_UNINIT(CRequestHit)
    DEBUG_ACACHE_UNINIT(CResponse)
    DEBUG_ACACHE_UNINIT(CResponseBuffer)
    DEBUG_ACACHE_UNINIT(CResponseData)
    DEBUG_ACACHE_UNINIT(CScriptingNamespace)
    DEBUG_ACACHE_UNINIT(CScriptingContext)
    DEBUG_ACACHE_UNINIT(CServer)
    DEBUG_ACACHE_UNINIT(CServerData)
    DEBUG_ACACHE_UNINIT(CSession)
    DEBUG_ACACHE_UNINIT(CSessionVariants)
    DEBUG_ACACHE_UNINIT(CStringList)
    DEBUG_ACACHE_UNINIT(CStringListElem)
    DEBUG_ACACHE_UNINIT(CTemplate)
//    DEBUG_ACACHE_UNINIT(CTemplate::CBuffer)
    DEBUG_ACACHE_UNINIT(CTemplate::CFileMap)
    DEBUG_ACACHE_UNINIT(CTypelibCacheEntry)
    DEBUG_ACACHE_UNINIT(CVariantsIterator)
    DEBUG_ACACHE_UNINIT(CViperActivity)
    DEBUG_ACACHE_UNINIT(CViperAsyncRequest)

    DEBUG_ACACHE_FSA_UNINIT(MemBlock128)
    DEBUG_ACACHE_FSA_UNINIT(MemBlock256)
    DEBUG_ACACHE_FSA_UNINIT(ResponseBuffer)

#ifdef DBG
    DebugFilePrintf
        (
        SZ_MEMCLS_LOG_FILE,
        "MEMCLS: ATQ allocation cache uninited.\n"
        "MEMCLS: Total of %d ASP objects leaked.\n",
        gs_cTotalObjectsLeaked
        );
#endif

    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\listmgr.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: List Allocater Template

File: Listmgr.h

Owner: PramodD

This is the List Allocator template header file.
It manages memory requests by allocating from a array/linklist.
The size of the initial array is a parameter to the constructor.
===================================================================*/
#ifndef LISTMGR_H
#define LISTMGR_H

#ifdef PAGESIZE
#undef PAGESIZE
#endif

#define PAGESIZE    4096

// Allocation unit
template <class T>
class CListElem
{
private:
    T       m_Element;  // The actual element we want to allocate
    T *     m_pNext;    // Next element in free list
    
public:
    void    SetNext(CListElem<T> * element);
    T *     GetNext(void);
};

// Member access functions
template <class T>
inline void CListElem<T>::SetNext(CListElem<T> * element) { m_pNext = (T *) element; }

template <class T>
inline T * CListElem<T>::GetNext( void ) { return m_pNext; }

// Single Threaded List Manager

template <class T>
class CSTList
{
private:
    CListElem<T> *  m_pFreeHead;
    CListElem<T> *  m_pAllocHead;
    UINT            m_cFree;
    UINT            m_cUsed;
    UINT            m_cSize;

public:
    CSTList(void);

private:
    void    MakeLinks(CListElem<T> * TArray, UINT cSize);
    HRESULT GrabMemory(UINT cSize);

public:
    HRESULT Init(UINT cSize=0);     // Initial allocation
    HRESULT UnInit(void);           // Release memory
    T *     Allocate(void);         // Allocate one element
    T *     ReAlloc(UINT cSize=0);  // Allocate memory if needed
    void    Free( T * element );    // Free one element
    UINT    FreeCount(void);        // Number of free elements
    UINT    UsedCount(void);        // Number of used elements
    UINT    Size(void);             // Number of elements
};

// Constructor
template <class T>
CSTList<T>::CSTList( void )
{
    m_pFreeHead = NULL;
    m_pAllocHead = NULL;
    m_cFree = 0;
    m_cUsed = 0;
    m_cSize = 0;
}

template <class T>
void CSTList<T>::MakeLinks( CListElem<T> *TArray, UINT cSize )
{
    CListElem<T> *  pT = TArray;
    UINT            i = 0;

    m_cSize += cSize;
    m_cFree += cSize;

    // Initialize link list
    while ( i < cSize - 1 )
    {
        pT->SetNext( pT + 1 );
        pT++;
        i++;
    }
    if ( m_pFreeHead )
        pT->SetNext( m_pFreeHead );
    else
        pT->SetNext( pT + 1 );

    m_pFreeHead = TArray;
}

template <class T>
HRESULT CSTList<T>::GrabMemory( UINT cSize )
{
    CListElem<T> *  pT;
    UINT cT;
    
    if ( cSize )
        cT = cSize;
    else
        cT = PAGESIZE/sizeof(CListElem<T>);

    if ( pT = (CListElem<T> *) GlobalAlloc( GPTR, sizeof( CListElem<T> ) * (cT + 1) ) )
    {
        pT->SetNext( m_pAllocHead );
        m_pAllocHead = pT;
        pT++;
        MakeLinks( pT, cT );
        return S_OK;
    }
    return E_FAIL;
}

// Initialization
template <class T>
inline HRESULT CSTList<T>::Init( UINT cSize = 0 ) { return GrabMemory( cSize ); }

// Free all memory, All allocated elements should have been
// returned to the list. Otherwise it returns E_FAIL.
template <class T>
HRESULT CSTList<T>::UnInit( void )
{
    HRESULT         hr = S_OK;
    CListElem<T> *  pT;

    // Free all the memory
    while ( m_pAllocHead )
    {
        pT = (CListElem<T> *) m_pAllocHead->GetNext();
        GlobalFree( (HGLOBAL) m_pAllocHead );
        m_pAllocHead = pT;
    }
    m_pFreeHead = NULL;

    // Check for memory leaks
    if ( m_cSize != m_cFree )
        hr = E_FAIL;

    m_cSize = 0;
    m_cFree = 0;
    m_cUsed = 0;

    return hr;
}

// Allocate element from array
template <class T>
T * CSTList<T>::Allocate( void )
{
    if ( m_cFree == 0 )
        return NULL;

    CListElem<T> * pT = m_pFreeHead;

    m_pFreeHead = (CListElem<T> *) pT->GetNext();
    pT->SetNext( NULL );
    m_cFree--;
    m_cUsed++;

    return (T *) pT;
}

// Allocate element from array, get more memory if needed
template <class T>
T * CSTList<T>::ReAlloc( UINT cSize = 0 )
{
    if ( m_cFree == 0 )
        GrabMemory(cSize);
    return Allocate();
}

// Return element to array
template <class T>
void CSTList<T>::Free( T *element )
{
    if ( element == NULL || m_cUsed == 0 )
        return;

    CListElem<T> * pT = (CListElem<T> *) element;

    if ( pT->GetNext() == NULL )
    {
        pT->SetNext( m_pFreeHead );
        m_pFreeHead = pT;
        m_cUsed--;
        m_cFree++;
    }
}

// Member access functions
template <class T>
inline UINT CSTList<T>::FreeCount( void ) { return m_cFree; }

template <class T>
inline UINT CSTList<T>::UsedCount( void ) { return m_cUsed; }

template <class T>
inline UINT CSTList<T>::Size( void ) {  return m_cSize; }



// Multi Threaded List Manager

template <class T>
class CMTList: private CSTList<T>
{
    // Synchronization objects
private:
    BOOL                m_fInited;
    CRITICAL_SECTION    m_csList;
    HANDLE              m_hBlockedReaders;
    HANDLE              m_hBlockedWriters;

    // Counters
private:
    int     m_cActiveReaders;
    int     m_cWaitingReaders;
    int     m_cActiveWriters;
    int     m_cWaitingWriters;

    // Public constructor and destructor
public:
            CMTList(void) { m_fInited = FALSE; }
    virtual ~CMTList( void );

    // Private synchronization functions
private:
    void    ReadLock(void);         // Lock List access for read
    void    WriteLock(void);        // Lock List access for write
    void    ReleaseReadLock(void);  // Unlock read access
    void    ReleaseWriteLock(void); // Unlock write access

    // Public List functions
public:
    HRESULT Init( int cSize = 0 );// Initial allocation
    HRESULT UnInit(void);           // Free all memory
    T *     Allocate(void);         // Allocate one element
    T *     ReAlloc(UINT cSize=0);  // Allocate more memory if needed
    void    Free(T *element);       // Free one element
    UINT    FreeCount(void);        // Number of free elements
    UINT    UsedCount(void);        // Number of used elements
    UINT    Size(void);             // Total number of elements
};

template <class T>
HRESULT CMTList<T>::Init( int cSize = 0 )
{
    HRESULT hr;
    
    // Initialize synchronization objects
    ErrInitCriticalSection( &m_csList, hr );
    if ( FAILED( hr ) )
        return hr;

    m_hBlockedReaders = IIS_CREATE_SEMAPHORE(
                            "CMTList<T>::m_hBlockedReaders",
                            this,
                            0L,
                            9999L
                            );
        
    m_hBlockedWriters = IIS_CREATE_SEMAPHORE(
                            "CMTList<T>::m_hBlockedWriters",
                            this,
                            0L,
                            9999L
                            );
        
    if ( m_hBlockedReaders && m_hBlockedWriters )
    {
        // Initialize counters
        m_cActiveReaders = 0;
        m_cWaitingReaders = 0;
        m_cActiveWriters = 0;
        m_cWaitingWriters = 0;
        m_fInited = TRUE;

        if ( SUCCEEDED( CSTList<T>::Init(cSize) ) )
            return S_OK;
    }
    return E_FAIL;
}

template <class T>
HRESULT CMTList<T>::UnInit( void )
{
    if ( !m_fInited )
        return E_FAIL;

    WriteLock();
    HRESULT hr = CSTList<T>::UnInit();
    ReleaseWriteLock();
    return hr;
}

template <class T>
CMTList<T>::~CMTList( void )
{
    if ( m_fInited )
    {
        // Destroy synchronization objects
        DeleteCriticalSection( &m_csList );
        CloseHandle( m_hBlockedReaders );
        CloseHandle( m_hBlockedWriters );
    }
}

template <class T>
void CMTList<T>::ReadLock( void )
{
    if ( !m_fInited )
        return;

    EnterCriticalSection( &m_csList );
    if ( m_cActiveWriters > 0 || m_cWaitingWriters > 0 )
    {
        m_cWaitingReaders++;
        LeaveCriticalSection( &m_csList );
        WaitForSingleObject( m_hBlockedReaders, INFINITE );
    }
    else
    {
        m_cActiveReaders++;
        LeaveCriticalSection( &m_csList );
    }
}

template <class T>
void CMTList<T>::ReleaseReadLock( void )
{
    if ( !m_fInited )
        return;

    EnterCriticalSection( &m_csList );
    m_cActiveReaders--;
    if ( m_cActiveReaders == 0 && m_cWaitingWriters > 0 )
    {
        m_cActiveWriters = 1;
        m_cWaitingWriters = 0;
        ReleaseSemaphore( m_hBlockedWriters, 1, NULL );
    }
    LeaveCriticalSection( &m_csList );
}

template <class T>
void CMTList<T>::WriteLock( void )
{
    if ( !m_fInited )
        return;

    EnterCriticalSection( &m_csList );
    if ( m_cActiveReaders == 0 && m_cActiveWriters == 0 )
    {
        m_cActiveWriters = 1;
        LeaveCriticalSection( &m_csList );
    }
    else
    {
        m_cWaitingWriters++;
        LeaveCriticalSection( &m_csList );
        WaitForSingleObject( m_hBlockedWriters, INFINITE );
    }
}

template <class T>
void CMTList<T>::ReleaseWriteLock( void )
{
    if ( !m_fInited )
        return;

    EnterCriticalSection( &m_csList );
    m_cActiveWriters = 0;
    if ( m_cWaitingReaders > 0 )
    {
        m_cActiveReaders = m_cWaitingReaders;
        m_cWaitingReaders = 0;
        ReleaseSemaphore( m_hBlockedReaders, m_cActiveReaders, NULL );
    }
    else if ( m_cWaitingWriters > 0 )
    {
        m_cWaitingWriters--;
        ReleaseSemaphore( m_hBlockedWriters, 1, NULL );
    }
    LeaveCriticalSection( &m_csList );
}

template <class T>
T * CMTList<T>::Allocate( void )
{
    if ( !m_fInited )
        return NULL;

    WriteLock();
    T * retVal = CSTList<T>::Allocate();
    ReleaseWriteLock();
    return retVal;
}

template <class T>
T * CMTList<T>::ReAlloc( UINT cSize = 0 )
{
    if ( !m_fInited )
        return NULL;

    WriteLock();
    T * retVal = CSTList<T>::ReAlloc( cSize );
    ReleaseWriteLock();
    return retVal;
}

template <class T>
void CMTList<T>::Free( T *element )
{
    if ( !m_fInited )
        return;

    WriteLock();
    CSTList<T>::Free( element );
    ReleaseWriteLock();
}

template <class T>
UINT CMTList<T>::FreeCount( void )
{
    if ( !m_fInited )
        return 0;

    ReadLock();
    UINT retVal = CSTList<T>::FreeCount();
    ReleaseReadLock();
    return retVal;
}

template <class T>
UINT CMTList<T>::UsedCount( void )
{
    if ( !m_fInited )
        return 0;

    ReadLock();
    UINT retVal = CSTList<T>::UsedCount();
    ReleaseReadLock();
    return retVal;
}

template <class T>
UINT CMTList<T>::Size( void )
{
    if ( !m_fInited )
        return 0;

    ReadLock();
    UINT retVal = CSTList<T>::Size();
    ReleaseReadLock();
    return retVal;
}

#endif // LISTMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\perfdata.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: perfdata.h

Owner: DmitryR

PERFMON related data in asp.dll -- header file
===================================================================*/

#ifndef _ASP_PERFDATA_H
#define _ASP_PERFDATA_H

#ifndef PERF_DISABLE

#include "perfdef.h"
#include "denali.h"

// Counter offsets in the array

#define ID_DEBUGDOCREQ      0
#define ID_REQERRRUNTIME    1
#define ID_REQERRPREPROC    2
#define ID_REQERRCOMPILE    3
#define ID_REQERRORPERSEC   4
#define ID_REQTOTALBYTEIN   5
#define ID_REQTOTALBYTEOUT  6
#define ID_REQEXECTIME      7
#define ID_REQWAITTIME      8
#define ID_REQCOMFAILED     9
#define ID_REQBROWSEREXEC   10
#define ID_REQFAILED        11
#define ID_REQNOTAUTH       12
#define ID_REQNOTFOUND      13
#define ID_REQCURRENT       14
#define ID_REQREJECTED      15
#define ID_REQSUCCEEDED     16
#define ID_REQTIMEOUT       17
#define ID_REQTOTAL         18
#define ID_REQPERSEC        19
#define ID_SCRIPTFREEENG    20
#define ID_SESSIONLIFETIME  21
#define ID_SESSIONCURRENT   22
#define ID_SESSIONTIMEOUT   23
#define ID_SESSIONSTOTAL    24
#define ID_TEMPLCACHE       25
#define ID_TEMPLCACHEHITS   26
#define ID_TEMPLCACHETRYS   27
#define ID_TEMPLFLUSHES     28
#define ID_TRANSABORTED     29
#define ID_TRANSCOMMIT      30
#define ID_TRANSPENDING     31
#define ID_TRANSTOTAL       32
#define ID_TRANSPERSEC      33
#define ID_MEMORYTEMPLCACHE   34
#define ID_MEMORYTEMPLCACHEHITS 35
#define ID_MEMORYTEMPLCACHETRYS 36

/*===================================================================
CPerfData -- PERFMON data for ASP
             CPerfProcBlock 
                + macros to update counters
                + clsid to remember
                + place to update counters before perfmon inited
===================================================================*/

class CPerfData : public CPerfProcBlock
    {
private:
    // Initial counter values (gathered when uninit)
    DWORD m_rgdwInitCounters[C_PERF_PROC_COUNTERS];
    // CLSID
    DWORD m_fValid : 1;
    CLSID m_ClsId;

public:
    inline CPerfData() 
        : m_fValid(FALSE)
        {
        memset(m_rgdwInitCounters, 0, CB_COUNTERS);
        }

    inline ~CPerfData()
        {
        }

    inline HRESULT Init(const CLSID &ClsId)
        {
        HRESULT hr = InitForThisProcess(ClsId, m_rgdwInitCounters);
        if (SUCCEEDED(hr))
            {
            m_ClsId = ClsId;
            m_fValid = TRUE;
            }
        return hr;
        }

    inline HRESULT UnInit()
        {
        m_fValid = FALSE;
        return CPerfProcBlock::UnInit();
        }

    inline BOOL FValid()
        {
        return m_fValid;
        }

    inline const CLSID & ClsId()
        {
        return m_ClsId;
        }

    // helper inline to get counter address as DWORD *
    inline DWORD *PDWCounter(int i)
        {
        return m_fInited ? &(m_pData->m_rgdwCounters[i])
                         : &(m_rgdwInitCounters[i]);
        }
    
    // helper inline to get counter address as LPLONG
    inline LPLONG PLCounter(int i)
        {
        return (LPLONG)PDWCounter(i);
        }

    // Inlines to change individual counters --------------

    inline void Incr_DEBUGDOCREQ()
        {
        InterlockedIncrement(PLCounter(ID_DEBUGDOCREQ));
        }
    inline void Incr_REQERRRUNTIME()
        {
        InterlockedIncrement(PLCounter(ID_REQERRRUNTIME));
        }
    inline void Incr_REQERRPREPROC()
        {
        InterlockedIncrement(PLCounter(ID_REQERRPREPROC));
        }
    inline void Incr_REQERRCOMPILE()
        {
        InterlockedIncrement(PLCounter(ID_REQERRCOMPILE));
        }
    inline void Incr_REQERRORPERSEC()
        {
        InterlockedIncrement(PLCounter(ID_REQERRORPERSEC));
        }
    inline void Add_REQTOTALBYTEIN(DWORD dw)
        {
        EnterCriticalSection(&m_csReqLock);
        *PDWCounter(ID_REQTOTALBYTEIN) += dw;
    	LeaveCriticalSection(&m_csReqLock);
        }
    inline void Add_REQTOTALBYTEOUT(DWORD dw)
        {
        EnterCriticalSection(&m_csReqLock);
        *PDWCounter(ID_REQTOTALBYTEOUT) += dw;
    	LeaveCriticalSection(&m_csReqLock);
        }
    inline void Set_REQEXECTIME(DWORD dw)
        {
        InterlockedExchange(PLCounter(ID_REQEXECTIME), (LONG)dw);
        }
    inline void Set_REQWAITTIME(DWORD dw)
        {
        InterlockedExchange(PLCounter(ID_REQWAITTIME), (LONG)dw);
        }
    inline void Incr_REQCOMFAILED()
        {
        InterlockedIncrement(PLCounter(ID_REQCOMFAILED));
        }
    inline void Incr_REQBROWSEREXEC()
        {
        InterlockedIncrement(PLCounter(ID_REQBROWSEREXEC));
        }
    inline void Decr_REQBROWSEREXEC()
        {
        InterlockedDecrement(PLCounter(ID_REQBROWSEREXEC));
        }
    inline void Incr_REQFAILED()
        {
        InterlockedIncrement(PLCounter(ID_REQFAILED));
        }
    inline void Incr_REQNOTAUTH()
        {
        InterlockedIncrement(PLCounter(ID_REQNOTAUTH));
        }
    inline void Incr_REQNOTFOUND()
        {
        InterlockedIncrement(PLCounter(ID_REQNOTFOUND));
        }
    inline DWORD Incr_REQCURRENT()
        {
        return InterlockedIncrement(PLCounter(ID_REQCURRENT));
        }
    inline void Decr_REQCURRENT()
        {
        InterlockedDecrement(PLCounter(ID_REQCURRENT));
        }
    inline void Incr_REQREJECTED()
        {
        InterlockedIncrement(PLCounter(ID_REQREJECTED));
        }
    inline void Incr_REQSUCCEEDED()
        {
        InterlockedIncrement(PLCounter(ID_REQSUCCEEDED));
        }
    inline void Incr_REQTIMEOUT()
        {
        InterlockedIncrement(PLCounter(ID_REQTIMEOUT));
        }
    inline void Incr_REQTOTAL()
        {
        InterlockedIncrement(PLCounter(ID_REQTOTAL));
        }
    inline void Incr_REQPERSEC()
        {
        InterlockedIncrement(PLCounter(ID_REQPERSEC));
        }
    inline void Incr_SCRIPTFREEENG()
        {
        InterlockedIncrement(PLCounter(ID_SCRIPTFREEENG));
        }
    inline void Decr_SCRIPTFREEENG()
        {
        InterlockedDecrement(PLCounter(ID_SCRIPTFREEENG));
        }
    inline void Set_SESSIONLIFETIME(DWORD dw)
        {
        InterlockedExchange(PLCounter(ID_SESSIONLIFETIME), (LONG)dw);
        }
    inline void Incr_SESSIONCURRENT()
        {
        InterlockedIncrement(PLCounter(ID_SESSIONCURRENT));
        }
    inline void Decr_SESSIONCURRENT()
        {
        InterlockedDecrement(PLCounter(ID_SESSIONCURRENT));
        }
    inline void Incr_SESSIONTIMEOUT()
        {
        InterlockedIncrement(PLCounter(ID_SESSIONTIMEOUT));
        }
    inline void Incr_SESSIONSTOTAL()
        {
        InterlockedIncrement(PLCounter(ID_SESSIONSTOTAL));
        }
    inline void Incr_TEMPLCACHE()
        {
        InterlockedIncrement(PLCounter(ID_TEMPLCACHE));
        }
    inline void Decr_TEMPLCACHE()
        {
        InterlockedDecrement(PLCounter(ID_TEMPLCACHE));
        }
    inline void Zero_TEMPLCACHE()
        {
        InterlockedExchange(PLCounter(ID_TEMPLCACHE), 0);
        }
    inline void Incr_TEMPLCACHEHITS()
        {
        InterlockedIncrement(PLCounter(ID_TEMPLCACHEHITS));
        }
    inline void Incr_TEMPLCACHETRYS()
        {
        InterlockedIncrement(PLCounter(ID_TEMPLCACHETRYS));
        }
    inline void Incr_MEMORYTEMPLCACHE()
        {
        InterlockedIncrement(PLCounter(ID_MEMORYTEMPLCACHE));
        }
    inline void Decr_MEMORYTEMPLCACHE()
        {
        InterlockedDecrement(PLCounter(ID_MEMORYTEMPLCACHE));
        }
    inline void Zero_MEMORYTEMPLCACHE()
        {
        InterlockedExchange(PLCounter(ID_MEMORYTEMPLCACHE), 0);
        }
    inline void Incr_MEMORYTEMPLCACHEHITS()
        {
        InterlockedIncrement(PLCounter(ID_MEMORYTEMPLCACHEHITS));
        }
    inline void Incr_MEMORYTEMPLCACHETRYS()
        {
        InterlockedIncrement(PLCounter(ID_MEMORYTEMPLCACHETRYS));
        }
    inline void Incr_TEMPLFLUSHES()
        {
        InterlockedIncrement(PLCounter(ID_TEMPLFLUSHES));
        }
    inline void Incr_TRANSABORTED()
        {
        InterlockedIncrement(PLCounter(ID_TRANSABORTED));
        }
    inline void Incr_TRANSCOMMIT()
        {
        InterlockedIncrement(PLCounter(ID_TRANSCOMMIT));
        }
    inline void Incr_TRANSPENDING()
        {
        InterlockedIncrement(PLCounter(ID_TRANSPENDING));
        }
    inline void Decr_TRANSPENDING()
        {
        InterlockedDecrement(PLCounter(ID_TRANSPENDING));
        }
    inline void Incr_TRANSTOTAL()
        {
        InterlockedIncrement(PLCounter(ID_TRANSTOTAL));
        }
    inline void Incr_TRANSPERSEC()
        {
        InterlockedIncrement(PLCounter(ID_TRANSPERSEC));
        }
        
    };

// We init PERFMON data on first request
extern BOOL g_fPerfInited;

// Object to access main shared PERFMON memory
extern CPerfMainBlock g_PerfMain;

// Object to access shared memory (incl. counters) for this process
extern CPerfData g_PerfData;

HRESULT PreInitPerfData();

HRESULT InitPerfDataOnFirstRequest(CIsapiReqInfo    *pIReq);

HRESULT UnInitPerfData();

#else

inline HRESULT PreInitPerfData()
    {
    return S_OK;
    }

inline HRESULT InitPerfDataOnFirstRequest(CIsapiReqInfo    *pIReq) 
    {
    return S_OK; 
    }

inline HRESULT UnInitPerfData()
    {
    return S_OK; 
    }

#endif  // PERF_DISABLE


#endif // _ASP_PERFDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\request.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: request object

File: request.cpp

Owner: CGrant, DGottner

This file contains the code for the implementation of the Request object.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "objbase.h"
#include "request.h"
#include "cookies.h"
#include "clcert.h"
#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init


static char HexToChar(LPSTR);
static char DecodeFromURL(char **pszSource, char *szStop, char *szDest, UINT uCodePage, BOOL fIgnoreCase = FALSE);

#define toupper(x)  BYTE(CharUpper(LPSTR(BYTE(x))))

#if _IIS_6_0

struct {
    int     varLen;
    char    *szVarName;
} g_sUNICODEVars [] = {
    
    {3, "URL"},
    {9, "PATH_INFO"},
    {9, "AUTH_USER"},
    {10,"LOGON_USER"},
    {11,"REMOTE_USER"},
    {11,"SCRIPT_NAME"},
    {11,"APP_POOL_ID"},
    {12,"APPL_MD_PATH"},
    {15,"PATH_TRANSLATED"},
    {17,"SCRIPT_TRANSLATED"},
    {18,"APPL_PHYSICAL_PATH"},
    {20,"UNMAPPED_REMOTE_USER"},
    {-1,""}
};

#endif

/*------------------------------------------------------------------
 * C R e q u e s t H i t
 */

/*===================================================================
CRequestHit::CRequestHit

Constructor

Parameters:
    None
===================================================================*/

CRequestHit::CRequestHit()
    {
    m_fInited = FALSE;
    m_fDuplicate = FALSE;
    m_pQueryData = m_pFormData = NULL;
    m_pCookieData = NULL;
    m_pClCertData = NULL;
    }



/*===================================================================
CRequestHit::~CRequestHit

Destructor
===================================================================*/

CRequestHit::~CRequestHit()
    {
    if (m_pQueryData != NULL)
        m_pQueryData->Release();

    if (m_pFormData != NULL)
        m_pFormData->Release();

    if (m_pCookieData != NULL)
        m_pCookieData->Release();

    if (m_pClCertData != NULL)
        m_pClCertData->Release();

    if (m_fDuplicate)
        delete m_pKey;
    }



/*===================================================================
CRequestHit::Init

Constructor

Parameters:
    szName - pointer to string containing name
    fDuplicate - TRUE if we should dup the string

Returns:
    E_OUTOFMEMORY, E_FAIL, or S_OK
===================================================================*/

HRESULT CRequestHit::Init(char *szName, BOOL fDuplicate)
    {
    if (m_fInited)
        return E_FAIL;

    m_fDuplicate = fDuplicate;
    if (fDuplicate)
        {
        char *szNewKey = new char [strlen(szName) + 1];
        if (szNewKey == NULL)
            return E_OUTOFMEMORY;

        if (FAILED(CLinkElem::Init(strcpy(szNewKey, szName), strlen(szName))))
            return E_FAIL;
        }
    else
        if (FAILED(CLinkElem::Init(szName, strlen(szName))))
            return E_FAIL;

    m_fInited = TRUE;
    return S_OK;
    }




/*===================================================================
CRequestHit::AddValue

Parameters:
    source - type of the value (QueryString or Body)
    szValue - the value as a null-terminated string.
    lCodePage - the CodePage used when retrieve the data

Returns:
    Nothing.
===================================================================*/
HRESULT CRequestHit::AddValue
(
CollectionType Source,
char *szValue,
CIsapiReqInfo   *pIReq,
UINT lCodePage
)
    {
    HRESULT hResult;
    CStringList **ppValues = NULL;

    switch (Source)
        {
    case QUERYSTRING:
        ppValues = &m_pQueryData;
        break;

    case FORM:
        ppValues = &m_pFormData;
        break;

    case COOKIE:
        if (m_pCookieData == NULL)
            {
            m_pCookieData = new CCookie(pIReq, lCodePage);

            if (m_pCookieData == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(hResult = m_pCookieData->Init()))
                return hResult;
            }

        return m_pCookieData->AddValue(szValue);

    case CLCERT:
        if (m_pClCertData == NULL)
            {
            m_pClCertData = new CClCert;

            if (m_pClCertData == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(hResult = m_pClCertData->Init()))
                return hResult;
            }

        return m_pClCertData->AddValue(szValue);

    default:
        return E_FAIL;
        }

    if (*ppValues == NULL)
        {
        *ppValues = new CStringList;
        if (*ppValues == NULL)
            return E_OUTOFMEMORY;
        }

    if (FAILED(hResult = (*ppValues)->AddValue(szValue, FALSE, lCodePage)))
        return hResult;

    return S_OK;
    }



HRESULT CRequestHit::AddCertValue(VARENUM ve, LPBYTE pValue, UINT cLen )
    {
    HRESULT hResult;

    if (m_pClCertData == NULL)
        {
        m_pClCertData = new CClCert;

        if (m_pClCertData == NULL)
            return E_OUTOFMEMORY;

        if (FAILED(hResult = m_pClCertData->Init()))
            return hResult;
        }

    return m_pClCertData->AddValue( (LPSTR)pValue, ve, cLen );
    }




/*===================================================================
CRequestHit::AddKeyAndValue

Add a value based on keys for collections that support them.  Currently,
only cookies support them.

Parameters:
    source - type of the value (must be Cookie)
    szKey - the key
    szValue - the value as a null-terminated string.

Returns:
    Returns E_OUTOFMEMORY if memory cannot be allocated,
    E_FAIL if source collection does not support keys,
===================================================================*/
HRESULT CRequestHit::AddKeyAndValue
(
CollectionType Source,
char *szKey,
char *szValue,
CIsapiReqInfo    *pIReq,
UINT    lCodePage
)
{
    HRESULT hResult;

    switch ( Source )
    {
        case COOKIE:
            if (m_pCookieData == NULL)
                {
                m_pCookieData = new CCookie( pIReq , lCodePage);

                if (m_pCookieData == NULL)
                    return E_OUTOFMEMORY;

                if (FAILED(hResult = m_pCookieData->Init()))
                    return hResult;
                }

            return m_pCookieData->AddKeyAndValue(szKey, szValue);

        default:
            return E_FAIL;
    }
}

/*------------------------------------------------------------------
 * C R e q u e s t H i t s A r r a y
 */

/*===================================================================
CRequestHitsArray::CRequestHitsArray

Constructor

Parameters:

Returns:
===================================================================*/
CRequestHitsArray::CRequestHitsArray()
    : m_dwCount(0), m_dwHitMax(0), m_rgRequestHit(NULL)
    {
    }

/*===================================================================
CRequestHitsArray::~CRequestHitsArray

Destructor

Parameters:

Returns:
===================================================================*/
CRequestHitsArray::~CRequestHitsArray()
    {
    if (m_rgRequestHit)
        delete [] m_rgRequestHit;
    }

/*===================================================================
CRequestHitsArray::AddRequestHit

Add an element to the array

Parameters:
    pHit    element to add

Returns:
===================================================================*/
BOOL CRequestHitsArray::AddRequestHit
(
CRequestHit *pHit
)
    {
    Assert(pHit);

    if (m_dwCount == m_dwHitMax)
        {
        DWORD dwNewSize = m_dwHitMax + NUM_REQUEST_HITS;
        CRequestHit **ppNewArray = new CRequestHit *[dwNewSize];

        if (ppNewArray == NULL)
            return FALSE;

        if (m_dwCount)
            {
            Assert(m_rgRequestHit);

            // Copy pointers from old array
            memcpy
                (
                ppNewArray,
                m_rgRequestHit,
                m_dwCount * sizeof(CRequestHit *)
                );

            // free old array
            delete [] m_rgRequestHit;
            }
         else
            {
            Assert(m_rgRequestHit == NULL);
            }

        m_rgRequestHit = ppNewArray;
        m_dwHitMax = dwNewSize;
        }

    m_rgRequestHit[m_dwCount++] = pHit;
    return TRUE;
    }

/*------------------------------------------------------------------
 * C Q u e r y S t r i n g
 */

/*===================================================================
CQueryString::CQueryString

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CQueryString::CQueryString(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CQueryString::~CQueryString

Destructor

Parameters:
    None
Returns:
    Nothing.
===================================================================*/
CQueryString::~CQueryString()
    {
    if (m_pRequest)
        m_pRequest->Release();
    }

/*===================================================================
HRESULT CQueryString::Init

Parameters:
    None

Returns:
    E_OUTOFMEMORY if allocation fails.

===================================================================*/
HRESULT CQueryString::Init()
    {
    return CRequestHitsArray::Init();
    }

/*===================================================================
HRESULT CQueryString::ReInit

Parameters:
    None

Returns:
    S_OK
===================================================================*/
HRESULT CQueryString::ReInit()
    {
    return CRequestHitsArray::ReInit();
    }

/*===================================================================
CQueryString::QueryInterface
CQueryString::AddRef
CQueryString::Release

IUnknown members for CQueryString object.
===================================================================*/

STDMETHODIMP CQueryString::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    if (iid == IID_IUnknown || iid == IID_IRequestDictionary || iid == IID_IDispatch)
        *ppvObj = this;

    else if (iid == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
    }


STDMETHODIMP_(ULONG) CQueryString::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CQueryString::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CQueryString::get_Item

Function called from DispInvoke to get values from the QueryString collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CQueryString::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key

    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    case VT_ERROR:
        if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
            {
            // Look up QueryString using the "ServerVariables" collection -
            // The LoadVariables() function trashes QueryPszQueryString() in the CIsapiReqInfo
            //
            DWORD dwQStrSize;

            STACK_BUFFER( queryStrBuff, 256 );

            if (!SERVER_GET(m_pRequest->GetIReq(), "QUERY_STRING", &queryStrBuff, &dwQStrSize)) {
                if (GetLastError() == E_OUTOFMEMORY) {
                    ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                    hrReturn = E_OUTOFMEMORY;
                }
                else {
                    hrReturn = E_FAIL;
                }
                goto LExit;
            }

            char *szQueryString = (char *)queryStrBuff.QueryPtr();

            BSTR bstrT;
            if (FAILED(SysAllocStringFromSz(szQueryString, 0, &bstrT,m_pRequest->GetCodePage())))
                {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
                }
            V_VT(pvarReturn) = VT_BSTR;
            V_BSTR(pvarReturn) = bstrT;

            goto LExit;
            }

        // Other error, FALL THROUGH to wrong type case

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadQuery)
        {
        if (FAILED(m_pRequest->LoadVariables(QUERYSTRING, m_pRequest->GetIReq()->QueryPszQueryString(), m_pRequest->GetCodePage())))
            {
            hrReturn = E_FAIL;
            goto LExit;
            }

        m_pRequest->m_pData->m_fLoadQuery = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && (int) m_dwCount == 0))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }


        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CStringList *pValues = pRequestHit->m_pQueryData;
        if (pValues == NULL)
            goto LNotFound;

        if (FAILED(pValues->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(&pSListReturn))))
            Assert (FALSE);

        V_VT(pvarReturn) = VT_DISPATCH;
        V_DISPATCH(pvarReturn) = pSListReturn;

        goto LExit;
        }

LNotFound: // Return "Empty"
    if (FAILED(m_pRequest->m_pData->GetEmptyStringList(&pSListReturn)))
        hrReturn = E_FAIL;

    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = pSListReturn;

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CQueryString::get_Key

Function called from DispInvoke to get keys from the QueryString collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CQueryString::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;
    HRESULT hrReturn = S_OK;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadQuery)
        {
        if (FAILED(m_pRequest->LoadVariables(QUERYSTRING, m_pRequest->GetIReq()->QueryPszQueryString(), m_pRequest->GetCodePage())))
            {
            hrReturn = E_FAIL;
            goto LExit;
            }

        m_pRequest->m_pData->m_fLoadQuery = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        // Create a BSTR containing the key for this variant
        BSTR bstrT = NULL;
        
        SysAllocStringFromSz((char *)pRequestHit->m_pKey,0,&bstrT,m_pRequest->GetCodePage());
        if (!bstrT)
            return E_OUTOFMEMORY;
        V_BSTR(pVar) = bstrT;
        }
LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CQueryString::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CQueryString::get_Count(int *pcValues)
    {
    HRESULT hrReturn = S_OK;

    if (m_pRequest->m_pData->m_fLoadQuery)
        {
        if (FAILED(hrReturn = m_pRequest->LoadVariables(QUERYSTRING, m_pRequest->GetIReq()->QueryPszQueryString(), m_pRequest->GetCodePage())))
            {
            goto LExit;
            }
        m_pRequest->m_pData->m_fLoadQuery = FALSE;
        }

    *pcValues = m_dwCount;

LExit:
    return hrReturn;
    }

/*===================================================================
CQueryString::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CQueryString::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->GetRequestEnumerator(QUERYSTRING, ppEnumReturn);
    }

/*------------------------------------------------------------------
 * C F o r m I n p u t s
 */

/*===================================================================
CFormInputs::CFormInputs

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CFormInputs::CFormInputs(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CFormInputs::CFormInputs

Destructor

Parameters:
    None
Returns:
    Nothing.
===================================================================*/
CFormInputs::~CFormInputs()
    {
    if (m_pRequest)
        m_pRequest->Release();
    }

/*===================================================================
HRESULT CFormInputs::Init

Parameters:
    None

Returns:
    E_OUTOFMEMORY if allocation fails.
===================================================================*/
HRESULT CFormInputs::Init()
    {
    return CRequestHitsArray::Init();
    }

/*===================================================================
HRESULT CFormInputs::ReInit

Parameters:
    None

Returns:
    S_OK
===================================================================*/
HRESULT CFormInputs::ReInit()
    {
    return CRequestHitsArray::ReInit();
    }

/*===================================================================
CFormInputs::QueryInterface
CFormInputs::AddRef
CFormInputs::Release

IUnknown members for CFormInputs object.
===================================================================*/

STDMETHODIMP CFormInputs::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    if (iid == IID_IUnknown || iid == IID_IRequestDictionary || iid == IID_IDispatch)
        *ppvObj = this;

    else if (iid == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CFormInputs::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CFormInputs::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CFormInputs::get_Item

Function called from DispInvoke to get values from the QueryString collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, S_OK if key not found, E_FAIL on failure.
===================================================================*/

HRESULT CFormInputs::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;                // ascii version of the key
    CWCharToMBCS    convKey;
    IDispatch       *pSListReturn;         // value of the key
    CRequestHit     *pRequestHit;          // pointer to request bucket
    BOOL            fDataAvail = FALSE;    // true if data seen from client

    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // If BinaryRead has been called, the Form collection is no longer available
    if (m_pRequest->m_pData->m_FormDataStatus != AVAILABLE &&
        m_pRequest->m_pData->m_FormDataStatus != FORMCOLLECTIONONLY)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_FORMCOLLECTION_NA);
        hrReturn = E_FAIL;
        }

    if (m_pRequest->m_pData->m_FormDataStatus == AVAILABLE)
        m_pRequest->m_pData->m_FormDataStatus = FORMCOLLECTIONONLY;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    if (m_pRequest->m_pData->m_fLoadForm)
        {
        if (FAILED(hrReturn = m_pRequest->CopyClientData()))
            goto LExit;

        if (FAILED(hrReturn = m_pRequest->LoadVariables(FORM, m_pRequest->m_pData->m_szFormData, m_pRequest->GetCodePage())))
            goto LExit;

        // BUG:895 (JHITTLE) added to check for null result set
        // this fixes the out of memory error when the form
        // data is NULL
        //
        fDataAvail = (m_pRequest->m_pData->m_szFormData != NULL);
        m_pRequest->m_pData->m_fLoadForm = FALSE;
        }
    else
        fDataAvail = (m_pRequest->m_pData->m_szFormData != NULL);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    case VT_ERROR:
        if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
            {
            if (fDataAvail)
                {
                BSTR bstrT;
                if (FAILED(SysAllocStringFromSz(m_pRequest->m_pData->m_szFormClone, 0, &bstrT,m_pRequest->GetCodePage())))
                    {
                    ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                    hrReturn = E_OUTOFMEMORY;
                    }
                V_VT(pvarReturn) = VT_BSTR;
                V_BSTR(pvarReturn) = bstrT;
                }

            // If there was no data available, status & return value are already set
            goto LExit;
            }

        // Other error, FALL THROUGH to wrong type case

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    pRequestHit = NULL;
    if (! fDataAvail)       // Quick check before we do an expensive lookup
        goto LNotFound;

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }


        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CStringList *pValues = pRequestHit->m_pFormData;
        if (pValues == NULL)
            goto LNotFound;

        if (FAILED(pValues->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(&pSListReturn))))
            Assert (FALSE);

        V_VT(pvarReturn) = VT_DISPATCH;
        V_DISPATCH(pvarReturn) = pSListReturn;
        goto LExit;
        }

LNotFound: // Return "Empty"
    if(vt != VT_BSTR)
        {
        hrReturn = E_FAIL;
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
        goto LExit;
        }

    if (FAILED(m_pRequest->m_pData->GetEmptyStringList(&pSListReturn)))
        hrReturn = E_FAIL;

    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = pSListReturn;

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CFormInputs::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CFormInputs::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    HRESULT hrReturn = S_OK;

    // If BinaryRead has been called, the Form collection is no longer available
    if (m_pRequest->m_pData->m_FormDataStatus != AVAILABLE &&
        m_pRequest->m_pData->m_FormDataStatus != FORMCOLLECTIONONLY)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_FORMCOLLECTION_NA);
        hrReturn = E_FAIL;
        }

    if (m_pRequest->m_pData->m_FormDataStatus == AVAILABLE)
        m_pRequest->m_pData->m_FormDataStatus = FORMCOLLECTIONONLY;


    if (m_pRequest->m_pData->m_fLoadForm)
        {
        if (FAILED(hrReturn = m_pRequest->CopyClientData()))
            goto LExit;

        if (FAILED(hrReturn = m_pRequest->LoadVariables(FORM, m_pRequest->m_pData->m_szFormData, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadForm = FALSE;
        }

    *pcValues = m_dwCount;

LExit:
    return hrReturn;
    }

/*===================================================================
CFormInputs::get_Key

Function called from DispInvoke to get keys from the form inputs collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CFormInputs::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;
    HRESULT hrReturn = S_OK;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;
    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadForm)
        {
        if (FAILED(hrReturn = m_pRequest->CopyClientData()))
            goto LExit;

        if (FAILED(hrReturn = m_pRequest->LoadVariables(FORM, m_pRequest->m_pData->m_szFormData, m_pRequest->GetCodePage())))
            {
            goto LExit;
            }
        m_pRequest->m_pData->m_fLoadForm = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        // Create a BSTR containing the key for this variant
        BSTR bstrT = NULL;
        SysAllocStringFromSz((char *)pRequestHit->m_pKey,0,&bstrT,m_pRequest->GetCodePage());
        if (!bstrT)
            return E_OUTOFMEMORY;
        V_BSTR(pVar) = bstrT;
        }
LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CFormInputs::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CFormInputs::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->GetRequestEnumerator(FORM, ppEnumReturn);
    }

/*------------------------------------------------------------------
 * C C o o k i e s
 */

/*===================================================================
CCookies::CCookies

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CCookies::CCookies(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    m_pEmptyCookie = NULL;
    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CCookies::CCookies

Destructor

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/
CCookies::~CCookies()
    {
    if (m_pRequest)
        m_pRequest->Release();
    if (m_pEmptyCookie)
        m_pEmptyCookie->Release();
    }


/*===================================================================
CCookies::Init

Initializer

Parameters:
    None

Returns:
    Nothing.
===================================================================*/
HRESULT CCookies::Init()
    {
    return CRequestHitsArray::Init();
    }

/*===================================================================
HRESULT CCookies::ReInit

Parameters:
    None

Returns:
    S_OK
===================================================================*/
HRESULT CCookies::ReInit()
    {
    return CRequestHitsArray::ReInit();
    }

/*===================================================================
CCookies::QueryInterface
CCookies::AddRef
CCookies::Release

IUnknown members for CQueryString object.
===================================================================*/

STDMETHODIMP CCookies::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    if (iid == IID_IUnknown || iid == IID_IRequestDictionary || iid == IID_IDispatch)
        *ppvObj = this;

    else if (iid == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CCookies::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CCookies::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CCookies::get_Item

Function called from DispInvoke to get values from the Cookies collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CCookies::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;          // ascii version of the key
    CRequestHit     *pRequestHit;   // pointer to request bucket
    CWCharToMBCS    convKey;

    STACK_BUFFER( tempCookie, 128 );
    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    if (m_pRequest->m_pData->m_fLoadCookies)
        {
        char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();
        
        if (FAILED(hrReturn = m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadCookies = FALSE;
        }

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    case VT_ERROR:
        if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
            {
            // Dynamically construct value of HTTP_COOKIE.
            //
            // Step 1: figure out how much space we need
            //
            int cbHTTPCookie = 1; // At the least we will need space for '\0'

            for (pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
                 pRequestHit != NULL;
                 pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
                {
                CCookie *pCookie = pRequestHit->m_pCookieData;
                if (pCookie)
                    cbHTTPCookie += pCookie->GetHTTPCookieSize() + pRequestHit->m_cbKey + 1;
                }

            // Allocate space for the HTTP_COOKIE value
            //
            if (cbHTTPCookie > REQUEST_ALLOC_MAX)
                {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_STACK_OVERFLOW);
                hrReturn = E_FAIL;
                goto LExit;
                }
            if (tempCookie.Resize(cbHTTPCookie) == FALSE) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
            }
            char *szHTTPCookie = static_cast<char *>(tempCookie.QueryPtr());

            // Step 2: create the value of HTTP_COOKIE
            //
            char *szDest = szHTTPCookie;

            for (pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
                 pRequestHit != NULL;
                 pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
                {
                CCookie *pCookie = pRequestHit->m_pCookieData;
                if (pCookie)
                    {
                    strcpy(szDest, reinterpret_cast<char *>(pRequestHit->m_pKey));
                    szDest = strchr(szDest, '\0');

                    *szDest++ = '=';

                    szDest = pCookie->GetHTTPCookie(szDest);
                    if (pRequestHit->m_pNext)
                        *szDest++ = ';';
                    }
                }
            *szDest = '\0';

            // Now we have the value, so return it.
            //
            BSTR bstrT;
            if (FAILED(SysAllocStringFromSz(szHTTPCookie, 0, &bstrT, m_pRequest->GetCodePage())))
                {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
                }
            V_VT(pvarReturn) = VT_BSTR;
            V_BSTR(pvarReturn) = bstrT;

            goto LExit;
            }

        // Other error, FALL THROUGH to wrong type case

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = NULL;

    if (vt == VT_BSTR)
        {
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }


        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CCookie *pDictionary = pRequestHit->m_pCookieData;
        if (pDictionary == NULL)
            goto LNotFound;

        if (FAILED(pDictionary->QueryInterface(IID_IReadCookie, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
            Assert (FALSE);

        goto LExit;
        }

LNotFound: // Return Empty Cookie
    if (!m_pEmptyCookie)
        {
        // create on demand
        if ((m_pEmptyCookie = new CCookie(m_pRequest->GetIReq(), m_pRequest->GetCodePage())) != NULL)
            hrReturn = m_pEmptyCookie->Init();
        else
            hrReturn = E_OUTOFMEMORY;
        }
    if (m_pEmptyCookie)
        hrReturn = m_pEmptyCookie->QueryInterface(IID_IReadCookie, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)));

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CCookies::get_Key

Function called from DispInvoke to get keys from the cookie collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CCookies::get_Key(VARIANT varKey, VARIANT *pVar)
{
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;
    HRESULT hrReturn = S_OK;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;
    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadCookies)
        {
        char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();
        
        if (FAILED(hrReturn = m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadCookies = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        // Create a BSTR containing the key for this variant
        BSTR bstrT = NULL;
        SysAllocStringFromSz((char *)pRequestHit->m_pKey,0,&bstrT,m_pRequest->GetCodePage());
        if (!bstrT)
            return E_OUTOFMEMORY;
        V_BSTR(pVar) = bstrT;
        }
LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CCookies::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CCookies::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    HRESULT hrReturn = S_OK;
    
    if (m_pRequest->m_pData->m_fLoadCookies)
        {
        char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();
        
        if (FAILED(hrReturn = m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadCookies = FALSE;
        }

    *pcValues = m_dwCount;

LExit:
    return hrReturn;
    }

/*===================================================================
CCookies::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CCookies::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->GetRequestEnumerator(COOKIE, ppEnumReturn);
    }


/*------------------------------------------------------------------
 * C C l C e r t s
 */

/*===================================================================
CClCerts::CClCerts

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CClCerts::CClCerts(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    m_pEmptyClCert = NULL;
    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CClCerts::ClCerts

Destructor

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/
CClCerts::~CClCerts()
    {
    if (m_pRequest)
        m_pRequest->Release();
    if (m_pEmptyClCert)
        m_pEmptyClCert->Release();
    }

/*===================================================================
CClCerts::Init

Initializer

Parameters:
    None

Returns:
    Nothing.
===================================================================*/
HRESULT CClCerts::Init()
    {
    return CRequestHitsArray::Init();
    }

/*===================================================================
CClCerts::ReInit

Parameters:
    None

Returns:
    S_OK
===================================================================*/
HRESULT CClCerts::ReInit()
    {
    return CRequestHitsArray::ReInit();
    }

/*===================================================================
CClCerts::QueryInterface
CClCerts::AddRef
CClCerts::Release

IUnknown members for CQueryString object.
===================================================================*/

STDMETHODIMP CClCerts::QueryInterface(REFIID riid, void **ppv)
    {
    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IRequestDictionary || riid == IID_IDispatch)
        *ppv = this;

    else if (riid == IID_ISupportErrorInfo)
        *ppv = &m_ISupportErrImp;

    if (*ppv != NULL)
        {
        static_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
    }


STDMETHODIMP_(ULONG) CClCerts::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CClCerts::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CClCerts::get_Item

Function called from DispInvoke to get values from the ClCerts collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, S_FALSE if key not found, E_FAIL on failure.
===================================================================*/

HRESULT CClCerts::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;          // ascii version of the key
    CRequestHit     *pRequestHit;   // pointer to request bucket
    CWCharToMBCS    convKey;

    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    if (m_pRequest->m_pData->m_fLoadClCerts)
        {
        if (FAILED(hrReturn = m_pRequest->LoadVariables(CLCERT, reinterpret_cast<char *>(m_pRequest->GetIReq()), m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadClCerts = FALSE;
        }

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    case VT_ERROR:
        if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
            {
            // Dynamically construct value of CLCERT
            //
            // Step 1: figure out how much space we need
            //
            int cbHTTPClCert = 0;

            for (pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
                 pRequestHit != NULL;
                 pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
                {
                CClCert *pClCert = pRequestHit->m_pClCertData;
                if (pClCert)
                    cbHTTPClCert += pClCert->GetHTTPClCertSize() + pRequestHit->m_cbKey + 1;
                }

            STACK_BUFFER( tempClCert, 256);

            if (!tempClCert.Resize(cbHTTPClCert)) {
			    ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
            }
            char *szHTTPClCert = static_cast<char *>(tempClCert.QueryPtr());

            // Step 2: create the value of CLCERT
            //
            char *szDest = szHTTPClCert;

            for (pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
                 pRequestHit != NULL;
                 pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
                {
                CClCert *pClCert = pRequestHit->m_pClCertData;
                if (pClCert)
                    {
                    strcpy(szDest, reinterpret_cast<char *>(pRequestHit->m_pKey));
                    szDest = strchr(szDest, '\0');

                    *szDest++ = '=';

                    szDest = pClCert->GetHTTPClCert(szDest);
                    if (pRequestHit->m_pNext)
                        *szDest++ = ';';
                    }
                }
            *szDest = '\0';

            // Now we have the value, so return it.
            //
            BSTR bstrT;
            if (FAILED(SysAllocStringFromSz(szHTTPClCert, 0, &bstrT)))
                {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
                }
            V_VT(pvarReturn) = VT_BSTR;
            V_BSTR(pvarReturn) = bstrT;

            goto LExit;
            }

        // Other error, FALL THROUGH to wrong type case

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = NULL;

    if (vt == VT_BSTR)
        {
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey)))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
    		szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CClCert *pDictionary = pRequestHit->m_pClCertData;
        if (pDictionary == NULL)
            goto LNotFound;

        if (FAILED(pDictionary->QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
            Assert (FALSE);

        goto LExit;
        }

LNotFound: // Return "Empty"
    if (!m_pEmptyClCert)
        {
        // create on demand
        if ((m_pEmptyClCert = new CClCert) != NULL)
            hrReturn = m_pEmptyClCert->Init();
        else
            hrReturn = E_OUTOFMEMORY;
        }
    if (m_pEmptyClCert)
        hrReturn = m_pEmptyClCert->QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)));

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CClCerts::get_Key

Function called from DispInvoke to get keys from the certificate collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CClCerts::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;
    HRESULT hrReturn = S_OK;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;
    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadClCerts)
        {
        if (FAILED(hrReturn = m_pRequest->LoadVariables(CLCERT, reinterpret_cast<char *>(m_pRequest->GetIReq()), m_pRequest->GetCodePage())))
            {
            goto LExit;
            }
        m_pRequest->m_pData->m_fLoadClCerts = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        // Create a BSTR containing the key for this variant
        BSTR bstrT = NULL;
        SysAllocStringFromSz((char *)pRequestHit->m_pKey,0,&bstrT,m_pRequest->GetCodePage());
        if (!bstrT)
            return E_OUTOFMEMORY;
        V_BSTR(pVar) = bstrT;
        }
LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CClCerts::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CClCerts::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    HRESULT hrReturn = S_OK;

    if (m_pRequest->m_pData->m_fLoadClCerts)
        {
        if (FAILED(hrReturn = m_pRequest->LoadVariables(CLCERT, reinterpret_cast<char *>(m_pRequest->GetIReq()), m_pRequest->GetCodePage())))
            {
            goto LExit;
            }
        m_pRequest->m_pData->m_fLoadClCerts = FALSE;
        }

    *pcValues = m_dwCount;

LExit:
    return hrReturn;
    }

/*===================================================================
CClCerts::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CClCerts::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->GetRequestEnumerator(CLCERT, ppEnumReturn);
    }


/*------------------------------------------------------------------
 * C S e r v e r V a r i a b l e s
 */

/*===================================================================
CServerVariables::CServerVariables

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CServerVariables::CServerVariables(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary),
      m_pIterator(NULL)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CServerVariables::~CServerVariables

Destructor

Parameters:
    None

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CServerVariables::~CServerVariables( )
    {
    if (m_pRequest)
        m_pRequest->Release();
    if (m_pIterator)
        m_pIterator->Release();
    }

/*===================================================================
CServerVariables::QueryInterface
CServerVariables::AddRef
CServerVariables::Release

IUnknown members for CFormInputs object.
===================================================================*/

STDMETHODIMP CServerVariables::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    if (iid == IID_IUnknown || iid == IID_IRequestDictionary || iid == IID_IDispatch)
        *ppvObj = this;

    else if (iid == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CServerVariables::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CServerVariables::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CServerVariables::get_Item

Function called from DispInvoke to get values from the ServerVariables
collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.

NOTE:
    This code is basically an enacpsulation from the SERVER_GET macro,
    only more efficient, since it only looks up the key once on average
    unfortunately, the only way to get good memory utilization with
    ISAPI is to use _alloca() with lookups, which means we can't
    encapsulate the lookup logic very well.
===================================================================*/

HRESULT CServerVariables::get_Item(VARIANT varKey, VARIANT *pvarReturn)
{

    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    DWORD           dwValSize;             // buffer size

    char            *szKey;                // pointer to ASCII value of varKey
    char            *szValue;              
    WCHAR           *wszValue;              

    BOOL            fSuccess;              // TRUE when call to GetServerVariable succeeds
    UINT            uCodePage = CP_ACP;
    CWCharToMBCS    convKey;
    BOOL            fUnicodeVar = FALSE;

    STACK_BUFFER( tempVal, 128 );

    dwValSize = tempVal.QuerySize();
    szValue = (char *)tempVal.QueryPtr();
    wszValue = (WCHAR *)tempVal.QueryPtr();

    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4)) {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
    }

    vt = V_VT(pvarKey);
    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = NULL;      // initial value of Nothing

    switch (vt) {

        // Bug 95201 support all numberic sub-types
        case VT_I1:  case VT_I2:               case VT_I8:
        case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
        case VT_R4:  case VT_R8:
            // Coerce all integral types to VT_I4
            if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
                goto LExit;

            // fallthru to VT_I4

        case VT_I4:
        case VT_BSTR:
            break;

        case VT_ERROR:
            if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
                hrReturn = E_FAIL;
                goto LExit;
            }

            // Other error, FALL THROUGH to wrong type case

        default:
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
            hrReturn = E_FAIL;
            goto LExit;
    }

    uCodePage = m_pRequest->GetCodePage();

    if (vt == VT_BSTR) {
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), uCodePage))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = CharUpperA(convKey.GetString());
        }
    }
    else {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // We use the CServVarsIterator to manange
        // the count of sv and integer index
        if (!m_pIterator) {
            m_pIterator = new CServVarsIterator;
            if (!m_pIterator) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
            }
            if (FAILED(hrReturn=m_pIterator->Init(m_pRequest->m_pData->m_pIReq)))
                goto LExit;
        }
        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_pIterator->m_cKeys)) || ((iCount > 0) && ((int) m_pIterator->m_cKeys == 0))) {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
        }
        if (FAILED(hrReturn = convKey.Init(m_pIterator->m_rgwszKeys[iCount - 1], uCodePage))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = CharUpperA(convKey.GetString());
        }
    }

    if (strncmp(convKey.GetString(), "UNICODE_", 7) == 0) {
        fSuccess = false;
        goto SkipLookup;
    }


#if _IIS_6_0

    // in IIS6, there are a number of variables that are UNICODE.  To
    // access them, you simply place UNICODE_ infront of the name.
    // Two approaches could be taken here. One would be to always
    // try for a UNICODE_ var and fallback to the non-UNICODE var
    // if the lookup fails.  This can be costly.  The second, and
    // chosen method here, would be to maintain a list of vars 
    // that have UNICODE_ versions.

    // this char array is declared on the stack and is currently only
    // 32 chars.  It only needs to be as big as the largest UNICODE
    // var name.  Which is UNICODE_UNMAPPED_REMOTE_USER.

    char            szUNICODEName[32];

    // search the list to see if this is one of the UNICODE_ vars.
    // the list is sorted by length of string.  The current list is
    // not all that long, so a sequential search is not that expensive
    // in the scheme of things.

    for (int i=0; 
         (g_sUNICODEVars[i].varLen != -1) 
             && (convKey.GetStringLen() >= g_sUNICODEVars[i].varLen); 
         i++) {

        // the 'for' loop allows in anything which is at least as long
        // as the current entry.  The following 'if' will check for
        // for an exact length match and then a string compare.

        if ((convKey.GetStringLen() == g_sUNICODEVars[i].varLen)
            && (strcmp(convKey.GetString(), g_sUNICODEVars[i].szVarName) == 0)) {

            // if a hit is made, set the fUnicodeVar = TRUE so that the
            // right ISAPI lookup routine is called and the right StringList
            // AddValue is called.

            fUnicodeVar = TRUE;

            // build up the UNICODE_ version into the stack temp array

            strcpyExA(strcpyExA(szUNICODEName,"UNICODE_"),convKey.GetString());

            // reassign the key name to this value

            szKey = szUNICODEName;

            break;
        }
    }
#endif

    fSuccess = fUnicodeVar
                ? m_pRequest->GetIReq()->GetServerVariableW(szKey, wszValue, &dwValSize)
                : m_pRequest->GetIReq()->GetServerVariableA(szKey, szValue, &dwValSize);

    if (!fSuccess && (dwValSize > tempVal.QuerySize())) {
        if (dwValSize > REQUEST_ALLOC_MAX) {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_STACK_OVERFLOW);
            hrReturn = E_FAIL;
            goto LExit;
        }

        if (tempVal.Resize(dwValSize) == FALSE) {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            hrReturn = E_OUTOFMEMORY;
            goto LExit;
        }
        szValue = static_cast<char *>(tempVal.QueryPtr());
        wszValue = static_cast<WCHAR *>(tempVal.QueryPtr());
        fSuccess = fUnicodeVar
                    ? m_pRequest->GetIReq()->GetServerVariableW(szKey, wszValue, &dwValSize)
                    : m_pRequest->GetIReq()->GetServerVariableA(szKey, szValue, &dwValSize);
    }

SkipLookup:

    if (fSuccess) {
        // Create return value
        CStringList *pValue = new CStringList;
        if (pValue == NULL) {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            hrReturn = E_OUTOFMEMORY;
            goto LExit;
        }

        // add the value and QueryInterface for IDispatch interface - strdup the input string
        if (FAILED(hrReturn = (fUnicodeVar 
                                  ? pValue->AddValue(wszValue, TRUE)
                                  : pValue->AddValue(szValue, TRUE, uCodePage))))
            goto LExit;

        if (FAILED(pValue->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
            Assert (FALSE);

        // Release temporary (QueryInterface AddRef'd)
        pValue->Release();
        goto LExit;
    }
    else {
        if (FAILED(m_pRequest->m_pData->GetEmptyStringList(&V_DISPATCH(pvarReturn))))
            hrReturn = E_FAIL;
    }

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
}

/*===================================================================
CServerVariables::get_Key

Function called from DispInvoke to get keys from the server variables collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CServerVariables::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    HRESULT hrReturn = S_OK;
    int iCount = 0;
    BSTR bstrT = NULL;

    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key
    CWCharToMBCS    convKey;

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }

    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;
        vt = V_VT(pvarKey);
        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    // At this point the VT of pvarKey should be VT_I4 or VT_BSTR
    Assert((vt == VT_I4) || (vt == VT_BSTR));

    if (vt == VT_I4)
        {
        // We were passed in a number.
        // Look up the key by integer index

        iCount = V_I4(pvarKey);

        // We use the CServVarsIterator to manange
        // the count of sv and integer index
        if (!m_pIterator)
            {
            m_pIterator = new CServVarsIterator;
            if (!m_pIterator)
                {
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
                }
            if (FAILED(hrReturn=m_pIterator->Init(m_pRequest->m_pData->m_pIReq)))
                goto LExit;
            }

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_pIterator->m_cKeys)) || ((iCount > 0) && ((int) m_pIterator->m_cKeys == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        // Create a BSTR containing the key for this variant
        bstrT = SysAllocString(m_pIterator->m_rgwszKeys[iCount - 1]);
        if (!bstrT)
            {
            hrReturn = E_OUTOFMEMORY;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            goto LExit;
            }
        }
    else
        {
        // We were passed in a BSTR. Check to see if there
        // is a server variable for this key

        char szBuffer;
        DWORD dwValSize = sizeof(szBuffer);
        UINT uCodePage = m_pRequest->GetCodePage();
        
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), uCodePage))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = CharUpperA(convKey.GetString());
        }
        
        BOOL fSuccess = m_pRequest->GetIReq()->GetServerVariableA(szKey, &szBuffer, &dwValSize);

        DWORD dwError = 0;

        if (!fSuccess)
            {
            dwError = GetLastError();
            }

        // If the error was that we had insufficient buffer then
        // there is a server variable for that key

        if (fSuccess || dwError == ERROR_INSUFFICIENT_BUFFER)
            {
            bstrT = SysAllocString(V_BSTR(pvarKey));
            if (!bstrT)
                {
                hrReturn = E_OUTOFMEMORY;
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
                }
            }
         else if (dwError != ERROR_INVALID_INDEX)
            {

            // Any other error indicates an unexpected failure

            hrReturn = HRESULT_FROM_WIN32(dwError);
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_UNEXPECTED);
            goto LExit;
            }
        }

    // If we found a key, copy it into the out parmater
    if (bstrT)
        {
        V_BSTR(pVar) = bstrT;
        }

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CServerVariables::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CServerVariables::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    HRESULT hrReturn = S_OK;

    // We use the CServVarsIterator to manange
    // the count of sv and integer index
    if (!m_pIterator)
        {
        m_pIterator = new CServVarsIterator;
        if (!m_pIterator)
            {
            *pcValues = 0;
            return E_OUTOFMEMORY;
            }
        if (FAILED(hrReturn=m_pIterator->Init(m_pRequest->m_pData->m_pIReq)))
            return hrReturn;
        }

    *pcValues = m_pIterator->m_cKeys;

    return hrReturn;
    }

/*===================================================================
CServerVariables::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CServerVariables::get__NewEnum(IUnknown **ppEnumReturn)
    {
    HRESULT hrReturn;

    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    *ppEnumReturn = NULL;

    CServVarsIterator *pIterator = new CServVarsIterator;
    if (pIterator == NULL)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        return E_OUTOFMEMORY;
        }

    if (FAILED(hrReturn=pIterator->Init(m_pRequest->GetIReq())))
        {
        delete pIterator;
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST,
                ((hrReturn==E_OUTOFMEMORY)? IDE_OOM: IDE_UNEXPECTED) );
        return hrReturn;
        }

    *ppEnumReturn = pIterator;
    return S_OK;
    }


/*------------------------------------------------------------------
 * C R e q u e s t D a t a
 */

/*===================================================================
CRequestData::CRequestData

Constructor

Parameters:
    CRequest *pRequest

Returns:
    Nothing.
===================================================================*/
CRequestData::CRequestData
(
CRequest *pRequest
)
    : m_ISupportErrImp(static_cast<IRequest *>(pRequest), this, IID_IRequest),
      m_QueryString(pRequest, this),
      m_ServerVariables(pRequest, this),
      m_FormInputs(pRequest, this),
      m_Cookies(pRequest, this),
      m_ClCerts(pRequest, this),
      m_cRefs(1)
    {
    m_pIReq = NULL;
    m_pHitObj = NULL;
    m_FormDataStatus = AVAILABLE;
    m_pbAvailableData = NULL;
    m_cbAvailable = 0;
    m_cbTotal = 0;
    m_szFormData = NULL;
    m_cbFormData = 0;
    m_szFormClone = NULL;
    m_szCookie = NULL;
    m_cbCookie = 0;
    m_szClCert = NULL;
    m_cbClCert = 0;
    m_fLoadForm = TRUE;
    m_fLoadQuery = TRUE;
    m_fLoadCookies = TRUE;
    m_fLoadClCerts = TRUE;
    m_pEmptyString = NULL;
    }

/*===================================================================
CRequestData::~CRequestData

Destructor

Parameters:

Returns:
    Nothing.
===================================================================*/
CRequestData::~CRequestData()
    {
    CRequestHit *pNukeElem = static_cast<CRequestHit *>
        (
        m_mpszStrings.Head()
        );
    while (pNukeElem != NULL) {
        CRequestHit *pNext = static_cast<CRequestHit *>(pNukeElem->m_pNext);
        delete pNukeElem;
        pNukeElem = pNext;
    }

    m_mpszStrings.UnInit();

    if (m_pEmptyString)
        m_pEmptyString->Release();

    if (m_szFormData)
        free(m_szFormData);

    if (m_szFormClone)
        free(m_szFormClone);

    if (m_szCookie)
        free(m_szCookie);

    if (m_szClCert)
        free(m_szClCert);
    }

/*===================================================================
CRequestData::Init

Init

Parameters:

Returns:
    Nothing.
===================================================================*/
HRESULT CRequestData::Init()
    {
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
        hr = m_mpszStrings.Init();

    if (SUCCEEDED(hr))
        hr = m_QueryString.Init();

    if (SUCCEEDED(hr))
        hr = m_FormInputs.Init();

    if (SUCCEEDED(hr))
        hr = m_Cookies.Init();

    if (SUCCEEDED(hr))
        hr = m_ClCerts.Init();

    if (SUCCEEDED(hr))
        hr = m_ServerVariables.Init();

    return hr;
    }

/*===================================================================
CRequestData::ReInit

ReInit -- associate with new CIsapiReqInfo and HitObj

Parameters:

Returns:
    Nothing.
===================================================================*/
HRESULT CRequestData::ReInit
(
CIsapiReqInfo   *pIReq,
CHitObj *pHitObj
)
    {
    CRequestHit *pNukeElem = static_cast<CRequestHit *>
        (
        m_mpszStrings.Head()
        );
    while (pNukeElem != NULL)
        {
        CRequestHit *pNext = static_cast<CRequestHit *>
            (
            pNukeElem->m_pNext
            );
        delete pNukeElem;
        pNukeElem = pNext;
        }
    m_mpszStrings.ReInit();

    m_QueryString.ReInit();
    m_FormInputs.ReInit();
    m_Cookies.ReInit();
    m_ClCerts.ReInit();

    m_pIReq = pIReq;
    m_pHitObj = pHitObj;
    m_fLoadForm = TRUE;
    m_fLoadQuery = TRUE;
    m_fLoadCookies = TRUE;
    m_fLoadClCerts = TRUE;
    m_FormDataStatus = AVAILABLE;

    if (pIReq)
        {
        m_pbAvailableData = pIReq->QueryPbData();
        m_cbAvailable = pIReq->QueryCbAvailable();
        m_cbTotal = pIReq->QueryCbTotalBytes();
        }
    else
        {
        m_pbAvailableData = NULL;
        m_cbAvailable = 0;
        m_cbTotal = 0;
        }

    if (m_szFormData)
        {
        m_szFormData[0] = '\0';
        m_szFormClone[0] = '\0';
        }

    if (m_szCookie)
        m_szCookie[0] = '\0';

    if (m_szClCert)
        m_szClCert[0] = '\0';

    return S_OK;
    }

/*===================================================================
CRequestData::GetEmptyStringList

Get empty string list's IDispatch *
Create empty string list on demand
===================================================================*/
HRESULT CRequestData::GetEmptyStringList
(
IDispatch **ppdisp
)
    {
    if (!m_pEmptyString)
        {
        m_pEmptyString = new CStringList;
        if (!m_pEmptyString)
            {
            *ppdisp = NULL;
            return E_FAIL;
            }
        }
    return m_pEmptyString->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(ppdisp));
    }

/*===================================================================
CRequestData::QueryInterface
CRequestData::AddRef
CRequestData::Release

IUnknown members for CRequestData object.
===================================================================*/
STDMETHODIMP CRequestData::QueryInterface
(
REFIID iid,
void **ppvObj
)
    {
    if (iid == IID_IUnknown)
        {
        *ppvObj = this;
        AddRef();
        return S_OK;
        }
    else
        {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        }
    }

STDMETHODIMP_(ULONG) CRequestData::AddRef()
    {
    return ++m_cRefs;
    }

STDMETHODIMP_(ULONG) CRequestData::Release(void)
    {
    if (--m_cRefs)
        return m_cRefs;
    delete this;
    return 0;
    }


/*------------------------------------------------------------------
 * C R e q u e s t
 */

/*===================================================================
CRequest::CRequest

Constructor

Parameters:
    punkOuter   object to ref count (can be NULL)
===================================================================*/
CRequest::CRequest(IUnknown *punkOuter)
    :
    m_fInited(FALSE),
    m_fDiagnostics(FALSE),
    m_pData(NULL)
    {
    CDispatch::Init(IID_IRequest);

    if (punkOuter)
        {
        m_punkOuter = punkOuter;
        m_fOuterUnknown = TRUE;
        }
    else
        {
        m_cRefs = 1;
        m_fOuterUnknown = FALSE;
        }

#ifdef DBG
    m_fDiagnostics = TRUE;
#endif // DBG
    }

/*===================================================================
CRequest::~CRequest

Destructor

Parameters:
    None

Returns:
    Nothing.
===================================================================*/
CRequest::~CRequest()
    {
    Assert(!m_fInited);
    Assert(m_fOuterUnknown || m_cRefs == 0);  // must have 0 ref count
    }

/*===================================================================
CRequest::CleanUp

Deallocates members and removes m_pData

Parameters:
    None

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CRequest::CleanUp()
    {
    if (m_pData)
        {
        m_pData->Release();
        m_pData = NULL;
        }
    return S_OK;
    }

/*===================================================================
CRequest::Init

Allocates m_pData.
Performs any intiailization of a CRequest that's prone to failure
that we also use internally before exposing the object outside.

Parameters:
    None

Returns:
    S_OK on success.
===================================================================*/

HRESULT CRequest::Init()
    {
    if (m_fInited)
        return S_OK; // already inited

    Assert(!m_pData);

    m_pData = new CRequestData(this);
    if (!m_pData)
        return E_OUTOFMEMORY;

    HRESULT hr = m_pData->Init();

    if (SUCCEEDED(hr))
        m_fInited = TRUE;
    else
        CleanUp();

    return hr;
    }

/*===================================================================
CRequest::UnInit

Remove m_pData. Back to UnInited state

Parameters:
    None

Returns:
    HRESULT
===================================================================*/
HRESULT CRequest::UnInit()
    {
    if (!m_fInited)
        return S_OK; // already uninited

    Assert(m_pData);
    CleanUp();
    Assert(!m_pData);

    m_fInited = FALSE;
    return S_OK;
    }

/*===================================================================
Request::ReInit

Each Request we service will have a new CIsapiReqInfo.
This function is used to set the value of the CIsapiReqInfo.

Parameters:
    CIsapiReqInfo *pIReq       CIsapiReqInfo
    CHitObj *pHitObj          HitObj

Returns:
    HRESULT
===================================================================*/

HRESULT CRequest::ReInit
(
CIsapiReqInfo *pIReq,
CHitObj *pHitObj
)
    {
    Assert(m_fInited);
    Assert(m_pData);

    return m_pData->ReInit(pIReq, pHitObj);
    }

/*===================================================================
CRequest::GetCodePage

GetCodePage from current HitObj

Parameters:

Returns:
    CodePage
===================================================================*/
UINT CRequest::GetCodePage()
    {
    Assert(m_fInited);
    Assert(m_pData);
    Assert(m_pData->m_pHitObj);
    return m_pData->m_pHitObj->GetCodePage();
    }

/*===================================================================
CRequest::LoadCookies

Load the Request map with values from the HTTP_COOKIE variable.

Parameters:
    bstrVar     BSTR, which parameter to get the value of
    pbstrRet    BSTR FAR *, return value of the requested parameter

Returns:
    S_OK on success. E_FAIL on failure.

Bugs:
    This code assumes that dictionary cookies are well-formed.
    If they are not, then the results will be unpredictable.

    The dictionary cookies are gauranteed to be well-formed if
    Response.Cookies is used.  If other means, such as a direct
    use of the <META> tag, or if Response.SetCookie is used, we
    are at the mercy of the script writer.
===================================================================*/

HRESULT CRequest::LoadCookies(char *szData)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hResult;

    if (szData == NULL)
        return S_OK;

    // Each cookie definition is moved to a buffer so that we don't
    // overwrite the value of HTTP_COOKIE.  We can save a strcpy()
    // call since 'DecodeFromURL' can copy for us.
    //
    size_t cbCookie = strlen(szData) + 1;
    if (m_pData->m_cbCookie == 0)
        m_pData->m_szCookie = static_cast<char *>(malloc(m_pData->m_cbCookie = cbCookie));

    else if (cbCookie > m_pData->m_cbCookie)
        m_pData->m_szCookie = static_cast<char *>(realloc(m_pData->m_szCookie, m_pData->m_cbCookie = cbCookie));

    if (m_pData->m_szCookie == NULL)
        return E_OUTOFMEMORY;

    char *szDest = m_pData->m_szCookie;
    char chDelimiter;           // delimiter that we found to stop the scan

    while (*szData != '\0')
        {
        char *szName, *szPartialValue;

        // Get the cookie name
        chDelimiter = DecodeFromURL(&szData, ";=", szName = szDest, GetCodePage(), FALSE);
        szDest = strchr(szDest, '\0') + 1;

        if (chDelimiter == '=') 
            {
            // if DecodeFromURL stop scanning because of an equal sign, then the browser sent
            // a value for this cookie

            // Get the cookie's value
            chDelimiter = DecodeFromURL(&szData, ";=", szPartialValue = szDest, GetCodePage(), FALSE);
            szDest = strchr(szDest, '\0') + 1;

            // discard the denali session ID
            if (strncmp(szName, SZ_SESSION_ID_COOKIE_PREFIX, CCH_SESSION_ID_COOKIE_PREFIX) == 0)
                {
                // DENALISESSIONID better not have non-alphabetics in it!  expecting
                // termination with ';' or NUL.
                //
                continue;
                }
            }
        else if (*szName == '\0')
            {
            continue;
            }
        else
            {
            // either we hit a ';' char or end of string.  In either case, this indicates that
            // the cookie has no value.  Set the szPartialValue to an empty string and set the
            // delimiter to ';' to trick the remainder of this function into thinking that the
            // cookie does have a value and that is a simple value (i.e. no sub-cookies).

            chDelimiter = ';';
            szPartialValue = "";
            }

        // Add this cookie to the Request
        CRequestHit *pRequestHit = static_cast<CRequestHit *>(GetStrings()->FindElem(szName, strlen(szName)));
        if (pRequestHit == NULL)
            {
            pRequestHit = new CRequestHit;
            if (pRequestHit == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(pRequestHit->Init(szName))) {
                delete pRequestHit;
                return E_FAIL;
            }

            GetStrings()->AddElem(pRequestHit);

            // This is a new request hit, add it to the array of request hits
            if (!m_pData->m_Cookies.AddRequestHit(pRequestHit))
                {
                return E_OUTOFMEMORY;
                }
            }
        else if (pRequestHit->m_pCookieData)    // a cookie by this name already exists
            {
            if (chDelimiter == '=')                     // eat the rest of this cookie
                DecodeFromURL(&szData, ";", szDest, GetCodePage());    // no need to advance szDest

            continue;                               // discard later cookies
            }

        // The cookie value may be in the form <key1=value1&key2=value2...>
        // or not. If there is an '=' sign present, that lets us know if it
        // is a cookie dictionary or a simple value.
        //
        // We assume that '=' signs that are part of the cookie are escaped in hex.
        //
        if (chDelimiter != '=')
            {
            if (FAILED(hResult = pRequestHit->AddValue(COOKIE, szPartialValue, m_pData->m_pIReq, GetCodePage())))
                return hResult;
            }
        else
            {
            char *szKey = szPartialValue;     // already got the key
            for (;;)
                {
                char *szValue;
                chDelimiter = DecodeFromURL(&szData, ";&", szValue = szDest, GetCodePage(), FALSE);
                szDest = strchr(szDest, '\0') + 1;

                if (FAILED(hResult = pRequestHit->AddKeyAndValue(COOKIE, szKey, szValue, m_pData->m_pIReq, GetCodePage())))
                    return hResult;

                if (chDelimiter == ';' || chDelimiter == '\0')
                    break;

                // get the key, exit when NUL terminator found
                chDelimiter = DecodeFromURL(&szData, "=;", szKey = szDest,  GetCodePage(), FALSE);
                if (chDelimiter == ';' || chDelimiter == '\0')
                    break;

                szDest = strchr(szDest, '\0') + 1;
                }
            }

        }

        return S_OK;
    }


#define CB_CERT_DEFAULT     4096
/*===================================================================
CRequest::LoadClCerts

Load the Request map with values from the CIsapiReqInfo

Parameters:
    szData - ptr to CIsapiReqInfo

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/

HRESULT CRequest::LoadClCerts(char *szData, UINT lCodePage)
{
    HRESULT         hres = S_OK;
    CERT_CONTEXT_EX CertContextEx;
    CCertRequest    CertReq( this );

    STACK_BUFFER( tempCert, CB_CERT_DEFAULT );

    ZeroMemory( &CertContextEx, sizeof(CERT_CONTEXT_EX) );
    
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    CIsapiReqInfo *pIReq = reinterpret_cast<CIsapiReqInfo *>(szData);

    // allocate certificate buffer
    CertContextEx.cbAllocated = tempCert.QuerySize();
    CertContextEx.CertContext.pbCertEncoded = static_cast<BYTE *>(tempCert.QueryPtr());

    // get certificate info from web server
    if ( !pIReq->ServerSupportFunction( HSE_REQ_GET_CERT_INFO_EX,
                                       &CertContextEx,
                                       NULL,
                                       NULL ) )
    {
        DWORD   dwErr = GetLastError();

        if ( dwErr == ERROR_INSUFFICIENT_BUFFER )
        {
            // buffer was too small - realloc and call again
            Assert( CertContextEx.cbAllocated < CertContextEx.CertContext.cbCertEncoded );
            CertContextEx.cbAllocated = CertContextEx.CertContext.cbCertEncoded;

            // If CB_CERT_DEFAULT wasn't enough, we want to allocate from the heap, rather then the stack

            if (tempCert.Resize(CertContextEx.cbAllocated) == FALSE) {
                hres = E_OUTOFMEMORY;
                goto LExit;
            }
            CertContextEx.CertContext.pbCertEncoded = static_cast<BYTE *>(tempCert.QueryPtr());

            if ( !pIReq->ServerSupportFunction(
                                               HSE_REQ_GET_CERT_INFO_EX,
                                               &CertContextEx,
                                               NULL,
                                               NULL ) )
            {
                // if we fail a second time, just bail
                // NOTE this should never happen?
                dwErr = GetLastError();
                Assert(dwErr != ERROR_INSUFFICIENT_BUFFER);
                hres = HRESULT_FROM_WIN32(dwErr);
                goto LExit;
            }

        }
        else if ( dwErr == ERROR_INVALID_PARAMETER )
        {
            // not supported (old IIS)
            hres = S_OK;
            goto LExit;
        }
        else
        {
            hres = HRESULT_FROM_WIN32(dwErr);
            goto LExit;
        }
    }

    if(CertContextEx.CertContext.cbCertEncoded == 0)
    {
        hres = CertReq.NoCertificate();
    }
    else
    {
        hres = CertReq.ParseCertificate( CertContextEx.CertContext.pbCertEncoded,
                                         CertContextEx.CertContext.cbCertEncoded,
                                         CertContextEx.CertContext.dwCertEncodingType,
                                         CertContextEx.dwCertificateFlags,
                                         lCodePage );
    }


LExit:
    return hres;

}



/*===================================================================
CRequest::LoadVariables

Load the Request map with values from a URL encoded string

WARNING:  This function modifies the passed szData!!
Note: this is part of bug 682, but we are not going to fix it for
performance reasons.  Just be aware that this function
screws up the passed in string.

Parameters:
    bstrVar     BSTR, which parameter to get the value of
    pbstrRet    BSTR FAR *, return value of the requested parameter
    lCodePage   UINT, the codepage used in retrieving the data

Returns:
    S_OK on success. E_FAIL on failure.
===================================================================*/

HRESULT CRequest::LoadVariables(CollectionType Source, char *szData, UINT lCodePage)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hResult;

    if (Source == COOKIE)                          // cookies are a special case
        return LoadCookies(szData);                // handle them specially

    if (Source == CLCERT)                          // clcerts are a special case
        return LoadClCerts(szData, lCodePage);     // handle them specially

    if (szData == NULL)         // treat NULL as "no data available"
        return S_OK;

    while (*szData != '\0')
        {
        char *szName, *szValue;

        DecodeFromURL(&szData, "=", szName = szData,  lCodePage, FALSE);
        DecodeFromURL(&szData, "&", szValue = szData, lCodePage, FALSE);

        // this is to handle the case where an un-named pair was passed.
        // skip it and process the next named pair
        //
        if(*szName == '\0')
            continue;

        CRequestHit *pRequestHit = static_cast<CRequestHit *>
            (
            GetStrings()->FindElem(szName, strlen(szName))
            );
        if (pRequestHit == NULL)
            {
            pRequestHit = new CRequestHit;
            if (pRequestHit == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(pRequestHit->Init(szName))) {
                delete pRequestHit;
                return E_FAIL;
            }

            GetStrings()->AddElem(pRequestHit);

            // This is a new request hit, so we should add it
            // to the array of request
            if (Source == QUERYSTRING)
                {
                if (!m_pData->m_QueryString.AddRequestHit(pRequestHit))
                    {
                    return E_FAIL;
                    }
                }
            else if (Source == FORM)
                {
                if (!m_pData->m_FormInputs.AddRequestHit(pRequestHit))
                    {
                    return E_FAIL;
                    }
                }
            }

        if (FAILED(hResult = pRequestHit->AddValue(Source, szValue, m_pData->m_pIReq, lCodePage)))
            return hResult;

        }

    return S_OK;
    }

/*===================================================================
CRequest::QueryInterface
CRequest::AddRef
CRequest::Release

IUnknown members for CRequest object.
===================================================================*/

STDMETHODIMP CRequest::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    // BUG FIX 683 added IID_IDenaliIntrinsic to prevent the user from
    // storing intrinsic objects in the application and session object
    if (iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_IRequest || iid == IID_IDenaliIntrinsic)
        *ppvObj = static_cast<IRequest *>(this);

    else if (iid == IID_ISupportErrorInfo)
        {
        if (m_pData)
            *ppvObj = &(m_pData->m_ISupportErrImp);
        }
        
    // Support IStream for ADO/XML
    else if (iid == IID_IStream )
        {
        *ppvObj = static_cast<IStream *>(this);
        }

    else if (IID_IMarshal == iid)
        {
        *ppvObj = static_cast<IMarshal *>(this);
        }
        
    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CRequest::AddRef(void)
    {
    if (m_fOuterUnknown)
        return m_punkOuter->AddRef();

    return InterlockedIncrement((LPLONG)&m_cRefs);
    }

STDMETHODIMP_(ULONG) CRequest::Release(void)
    {
    if (m_fOuterUnknown)
        return m_punkOuter->Release();

    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
    if (cRefs)
        return cRefs;

    delete this;
    return 0;
    }

/*===================================================================
CRequest::CheckForTombstone

Tombstone stub for IRequest methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:

Returns:
    HRESULT     E_FAIL  if Tombstone
                S_OK if not
===================================================================*/
HRESULT CRequest::CheckForTombstone()
    {
    if (m_fInited)
        {
        // inited - good object
        Assert(m_pData); // must be present for inited objects
        return S_OK;
        }

    ExceptionId
        (
        IID_IRequest,
        IDE_REQUEST,
        IDE_INTRINSIC_OUT_OF_SCOPE
        );
    return E_FAIL;
    }

/*===================================================================
CRequest::get_QueryString

Return the QueryString dictionary
===================================================================*/

HRESULT CRequest::get_QueryString(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_QueryString.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }


/*===================================================================
CRequest::get_Form

Return the Form dictionary
===================================================================*/

HRESULT CRequest::get_Form(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_FormInputs.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_Body

Return the Body dictionary (alias for Form dictionary)
===================================================================*/

HRESULT CRequest::get_Body(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_FormInputs.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_Cookies

Return the Cookies dictionary
===================================================================*/

HRESULT CRequest::get_Cookies(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_Cookies.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_ClientCertificate

Return the ClCerts dictionary
===================================================================*/

HRESULT CRequest::get_ClientCertificate(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_ClCerts.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_ServerVariables

Return the Form dictionary
===================================================================*/

HRESULT CRequest::get_ServerVariables(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_ServerVariables.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_Item

Function called from DispInvoke to get values from any one of four
collections. Search order is "ServerVariables", "QueryString",
"Form", "Cookies", "ClientCertificate"

Parameters:
    bstrVar     BSTR, which parameter to get the value of
    pVarReturn  VARIANT *, return value of the requested parameter

Returns:
    S_OK on success. E_FAIL on failure.
===================================================================*/

HRESULT CRequest::get_Item(BSTR bstrName, IDispatch **ppDispReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (bstrName == NULL)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    UINT            lCodePage = CP_ACP;
    CWCharToMBCS    convName;
    char            *szName;

    // If BinaryRead has been called, the Form collection is no longer available
    // so we insist that the script writer specify which collection to use
    if (m_pData->m_FormDataStatus != AVAILABLE &&
        m_pData->m_FormDataStatus != FORMCOLLECTIONONLY)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_GENERICCOLLECTION_NA);
        return E_FAIL;
        }

    // At this point, we are forced to load the QueryString, Form, Cookies
    // and ClientCertificate
    // collections even though it will only come from one of these.
    //
    if (m_pData->m_fLoadQuery)
        {
        // QueryString can contains DBCS string
        lCodePage = GetCodePage();
        if (FAILED(LoadVariables(QUERYSTRING, GetIReq()->QueryPszQueryString(), lCodePage)))
            return E_FAIL;

        m_pData->m_fLoadQuery = FALSE;
        }

    if (m_pData->m_fLoadCookies)
        {
        char *szCookie = GetIReq()->QueryPszCookie();

        if (FAILED(LoadVariables(COOKIE, szCookie, lCodePage)))
            return E_FAIL;

        m_pData->m_fLoadCookies = FALSE;
        }

    if (m_pData->m_fLoadClCerts)
        {
        lCodePage = GetCodePage();
        if (FAILED(LoadVariables(CLCERT, (char*)GetIReq(), lCodePage)))
            return E_FAIL;

        m_pData->m_fLoadClCerts = FALSE;
        }

    if (m_pData->m_fLoadForm)
        {
        HRESULT hrGetData = CopyClientData();
        if (FAILED(hrGetData))
            return hrGetData;

        // Form can contain DBCS string
        lCodePage = GetCodePage();
        if (FAILED(LoadVariables(FORM, m_pData->m_szFormData, lCodePage)))
            return E_FAIL;

        m_pData->m_fLoadForm = FALSE;
        }

    // Convert name to ANSI
    //
    HRESULT hr;
    if (FAILED(hr = convName.Init(bstrName, lCodePage))) {
        if (hr == E_OUTOFMEMORY) {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            return hr;
        }
        hr = NO_ERROR;
        szName = "";
    }
    else {
        szName = convName.GetString();
    }
    // Look up the name in the collections
    //
    CRequestHit *pRequestHit = static_cast<CRequestHit *>(GetStrings()->FindElem(szName, strlen(szName)));
    if (pRequestHit)
        {
        IUnknown *pValues = NULL;
        if (pRequestHit->m_pQueryData)
            pValues = pRequestHit->m_pQueryData;

        else if (pRequestHit->m_pFormData)
            pValues = pRequestHit->m_pFormData;

        else if (pRequestHit->m_pCookieData)
            pValues = pRequestHit->m_pCookieData;

        else if (pRequestHit->m_pClCertData)
            pValues = pRequestHit->m_pClCertData;

        if (pValues == NULL)
            goto NotFound;

        if (FAILED(pValues->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(ppDispReturn))))
            return E_FAIL;

        return S_OK;
        }

NotFound:
    // Look in server variables
    VARIANT varKey, varValue;

    V_VT(&varKey) = VT_BSTR;
    V_BSTR(&varKey) = bstrName;

    if (m_pData->m_ServerVariables.get_Item(varKey, &varValue) == S_OK)
        {
        Assert (V_VT(&varValue) == VT_DISPATCH);
        *ppDispReturn = V_DISPATCH(&varValue);

        return S_OK;
        }

    if (FAILED(m_pData->GetEmptyStringList(ppDispReturn)))
        return E_FAIL;

    return S_OK;
    }



/*===================================================================
CRequest::CopyClientData

Load the form data (stdin) by using either ReadClient or the
ISAPI buffer
===================================================================*/

HRESULT CRequest::CopyClientData()
{
    HRESULT hr  = S_OK; 

    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    STACK_BUFFER(tempContent, 1024 );

    CIsapiReqInfo *pIReq = m_pData->m_pIReq;

    // assert that the data is in the format we want
    //
	// we need to scan the content type for the supported header,
	// the client my send multiple headers so use strstr to search
	// the header string this is a HOT_FIX for NT BUG:208530
	//
	if (pIReq->QueryPszContentType())
    {
        size_t cbQueryPszContentType = (strlen(pIReq->QueryPszContentType()) + 1);
        if (cbQueryPszContentType > REQUEST_ALLOC_MAX)
        {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_STACK_OVERFLOW);
            return E_FAIL;
        }

        if (tempContent.Resize(cbQueryPszContentType) == FALSE) 
        {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            return E_FAIL;
        }

        CHAR *szQueryPszContentType = _strlwr(
							        strcpy(
								        static_cast<char *>(tempContent.QueryPtr()),
								        pIReq->QueryPszContentType()
								        ));
        if (strstr(szQueryPszContentType, "application/x-www-form-urlencoded") == NULL)
            return S_OK;
    }
	else
		return S_OK;

	//
	// Determine if it is chunked or not.
	//    
    DWORD dwVarSize = 0;
    STACK_BUFFER( varBuff, 128 );    
    
    if (SERVER_GET(pIReq, "HTTP_TRANSFER_ENCODING", &varBuff, &dwVarSize) && 
        (!stricmp(static_cast<char *>(varBuff.QueryPtr()),"chunked")))
            hr = CopyChunkedClientData();    
    else    
        hr = CopyNonChunkedClientData();    

    // Clone the data (LoadVariables will destroy the data)
    
    // Allocate memory for clone. It should theoritically be equal to the size of FormData.        
    if (SUCCEEDED (hr))
    {
    m_pData->m_szFormClone = static_cast<char *>(malloc(m_pData->m_cbFormData));
    if (m_pData->m_szFormClone == NULL)
        return E_OUTOFMEMORY;
    
    // Actually perform the copy of data.    
    strcpy(m_pData->m_szFormClone, m_pData->m_szFormData); 
    }

    return hr;
}

	
/*===================================================================
CRequest::CopyChunkedClientData

Load the form data (stdin) by using either ReadClient or the
ISAPI buffer. This case is called when Data is being sent in a chunks.
===================================================================*/
HRESULT CRequest::CopyChunkedClientData ()
{
    CIsapiReqInfo *pIReq = m_pData->m_pIReq;
    
    // Try to initially allocate units 4K,16K,32K.... 
    // For the current implementation we shall stop at 32K 
    // Which will bring us to an allocation of (48) +4+8+16+32 +32 +32 + .....
    //
    DWORD allocUnit = 4096;    // 0001 0000 0000 0000 B

    
    DWORD cbFormData = (pIReq->QueryCbAvailable() + 1);

    // WinSE 26645: check for interger overflow after every add
    //
    if (cbFormData < 1)
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
        return E_FAIL;
    }

    // Alloc the 4K extra memory.
    cbFormData += allocUnit;
    
    if (cbFormData < allocUnit)
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
        return E_FAIL;
    }


    if (m_pData->m_cbFormData == 0)
        m_pData->m_szFormData = static_cast<char *>(malloc(m_pData->m_cbFormData = cbFormData));        // space for data & its clone

    else if (cbFormData > m_pData->m_cbFormData)
        m_pData->m_szFormData = static_cast<char *>(realloc(m_pData->m_szFormData, m_pData->m_cbFormData = cbFormData));

    if (m_pData->m_szFormData == NULL)
        return E_OUTOFMEMORY;

    char * pszOffset;
    // Once we start to read the form data only the form collection can use it
    m_pData->m_FormDataStatus = FORMCOLLECTIONONLY;
    
    memcpy( m_pData->m_szFormData,
            pIReq->QueryPbData(),
            pIReq->QueryCbAvailable() );

    pszOffset = m_pData->m_szFormData + pIReq->QueryCbAvailable();
    DWORD cBytesToRead = allocUnit;
    DWORD cBytesRead = cBytesToRead;    

    //
    // Call ReadClient until we have read all the data
    //
    while (cBytesRead > 0)
    {
        if ((!pIReq->SyncReadClient(pszOffset, &cBytesRead)) || (cBytesRead == 0))
            break;

        cBytesToRead -= cBytesRead;
        if (cBytesToRead == 0)
        {            
            // Dont allocatate anything larger than 32K unit else double the size of the allocation Unit.
            if (allocUnit < 0x8000)                  
                allocUnit = allocUnit << 1;
            
            // Adjust buffer size
            cbFormData += allocUnit;                

            if (cbFormData < allocUnit)
            {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
                return E_FAIL;
            }

            // Allocate new memory.
            m_pData->m_szFormData = static_cast<char *>(realloc(m_pData->m_szFormData, 
                            m_pData->m_cbFormData = cbFormData));
            // Check for out of memory.
            if (m_pData->m_szFormData == NULL)
                return E_OUTOFMEMORY;  

            // Adjust offset.
            pszOffset = m_pData->m_szFormData + cbFormData - allocUnit -1;
            cBytesToRead = allocUnit;
        }
        else
        {
            pszOffset += cBytesRead;            
        }
        cBytesRead = cBytesToRead;
    }        

    // Adjust cbFormData to read the currect count of data.
    m_pData->m_cbFormData -= cBytesToRead;
    // Add the NULL terminator.
    m_pData->m_szFormData[m_pData->m_cbFormData-1] = '\0';

    return S_OK;
}
	
/*===================================================================
CRequest::CopyNonChunkedClientData

Load the form data (stdin) by using either ReadClient or the
ISAPI buffer. This case is called when the Content Length is known and 
===================================================================*/
HRESULT CRequest::CopyNonChunkedClientData ()
{
    CIsapiReqInfo *pIReq = m_pData->m_pIReq;
    //
    // Allocate enough space for the form data and a copy
    //
    size_t cbFormData = (pIReq->QueryCbTotalBytes() + 1);

    if (cbFormData < 1)
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
        return E_FAIL;
    }

    if (m_pData->m_cbFormData == 0)
        m_pData->m_szFormData = static_cast<char *>(malloc(m_pData->m_cbFormData = cbFormData));        // space for data & its clone

    else if (cbFormData > m_pData->m_cbFormData)
        m_pData->m_szFormData = static_cast<char *>(realloc(m_pData->m_szFormData, m_pData->m_cbFormData = cbFormData));

    if (m_pData->m_szFormData == NULL)
        return E_OUTOFMEMORY;

    char * pszOffset;

    // Once we start to read the form data only the form collection can use it
    m_pData->m_FormDataStatus = FORMCOLLECTIONONLY;

    // Load the data
    //
    if (pIReq->QueryCbTotalBytes() <= pIReq->QueryCbAvailable())
        {
        memcpy( m_pData->m_szFormData,
                pIReq->QueryPbData(),
                pIReq->QueryCbTotalBytes() ); // bytes are available now
        }
    else
        {
        // Some bytes are in the CIsapiReqInfo buffer, we must call ReadClient for others
        // First copy the data in the CIsapiReqInfo buffer
        //
        memcpy( m_pData->m_szFormData,
                pIReq->QueryPbData(),
                pIReq->QueryCbAvailable() );

        DWORD cBytesToRead = pIReq->QueryCbTotalBytes() - pIReq->QueryCbAvailable();
        DWORD cBytesRead = cBytesToRead;
        pszOffset = m_pData->m_szFormData + pIReq->QueryCbAvailable();

        // Call ReadClient until we have read all the data
        //
        while (cBytesToRead > 0)
            {
            if ((!pIReq->SyncReadClient(pszOffset, &cBytesRead)) || (cBytesRead == 0))
                return E_FAIL;
            cBytesToRead -= cBytesRead;
            pszOffset += cBytesRead;
            cBytesRead = cBytesToRead;
            }
        }
    m_pData->m_szFormData[pIReq->QueryCbTotalBytes()] = '\0';


    return S_OK;

}

/*===================================================================
CResponse::GetRequestIterator

Provide a default implementation of get__NewEnum for the Request
collections because most of the collections can use this
implementation.

Parameters:
    Collection - the type of iterator to create
    ppEnumReturn - on return, this points to the new enumeration

Returns:
    Can return E_FAIL or E_OUTOFMEMORY

Side effects:
    None.
===================================================================*/

HRESULT CRequest::GetRequestEnumerator(CollectionType WhichCollection, IUnknown **ppEnumReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    *ppEnumReturn = NULL;

    CRequestIterator *pIterator = new CRequestIterator(this, WhichCollection);
    if (pIterator == NULL)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        return E_OUTOFMEMORY;
        }

    HRESULT hrInit = pIterator->Init();
    if (FAILED(hrInit))
        {
        delete pIterator;
        ExceptionId(IID_IRequestDictionary,
                    IDE_REQUEST,
                    (hrInit == E_OUTOFMEMORY)? IDE_OOM : IDE_UNEXPECTED);
        return hrInit;
        }

    *ppEnumReturn = pIterator;
    return S_OK;
    }

/*===================================================================
CResponse::get_TotalBytes

Presents the number of bytes to expect in the request body

Parameters:
    pcBytes - pointer to long where we will place the number
              of bytes to expect in the request body

Returns:
    Can return E_FAIL

Side effects:
    None.
===================================================================*/

HRESULT CRequest::get_TotalBytes(long *pcbTotal)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (pcbTotal == NULL)
        return E_FAIL;

    Assert(m_pData->m_pIReq);
    *pcbTotal = (long) m_pData->m_pIReq->QueryCbTotalBytes();
    return S_OK;
    }

/*===================================================================
CResponse::BinaryRead

Read bytes from the Request Body to a SafeArray of VT_U1.

Parameters:
    pcBytes     - pointer to long where we will find the number
                  of bytes to read in the request body, and where
                  we will store the number of bytes we read.

     pvarOutput - pointer to variant that will contain the SafeArray we create


Returns:
    Can return E_FAIL or E_OUTOFMEMORY

Side effects:
    Allocates memory.
===================================================================*/

HRESULT CRequest::BinaryRead(VARIANT *pvarCount, VARIANT *pvarReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    SAFEARRAYBOUND rgsabound[1];
    size_t cbToRead = 0;
    size_t cbRead = 0;
    BYTE *pbData = NULL;

    Assert(m_pData->m_pIReq);
    Assert(pvarCount);
    Assert(pvarReturn);

    // Set the variant type of the output parameter
    V_VT(pvarReturn) = VT_ARRAY|VT_UI1;
    V_ARRAY(pvarReturn) = NULL;

    if (m_pData->m_FormDataStatus == FORMCOLLECTIONONLY)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_BINARYREAD_NA);
		hr = E_FAIL;
		goto error;
        }

    // Convert the byte count variant to a long
    if (FAILED(hr = VariantChangeTypeEx(pvarCount, pvarCount, m_pData->m_pHitObj->GetLCID(), 0,  VT_I4)))
        {
        switch (hr)
            {
            case E_OUTOFMEMORY:
                ExceptionId(IID_IResponse, IDE_REQUEST, IDE_OOM);
                break;
            case DISP_E_OVERFLOW:
                hr = E_FAIL;
                ExceptionId(IID_IResponse, IDE_REQUEST, IDE_RESPONSE_UNABLE_TO_CONVERT);
                break;
            case DISP_E_TYPEMISMATCH:
                ExceptionId(IID_IResponse, IDE_REQUEST, IDE_TYPE_MISMATCH);
                break;
            default:
                ExceptionId(IID_IResponse, IDE_REQUEST, IDE_UNEXPECTED);
            }
            goto error;
        }

    cbToRead = V_I4(pvarCount);
    V_I4(pvarCount) = 0;

	if ((signed long) cbToRead < 0)
		{
		ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_BINREAD_BAD_ARG);
		hr = E_FAIL;
		goto error;
		}


    // If 0 bytes are requested, or available we're done
    if (cbToRead == 0 || m_pData->m_cbTotal == 0)
        return S_OK;

    // Allocate a SafeArray for the data
    // If they've asked for more bytes then the request
    // contains, give them all the bytes in the request.
    rgsabound[0].lLbound = 0;
    if (cbToRead > m_pData->m_cbTotal)
        cbToRead = m_pData->m_cbTotal;

    rgsabound[0].cElements = cbToRead;

    V_ARRAY(pvarReturn) = SafeArrayCreate(VT_UI1, 1, rgsabound);
    if (V_ARRAY(pvarReturn) == NULL)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hr = E_OUTOFMEMORY;
        goto error;
        }

    if (FAILED(SafeArrayAccessData(V_ARRAY(pvarReturn), (void **) &pbData)))
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_UNEXPECTED);
        hr = E_UNEXPECTED;
        goto error;
        }

    // There is no turning back now. The Request.Form collection will
    // no longer be available.
    if (m_pData->m_FormDataStatus == AVAILABLE)
        {
        m_pData->m_FormDataStatus = BINARYREADONLY;
        m_pData->m_fLoadForm = FALSE;
        }

    // If the number of bytes requested is less then the number of
    // bytes available (as maintained by the request object),
    // then copy the requested bytes from the request object copy
    // of the pointer to the CIsapiReqInfo buffer, decrement the number of bytes
    // available, and increment the pointer to the CIsapiReqInfo buffer.
    // Otherwise, copy all available bytes from the CIsapiReqInfo buffer, and
    // then issue a call to ReadClient to get the remaining needed bytes.

    if (cbToRead <= m_pData->m_cbAvailable)
        {
        memcpy(pbData, m_pData->m_pbAvailableData, cbToRead);
        m_pData->m_pbAvailableData += cbToRead;
        m_pData->m_cbAvailable -= cbToRead;
        m_pData->m_cbTotal -= cbToRead;
        V_I4(pvarCount) = cbToRead;
        }
    else
        {
        if (m_pData->m_cbAvailable > 0)
            {
            memcpy(pbData, m_pData->m_pbAvailableData, m_pData->m_cbAvailable);
            V_I4(pvarCount) = m_pData->m_cbAvailable;
            cbToRead -= m_pData->m_cbAvailable;
            m_pData->m_cbTotal -= m_pData->m_cbAvailable;
            pbData += m_pData->m_cbAvailable;
            }
        m_pData->m_pbAvailableData = NULL;
        m_pData->m_cbAvailable = 0;
        while (cbToRead)
            {
            cbRead = cbToRead;
            if (!GetIReq()->SyncReadClient(pbData, (DWORD *)&cbRead) || (cbRead == 0))
                {
                SafeArrayUnaccessData(V_ARRAY(pvarReturn));
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_UNEXPECTED);
                hr = E_FAIL;
                goto error;
                }
            pbData += cbRead;
            V_I4(pvarCount) += cbRead;
            m_pData->m_cbTotal -= cbRead;
            cbToRead -= cbRead;
            }
    }

    SafeArrayUnaccessData(V_ARRAY(pvarReturn));
    return S_OK;

error:
    VariantClear(pvarReturn);
    return(hr);
    }


/*===================================================================
IStream implementation for ADO/XML
===================================================================*/

STDMETHODIMP CRequest::Read(
    void *pv,
    ULONG cb,
    ULONG *pcbRead)
{
    if (pv == NULL)
        return E_POINTER;

    ULONG cbReadDummy;
    if (pcbRead == NULL)
        pcbRead = &cbReadDummy;

    if (m_pData->m_FormDataStatus != AVAILABLE &&
        m_pData->m_FormDataStatus != ISTREAMONLY)
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST,
                    IDE_REQUEST_STREAMONLY);
        return E_FAIL;
    }

    // If they've asked for more bytes then the request
    // contains, give them all the bytes in the request.
    if (cb > m_pData->m_cbTotal)
        cb = m_pData->m_cbTotal;

    // There is no turning back now. The Request.Form collection and
    // Request.BinaryRead will no longer be available.
    if (m_pData->m_FormDataStatus == AVAILABLE)
    {
        m_pData->m_FormDataStatus = ISTREAMONLY;
        m_pData->m_fLoadForm = FALSE;
    }

    // If the number of bytes requested is less then the number of
    // bytes available (as maintained by the request object),
    // then copy the requested bytes from the request object copy of
    // the pointer to the CIsapiReqInfo buffer, decrement the number of bytes
    // available, and increment the pointer to the CIsapiReqInfo buffer.
    // Otherwise, copy all available bytes from the CIsapiReqInfo buffer, and
    // then issue a call to ReadClient to get the remaining needed bytes.

    BYTE* pbData = static_cast<BYTE*>(pv);

    if (cb <= m_pData->m_cbAvailable)
    {
        memcpy(pbData, m_pData->m_pbAvailableData, cb);
        m_pData->m_pbAvailableData += cb;
        m_pData->m_cbAvailable -= cb;
        m_pData->m_cbTotal -= cb;
        *pcbRead = cb;
    }
    else
    {
        *pcbRead = 0;
        if (m_pData->m_cbAvailable > 0)
        {
            memcpy(pbData, m_pData->m_pbAvailableData, m_pData->m_cbAvailable);
            *pcbRead = m_pData->m_cbAvailable;
            cb -= m_pData->m_cbAvailable;
            m_pData->m_cbTotal -= m_pData->m_cbAvailable;
            pbData += m_pData->m_cbAvailable;
        }
        m_pData->m_pbAvailableData = NULL;
        m_pData->m_cbAvailable = 0;

        while (cb > 0)
        {
            DWORD cbRead = cb;
            if ((!GetIReq()->SyncReadClient(pbData, &cbRead)) || (cbRead == 0))
            {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST,
                            IDE_UNEXPECTED);
                return E_FAIL;
            }
            pbData += cbRead;
            *pcbRead += cbRead;
            m_pData->m_cbTotal -= cbRead;
            cb -= cbRead;
        }
    }
    
    return S_OK;
}


STDMETHODIMP CRequest::Write(
    const void *pv,
    ULONG cb,
    ULONG *pcbWritten)
{
    return E_NOTIMPL;
}


STDMETHODIMP CRequest::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition)
{
    // We can only do a seek if we're in the first, pre-read portion of the
    // form data
    if (m_pData->m_pbAvailableData == NULL)
        return E_FAIL;

    BYTE* pbAvailableData;

    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        // relative to beginning of stream
        pbAvailableData = m_pData->m_pIReq->QueryPbData() + dlibMove.LowPart;
        break;
    case STREAM_SEEK_CUR:
        // relative to current position in stream
        pbAvailableData = m_pData->m_pbAvailableData + dlibMove.LowPart;
        break;
    case STREAM_SEEK_END:
        // relative to end of stream; not supported
        return E_FAIL;
    };

    // Does the new offset fall within the initial header?
    if (m_pData->m_pIReq->QueryPbData() <= pbAvailableData 
        &&  pbAvailableData < m_pData->m_pIReq->QueryPbData()
                              + m_pData->m_pIReq->QueryCbAvailable())
    {
        DWORD dwDiff = DIFF(pbAvailableData - m_pData->m_pIReq->QueryPbData());
        m_pData->m_pbAvailableData = pbAvailableData;
        m_pData->m_cbAvailable = m_pData->m_pIReq->QueryCbAvailable() - dwDiff;
        m_pData->m_cbTotal = m_pData->m_pIReq->QueryCbTotalBytes() - dwDiff;
        // Return the new position, if wanted
        if (plibNewPosition != NULL)
            plibNewPosition->LowPart = dwDiff;
        return S_OK;
    }

    return E_FAIL;
}

STDMETHODIMP CRequest::SetSize(
    ULARGE_INTEGER libNewSize)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::Commit(
    DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::Clone(
    IStream **ppstm)
{
    return E_NOTIMPL;
}


#ifdef DBG
/*===================================================================
CRequest::AssertValid

Test to make sure that the CRequest object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
    None.
===================================================================*/
VOID CRequest::AssertValid() const
    {
    }
#endif // DBG



/*===================================================================
HexToChar

Convert two digit hex string to a hex byte

Parameters:
    szHex - pointer to two digit hex string

Return Value:
    the character value of the hex string
===================================================================*/

char HexToChar(LPSTR szHex)
    {
    char chResult, chDigit;

    chDigit = (char)CharUpperA((LPSTR)szHex[0]);
    chResult = (chDigit >= 'A'? (chDigit - 'A' + 0xA) : (chDigit - '0')) << 4;

    chDigit = (char)CharUpperA((LPSTR)szHex[1]);
    chResult |= chDigit >= 'A'? (chDigit - 'A' + 0xA) : (chDigit - '0');

    return chResult;
    }



/*===================================================================
DecodeFromURL

Convert two digit hex string to a hex byte

WARNING:  This function modifies the passed pszSource!!
Note: this is part of bug 682, but we are not going to fix it for
performance reasons.  Just be aware that this function
screws up the passed in string.

Parameters:
    pszSource    - in/out parameter points to a substring in the URL which
                   contains a Name=Value pair
    szDelimiters - a set of delimiters for this field
    szDest       - pointer to buffer to hold the substring

Return Value:
    Returns the actual delimiter that caused parsing to halt.
===================================================================*/

char DecodeFromURL(char **pszSource, char *szDelimiters, char *szDest, UINT uCodePage, BOOL fIgnoreCase)
    {
    char  ch;
    char *szSource = *pszSource;
    char *pszDestStart = szDest;
    CPINFO  CpInfo;
    BOOL    fIschLeadingByte = TRUE;
    BOOL    InvalidPercent = FALSE; 

    GetCPInfo(uCodePage, (LPCPINFO)&CpInfo);

    while ((ch = *szSource++) != '\0' &&
        ((!strchr(szDelimiters, ch) && fIschLeadingByte) || (!fIschLeadingByte))) {
        InvalidPercent = FALSE;
        switch (ch) {
            case ' ':       // skip whitespace - assume that all whitespace
            case '\t':      // that we need is escaped
            case '\r':      // all these chars are out of trailing byte range
            case '\n':
            case '\f':
            case '\v':
                Assert(fIschLeadingByte);
                continue;

            case '+':       // '+' is out of trailing byte range, can never be a trailing byte
                *szDest++ = ' ';
                Assert(fIschLeadingByte);
                break;

            case '%':       // '%' is out of trailing byte range, can never be a trailing byte
                if (*szSource == 'u') {
                    if (isxdigit((UCHAR)*(szSource+1)) && 
                        isxdigit((UCHAR)*(szSource+2)) &&
                        isxdigit((UCHAR)*(szSource+3)) &&
                        isxdigit((UCHAR)*(szSource+4))) {
	                    WCHAR   wch[2];
                        int     cch = 1;
    	                wch[0] =  (UCHAR)HexToChar(&szSource[1]) << 8;
        	            wch[0] |= (UCHAR)HexToChar(&szSource[3]);
            	        szSource += 5;

                        // if the current UNICODE value falls into the
                        // range of valid high-Surrogate, check to see if
                        // the next character is in the low-Surrogate
                        // range.

                        if ((wch[0] >= 0xd800)
                            && (wch[0] <= 0xdbff)
                            && (szSource[0] == '%')
                            && (szSource[1] == 'u')
                            && isxdigit((UCHAR)szSource[2])
                            && isxdigit((UCHAR)szSource[3])
                            && isxdigit((UCHAR)szSource[4])
                            && isxdigit((UCHAR)szSource[5])) {

                            // Well, the current UNICODE value is in the high
                            // range and the next portion of the string is
                            // a UNICODE encoding.  Decode it.

                            wch[1] = (UCHAR)HexToChar(&szSource[2]) << 8;
                            wch[1] |= (UCHAR)HexToChar(&szSource[4]);

                            // Now see if it falls in the range of low-Surrogates

                            if ((wch[1] >= 0xdc00)
                                && (wch[1] <= 0xdfff)) {

                                // it does!!!  Up the number of characters in the
                                // string that WideCharToMultiByte is going to
                                // convert.  And advance the source string past this
                                // location.

                                cch = 2;
                                szSource += 6;
                            }
                        }
                	    szDest += WideCharToMultiByte( uCodePage, 0, wch, cch, szDest, 6, NULL, NULL );
                    } else {
                        // What to do here ?
                        // since we have at least the u char after the %, 
                        // keep the u and let the show go on
                    }
                    break;
                }
                else {
                    if (isxdigit((UCHAR)*szSource) && isxdigit((UCHAR)*(szSource+1))) {
                        ch = HexToChar(szSource);
		                szSource += 2;
                    }
                    else 
                    {
                         // the spurious encoding MUST be removed
                         InvalidPercent = TRUE;
                    }
                }
                // FALL THROUGH to "Normal" case

            default:
                if (fIschLeadingByte == TRUE) {
                    if (CpInfo.MaxCharSize > 1) {
                        // if this is a Leading byte, then, the next one is a trailing byte, we need
                        // not process the next char even the next char is in szDelimiter, next char
                        // is just the second byte of a DBCS char.
                        if (IsDBCSLeadByteEx(uCodePage, ch))
                            fIschLeadingByte = FALSE;
                    }
                }
                else {   // A trailing byte
                    // If we skip a DBCS trailing byte, then, the next char we check is a leading byte
                    Assert(CpInfo.MaxCharSize == 2);
                    fIschLeadingByte = TRUE;
                }
                if (!InvalidPercent) {
                    *szDest++ = ch;
                }
        }
    }

    if (ch == '\0')     // End of String - undo increment of szSource
        --szSource;

    *szDest = '\0';

    if (fIgnoreCase)
        CharUpperA(pszDestStart);

    *pszSource = szSource;

    return ch;
    }




/*------------------------------------------------------------------
 * C S e r v V a r s I t e r a t o r
 */

/*===================================================================
CServVarsIterator::CServVarsIterator

Constructor
===================================================================*/

CServVarsIterator::CServVarsIterator()
    {
    m_rgwszKeys   = NULL;
    m_pwszKey     = NULL;
    m_pwchAllHttp = NULL;
    m_cRefs       = 1;
    m_cKeys       = 0;
    }



/*===================================================================
CServVarsIterator::~CServVarsIterator

Destructor
===================================================================*/

CServVarsIterator::~CServVarsIterator()
    {
    delete m_rgwszKeys;
    delete m_pwchAllHttp;
    }



/*===================================================================
CServVarsIterator::Init

Initialize the iterator by:

    * Getting the value of ALL_HTTP, and parsing it to get the
      extra keys

    * creating a dynamic memory area to hold the ALL_HTTP keys

    * setting m_rgwszKeys by copying pointers from rgwszStandardKeys
      and from ALL_HTTP keys

Parameters:
    pIReq - pointer to CIsapiReqInfo used to query for extra headers

Return Value:
    Returns E_OUTOFMEMORY or S_OK
===================================================================*/

HRESULT CServVarsIterator::Init
(
CIsapiReqInfo *pIReq
)
    {
    static wchar_t *rgwszStandardKeys[] = {
                                            L"ALL_HTTP",
                                            L"ALL_RAW",
                                            L"APPL_MD_PATH",
                                            L"APPL_PHYSICAL_PATH",
                                            L"AUTH_PASSWORD",
                                            L"AUTH_TYPE",
                                            L"AUTH_USER",
                                            L"CERT_COOKIE",
                                            L"CERT_FLAGS",
                                            L"CERT_ISSUER",
                                            L"CERT_KEYSIZE",
                                            L"CERT_SECRETKEYSIZE",
                                            L"CERT_SERIALNUMBER",
                                            L"CERT_SERVER_ISSUER",
                                            L"CERT_SERVER_SUBJECT",
                                            L"CERT_SUBJECT",
                                            L"CONTENT_LENGTH",
                                            L"CONTENT_TYPE",
                                            L"GATEWAY_INTERFACE",
// Purposely left out of IIS 4.0            L"HTTP_CFG_ENC_CAPS",
// Purposely left out of IIS 4.0            L"HTTP_REQ_PWD_EXPIRE",
// Purposely left out of IIS 4.0            L"HTTP_REQ_REALM",
                                            L"HTTPS",
                                            L"HTTPS_KEYSIZE",
                                            L"HTTPS_SECRETKEYSIZE",
                                            L"HTTPS_SERVER_ISSUER",
                                            L"HTTPS_SERVER_SUBJECT",
                                            L"INSTANCE_ID",
                                            L"INSTANCE_META_PATH",
                                            L"LOCAL_ADDR",
                                            L"LOGON_USER",
                                            L"PATH_INFO",
                                            L"PATH_TRANSLATED",
                                            L"QUERY_STRING",
                                            L"REMOTE_ADDR",
                                            L"REMOTE_HOST",
                                            L"REMOTE_USER",
                                            L"REQUEST_METHOD",
// Deleted bogus variable in IIS 4.0        L"SCRIPT_MAP",
                                            L"SCRIPT_NAME",
                                            L"SERVER_NAME",
                                            L"SERVER_PORT",
                                            L"SERVER_PORT_SECURE",
                                            L"SERVER_PROTOCOL",
                                            L"SERVER_SOFTWARE",
// Purposely left out of IIS 4.0            L"UNMAPPED_REMOTE_USER",
                                            L"URL"
                                            };

    const int cStandardKeys = sizeof(rgwszStandardKeys) / sizeof(rgwszStandardKeys[0]);

    // Style note:
    //
    //  pwchExtraKeys points not to just one NUL terminated wide string
    //  but a whole sequence of NUL terminated wide string followed by
    //  a double NUL terminator.  I therefore chose not to use the
    //  standard "wsz" hungarian prefix, instead using "pwch" as
    //  "pointer to wide characters"
    //
    int cwchAlloc = 0, cRequestHeaders = 0;
    DWORD dwHeaderSize = 0;

    STACK_BUFFER( extraKeysBuff, 2048 );

    if (!SERVER_GET(pIReq, "ALL_HTTP", &extraKeysBuff, &dwHeaderSize)) {
        if (GetLastError() == E_OUTOFMEMORY) {
            return E_OUTOFMEMORY;
        }
        else {
            return E_FAIL;
        }
    }

    char            *szExtraKeys = (char *)extraKeysBuff.QueryPtr();
    CMBCSToWChar    convStr;
    HRESULT         hrConvResult;

    if (FAILED(hrConvResult = convStr.Init(szExtraKeys))) {
        return hrConvResult;
    }

    wchar_t *pwchExtraKeys = convStr.GetString();

    if (! CreateKeys(pwchExtraKeys, &cwchAlloc, &cRequestHeaders))
        {
            return E_FAIL;
        }

    // At this point, pwchExtraKeys has the strings.  Copy them
    // into more permanent storage.
    //
    if (cwchAlloc)
        {
        Assert(pwchExtraKeys != NULL);
        if ((m_pwchAllHttp = new wchar_t [cwchAlloc]) == NULL)
            return E_OUTOFMEMORY;

        memcpy(m_pwchAllHttp, pwchExtraKeys, cwchAlloc * sizeof(wchar_t));
        }
    else
        m_pwchAllHttp = NULL;

    // Allocate the array of keys, m_rgwszKeys, and copy the standard
    // ISAPI keys, the extra keys from the request headers, and a
    // terminating NULL to easily mark the end of an iteration.
    //
    if ((m_rgwszKeys = new wchar_t *[cStandardKeys + cRequestHeaders + 1]) == NULL)
        return E_OUTOFMEMORY;

    m_cKeys = cStandardKeys + cRequestHeaders;

    wchar_t **pwszKey = m_rgwszKeys;
    int i;

    for (i = 0; i < cStandardKeys; ++i)
        *pwszKey++ = rgwszStandardKeys[i];

    wchar_t *pwch = m_pwchAllHttp;
    for (i = 0; i < cRequestHeaders; ++i)
        {
        *pwszKey++ = pwch;
        pwch = wcschr(pwch, L'\0') + 1;
        }

    // make sure that cRequestHeaders was equal to the actual number of strings
    // in the pwchAllHttp string table.  (Do this by making sure that we stored
    // the exact amount of bytes and are now at the NULL terminator)
    //
    Assert (*pwch == L'\0' && (pwch - m_pwchAllHttp + 1) == cwchAlloc);

    *pwszKey = NULL;                // terminate the array
    return Reset();                 // reset the iterator
    }



/*===================================================================
CServVarsIterator::CreateKeys

Parse the string from Request.ServerVariables["ALL_HTTP"], then
transform the string into a list of NUL terminated wide strings
in place, terminated with a double NUL.

Parameters:
    pwchKeys -
        Input: Contains the value of Request.ServerVariables["ALL_HTTP"]
                as a wide string

        Output: Contains the keys from Request.ServerVariables["ALL_HTTP"],
                each key is separated by a NUL terminator, and the entire
                list of keys is terminated by a double NUL.

    pwchAlloc -
        Output: Contains the number of wide characters that should be
                allocated to contain the entire list of strings pointed
                to by pwchKeys

    pcRequestHeaders -
        Output: Contains the number of keys that were found in
                Request.ServerVariables["ALL_HTTP"].

Return Value:
    true if successful
===================================================================*/

BOOL CServVarsIterator::CreateKeys(wchar_t *pwchKeys, int *pcwchAlloc, int *pcRequestHeaders)
    {
    wchar_t *pwchSrc = pwchKeys;            // source
    wchar_t *pwchDest = pwchKeys;           // destination

    if (pwchKeys == NULL)
        {
        *pcwchAlloc = 0;
        *pcRequestHeaders = 0;
        return TRUE;
        }

    // Loop over pwchKeys until we hit the NUL terminator
    //
    *pcRequestHeaders = 0;
    while (*pwchSrc)
        {
        // Copy characters up to the ':' and store in pwchDest
        //
        while (*pwchSrc != L':')
            {
            if (*pwchSrc == L'\0')     // WinSE 27000
                {
                    return FALSE;
                }

            *pwchDest++ = *pwchSrc++;
            }

        // now NUL terminate pwchDest, advance pwchSrc, increment cRequestHeaders
        //
        *pwchDest++ = L'\0';
        ++pwchSrc;
        ++*pcRequestHeaders;

        // Skip characters until we find a \r OR \n
        //
        // If wcspbrk returns NULL here, it means there was no terminating
        // \r or \n.  In this case we can exit the loop because there
        // are no more keys (the value must have ran to the end of the
        // string without termination)
        //
        pwchSrc = wcspbrk(pwchSrc, L"\r\n");
        if (! pwchSrc)
            break;

        // we found either \r OR \n. Skip the remaining whitspace char.
        //
        while (*pwchSrc == L'\r' || *pwchSrc == L'\n')
            ++pwchSrc;

        // pwchSrc now points to the next key.
        }

    // terminate with the final NUL.
    *pwchDest++ = L'\0';
    *pcwchAlloc = DIFF(pwchDest - pwchKeys);

    return TRUE;
    }



/*===================================================================
CServVarsIterator::QueryInterface
CServVarsIterator::AddRef
CServVarsIterator::Release

IUnknown members for CServVarsIterator object.
===================================================================*/

STDMETHODIMP CServVarsIterator::QueryInterface(REFIID iid, void **ppvObj)
    {
    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
        {
        AddRef();
        *ppvObj = this;
        return S_OK;
        }

    *ppvObj = NULL;
    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CServVarsIterator::AddRef()
    {
    return ++m_cRefs;
    }


STDMETHODIMP_(ULONG) CServVarsIterator::Release()
    {
    if (--m_cRefs > 0)
        return m_cRefs;

    delete this;
    return 0;
    }



/*===================================================================
CServVarsIterator::Clone

Clone this iterator (standard method)

NOTE:
    Cloning this iterator is quite involved.  (It essentially
    involves copying the allocated memory, then adjusting
    ONLY the dynamic pointers in the rgwszKeys array.)

    Right now, this is NYI, as our client (VBScript)
    does not clone this iterator.
===================================================================*/

STDMETHODIMP CServVarsIterator::Clone(IEnumVARIANT **ppEnumReturn)
    {
    return E_NOTIMPL;
    }



/*===================================================================
CServVarsIterator::Next

Get next value (standard method)

To rehash standard OLE semantics:

    We get the next "cElements" from the collection and store them
    in "rgVariant" which holds at least "cElements" items.  On
    return "*pcElementsFetched" contains the actual number of elements
    stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
    otherwise.
===================================================================*/

STDMETHODIMP CServVarsIterator::Next(unsigned long cElementsRequested, VARIANT *rgVariant, unsigned long *pcElementsFetched)
    {
    // give a valid pointer value to 'pcElementsFetched'
    //
    unsigned long cElementsFetched;
    if (pcElementsFetched == NULL)
        pcElementsFetched = &cElementsFetched;

    // Loop through the collection until either we reach the end or
    // cElements becomes zero
    //
    unsigned long cElements = cElementsRequested;
    *pcElementsFetched = 0;

    while (cElements > 0 && *m_pwszKey != NULL)
        {
        BSTR bstrT = SysAllocString(*m_pwszKey);
        if (bstrT == NULL)
            return E_OUTOFMEMORY;
        V_VT(rgVariant) = VT_BSTR;
        V_BSTR(rgVariant) = bstrT;

        ++m_pwszKey;
        ++rgVariant;
        --cElements;
        ++*pcElementsFetched;
        }

    // initialize the remaining variants
    //
    while (cElements-- > 0)
        VariantInit(rgVariant++);

    return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
    }



/*===================================================================
CServVarsIterator::Skip

Skip items (standard method)

To rehash standard OLE semantics:

    We skip over the next "cElements" from the collection.
    Returns S_FALSE if less than "cElements" were skipped, S_OK
    otherwise.
===================================================================*/

STDMETHODIMP CServVarsIterator::Skip(unsigned long cElements)
    {
    /* Loop through the collection until either we reach the end or
     * cElements becomes zero
     */
    while (cElements > 0 && *m_pwszKey != NULL)
        {
        --cElements;
        ++m_pwszKey;
        }

    return (cElements == 0)? S_OK : S_FALSE;
    }



/*===================================================================
CServVarsIterator::Reset

Reset the iterator (standard method)
===================================================================*/

STDMETHODIMP CServVarsIterator::Reset()
    {
    m_pwszKey = &m_rgwszKeys[0];
    return S_OK;
    }



/*------------------------------------------------------------------
 * C R e q u e s t I t e r a t o r
 */

/*===================================================================
CRequestIterator::CRequestIterator

Constructor

NOTE: CRequest is (currently) not refcounted.  AddRef/Release
      added to protect against future changes.
===================================================================*/

CRequestIterator::CRequestIterator(CRequest *pRequest, CollectionType Collection)
    {
    m_Collection  = Collection;
    m_pRequest    = pRequest;
    m_cRefs       = 1;
    m_pRequestHit = NULL;       // Init() will change this pointer anyway...

    m_pRequest->AddRef();
    }



/*===================================================================
CRequestIterator::CRequestIterator

Destructor
===================================================================*/

CRequestIterator::~CRequestIterator()
    {
    m_pRequest->Release();
    }



/*===================================================================
CRequestIterator::Init

Initialize the iterator by loading the collection that we are
about to iterate over.

Return Value:
    Returns E_FAIL if there were problems loading the collection,
    and possibly E_OUTOFMEMORY.
===================================================================*/

HRESULT CRequestIterator::Init()
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    switch (m_Collection)
        {
    case QUERYSTRING:
        if (m_pRequest->m_pData->m_fLoadQuery)
            {
            if (FAILED(m_pRequest->LoadVariables(QUERYSTRING, m_pRequest->GetIReq()->QueryPszQueryString(), m_pRequest->GetCodePage())))
                return E_FAIL;

            m_pRequest->m_pData->m_fLoadQuery = FALSE;
            }
        break;

    case FORM:
        if (m_pRequest->m_pData->m_fLoadForm)
            {
            HRESULT hrGetData = m_pRequest->CopyClientData();
            if (FAILED(hrGetData))
                return hrGetData;

            if (FAILED(m_pRequest->LoadVariables(FORM, m_pRequest->m_pData->m_szFormData, m_pRequest->GetCodePage())))
                return E_FAIL;

            m_pRequest->m_pData->m_fLoadForm = FALSE;
            }
        break;

    case COOKIE:
        if (m_pRequest->m_pData->m_fLoadCookies)
            {
            char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();

            if (FAILED(m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
                return E_FAIL;

            m_pRequest->m_pData->m_fLoadCookies = FALSE;
            }
        break;

    case CLCERT:
        if (m_pRequest->m_pData->m_fLoadClCerts)
            {
            if (FAILED(m_pRequest->LoadVariables(CLCERT, (char*)m_pRequest->GetIReq(), m_pRequest->GetCodePage())))
                return E_FAIL;

            m_pRequest->m_pData->m_fLoadClCerts = FALSE;
            }
        break;
        }

    return Reset();
    }



/*===================================================================
CRequestIterator::QueryInterface
CRequestIterator::AddRef
CRequestIterator::Release

IUnknown members for CRequestIterator object.
===================================================================*/

STDMETHODIMP CRequestIterator::QueryInterface(REFIID iid, void **ppvObj)
    {
    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
        {
        AddRef();
        *ppvObj = this;
        return S_OK;
        }

    *ppvObj = NULL;
    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CRequestIterator::AddRef()
    {
    return ++m_cRefs;
    }


STDMETHODIMP_(ULONG) CRequestIterator::Release()
    {
    if (--m_cRefs > 0)
        return m_cRefs;

    delete this;
    return 0;
    }



/*===================================================================
CRequestIterator::Clone

Clone this iterator (standard method)
===================================================================*/

STDMETHODIMP CRequestIterator::Clone(IEnumVARIANT **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    CRequestIterator *pNewIterator = new CRequestIterator(m_pRequest, m_Collection);
    if (pNewIterator == NULL)
        return E_OUTOFMEMORY;

    // new iterator should point to same location as this.
    pNewIterator->m_pRequestHit = m_pRequestHit;

    *ppEnumReturn = pNewIterator;
    return S_OK;
    }



/*===================================================================
CRequestIterator::Next

Get next value (standard method)

To rehash standard OLE semantics:

    We get the next "cElements" from the collection and store them
    in "rgVariant" which holds at least "cElements" items.  On
    return "*pcElementsFetched" contains the actual number of elements
    stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
    otherwise.
===================================================================*/

STDMETHODIMP CRequestIterator::Next(unsigned long cElementsRequested, VARIANT *rgVariant, unsigned long *pcElementsFetched)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    // give a valid pointer value to 'pcElementsFetched'
    //
    unsigned long cElementsFetched;
    if (pcElementsFetched == NULL)
        pcElementsFetched = &cElementsFetched;

    // Loop through the collection until either we reach the end or
    // cElements becomes zero
    //
    unsigned long cElements = cElementsRequested;
    *pcElementsFetched = 0;

    while (cElements > 0 && m_pRequestHit != NULL)
        {
        BOOL fHaveData = FALSE;
        switch (m_Collection)
            {
        case QUERYSTRING:
            fHaveData = m_pRequestHit->m_pQueryData != NULL;
            break;

        case FORM:
            fHaveData = m_pRequestHit->m_pFormData != NULL;
            break;

        case COOKIE:
            fHaveData = m_pRequestHit->m_pCookieData != NULL;
            break;

        case CLCERT:
            fHaveData = m_pRequestHit->m_pClCertData != NULL;
            }

        if (fHaveData)
            {
            BSTR bstrT;
            if (FAILED(SysAllocStringFromSz(reinterpret_cast<char *>(m_pRequestHit->m_pKey), 0, &bstrT,m_pRequest->GetCodePage())))
                return E_OUTOFMEMORY;
            V_VT(rgVariant) = VT_BSTR;
            V_BSTR(rgVariant) = bstrT;

            ++rgVariant;
            --cElements;
            ++*pcElementsFetched;
            }

        m_pRequestHit = static_cast<CRequestHit *>(m_pRequestHit->m_pPrev);
        }

    // initialize the remaining variants
    //
    while (cElements-- > 0)
        VariantInit(rgVariant++);

    return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
    }



/*===================================================================
CRequestIterator::Skip

Skip items (standard method)

To rehash standard OLE semantics:

    We skip over the next "cElements" from the collection.
    Returns S_FALSE if less than "cElements" were skipped, S_OK
    otherwise.
===================================================================*/

STDMETHODIMP CRequestIterator::Skip(unsigned long cElements)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    /* Loop through the collection until either we reach the end or
     * cElements becomes zero
     */
    while (cElements > 0 && m_pRequestHit != NULL)
        {
        BOOL fHaveData = FALSE;
        switch (m_Collection)
            {
        case QUERYSTRING:
            fHaveData = m_pRequestHit->m_pQueryData != NULL;
            break;

        case FORM:
            fHaveData = m_pRequestHit->m_pFormData != NULL;
            break;

        case COOKIE:
            fHaveData = m_pRequestHit->m_pCookieData != NULL;
            break;

        case CLCERT:
            fHaveData = m_pRequestHit->m_pClCertData != NULL;
            }

        if (fHaveData)
            --cElements;

        m_pRequestHit = static_cast<CRequestHit *>(m_pRequestHit->m_pPrev);
        }

    return (cElements == 0)? S_OK : S_FALSE;
    }



/*===================================================================
CRequestIterator::Reset

Reset the iterator (standard method)
===================================================================*/

STDMETHODIMP CRequestIterator::Reset()
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    m_pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Tail());
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\mtacb.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MTA Callback

File: mtacb.cpp

Owner: DmitryR

This file contains the implementation of MTA callbacks
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "MTAcb.h"
#include "memchk.h"

/*===================================================================
  MTA Callback Thread

  Worker thread that implements the MTA callback functionality
===================================================================*/
class CMTACallbackThread
    {
private:
    DWORD m_fInited : 1;    // inited?
    DWORD m_fCSInited : 1;  // critical section inited?
    DWORD m_fShutdown : 1;  // shutdown?

    CRITICAL_SECTION  m_csLock;      // callback critical section
    HANDLE            m_hDoItEvent;  // callback requested event
    HANDLE            m_hDoneEvent;  // callback done event
    HANDLE            m_hThread;     // thread handle

    PMTACALLBACK      m_pMTACallback;   // callback function ptr
    void             *m_pvContext;      // arg1
    void             *m_pvContext2;     // arg2
    HRESULT           m_hrResult;       // return code

    // The call callback from MTA thread
    void DoCallback()
        {
        Assert(m_pMTACallback);
        m_hrResult = (*m_pMTACallback)(m_pvContext, m_pvContext2);
        }

    // The thread function
    static void __cdecl Thread(void *pvArg)
        {
        HRESULT hr;

        Assert(pvArg);
        CMTACallbackThread *pThread = (CMTACallbackThread *)pvArg;

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);  // MTA
        if (FAILED(hr))
            {
            // Bug 87857: Handle failure from CoInitialize
            if (hr == E_INVALIDARG)
                {
                CoUninitialize();
                }
                
            // This shouldnt actually fail.  Not entirely clear what to do if it does
            Assert(FALSE);
            return;
            }

        while (!pThread->m_fShutdown)
            {
            DWORD dwRet = MsgWaitForMultipleObjects
                (
                1,
                &(pThread->m_hDoItEvent),
                FALSE,
                INFINITE,
                QS_ALLINPUT
                );

            if (pThread->m_fShutdown)
                break;

            if (dwRet == WAIT_OBJECT_0)
                {
                // Event -> do the callback
                pThread->DoCallback();
                SetEvent(pThread->m_hDoneEvent);
                }
            else
                {
                // Do messages
                MSG msg;
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                    DispatchMessage(&msg);
                }
            }

        CoUninitialize();
        }

public:
    // Constructor
    CMTACallbackThread()
        : m_fInited(FALSE), m_fCSInited(FALSE), m_fShutdown(FALSE),
          m_hDoItEvent(NULL), m_hDoneEvent(NULL), m_hThread(NULL),
          m_pMTACallback(NULL)
        {
        }

    // Destructor
    ~CMTACallbackThread()
        {
        // Real cleanup is in UnInit()
        // This is to cleanup after a bad Init()
        if (m_fCSInited)
            DeleteCriticalSection(&m_csLock);
        if (m_hDoItEvent)
            CloseHandle(m_hDoItEvent);
        if (m_hDoneEvent)
            CloseHandle(m_hDoneEvent);
        }

    // Init (real constructor)
    HRESULT Init()
        {
        HRESULT hr = S_OK;

        if (SUCCEEDED(hr))
            {
            ErrInitCriticalSection(&m_csLock, hr);
            m_fCSInited = SUCCEEDED(hr);
            }

        if (SUCCEEDED(hr))
            {
            m_hDoItEvent = IIS_CREATE_EVENT(
                               "CMTACallbackThread::m_hDoItEvent",
                               this,
                               FALSE,
                               FALSE
                               );
            if (!m_hDoItEvent)
                hr = E_OUTOFMEMORY;
            }

        if (SUCCEEDED(hr))
            {
            m_hDoneEvent = IIS_CREATE_EVENT(
                               "CMTACallbackThread::m_hDoneEvent",
                               this,
                               FALSE,
                               FALSE
                               );
            if (!m_hDoneEvent)
                hr = E_OUTOFMEMORY;
            }
        
        // Launch the MTA thread

        uintptr_t ulThread = _beginthread(CMTACallbackThread::Thread, 0, this);
        if (ulThread == 0xffffffff || ulThread == 0)
            hr = E_OUTOFMEMORY;
        else
            m_hThread = (HANDLE)ulThread;

        if (SUCCEEDED(hr))
            m_fInited = TRUE;
        return hr;
        }

    // UnInit (real destructor)
    HRESULT UnInit()
        {
        Assert(m_fInited);

        if (m_hThread)
            {
            // Kill the MTA thread
            m_fShutdown = TRUE;
            SetEvent(m_hDoItEvent);
            WaitForSingleObject(m_hThread, INFINITE);
            m_hThread = NULL;
            }

        if (m_fCSInited)
            {
            DeleteCriticalSection(&m_csLock);
            m_fCSInited = FALSE;
            }

        if (m_hDoItEvent)
            {
            CloseHandle(m_hDoItEvent);
            m_hDoItEvent = NULL;
            }

        if (m_hDoneEvent)
            {
            CloseHandle(m_hDoneEvent);
            m_hDoneEvent = NULL;
            }
    
        m_fInited = FALSE;
        return S_OK;
        }

    // Execute callback
    HRESULT CallCallback
    (
    PMTACALLBACK pMTACallback,
    void        *pvContext,
    void        *pvContext2
    )
        {
        if (m_fShutdown)
            return E_FAIL;

        Assert(m_fInited);
        Assert(pMTACallback);

        HRESULT hr = E_FAIL;
        DWORD   eventSignaled;

        EnterCriticalSection(&m_csLock);

        Assert(m_pMTACallback == NULL);
        m_pMTACallback = pMTACallback;
        m_pvContext  = pvContext;
        m_pvContext2 = pvContext2;
        m_hrResult   = E_FAIL;

        // Tell MTA thread to call back
        SetEvent(m_hDoItEvent);

        // Wait till done
        CoWaitForMultipleHandles(0,
                                 INFINITE,
                                 1,
                                 &m_hDoneEvent,
                                 &eventSignaled);

        // remember HRESULT
        hr = m_hrResult;

        // to make sure we never do it twice
        m_pMTACallback = NULL;

        LeaveCriticalSection(&m_csLock);
        return hr;
        }
    };

// Sole instance of the above
static CMTACallbackThread g_MTACallbackThread;

/*===================================================================
  E x t e r n a l  A P I
===================================================================*/

/*===================================================================
InitMTACallbacks

To be called from DllInit()
Inits the MTA callback processing
Launches the MTA thread

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT InitMTACallbacks()
    {
    return g_MTACallbackThread.Init();
    }

/*===================================================================
UnInitMTACallbacks

To be called from DllUnInit()
Stops the MTA callback processing
Kills the MTA thread

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT UnInitMTACallbacks()
    {
    return g_MTACallbackThread.UnInit();
    }

/*===================================================================
CallMTACallback

Calls the hack.

Parameters
    PMTACALLBACK  pMTACallback       call this function
    void         *pvContext          pass this to it
    void         *pvContext2         extra arg

Returns:
    HRESULT
===================================================================*/
HRESULT CallMTACallback
(
PMTACALLBACK pMTACallback,
void        *pvContext,
void        *pvContext2
)
    {
    return g_MTACallbackThread.CallCallback
        (
        pMTACallback,
        pvContext,
        pvContext2
        );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\request.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request object

File: Request.h

Owner: CGrant, DGottner

This file contains the header info for defining the Request object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef _Request_H
#define _Request_H

#include "debug.h"
#include "util.h"
#include "hashing.h"
#include "dispatch.h"
#include "strlist.h"
#include "asptlb.h"
#include "response.h"
#include "memcls.h" 
#include "ftm.h"

#ifdef USE_LOCALE
extern DWORD	 g_dwTLS;
#endif

class CCookie;
class CClCert;
class CRequestHit;
class CServVarsIterator;

// Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);

enum CollectionType {NONE, SERVERVARIABLE, QUERYSTRING, FORM, COOKIE, CLCERT };
enum FormDataStatus {AVAILABLE, BINARYREADONLY, FORMCOLLECTIONONLY, ISTREAMONLY};

class CRequest;

#define	NUM_REQUEST_HITS 32

/*
 * C R e q u e s t H i t s A r r a y
 *
 * Base class for:
 *      CQueryString
 *      CFormInputs
 *      CCookies
 *      CClCerts
 *
 * Implements self-reallocating array of CRequestHit 
 */

class CRequestHitsArray
    {
protected:    
	DWORD			m_dwCount;			// How many Request hits there are
	DWORD			m_dwHitMax;			// Number of slots available to store Request hits
	CRequestHit**	m_rgRequestHit;		// Array of Request hits

    CRequestHitsArray();
    ~CRequestHitsArray();

    inline HRESULT Init()
        {
        m_dwCount = 0;
        m_dwHitMax = 0;
        m_rgRequestHit = NULL;
        return S_OK;
        }
        
    inline HRESULT ReInit() 
        {
        m_dwCount = 0; 
        return S_OK;
        }

public:
	BOOL AddRequestHit(CRequestHit *pHit);
	
    };

/*
 * C Q u e r y S t r i n g
 *
 * Implements the QueryString object (interface derived from IRequestDictionary)
 */

class CQueryString : public IRequestDictionaryImpl, public CRequestHitsArray
	{
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr

public:
	CQueryString(CRequest *, IUnknown *);

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT varKey, VARIANT *pvarReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);

	HRESULT			Init();
	HRESULT         ReInit();

	~CQueryString();
	};
 


/*
 * C S e r v e r V a r i a b l e s
 *
 * Implements the ServerVariables object (interface derived from IRequestDictionary)
 */

class CServerVariables : public IRequestDictionaryImpl
	{
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr
	CServVarsIterator *	m_pIterator;		// we use an iterator to support integer index

public:
	CServerVariables(CRequest *, IUnknown *);
	HRESULT Init()
		{
		return S_OK;
		}

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT Var, VARIANT *pVariantReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);

	// We've added a destructor, but didn't want to change the
	// order of the existing vtbl entries.
	~CServerVariables();
	};


/*
 * C F o r m I n p u t s
 *
 * Implements the Form object (interface derived from IRequestDictionary)
 */

class CFormInputs : public IRequestDictionaryImpl, public CRequestHitsArray
	{
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr

public:
	CFormInputs(CRequest *, IUnknown *);
	HRESULT Init();
	HRESULT ReInit();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT Var, VARIANT *pVariantReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);

	~CFormInputs();
	};
 

/*
 * C C o o k i e s
 *
 * Implements the Cookies object (interface derived from IRequestDictionary)
 */

class CCookies : public IRequestDictionaryImpl, public CRequestHitsArray
	{
friend CResponseCookies;
	
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr
	CCookie *			m_pEmptyCookie;		// for when the cookie is not there

public:
	CCookies(CRequest *, IUnknown *);
	~CCookies();
	HRESULT Init();
	HRESULT ReInit();
		
	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
   	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT Var, VARIANT *pVariantReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);
	};
 


/*
 * C C l C e r t s
 *
 * Implements the ClCerts object (interface derived from IRequestDictionary)
 */

class CClCerts : public IRequestDictionaryImpl, public CRequestHitsArray
	{
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr
	CClCert *			m_pEmptyClCert;		// for when the clcert is not there

public:
	CClCerts(CRequest *, IUnknown *);
	~CClCerts();
	HRESULT Init();
	HRESULT ReInit();
		
	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT Var, VARIANT *pVariantReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);
	};


/*
 * C R e q u e s t H i t
 *
 * Implements the RequestHit object
 */

class CRequestHit : private CLinkElem
	{
friend class CRequest;
friend class CRequestData;
friend class CQueryString;
friend class CFormInputs;
friend class CCookies;
friend class CClCerts;
friend class CCertRequest;
friend class CResponseCookies;
friend class CRequestIterator;

private:
	BOOL			m_fInited:1;
	BOOL			m_fDuplicate:1;
	CStringList		*m_pQueryData, *m_pFormData;
	CCookie			*m_pCookieData;
	CClCert			*m_pClCertData;

public:
	CRequestHit();
	~CRequestHit();

	HRESULT Init(char *szName, BOOL fDuplicate = FALSE);
	HRESULT AddValue(CollectionType source, char *szValue, CIsapiReqInfo *, UINT lCodePage);
    HRESULT AddCertValue(VARENUM ve, LPBYTE pValue, UINT cLen );
	HRESULT AddKeyAndValue(CollectionType source, char *szKey, char *szValue, CIsapiReqInfo *, UINT lCodePage);

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

/*
 * C R e q u e s t D a t a
 *
 * Structure that holds the intrinsic's properties.
 * The instrinsic keeps pointer to it (NULL when lightweight)
 */
class CRequestData : public IUnknown
    {
friend class CRequest;
friend class CResponse;
friend class CQueryString;
friend class CServerVariables;
friend class CFormInputs;
friend class CCookies;
friend class CClCerts;
friend class CResponseCookies;
friend class CRequestIterator;
friend class CCertRequest;

private:
    // constructor to pass params to members and init members
    CRequestData(CRequest *pRequest);
    ~CRequestData();

    HRESULT Init();
	HRESULT	ReInit(CIsapiReqInfo *pIReq, CHitObj *pHitObj);

	HRESULT GetEmptyStringList(IDispatch **ppdisp);
    
	CSupportErrorInfo		m_ISupportErrImp;	// Implementation of ISupportErrorInfo for this object
	CIsapiReqInfo *         m_pIReq;			    // CIsapiReqInfo block for HTTP info
	CHitObj	*				m_pHitObj;			// pointer to hitobj for this request
	CHashTableMBStr			m_mpszStrings;		// map sz's to string lists
	BOOL					m_fLoadForm:1;		// do we need to load the body?
	BOOL					m_fLoadQuery:1;		// do we need to load QueryString?
	BOOL					m_fLoadCookies:1;	// do we need to load Cookies?
	BOOL					m_fLoadClCerts:1;	// do we need to load ClCerts?
	FormDataStatus			m_FormDataStatus;	// Is form data available for BinaryRead or Form Collection?
	BYTE *					m_pbAvailableData;	// pointer to available data in CIsapiReqInfo
	size_t					m_cbAvailable;		// number of bytes available in CIsapiReqInfo
	size_t					m_cbTotal;			// Total number of bytes remaining in request
	char *					m_szFormData;		// pointer to form data (allocted or CIsapiReqInfo)
	size_t					m_cbFormData;		// number of bytes allocated for form data
	char *					m_szFormClone;		// clone of form data (LoadVariables clobbers)
	char *					m_szCookie;			// clone of cookie data (this one gets trashed)
	size_t					m_cbCookie;			// number of bytes allocated for the cookie data
	char *					m_szClCert;			// clone of clcert data (this one gets trashed)
	size_t					m_cbClCert;			// number of bytes allocated for the clcert data
	CStringList *			m_pEmptyString;		// all empty results share the same object
	CQueryString			m_QueryString;		// pointer to the "QueryString" object
	CServerVariables		m_ServerVariables;	// pointer to the "ServerVariables" object
	CFormInputs				m_FormInputs;		// pointer to the "Form" object
	CCookies				m_Cookies;			// pointer to the "Cookies" object
	CClCerts    			m_ClCerts;			// pointer to the "ClCert" object
	ULONG                   m_cRefs;            // ref count

public:
	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*
 * C R e q u e s t
 *
 * Implements the Request object
 */
class CRequest : public IRequestImpl, public CFTMImplementation, public IStream
	{
friend class CQueryString;
friend class CServerVariables;
friend class CFormInputs;
friend class CCookies;
friend class CClCerts;
friend class CResponseCookies;
friend class CRequestIterator;
friend class CCertRequest;

private:
    // Flags
	DWORD m_fInited : 1;	    // Is initialized?
	DWORD m_fDiagnostics : 1;   // Display ref count in debug output
	DWORD m_fOuterUnknown : 1;  // Ref count outer unknown?

    // Ref count / Outer unknown
    union
    {
    DWORD m_cRefs;
    IUnknown *m_punkOuter;
    };

    // Properties
    CRequestData *m_pData;   // pointer to structure that holds
                             // CRequest properties

    UINT GetCodePage();

	HRESULT LoadVariables(CollectionType Source, char *szURL, UINT lCodePage);
	HRESULT LoadCookies(char *szCookies);
	HRESULT LoadClCerts(char *szClCerts, UINT lCodePage);

	HRESULT LoadCertList( LPSTR pszPrefix, LPSTR* pszCertList);
	HRESULT CopyClientData();
    HRESULT GetRequestEnumerator(CollectionType, IUnknown **ppEnumReturn);

    // Added support for chunked Transfer in Request.form  
    HRESULT CopyChunkedClientData();
    HRESULT CopyNonChunkedClientData();	    

#ifdef DBG
    inline void TurnDiagsOn()  { m_fDiagnostics = TRUE; }
    inline void TurnDiagsOff() { m_fDiagnostics = FALSE; }
    void AssertValid() const;
#else
    inline void TurnDiagsOn()  {}
    inline void TurnDiagsOff() {}
    inline void AssertValid() const {}
#endif

public:
	CRequest(IUnknown *punkOuter = NULL);
	~CRequest();

    HRESULT CleanUp();
    HRESULT Init();
    HRESULT UnInit();
	
	HRESULT	ReInit(CIsapiReqInfo *pIReq, CHitObj *pHitObj);
	
    inline CIsapiReqInfo *GetIReq()
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_pIReq;
        }
        
    inline CLinkElem* CertStoreFindElem(LPSTR pV, int cV)
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_mpszStrings.FindElem( pV, cV );
        }
        
    inline CLinkElem* CertStoreAddElem(CLinkElem* pH)
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_mpszStrings.AddElem( pH ); 
        }
        
    inline LPSTR GetCertStoreBuf()
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_szClCert; 
        }
        
    inline size_t GetCertStoreSize()
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_cbClCert; 
        }
        
    inline void SetCertStore(LPSTR p, size_t s)
        {
        Assert(m_fInited);
        Assert(m_pData);
        m_pData->m_szClCert = p;
        m_pData->m_cbClCert = s;
        }

    inline CHashTable *GetStrings()
        {
        Assert(m_fInited);
        Assert(m_pData);
        return &(m_pData->m_mpszStrings);
        }

	// Non-delegating object IUnknown
	//
	STDMETHODIMP		 QueryInterface(const IID &Iid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

    // Tombstone stub
	HRESULT CheckForTombstone();
	
	// IRequest functions
	//
	STDMETHODIMP	get_Item(BSTR bstrVar, IDispatch **ppDispReturn);
	STDMETHODIMP	get_QueryString(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_Form(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_Body(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_ServerVariables(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_ClientCertificate(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_Cookies(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_TotalBytes(long *pcbTotal);
	STDMETHODIMP	BinaryRead(VARIANT *pvarCount, VARIANT *pvarReturn);

    // IStream implementation

    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(const void *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin,
                      ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb,
                        ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                            DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                              DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppstm);

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

/*===================================================================
ITERATORS:

There are two iterators used for Request - a general purpose
iterator which will iterate through the keys of Cookies, QueryString,
Form.  A special iterator is used for ServerVariables
===================================================================*/

/*
 * C S e r v V a r s I t e r a t o r
 *
 * IEnumVariant implementation for Request.ServerVariables
 */

class CServVarsIterator : public IEnumVARIANT
	{
friend CServerVariables;
	
public:
	CServVarsIterator();
	~CServVarsIterator();

	HRESULT Init(CIsapiReqInfo *pIReq);


	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG m_cRefs;					// reference count
	wchar_t **m_rgwszKeys;			// array of ISAPI keys
	wchar_t **m_pwszKey;			// current key in gm_rgwszKeys
	wchar_t *m_pwchAllHttp;			// extra keys in ALL_HTTP server variable
	ULONG	m_cKeys;				// total number of keys

	BOOL CreateKeys(wchar_t *pwchKeys, int *pcwchAlloc, int *pcRequestHeaders);
	};


/*
 * C R e q u e s t I t e r a t o r
 *
 * IEnumVariant implementation for all Request collections except
 * ServerVariables
 */

class CRequestIterator : public IEnumVARIANT
	{
public:
	CRequestIterator(CRequest *, CollectionType);
	~CRequestIterator();

	HRESULT Init();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG m_cRefs;					// reference count
	CollectionType m_Collection;	// which collection to iterate over?
	CRequest *m_pRequest;			// pointer to the request object
	CRequestHit *m_pRequestHit;		// current bookmark for iteration
	};

BOOL RequestSupportInit();
VOID RequestSupportTerminate();

#endif //_Request_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\perfdef.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: perfdef.h

Owner: DmitryR

Data definitions shared between asp.dll and aspperf.dll
===================================================================*/

#ifndef _ASP_PERFDEF_H
#define _ASP_PERFDEF_H

#include <pudebug.h>

/*===================================================================
Definitions of names, sizes and mapped data block structures
===================================================================*/

// Mutex name to access the main file map
#define SZ_PERF_MUTEX           "Global\\ASP_PERFMON_MUTEX"

// WaitForSingleObject arg (how long to wait for mutext before failing)
#define PERM_MUTEX_WAIT         1000

// Main shared file map name
#define SZ_PERF_MAIN_FILEMAP    "Global\\ASP_PERFMON_MAIN_BLOCK"

// Max number of registered (ASP) processes in main file map
#define C_PERF_PROC_MAX         1024

// Structure that defines main file map
struct CPerfMainBlockData
    {
    DWORD m_dwTimestamp;  // time (GetTickCount()) of the last change
    DWORD m_cItems;       // number of registred processes
    
    // array of process WAM CLS IDs
    CLSID m_rgClsIds[C_PERF_PROC_MAX];
    };

#define CB_PERF_MAIN_BLOCK      (sizeof(struct CPerfMainBlockData))

// Name for per-process file map
#define SZ_PERF_PROC_FILEMAP_PREFIX    "Global\\ASP_PERFMON_BLOCK_"
#define CCH_PERF_PROC_FILEMAP_PREFIX   25

// Number of counters in per-process file map
#define C_PERF_PROC_COUNTERS    37

struct CPerfProcBlockData
    {
    CLSID m_ClsId;                               // process CLS ID
    DWORD m_rgdwCounters[C_PERF_PROC_COUNTERS];  // array counters
    };

#define CB_PERF_PROC_BLOCK      (sizeof(struct CPerfProcBlockData))
#define CB_COUNTERS             (sizeof(DWORD) * C_PERF_PROC_COUNTERS)



/*===================================================================
CSharedMemBlock  --  generic shared memory block
===================================================================*/

class CSharedMemBlock
    {
private:
    HANDLE m_hMemory;
    void  *m_pMemory;

protected:
    SECURITY_ATTRIBUTES m_sa;

public:
    inline CSharedMemBlock() : m_hMemory(NULL), m_pMemory(NULL) {
		m_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    	m_sa.lpSecurityDescriptor = NULL;
	    m_sa.bInheritHandle = FALSE;
    }
    inline ~CSharedMemBlock() { 
        UnInitMap(); 
        if (m_sa.lpSecurityDescriptor)
            free(m_sa.lpSecurityDescriptor);
    }

    inline void *PMemory() { return m_pMemory; }

    HRESULT InitSD();
    HRESULT InitMap(LPCSTR szName, DWORD dwSize);
    HRESULT UnInitMap();
private:
    HRESULT CreateSids( PSID                    *ppBuiltInAdministrators,
                        PSID                    *ppPowerUsers,
                        PSID                    *ppAuthenticatedUsers);
    };

//
// CreateSids
//
// Create 3 Security IDs
//
// Caller must free memory allocated to SIDs on success.
//
// Returns: HRESULT indicating SUCCESS or FAILURE
//
inline HRESULT CSharedMemBlock::CreateSids(
    PSID                    *ppBuiltInAdministrators,
    PSID                    *ppPowerUsers,
    PSID                    *ppAuthenticatedUsers
)
{
    HRESULT     hr = S_OK;

    *ppBuiltInAdministrators = NULL;
    *ppPowerUsers = NULL;
    *ppAuthenticatedUsers = NULL;

    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Two of the SIDs we
    // want to build, Local Administrators, and Power Users, are in the "built
    // in" domain.  The other SID, for Authenticated users, is based directly
    // off of the authority.
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  ppBuiltInAdministrators)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        
    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         2,            // 2 sub-authorities
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_POWER_USERS,
                                         0,0,0,0,0,0,
                                         ppPowerUsers)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        
    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            // 1 sub-authority
                                         SECURITY_AUTHENTICATED_USER_RID,
                                         0,0,0,0,0,0,0,
                                         ppAuthenticatedUsers)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        
    }

    if (FAILED(hr)) {

        if (*ppBuiltInAdministrators) {
            FreeSid(*ppBuiltInAdministrators);
            *ppBuiltInAdministrators = NULL;
        }

        if (*ppPowerUsers) {
            FreeSid(*ppPowerUsers);
            *ppPowerUsers = NULL;
        }

        if (*ppAuthenticatedUsers) {
            FreeSid(*ppAuthenticatedUsers);
            *ppAuthenticatedUsers = NULL;
        }
    }

    return hr;
}


//
// InitSD
//
// Creates a SECURITY_DESCRIPTOR with specific DACLs.
//

inline HRESULT CSharedMemBlock::InitSD()
{
    HRESULT                 hr = S_OK;
    PSID                    pAuthenticatedUsers = NULL;
    PSID                    pBuiltInAdministrators = NULL;
    PSID                    pPowerUsers = NULL;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    if (m_sa.lpSecurityDescriptor != NULL) {
        return S_OK;
    }

    if (FAILED(hr = CreateSids(&pBuiltInAdministrators,
                               &pPowerUsers,
                               &pAuthenticatedUsers)));


    else {

        // 
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.
        //

        ULONG                   AclSize;

        //
        // "- sizeof (ULONG)" represents the SidStart field of the
        // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
        // SID, this field is counted twice.
        //

        AclSize = sizeof (ACL) +
            (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
            GetLengthSid(pAuthenticatedUsers) +
            GetLengthSid(pBuiltInAdministrators) +
            GetLengthSid(pPowerUsers);

        pSD = malloc(SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

        if (!pSD) {

            hr = E_OUTOFMEMORY;

        } else {

            ACL                     *Acl;

            Acl = (ACL *)((BYTE *)pSD + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeAcl(Acl,
                               AclSize,
                               ACL_REVISION)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_ALL,
                                            pAuthenticatedUsers)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_ALL,
                                            pPowerUsers)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_ALL,
                                            pBuiltInAdministrators)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!InitializeSecurityDescriptor(pSD,
                                                     SECURITY_DESCRIPTOR_REVISION)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!SetSecurityDescriptorDacl(pSD,
                                                  TRUE,
                                                  Acl,
                                                  FALSE)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } 
        }
    }

    if (pAuthenticatedUsers)
        FreeSid(pAuthenticatedUsers);

    if (pBuiltInAdministrators)
        FreeSid(pBuiltInAdministrators);

    if (pPowerUsers)
        FreeSid(pPowerUsers);

    if (FAILED(hr) && pSD) {
        free(pSD);
        pSD = NULL;
    }

    m_sa.lpSecurityDescriptor = pSD;

    return hr;
}

inline HRESULT CSharedMemBlock::InitMap
(
LPCSTR szName,
DWORD  dwSize
)
    {
    BOOL fNew = FALSE;
    HRESULT hr = S_OK;

    if (FAILED(hr = InitSD())) {
        return hr;
    }
    
    // Try to open existing
    m_hMemory = OpenFileMappingA
        (
        FILE_MAP_ALL_ACCESS,
        FALSE, 
        szName
        );
    if (!m_hMemory)
        {
	    m_hMemory = CreateFileMappingA
	        (
	        INVALID_HANDLE_VALUE,
    		&m_sa,
    		PAGE_READWRITE,
	    	0,
		    dwSize,
			szName
			);
		fNew = TRUE;
		}
    if (!m_hMemory)
        return E_FAIL;

	m_pMemory = MapViewOfFile
	    (
	    m_hMemory,
		FILE_MAP_ALL_ACCESS,
		0,
		0,
		0
		);
	if (!m_pMemory)
	    {
        UnInitMap();
	    return E_FAIL;
	    }

	if (fNew)
	    memset(m_pMemory, 0, dwSize);
	    
	return S_OK;
    }

inline HRESULT CSharedMemBlock::UnInitMap()
    {
   	if (m_pMemory) 
   	    {
		UnmapViewOfFile(m_pMemory);
		m_pMemory = NULL;
		}
	if (m_hMemory) 
	    {
		CloseHandle(m_hMemory);
		m_hMemory = NULL;
    	}
    return S_OK;
  	}

/*===================================================================
CPerfProcBlock - class representing pref data for a single process
===================================================================*/

class CPerfProcBlock : public CSharedMemBlock
    {

friend class CPerfMainBlock;

protected:
    DWORD m_fInited : 1;
    DWORD m_fMemCSInited : 1;
    DWORD m_fReqCSInited : 1;

    // critical sections (only used in ASP.DLL)
    CRITICAL_SECTION m_csMemLock; // CS for memory counters
    CRITICAL_SECTION m_csReqLock; // CS for per-request counters

    // block of counters
    CPerfProcBlockData *m_pData;
    
    // next process data (used in ASPPERF.DLL)
    CPerfProcBlock *m_pNext;

    // access shared memory
    HRESULT MapMemory(const CLSID &ClsId);

public:
    inline CPerfProcBlock() 
        : m_fInited(FALSE),
          m_fMemCSInited(FALSE), m_fReqCSInited(FALSE),
          m_pData(NULL), m_pNext(NULL) 
        {}
        
    inline ~CPerfProcBlock() { UnInit(); }

    HRESULT InitCriticalSections();
    
    HRESULT InitExternal(const CLSID &ClsId);  // from ASPPERF.DLL
    
    HRESULT InitForThisProcess                 // from ASP.DLL
        (
        const CLSID &ClsId,
        DWORD *pdwInitCounters = NULL
        );

    HRESULT UnInit();
    };

inline HRESULT CPerfProcBlock::MapMemory
(
const CLSID &ClsId
)
    {
    // Construct unique map name with CLSID
    char szMapName[CCH_PERF_PROC_FILEMAP_PREFIX+32+1];
    strcpy(szMapName, SZ_PERF_PROC_FILEMAP_PREFIX);
    
    char  *pszHex = szMapName + CCH_PERF_PROC_FILEMAP_PREFIX;
    DWORD *pdwHex = (DWORD *)&ClsId;
    for (int i = 0; i < 4; i++, pszHex += 8, pdwHex++)
        sprintf(pszHex, "%08x", *pdwHex);

    // create or open the map
    HRESULT hr = InitMap(szMapName, CB_PERF_PROC_BLOCK);
    
    if (SUCCEEDED(hr))
        {
        m_pData = (CPerfProcBlockData *)PMemory();

        if (m_pData->m_ClsId == CLSID_NULL)
            m_pData->m_ClsId = ClsId;
        else if (m_pData->m_ClsId != ClsId)
            hr = E_FAIL; // cls id mismatch
        }
        
    return hr;
    }

inline HRESULT CPerfProcBlock::InitCriticalSections()
    {
    HRESULT hr = S_OK;
    
    if (!m_fMemCSInited)
        {
		__try { INITIALIZE_CRITICAL_SECTION(&m_csMemLock); }
		__except(1) { hr = E_UNEXPECTED; }
		if (SUCCEEDED(hr))
		    m_fMemCSInited = TRUE;
		else
		    return hr;
        }
        
    if (!m_fReqCSInited)
        {
		__try { INITIALIZE_CRITICAL_SECTION(&m_csReqLock); }
		__except(1) { hr = E_UNEXPECTED; }
		if (SUCCEEDED(hr))
		    m_fReqCSInited = TRUE;
		else
		    return hr;
        }

    return S_OK;
    }

inline HRESULT CPerfProcBlock::InitExternal
(
const CLSID &ClsId
)
    {
    HRESULT hr = MapMemory(ClsId);
	if (SUCCEEDED(hr))
	    m_fInited = TRUE;
	else
	    UnInit();
    return hr;
    }

inline HRESULT CPerfProcBlock::InitForThisProcess
(
const CLSID &ClsId,
DWORD *pdwInitCounters
)
    {
	HRESULT hr = S_OK;

    // Map the shared memory
	if (SUCCEEDED(hr))
        hr = MapMemory(ClsId);

	if (SUCCEEDED(hr))
	    {
        // init the counters
	    if (pdwInitCounters)
	        memcpy(m_pData->m_rgdwCounters, pdwInitCounters, CB_COUNTERS);
        else
        	memset(m_pData->m_rgdwCounters, 0, CB_COUNTERS);
        	
	    m_fInited = TRUE;
      	}
    else
        {
	    UnInit();
	    }
	    
    return hr;
    }

inline HRESULT CPerfProcBlock::UnInit()
    {
    if (m_fMemCSInited)
        {
    	DeleteCriticalSection(&m_csMemLock);
    	m_fMemCSInited = FALSE;
    	}
	if (m_fReqCSInited)
	    {
	    DeleteCriticalSection(&m_csReqLock);
	    m_fReqCSInited = FALSE;
	    }

    UnInitMap();
    
    m_pData = NULL;
    m_pNext = NULL;		    
    m_fInited = FALSE;
    return S_OK;
    }

/*===================================================================
CPerfMainBlock - class representing the main perf data
===================================================================*/

class CPerfMainBlock : public CSharedMemBlock
    {
private:
    DWORD m_fInited : 1;

    // the process block directory
    CPerfMainBlockData *m_pData;

    // mutex to access the process block directory
    HANDLE m_hMutex;

    // first process data (used in ASPPERF.DLL)
    CPerfProcBlock *m_pProcBlock;

    // timestamp of main block when the list of process blocks
    // last loaded -- to make decide to reload (ASPPREF.DLL only)
    DWORD m_dwTimestamp;

public:
    inline CPerfMainBlock() 
        : m_fInited(FALSE),
          m_pData(NULL), m_hMutex(NULL), 
          m_pProcBlock(NULL), m_dwTimestamp(NULL)
        {}
        
    inline ~CPerfMainBlock() { UnInit(); }

    HRESULT Init();
    HRESULT UnInit();

    // lock / unlock using mutex
    HRESULT Lock();
    HRESULT UnLock();

    // add/remove process record to the main block (used from ASP.DLL)
    HRESULT AddProcess(const CLSID &ClsId);
    HRESULT RemoveProcess(const CLSID &ClsId);

    // load CPerfProcBlock blocks from the main block into
    // objects (used from APPPREF.DLL)
    HRESULT Load();

    // gather (sum-up) the statistics from each proc block
    HRESULT GetStats(DWORD *pdwCounters);
    };

inline HRESULT CPerfMainBlock::Init()
    {
    HRESULT hr = S_OK;

    if (FAILED(hr = InitSD())) {
        return hr;
    }
    
    m_hMutex = OpenMutexA(MUTEX_ALL_ACCESS, FALSE, SZ_PERF_MUTEX);
    if (!m_hMutex)
        {
    
        m_hMutex = CreateMutexA(&m_sa, FALSE, SZ_PERF_MUTEX);

        }
        
    if (!m_hMutex)
        hr = E_FAIL;

	if (SUCCEEDED(hr))
	    {
        hr = InitMap(SZ_PERF_MAIN_FILEMAP, CB_PERF_MAIN_BLOCK);
    	if (SUCCEEDED(hr))
    	    m_pData = (CPerfMainBlockData *)PMemory();
        }

	if (SUCCEEDED(hr))
	    m_fInited = TRUE;
	else
	    UnInit();
    return hr;
    }

inline HRESULT CPerfMainBlock::UnInit()
    {
    while (m_pProcBlock)
        {
        CPerfProcBlock *pNext = m_pProcBlock->m_pNext;
        m_pProcBlock->UnInit();
        delete m_pProcBlock;
        m_pProcBlock = pNext;
        }
        
    if (m_hMutex)
        {
        CloseHandle(m_hMutex);
        m_hMutex = NULL;
        }
    
    UnInitMap();

    m_dwTimestamp = 0;
    m_pData = NULL;
    m_pProcBlock = NULL;
    m_fInited = FALSE;
    return S_OK;
    }

inline HRESULT CPerfMainBlock::Lock()
    {
    if (!m_hMutex)
        return E_FAIL;
    if (WaitForSingleObject(m_hMutex, PERM_MUTEX_WAIT) == WAIT_TIMEOUT)
        return E_FAIL;
    return S_OK;
    }
    
inline HRESULT CPerfMainBlock::UnLock()
    {
    if (m_hMutex)
        ReleaseMutex(m_hMutex);
    return S_OK;
    }

inline HRESULT CPerfMainBlock::AddProcess
(
const CLSID &ClsId
)
    {
    if (!m_fInited)
        return E_FAIL;

    if (FAILED(Lock()))  // lock mutex
        return E_FAIL;
    HRESULT hr = S_OK;

    BOOL fFound = FALSE;
    // find
    for (DWORD i = 0; i < m_pData->m_cItems; i++)
        {
        if (m_pData->m_rgClsIds[i] == ClsId)
            {
            fFound = TRUE;
            break;
            }
        }

    // add only if not already there
    if (!fFound)
        {
        if (m_pData->m_cItems < C_PERF_PROC_MAX)
            {
            m_pData->m_rgClsIds[m_pData->m_cItems] = ClsId;
            m_pData->m_cItems++;
            m_pData->m_dwTimestamp = GetTickCount();
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }

    UnLock();   // unlock mutex
    return hr;
    }

inline HRESULT CPerfMainBlock::RemoveProcess
(
const CLSID &ClsId
)
    {
    if (!m_fInited)
        return E_FAIL;

    if (FAILED(Lock()))  // lock mutex
        return E_FAIL;
    HRESULT hr = S_OK;

    int iFound = -1;
    // find
    for (DWORD i = 0; i < m_pData->m_cItems; i++)
        {
        if (m_pData->m_rgClsIds[i] == ClsId)
            {
            iFound = i;
            break;
            }
        }

    // remove
    if (iFound >= 0)
        {
        for (i = iFound; i < m_pData->m_cItems-1; i++)
            m_pData->m_rgClsIds[i] = m_pData->m_rgClsIds[i+1];
            
        m_pData->m_cItems--;
        m_pData->m_dwTimestamp = GetTickCount();
        }

    UnLock();   // unlock mutex
    return hr;
    }
    
inline HRESULT CPerfMainBlock::Load()
    {
    if (!m_fInited)
        return E_FAIL;

    if (m_dwTimestamp == m_pData->m_dwTimestamp)
        return S_OK; // already up-to-date

    // clear out what we have
    while (m_pProcBlock)
        {
        CPerfProcBlock *pNext = m_pProcBlock->m_pNext;
        m_pProcBlock->UnInit();
        delete m_pProcBlock;
        m_pProcBlock = pNext;
        }
        
    if (FAILED(Lock())) // lock mutex
        return E_FAIL;
    HRESULT hr = S_OK;

    // populate new objects for blocks
    for (DWORD i = 0; i < m_pData->m_cItems; i++)
        {
        CPerfProcBlock *pBlock = new CPerfProcBlock;
        if (!pBlock)
            {
            hr = E_OUTOFMEMORY;
            break;
            }
        
        hr = pBlock->InitExternal(m_pData->m_rgClsIds[i]);
        if (FAILED(hr))
            {
            delete pBlock;
            continue;
            }

        pBlock->m_pNext = m_pProcBlock;
        m_pProcBlock = pBlock;
        }

    // remember timestamp
    m_dwTimestamp = SUCCEEDED(hr) ? m_pData->m_dwTimestamp : 0;

    UnLock();   // unlock mutex
    return hr;
    }

inline HRESULT CPerfMainBlock::GetStats
(
DWORD *pdwCounters
)
    {
    if (!m_fInited)
        return E_FAIL;

    // reload if needed
    if (FAILED(Load()))
        return E_FAIL;

    // init
    memset(pdwCounters, 0, CB_COUNTERS);

    // gather
    CPerfProcBlock *pBlock = m_pProcBlock;
    while (pBlock)
        {
        for (int i = 0; i < C_PERF_PROC_COUNTERS; i++)
            pdwCounters[i] += pBlock->m_pData->m_rgdwCounters[i];
        pBlock = pBlock->m_pNext;
        }
        
    return S_OK;
    }

#endif // _ASP_PERFDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\rfs.h ===
/*===================================================================
Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: RFS

File: rfs.h

Owner: EricN

This the Resource failure objects.
===================================================================*/

#ifdef _RFS
#ifndef _RFS_CLS_H
#define _RFS_CLS_H

#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>

// for failure types
#define COUNT			1
#define MEM				2
#define	FILE_LINE		3

// for logging
#define MFSLOGFILE		"\\temp\\mfs.log"
#define MFSINIFILE		"\\temp\\mfs.ini"
	
//RFS MACROS for memory 
#define MFS_INIT(mem)		(mem).Init()
#define MFS_ON(mem)			(mem).SetRFSOn(TRUE)
#define MFS_OFF(mem)		(mem).SetRFSOn(FALSE)
#define MFS_SETTHREAD(mem)	(mem).SetThreadID(GetCurrentThreadId())
#define MFS_WRITEDATA(mem)	(mem).WriteData()
#define MFS_STARTLOOP \
	while(TRUE) \
	{
#define MFS_ENDLOOP(mem)		}
#define MFS_ENDLOOP_HR(mem)	if (hr == S_OK) break;}
#define MFS_EXTERN(mem)	extern MemRFS (mem)
#define MFS_CHECKFAIL(mem, size, file, line) \
	if ((mem).FailAlloc(size, file, line)) \
		return NULL
		
#define MFS_START(mem) \
		MFS_INIT(mem); \
		MFS_SETTHREAD(mem); \
		MFS_ON(mem); \
		MFS_STARTLOOP 

#define MFS_END_HR(mem) \
		MFS_ENDLOOP_HR(mem); \
		MFS_WRITEDATA(mem); 
 
//end macros


//rfs class
class RFS
{
public:

	RFS(DWORD dwFailOn, DWORD dwThreadID);

	void	SetThreadID(DWORD);
	virtual HRESULT Init() = 0;

protected:

	BOOL	m_fFail;
	DWORD	m_dwCurrentAlloc;

	//this will communicate with outside program	
	BOOL	DetermineFailure(LPCSTR szFile = NULL, int iLineNo = -1);	
	void	SetFailOn(DWORD, BYTE); //after a certain amount of memory or a specific request
	void	SetFailOn(LPSTR, long); //on a specific line in a file
	virtual void WriteData();

private:

	BYTE	m_bType;
	DWORD	m_dwFailOn;
	DWORD	m_dwTtlNumAllocs;
	DWORD	m_dwThreadID;
	char	m_szFailIn[MAX_PATH];

	virtual BOOL FailAlloc(void *v = NULL, LPCSTR szFile = NULL, int iLineNo = -1) = 0; //implemeneted by derived class
	virtual void Log(LPSTR pszFileName, LPSTR pszMsg);
};

class MemRFS : public RFS
{

public:

	HRESULT Init();
	MemRFS(DWORD dwFailOn = 1, DWORD dwThreadID = -1);
	void SetRFSOn(BOOL);
	void SetFailOn(DWORD, BYTE); //after a certain amount of memory or a specific request
	void SetFailOn(LPSTR, long); //on a specific line in a file
	BOOL FailAlloc(void *v = NULL, LPCSTR szFile = NULL, int iLineNo = -1);
	void WriteData();
};

#endif //_rfs_cls_h
#else

//blank out macros for non rfs build

#define MFS_ON	
#define MFS_OFF 
#define MFS_INIT  
#define MFS_STARTLOOP 
#define MFS_ENDLOOP
#define MFS_ENDLOOP_HR
#define MFS_EXTERN(mem)
#define MFS_CHECKFAIL(mem, size, file, line)
#define MFS_SETTHREAD
#define MFS_WRITEDATA
#define MFS_START(mem)
#define MFS_END_HR(mem)
#endif //_rfs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\rfs.cpp ===
/*===================================================================
Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: RFS

File: rfs.cpp

Owner: EricN

This the Resource failure objects.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#ifdef _RFS

#include <tchar.h>
#include <stdio.h>
#include "rfs.h"

//constructor
RFS::RFS(DWORD dwFailOn, DWORD dwThreadID)
{
	__asm {int 3}
	m_dwFailOn = dwFailOn;
	m_dwTtlNumAllocs = 0;
	m_dwCurrentAlloc = 0;
	m_dwThreadID = dwThreadID;
	m_fFail = FALSE;
	m_bType = -1;
}

//*****************************************************************************
// Name:	RFS::SetFailOn
// Args:	Changes the fail on value and spcifies what the number means
//			bType = COUNT | ALLOCATE
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	
//*****************************************************************************
void
RFS::SetFailOn(DWORD dwFailOn, BYTE bType)
{
	m_dwFailOn = dwFailOn;
	m_bType = bType;
}

//*****************************************************************************
// Name:	RFS::SetFailOn
// Args:	Causes a failure on a line or allocation form a specific file
//			pszFile - the file (a .cpp file)
//			lLine - the line number
//			the type is forced to FILE_LINE
// Author:	EricN
// History:	Created 7/8/97
// Notes:	
//*****************************************************************************
void
RFS::SetFailOn(LPSTR pszFile, long lLine)
{
	strcpy(m_szFailIn, pszFile);
	m_dwFailOn = lLine;
	m_bType = FILE_LINE;
}

//*****************************************************************************
// Name:	RFS::WriteData
// Args:	none
// Author:	EricN
// History:	Created 4/22/97 (tax day)
// Notes:	writes out any interesting data
//*****************************************************************************
void
RFS::WriteData()
{
	char szOutput[200];

	sprintf(szOutput, "\n\nTotal Number of allocations: %ld\n", m_dwTtlNumAllocs);
	Log(MFSLOGFILE, szOutput);
}

//*****************************************************************************
// Name:	RFS::DetermineFailure
// Args:	None
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	
//			This determines if the particular resource should fail
//			Currently it just logs the failure to a file, but will eventually
//			communicate with an outside application
//*****************************************************************************
BOOL
RFS::DetermineFailure(LPCSTR szFile, int iLineNo)
{
	BOOL  fFail = FALSE;
	DWORD dwThreadID = GetCurrentThreadId();
	char  szOutput[200];

	//verify the we're being called on the correct threadid
	if (dwThreadID != m_dwThreadID)
	{
		//sprintf(szOutput, "Called on differnt thread. Exp: %ld, Rec: %ld\n", m_dwThreadID, dwThreadID);
		//Log(MFSLOGFILE, szOutput); 
		return FALSE;
	}
	
	m_dwTtlNumAllocs++;
	m_dwCurrentAlloc++;

	switch(m_bType)
	{
	case COUNT:

		if (m_fFail && m_dwCurrentAlloc == m_dwFailOn)
		{
			fFail = TRUE;
			m_dwFailOn++;
			m_dwCurrentAlloc = 0;
		}

		break;
	case MEM:
		break;
	case FILE_LINE:
			if (m_fFail && m_dwFailOn == iLineNo)
			{
				if (_stricmp(m_szFailIn, szFile) == 0)
				{
					fFail = TRUE;
				}
			}

		break;
	default:
		sprintf(szOutput, "BAD failure type specified: %d\n",m_bType);
		Log(MFSLOGFILE, szOutput); 
		break;
	}//switch

	if (fFail)
	{
		if (szFile != NULL)
			sprintf(szOutput, "Failing Allocation: %ld File: %s, Line: %d\n", m_dwCurrentAlloc, 
					szFile, iLineNo);
		else
			sprintf(szOutput, "Failing Allocation: %ld\n", m_dwCurrentAlloc);

		Log(MFSLOGFILE, szOutput); 
		return TRUE;
	}

	return FALSE;
}

void
RFS::SetThreadID(DWORD dwThreadID)
{
	m_dwThreadID = dwThreadID;
}

void
RFS::Log(LPSTR pszFileName, LPSTR pszMsg)
{
int fh;

	fh = _open(pszFileName, 
			   _O_WRONLY | _O_CREAT | _O_APPEND | _O_BINARY, 
			   _S_IREAD | _S_IWRITE );

	if (fh == -1)
	{
		DBG_PRINTF((DBG_CONTEXT, "FAIL: Could not open RFS log\n"));
	}

	_write( fh, (void*)pszMsg, strlen(pszMsg));
	_close(fh);
}

//construstor
MemRFS::MemRFS(DWORD dwFailOn, DWORD dwThreadID) : RFS(dwFailOn, dwThreadID)
{
}

//*****************************************************************************
// Name:	MemRFS::Init
// Args:	None
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	
//*****************************************************************************
HRESULT
MemRFS::Init()
{
	int fh;
	long lVal;
	char szBuff[MAX_PATH];

	//only read the file the first time the RFS stuff is instantiated
	if (m_dwCurrentAlloc == 0)
	{
		fh = _open(MFSINIFILE, 
				   _O_RDONLY | _O_BINARY, _S_IREAD | _S_IWRITE );

		//init doesn't fail if there is no init file,
		if (fh != -1)
		{
			DWORD dwBytes = _read( fh, (void*)szBuff, MAX_PATH);
			_close(fh);
			szBuff[dwBytes-1] = '\0';
			//determine type of failure requested
			lVal = atol(szBuff);
			//if lval is 0 then a file name was specified
			if (lVal == 0)
			{
				LPSTR pStr;
				pStr = strstr(szBuff, ",");
				if (pStr != NULL)
				{
					//replace ',' with \0
					*pStr = '\0';

					pStr++;
					lVal = atol(pStr);
					SetFailOn(szBuff, lVal);
				}
				else
				{
					//having a line of zero will force a failure on the 
					//first request from a file
					SetFailOn(szBuff, 0);
				}
			}
			else
			{
				LPSTR pStr;
				pStr = strstr(szBuff, ",");
				if (!pStr != NULL)
				{
					pStr++;
					SetFailOn(lVal, (BYTE)atoi(pStr));
				}
				else
					SetFailOn(lVal, COUNT);					
			}
		}
	}

	//reset the allocations for this request.
	m_dwCurrentAlloc = 0;

	return S_OK;
}

//*****************************************************************************
// Name:	MemRFS::FailAlloc
// Args:	None
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	Just calls base class
//*****************************************************************************
BOOL
MemRFS::FailAlloc(void *cSize, LPCSTR szFile, int iLineNo)
{
	//need to add code to handle size stuff.
	return DetermineFailure(szFile, iLineNo);
}

//*****************************************************************************
// Name:	MemRFS::SetRFSOn
// Args:	fRFSOn - determines if RFS is on or off
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	This turns on and off RFS
//*****************************************************************************
void
MemRFS::SetRFSOn(BOOL fRFSOn)
{
	m_fFail = fRFSOn;
}

//*****************************************************************************
// Name:	MemRFS::SetFailOn
// Args:	Changes the fail on value
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	This turns on and off RFS
//*****************************************************************************
void
MemRFS::SetFailOn(DWORD dwFailOn, BYTE bType)
{
	RFS::SetFailOn(dwFailOn, bType);
}

//*****************************************************************************
// Name:	MemRFS::SetFailOn
// Args:	Changes the fail on value
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	This turns on and off RFS
//*****************************************************************************
void
MemRFS::SetFailOn(LPSTR pszFile, long lLine)
{
	RFS::SetFailOn(pszFile, lLine);
}

//*****************************************************************************
// Name:	MemRFS::WriteData
// Args:	None
// Author:	EricN
// History:	Created 4/22/97 
// Notes:	Writes out any data of interest
//*****************************************************************************
void
MemRFS::WriteData()
{
	RFS::WriteData();
}

#endif // _RFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\script.h ===
#ifndef SCRIPT_H
#define SCRIPT_H


/***************************************************************************
	Project: VB Script and JavaScript
	Reviewed:
	Copyright (c) Microsoft Corporation

	This defines the public interface to VB Script and JavaScript.

***************************************************************************/

#include "activscp.h"

typedef void *HSCRIPT;	// Handle to a scripting environment instance
typedef void *HENTRY;	// Handle to a script entry point
typedef unsigned long MODID;
const MODID kmodGlobal = 0;

// PFNOUTPUT is used for all output for the script, including compile errors,
// printing (if ScriptAdmin is called to turn on printing), dumping pcode
// (if requested when ScriptAddScript is called), etc.
typedef void  (_stdcall *PFNOUTPUT)(DWORD, LPCOLESTR, BOOL);

enum SAdminEnum
	{
	scadEnableCreateObject = 1, // Only used in VER1
	scadEnablePrint,
	scadEnableTakeOutTrash,     // Only used in JavaScript
	};

STDAPI ScriptBreakThread(DWORD dwThreadID);


inline void FreeExcepInfo(EXCEPINFO *pei)
	{
	if (pei->bstrSource)
		SysFreeString(pei->bstrSource);
	if (pei->bstrDescription)
		SysFreeString(pei->bstrDescription);
	if (pei->bstrHelpFile)
		SysFreeString(pei->bstrHelpFile);
	memset(pei, 0, sizeof(*pei));
	}

struct ScriptException
	{
	IUnknown *punk;
	BSTR bstrUser;		// user data as provided to AddToScript - binary data
	long ichMin;		// character range of error
	long ichLim;
	long line;			// line number of error (zero based)
	long ichMinLine;	// starting char of the line

	BSTR bstrLine;		// source line (if available)
	BOOL fReported;		// been reported via IScriptSite->OnScriptError?

	// must be last
	EXCEPINFO ei;

	void Clear(void)
		{ memset(this, 0, sizeof(*this)); }

	void Free(void)
		{
		FreeExcepInfo(&ei);
		if (NULL != punk)
			punk->Release();
		if (NULL != bstrUser)
			SysFreeString(bstrUser);
		if (NULL != bstrLine)
			SysFreeString(bstrLine);
		memset(this, 0, offsetof(ScriptException, ei));
		}
	};

/***************************************************************************
	The COM Interfaces
***************************************************************************/

enum
	{
	fdexNil = 0x00,
	fdexDontCreate = 0x01,
	fdexInitNull = 0x02,
	fdexCaseSensitive = 0x04,
	fdexLim = 0x80,
	};
const DWORD kgrfdexAll = fdexLim - 1;


// This is the interface for extensible IDispatch objects.
class IDispatchEx : public IDispatch
	{
public:
	// Get dispID for names, with options
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNamesEx(REFIID riid,
		LPOLESTR *prgpsz, UINT cpsz, LCID lcid, DISPID *prgid, DWORD grfdex) = 0;

	// Enumerate dispIDs and their associated "names".
	// Returns S_FALSE if the enumeration is done, S_OK if it's not, an
	// error code if the call fails.
	virtual HRESULT STDMETHODCALLTYPE GetNextDispID(DISPID id, DISPID *pid,
		BSTR *pbstrName) = 0;
	};


// Interface on owner of an IScript object. To avoid circular refcounts,
// the IScript implementation should not AddRef this interface.
class IScriptSite : public IUnknown
	{
public:
	// IScriptSite Methods

	// NOTE:  OnEnterScript() and OnLeaveScript() will nest, but must be
	// balanced pairs.
	// OnEnterScript() is called before entering the execution loop.
	virtual void STDMETHODCALLTYPE OnEnterScript(void) = 0;
	// OnLeaveScript() is called upon exiting the execution loop.
	virtual void STDMETHODCALLTYPE OnLeaveScript(void) = 0;

	virtual HRESULT STDMETHODCALLTYPE GetActiveScriptSiteWindow(
		IActiveScriptSiteWindow **ppassw) = 0;

	// error feedback - the client should not muck with the sei. We own it.
	virtual HRESULT STDMETHODCALLTYPE OnScriptError(const ScriptException *psei) = 0;

	// LCID support
	virtual LCID STDMETHODCALLTYPE GetUserLcid(void) = 0;

	// call back to get an object for a name
	virtual HRESULT STDMETHODCALLTYPE GetExternObject(long lwCookie, IDispatch ** ppdisp) = 0;

#if SCRIPT_DEBUGGER
	virtual HRESULT STDMETHODCALLTYPE DebugBreakPoint(IUnknown *punk,
		void *pvUser, long cbUser, long ichMin, long ichLim) = 0;
#endif //SCRIPT_DEBUGGER

#if VER2
	virtual DWORD STDMETHODCALLTYPE GetSafetyOptions(void) = 0;
#endif //VER2

	virtual HRESULT STDMETHODCALLTYPE GetInterruptInfo(EXCEPINFO * pexcepinfo) = 0;

	};


enum
	{
	fscrNil = 0x00,
	fscrDumpPcode = 0x01,		// dump pcode to the output function
	fscrPersist = 0x08,			// keep this code on reset
	fscrParseHTMLComments = 0x10,
	fscrReturnExpression = 0x20,// call should return the last expression
	fscrImpliedThis = 0x40,		// 'this.' is optional (for Call)
	fscrDebug = 0x80,			// keep this code around for debugging
	};

#if SCRIPT_DEBUGGER
enum BP_COMMAND
	{
	BPCMD_GET,
	BPCMD_SET,
	BPCMD_CLEAR,
	BPCMD_TOGGLE
	};
#endif //SCRIPT_DEBUGGER

class IScript : public IUnknown
	{
public:
	// IScript methods
	virtual HRESULT STDMETHODCALLTYPE AddToScript(LPCOLESTR pszSrc, MODID mod,
		IUnknown *punk, void *pvData, long cbData, ULONG grfscr,
		HENTRY *phentryGlobal, ScriptException *pse) = 0;
	virtual HRESULT STDMETHODCALLTYPE AddObject(LPCOLESTR pszName,
		IDispatch *pdisp, MODID mod = kmodGlobal, long lwCookie = 0) = 0;
	virtual HRESULT STDMETHODCALLTYPE AddObjectMember(LPCOLESTR pszName,
		IDispatch *pdisp, DISPID dispID, MODID mod = kmodGlobal) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetEntryPoint(LPCOLESTR pszName,
		HENTRY *phentry, MODID mod = kmodGlobal) = 0;
	virtual HRESULT STDMETHODCALLTYPE ReleaseEntryPoint(HENTRY hentry) = 0;

	virtual HRESULT STDMETHODCALLTYPE Call(HENTRY hentry, VARIANT *pvarRes,
		int cvarArgs, VARIANT *prgvarArgs, IDispatch *pdispThis = NULL,
		ScriptException *pse = NULL, DWORD grfscr = fscrNil) = 0;

	virtual HRESULT STDMETHODCALLTYPE Break(void) = 0;
	virtual HRESULT STDMETHODCALLTYPE Admin(SAdminEnum scad, void *pvArg = NULL,
		MODID mod = kmodGlobal) = 0;
	virtual void STDMETHODCALLTYPE SetOutputFunction(PFNOUTPUT pfn,
		DWORD dwOutput) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetDefaultDispatch(MODID mod,
		IDispatch *pdisp) = 0;

	// psite may be NULL
	virtual void STDMETHODCALLTYPE SetScriptSite(IScriptSite *psite) = 0;
#if WIN16
	virtual HRESULT STDMETHODCALLTYPE
        SetActiveScriptSitePoll(IActiveScriptSiteInterruptPoll *pPoll) = 0;
#endif // WIN16

	virtual void STDMETHODCALLTYPE Enter(void) = 0;
	virtual void STDMETHODCALLTYPE Leave(void) = 0;

	// get an IDispatch wrapper for the module
	virtual HRESULT STDMETHODCALLTYPE GetDispatchForModule(MODID mod,
		IDispatch **ppdisp) = 0;

	// Reset/Clone functionality
	virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;
	virtual HRESULT STDMETHODCALLTYPE Clone(IScript **ppscript) = 0;
	virtual HRESULT STDMETHODCALLTYPE Execute(ScriptException *pse = NULL) = 0;

#if SCRIPT_DEBUGGER
	virtual HRESULT STDMETHODCALLTYPE ToggleBreakPoint(IUnknown *punk, long ich,
		BP_COMMAND bpcmd, long *pichMin, long *pichLim, BOOL *pfSet) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetOneTimeBreakOnEntry(BOOL fSet = TRUE) = 0;
#endif //SCRIPT_DEBUGGER
	virtual HRESULT STDMETHODCALLTYPE GetLineNumber(IUnknown *punk, long ich,
		long *pline, long *pichMinLine, long *pichLimLine) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetUserData(IUnknown *punk, BSTR *pbstr) = 0;

#if SUPPORT_SCRIPT_HELPER
#if DBG
    virtual HRESULT STDMETHODCALLTYPE DumpPCode(void) = 0;
#endif // DBG
#endif // SUPPORT_SCRIPT_HELPER
	};

// helper to create a script object
STDAPI CreateScript(IScript **ppscript, PFNOUTPUT pfn = NULL, DWORD dwOutput = 0);

#endif // SCRIPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\scrpteng.h ===
/*
 *
 *
 * C S c r i p t E n g i n e
 *
 * An individual script engine for a given language.  May be used
 * by one and only one client at a time.
 *
 */
class CScriptEngine
	{
public:	
	// public methods
	virtual HRESULT AddScriptlet(LPCOLESTR wstrScript) = 0; // Text of scriptlet

	virtual HRESULT AddObjects(BOOL fPersistNames = TRUE) = 0;

	virtual HRESULT AddAdditionalObject(LPWSTR strObjName, BOOL fPersistNames = TRUE) = 0;

	virtual HRESULT Call(LPCOLESTR strEntryPoint) = 0;

	virtual HRESULT CheckEntryPoint(LPCOLESTR strEntryPoint) = 0;

	virtual HRESULT MakeEngineRunnable() = 0;

	virtual HRESULT ResetScript() = 0;

	virtual HRESULT AddScriptingNamespace() = 0;

	virtual VOID Zombify() = 0;

	virtual HRESULT InterruptScript(BOOL fAbnormal = TRUE) = 0;

	virtual BOOL FScriptTimedOut() = 0;

	virtual BOOL FScriptHadError() = 0;

	virtual HRESULT UpdateLocaleInfo(hostinfo) = 0;

	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\server.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Server object

File: Server.h

Owner: CGrant

This file contains the header info for defining the Server object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef _Server_H
#define _Server_H

#include "debug.h"
#include "dispatch.h"
#include "denguid.h"
#include "memcls.h"
#include "ftm.h"

#ifdef USE_LOCALE
extern DWORD g_dwTLS;
#endif

//This file is generated from MKTYPLIB on denali.obj
#include "asptlb.h"

// Forward declr
class CHitObj;

/*
 * C S e r v e r D a t a
 *
 * Structure that holds the intrinsic's properties.
 * The instrinsic keeps pointer to it (NULL when lightweight)
 */
class CServerData
    {
public:    
    // Interface to indicate that we support ErrorInfo reporting
	CSupportErrorInfo m_ISupportErrImp;

    // CIsapiReqInfo block for HTTP info
    CIsapiReqInfo *m_pIReq;

    // Back pointer to current HitObj (required for the MapPath)
	CHitObj *m_pHitObj;

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*
 * C S e r v e r
 *
 * Implements the Server object
 */
class CServer : public IServerImpl, public CFTMImplementation
	{
private:

    // Flags
	DWORD m_fInited : 1;	    // Is initialized?
	DWORD m_fDiagnostics : 1;   // Display ref count in debug output
	DWORD m_fOuterUnknown : 1;  // Ref count outer unknown?

    // Ref count / Outer unknown
    union
    {
    DWORD m_cRefs;
    IUnknown *m_punkOuter;
    };

    // Properties
    CServerData *m_pData;   // pointer to structure that holds
                            // CServer properties
                            
public:
	CServer(IUnknown *punkOuter = NULL);
	~CServer();

    HRESULT Init();
    HRESULT UnInit();
    
    HRESULT ReInit(CIsapiReqInfo *pIReq, CHitObj *pHitObj);

    HRESULT MapPathInternal(DWORD dwContextId, WCHAR *wszVirtPath, 
                            TCHAR *szPhysPath, TCHAR *szVirtPath = NULL);

    // Retrieve HitObj
    inline CHitObj *PHitObj() { return m_pData ? m_pData->m_pHitObj : NULL; }

	//Non-delegating object IUnknown
	STDMETHODIMP		 QueryInterface(REFIID, PPVOID);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

    // GetIDsOfNames special-case implementation
	STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);

    // Tombstone stub
	HRESULT CheckForTombstone();

	//IServer functions
	STDMETHODIMP CreateObject(BSTR bstr, IDispatch **ppdispObject);
	STDMETHODIMP MapPath(BSTR bstrLogicalPath, BSTR *pbstrPhysicalPath);
	STDMETHODIMP HTMLEncode(BSTR bstrIn, BSTR *pbstrEncoded);
	STDMETHODIMP URLEncode(BSTR bstrIn, BSTR *pbstrEncoded);
	STDMETHODIMP URLPathEncode(BSTR bstrIn, BSTR *pbstrEncoded);
	STDMETHODIMP get_ScriptTimeout(long * plTimeoutSeconds);
	STDMETHODIMP put_ScriptTimeout(long lTimeoutSeconds);		
	STDMETHODIMP Execute(BSTR bstrURL);
	STDMETHODIMP Transfer(BSTR bstrURL);
	STDMETHODIMP GetLastError(IASPError **ppASPErrorObject);

    // Debug support
    
#ifdef DBG
	inline void TurnDiagsOn()  { m_fDiagnostics = TRUE; }
	inline void TurnDiagsOff() { m_fDiagnostics = FALSE; }
	void AssertValid() const;
#else
	inline void TurnDiagsOn()  {}
	inline void TurnDiagsOff() {}
	inline void AssertValid() const {}
#endif

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

typedef CServer *PCServer;

#endif //_Server_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\resource.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Resources

File: Resource.h

Owner: AndrewS

This file contains constants for all resources used by Denali

===================================================================*/


#define IDE_BEGIN					100

//
// General errors
//
#define IDE_GENERAL_BEGIN			100
#define IDE_OOM						IDE_GENERAL_BEGIN
#define IDE_UNEXPECTED				IDE_GENERAL_BEGIN + 1
#define IDE_EXPECTING_STR			IDE_GENERAL_BEGIN + 2
#define IDE_EXPECTING_INT			IDE_GENERAL_BEGIN + 3
#define IDE_NOT_ALLOWED				IDE_GENERAL_BEGIN + 4
#define IDE_BAD_ARRAY_INDEX			IDE_GENERAL_BEGIN + 5	
#define IDE_TYPE_MISMATCH			IDE_GENERAL_BEGIN + 6
#define IDE_STACK_OVERFLOW			IDE_GENERAL_BEGIN + 7
#define IDS_COUNINITIALIZE			IDE_GENERAL_BEGIN + 8
#define IDS_TRUE					IDE_GENERAL_BEGIN + 9
#define IDS_FALSE					IDE_GENERAL_BEGIN + 10
#define IDE_INTRINSIC_OUT_OF_SCOPE  IDE_GENERAL_BEGIN + 11
#define IDE_CANT_MOD_STATICOBJECTS  IDE_GENERAL_BEGIN + 12
#define IDE_TOOBIG					IDE_GENERAL_BEGIN + 13
#define IDS_CACHE_DIR_MISSING       IDE_GENERAL_BEGIN + 14
#define IDE_GENERAL_END				IDE_GENERAL_BEGIN + 14

#define IDS_REG_GENERAL_BEGIN		200
#define IDS_DEFAULTMSG_DENIED		IDS_REG_GENERAL_BEGIN + 1
#define IDS_DEFAULTMSG_ERROR		IDS_REG_GENERAL_BEGIN + 2
#define IDS_DEFAULTMSG_BUSY			IDS_REG_GENERAL_BEGIN + 3
#define IDS_SCRIPTLANGUAGE			IDS_REG_GENERAL_BEGIN + 4
#define IDS_IIS_NOTINSTALLED		IDS_REG_GENERAL_BEGIN + 5
#define IDS_DEFAULTPERSISTDIR       IDS_REG_GENERAL_BEGIN + 6
#define IDS_REG_GENERAL_END			IDS_REG_GENERAL_BEGIN + 6

#define IDS_BROWSER_TEMPLATE_BEGIN			300
#define IDS_BROWSER_TEMPLATE_ENGINE_BEGIN	IDS_BROWSER_TEMPLATE_BEGIN + 1
#define IDS_BROWSER_TEMPLATE_ENGINE_END		IDS_BROWSER_TEMPLATE_BEGIN + 2
#define IDS_BROWSER_TEMPLATE_ERROR_BEGIN	IDS_BROWSER_TEMPLATE_BEGIN + 3
#define IDS_BROWSER_TEMPLATE_ERROR_END		IDS_BROWSER_TEMPLATE_BEGIN + 4
#define IDS_BROWSER_TEMPLATE_SHORT_BEGIN	IDS_BROWSER_TEMPLATE_BEGIN + 5
#define IDS_BROWSER_TEMPLATE_SHORT_END		IDS_BROWSER_TEMPLATE_BEGIN + 6
#define IDS_BROWSER_TEMPLATE_FILE_BEGIN		IDS_BROWSER_TEMPLATE_BEGIN + 7
#define IDS_BROWSER_TEMPLATE_FILE_END		IDS_BROWSER_TEMPLATE_BEGIN + 8
#define IDS_BROWSER_TEMPLATE_LINE_BEGIN		IDS_BROWSER_TEMPLATE_BEGIN + 9
#define IDS_BROWSER_TEMPLATE_LINE_END		IDS_BROWSER_TEMPLATE_BEGIN + 10
#define IDS_BROWSER_TEMPLATE_CODE_BEGIN		IDS_BROWSER_TEMPLATE_BEGIN + 11
#define IDS_BROWSER_TEMPLATE_CODE_END		IDS_BROWSER_TEMPLATE_BEGIN + 12
#define IDS_BROWSER_TEMPLATE_LONG_BEGIN		IDS_BROWSER_TEMPLATE_BEGIN + 13
#define IDS_BROWSER_TEMPLATE_LONG_END		IDS_BROWSER_TEMPLATE_BEGIN + 14
#define IDS_BROWSER_TEMPLATE_END			IDS_BROWSER_TEMPLATE_BEGIN + 15

#define IDS_ERROR_HANDLINGSTRING	400
#define IDS_DEBUG_APP				IDS_ERROR_HANDLINGSTRING + 1
#define IDS_LOG_IISLOGFAILED		IDS_ERROR_HANDLINGSTRING + 2
#define	IDS_COMPILER				IDS_ERROR_HANDLINGSTRING + 3
#define IDS_ENGINE					IDS_ERROR_HANDLINGSTRING + 4
#define IDS_LOGTOEVENTLOG_FILE		IDS_ERROR_HANDLINGSTRING + 5
#define	IDS_LOGTOEVENTLOG_LINE		IDS_ERROR_HANDLINGSTRING + 6
#define IDS_MDOORANGE_FORMAT		IDS_ERROR_HANDLINGSTRING + 7
#define IDS_IISLOG_PREFIX			IDS_ERROR_HANDLINGSTRING + 8
#define IDS_RE_REGSVR_ASP			IDS_ERROR_HANDLINGSTRING + 9
#define IDS_SCRIPT_ERROR			IDS_ERROR_HANDLINGSTRING + 10
#define IDS_DEBUGGER_TEMPLATE_BEGIN	IDS_ERROR_HANDLINGSTRING + 11
#define IDS_DEBUGGER_TEMPLATE_END	IDS_ERROR_HANDLINGSTRING + 12
#define IDS_DEBUGGING_DISABLED		IDS_ERROR_HANDLINGSTRING + 13

//Header strings
#define IDH_HEADER_BEGIN			500
#define IDH_204_NO_CONTENT			IDH_HEADER_BEGIN + 1
#define IDH_403_FORBIDDEN           IDH_HEADER_BEGIN + 2
#define IDH_404_OBJECT_NOT_FOUND	IDH_HEADER_BEGIN + 3
#define IDH_500_SERVER_ERROR		IDH_HEADER_BEGIN + 4
#define IDH_401_3_ACCESS_DENIED     IDH_HEADER_BEGIN + 5
#define IDH_HEADER_END				IDH_HEADER_BEGIN + 6

//Encrypted ASP printable file header
#define IDS_EASP_PRINTABLE_HEADER   601

// Errors previously hardcoded in hitobj.h

// 
// Script Engine/Manager errors
//
#define IDE_SCRIPT_BEGIN			1000
#define	IDE_SCRIPT_CANT_LOAD_OBJ	IDE_SCRIPT_BEGIN+0
#define	IDE_SCRIPT_GENERIC_PREFIX	IDE_SCRIPT_BEGIN+1
#define	IDE_SCRIPT_LINE_NUMBER		IDE_SCRIPT_BEGIN+2
#define	IDE_SCRIPT_FILE_PATH_INFO	IDE_SCRIPT_BEGIN+3
#define	IDE_SCRIPT_METHOD_NOT_FOUND	IDE_SCRIPT_BEGIN+4
#define	IDE_SCRIPT_UNKNOWN_NAME		IDE_SCRIPT_BEGIN+5
#define	IDE_SCRIPT_UNKNOWN_INTERFACE IDE_SCRIPT_BEGIN+6
#define	IDE_SCRIPT_MISSING_PARAMETER IDE_SCRIPT_BEGIN+7
#define	IDE_SCRIPT_TIMEOUT			IDE_SCRIPT_BEGIN+8
#define IDE_SCRIPT_BAD_SCOPE_MODEL	IDE_SCRIPT_BEGIN+9
#define IDE_SCRIPT_GPF				IDE_SCRIPT_BEGIN+10
#define IDE_SCRIPT_UNKNOWN			IDE_SCRIPT_BEGIN+11
#define IDE_SCRIPT_ENGINE_GPF       IDE_SCRIPT_BEGIN+12
#define IDE_SCRIPT_OBJ_INSTANTIATE_FAILED	IDE_SCRIPT_BEGIN+13
#define IDE_SCRIPT_OBJ_ONPAGE_QI_FAILED		IDE_SCRIPT_BEGIN+14   
#define IDE_SCRIPT_END				IDE_SCRIPT_BEGIN+15

// 
// CTemplate errors
//
#define IDE_TEMPLATE_BEGIN						2000
#define IDE_TEMPLATE_ERRMSG_TITLE				IDE_TEMPLATE_BEGIN
#define IDE_TEMPLATE_ERRMSG_PREFIX				IDE_TEMPLATE_BEGIN + 1
#define IDE_TEMPLATE_NO_CLOSE_PSCRIPT			IDE_TEMPLATE_BEGIN + 2
#define IDE_TEMPLATE_NO_CLOSE_TSCRIPT			IDE_TEMPLATE_BEGIN + 3
#define IDE_TEMPLATE_NO_CLOSE_OBJECT			IDE_TEMPLATE_BEGIN + 4
#define IDE_TEMPLATE_NO_CLASSID_PROGID			IDE_TEMPLATE_BEGIN + 5
#define IDE_TEMPLATE_RUNAT_NOT_SERVER			IDE_TEMPLATE_BEGIN + 6
#define IDE_TEMPLATE_BAD_PAGE_OBJECT_SCOPE		IDE_TEMPLATE_BEGIN + 7
#define IDE_TEMPLATE_BAD_GLOBAL_OBJECT_SCOPE	IDE_TEMPLATE_BEGIN + 8
#define IDE_TEMPLATE_NO_OBJECT_NAME				IDE_TEMPLATE_BEGIN + 9
#define IDE_TEMPLATE_NO_ENGINE_NAME				IDE_TEMPLATE_BEGIN + 10
#define IDE_TEMPLATE_NO_ATTRIBUTE_DELIMITER		IDE_TEMPLATE_BEGIN + 11
#define IDE_TEMPLATE_BAD_INCLUDE				IDE_TEMPLATE_BEGIN + 12
#define IDE_TEMPLATE_NO_CLOSE_HTML_COMMENT		IDE_TEMPLATE_BEGIN + 13
#define IDE_TEMPLATE_NO_INCLUDE_NAME			IDE_TEMPLATE_BEGIN + 14
#define IDE_TEMPLATE_BAD_PROGLANG				IDE_TEMPLATE_BEGIN + 15
#define IDE_TEMPLATE_BAD_FILE_TAG				IDE_TEMPLATE_BEGIN + 16
#define IDE_TEMPLATE_DISALLOWED_PARENT_PATH		IDE_TEMPLATE_BEGIN + 17
#define IDE_TEMPLATE_ERRMSG_GENERIC				IDE_TEMPLATE_BEGIN + 18
#define IDE_TEMPLATE_BAD_CLASSID				IDE_TEMPLATE_BEGIN + 19
#define IDE_TEMPLATE_BAD_PROGID					IDE_TEMPLATE_BEGIN + 20
#define IDE_TEMPLATE_CYCLIC_INCLUDE				IDE_TEMPLATE_BEGIN + 21
#define IDE_TEMPLATE_INVALID_OBJECT_NAME		IDE_TEMPLATE_BEGIN + 22
#define IDE_TEMPLATE_BAD_GLOBAL_PSCRIPT			IDE_TEMPLATE_BEGIN + 23
#define IDE_TEMPLATE_NESTED_TSCRIPT				IDE_TEMPLATE_BEGIN + 24
#define IDE_TEMPLATE_NESTED_OBJECT				IDE_TEMPLATE_BEGIN + 25
#define IDE_TEMPLATE_PAGE_COMMAND_NOT_FIRST		IDE_TEMPLATE_BEGIN + 26
#define IDE_TEMPLATE_PAGE_COMMAND_REPEATED		IDE_TEMPLATE_BEGIN + 27
#define IDE_TEMPLATE_BAD_PROGLANG_IN_REGISTRY	IDE_TEMPLATE_BEGIN + 28
#define IDE_TEMPLATE_NO_CODEPAGE				IDE_TEMPLATE_BEGIN + 29
#define IDE_TEMPLATE_BAD_CODEPAGE				IDE_TEMPLATE_BEGIN + 30
#define IDE_TEMPLATE_BAD_TRANSACTED_VALUE		IDE_TEMPLATE_BEGIN + 31
#define IDE_TEMPLATE_BAD_SESSION_VALUE		    IDE_TEMPLATE_BEGIN + 32
#define IDE_TEMPLATE_BAD_OBJECT_SCOPE           IDE_TEMPLATE_BEGIN + 33
#define IDE_TEMPLATE_NO_LCID					IDE_TEMPLATE_BEGIN + 34
#define IDE_TEMPLATE_BAD_LCID					IDE_TEMPLATE_BEGIN + 35
#define IDE_TEMPLATE_BAD_AT_COMMAND				IDE_TEMPLATE_BEGIN + 36
#define IDE_TEMPLATE_BAD_TYPELIB_SPEC           IDE_TEMPLATE_BEGIN + 37
#define IDE_TEMPLATE_BAD_TYPELIB_REG_SPEC       IDE_TEMPLATE_BEGIN + 38
#define IDE_TEMPLATE_LOAD_TYPELIB_FAILED        IDE_TEMPLATE_BEGIN + 39
#define IDE_TEMPLATE_WRAP_TYPELIB_FAILED        IDE_TEMPLATE_BEGIN + 40
#define IDE_TEMPLATE_BAD_COOKIE_SPEC			IDE_TEMPLATE_BEGIN + 41
#define IDE_TEMPLATE_LOAD_COOKIESCRIPT_FAILED   IDE_TEMPLATE_BEGIN + 42
#define IDE_TEMPLATE_BAD_SSI_COMMAND			IDE_TEMPLATE_BEGIN + 43
#define IDE_TEMPLATE_BAD_COOKIE_SPEC_SRC        IDE_TEMPLATE_BEGIN + 44
#define IDE_TEMPLATE_BAD_COOKIE_SPEC_NAME       IDE_TEMPLATE_BEGIN + 45
#define IDE_TEMPLATE_VALUE_REQUIRED				IDE_TEMPLATE_BEGIN + 46
#define IDE_TEMPLATE_UNICODE_NOTSUP             IDE_TEMPLATE_BEGIN + 47
#define IDE_TEMPLATE_METADATA_IN_GLOBAL_ASA		IDE_TEMPLATE_BEGIN + 48
#define IDE_TEMPLATE_CANT_ENABLE_SESSIONS	    IDE_TEMPLATE_BEGIN + 49
#define IDE_TEMPLATE_END						IDE_TEMPLATE_BEGIN + 49

// 
// Executor errors
//
#define IDE_EXECUTOR_BEGIN				3000
#define IDE_204_NO_CONTENT				IDE_EXECUTOR_BEGIN + 1
#define IDE_404_OBJECT_NOT_FOUND		IDE_EXECUTOR_BEGIN + 2
#define IDE_EXECUTOR_DTC_NOT_RUNNING	IDE_EXECUTOR_BEGIN + 3
#define IDE_401_3_ACCESS_DENIED         IDE_EXECUTOR_BEGIN + 4
#define IDE_EXECUTOR_END				IDE_EXECUTOR_BEGIN + 4

// 
// Sessmgr errors
//
#define IDE_SESSMGR_BEGIN			4000
#define IDE_ERROR_STRING_403		IDE_SESSMGR_BEGIN
#define IDE_ERROR_SCRIPT_NF			IDE_SESSMGR_BEGIN+1
#define IDE_ERROR_SCRIPT_EMPTY		IDE_SESSMGR_BEGIN+2
#define IDE_OPEN_THREAD_TOKEN		IDE_SESSMGR_BEGIN+3
#define IDE_INVALID_APPLICATION		IDE_SESSMGR_BEGIN+4
#define IDE_INIT_PAGE_LEVEL_OBJ		IDE_SESSMGR_BEGIN+5
#define IDE_ADD_APPLICATION			IDE_SESSMGR_BEGIN+6
#define IDE_ADD_SESSION				IDE_SESSMGR_BEGIN+7
#define IDE_OPEN_APPLN_DIR			IDE_SESSMGR_BEGIN+8
#define IDE_CHANGE_NOTIFICATION		IDE_SESSMGR_BEGIN+9
#define IDE_IMPERSONATE_USER		IDE_SESSMGR_BEGIN+10
#define IDE_500_SERVER_ERROR		IDE_SESSMGR_BEGIN+11
#define IDE_SERVER_TOO_BUSY			IDE_SESSMGR_BEGIN+12
#define	IDE_SERVER_SHUTTING_DOWN	IDE_SESSMGR_BEGIN+13
#define IDE_GLOBAL_ASA_CHANGED		IDE_SESSMGR_BEGIN+14
#define IDE_GLOBAL_ASA_FORBIDDEN    IDE_SESSMGR_BEGIN+15
#define IDE_TOO_MANY_USERS			IDE_SESSMGR_BEGIN+16
#define IDE_BAD_CODEPAGE_IN_MB		IDE_SESSMGR_BEGIN+17
#define IDE_SESSMGR_END				IDE_SESSMGR_BEGIN+17

// 
// Threadmgr errors
//
#define IDE_THREADMGR_BEGIN			5000
#define IDE_CANT_CREATE_THREAD		IDE_THREADMGR_BEGIN
#define IDE_THREADMGR_END			IDE_CANT_CREATE_THREAD

// 
// Intrinsic errors
//
#define IDE_INTRINSIC_BEGIN						6000
#define IDE_RESPONSE_BEGIN						IDE_INTRINSIC_BEGIN
#define IDE_RESPONSE							IDE_RESPONSE_BEGIN
#define IDE_RESPONSE_HEADERS_CANT_REACH_CLIENT	IDE_RESPONSE_BEGIN + 1
#define IDE_RESPONSE_BODY_CANT_REACH_CLIENT		IDE_RESPONSE_BEGIN + 2
#define IDE_RESPONSE_HEADERS_WRITTEN			IDE_RESPONSE_BEGIN + 3
#define IDE_RESPONSE_CANT_STOP_BUFFER			IDE_RESPONSE_BEGIN + 4
#define IDE_RESPONSE_NO_URL						IDE_RESPONSE_BEGIN + 5
#define IDE_RESPONSE_BUFFER_NOT_ON				IDE_RESPONSE_BEGIN + 6
#define IDE_RESPONSE_LOG_FAILURE				IDE_RESPONSE_BEGIN + 7
#define IDE_RESPONSE_REDIRECT1					IDE_RESPONSE_BEGIN + 8
#define IDE_RESPONSE_REDIRECT2					IDE_RESPONSE_BEGIN + 9
#define IDE_RESPONSE_UNABLE_TO_CONVERT			IDE_RESPONSE_BEGIN + 10
#define IDE_RESPONSE_MODIFY_SESS_COOKIE			IDE_RESPONSE_BEGIN + 11
#define IDE_RESPONSE_COMMAS_NOT_ALLOWED			IDE_RESPONSE_BEGIN + 12
#define IDE_RESPONSE_CLEAR_AFTER_FLUSH_IN_DEBUG	IDE_RESPONSE_BEGIN + 13
#define IDE_RESPONSE_NOT_IMPLEMENTED			IDE_RESPONSE_BEGIN + 14
#define IDE_RESPONSE_END						IDE_RESPONSE_BEGIN + 14

#define IDE_SESSION								6100
#define IDE_SESSION_ID							IDE_SESSION + 1
#define IDE_SESSION_INVALID_TIMEOUT				IDE_SESSION + 2
#define IDE_SESSION_MAP_FAILED					IDE_SESSION + 3
#define IDE_SESSION_UNINITIALIZED_OBJ   		IDE_SESSION + 4
#define IDE_SESSION_INIT_FAIL					IDE_SESSION + 5
#define IDE_SESSION_END							IDE_SESSION + 6
#define IDE_SESSION_CANT_STORE_INTRINSIC		IDE_SESSION + 7
#define IDE_SESSION_CANT_STORE_NO_MODEL			IDE_SESSION + 8
#define IDE_SESSION_COULD_NOT_DELETE			IDE_SESSION + 9
#define	IDE_SESSION_CANT_STORE_TAG_OBJECT		IDE_SESSION + 10
#define	IDE_CANT_STORE_JAVASCRIPT_OBJECT		IDE_SESSION + 11
#define IDE_SESSION_INVALID_CODEPAGE			IDE_SESSION + 12

#define IDE_SERVER								6200
#define IDE_SERVER_MAPPATH						IDE_SERVER + 1
#define IDE_SERVER_MAPPATH_INVALID_STR			IDE_SERVER + 2
#define IDE_SERVER_MAPPATH_PHY_STR				IDE_SERVER + 3
#define IDE_SERVER_MAPPATH_INVALID_CHR			IDE_SERVER + 4
#define IDE_SERVER_MAPPATH_INVALID_CHR2			IDE_SERVER + 5
#define IDE_SERVER_MAPPATH_INVALID_CHR3			IDE_SERVER + 6
#define IDE_SERVER_MAPPATH_FAILED				IDE_SERVER + 7
#define IDE_SERVER_INVALID_CALL					IDE_SERVER + 8
#define IDE_SERVER_CREATEOBJ_FAILED				IDE_SERVER + 9
#define IDE_SERVER_CREATEOBJ_DENIED				IDE_SERVER + 10
#define IDE_SERVER_CREATEOBJ_NOTINPROC			IDE_SERVER + 11
#define IDE_SERVER_INVALID_TIMEOUT				IDE_SERVER + 12
#define IDE_SERVER_EXCEDED_MAX_PATH				IDE_SERVER + 13
#define IDE_SERVER_EXECUTE_FAILED				IDE_SERVER + 14
#define IDE_SERVER_EXECUTE_CANTLOAD				IDE_SERVER + 15
#define IDE_SERVER_EXECUTE_INVALID_PATH			IDE_SERVER + 16
#define IDE_SERVER_TRANSFER_FAILED				IDE_SERVER + 17
#define IDE_SERVER_TRANSFER_CANTLOAD			IDE_SERVER + 18
#define IDE_SERVER_TRANSFER_INVALID_PATH		IDE_SERVER + 19


#define IDE_APPLICATION							6300
#define IDE_APPLICATION_FAILED_INIT				IDE_APPLICATION + 1
#define IDE_APPLICATION_CANT_STORE_INTRINSIC 	IDE_APPLICATION + 2
#define IDE_APPLICATION_CANT_STORE_APT_MODEL	IDE_APPLICATION + 3
#define IDE_APPLICATION_CANT_STORE_NO_MODEL		IDE_APPLICATION + 4
#define	IDE_APPLICATION_CANT_STORE_TAG_OBJECT	IDE_APPLICATION + 5
#define IDE_APPLICATION_LOCKED_CANT_STORE_OBJ		IDE_APPLICATION + 7
#define IDE_APPLICATION_CANT_STORE_OBJECT		IDE_APPLICATION + 8
#define IDE_APPLICATION_CREATE_EVENT_FAILED		IDE_APPLICATION + 9

#define IDE_COOKIE								6400
#define IDE_COOKIE_EMPTY_DICT					IDE_COOKIE + 1
#define IDE_COOKIE_NO_NAME						IDE_COOKIE + 2
#define IDE_COOKIE_BAD_EXPIRATION				IDE_COOKIE + 3

#define IDE_REQUEST								6500
#define IDE_REQUEST_BINARYREAD_NA				IDE_REQUEST + 1
#define IDE_REQUEST_FORMCOLLECTION_NA			IDE_REQUEST + 2
#define IDE_REQUEST_GENERICCOLLECTION_NA		IDE_REQUEST + 3
#define IDE_REQUEST_STREAMONLY   				IDE_REQUEST + 4
#define IDE_REQUEST_BINREAD_BAD_ARG				IDE_REQUEST + 5

#define	IDE_COVER								6700
#define IDE_COVER_DISP_RELEASE_GPF			IDE_COVER + 1
#define IDE_COVER_ON_START_PAGE_GPF			IDE_COVER + 2
#define IDE_COVER_ON_END_PAGE_GPF			IDE_COVER + 3
#define IDE_COVER_ON_START_PAGE_FAILED		IDE_COVER + 4
#define IDE_COVER_ON_END_PAGE_FAILED		IDE_COVER + 5
	
#define IDE_CERTIFICATE					6800
#define IDE_CERTIFICATE_BAD_CERT        6801

#define IDE_OBJECTCONTEXT					6850
#define IDE_OBJECTCONTEXT_NOT_TRANSACTED	6851

#define IDE_INTRINSIC_END				IDE_CERTIFICATE_BAD_CERT

// 
// Cachemgr errors
//
#define IDE_CACHEMGR_BEGIN			7000
#define IDE_CACHEMGR_END			IDE_CACHEMGR_BEGIN

//
// NT event log errors and warnings
//
#define IDE_EVENT_BEGIN				8000
#define IDE_EVENT_END				IDE_EVENT_BEGIN + 1

//
// Errors that utility functions detect
//
#define IDE_UTIL_BEGIN				9000
#define IDE_UTIL_NO_VALUE			IDE_UTIL_BEGIN

#define IDE_END						IDE_UTIL_NO_VALUE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\reg.cpp ===
/*===================================================================
Microsoft IIS Active Server Pages

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Registry stuff

File: reg.cpp

Owner: AndrewS/LeiJin
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#if _IIS_5_1
#include <iadm.h>
#elif _IIS_6_0
#include <iadmw.h>
#else
#error "Neither _IIS_6_0 nor _IIS_5_1 is defined"
#endif

#include "comadmin.h"
#include "dlldatax.h"

#include "memchk.h"

#include "Accctrl.h"
#include "aclapi.h"

#include "iiscnfg.h"

//External functions, defined in glob.cpp
extern HRESULT MDRegisterProperties(void);
extern HRESULT MDUnRegisterProperties(void);
// Globals

const REGSAM samDesired =       KEY_READ | KEY_WRITE;

HRESULT RegisterASPProperties(BOOL fReg = TRUE);



/*
 * Info about our intrinsics used by Register & UnRegister
 */
const char *szClassDesc[] = {  "ASP Response Object",
                               "ASP Request Object",
                               "ASP Request Dictionary",
                               "ASP Server Object",
                               "ASP Application Object",
                               "ASP Session Object",
                               "ASP String List Object",
                               "ASP Read Cookie",
                               "ASP Write Cookie",
                               "ASP Scripting Context Object",
                               "ASP Certificate Object",
                                };

const char *szCLSIDEntry[] = { "CLSID\\{D97A6DA0-A864-11cf-83BE-00A0C90C2BD8}",  // IResponse
                               "CLSID\\{D97A6DA0-A861-11cf-93AE-00A0C90C2BD8}",  // IRequest
                               "CLSID\\{D97A6DA0-A85F-11df-83AE-00A0C90C2BD8}",  // IRequestDictionary
                               "CLSID\\{D97A6DA0-A867-11cf-83AE-01A0C90C2BD8}",  // IServer
                               "CLSID\\{D97A6DA0-A866-11cf-83AE-10A0C90C2BD8}",  // IApplicationObject
                               "CLSID\\{D97A6DA0-A865-11cf-83AF-00A0C90C2BD8}",  // ISessionObject
                               "CLSID\\{D97A6DA0-A85D-11cf-83AE-00A0C90C2BD8}",  // IStringList
                               "CLSID\\{71EAF260-0CE0-11d0-A53E-00A0C90C2091}",  // IReadCookie
                               "CLSID\\{D97A6DA0-A862-11cf-84AE-00A0C90C2BD8}",  // IWriteCookie
                               "CLSID\\{D97A6DA0-A868-11cf-83AE-00B0C90C2BD8}",  // IScriptingContext
                               "CLSID\\{b3192190-1176-11d0-8ce8-00aa006c400c}",  // ICertificate
                               };

const cClassesMax = sizeof(szCLSIDEntry) / sizeof(char *);


/*===================================================================
RegisterIntrinsics

Register info about our intrinsics in the registry.

Returns:
        HRESULT - S_OK on success

Side effects:
        Registers denali objects in the registry
===================================================================*/
HRESULT RegisterIntrinsics(void)
{
        static const char szDenaliDLL[] = "asp.DLL";
        static const char szThreadingModel[] = "ThreadingModel";
        static const char szInprocServer32[] = "InprocServer32";
        static const char szFreeThreaded[] = "Both";
        static const char szProgIdKey[] = "ProgId";
        static const char szCLSIDKey[] = "CLSID";

        HRESULT hr = S_OK;
        char            szPath[MAX_PATH];
        char            *pch;
        HKEY            hkeyCLSID = NULL;
        HKEY            hkeyT = NULL;
        HKEY            hkey2;
        DWORD           iClass;

        // Get the path and name of Denali
        if (!GetModuleFileNameA(g_hinstDLL, szPath, sizeof(szPath)/sizeof(char)))
                return E_FAIL;
        // bug fix 102010 DBCS fixes
        //
        //for (pch = szPath + lstrlen(szPath); pch > szPath && *pch != TEXT('\\'); pch--)
        //      ;
        //if (pch == szPath)

        pch = (char*) _mbsrchr((const unsigned char*)szPath, '\\');
        if (pch == NULL)
                {
                Assert(FALSE);
                goto LErrExit;
                }

        strcpy(pch + 1, szDenaliDLL);

        for (iClass = 0; iClass < cClassesMax; iClass++)
                {
                // install the CLSID key
                // Setting the value of the description creates the key for the clsid
                if ((RegSetValueA(HKEY_CLASSES_ROOT, szCLSIDEntry[iClass], REG_SZ, szClassDesc[iClass],
                        strlen(szClassDesc[iClass])) != ERROR_SUCCESS))
                        goto LErrExit;

                // Open the CLSID key so we can set values on it
                if      (RegOpenKeyExA(HKEY_CLASSES_ROOT, szCLSIDEntry[iClass], 0, samDesired, &hkeyCLSID) != ERROR_SUCCESS)
                        goto LErrExit;

                // install the InprocServer32 key and open the sub-key to set the named value
                if ((RegSetValueA(hkeyCLSID, szInprocServer32, REG_SZ, szPath, strlen(szPath)) != ERROR_SUCCESS))
                        goto LErrExit;

                if ((RegOpenKeyExA(hkeyCLSID, szInprocServer32, 0, samDesired, &hkeyT) != ERROR_SUCCESS))
                        goto LErrExit;

                // install the ThreadingModel named value
                if (RegSetValueExA(hkeyT, szThreadingModel, 0, REG_SZ, (const BYTE *)szFreeThreaded,
                                (strlen(szFreeThreaded)+1) * sizeof(char)) != ERROR_SUCCESS)
                        goto LErrExit;

                if (RegCloseKey(hkeyT) != ERROR_SUCCESS)
                        goto LErrExit;
                hkeyT = NULL;

                RegCloseKey(hkeyCLSID);
                hkeyCLSID = NULL;
                }


        return hr;

LErrExit:
        RegCloseKey(hkeyT);
        RegCloseKey(hkeyCLSID);
        return E_FAIL;
}

/*===================================================================
UnRegisterKey

Given a string which is the name of a key under HKEY_CLASSES_ROOT,
delete everything under that key and the key itself from the registry
(why the heck isnt there an API that does this!?!?)

Returns:
        HRESULT - S_OK on success

Side effects:
        Removes a key & all subkeys from the registry
===================================================================*/
HRESULT UnRegisterKey(CHAR *szKey)
{
        HKEY            hkey = NULL;
        CHAR            szKeyName[255];
        DWORD           cbKeyName;
        LONG            errT;

        // Open the HKEY_CLASSES_ROOT\CLSID\{...} key so we can delete its subkeys
        if      (RegOpenKeyExA(HKEY_CLASSES_ROOT, szKey, 0, samDesired, &hkey) != ERROR_SUCCESS)
                goto LErrExit;

        // Enumerate all its subkeys, and delete them
        while (TRUE)
                {
                cbKeyName = sizeof(szKeyName);
                if ((errT = RegEnumKeyExA(hkey, 0, szKeyName, &cbKeyName, 0, NULL, 0, NULL)) != ERROR_SUCCESS)
                        break;

                if ((errT = RegDeleteKeyA(hkey, szKeyName)) != ERROR_SUCCESS)
                        goto LErrExit;
                }

        // Close the key, and then delete it
        if ((errT = RegCloseKey(hkey)) != ERROR_SUCCESS)
                return(E_FAIL);
        if ((errT = RegDeleteKeyA(HKEY_CLASSES_ROOT, szKey)) != ERROR_SUCCESS)
                {
        DBGPRINTF((DBG_CONTEXT, "Deleting key %s returned %d\n",
                    szKey, GetLastError()));
                return(E_FAIL);
                }

        return S_OK;

LErrExit:
        RegCloseKey(hkey);
        return E_FAIL;
}

/*===================================================================
UnRegisterIntrinsics

UnRegister the info about our intrinsics from the registry.

Returns:
        HRESULT - S_OK on success

Side effects:
        Removes denali objects from the registry
===================================================================*/
HRESULT UnRegisterIntrinsics(void)
{
        HRESULT         hr = S_OK, hrT;
        DWORD           iClass;

        // Now delete the keys for the objects
        for (iClass = 0; iClass < cClassesMax; iClass++)
                {
                // Open the HKEY_CLASSES_ROOT\CLSID\{...} key so we can delete its subkeys
                if (FAILED(hrT = UnRegisterKey((CHAR *)szCLSIDEntry[iClass])))
                        hr = hrT;       // Hold onto the error, but keep going

                }

        return hr;
}


/*===================================================================
RegisterTypeLib

Register denali typelib in the registry.

Returns:
        HRESULT - S_OK on success

Side effects:
        register denali typelib in the registry
===================================================================*/
HRESULT RegisterTypeLib(void)
{
        HRESULT hr;
        ITypeLib *pITypeLib = NULL;

        char    szFile[MAX_PATH + 4];
        BSTR    bstrFile;

        // Get the path and name of Denali
        if (!GetModuleFileNameA(g_hinstDLL, szFile, sizeof(szFile)/sizeof(char)))
                return E_FAIL;

        // There are two type libraries: First the standard ASP typelib
        //              then the typelib for the Transacted Script Context object.
        //              Load them both.

        // First type lib, from default (first ITypeLib entry) location
        hr = SysAllocStringFromSz(szFile, 0, &bstrFile);
        if (FAILED(hr))
                return hr;

        hr = LoadTypeLibEx(bstrFile, REGKIND_REGISTER, &pITypeLib);
        if (pITypeLib)
                {
                pITypeLib->Release();
                pITypeLib = NULL;
                }

        SysFreeString(bstrFile);

        return hr;
}
/*===================================================================
UnRegisterTypeLib

UnRegister denali typelib in the registry.  Note: Only the current version used by asp.dll is removed.

Returns:
        HRESULT - S_OK on success

Side effects:
        unregister denali typelib in the registry
===================================================================*/
HRESULT UnRegisterTypeLib(void)
{
        HRESULT hr;
        ITypeLib *pITypeLib = NULL;
        TLIBATTR *pTLibAttr = NULL;

        char    szFile[MAX_PATH + 4];
        BSTR    bstrFile;

        // Get the path and name of Denali
        if (!GetModuleFileNameA(g_hinstDLL, szFile, sizeof(szFile)/sizeof(char)))
                return E_FAIL;

        hr = SysAllocStringFromSz(szFile, 0, &bstrFile);
        if (FAILED(hr))
                return hr;

        hr = LoadTypeLibEx(bstrFile, REGKIND_REGISTER, &pITypeLib);
        if(SUCCEEDED(hr) && pITypeLib)
                {
                hr = pITypeLib->GetLibAttr(&pTLibAttr);
                if(SUCCEEDED(hr) && pTLibAttr)
                        {
                        hr = UnRegisterTypeLib( pTLibAttr->guid,
                                                                        pTLibAttr->wMajorVerNum,
                                                                        pTLibAttr->wMinorVerNum,
                                                                        pTLibAttr->lcid,
                                                                        pTLibAttr->syskind);

                        pITypeLib->ReleaseTLibAttr(pTLibAttr);
                        pTLibAttr = NULL;
                        }
                pITypeLib->Release();
                pITypeLib = NULL;
                }

        SysFreeString(bstrFile);

        return hr;
}

HRESULT  GetIWAMAccountName(LPSTR   pszIdentity,
                            DWORD    cbIdentity)
{

    HRESULT         hr = S_OK;
  	IMSAdminBase	*pMetabase = NULL;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
    DWORD           dwRequiredLen;
    CWCharToMBCS    convStr;

	MD_SET_DATA_RECORD(	&recMetaData, 
                        MD_WAM_USER_NAME, 
                        METADATA_NO_ATTRIBUTES, 
                        IIS_MD_UT_WAM,
						STRING_METADATA,  
                        cbIdentity, 
                        pszIdentity);

   	if (FAILED(hr = CoCreateInstance(CLSID_MSAdminBase, 
                                     NULL, 
                                     CLSCTX_SERVER, 
                                     IID_IMSAdminBase, 
                                     (void **)&pMetabase)));
		
	// Open key to the Web service, and get a handle of \LM\w3svc
	else if (FAILED(hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, 
                                            (LPWSTR)(L"\\LM\\W3SVC"),
							                METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
							                2000, 
                                            &hMetabase)));

    // get the data.  This will return the IWAM username in the caller
    // supplied buffer.  The name will be UNICODE.

    else if (FAILED(hr = pMetabase->GetData(hMetabase, 
                                            NULL, 
                                            &recMetaData, 
                                            &dwRequiredLen)));

    // convert the string to MBCS using the CP_ACP

    else if (FAILED(hr = convStr.Init((LPWSTR)pszIdentity)));

    // overwrite the caller's memory with the converted string

    else strcpy(pszIdentity, convStr.GetString());

    // cleanup

    if (hMetabase && pMetabase)
        pMetabase->CloseKey(hMetabase);

    if (pMetabase)
        pMetabase->Release();

    return(hr);
}

HRESULT CreateCompiledTemplatesTempDir()
{
    HRESULT                 hr = S_OK;
	BYTE                    szRegString[MAX_PATH];
    BYTE                    pszExpanded[MAX_PATH];
    int                     result = 0;
    EXPLICIT_ACCESSA        ea[3];
    PACL                    pNewDACL = NULL;
    char                    szWamIdentity[1024];
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;

    // read the temp dir name for the persistant templ
    // cache.

    CchLoadStringOfId(IDS_DEFAULTPERSISTDIR, (LPSTR)szRegString, MAX_PATH);

    result = ExpandEnvironmentStringsA((LPCSTR)szRegString,
                                       (LPSTR)pszExpanded,
                                       MAX_PATH);  
    
    if ((result <= MAX_PATH) && (result > 0)) {
        CreateDirectoryA((LPCSTR)pszExpanded,NULL);        
    }

    // this next section of code will place the SYSTEM and IWAM_<ComputerName>
    // ACEs on the directorie's ACL

    ZeroMemory(ea, sizeof(EXPLICIT_ACCESSA) * 3);
    
    ea[0].grfAccessPermissions = SYNCHRONIZE | GENERIC_ALL;
    ea[0].grfAccessMode = GRANT_ACCESS;
    ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;

    ea[1].grfAccessPermissions = SYNCHRONIZE | GENERIC_ALL;
    ea[1].grfAccessMode = GRANT_ACCESS;
    ea[1].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    ea[1].Trustee.ptstrName = szWamIdentity;

    ea[2].grfAccessPermissions = SYNCHRONIZE | GENERIC_ALL;
    ea[2].grfAccessMode = GRANT_ACCESS;
    ea[2].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;

    // go get the IWAM account name from the metabase

    if (FAILED(hr = GetIWAMAccountName(szWamIdentity, sizeof(szWamIdentity))));

    // build the new DACL with just these ACEs

    else if (!AllocateAndInitializeSid(&NtAuthority,
                                       1,
                                       SECURITY_LOCAL_SYSTEM_RID,
                                       0,0,0,0,0,0,0,
                                       (PSID *)(&ea[0].Trustee.ptstrName)))

        hr = HRESULT_FROM_WIN32(GetLastError());

    else if (!AllocateAndInitializeSid(&NtAuthority,
                                       2,            // 2 sub-authorities
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_ADMINS,
                                       0,0,0,0,0,0,
                                       (PSID *)(&ea[2].Trustee.ptstrName)))

        hr = HRESULT_FROM_WIN32(GetLastError());

    else if ((hr = SetEntriesInAclA(3, 
                                    ea, 
                                    NULL, 
                                    &pNewDACL)) != ERROR_SUCCESS);

    // set the ACL on the directory

    else hr = SetNamedSecurityInfoA((LPSTR)pszExpanded,
                                    SE_FILE_OBJECT,
                                    DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                                    NULL,
                                    NULL,
                                    pNewDACL,
                                    NULL);
    if (pNewDACL)
        LocalFree(pNewDACL);

    if (ea[0].Trustee.ptstrName)
        FreeSid(ea[0].Trustee.ptstrName);

    if (ea[2].Trustee.ptstrName)
        FreeSid(ea[2].Trustee.ptstrName);

    return(hr);
}

/*===================================================================
DllRegisterServer

Entry point used by RegSvr32.exe to register the DLL.

Returns:
        HRESULT - S_OK on success

Side effects:
        Registers denali objects in the registry
===================================================================*/
STDAPI DllRegisterServer(void)
        {
        HRESULT             hr;
        HRESULT             hrCoInit;

        hrCoInit = CoInitialize(NULL);

    // First try to unregister some stuff
    // This is important when we are registering on top of
    // an old IIS 3.0 Denali registration
    // Don't care if fails
        UnRegisterEventLog();
        UnRegisterIntrinsics();
        UnRegisterTypeLib();


    // Now do the registration

        if (FAILED(hr = MDRegisterProperties()))
                goto LErr;

        // Register NT event log
        if(FAILED(hr = RegisterEventLog()))
                goto LErr;

        if (FAILED(hr = RegisterTypeLib()))
                goto LErr;

        // Register our intrinsics
        if (FAILED(hr = RegisterIntrinsics()))
                goto LErr;

        if(FAILED(hr = RegisterASPProperties(TRUE)))
                goto LErr;

        if (FAILED(hr = CreateCompiledTemplatesTempDir()))
            goto LErr;

LErr:
        if (SUCCEEDED(hrCoInit))
                CoUninitialize();
        return(hr);
        }

/*===================================================================
DllUnregisterServer

Entry point used by RegSvr32.exe to unregister the DLL.

Returns:
        HRESULT - S_OK on success

Side effects:
        Removes denali registrations from the registry
===================================================================*/
STDAPI DllUnregisterServer(void)
        {
        HRESULT hr = S_OK, hrT;
        HRESULT hrCoInit;

        hrCoInit = CoInitialize(NULL);

        hrT = UnRegisterEventLog();
        if (FAILED(hrT))
                hr = hrT;

        hrT = MDUnRegisterProperties();
        if (FAILED(hrT))
                hr = hrT;

        hrT = UnRegisterIntrinsics();
        if (FAILED(hrT))
                hr = hrT;

        hrT = UnRegisterTypeLib();
        if (FAILED(hrT))
                hr = hrT;

        hrT = RegisterASPProperties(FALSE);
        if (FAILED(hrT))
                hr = hrT;


        // UNDONE BUG 80063: Ignore errors from this call
#ifdef UNDONE
        if (FAILED(hrT))
                hr = hrT;
#endif


        if (SUCCEEDED(hrCoInit))
                CoUninitialize();

        return(hr);
        }

/*===================================================================
RegisterASPProperties

Entry point used by RegSvr32.exe to register and unregister
ASP setting stored in the SYSTEM registry.

Parameters
        fReg    = TRUE  - to register
                          FALSE - to unregister
Returns:
        HRESULT - S_OK on success

Side effects:
        Removes denali registrations from the registry
===================================================================*/

HRESULT RegisterASPProperties(BOOL fReg)
        {
        HKEY    hkey1 = NULL, hkey2 = NULL;
        DWORD   iValue;
        LONG    lT;

        static const char szW3SVC[]    = "System\\CurrentControlSet\\Services\\W3SVC";
        static const char szW3SVCASP[] = "System\\CurrentControlSet\\Services\\W3SVC\\ASP\\Parameters";
        static const char szASPParm[]  = "ASP\\Parameters";

        BYTE    szDefailtString[1024];


        // Open the key for W3SVCASP so we can add denali under it if it does not exist
        //
        if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, szW3SVCASP, 0, samDesired, &hkey2) != ERROR_SUCCESS)
                {
                // if the key does not exits and you call with FALSE the exit with error
                //
                if (!fReg)
                        goto LErrExit;

                // Open the key for W3SVC so we can add denali under it
                //
                if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, szW3SVC, 0, samDesired, &hkey1) != ERROR_SUCCESS)
                        {
                        MSG_Error(IDS_IIS_NOTINSTALLED);
                        return(E_FAIL);
                        }

                // Add the key for Denali\Parameters
                //
                if (RegCreateKeyA(hkey1, szASPParm, &hkey2) != ERROR_SUCCESS)
                        return(E_FAIL);
                }

        // release the extra key
        //
        if (hkey1)
                RegCloseKey(hkey1);
        hkey1 = hkey2;

    // set whatever is needed under hkey1
    // (currently nothing)

        // done clean up and exit
        if (RegCloseKey(hkey1) != ERROR_SUCCESS)
                return(E_FAIL);
        return S_OK;

LErrExit:
        RegCloseKey(hkey1);
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\response.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Response object

File: response.cpp

Owner: CGrant

This file contains the code for the implementation of the Response object.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "response.h"
#include "request.h"
#include "Cookies.h"
#include "perfdata.h"

#include "winsock2.h"

#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

static const char s_szContentLengthHeader[] = "Content-Length: ";
static const char s_szContentTypeHeader[]   = "Content-Type: ";
static const char s_szCharSetHTML[]         = "; Charset=";
static const char s_szCacheControl[]        = "Cache-control: ";
static const char s_szCacheControlPrivate[] = "Cache-control: private\r\n";
static const char s_szTransferEncoding[]    = "Transfer-Encoding: chunked\r\n";
static const char s_szHTML[]                = "text/html";
static const char s_szCDF[]                 = "application/x-cdf";
static const char s_szDefaultStatus[]       = "200 OK";

inline void AddtoTotalByteOut(int cByteOut)
    {
#ifndef PERF_DISABLE
    g_PerfData.Add_REQTOTALBYTEOUT(cByteOut);
#endif
    }

inline const char *GetResponseMimeType(CIsapiReqInfo *pIReq)
    {
    TCHAR *szPath = pIReq->QueryPszPathTranslated();
    DWORD cch = pIReq->QueryCchPathTranslated();
    if (cch > 4 && _tcscmp(szPath + cch - 4, _T(".CDX")) == 0)
        {
        return s_szCDF;
        }
    else
        {
        return s_szHTML;
        }
    }

/*
 *
 *
 *
 * C R e s p o n s e C o o k i e s
 *
 *
 *
 */

//===================================================================
// CResponseCookies::CResponseCookies
//
// Constructor.
//===================================================================
CResponseCookies::CResponseCookies(CResponse *pResponse, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pResponse)
        pResponse->AddRef();
    m_pResponse = pResponse;

    m_pRequest = NULL;

    CDispatch::Init(IID_IRequestDictionary);
    }

//===================================================================
// CResponseCookies::~CResponseCookies
//
// Destructor.
//===================================================================
CResponseCookies::~CResponseCookies()
    {
    if (m_pRequest)
        m_pRequest->Release();

    if (m_pResponse)
        m_pResponse->Release();
    }

//===================================================================
// CResponseCookies::ReInit
//
// Parameters:
//  pRequest  - pointer to the request object. Will need it to
//              read the request for the cookies
//
// Returns:
//  always S_OK, unlest pRequest is NULL.
//===================================================================
HRESULT CResponseCookies::ReInit(CRequest *pRequest)
    {
    if (pRequest)
        pRequest->AddRef();
    if (m_pRequest)
        m_pRequest->Release();

    m_pRequest = pRequest;      // CRequest is not ref counted, so no need for AddRef/Release

    if (m_pRequest == NULL)
        return E_POINTER;

    return S_OK;
    }

/*===================================================================
CResponseCookies::QueryInterface
CResponseCookies::AddRef
CResponseCookies::Release

IUnknown members for CResponseCookies object.
===================================================================*/

STDMETHODIMP CResponseCookies::QueryInterface(const IID &idInterface, void **ppvObj)
    {
    *ppvObj = NULL;

    if (idInterface == IID_IUnknown || idInterface == IID_IRequestDictionary || idInterface == IID_IDispatch)
        *ppvObj = this;

    else if (idInterface == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
    }

STDMETHODIMP_(ULONG) CResponseCookies::AddRef()
    {
    return m_punkOuter->AddRef();
    }

STDMETHODIMP_(ULONG) CResponseCookies::Release()
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CResponseCookies::get_Item

Function called from DispInvoke to get values from the Response.Cookies
collection.  If the Cookie does not exist, then a new one is created
and added to the Request dictionary

Parameters:
    varKey      VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CResponseCookies::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pResponse->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii value of 'varKey'
    CRequestHit     *pRequestHit;   // pointer to request bucket
    DWORD           vt = 0;         // Variant type of key
    CWCharToMBCS    convKey;

    if (m_pResponse->FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    // Initialize things
    //
    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = NULL;
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }

    vt = V_VT(pvarKey);

    switch(vt)
        {
        // Bug 95201 support all numberic sub-types
        case VT_I1:  case VT_I2:               case VT_I8:
        case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
        case VT_R4:  case VT_R8:
            // Coerce all integral types to VT_I4
            if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
                goto LExit;

            // fallthru to VT_I4

        case VT_I4:
        case VT_BSTR:
            break;
        default:
            ExceptionId(IID_IRequestDictionary, IDE_COOKIE, IDE_EXPECTING_STR);
            hrReturn = E_FAIL;
            goto LExit;
        }

    if (FAILED(m_pRequest->CheckForTombstone()))
        {
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadCookies)
        {
        char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();

        if (FAILED(hrReturn = m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadCookies = FALSE;
        }

    if (vt == VT_BSTR)
        {
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IResponse, IDE_COOKIE, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
                        szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        // Bug 456: Don't allow assignment to DenaliSessionID
        if (strncmp(szKey, SZ_SESSION_ID_COOKIE_PREFIX, CCH_SESSION_ID_COOKIE_PREFIX) == 0)
            {
            ExceptionId(IID_IResponse, IDE_COOKIE, IDE_RESPONSE_MODIFY_SESS_COOKIE);
            hrReturn = E_FAIL;
            goto LExit;
            }

            pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount = 0;
        if (vt == VT_I2)
            {
            iCount = V_I2(pvarKey);
            }
        else
            {
            iCount = V_I4(pvarKey);
            }

        // The Request hits for all cookies are stored with the request object
        if ((iCount < 1) || (iCount > (int) m_pRequest->m_pData->m_Cookies.m_dwCount))
            {
            hrReturn = E_FAIL;
            goto LExit;
            }

        pRequestHit = m_pRequest->m_pData->m_Cookies.m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CCookie *pDictionary = pRequestHit->m_pCookieData;
        if (pDictionary == NULL)
            goto LNotFound;

        if (FAILED(pDictionary->QueryInterface(IID_IWriteCookie, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
            Assert (FALSE);

        goto LExit;
        }

LNotFound:
    // don't allow empty cookie names
    //
    if (*szKey == '\0')
        {
        ExceptionId(IID_IResponse, IDE_COOKIE, IDE_COOKIE_NO_NAME);
        hrReturn = E_FAIL;
        goto LExit;
        }

    // Create a new RequestHit if there is no key by this name
    if (pRequestHit == NULL)
        {
        pRequestHit = new CRequestHit;
        if (pRequestHit == NULL || FAILED(pRequestHit->Init(szKey, TRUE)))
            {
            if (pRequestHit)
                delete pRequestHit;
            ExceptionId(IID_IResponse, IDE_COOKIE, IDE_OOM);
            hrReturn = E_OUTOFMEMORY;
            goto LExit;
            }

        m_pRequest->GetStrings()->AddElem(pRequestHit);
        }

    // Create a new cookie, with an initial unassigned value.
    if (pRequestHit->m_pCookieData == NULL)
        {
        pRequestHit->m_pCookieData = new CCookie(m_pResponse->GetIReq(),m_pRequest->GetCodePage());
        if (pRequestHit->m_pCookieData == NULL || FAILED(pRequestHit->m_pCookieData->Init()))
            {
            ExceptionId(IID_IResponse, IDE_COOKIE, IDE_OOM);
            hrReturn = E_OUTOFMEMORY;
            goto LExit;
            }
        }

    // Add this Request hit to the ResponseCookies array of hits
    if (!m_pRequest->m_pData->m_Cookies.AddRequestHit(pRequestHit))
        {
        return E_OUTOFMEMORY;
        }

    // Query for IWriteCookie
    if (FAILED(pRequestHit->m_pCookieData->QueryInterface(IID_IWriteCookie, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
        {
        Assert (FALSE);
        }

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CResponseCookies::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CResponseCookies::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->m_pData->m_Cookies.get_Count(pcValues);
    }

/*===================================================================
CResponseCookies::get_Key

Function called from DispInvoke to get keys from the response cookie collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CResponseCookies::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->m_pData->m_Cookies.get_Key(varKey, pVar);
    }

/*===================================================================
CResponseCookies::get__NewEnum

Return a new enumerator
===================================================================*/
HRESULT CResponseCookies::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pResponse->CheckForTombstone()))
        return E_FAIL;

    *ppEnumReturn = NULL;

    CRequestIterator *pIterator = new CRequestIterator(m_pRequest, COOKIE);
    if (pIterator == NULL)
        return E_OUTOFMEMORY;

    HRESULT hrInit = pIterator->Init();
    if (FAILED(hrInit))
        {
        delete pIterator;
        return hrInit;
        }

    *ppEnumReturn = pIterator;
    return S_OK;
    }

/*===================================================================
CResponseCookies::QueryHeaderSize

Returns:
    returns the number of bytes required for the cookie headers.
===================================================================*/

size_t CResponseCookies::QueryHeaderSize()
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return 0;

    int cbHeaders = 0;

    for (CRequestHit *pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
         pRequestHit != NULL;
         pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
        {
        CCookie *pCookie = pRequestHit->m_pCookieData;
        if (pCookie == NULL || !pCookie->IsDirty())
            continue;

        // add two bytes for '\r\n'
        //
        // CCookie::GetCookieHeaderSize adds one byte for NUL terminator, so
        // just add one byte here.
        //
        // CResponse::WriteHeaders does not want to know about the NUL yet.
        //
        cbHeaders += pCookie->GetCookieHeaderSize(reinterpret_cast<char *>(pRequestHit->m_pKey)) + 1;
        }

    return cbHeaders;
    }

/*===================================================================
CResponseCookies::GetHeaders

Parameters:
    szBuffer - contains the destination buffer for the cookie header
                text

Returns:
    return a pointer to the NUL character in the destination
===================================================================*/

char *CResponseCookies::GetHeaders(char *szBuffer)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        {
        szBuffer[0] = '\0';
        return szBuffer;
        }

    for (CRequestHit *pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
         pRequestHit != NULL;
         pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
        {
        CCookie *pCookie = pRequestHit->m_pCookieData;
        if (pCookie == NULL || !pCookie->IsDirty())
            continue;

        szBuffer = pCookie->GetCookieHeader(reinterpret_cast<char *>(pRequestHit->m_pKey), szBuffer);
        szBuffer = strcpyExA(szBuffer, "\r\n");
        }

    return szBuffer;
    }


/*
 *
 *
 *
 * C R e s p o n s e B u f f e r
 *
 *
 *
 */

/*===================================================================
The CResponseBuffer object maintains an array of buffers.
If buffering is turned on, the Response.Write and Response.WriteBlock
methods will write to the buffers in these arrays rather then directly
back to the client. Response.Flush writes the content of the buffers to
the client and then frees the buffers. Response.Clear frees the buffers without
writing to the client
====================================================================*/

/*===================================================================
CResponseBuffer::CResponseBuffer

Constructor

Parameters:
    None

Returns:
    Nothing

Side Effects
    None

===================================================================*/
CResponseBuffer::CResponseBuffer()
    {
    m_pResponse = NULL;

    m_rgpchBuffers = &m_pchBuffer0;
    m_cBufferPointers = 1;
    m_pchBuffer0 = NULL;

    m_cBuffers = 0;
    m_iCurrentBuffer = 0;
    m_cchOffsetInCurrentBuffer = 0;
    m_cchTotalBuffered = 0;
    m_fInited = FALSE;
    }

/*===================================================================
CResponseBuffer::Init

Initializes the CResponseBuffer object

Parameters:
    None

Returns:
    S_OK         Success
    E_OUTOFMEMORY   Failure

Side Effects
    Allocates memory

===================================================================*/
HRESULT CResponseBuffer::Init(CResponse* pResponse)
    {
    Assert(pResponse);

    // Set the pointer to the enclosing response object
    m_pResponse = pResponse;
    m_fInited = TRUE;

    return S_OK;
    }

/*===================================================================
CResponseBuffer::~CResponseBuffer

Destructor

Parameters:
    None

Returns:
    Nothing

Side Effects
    Frees memory

===================================================================*/
CResponseBuffer::~CResponseBuffer()
    {
    Assert(m_rgpchBuffers);

    // Free all the buffers we've allocated
    for (DWORD i = 0; i < m_cBuffers; i++)
        {
        if (m_rgpchBuffers[i])
            {
            ACACHE_FSA_FREE(ResponseBuffer, m_rgpchBuffers[i]);
            }
        }

    // Free the array of buffer pointers
    // (only if allocated - doesn't point to the member pointer
    if (m_cBufferPointers > 1)
        free(m_rgpchBuffers);
    }

/*===================================================================
CResponseBuffer::GrowBuffers

Increases available buffer space

Parameters:
    cchNewRequest   count of bytes to be accomodated

Returns:
    HRESULT         Indicating success or type of failure

Side Effects
    May cause memory to be allocated

===================================================================*/
HRESULT CResponseBuffer::GrowBuffers(DWORD cchNewRequest)
    {
    Assert(m_fInited);

    // Calculate how many more buffers are needed
    DWORD cAddBuffers = (cchNewRequest+RESPONSE_BUFFER_SIZE-1)/RESPONSE_BUFFER_SIZE;

    // Always at least one must be there already
    Assert(m_rgpchBuffers);
    Assert(m_cBufferPointers);

    // Allocate more buffer pointers if needed
    if (cAddBuffers > (m_cBufferPointers - m_cBuffers)) // doesn't fit?
        {
        char **rgpchTmp;
        DWORD cNewBufferPointers = m_cBufferPointers + cAddBuffers + BUFFERS_INCREMENT;

        if (m_cBufferPointers == 1)
            rgpchTmp = (char **)malloc(cNewBufferPointers*sizeof(char *));
        else
            rgpchTmp = (char **)realloc(m_rgpchBuffers, cNewBufferPointers*sizeof(char *));
        if (!rgpchTmp)
            return E_OUTOFMEMORY;

        // preserve the first buffer pointer in the special case
        // of m_rgpchBuffers initally pointing to a member buffer pointer
        if (m_cBufferPointers == 1)
            rgpchTmp[0] = m_rgpchBuffers[0];

        m_rgpchBuffers = rgpchTmp;
        m_cBufferPointers = cNewBufferPointers;
        }

    // Allocate the new buffers
    for (DWORD i = 0; i < cAddBuffers; i++)
        {
        char *pchTmp = (char *)ACACHE_FSA_ALLOC(ResponseBuffer);
        if (!pchTmp)
            return E_OUTOFMEMORY;
        m_rgpchBuffers[m_cBuffers++] = pchTmp;
        }

    return S_OK;
    }


/*===================================================================
CResponseBuffer::Write

Writes data to the CResponseBuffer object. We first write
a data structure that describes this segment of the buffer.
The data structure identifies which method is doing the
writing, and contains an index to the starting buffer,
the starting offset in that buffer, and the length of the
data. The data itself is then writen to one or more buffers.
New buffers are allocated as needed

Parameters:
    szSource    pointer to buffer to read into the Response buffer
    cch         count of bytes to be read into the Response buffer

Returns:
    HRESULT     Indicating success or type of failure

Side Effects
    May cause memory to be allocated

===================================================================*/
HRESULT CResponseBuffer::Write(char* szSource, DWORD cch)
    {

    HRESULT hr = S_OK;

    Assert(m_fInited);

    // Caclulate how much buffer space we have left
    DWORD cchBufferRemaining;
    if (m_cBuffers)
        cchBufferRemaining = RESPONSE_BUFFER_SIZE - m_cchOffsetInCurrentBuffer;
    else
        cchBufferRemaining = 0;

    // Check if enough space is left in the current buffer
    if (cch <= cchBufferRemaining)
        {
        // Enough space available, copy data to buffer
        memcpy(m_rgpchBuffers[m_iCurrentBuffer] + m_cchOffsetInCurrentBuffer, szSource, cch);
        m_cchOffsetInCurrentBuffer += cch;
        m_cchTotalBuffered += cch;
        }
    else
        {
        // Not enough space in current buffer, allocate more buffers
        hr = GrowBuffers(cch - cchBufferRemaining);
        if (FAILED(hr))
            {
            goto lRet;
            }

        // Copy data to the buffers, we loop to handle
        // the case where the data is larger then the buffer size
        while (cch)
            {
            if (RESPONSE_BUFFER_SIZE == m_cchOffsetInCurrentBuffer)
                {
                m_iCurrentBuffer++;
                m_cchOffsetInCurrentBuffer = 0;
                }
            DWORD cchToCopy = min(cch, (RESPONSE_BUFFER_SIZE - m_cchOffsetInCurrentBuffer));
            memcpy(m_rgpchBuffers[m_iCurrentBuffer] + m_cchOffsetInCurrentBuffer, szSource, cchToCopy);
            m_cchOffsetInCurrentBuffer += cchToCopy;
            szSource += cchToCopy;
            cch -= cchToCopy;
            m_cchTotalBuffered += cchToCopy;
            }
        }

lRet:
    return(hr);
    }

/*===================================================================
CResponseBuffer::Clear

  Deletes all information currently in the buffers, and restores
  the buffer array to it's starting state.

Parameters:
    None

Returns:
    S_OK success

Side Effects
    May free memory

===================================================================*/
HRESULT CResponseBuffer::Clear()
    {
    Assert(m_fInited);

    if (m_cBuffers == 0)
        return S_OK;

    // Free all but the first of the allocated buffers
    for (DWORD i = 1; i < m_cBuffers;  i++)
        {
        ACACHE_FSA_FREE(ResponseBuffer, m_rgpchBuffers[i]);
        m_rgpchBuffers[i] = NULL;
        }

    m_cBuffers = 1;
    m_iCurrentBuffer = 0;
    m_cchOffsetInCurrentBuffer = 0;
    m_cchTotalBuffered = 0;
    return S_OK;
    }


/*===================================================================
CResponseBuffer::Flush

    Writes all data in the buffer to the client. We walk through
    the array of descriptions of buffer requests. The description
    includes which method was responsible for the request. If WriteBlock
    made the request, then we can just hand WriteClient the pointer to the HTML
    block and its length. If Write made the request, we find the starting buffer
    and offset from the request description, walk through the array of buffers until
    all of the data from the request has been writen to the client.

    After all data in the buffers has been writen to the client the buffers
    are freed.

Parameters:
    Pointer to CIsapiReqInfo
    Flag indicating whether this is in response to a head request

Returns:
    S_OK success

Side Effects
    May free memory

===================================================================*/
HRESULT CResponseBuffer::Flush(CIsapiReqInfo *pIReq)
    {
    HRESULT hr = S_OK;

    Assert(m_fInited);
    Assert(pIReq);

    // If no buffers are allocated, no point in going any further
    if (m_cchTotalBuffered == 0)
        return S_OK;

    // If this is not a head request transmit the buffer contents to the client
    if (!m_pResponse->IsHeadRequest())
        {
        // Write out all the buffers
        for (DWORD i = 0; i <= m_iCurrentBuffer; i++)
            {
            DWORD cchToWrite = (i == m_iCurrentBuffer) ?
                m_cchOffsetInCurrentBuffer : RESPONSE_BUFFER_SIZE;

            if (FAILED(CResponse::SyncWrite(pIReq, m_rgpchBuffers[i], cchToWrite)))
                {
                // Failed to write to the client,
                // further ouput to client is futile
                m_pResponse->m_pData->m_fWriteClientError = TRUE;
                break;
                }
            }
        }

    Clear();
    return hr;
    }

/*
 *
 *
 *
 * C D e b u g R e s p o n s e B u f f e r
 *
 *
 *
 */

/*===================================================================
CDebugResponseBuffer::AppendRecord

Create client side debugger metadata record and appends it to
the buffer

Parameters:

Returns:
    HRESULT     Indicating success or type of failure
===================================================================*/
HRESULT CDebugResponseBuffer::AppendRecord
(
const int cchBlockOffset,
const int cchBlockLength,
const int cchSourceOffset,
const char *pszSourceFile
)
    {
    HRESULT hr = S_OK;

#define CCH_METADATA_RECORD_MAX 40 // without filename

    if (pszSourceFile)
        {
        char *pszBuf = new char [strlen(pszSourceFile) +
                                 CCH_METADATA_RECORD_MAX + 1];
        if (pszBuf)
            {
            sprintf(pszBuf, "%d,%d,%d,%s\r\n",
                cchBlockOffset, cchBlockLength, cchSourceOffset,
                pszSourceFile);

            hr = Write(pszBuf);
            delete [] pszBuf;
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }
    else
        {
        char szBuf[CCH_METADATA_RECORD_MAX+1];
        sprintf(szBuf, "%d,%d,%d\r\n",
            cchBlockOffset, cchBlockLength, cchSourceOffset);

        hr = Write(szBuf);
        }

#undef CCH_METADATA_RECORD_MAX

    return hr;
    }

/*
 *
 *
 *
 * C H T T P H e a d e r
 *
 *
 *
 */

/*===================================================================
CHTTPHeader::CHTTPHeader

Constructor.
===================================================================*/
CHTTPHeader::CHTTPHeader()
    :
    m_fInited(FALSE),
    m_fNameAllocated(FALSE), m_fValueAllocated(FALSE),
    m_szName(NULL), m_szValue(NULL),
    m_cchName(0), m_cchValue(0),
    m_pNext(NULL)
    {
    }

/*===================================================================
CHTTPHeader::~CHTTPHeader

Destructor
===================================================================*/
CHTTPHeader::~CHTTPHeader()
    {
    if (m_fNameAllocated)
        {
        Assert(m_szName);
        delete [] m_szName;
        }
    if (m_fValueAllocated)
        {
        Assert(m_szValue);
        delete [] m_szValue;
        }
    }

/*===================================================================
HRESULT CHTTPHeader::InitHeader

Functions set the header strings. Agrument types combinations:
    BSTR, BSTR
    hardcoded char*, BSTR
    hardcoded char*, hardcoded char*
    hardcoded char*, int

Parameters:
    Name, Value

Returns:
    S_OK     Success
===================================================================*/
HRESULT CHTTPHeader::InitHeader(BSTR wszName, BSTR wszValue, UINT lCodePage /* CP_ACP */)
    {
    Assert(!m_fInited);
    Assert(wszName);

    CWCharToMBCS    convStr;
    HRESULT         hr = S_OK;

    // name

    if (FAILED(hr = convStr.Init(wszName,lCodePage))) {
        if (hr == E_OUTOFMEMORY)
            return hr;
        m_fNameAllocated = FALSE;
        m_szName = "";
    }
    else {
        m_szName = convStr.GetString(TRUE);
        m_fNameAllocated = TRUE;
    }
    m_cchName = strlen(m_szName);

    // value
    int cch = wszValue ? wcslen(wszValue) : 0;
    if (cch > 0)
        {
        if (FAILED(hr = convStr.Init(wszValue,lCodePage))) {
            return hr;
        }
        m_szValue = convStr.GetString(TRUE);
        m_fValueAllocated = TRUE;
        m_cchValue = strlen(m_szValue);
        }
    else
        {
        m_szValue = NULL;
        m_fValueAllocated = FALSE;
        m_cchValue = 0;
        }

    m_fInited = TRUE;
    return S_OK;
    }

HRESULT CHTTPHeader::InitHeader(char *szName, BSTR wszValue, UINT lCodePage /* = CP_ACP */)
    {
    Assert(!m_fInited);
    Assert(szName);

    CWCharToMBCS    convStr;
    HRESULT         hr = S_OK;

    m_szName = szName;
    m_cchName = strlen(m_szName);
    m_fNameAllocated = FALSE;

    int cch = wszValue ? wcslen(wszValue) : 0;
    if (cch > 0)
        {
        if (FAILED(hr = convStr.Init(wszValue,lCodePage))) {
            return hr;
        }
        m_szValue = convStr.GetString(TRUE);
        m_fValueAllocated = TRUE;
        m_cchValue = strlen(m_szValue);
        }
    else
        {
        m_szValue = NULL;
        m_fValueAllocated = FALSE;
        m_cchValue = 0;
        }

    m_fInited = TRUE;
    return S_OK;
    }

HRESULT CHTTPHeader::InitHeader(char *szName, char *szValue, BOOL fCopyValue)
    {
    Assert(!m_fInited);
    Assert(szName);

    m_szName = szName;
    m_cchName = strlen(m_szName);
    m_fNameAllocated = FALSE;

    if (fCopyValue)
        {
        int cch = szValue ? strlen(szValue) : 0;
        if (cch > 0)
            {
            m_szValue = new char[cch+1];
            if (m_szValue == NULL)
                return E_OUTOFMEMORY;
            m_fValueAllocated = TRUE;
            strcpy(m_szValue, szValue);
            m_cchValue = cch;
            }
        else
            {
            m_szValue = NULL;
            m_fValueAllocated = FALSE;
            m_cchValue = 0;
            }
        }
    else
        {
        m_szValue = szValue;
        m_cchValue = strlen(m_szValue);
        m_fValueAllocated = FALSE;
        }

    m_fInited = TRUE;
    return S_OK;
    }

HRESULT CHTTPHeader::InitHeader(char *szName, long lValue)
    {
    Assert(!m_fInited);
    Assert(szName);

    m_szName = szName;
    m_cchName = strlen(m_szName);
    m_fNameAllocated = FALSE;

    ltoa(lValue, m_rgchLtoaBuffer, 10);
    m_szValue = m_rgchLtoaBuffer;
    m_cchValue = strlen(m_szValue);
    m_fValueAllocated = FALSE;

    m_fInited = TRUE;
    return S_OK;
    }

/*===================================================================
CHTTPHeader::Print

Prints the header into a buffer in "Header: Value\r\n" format.

Parameters:
    szBuf       buffer to fill
===================================================================*/
void CHTTPHeader::Print
(
char *szBuf
)
    {
    Assert(m_fInited);

    Assert(m_cchName);
    Assert(m_szName);
    memcpy(szBuf, m_szName, m_cchName);
    szBuf += m_cchName;

    *szBuf++ = ':';
    *szBuf++ = ' ';

    if (m_cchValue)
        {
        Assert(m_szValue);
        memcpy(szBuf, m_szValue, m_cchValue);
        szBuf += m_cchValue;
        }

    *szBuf++ = '\r';
    *szBuf++ = '\n';
    *szBuf = '\0';
    }


/*
 *
 *
 *
 * C R e s p o n s e D a t a
 *
 *
 *
 */

/*===================================================================
CResponseData::CResponseData

Constructor

Parameters:
    CResponse *pResponse

Returns:
    Nothing.
===================================================================*/
CResponseData::CResponseData
(
CResponse *pResponse
)
    :
    m_ISupportErrImp(static_cast<IResponse *>(pResponse), this, IID_IResponse),
    m_WriteCookies(pResponse, this),
    m_cRefs(1)
    {
    m_pIReq = NULL;
    m_pHitObj = NULL;
    m_pTemplate = NULL;
    m_pFirstHeader = m_pLastHeader = NULL;
    m_fHeadersWritten = FALSE;
    m_fResponseAborted = FALSE;
    m_fWriteClientError = FALSE;
    m_fIgnoreWrites = FALSE;
    m_fBufferingOn = FALSE;
    m_fFlushed = FALSE;
    m_fChunked = FALSE;
    m_fClientDebugMode = FALSE;
    m_fClientDebugFlushIgnored = FALSE;
    m_szCookieVal = NULL;
    m_pszDefaultContentType = NULL;
    m_pszContentType = NULL;
    m_pszCharSet = NULL;
    m_pszStatus = NULL;
    m_pszCacheControl = NULL;
    m_dwVersionMajor = 0;
    m_dwVersionMinor = 0;
    m_pResponseBuffer = NULL;
    m_pClientDebugBuffer = NULL;
    m_tExpires = -1;
    m_pszDefaultExpires = NULL;
    m_pfnGetScript = NULL;
    m_pvGetScriptContext = NULL;
    }

/*===================================================================
CResponseData::~CResponseData

Destructor

Parameters:

Returns:
    Nothing.
===================================================================*/
CResponseData::~CResponseData()
    {
    // points to static string - no need to free
    // m_pszDefaultContentType = NULL;

    // Free any memory associated with the content-type
    if (m_pszContentType)
        free(m_pszContentType);

        // Free any memory associated with the CacheControl
        if (m_pszCacheControl)
                free(m_pszCacheControl);

    // Free any memory associated with the CharSet
    if (m_pszCharSet)
        free(m_pszCharSet);

    // Free any memory associated with the status
    if (m_pszStatus)
        free(m_pszStatus);

    // Free all headers
    CHTTPHeader *pHeader = m_pFirstHeader;
    while (pHeader)
        {
        CHTTPHeader *pNextHeader = pHeader->PNext();
        delete pHeader;
        pHeader = pNextHeader;
        }
    m_pFirstHeader = m_pLastHeader = NULL;

    // Clean up the Response Buffer
    if (m_pResponseBuffer)
        delete m_pResponseBuffer;

    // Clean up Client Debug Response Buffer
    if (m_pClientDebugBuffer)
        delete m_pClientDebugBuffer;
    }

/*===================================================================
CResponseData::Init

Init

Parameters:
    CResponse *pResponse

Returns:
    Nothing.
===================================================================*/
HRESULT CResponseData::Init
(
CResponse *pResponse
)
    {
    HRESULT hr = S_OK;

    m_pIReq = NULL;

    // set the HEAD request flag to 0 un-inited
    m_IsHeadRequest = 0;

    // Initialize header list
    m_pFirstHeader = m_pLastHeader = NULL;

    // Initialize the response buffer
    m_pResponseBuffer = new CResponseBuffer;
    if (m_pResponseBuffer == NULL)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = m_pResponseBuffer->Init(pResponse);

    return hr;
    }

/*===================================================================
CResponseData::QueryInterface
CResponseData::AddRef
CResponseData::Release

IUnknown members for CRequestData object.
===================================================================*/
STDMETHODIMP CResponseData::QueryInterface
(
REFIID iid,
void **ppvObj
)
    {
    if (iid == IID_IUnknown)
        {
        *ppvObj = this;
        AddRef();
        return S_OK;
        }
    else
        {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        }
    }

STDMETHODIMP_(ULONG) CResponseData::AddRef()
    {
    return ++m_cRefs;
    }

STDMETHODIMP_(ULONG) CResponseData::Release(void)
    {
    if (--m_cRefs)
        return m_cRefs;
    delete this;
    return 0;
    }

/*
 *
 *
 *
 * C R e s p o n s e
 *
 *
 *
 */

/*===================================================================
CResponse::CResponse

Constructor

Parameters:
    punkOuter   object to ref count (can be NULL)
===================================================================*/
CResponse::CResponse(IUnknown *punkOuter)
    :
    m_fInited(FALSE),
    m_fDiagnostics(FALSE),
    m_pData(NULL)
    {
    CDispatch::Init(IID_IResponse);

    if (punkOuter)
        {
        m_punkOuter = punkOuter;
        m_fOuterUnknown = TRUE;
        }
    else
        {
        m_cRefs = 1;
        m_fOuterUnknown = FALSE;
        }

#ifdef DBG
    m_fDiagnostics = TRUE;
#endif // DBG
    }

/*===================================================================
CResponse::~CResponse

Destructor

Parameters:
    None

Returns:
    Nothing.

===================================================================*/
CResponse::~CResponse()
    {
    Assert(!m_fInited);
    Assert(m_fOuterUnknown || m_cRefs == 0);  // must have 0 ref count
    }

/*===================================================================
CResponse::CleanUp

Deallocates members and removes m_pData

Parameters:
    None

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CResponse::CleanUp()
    {
    if (m_pData)
        {
        m_pData->Release();
        m_pData = NULL;
        }
    return S_OK;
    }

/*===================================================================
CResponse::Init

Allocates m_pData
Performs any intiailization of a CResponse that's prone to failure
that we also use internally before exposing the object outside.

Parameters:
    None

Returns:
    S_OK on success.

===================================================================*/
HRESULT CResponse::Init()
    {
    if (m_fInited)
        return S_OK; // already inited

    Assert(!m_pData);

    m_pData = new CResponseData(this);
    if (!m_pData)
        return E_OUTOFMEMORY;

    HRESULT hr = m_pData->Init(this);

    if (SUCCEEDED(hr))
        m_fInited = TRUE;
    else
        CleanUp();

    return hr;
    }

/*===================================================================
CResponse::UnInit

Remove m_pData. Back to UnInited state

Parameters:
    None

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::UnInit()
    {
    if (!m_fInited)
        return S_OK; // already uninited

    Assert(m_pData);
    CleanUp();
    Assert(!m_pData);

    m_fInited = FALSE;
    return S_OK;
    }

/*===================================================================
CResponse::ReInitTemplate

This function is used to set the template member. It should only
be used for an ordinary script file's template, not for global.asa template.

Parameters:
    Pointer to template

Returns:
    S_OK on success.
===================================================================*/
HRESULT CResponse::ReInitTemplate
(
CTemplate* pTemplate,
const char *szCookieVal
)
    {
    Assert(m_fInited);
    Assert(m_pData);

    Assert(pTemplate != NULL);
    Assert(m_pData->m_pTemplate == NULL);

    m_pData->m_pTemplate = pTemplate;
    m_pData->m_pTemplate->AddRef(); // We release the template in FinalFlush

    m_pData->m_szCookieVal = szCookieVal;
    return(S_OK);
    }

/*===================================================================
CResponse::SwapTemplate

Temporary substitutes Template in response
Used in child request execution

Parameters:
    Pointer to the new template

Returns:
    Pointer to the old template
===================================================================*/
CTemplate *CResponse::SwapTemplate
(
CTemplate* pNewTemplate
)
    {
    Assert(m_fInited);
    Assert(m_pData);

    CTemplate *pOldTemplate = m_pData->m_pTemplate;
    m_pData->m_pTemplate = pNewTemplate;
    return pOldTemplate;
    }

/*===================================================================
CResponse::ReInit

Each Request we service will have a new CIsapiReqInfo.
This function is used to set the value of the CIsapiReqInfo.

Parameters:
    Pointer to CIsapiReqInfo
Returns:
    S_OK on success.
===================================================================*/
HRESULT CResponse::ReInit
(
CIsapiReqInfo *pIReq,
const char *szCookieVal,
CRequest *pRequest,
PFNGETSCRIPT pfnGetScript,
void *pvGetScriptContext,
CHitObj *pHitObj
)
    {
    Assert(m_fInited);
    Assert(m_pData);

    CHTTPHeader *pCurr;
    CLinkElem *pT;
    CLinkElem *pNext;

    // set the HEAD request flag to 0 un-inited
    m_pData->m_IsHeadRequest = 0;

    // ReInitialize the WriteCookie dictionary
    if (FAILED(m_pData->m_WriteCookies.ReInit(pRequest)))
        return E_FAIL;

    // points to static string - no need to free
    m_pData->m_pszDefaultContentType = NULL;

    // Free any memory associated with the content type
    if (m_pData->m_pszContentType != NULL)
        {
        free(m_pData->m_pszContentType);
        m_pData->m_pszContentType = NULL;
        }

    // Free any memory associated with the content type
    if (m_pData->m_pszCharSet != NULL)
        {
        free(m_pData->m_pszCharSet);
        m_pData->m_pszCharSet = NULL;
        }


    // Free any memory associated with the status
    if (m_pData->m_pszStatus != NULL)
        {
        free(m_pData->m_pszStatus);
        m_pData->m_pszStatus = NULL;
        }

    // Free all headers
    CHTTPHeader *pHeader = m_pData->m_pFirstHeader;
    while (pHeader)
        {
        CHTTPHeader *pNextHeader = pHeader->PNext();
        delete pHeader;
        pHeader = pNextHeader;
        }
    m_pData->m_pFirstHeader = m_pData->m_pLastHeader = NULL;

    m_pData->m_fHeadersWritten = FALSE;

    m_pData->m_fResponseAborted = FALSE;
    m_pData->m_fWriteClientError = FALSE;
    m_pData->m_fIgnoreWrites = FALSE;
    m_pData->m_pIReq = pIReq;
    m_pData->m_szCookieVal = szCookieVal;
    m_pData->m_pszDefaultContentType = NULL;
    m_pData->m_pszContentType = NULL;
    m_pData->m_pszCharSet = NULL;
    m_pData->m_pszStatus = NULL;
    m_pData->m_pfnGetScript = pfnGetScript;
    m_pData->m_pvGetScriptContext = pvGetScriptContext;
    m_pData->m_pHitObj = pHitObj;
    m_pData->m_tExpires = -1;
    m_pData->m_pszDefaultExpires = NULL;

    // Ask for the HTTP version of the client
    GetClientVerison();

    // Set the default content type
    if (m_pData->m_pIReq)
        m_pData->m_pszDefaultContentType = GetResponseMimeType(m_pData->m_pIReq);

    // Set the default Expires Header
    // NOTE - removed per discussions on proper header settings with IE/IIS
    // teams.
#if 0
    if (m_pData->m_pIReq)
        m_pData->m_pszDefaultExpires = m_pData->m_pIReq->QueryPszExpires();
#endif

    // Set the buffering flag to the global value
    m_pData->m_fBufferingOn = (pHitObj->QueryAppConfig())->fBufferingOn();

    // Buffering always on for client code debug
    if (pHitObj && pHitObj->FClientCodeDebug())
        {
        m_pData->m_fBufferingOn = TRUE;
        m_pData->m_fClientDebugMode = TRUE;
        m_pData->m_fClientDebugFlushIgnored = FALSE;
        }
    else
        {
        m_pData->m_fClientDebugMode = FALSE;
        m_pData->m_fClientDebugFlushIgnored = FALSE;
        }

    HRESULT hr = S_OK;

    if (m_pData->m_fClientDebugMode)
        {
        // Create and init client debug buffer if needed
        if (m_pData->m_pClientDebugBuffer)
            {
            hr = m_pData->m_pClientDebugBuffer->ClearAndStart();
            }
        else
            {
            m_pData->m_pClientDebugBuffer = new CDebugResponseBuffer;
            if (m_pData->m_pClientDebugBuffer)
                hr = m_pData->m_pClientDebugBuffer->InitAndStart(this);
            else
                hr = E_OUTOFMEMORY;
            }
        }

    return hr;
    }

/*===================================================================
CResponse::QueryInterface
CResponse::AddRef
CResponse::Release

IUnknown members for CResponse object.

===================================================================*/
STDMETHODIMP CResponse::QueryInterface
(
REFIID riid,
PPVOID ppv
)
    {
    *ppv = NULL;

    /*
     * The only calls for IUnknown are either in a nonaggregated
     * case or when created in an aggregation, so in either case
     * always return our IUnknown for IID_IUnknown.
     */

    // BUG FIX 683 added IID_IDenaliIntrinsic to prevent the user from
    // storing intrinsic objects in the application and session object
    if (IID_IUnknown == riid || IID_IDispatch == riid || IID_IResponse == riid || IID_IDenaliIntrinsic == riid)
        *ppv = static_cast<IResponse *>(this);

    // Support IStream for ADO/XML
    else if (IID_IStream == riid)
        *ppv = static_cast<IStream *>(this);

    //Indicate that we support error information
    else if (IID_ISupportErrorInfo == riid)
        {
        if (m_pData)
            *ppv = &(m_pData->m_ISupportErrImp);
        }

    else if (IID_IMarshal == riid)
        {
        *ppv = static_cast<IMarshal *>(this);
        }

    //AddRef any interface we'll return.
    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
    }


STDMETHODIMP_(ULONG) CResponse::AddRef(void)
    {
    if (m_fOuterUnknown)
        return m_punkOuter->AddRef();

    return InterlockedIncrement((LPLONG)&m_cRefs);
    }


STDMETHODIMP_(ULONG) CResponse::Release(void)
    {
    if (m_fOuterUnknown)
        return m_punkOuter->Release();

    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
    if (cRefs)
        return cRefs;

    delete this;
    return 0;
    }

/*===================================================================
CResponse::GetIDsOfNames

Special-case implementation for Response.WriteBlock and
Response.Write

Parameters:
    riid            REFIID reserved. Must be IID_NULL.
    rgszNames       OLECHAR ** pointing to the array of names to be mapped.
    cNames          UINT number of names to be mapped.
    lcid            LCID of the locale.
    rgDispID        DISPID * caller allocated array containing IDs
                    corresponging to those names in rgszNames.

Return Value:
    HRESULT      S_OK or a general error code.
===================================================================*/
STDMETHODIMP CResponse::GetIDsOfNames
(
REFIID riid,
OLECHAR **rgszNames,
UINT cNames,
LCID lcid,
DISPID *rgDispID
)
    {
    const DISPID dispidWrite      = 0x60020013;
    const DISPID dispidWriteBlock = 0x60020014;

    if (cNames == 1)
        {
        // first char 'W'
        if (rgszNames[0][0] == L'w' || rgszNames[0][0] == L'W')
            {
            // swtich on strlen
            switch (wcslen(rgszNames[0]))
                {
            case 5:
                // case insensitive because user can type either way
                if (wcsicmp(rgszNames[0], L"write") == 0)
                    {
                    *rgDispID = dispidWrite;
                    return S_OK;
                    }
                break;
            case 10:
                // case sensitive because only we generate WriteBlock
                if (wcscmp(rgszNames[0], L"WriteBlock") == 0)
                    {
                    *rgDispID = dispidWriteBlock;
                    return S_OK;
                    }
                break;
                }
            }
        }

    // default to CDispatch's implementation
    return CDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispID);
    }

/*===================================================================
CResponse::CheckForTombstone

Tombstone stub for IResponse methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:

Returns:
    HRESULT     E_FAIL  if Tombstone
                S_OK if not
===================================================================*/
HRESULT CResponse::CheckForTombstone()
    {
    if (m_fInited)
        {
        // inited - good object
        Assert(m_pData); // must be present for inited objects
        return S_OK;
        }

    ExceptionId
        (
        IID_IResponse,
        IDE_RESPONSE,
        IDE_INTRINSIC_OUT_OF_SCOPE
        );
    return E_FAIL;
    }

/*===================================================================
CResponse::SyncWrite

Static method. Sends data until either everything is sent
or there's an error.

Parameters:
    pIReq        CIsapiReqInfo to send
    pchBuf      pointer to buffer to send
    cchBuf      number of bytes to send (0 means do strlen())

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::SyncWrite
(
CIsapiReqInfo *pIReq,
char *pchBuf,
DWORD cchBuf
)
    {
    Assert(pchBuf);
    if (cchBuf == 0)
        cchBuf = strlen(pchBuf);

    while (cchBuf)
        {
        // never send out more then MAX_RESPONSE bytes at one shot
        DWORD cchSend = (cchBuf < MAX_RESPONSE) ? cchBuf : MAX_RESPONSE;

        if (!pIReq->SyncWriteClient(pchBuf, &cchSend))
            return E_FAIL;

        AddtoTotalByteOut(cchSend);
        cchBuf -= cchSend;
        pchBuf += cchSend;
        }

    return S_OK;
    }

/*===================================================================
CResponse::SyncWriteFile

Static method.
Sends entire response as a content of the file

Parameters:
    pIReq            CIsapiReqInfo to send
    szFile          file name
    szMimeType      mime type
    szStatus        HTTP status
    szExtraHeaders  additional HTTP headers to send

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::SyncWriteFile
(
CIsapiReqInfo *pIReq,
TCHAR *szFile,
char *szMimeType,
char *szStatus,
char *szExtraHeaders
)
    {
    HRESULT hr = S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    BYTE *pbBytes = NULL;
    DWORD dwSize = 0;

    // open the file
    if (SUCCEEDED(hr)) {
        hFile = CreateFile(
            szFile,
            GENERIC_READ,          // access (read-write) mode
            FILE_SHARE_READ,       // share mode
            NULL,                  // pointer to security descriptor
            OPEN_EXISTING,         // how to create
            FILE_ATTRIBUTE_NORMAL, // file attributes
            NULL                   // handle to file with attributes to copy
            );
        if (hFile == INVALID_HANDLE_VALUE) {
#if UNICODE
            DBGERROR((DBG_CONTEXT, "Could not open \"%S\".  Win32 Error = %u\n", szFile, GetLastError()));
#else
            DBGERROR((DBG_CONTEXT, "Could not open \"%s\".  Win32 Error = %u\n", szFile, GetLastError()));
#endif
            hr = E_FAIL;
        }
    }

    // get file size
    if (SUCCEEDED(hr))
        {
        dwSize = GetFileSize(hFile, NULL);
        if (dwSize == 0 || dwSize == 0xFFFFFFFF)
            hr = E_FAIL;
        }

    // create mapping
    if (SUCCEEDED(hr))
        {
        hMap = CreateFileMapping(
            hFile,          // handle to file to map
            NULL,           // optional security attributes
            PAGE_READONLY,  // protection for mapping object
            0,              // high-order 32 bits of object size
            0,              // low-order 32 bits of object size
            NULL            // name of file-mapping object
            );
        if (hMap == NULL)
            hr = E_FAIL;
        }

    // map the file
    if (SUCCEEDED(hr))
        {
        pbBytes = (BYTE *)MapViewOfFile(
            hMap,           // file-mapping object to map into address space
            FILE_MAP_READ,  // access mode
            0,              // high-order 32 bits of file offset
            0,              // low-order 32 bits of file offset
            0               // number of bytes to map
            );
        if (pbBytes == NULL)
            hr = E_FAIL;
        }

    // send the response
    if (SUCCEEDED(hr))
        {
        hr = SyncWriteBlock(pIReq, pbBytes, dwSize, szMimeType, szStatus, szExtraHeaders);
        }

    // cleanup
    if (pbBytes != NULL)
        UnmapViewOfFile(pbBytes);
    if (hMap != NULL)
        CloseHandle(hMap);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return hr;
    }

/*===================================================================
CResponse::SyncWriteScriptlessTemplate

Static method.
Sends entire response as a content of the [scriptless] template.

Parameters:
    pIReq        CIsapiReqInfo to send
    pTemplate   template

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::SyncWriteScriptlessTemplate
(
CIsapiReqInfo *pIReq,
CTemplate *pTemplate
)
    {
    Assert(pTemplate && pTemplate->FScriptless());

    char*   pbHTML = NULL;
    ULONG   cbHTML = 0;
    ULONG   cbSrcOffset = 0;
    char*   pbIncSrcFileName = NULL;

    HRESULT hr = pTemplate->GetHTMLBlock(0, &pbHTML, &cbHTML, &cbSrcOffset, &pbIncSrcFileName);

    if (FAILED(hr))
        return hr;
    if (pbHTML == NULL || cbHTML == 0)
        return E_FAIL;

    SyncWriteBlock(pIReq, pbHTML, cbHTML);
    return S_OK;
    }

/*===================================================================
CResponse::SyncWriteBlocks

Static method.
Sends entire response as a content of a set of memory blocks.

Parameters:
    pIReq            CIsapiReqInfo to send
    cBlocks         number of blocks
    cbTotal         total length of all blocks
    rgpvBlock       array of pointers to buffers
    rgcbBlock       array of block sizes
    szMimeType      mime type
    szStatus        HTTP status
    szExtraHeaders  additional HTTP headers to send

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::SyncWriteBlocks
(
CIsapiReqInfo *pIReq,
DWORD cBlocks,
DWORD cbTotal,
void **rgpvBlock,
DWORD *rgcbBlock,
char *szMimeType,
char *szStatus,
char *szExtraHeaders
)
    {
    BOOL fCacheControlPrivate = FALSE;

    STACK_BUFFER( tempContent, 1024);

    // defaut mime type and status

    if (szMimeType == NULL)
        szMimeType = (char *)GetResponseMimeType(pIReq);

    if (szStatus == NULL)
        {
        szStatus = (char *)s_szDefaultStatus;
        fCacheControlPrivate = TRUE;
        }
    else
        {
        fCacheControlPrivate = (strcmp(szStatus, s_szDefaultStatus) == 0);
        }

    // extra headers size

    DWORD cbExtra = (szExtraHeaders != NULL) ? strlen(szExtraHeaders) : 0;

    // send the header

    char szLength[20];
    ltoa(cbTotal, szLength, 10);

    DWORD cchContentHeader = (DWORD)(0
      + sizeof(s_szContentTypeHeader)-1     // Content-Type:
      + strlen(szMimeType)                  // text/html
      + 2                                   // \r\n
      + cbExtra                             // Extra headers
      + sizeof(s_szContentLengthHeader)-1   // Content-Length:
      + strlen(szLength)                    // <length>
      + 4                                   // \r\n\r\n
      + 1);                                 // '\0'

    if (fCacheControlPrivate)
        cchContentHeader += sizeof(s_szCacheControlPrivate)-1;

    if (!tempContent.Resize(cchContentHeader)) {
        return E_OUTOFMEMORY;
    }

    char *szContentHeader = (char *)tempContent.QueryPtr();

    char *szBuf = szContentHeader;

    szBuf = strcpyExA(szBuf, s_szContentTypeHeader);
    szBuf = strcpyExA(szBuf, szMimeType);
    szBuf = strcpyExA(szBuf, "\r\n");

    if (cbExtra > 0)
        szBuf = strcpyExA(szBuf, szExtraHeaders);

    if (fCacheControlPrivate)
        szBuf = strcpyExA(szBuf, s_szCacheControlPrivate);

    szBuf = strcpyExA(szBuf, s_szContentLengthHeader);
    szBuf = strcpyExA(szBuf, szLength);
    szBuf = strcpyExA(szBuf, "\r\n\r\n");

    BOOL fRet = pIReq->SendHeader
        (
        szStatus,
        strlen(szStatus) + 1,
        szContentHeader,
        cchContentHeader,
        FALSE
        );
    if (!fRet)
        return E_FAIL;

    // send the data

    for (DWORD i = 0; i < cBlocks; i++)
        {
        if (FAILED(SyncWrite(pIReq, (char *)rgpvBlock[i], rgcbBlock[i])))
            return E_FAIL;
        }

    return S_OK;
    }


//IResponse interface functions

/*===================================================================
CResponse::WriteHeaders

Write out standard HTTP headers and any user created headers.
If transmission of the headers to the client fails, we still
want the calling script to finish execution, so we will return
S_OK, but set the m_fWriteClientError flag. If we are unable
to build the needed headers we will return E_FAIL.

Parameters:
    BOOL fSendEntireResponse - send headers and body all at once?

Returns:
    HRESULT     S_OK on success
                E_FAIL if unable to build expires headers
                E_OUTOFMEMORY if memory failure
===================================================================*/
HRESULT CResponse::WriteHeaders(
    BOOL fSendEntireResponse)
{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FDontWrite())
        return S_OK;

    HRESULT hr = S_OK;
    CHAR *szBuff;
    DWORD cch = 0;
    BOOL fContentTypeFound = FALSE;

    // Static cookie buffer should be enough to fit:
    //   cookie name    20 chars
    //   cookie value   24 chars
    //   decorations    28 = strlen("Set-Cookie: C=V; secure; path=/;\r\n")
#define CCH_STATIC_COOKIE_BUF    88
    char szCookieBuff[CCH_STATIC_COOKIE_BUF];
    DWORD cchCookieBuff = 0;

    STACK_BUFFER( tempHeaders, 2048 );

    STACK_BUFFER( tempWSABUFs, 128 );

    AssertValid();

    // Loop through any headers counting up the length
    CHTTPHeader *pHeader = m_pData->m_pFirstHeader;
    while (pHeader) {
        cch += pHeader->CchLength();
        pHeader = pHeader->PNext();
    }

    // Add the content-type tag
    cch += sizeof(s_szContentTypeHeader)-1;
    cch += strlen(PContentType())+2;

    // Add the Character set tag
    if (m_pData->m_pszCharSet) {
        cch += sizeof(s_szCharSetHTML)-1;
        cch += strlen(m_pData->m_pszCharSet);
    }

    // Add the Expires tag
    if ((m_pData->m_tExpires != -1) || (m_pData->m_pszDefaultExpires != NULL))
        cch += DATE_STRING_SIZE + 11;   // DATE_STRING_SIZE + length("Expires: \r\n")

    // Add the cookies that we will send
    cch += m_pData->m_WriteCookies.QueryHeaderSize()+2;

    // Account for space required by headers we always send back.

    // Prepare cookie if any.
    if (m_pData->m_szCookieVal) {
        char *pchEnd = strcpyExA(szCookieBuff, "Set-Cookie: ");
        pchEnd = strcpyExA(pchEnd, g_szSessionIDCookieName);
        pchEnd = strcpyExA(pchEnd, "=");
        pchEnd = strcpyExA(pchEnd, m_pData->m_szCookieVal);

        // If we keep secure sessions secure, and this connection is secure,  add flag to cookie
        if ((m_pData->m_pHitObj->QueryAppConfig()->fKeepSessionIDSecure()) && 
            (m_pData->m_pHitObj->FSecure()))
        {
            pchEnd = strcpyExA(pchEnd,"; secure");
        }
        
        pchEnd = strcpyExA(pchEnd, "; path=/\r\n");
        cchCookieBuff = strlen(szCookieBuff);
        cch += cchCookieBuff;
        Assert(cchCookieBuff < CCH_STATIC_COOKIE_BUF);
    }
    else {
        szCookieBuff[0] = '\0';
        cchCookieBuff = 0;
    }

    // Will len of cache control header
    if (m_pData->m_pszCacheControl) {
        cch += sizeof(s_szCacheControl)-1;
        cch += strlen(m_pData->m_pszCacheControl)+2;
    }
    else {
        cch += sizeof(s_szCacheControlPrivate)-1;
    }

    // If using HTTP/1.1 and not buffering add length ofTransfer-Encoding headers
    if ((m_pData->m_dwVersionMinor >= 1) && (m_pData->m_dwVersionMajor >= 1) &&
        (m_pData->m_fBufferingOn == FALSE) &&
        !GetIReq()->IsChild()) { // don't chunk child request output

        // UNDONE: Temporary setting to turn off chuncked encoding
        if (Glob(fEnableChunkedEncoding))
            m_pData->m_fChunked = TRUE;
    }
    if (m_pData->m_fChunked)
        cch += sizeof(s_szTransferEncoding)-1;

    // Will terminate with \r\n.  Leave extra space
    cch += 2;

    /*
     * We know how big; allocate memory and build the string.
     */

    if (!tempHeaders.Resize(cch + 1)) {
        return E_OUTOFMEMORY;
    }
    szBuff = (LPSTR)tempHeaders.QueryPtr();
    *szBuff = '\0';

    char *szTmpBuf = szBuff;

    pHeader = m_pData->m_pFirstHeader;
    while (pHeader) {
        pHeader->Print(szTmpBuf);
        szTmpBuf += pHeader->CchLength();
        pHeader = pHeader->PNext();
    }

    // Send the content-type tag
    szTmpBuf = strcpyExA(szTmpBuf, s_szContentTypeHeader);
    szTmpBuf = strcpyExA(szTmpBuf, PContentType());

    // Send the CharSet tag if exists
    if (m_pData->m_pszCharSet) {
        szTmpBuf = strcpyExA(szTmpBuf, s_szCharSetHTML);
        szTmpBuf = strcpyExA(szTmpBuf, m_pData->m_pszCharSet);
    }

    szTmpBuf = strcpyExA(szTmpBuf, "\r\n");

    // Send the Expires tag
    if ((m_pData->m_tExpires != -1) || (m_pData->m_pszDefaultExpires != NULL)) {

        // if the script set an expires value, than use it
        if (m_pData->m_tExpires != -1) {
            szTmpBuf = strcpyExA(szTmpBuf, "Expires: ");
            if (FAILED(CTimeToStringGMT(&m_pData->m_tExpires, szTmpBuf)))
                return E_FAIL;
            szTmpBuf += strlen(szTmpBuf);
            szTmpBuf = strcpyExA(szTmpBuf, "\r\n");
        }
        // else, use the default value in the metabase.  Note that it already
        // includes the Expires: prefix and \r\n suffix
        else {

            szTmpBuf = strcpyExA(szTmpBuf, m_pData->m_pszDefaultExpires);
        }
    }

    // send the cookies
    m_pData->m_WriteCookies.GetHeaders(szTmpBuf);
    szTmpBuf += strlen(szTmpBuf);

    // Send the required headers: session id cookie and cache control
    szTmpBuf = strcpyExA(szTmpBuf, szCookieBuff);

    // Send the cache-control tag
    if (m_pData->m_pszCacheControl) {
        szTmpBuf = strcpyExA(szTmpBuf, s_szCacheControl);
        szTmpBuf = strcpyExA(szTmpBuf, m_pData->m_pszCacheControl);
        szTmpBuf = strcpyExA(szTmpBuf, "\r\n");
    }
    else {
        szTmpBuf = strcpyExA(szTmpBuf, s_szCacheControlPrivate);
    }

    // Chunked encoding
    if (m_pData->m_fChunked)
        szTmpBuf = strcpyExA(szTmpBuf, s_szTransferEncoding);

    // Add trailing \r\n to terminate headers
    szTmpBuf = strcpyExA(szTmpBuf, "\r\n");

    Assert(strlen(szBuff) <= cch);

    // Output the headers
    // Failure is not a fatal error, so we still return success
    // but set the m_fWriteClient flag
    CHAR *szStatus = m_pData->m_pszStatus ? m_pData->m_pszStatus
                                          : (CHAR *)s_szDefaultStatus;

    BOOL fKeepConnected =
        (m_pData->m_fBufferingOn && !m_pData->m_fFlushed) || m_pData->m_fChunked;

    BOOL fHeaderSent;
    DWORD cchStatus = strlen(szStatus) + 1;
    DWORD cchHeader = strlen(szBuff) + 1;

    if ( !fSendEntireResponse ) {
        fHeaderSent = GetIReq()->SendHeader
                            (
                            szStatus,
                            cchStatus,
                            szBuff,
                            cchHeader,
                            fKeepConnected
                            );
    }
    else {
        BOOL    fSendDebugBuffers = (m_pData->m_fClientDebugMode && m_pData->m_pClientDebugBuffer);

        // if we are sending both headers and body at once, we put
        // all of our content into an optimized struct which we pass
        // to an optimized api

        HSE_SEND_ENTIRE_RESPONSE_INFO   tempHseResponseInfo;
        HSE_SEND_ENTIRE_RESPONSE_INFO * pHseResponseInfo = &tempHseResponseInfo;

        // populate struct with header info
        pHseResponseInfo->HeaderInfo.pszStatus = szStatus;
        pHseResponseInfo->HeaderInfo.cchStatus = cchStatus;
        pHseResponseInfo->HeaderInfo.pszHeader = szBuff;
        pHseResponseInfo->HeaderInfo.cchHeader = cchHeader;
        pHseResponseInfo->HeaderInfo.fKeepConn = fKeepConnected;

        // populate struct with response body buffers (and, if required, debug buffers)
        //
        // NOTE: To send an entire response whose data (body)
        // is contained in N buffers, caller must allocate N+1 buffers
        // and fill buffers 1 through N with its data buffers.
        // IIS will fill the extra buffer (buffer 0) with header info.
        //
        CResponseBuffer * pResponseBuffer = m_pData->m_pResponseBuffer;
        CResponseBuffer * pClientDebugBuffer = (fSendDebugBuffers
                                               ? m_pData->m_pClientDebugBuffer
                                               : NULL);

        DWORD   cResponseBuffers = pResponseBuffer->CountOfBuffers();
        DWORD   cClientDebugBuffers = ( fSendDebugBuffers
                                        ? pClientDebugBuffer->CountOfBuffers()
                                        : 0);
        Assert(cResponseBuffers);

        pHseResponseInfo->cWsaBuf = 1 + cResponseBuffers + cClientDebugBuffers;

        if (!tempWSABUFs.Resize(pHseResponseInfo->cWsaBuf * sizeof(WSABUF))) {
            return E_OUTOFMEMORY;
        }

        pHseResponseInfo->rgWsaBuf = static_cast<WSABUF *>(tempWSABUFs.QueryPtr());

        //  zero-out the empty array slot - allows IIS to assert that it is "available"
        pHseResponseInfo->rgWsaBuf[0].len = 0;
        pHseResponseInfo->rgWsaBuf[0].buf = NULL;

        UINT i;
        // fill buffers 1 through N with our buffers 0 through N-1 (see NOTE above)
        // buffers 1 through N will be debug buffers, if required, followed by response body buffers
        for ( i = 0; i < cClientDebugBuffers; i++ ) {
            pHseResponseInfo->rgWsaBuf[i+1].len = pClientDebugBuffer->GetBufferSize(i);
            pHseResponseInfo->rgWsaBuf[i+1].buf = pClientDebugBuffer->GetBuffer(i);
        }

        for ( i = 0; i < cResponseBuffers; i++ ) {
            pHseResponseInfo->rgWsaBuf[i + 1 + cClientDebugBuffers].len = pResponseBuffer->GetBufferSize(i);
            pHseResponseInfo->rgWsaBuf[i + 1 + cClientDebugBuffers].buf = pResponseBuffer->GetBuffer(i);
        }

        // send entire response (headers and body) at once
        if( g_fOOP ) {
            fHeaderSent = GetIReq()->SendEntireResponseOop(pHseResponseInfo);
        }
        else {
            fHeaderSent = GetIReq()->SendEntireResponse(pHseResponseInfo);
        }
    }

    if (!fHeaderSent) {
        m_pData->m_fWriteClientError = TRUE;
    }
    else {
        m_pData->m_fHeadersWritten = TRUE;
        //PERF ADD-ON
        AddtoTotalByteOut(cch);
    }

    return(hr);
    }


/*===================================================================
CResponse::Write

Writes a string to the client.

It accepts a variant as an argument and attempts to coerce that
variant into a BSTR. We convert that BSTR into an ANSI string,
and then hand that ANSI string to Response::WriteSz which sends
it back to the client.

Normally a VT_NULL variant cannot be coerced to a BSTR, but we want
VT_NULL to be a valid input, therefore we explictly handle the case of
variants of type VT_NULL. If the type of the input variant is VT_NULL
we return S_OK, but don't send anything back to the client.

If we are handed a VT_DISPATCH variant, we resolve it by repeatedly calling
Dispatch on the associated pdispVal, until we get back a variant that is not
a VT_DISPATCH. VariantChangeType would ordinarily handle this for us, but the
final resulting variant might be a VT_NULL which VariantChangeType would not
coerce into a BSTR. This is why we have to handle walking down the VT_DISPATC
variants outselves.

Parameters:
    VARIANT     varInput, value: the variant to be converted to string
                                  and written to the client

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/
STDMETHODIMP CResponse::Write(VARIANT varInput)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    DWORD cch;
    LPSTR szT;
    BSTR  bstr;
    VARIANT varResolved;

    static char szTrue[MAX_MESSAGE_LENGTH];
    static char szFalse[MAX_MESSAGE_LENGTH];

    AssertValid();

    // If we've already had an error writing to the client
    // there is no point in proceding, so we immediately return
    // with no error
    if (FDontWrite())
        goto lRet2;

    // If already BSTR (directly or as VARIANT by ref)
    bstr = VariantGetBSTR(&varInput);
    if (bstr != NULL)
        {
        hr = WriteBSTR(bstr);
        goto lRet2;
        }

    // If the variant passed in is a VT_DISPATCH, get its default property
    if (FAILED(hr = VariantResolveDispatch(&varResolved, &varInput, IID_IResponse, IDE_RESPONSE)))
        goto lRet2;

    // Check if the variant in is VT_NULL
    if (V_VT(&varResolved) == VT_NULL)
        goto lRet;                  // S_OK, but don't send anything to the client

    // Check if the variant in is VT_BOOL
    if(V_VT(&varResolved) == VT_BOOL)
        {
        if (V_BOOL(&varResolved) == VARIANT_TRUE)
            {
            if (szTrue[0] == '\0')
                cch = CchLoadStringOfId(IDS_TRUE, szTrue, MAX_MESSAGE_LENGTH);
            szT = szTrue;
            }
        else
            {
            if(szFalse[0] == '\0')
                cch = CchLoadStringOfId(IDS_FALSE, szFalse, MAX_MESSAGE_LENGTH);
            szT = szFalse;
            }
        cch = strlen(szT);
        if (FAILED(hr = WriteSz(szT, cch)))
            {
            if (E_OUTOFMEMORY == hr)
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
            else
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
            }
        goto lRet;
        }

    // Coerce the variant into a bstr if necessary
    if (V_VT(&varResolved) != VT_BSTR)
        {
        if (FAILED(hr = VariantChangeTypeEx(&varResolved, &varResolved, m_pData->m_pHitObj->GetLCID(), 0, VT_BSTR)))
            {
            switch (GetScode(hr))
                {
                case E_OUTOFMEMORY:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
                    break;
                case DISP_E_OVERFLOW:
                    hr = E_FAIL;
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_UNABLE_TO_CONVERT);
                    break;
                case DISP_E_TYPEMISMATCH:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_TYPE_MISMATCH);
                    break;
                default:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
                }
            goto lRet;
            }
        }

    hr = WriteBSTR(V_BSTR(&varResolved));

lRet:
#ifdef DBG
    hr =
#endif // DBG
    VariantClear(&varResolved);
    Assert(SUCCEEDED(hr));
lRet2:
    return(hr);
    }

/*===================================================================
CResponse::BinaryWrite

Function called from DispInvoke to invoke the BinaryWrite method.

Parameters:
    varInput    Variant which must resolve to an array of unsigned bytes

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/
STDMETHODIMP CResponse::BinaryWrite(VARIANT varInput)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    DWORD nDim = 0;
    long lLBound = 0;
    long lUBound = 0;
    void *lpData = NULL;
    DWORD cch = 0;
    VARIANT varResolved;
    SAFEARRAY* pvarBuffer;

    AssertValid();

    // If we've already had an error writing to the client
    // there is no point in proceding, so we immediately return
    // with no error
    if (FDontWrite())
        goto lRet2;

    // De-reference and de-dispatch the variant
    if (FAILED(hr = VariantResolveDispatch(&varResolved, &varInput, IID_IResponse, IDE_RESPONSE)))
        goto lRet2;

    // Coerce the result into an array of VT_UI1 if needed
    if (V_VT(&varResolved) != (VT_ARRAY|VT_UI1))
        {
        if (FAILED(hr = VariantChangeType(&varResolved, &varResolved, 0, VT_ARRAY|VT_UI1)))
            {
            switch (GetScode(hr))
                {
                case E_OUTOFMEMORY:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
                    break;
                case DISP_E_OVERFLOW:
                    hr = E_FAIL;
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_UNABLE_TO_CONVERT);
                    break;
                case DISP_E_TYPEMISMATCH:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_TYPE_MISMATCH);
                    break;
                default:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
                }
            goto lRet;
            }
        }

    // We got here, so we must have a variant containing a safe array of UI1 in varResolved
    pvarBuffer = V_ARRAY(&varResolved);

    nDim = SafeArrayGetDim(pvarBuffer);
    if (nDim != 1)
        {
        hr = E_INVALIDARG;
        goto lRet;
        }

    if (FAILED(SafeArrayGetLBound(pvarBuffer, 1, &lLBound)))
        {
        hr = E_INVALIDARG;
        goto lRet;
        }

    if (FAILED(SafeArrayGetUBound(pvarBuffer, 1, &lUBound)))
        {
        hr = E_INVALIDARG;
        goto lRet;
        }

    if (FAILED(SafeArrayAccessData(pvarBuffer, &lpData)))
        {
        hr = E_INVALIDARG;
        goto lRet;
        }
    cch = lUBound - lLBound + 1;

    if (m_pData->m_fBufferingOn)
        {
        // Buffering is on
        if (FAILED(hr = m_pData->m_pResponseBuffer->Write((char *) lpData, cch)))
            {
            // We can't buffer the ouput, so quit
            SafeArrayUnaccessData(pvarBuffer);
            if (E_OUTOFMEMORY == hr)
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
            else
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
            goto lRet;
            }
        }
    else
        {
        // Buffering is off
        // If this is the first write response, then output the headers first
        if (!FHeadersWritten())  // bug 512: write hdrs even if global.asa
            {
            if (FAILED(hr = WriteHeaders()))
                {
                if (E_OUTOFMEMORY == hr)
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
                else
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
                }
            }

        // If this is not a head request we transmit the string to the clienet
        if (SUCCEEDED(hr) && !IsHeadRequest() && !FDontWrite())
            WriteClient((BYTE *) lpData, cch);
        }

    hr = SafeArrayUnaccessData(pvarBuffer);

lRet:
    VariantClear(&varResolved);
lRet2:
    return(hr);
    }

/*===================================================================
CResponse::WriteSz

Support routine for the Write method to write the string.  Unlike
CResponse::Write(), this routine takes an Ascii string, and is
not intended to be exposed as a method

Parameters:
    sz - String to write as an Ascii string
    cch - Length of string to write

Returns:
    S_OK on success.

===================================================================*/
HRESULT CResponse::WriteSz(CHAR *sz, DWORD cch)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    AssertValid();

    // If we've already had an error writing to the client
    // there is no point in proceding, so we immediately return
    // with no error
    if (FDontWrite())
        goto lRet;

    if (m_pData->m_fBufferingOn)
        {
        // Buffering is on
        hr = m_pData->m_pResponseBuffer->Write(sz, cch);
        }
    else
        {
        // Buffering is off
        if (!FHeadersWritten())  // bug 512: write hdrs even if global.asa
            {
            // This is the first response, then output the headers first
            if (FAILED(hr = WriteHeaders()))
                goto lRet;
            }

        // If this is not a head request we transmit the string to the client
        if (!IsHeadRequest() && !FDontWrite())
            WriteClient((BYTE *) sz, cch);
        }

lRet:
    return(hr);
    }

/*===================================================================
CResponse::WriteBSTR

Support routine for the Write method

Parameters:
    BSTR - String to write as an Ascii string

Returns:
    S_OK on success.
===================================================================*/
HRESULT CResponse::WriteBSTR(BSTR bstr)
    {
    CWCharToMBCS  convStr;
    HRESULT       hr = NO_ERROR;

    if (FAILED(hr = convStr.Init(bstr, m_pData->m_pHitObj->GetCodePage())));


    else hr = WriteSz(convStr.GetString(), convStr.GetStringLen());

    if (FAILED(hr))
        {
        if (E_OUTOFMEMORY == hr)
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        else
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
        }

    return hr;
    }

/*===================================================================
CResponse::WriteBlock

Function called from DispInvoke to invoke the WriteBlock method.

Parameters:
    Identifier for the HTML block

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/
HRESULT CResponse::WriteBlock(short iBlockNumber)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    char*   pbHTML = NULL;
    ULONG   cbHTML = 0;
    ULONG   cbSrcOffset = 0;
    char*   pbIncSrcFileName = NULL;

    AssertValid();

    // If we've already had an error writing to the client
    // there is no point in proceding, so we immediately return
    // with no error
    if (FDontWrite())
        goto lRet;

    // bail out (and assert) if template is null
    Assert(m_pData->m_pTemplate != NULL);
    if (m_pData->m_pTemplate == NULL)
        {
        hr = E_FAIL;
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
        goto lRet;
        }

    /*
        get ptr and byte count for html block from template
        NOTE: by design, this public template call cannot fail because we give it a block id
        generated during template compilation (instead we assert within and after the call)

        I added the return HRESULT to catch for invalid user access of this method, if a user
        attempts to access this method and passes an invalid array offset it will return the
        error IDE_BAD_ARRAY_INDEX, this really should not happen except for the case of a user
        attempting to access this hidden method.
    */


    hr = m_pData->m_pTemplate->GetHTMLBlock(iBlockNumber, &pbHTML, &cbHTML, &cbSrcOffset, &pbIncSrcFileName);
    if ( hr != S_OK )
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_BAD_ARRAY_INDEX);
        goto lRet;
        }

    Assert(pbHTML);
    Assert(cbHTML > 0);

    if (m_pData->m_fBufferingOn)
        {
        hr = S_OK;

        // Take care of Client Debugger issues
        if (m_pData->m_fClientDebugMode && m_pData->m_pClientDebugBuffer)
            {
            if (cbSrcOffset) // only if source info is known
                {
                // Write a METADATA line corresponding to this block
                // into ClientDebugBuffer
                ULONG cbPos = m_pData->m_pResponseBuffer->BytesBuffered() + 1;
                ULONG cbLen = cbHTML;

                hr  = m_pData->m_pClientDebugBuffer->AppendRecord(
                    cbPos, cbLen, cbSrcOffset, pbIncSrcFileName);
                }
            }

        // Write the actual data
        if (SUCCEEDED(hr))
            hr = m_pData->m_pResponseBuffer->Write(pbHTML, cbHTML);

        // Buffering is on
        if (FAILED(hr))
            {
            if (E_OUTOFMEMORY == hr)
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
            else
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
            }
        }
    else
        {
        // Buffering is off
        if (!FHeadersWritten())  // bug 512: write hdrs even if global.asa
            {
            // This is the first response.write, so output the headers
            if (FAILED(hr = WriteHeaders()))
                {
                if (E_OUTOFMEMORY == hr)
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
                else
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
                goto lRet;
                }
            }

        // If this is not a head request we transmit the string to the clienet
        if (!IsHeadRequest() && !FDontWrite())
            {
                WriteClient((BYTE * ) pbHTML, cbHTML);
            }
        }

lRet:
    return(hr);
    }

/*===================================================================
CResponse::GetClientVersion

Uses GetServerVariable to determine the HTTP version of the client.
Borrowed from simiarl code in w3 server Httpreq.cxx, OnVersion()

Parameters:

    None

Returns:
    None
===================================================================*/
VOID CResponse::GetClientVerison()
    {
    if (FAILED(CheckForTombstone()))
        return;

    if (m_pData->m_pIReq)
        {
        m_pData->m_dwVersionMajor = (BYTE)m_pData->m_pIReq->QueryHttpVersionMajor();
        m_pData->m_dwVersionMinor = (BYTE)m_pData->m_pIReq->QueryHttpVersionMinor();
        }
    else
        {
        // Assume version 0.9
        m_pData->m_dwVersionMajor = 0;
        m_pData->m_dwVersionMinor = 9;
        }
    }

/*===================================================================
CResponse::WriteClient

Wrapper for the ISAPI WriteClient method. Use for non-buffered responses
by the WriteSz, BinaryWrite, and WriteBlock methods.

Parameters:

    sz - pointer to buffer to write
    cch - Length of buffer

Returns:
    HRESULT     S_OK if ok
===================================================================*/
HRESULT CResponse::WriteClient(BYTE *pb, DWORD cb)
    {
    HRESULT hr = S_OK;

    if (m_pData->m_fChunked)
        return WriteClientChunked(pb, cb);

    if (FAILED(CResponse::SyncWrite(GetIReq(), (char *)pb, cb)))
        m_pData->m_fWriteClientError = TRUE;

    return hr;
    }

/*===================================================================
CResponse::WriteClientChunked

Wrapper for the ISAPI WriteClient method using chunk transfer encoding.
Use for non-buffered responses by the WriteSz, BinaryWrite, and WriteBlock
methods if using HTTP 1.1

Each chunk is prefaced with the size of the chunk and terminated with a CRLF

Parameters:
    sz - pointer to buffer to write
    cch - Length of buffer

Returns:
    HRESULT     S_OK if ok
===================================================================*/
HRESULT CResponse::WriteClientChunked(BYTE *pb, DWORD cb)
    {
    HRESULT hr = S_OK;

    if (cb == 0)
        return hr;

    char *pchBuf = NULL;
    const int cchMaxChunkOverhead = 16;

    if (cb + cchMaxChunkOverhead < ALLOCA_LIMIT) {
        TRY
            pchBuf = (char *)_alloca(cb + cchMaxChunkOverhead);
        CATCH(hrException)
            // if exception occurred, just make sure that pchBuf is NULL and
            // let the routine continue
            pchBuf = NULL;
        END_TRY
    }

    if (pchBuf)
        {
        // fill in new buffer and do one single send
        char *pch = pchBuf;

        // chunk length
        _itoa(cb, pch, 16);
        pch += strlen(pch);

        // CR LF
        *pch++ = '\r';
        *pch++ = '\n';

        // buffer
        memcpy(pch, pb, cb);
        pch += cb;

        // CR LF
        *pch++ = '\r';
        *pch++ = '\n';

        *pch = '\0';

        // Send
        if (FAILED(CResponse::SyncWrite(GetIReq(), pchBuf, DIFF(pch-pchBuf))))
            m_pData->m_fWriteClientError = TRUE;
        }
    else
        {
        // do multiple sends

        char szLen[12];
        _itoa(cb, szLen, 16);
        DWORD cchLen = strlen(szLen);
        szLen[cchLen++] = '\r';
        szLen[cchLen++] = '\n';
        szLen[cchLen] = '\0';

        // send length
        if (FAILED(CResponse::SyncWrite(GetIReq(), szLen, cchLen)))
            m_pData->m_fWriteClientError = TRUE;

        // send buffer
        else if (FAILED(CResponse::SyncWrite(GetIReq(), (char *)pb, cb)))
            m_pData->m_fWriteClientError = TRUE;

        // send trailing CR LF
        else if (FAILED(CResponse::SyncWrite(GetIReq(), "\r\n", 2)))
            m_pData->m_fWriteClientError = TRUE;
        }

    return hr;
    }

/*===================================================================
CResponse::AppendHeader

Functions to add headers of different kind
(hardcoded and user-supplied)

Parameters:
    Name, Value

Returns:
    HRESULT         S_OK if ok

===================================================================*/
HRESULT CResponse::AppendHeader(BSTR wszName, BSTR wszValue)
    {
    CHTTPHeader *pHeader = new CHTTPHeader;
    if (!pHeader)
        return E_OUTOFMEMORY;
    if (FAILED(pHeader->InitHeader(wszName, wszValue,m_pData->m_pHitObj->GetCodePage())))
        {
        delete pHeader;
        return E_FAIL;
        }
    m_pData->AppendHeaderToList(pHeader);
    return S_OK;
    }

HRESULT CResponse::AppendHeader(char *szName, BSTR wszValue)
    {
    CHTTPHeader *pHeader = new CHTTPHeader;
    if (!pHeader)
        return E_OUTOFMEMORY;
    if (FAILED(pHeader->InitHeader(szName, wszValue,m_pData->m_pHitObj->GetCodePage())))
        {
        delete pHeader;
        return E_FAIL;
        }
    m_pData->AppendHeaderToList(pHeader);
    return S_OK;
    }

HRESULT CResponse::AppendHeader(char *szName, char *szValue, BOOL fCopyValue)
    {
    CHTTPHeader *pHeader = new CHTTPHeader;
    if (!pHeader)
        return E_OUTOFMEMORY;
    if (FAILED(pHeader->InitHeader(szName, szValue, fCopyValue)))
        {
        delete pHeader;
        return E_FAIL;
        }
    m_pData->AppendHeaderToList(pHeader);
    return S_OK;
    }

HRESULT CResponse::AppendHeader(char *szName, long lValue)
    {
    CHTTPHeader *pHeader = new CHTTPHeader;
    if (!pHeader)
        return E_OUTOFMEMORY;
    if (FAILED(pHeader->InitHeader(szName, lValue)))
        {
        delete pHeader;
        return E_FAIL;
        }
    m_pData->AppendHeaderToList(pHeader);
    return S_OK;
    }

/*===================================================================
CResponse::get_ContentType

Functions called from DispInvoke to return the ContentType property.

Parameters:
    pbstrContentTypeRet     BSTR FAR *, return value: pointer to the ContentType as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_ContentType
(
BSTR FAR * pbstrContentTypeRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    hr = SysAllocStringFromSz((char *)PContentType(), 0, pbstrContentTypeRet);
    if (FAILED(hr))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_FAIL;
        }
    return(hr);
    }

/*===================================================================
CResponse::put_ContentType

Functions called from DispInvoke to set the ContentType property.

Parameters:
    bstrContentType     BSTR, value: the ContentType as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_ContentType
(
BSTR bstrContentType
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT       hr = S_OK;
    CWCharToMBCS  convStr;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    if (m_pData->m_pszContentType) {
        free(m_pData->m_pszContentType);
        m_pData->m_pszContentType = NULL;
    }

    if (FAILED(hr = convStr.Init(bstrContentType)));

    else if ((m_pData->m_pszContentType = convStr.GetString(TRUE)) == NULL) {
        hr = E_OUTOFMEMORY;
    }

lRet:
    if (hr == E_OUTOFMEMORY) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
    }
    return(hr);
    }


/*===================================================================
CResponse::get_Status

Function called from DispInvoke to return the Status property.

Parameters:
    pbstrStatusRet      BSTR FAR *, return value: pointer to the Status as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_Status
(
BSTR FAR * pbstrStatusRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    if (m_pData->m_pszStatus)
        hr = SysAllocStringFromSz(m_pData->m_pszStatus, 0, pbstrStatusRet);
    else
        hr = SysAllocStringFromSz((CHAR *)s_szDefaultStatus, 0, pbstrStatusRet);
    if (FAILED(hr))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_FAIL;
        }
    return(hr);
    }

/*===================================================================
CResponse::put_Status

Function called from DispInvoke to set the ContentType property.

Parameters:
    bstrStatus      BSTR, value: the status as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_Status
(
BSTR bstrStatus
)
    {
    DWORD dwStatus = 200;

    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT      hr = S_OK;
    CWCharToMBCS convStr;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    if (m_pData->m_pszStatus) {
        free(m_pData->m_pszStatus);
        m_pData->m_pszStatus = NULL;
    }

    if (FAILED(hr = convStr.Init(bstrStatus)));

    else if ((m_pData->m_pszStatus = convStr.GetString(TRUE)) == NULL) {
        hr = E_OUTOFMEMORY;
    }
    else {
        dwStatus = atol(m_pData->m_pszStatus);
        GetIReq()->SetDwHttpStatusCode(dwStatus);
    }

lRet:
    if (hr == E_OUTOFMEMORY) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
    }
    return(hr);
    }

/*===================================================================
CResponse::get_Expires

Function called from DispInvoke to return the Expires property.

Parameters:
    plExpiresTimeRet        long *, return value: pointer to number of minutes until response expires

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_Expires
(
VARIANT * pvarExpiresTimeRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    // return early if we can
    //
    if (m_pData->m_tExpires == -1)
        {
        V_VT(pvarExpiresTimeRet) = VT_NULL;
        return S_OK;
        }

    // get the current time
    //
    time_t tNow;
    time(&tNow);

    // get the time difference and round to the nearest minute
    //
    V_VT(pvarExpiresTimeRet) = VT_I4;
    V_I4(pvarExpiresTimeRet) = long((difftime(m_pData->m_tExpires, tNow) / 60) + 0.5);
    return S_OK;
    }

/*===================================================================
CResponse::put_Expires

Functions called from DispInvoke to set the expires property.

Parameters:
    iValue      int, value: the number of minutes until response should expire

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_Expires
(
long lExpiresMinutes
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    // get the current time
    //
    time_t tNow;
    time(&tNow);
    time_t tRelativeTime;
    // add the number of minuites.  (must convert to seconds first)
    //
    tRelativeTime = lExpiresMinutes * 60;
    if ((lExpiresMinutes < 0 && tRelativeTime > 0)
        || (lExpiresMinutes > 0 && tRelativeTime < 0))
        {
        // overflow, tRelativeTime could be a small positive integer if lExpiresMinutes is
        // some value like 0x80000010
        // tNow will be overflowed if tRelativeTime is negative
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_COOKIE_BAD_EXPIRATION);
        return E_FAIL;
        }

    tNow += tRelativeTime;

    // Store the date if
    //      a. No date was stored previously
    //      b. This date comes before the previously set date.
    //
    if (m_pData->m_tExpires == -1 || tNow < m_pData->m_tExpires)
        {
        struct tm *ptmGMT = gmtime(&tNow);
        if (ptmGMT == NULL)
            {
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_COOKIE_BAD_EXPIRATION);
            return E_FAIL;
            }

        m_pData->m_tExpires = tNow;
        }
        // convert time to GMT
    return S_OK;
    }

/*===================================================================
CResponse::get_ExpiresAbsolute

Function called from DispInvoke to return the ExpiresAbsolute property.

Parameters:
    pbstrTimeRet    BSTR *, return value: pointer to string that will contain
                    the time response should expire

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_ExpiresAbsolute
(
VARIANT *pvarTimeRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    V_VT(pvarTimeRet) = VT_DATE;
    CTimeToVariantDate(&m_pData->m_tExpires, &V_DATE(pvarTimeRet));
    return S_OK;
    }

/*===================================================================
CResponse::put_ExpiresAbsolute

Function called from DispInvoke to set the ExpiresAbsolute property.

Parameters:
    pbstrTime       BSTR, value: time response should expire

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_ExpiresAbsolute
(
DATE dtExpires
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    if (int(dtExpires) == 0)                    // time specified but no date (assume today)
        {
        time_t tToday;                                          // get the date and time now
        DATE dtToday;

        time(&tToday);
        struct tm *tmToday = localtime(&tToday);

        tmToday->tm_hour = tmToday->tm_min = tmToday->tm_sec = 0;       // reset to midnight
        tToday = mktime(tmToday);

        if (FAILED(CTimeToVariantDate(&tToday, &dtToday)))
            return E_FAIL;

        dtExpires += dtToday;
        }

    time_t tExpires;
    if (FAILED(VariantDateToCTime(dtExpires, &tExpires)))
        {
        ExceptionId(IID_IWriteCookie, IDE_RESPONSE, IDE_COOKIE_BAD_EXPIRATION);
        return E_FAIL;
        }

    if (m_pData->m_tExpires == -1 || tExpires < m_pData->m_tExpires)
        {
        m_pData->m_tExpires = tExpires;
        }

    return S_OK;
    }

/*===================================================================
CResponse::put_Buffer

Function called from DispInvoke to set the Buffer property.

Parameters:
    fIsBuffering        VARIANT_BOOL, if true turn on buffering of HTML output

Returns:
    HRESULT     S_OK if ok

Side Effects:
    Turning buffering on will cause memory to be allocated.
===================================================================*/
STDMETHODIMP CResponse::put_Buffer
(
VARIANT_BOOL fIsBuffering
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    // Assume TRUE if not 0
    if (fIsBuffering != VARIANT_FALSE)
        fIsBuffering = VARIANT_TRUE;

    // Ignore no change requests
    if ((fIsBuffering == VARIANT_TRUE) && m_pData->m_fBufferingOn)
        return S_OK;
    if ((fIsBuffering == VARIANT_FALSE) && !m_pData->m_fBufferingOn)
        return S_OK;

    // Ignore if change is not allowed to change (Client Dedug)
    if (m_pData->m_fClientDebugMode)
        return S_OK;

    // Set the new value (error if cannot change)

    if (fIsBuffering == VARIANT_TRUE)
        {
        if (FHeadersWritten())
            {
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
            return E_FAIL;
            }

        m_pData->m_fBufferingOn = TRUE;
        }
    else // if (fIsBuffering == VARIANT_FALSE)
        {
        if ((m_pData->m_pResponseBuffer->BytesBuffered() > 0) ||
            FHeadersWritten())
            {
            // If we already buffered some output it is too late to go back
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_CANT_STOP_BUFFER);
            return E_FAIL;
            }

        m_pData->m_fBufferingOn = FALSE;
        }

    return S_OK;
    }

/*===================================================================
CResponse::get_Buffer

Function called from DispInvoke to get the Buffer property.

Parameters:
    fIsBuffering        VARIANT_BOOL, value: if true turn buffering of HTML output
                        is turned on

Returns:
    HRESULT         S_OK if ok

Side Effects:
    None

===================================================================*/
STDMETHODIMP CResponse::get_Buffer
(
VARIANT_BOOL *fIsBuffering
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    if (m_pData->m_fBufferingOn)
        *fIsBuffering = VARIANT_TRUE;
    else
        *fIsBuffering = VARIANT_FALSE;

    return(hr);
    }

/*===================================================================
CResponse::Redirect

Function called from DispInvoke to invoke the Redirect method.

Parameters:
    bstrURL Unicode BSTR    Value: URL to rediect to

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/
STDMETHODIMP CResponse::Redirect(BSTR bstrURL)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    AssertValid();

    HRESULT hr = S_OK;
    DWORD cch = 0;
    DWORD cchURL = 0;
    DWORD cchMessage = 0;
    char *szURL = NULL;
    char *szMessage = NULL;
    DWORD  cchEncodedURL;
    char *pszEncodedURL = NULL;
    char *pszURL = NULL;
    CWCharToMBCS  convURL;

    STACK_BUFFER( tempURL, 256 );
    STACK_BUFFER( tempMessage, 256 + 512 );


    // Insist that we have a non-zero length URL
    if (bstrURL)
        cchURL = wcslen(bstrURL);

    if (cchURL == 0)
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_NO_URL);
        hr =  E_FAIL;
        goto lRet;
        }

    // Check that we haven't already passed data back to the client
    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    // If buffering is on, clear any pending output
    if (m_pData->m_fBufferingOn)
        Clear();

        // turn buffering on for this response.
        m_pData->m_fBufferingOn = TRUE;

    // BUGBUG - should this be 65001?

    if (FAILED(hr = convURL.Init(bstrURL, m_pData->m_pHitObj->GetCodePage()))) {
        if (hr == E_OUTOFMEMORY)
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        goto lRet;
    }

    pszURL = convURL.GetString();

    cchEncodedURL = URLPathEncodeLen(pszURL);

    if (!tempURL.Resize(cchEncodedURL)) {
        hr = E_OUTOFMEMORY;
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        goto lRet;
    }

    pszEncodedURL = (CHAR *)tempURL.QueryPtr();

    URLPathEncode(pszEncodedURL, pszURL);

    // We need to alloccate memory to build the body redirection message.
    // If our memory requirement is small we allocate memory from the stack,
    // otherwise we allocate from the heap.
    cchMessage = strlen(pszEncodedURL);
    cchMessage += 512; // Allow space for sub-strings coming from resource file.

    if (!tempMessage.Resize(cchMessage)) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_OUTOFMEMORY;
        goto lRet;
    }

    szMessage = (char *)tempMessage.QueryPtr();

    // Build the body redirection message
    // Redirect(URL), URL must be a valid URL, that is, no DBCS string.
    cch = CchLoadStringOfId(IDE_RESPONSE_REDIRECT1, szMessage, cchMessage);
    strcpy(szMessage + cch, pszEncodedURL);
    cch += strlen(pszEncodedURL);
    cch += CchLoadStringOfId(IDE_RESPONSE_REDIRECT2, szMessage + cch, cchMessage - cch);

    // Set the status to redirect
    put_Status(L"302 Object moved");

    // Add the location header
    AppendHeader("Location", pszEncodedURL, TRUE);

    // Transmit redirect text to the client, headers will be
    // sent automatically
    if (FAILED(WriteSz(szMessage, cch)))
        {
        hr = E_FAIL;
        goto lRet;
        }

    // No further processing of the script
    End();

lRet:

    return(hr);
    }

/*===================================================================
CResponse::Add

Functions called from DispInvoke to Add a header.

This is a compatibility for the ISBU controls.

Parameters:
    bstrHeaderValue     Unicode BSTR, value: the value of header
    bstrHeaderName      Unicode BSTR, value: the name of the header

  Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::Add
(
BSTR bstrHeaderValue,
BSTR bstrHeaderName
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return AddHeader(bstrHeaderName, bstrHeaderValue);
    }

/*===================================================================
CResponse::AddHeader

Functions called from DispInvoke to Add a header.

Parameters:
    bstrHeaderName      Unicode BSTR, value: the name of the header
    bstrHeaderValue     Unicode BSTR, value: the value of header

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::AddHeader
(
BSTR bstrHeaderName,
BSTR bstrHeaderValue
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    AssertValid();

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    if (bstrHeaderName == NULL || wcslen(bstrHeaderName) == 0)
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    if (FAILED(AppendHeader(bstrHeaderName, bstrHeaderValue)))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
        }

    return S_OK;
    }

/*===================================================================
CResponse::Clear

Erases all output waiting in buffer.

Parameters
    None

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::Clear()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    if (m_pData->m_fClientDebugMode && m_pData->m_fClientDebugFlushIgnored)
        {
        // Clear after flush in ClientDebugMode is an error
        hr = E_FAIL;
        ExceptionId(IID_IResponse, IDE_RESPONSE,
                    IDE_RESPONSE_CLEAR_AFTER_FLUSH_IN_DEBUG);
        }
    else if (!m_pData->m_fBufferingOn)
        {
        hr = E_FAIL;
        ExceptionId(IID_IResponse, IDE_RESPONSE,
                    IDE_RESPONSE_BUFFER_NOT_ON);
        }
    else
        {
        AssertValid();
        hr = m_pData->m_pResponseBuffer->Clear();

        if (SUCCEEDED(hr))
            {
            if (m_pData->m_fClientDebugMode && m_pData->m_pClientDebugBuffer)
                hr = m_pData->m_pClientDebugBuffer->ClearAndStart();
            }

        if (FAILED(hr))
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
        }
    return(hr);
    }

/*===================================================================
CResponse::Flush

Sends out all HTML waiting in the buffer.

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::Flush()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    AssertValid();

    if (!m_pData->m_fBufferingOn)
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_BUFFER_NOT_ON);
        hr = E_FAIL;
        goto lRet;
        }

    // Ignore Response.Flush() in Client Debug Mode
    if (m_pData->m_fClientDebugMode)
        {
        m_pData->m_fClientDebugFlushIgnored = TRUE;
        goto lRet;
        }

    // We mark this response as having had flush called so
    // that we won't try to do keep-alive
    m_pData->m_fFlushed = TRUE;

    if (!FHeadersWritten())  // bug 512: write hdrs even if global.asa
        {
        if (FAILED(WriteHeaders()))
            {
            if (E_OUTOFMEMORY == hr)
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
            else
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
            goto lRet;
            }
        }

    if (FAILED(hr = m_pData->m_pResponseBuffer->Flush(GetIReq())))
        {
        if (E_OUTOFMEMORY == hr)
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        else
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
        }
lRet:
    return(hr);
    }

/*===================================================================
CResponse::FinalFlush

FinalFlush is called if a script terminates without having yet sent
the response headers. This means we can use the Content-Length and
Connection: Keep-Alive headers to increase efficiency. We add those headers,
then send all headers, and all waiting output.

Returns:
    HRESULT         S_OK if ok

===================================================================*/
HRESULT CResponse::FinalFlush(HRESULT hr_Status)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    DWORD dwRequestStatus = (FAILED(hr_Status) ? HSE_STATUS_ERROR : HSE_STATUS_SUCCESS);
    BOOL fWriteBodyWithHeaders = FALSE;   // append body to headers?
    AssertValid();

    // If the headers have not yet been sent, send them now
    if (!FHeadersWritten() && !FDontWrite())
        {
        DWORD dwLength = m_pData->m_fBufferingOn ? m_pData->m_pResponseBuffer->BytesBuffered() : 0;

        // If there was an error and and nothing is buffered,
        // send "server error" instead of an empty 200 OK response
        if (FAILED(hr_Status) && dwLength == 0)
            {
            Handle500Error(IDE_500_SERVER_ERROR, GetIReq());
            goto lRet;
            }

        // If buffering, add the Content: Keep-Alive, and Content-Length headers
        if (m_pData->m_fBufferingOn)
            {

            // If client is less then HTTP 1.1 add Keep-Alive header
            if (!(m_pData->m_dwVersionMinor >= 1 && m_pData->m_dwVersionMajor >=1))
                {
                AppendHeader("Connection", "Keep-Alive");
                }

            if (m_pData->m_fClientDebugMode && m_pData->m_pClientDebugBuffer)
                {
                // end the buffer with end of METADATA
                m_pData->m_pClientDebugBuffer->End();
                dwLength += m_pData->m_pClientDebugBuffer->BytesBuffered();
                }

            AppendHeader("Content-Length", (LONG)dwLength);
            dwRequestStatus = HSE_STATUS_SUCCESS_AND_KEEP_CONN;

            // if
            //      buffering is on,
            //      we are in-proc,
            //      headers are not yet written, and
            //      there is body
            // then we can optimize by sending both headers and body at once
            //
            if (!IsHeadRequest() && dwLength)
                {
                fWriteBodyWithHeaders = TRUE;
                }
            }

        // If buffering, tell WriteHeaders to append response body
        if (FAILED(hr = WriteHeaders(fWriteBodyWithHeaders)))
            {
            dwRequestStatus = HSE_STATUS_ERROR;
            goto lRet;
            }
        }

    // if we sent body with headers, we are done
    if (fWriteBodyWithHeaders)
        {
        goto lRet;
        }

    // If we have a response buffer, and we have not yet
    // had a write client error, flush the buffer
    // CONSIDER: Rearrange the tests for greater efficiency
    if (m_pData->m_fBufferingOn && !FDontWrite() && !IsHeadRequest())
        {
        // client debug buffer goes first
        if (m_pData->m_fClientDebugMode && m_pData->m_pClientDebugBuffer)
            {
            if (FAILED(hr = m_pData->m_pClientDebugBuffer->Flush(GetIReq())))
                {
                dwRequestStatus = HSE_STATUS_ERROR;
                goto lRet;
                }
            }

        // response buffer follows
        if (FAILED(hr = m_pData->m_pResponseBuffer->Flush(GetIReq())))
            {
            dwRequestStatus = HSE_STATUS_ERROR;
            goto lRet;
            }
        }
    else if (m_pData->m_fBufferingOn)
        {
        // If we have a response buffer and have had a write client
        // error, or this is a head request, we clear the buffers

        if (m_pData->m_pClientDebugBuffer)
            m_pData->m_pClientDebugBuffer->Clear();

        m_pData->m_pResponseBuffer->Clear();
        }
    else if (m_pData->m_fChunked && !FDontWrite() && !IsHeadRequest())
        {
        // Send closing 0-length chunk, we don't use any entity headers
        // so this is just 0 followed by two CRLF
        if (FAILED(CResponse::SyncWrite(GetIReq(), "0\r\n\r\n", 5)))
            {
            m_pData->m_fWriteClientError = TRUE;
            }
        }

lRet:
    // Done with this request
    if (m_pData->m_fWriteClientError)
        dwRequestStatus = HSE_STATUS_ERROR; // We had a write error at some point

    GetIReq()->ServerSupportFunction(
                        HSE_REQ_DONE_WITH_SESSION,
                        &dwRequestStatus,
                        0,
                        NULL);

    if (m_pData->m_pHitObj)
        m_pData->m_pHitObj->SetDoneWithSession();

    // We no longer need access to the template
    // which we AddRef'd in Response::ReinitTemplate
    if (m_pData->m_pTemplate)
        {
        m_pData->m_pTemplate->Release();
        m_pData->m_pTemplate = NULL;
        }

    return(hr);
    }

/*===================================================================
CResponse::End

Stops all further template processing, and returns the current response

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::End()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (m_pData->m_pfnGetScript != NULL && m_pData->m_pvGetScriptContext != NULL)
        {
        int i = 0;

        CScriptEngine* pEngine;
        while (NULL != (pEngine = (*m_pData->m_pfnGetScript)(i, m_pData->m_pvGetScriptContext)))
            {
            pEngine->InterruptScript(/*fAbnormal*/ FALSE);
            i++;
            }
        }

    m_pData->m_fResponseAborted = TRUE;
    return S_OK;
    }

/*===================================================================
CResponse::AppendToLog

Append a string to the current log entry.

Parameters
    bstrLogEntry Unicode BSTR, value: string to add to log entry

Returns:
    HRESULT         S_OK if ok

Side Effects:
    NONE
===================================================================*/
STDMETHODIMP CResponse::AppendToLog(BSTR bstrLogEntry)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    AssertValid();

    HRESULT       hr = S_OK;
    CWCharToMBCS  convEntry;

    // BUGBUG - should this be 65001?

    if (FAILED(hr = convEntry.Init(bstrLogEntry, m_pData->m_pHitObj->GetCodePage())));

    else hr = GetIReq()->AppendLogParameter(convEntry.GetString());

    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        }
        else {
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_LOG_FAILURE);
        }
    }

    return(hr);
    }

/*===================================================================
CResponse::get_Cookies

Return the write-only response cookie dictionary

Parameters
    bstrLogEntry Unicode BSTR, value: string to add to log entry

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_Cookies(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    AssertValid();
    return m_pData->m_WriteCookies.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }

#ifdef DBG
/*===================================================================
CResponse::AssertValid

Test to make sure that the CResponse object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
    None.
===================================================================*/
VOID CResponse::AssertValid() const
    {
    Assert(m_fInited);
    Assert(m_pData);
    Assert(m_pData->m_pResponseBuffer);
    Assert(m_pData->m_pIReq);
    }
#endif // DBG


/*===================================================================
IsHeadRequest

This function will check the REQUEST_METHOD and set a BOOL flag in
the class.  If the request method is HEAD the flag will be set to
true.

Also the flag must be reset with each init/reinit call

m_IsHeadRequest == 0    // HEAD request status not set
m_IsHeadRequest == 1    // Not a HEAD request
m_IsHeadRequest == 2    // is a HEAD request

Parameters

Returns:
    void

Side effects:
    sets status flag m_IsHeadRequest

===================================================================*/
BOOL CResponse::IsHeadRequest(void)
    {
    if (FAILED(CheckForTombstone()))
        return FALSE;

    AssertValid();

    if (m_pData->m_IsHeadRequest != 0)
        return ( m_pData->m_IsHeadRequest == 2);

    if (stricmp(GetIReq()->QueryPszMethod(), "HEAD") == 0 )
        m_pData->m_IsHeadRequest = 2;
    else
        m_pData->m_IsHeadRequest = 1;

    return ( m_pData->m_IsHeadRequest == 2);
    }

/*===================================================================
IsClientConnected

This function will return the status of the last attempt to write to
the client. If Ok, it check the connection using new CIsapiReqInfo method

Parameters
    none

Returns:
    VARIANT_BOOL reflecting the status of the client connection
===================================================================*/
STDMETHODIMP CResponse::IsClientConnected(VARIANT_BOOL* fIsClientConnected)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (m_pData->m_fWriteClientError)
        {
        *fIsClientConnected = VARIANT_FALSE;
        }
    else
        {
        // assume connected
        BOOL fConnected = TRUE;

        // test
        if (m_pData->m_pIReq)
            m_pData->m_pIReq->TestConnection(&fConnected);

        *fIsClientConnected = fConnected ? VARIANT_TRUE : VARIANT_FALSE;
        }

    return(S_OK);
    }

/*===================================================================
CResponse::get_CharSet

Functions called from DispInvoke to return the CarSet property.

Parameters:
    pbstrCharSetRet     BSTR FAR *, return value: pointer to the CharSet as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_CharSet
(
BSTR FAR * pbstrCharSetRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    if (m_pData->m_pszCharSet)
        hr = SysAllocStringFromSz(m_pData->m_pszCharSet, 0, pbstrCharSetRet);
    else
        *pbstrCharSetRet    = NULL;

    if (FAILED(hr))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_FAIL;
        }
    return(hr);
    }

/*===================================================================
CResponse::put_CharSet

Functions called from DispInvoke to set the CharSet property.

This function takses a string, which identifies the name of the
character set of the current page, and appends the name of the
character set (for example, " ISO-LATIN-7") specified by the
charsetname to the content-type header in the response object

Notes:

* this function inserts any string in the header, whether or not
it represents a valis charcter set.
* if a single page contains multiple tags contianing response.charset,
each response.charset will replace the cahrset by the previous entry.
As a result, the charset will be set to the value specified by the
last instance of response.charset on a page.
* this command must also be invoked before the first response.write
operation unless buffering is turned on.

Parameters:
    bstrContentType     BSTR, value: the ContentType as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_CharSet
(
BSTR bstrCharSet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT         hr = S_OK;
    CWCharToMBCS    convStr;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    if (m_pData->m_pszCharSet) {
        free(m_pData->m_pszCharSet);
        m_pData->m_pszCharSet = NULL;
    }

    if (FAILED(hr = convStr.Init(bstrCharSet)));

    else if ((m_pData->m_pszCharSet = convStr.GetString(TRUE)) == NULL) {
        hr = E_OUTOFMEMORY;
    }

lRet:
    if (hr == E_OUTOFMEMORY) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
    }
    return(hr);
    }


/*===================================================================
CResponse::Pics

Functions called from DispInvoke to Add a pics header.

Parameters:
    bstrHeaderValue     Unicode BSTR, value: the value of pics header

Takes a string, which is the properly formatted PICS label, and adds
the value specified by the picslabel to the pics-label field of the response header.

Note:

* this function inserts any string in the header, whether or not it
represents a valid PICS lavel.

* current implimentation is a wraper on the addheader method.


Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::Pics
(
BSTR bstrHeaderValue
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    if (FAILED(AppendHeader("pics-label", bstrHeaderValue)))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
        }

    return S_OK;
    }

/*===================================================================
CResponse::get_CacheControl

Functions called from DispInvoke to return the CacheControl property.

Parameters:
    pbstrCacheControl   BSTR FAR *, return value: pointer to the CacheControl as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_CacheControl
(
BSTR FAR * pbstrCacheControl
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    if (m_pData->m_pszCacheControl)
        hr = SysAllocStringFromSz(m_pData->m_pszCacheControl, 0, pbstrCacheControl);
    else
        hr = SysAllocStringFromSz( "private", 0, pbstrCacheControl);

    if (FAILED(hr))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_FAIL;
        }
    return(hr);
    }

/*===================================================================
CResponse::put_CacheControl

Functions called from DispInvoke to set the CacheControl property.

Parameters:
    bstrCacheControl    BSTR, value: the CacheControl as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_CacheControl
(
BSTR bstrCacheControl
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT         hr = S_OK;
    CWCharToMBCS    convStr;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    if (m_pData->m_pszCacheControl) {
        free(m_pData->m_pszCacheControl);
        m_pData->m_pszCacheControl = NULL;
    }

    if (FAILED(hr = convStr.Init(bstrCacheControl)));

    else if ((m_pData->m_pszCacheControl = convStr.GetString(TRUE)) == NULL) {
        hr = E_OUTOFMEMORY;
    }

lRet:
    if (hr == E_OUTOFMEMORY) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
    }
    return(hr);
    }

/*===================================================================
CResponse::get_CodePage

Returns the current code page value for the response

Parameters:
    long *plVar     [out] code page value

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CResponse::get_CodePage
(
long *plVar 
)
{
    Assert(m_pData);
        Assert(m_pData->m_pHitObj);

        *plVar = m_pData->m_pHitObj->GetCodePage();

	// If code page is 0, look up default ANSI code page
	if (*plVar == 0) {
		*plVar = (long) GetACP();
    }
		
	return S_OK;
}

/*===================================================================
CResponse::put_CodePage

Sets the current code page value for the response

Parameters:
    long lVar       code page to assign to this response

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CResponse::put_CodePage
(
long lVar 
) 
{
    Assert(m_pData);
    Assert(m_pData->m_pHitObj);

    // set code page member variable 
    HRESULT hr = m_pData->m_pHitObj->SetCodePage(lVar);

    if (FAILED(hr)) {
        ExceptionId
            (
            IID_IResponse,
            IDE_RESPONSE, 
            IDE_SESSION_INVALID_CODEPAGE 
            );
        return E_FAIL;
    }

	return S_OK;
}

/*===================================================================
CResponse::get_LCID

Returns the current LCID value for the response

Parameters:
    long *plVar     [out] LCID value

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CResponse::get_LCID
(
long *plVar 
)
{
    Assert(m_pData);
    Assert(m_pData->m_pHitObj);

        *plVar = m_pData->m_pHitObj->GetLCID();

	// If code page is 0, look up default ANSI code page
	if (*plVar == LOCALE_SYSTEM_DEFAULT) {
		*plVar = (long) GetSystemDefaultLCID();
	}
		
	return S_OK;
}

/*===================================================================
CResponse::put_LCID

Sets the current LCID value for the response

Parameters:
    long lVar       LCID to assign to this response

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CResponse::put_LCID
(
long lVar 
) 
{
    Assert(m_pData);
    Assert(m_pData->m_pHitObj);

    // set code page member variable 
    HRESULT hr = m_pData->m_pHitObj->SetLCID(lVar);

    if (FAILED(hr)) {
        ExceptionId
            (
            IID_IResponse,
            IDE_RESPONSE, 
            IDE_TEMPLATE_BAD_LCID 
            );
        return E_FAIL;
    }

	return S_OK;
}


/*===================================================================
IStream implementation for ADO/XML
===================================================================*/

STDMETHODIMP CResponse::Read(
    void *pv,
    ULONG cb,
    ULONG *pcbRead)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Write(
    const void *pv,
    ULONG cb,
    ULONG *pcbWritten)
{
    if (pcbWritten != NULL)
        *pcbWritten = cb;
    return WriteSz((CHAR*) pv, cb);
}

STDMETHODIMP CResponse::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::SetSize(
    ULARGE_INTEGER libNewSize)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Commit(
    DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Clone(
    IStream **ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\smhash.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash table for Script Manager

File: SMHash.cpp

Owner: AndrewS

This is the Link list and Hash table for use by the Script Manager only
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "memchk.h"

/*===================================================================
CSMHash::AddElem

Adds a CLruLinkElem to the SM Hash table.
User is responsible for allocating the Element to be added.

Note: This is identical to the standard CHashTable::AddElem, except
that it allows for elements with duplicate names

Parameters:
	CLruLinkElem *pElem		Object to be added

Returns:
	Pointer to element added/found.
===================================================================*/
CLruLinkElem *CSMHash::AddElem
(
CLruLinkElem *pElem
)
	{
	AssertValid();

    if (m_rgpBuckets == NULL)
        {
        if (FAILED(AllocateBuckets()))
            return NULL;
        }
	
	if (pElem == NULL)
		return NULL;

	UINT			iBucket = m_pfnHash(pElem->m_pKey, pElem->m_cbKey) % m_cBuckets;
	CLruLinkElem *	pT = static_cast<CLruLinkElem *>(m_rgpBuckets[iBucket]);
	
	while (pT)
		{
		if (pT->m_Info > 0)
			pT = static_cast<CLruLinkElem *>(pT->m_pNext);
		else
			break;
		}

	if (pT)
		{
		// There are other elements in bucket
		pT = static_cast<CLruLinkElem *>(m_rgpBuckets[iBucket]);
		m_rgpBuckets[iBucket] = pElem;
		pElem->m_Info = pT->m_Info + 1;
		pElem->m_pNext = pT;
		pElem->m_pPrev = pT->m_pPrev;
		pT->m_pPrev = pElem;
		if (pElem->m_pPrev == NULL)
			m_pHead = pElem;
		else
			pElem->m_pPrev->m_pNext = pElem;
		}
	else
		{
		// This is the first element in the bucket
		m_rgpBuckets[iBucket] = pElem;
		pElem->m_pPrev = NULL;
		pElem->m_pNext = m_pHead;
		pElem->m_Info = 0;
		if (m_pHead)
			m_pHead->m_pPrev = pElem;
		else
			m_pTail = pElem;
		m_pHead = pElem;
		}
	m_Count++;
	pElem->PrependTo(m_lruHead);
	AssertValid();
	return pElem;
	}

/*===================================================================
CSMHash::FindElem

Finds a script engine element in the hash table based on the name
and language type.

Parameters:
	void *	pKey			- the key to look for
	int		cbKey			- length of the key to look for
	PROGLANG_ID proglang_id - program language name
	DWORD   dwInstanceID    - instance ID to find
	BOOL	fCheckLoaded	- if true, only return engines flagged as "loaded"

Returns:
	Pointer to CLruLinkElem if found, otherwise NULL.
===================================================================*/
CLruLinkElem * CSMHash::FindElem
(
const void *pKey,
int cbKey,
PROGLANG_ID proglang_id,
DWORD dwInstanceID,
BOOL fCheckLoaded
)
	{
	AssertValid();
	if (m_rgpBuckets == NULL || pKey == NULL)
		return NULL;

	UINT iBucket = m_pfnHash(static_cast<const BYTE *>(pKey), cbKey) % m_cBuckets;
	CLruLinkElem *	pT = static_cast<CLruLinkElem *>(m_rgpBuckets[iBucket]);
	CLruLinkElem *	pRet = NULL;

	/*
	 * We have the right bucket based on the hashed name.  
	 * Search through the bucket chain looking for elements whose name
	 * is correct (multiple names can hash to the same bucket), and 
	 * whose language is the one we want, and (optionally) skip
	 * elements that are not fully "loaded"
	 *
	 * Note: This all relys on intimate knowlege of the format of an ActiveScriptEngine.
	 *			these elements better be ASE's.
	 */
	while (pT && pRet == NULL)
		{
		if (FIsEqual(pT->m_pKey, pT->m_cbKey, pKey, cbKey))
			{
			CASEElem *pASEElem = static_cast<CASEElem *>(pT);
			Assert(pASEElem != NULL);
			CActiveScriptEngine *pASE = pASEElem->PASE();
			Assert(pASE != NULL);
			
			// Element has the right name.  Is it really the one we want?
			if (proglang_id != pASE->ProgLang_Id())
				goto LNext;

			if (dwInstanceID != pASE->DWInstanceID())
				goto LNext;

			if (fCheckLoaded && !pASE->FFullyLoaded())
				goto LNext;

			// Yup, its the right one!
			pRet = pT;
			break;
			}
			
LNext:			
		if (pT->m_Info > 0)
			pT = static_cast<CLruLinkElem *>(pT->m_pNext);
		else
			{
			// got to the last element in this bucket chain
			break;
			}
		}
		
	if (pRet)
		pRet->PrependTo(m_lruHead);

	AssertValid();
	return pRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\smhash.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash table for Script Manager

File: SMHash.h

Owner: AndrewS

This is the Link list and Hash table for use by the Script Manager only
===================================================================*/

#ifndef SMHASH_H
#define SMHASH_H

#include "LinkHash.h"

/*
 * C S M H a s h
 *
 * CSMHash is identical to CHashTable, but AddElem has differing behavior.
 */
class CSMHash : public CLinkHash
{
public:
	CLruLinkElem *AddElem(CLruLinkElem *pElem);
	CLruLinkElem *FindElem(const void *pKey, int cbKey, PROGLANG_ID proglang_id, DWORD dwInstanceID, BOOL fCheckLoaded);

};

#endif // SMHASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\strlist.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: StringList object

File: StrList.h

Owner: DGottner

This file contains the header info for defining the Request object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef _StrList_H
#define _StrList_H

#include "dispatch.h"
#include "asptlb.h"
#include "memcls.h"

// Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);


/*
 * C S t r i n g L i s t E l e m
 *
 * A String list is a linked list of CStringListElem's
 * This approach was chosen because it should cause less fragmentation
 * than an array-based approach. (At least with our current memory
 * management algorithm.)
 */
class CStringListElem
	{
private:
    DWORD   m_fBufferInUse : 1; // buffer instead of pointer?
    DWORD   m_fAllocated : 1;   // free the pointer on destructor?

	CStringListElem	*m_pNext;   // next element

    union
        {
    WCHAR   *m_szPointer;     // valid when m_fBufferInUse is FALSE
    WCHAR    m_szBuffer[48];  // valid when m_fBufferInUse is TRUE
                              // 48 hardcoded only here - sizeof() used elsewhere
        };
    
public:
	CStringListElem();
	~CStringListElem();

	HRESULT Init(char *szValue, BOOL fMakeCopy, UINT  lCodePage);

    HRESULT Init(WCHAR *wszValue, BOOL fMakeCopy);
	
	inline WCHAR *QueryValue()
	    {
	    return (m_fBufferInUse ? m_szBuffer : m_szPointer);
	    }
	    
	inline CStringListElem *QueryNext()
	    {
	    return m_pNext;
	    }
	    
	inline void SetNext(CStringListElem *pNext)
	    {
	    m_pNext = pNext;
	    }
	    
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};



/*
 * C S t r i n g L i s t
 *
 * IStringList implementation (includes IDispatch)
 */
class CStringList : public IStringList
	{
friend class CStrListIterator;

protected:
	CSupportErrorInfo	m_ISupportErrImp;	// ISupportError implementation
	ULONG				m_cRefs;			// reference count
	PFNDESTROYED		m_pfnDestroy;		// To call on closure

private:
	CStringListElem		*m_pBegin, *m_pEnd;	// begin & end of string list
	int					m_cValues;			// number of values stored
	long				m_lCodePage;		// CodePage used in converting stored value to proper UNICODE string

	HRESULT ConstructDefaultReturn(VARIANT *);	// construct comma-separated return

public:
	CStringList(IUnknown * = NULL, PFNDESTROYED = NULL);
	~CStringList();

	HRESULT AddValue(char *szValue, BOOL fDuplicate = FALSE, UINT lCodePage = CP_ACP);

	HRESULT AddValue(WCHAR *szValue, BOOL fDuplicate = FALSE);

	// IUnknown implementation
	//
	STDMETHODIMP		 	QueryInterface(const IID &rIID, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// IStringList implementation
	//
	STDMETHODIMP			get_Item(VARIANT varIndex, VARIANT *pvarOut);
	STDMETHODIMP			get_Count(int *pcValues);
	STDMETHODIMP			get__NewEnum(IUnknown **ppEnum);
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};



/*
 * C S t r L i s t I t e r a t o r
 *
 * IEnumVariant implementation for all Request collections except
 * ServerVariables
 */

class CStrListIterator : public IEnumVARIANT
	{
public:
	CStrListIterator(CStringList *pStrings);
	~CStrListIterator();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG				m_cRefs;		// reference count
	CStringList *		m_pStringList;	// pointer to iteratee
	CStringListElem *	m_pCurrent;		// pointer to current element in target CStringList
	};

#endif  // _StrList_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\svcintfs.h ===
EXTERN_C const IID IID_IComStaThreadPoolKnobs;

    
    MIDL_INTERFACE("324B64FA-33B6-11d2-98B7-00C04F8EE1C4")
    IComStaThreadPoolKnobs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMinThreadCount( 
            DWORD minThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinThreadCount( 
            /* [out] */ DWORD __RPC_FAR *minThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxThreadCount( 
            DWORD maxThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxThreadCount( 
            /* [out] */ DWORD __RPC_FAR *maxThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActivityPerThread( 
            DWORD activitiesPerThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivityPerThread( 
            /* [out] */ DWORD __RPC_FAR *activitiesPerThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActivityRatio( 
            DOUBLE activityRatio) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivityRatio( 
            /* [out] */ DOUBLE __RPC_FAR *activityRatio) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadCount( 
            /* [out] */ DWORD __RPC_FAR *pdwThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQueueDepth( 
            /* [out] */ DWORD __RPC_FAR *pdwQDepth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQueueDepth( 
            /* [in] */ long dwQDepth) = 0;
        
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\sessmgr.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Session Manager

File: Sessmgr.h

Owner: PramodD

This is the session manager header file.
===================================================================*/
#ifndef SESSMGR_H
#define SESSMGR_H

#include "debug.h"
#include "idhash.h"
#include "idgener.h"
#include "compcol.h"
#include "request.h"
#include "response.h"
#include "server.h"
#include "viperint.h"
#include "ftm.h"
#include "memcls.h"

/*===================================================================
  #defines
===================================================================*/

// Min/Max session timeout in minutes
#define SESSION_TIMEOUT_MIN		        1		// 1 minute
#define SESSION_TIMEOUT_MAX		        1440	// 1 day

// Master hash table sizes
#define SESSION_MASTERHASH_SIZE1_MAX    499
#define SESSION_MASTERHASH_SIZE2_MAX    31
#define SESSION_MASTERHASH_SIZE3_MAX    13

// Timeout bucket hash tables sizes
#define SESSION_TIMEOUTHASH_SIZE1_MAX   97
#define SESSION_TIMEOUTHASH_SIZE2_MAX   29
#define SESSION_TIMEOUTHASH_SIZE3_MAX   11

// Min/Max # of timeout buckets (hash tables)
#define SESSION_TIMEOUTBUCKETS_MIN      10
#define SESSION_TIMEOUTBUCKETS_MAX      45

// max value of GetTickCount()
#define	DWT_MAX 0xFFFFFFFF

// session killer workitem default wait
#define MSEC_ONE_MINUTE     60000   // 1 min

#include "asptlb.h"

/*===================================================================
  Forward declarations
===================================================================*/

class CAppln;
class CHitObj;
class CSession;

/*===================================================================
  C S e s s i o n V a r i a n t s
===================================================================*/
class CSessionVariants : public IVariantDictionary
	{
private:
    ULONG               m_cRefs;            // ref count
	CSession *			m_pSession;			// pointer to parent object
	CompType            m_ctColType;        // collection type
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr

	HRESULT ObjectNameFromVariant(VARIANT &vKey, WCHAR **ppwszName, 
	                              BOOL fVerify = FALSE);

public:
	CSessionVariants();
	~CSessionVariants();

	HRESULT Init(CSession *pSession, CompType ctColType);
	HRESULT UnInit();

	// The Big Three

	STDMETHODIMP		 QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// OLE Automation Interface

	STDMETHODIMP get_Item(VARIANT VarKey, VARIANT *pvar);
	STDMETHODIMP put_Item(VARIANT VarKey, VARIANT var);
	STDMETHODIMP putref_Item(VARIANT VarKey, VARIANT var);
	STDMETHODIMP get_Key(VARIANT VarKey, VARIANT *pvar);
	STDMETHODIMP get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP get_Count(int *pcValues);
	STDMETHODIMP Remove(VARIANT VarKey);
	STDMETHODIMP RemoveAll();
	
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

/*===================================================================
  C  S e s s i o n  I D
===================================================================*/
struct CSessionId
    {
	DWORD m_dwId;	// Session Id
	DWORD m_dwR1;	// Session Id random element 1
	DWORD m_dwR2;	// Session Id random element 2

    CSessionId(DWORD dwId = INVALID_ID, DWORD dwR1 = 0, DWORD dwR2 = 0);
    };

inline CSessionId::CSessionId(DWORD dwId, DWORD dwR1, DWORD dwR2)
    {
    m_dwId = dwId;
    m_dwR1 = dwR1;
    m_dwR2 = dwR2;
    }

/*===================================================================
  C  S e s s i o n
===================================================================*/
class CSession : public ISessionObjectImpl, public CFTMImplementation
    {

friend class CSessionMgr;
friend class CSessionVariants;

private:

    //========= Misc flags
    
	DWORD m_fInited : 1;		  // Are we initialized?
	DWORD m_fLightWeight : 1;     // Is in lightweight form?
	DWORD m_fOnStartFailed : 1;	  // Session_OnStart failed?
	DWORD m_fOnStartInvoked : 1;  // Session_OnStart invoked?
	DWORD m_fOnEndPresent : 1;    // Need to invoke Session_OnEnd ?
	DWORD m_fTimedOut : 1;        // Session timed out?
	DWORD m_fStateAcquired : 1;   // Any property set (!m_fCanDelete)?
	DWORD m_fCustomTimeout : 1;   // Timeout different from standard?
	DWORD m_fAbandoned : 1;       // Session abandoned?
	DWORD m_fTombstone : 1;       // ASP is done with the session?
	DWORD m_fInTOBucket : 1;      // Session in a timeout bucket?
	DWORD m_fSessCompCol : 1;     // Component collection present?
	DWORD m_fSecureSession : 1;   //  Is the session used over a secure line?
    DWORD m_fCodePageSet : 1;     // CodePage explicitly set?
    DWORD m_fLCIDSet     : 1;     // LCID explicitly set?

	//========= Pointers to related objects
	
	CAppln  *m_pAppln;    // Session's Application
	CHitObj *m_pHitObj;   // Session's current HitObj
	
	//========= Session's dictionaries for presenting component collection
	
	CSessionVariants *m_pTaggedObjects;
	CSessionVariants *m_pProperties;

    //========= Session data

    CSessionId m_Id;        // Session ID + 2 random keys
    DWORD m_dwExternId;     // Session ID to be given out (Session.ID)

    DWORD m_cRefs;          // Ref count
	DWORD m_cRequests;      // Requests count

	// Timeout when current time (in minutes) reaches this
	// The timeout bucket is current_time mod #_of_buckets
	DWORD m_dwmTimeoutTime;
	
	long  m_lCodePage;	    // Code page for this session
	LCID  m_lcid;			// LCID for this session
	long  m_nTimeout;       // Current time value in minutes

	// to make session elem in the timeout bucket
	CObjectListElem m_TOBucketElem;
	
#ifndef PERF_DISABLE
    DWORD m_dwtInitTimestamp; // Timestamp of session creation for PERFMON
#endif

	//========= Session's Component Collection

	// to avoid the memory fragmentation component collection is
	// aggregated here. its validity is indicated by m_fSessCompCol flag
	CComponentCollection m_SessCompCol;  // Session scope objects
	
	//========= Viper Activity of this Session
	
	CViperActivity m_Activity;

	//========= Intrinsics for this Session
	
	CRequest    m_Request;
	CResponse   m_Response;
	CServer     m_Server;

	//========= SupportErrorInfo
	
	// Interface to indicate that we support ErrorInfo reporting
    CSupportErrorInfo m_ISuppErrImp;

public:	
	CSession();
	~CSession();

	HRESULT Init(CAppln *pAppln, const CSessionId &Id);

    // Convert to tombstone state
    HRESULT UnInit();

	// Convert to 'light-weight' state if possible
	HRESULT MakeLightWeight();

	// Create/Remove Session's component collection
	HRESULT CreateComponentCollection();
	HRESULT RemoveComponentCollection();

    // Check if the session should be deleted
    BOOL FShouldBeDeletedNow(BOOL fAtEndOfRequest);

	// Non-delegating object IUnknown
	STDMETHODIMP		 QueryInterface(REFIID, void **);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

    // Tombstone stub
	HRESULT CheckForTombstone();

	// ISessionObject functions
	STDMETHODIMP get_SessionID(BSTR *pbstrRet);
	STDMETHODIMP get_Timeout(long *plVar);
	STDMETHODIMP put_Timeout(long lVar);
	STDMETHODIMP get_CodePage(long *plVar);
	STDMETHODIMP put_CodePage(long lVar);
	STDMETHODIMP get_Value(BSTR bstr, VARIANT FAR * pvar);
	STDMETHODIMP put_Value(BSTR bstr, VARIANT var);
	STDMETHODIMP putref_Value(BSTR bstr, VARIANT var);
	STDMETHODIMP Abandon();
	STDMETHODIMP get_LCID(long *plVar);
	STDMETHODIMP put_LCID(long lVar);
	STDMETHODIMP get_StaticObjects(IVariantDictionary **ppDictReturn);
	STDMETHODIMP get_Contents(IVariantDictionary **ppDictReturn);

	// inline methods to access member properties
	CAppln                *PAppln();
	CHitObj               *PHitObj();
	CComponentCollection  *PCompCol();
	CViperActivity        *PActivity();
	CRequest              *PRequest();
	CResponse             *PResponse();
	CServer               *PServer();
	BOOL                   FCustomTimeout();
	BOOL                   FAbandoned();
	DWORD                  GetId();
	BOOL                   FInTOBucket();
	LCID				   GetLCID();
    long                   GetCodePage();
	DWORD                  GetTimeoutTime();
	BOOL                   FSecureSession(); 


    // inline methods to set member properties
	void    SetHitObj(CHitObj *pHitObj);
	void    SetOnStartFailedFlag();
	void    SetOnStartInvokedFlag();
	void    SetOnEndPresentFlag();
	HRESULT SetLCID(LCID lcid);
	
    // Misc inline methods
	DWORD   IncrementRequestsCount();
	DWORD   DecrementRequestsCount();
    DWORD   GetRequestsCount();
    BOOL    FCanDeleteWithoutExec();
    BOOL    FHasObjects();
	BOOL    FPassesIdSecurityCheck(DWORD dwR1, DWORD dwR2);
    void    AssignNewId(const CSessionId &Id);
    void    SetSecureSession(BOOL fSecure); 
    BOOL    FCodePageSet();
    BOOL    FLCIDSet();

    // AssertValid()
public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()

	// Trace Log info -- keep in both free & checked builds so that ntsd extension will work for both builds
	// for FREE build, trace log is always NULL.  Checked builds, it must be enabled.
	static PTRACE_LOG gm_pTraceLog;
    };

/*===================================================================
  C  S e s s i o n   inlines
===================================================================*/

inline CAppln *CSession::PAppln()
    {
    Assert(m_fInited);
    return m_pAppln;
    }
    
inline CHitObj *CSession::PHitObj()
    {
    Assert(m_fInited);
    return m_pHitObj;
    }
    
inline CComponentCollection  *CSession::PCompCol()
    {
    Assert(m_fInited);
    return (m_fSessCompCol ? &m_SessCompCol : NULL);
    }
    
inline CViperActivity *CSession::PActivity()
    {
    Assert(m_fInited);
    return &m_Activity;
    }

inline CRequest *CSession::PRequest()
    {
    Assert(m_fInited);
    return &m_Request;
    }
    
inline CResponse *CSession::PResponse()
    {
    Assert(m_fInited);
    return &m_Response;
    }
    
inline CServer *CSession::PServer()
    {
    Assert(m_fInited);
    return &m_Server;
    }

inline BOOL CSession::FCustomTimeout()
    {
    Assert(m_fInited);
    return m_fCustomTimeout;
    }
    
inline BOOL CSession::FAbandoned()
    {
    Assert(m_fInited);
    return m_fAbandoned;
    }
    
inline DWORD CSession::GetId()
    {
    Assert(m_fInited);
    return m_Id.m_dwId;
    }

inline BOOL CSession::FInTOBucket()
    {
    Assert(m_fInited);
    return m_fInTOBucket;
    }

inline LCID CSession::GetLCID()
    {
    Assert(m_fInited);
    return (UINT)m_lcid;
    }

inline long CSession::GetCodePage()
{
    Assert(m_fInited);
    return m_lCodePage;
}

inline BOOL CSession::FCodePageSet()
{
    Assert(m_fInited);
    return (m_fCodePageSet);
}

inline BOOL CSession::FLCIDSet()
{
    Assert(m_fInited);
    return (m_fLCIDSet);
}

inline DWORD CSession::GetTimeoutTime()
    {
    Assert(m_fInited);
    return m_dwmTimeoutTime;
    }


inline BOOL CSession::FSecureSession()
    {
    Assert(m_fInited);
    return m_fSecureSession;
    }

inline void CSession::SetHitObj(CHitObj *pHitObj)
    {
    Assert(m_fInited);
    Assert(pHitObj ? (m_pHitObj == NULL) : (m_pHitObj != NULL));
    m_pHitObj = pHitObj;
    }
    
inline void CSession::SetOnStartFailedFlag()
    {
    Assert(m_fInited);
    m_fOnStartFailed = TRUE;
    }
    
inline void CSession::SetOnStartInvokedFlag()
    {
    Assert(m_fInited);
    m_fOnStartInvoked = TRUE;
    }

inline void CSession::SetOnEndPresentFlag()
    {
    Assert(m_fInited);
    m_fOnEndPresent = TRUE;
    }
    
inline HRESULT CSession::SetLCID(LCID lcid)
    {
    Assert(m_fInited);
	if ((LOCALE_SYSTEM_DEFAULT == lcid) || IsValidLocale(lcid, LCID_INSTALLED))
	    {
	    m_lcid = lcid; 
	    return S_OK;
	    }
	 else
	    {
	    return E_FAIL;
	    }
    }

inline DWORD CSession::IncrementRequestsCount()
    {
    Assert(m_fInited);
    return InterlockedIncrement((LPLONG)&m_cRequests);
    }
    
inline DWORD CSession::DecrementRequestsCount()
    {
    Assert(m_fInited);
    return InterlockedDecrement((LPLONG)&m_cRequests);
    }
    
inline DWORD CSession::GetRequestsCount()
    {
    Assert(m_fInited);
    return m_cRequests;
    }
    
inline BOOL CSession::FCanDeleteWithoutExec()
    {
    // Return TRUE to delete CSession right away or FALSE to
    // post Viper request to execute Session_OnEnd()
	return (m_fOnStartFailed || !m_fOnEndPresent);
	}

inline BOOL CSession::FHasObjects()
    {
    return m_fSessCompCol && m_SessCompCol.FHasObjects();
    }
    
inline BOOL CSession::FPassesIdSecurityCheck(DWORD dwR1, DWORD dwR2)
    {
    Assert(m_fInited);
    return (m_Id.m_dwR1 == dwR1 && m_Id.m_dwR2 == dwR2);
    }

inline void CSession::AssignNewId(const CSessionId &Id)
    {
    Assert(m_fInited);
	m_Id = Id;
    }


inline void CSession::SetSecureSession(BOOL fSecure)
    {
    Assert(m_fInited);
    m_fSecureSession = fSecure;
    }

/*===================================================================
  C  S e s s i o n  M g r
===================================================================*/

class CSessionMgr
    {
private:
    // Flags
	DWORD m_fInited : 1;	            // Are we initialized?

    // Application
	CAppln *m_pAppln;

	// Sessions master hash table
	CIdHashTableWithLock m_htidMaster;

	// Number of posted Session Cleanup requests
	DWORD m_cSessionCleanupRequests;

	// Timeout buckets
	DWORD m_cTimeoutBuckets;
	CObjectListWithLock *m_rgolTOBuckets;

    // Session killer scheduler workitem
    DWORD m_idSessionKiller;    // workitem id

    DWORD m_dwmCurrentTime; // current time in minutes since start
    DWORD m_dwtNextSessionKillerTime;  // next session killer time

public:
	CSessionMgr();
	~CSessionMgr();

    // Init/Unit
	HRESULT	Init(CAppln *pAppln);
	HRESULT	UnInit();

    // Add/remove session killer workitem
    HRESULT ScheduleSessionKiller();
    HRESULT UnScheduleSessionKiller();
    BOOL    FIsSessionKillerScheduled();

    // Lock/Unlock master hash table
	HRESULT LockMaster();
    HRESULT UnLockMaster();
    
    // Lock/Unlock a timeout bucket hash table
	HRESULT LockTOBucket(DWORD iBucket);
    HRESULT UnLockTOBucket(DWORD iBucket);

    // Get current time in minute ticks
    DWORD GetCurrentTime();
    // Set the time when the session should be gone
    HRESULT UpdateSessionTimeoutTime(CSession *pSession);
    // Calculate which timeout bucket the session's in
    DWORD GetSessionTOBucket(CSession *pSession);

    // Generate new ID and cookie
    HRESULT GenerateIdAndCookie(CSessionId *pId, char *pszCookie);

    // Create new session object
    HRESULT NewSession(const CSessionId &Id, CSession **ppSession);

    // Reassign session's Id (reinsert session into master hash)
    HRESULT ChangeSessionId(CSession *pSession, const CSessionId &Id);
   
    // Master hash table manipulations
    HRESULT AddToMasterHash(CSession *pSession);
    HRESULT RemoveFromMasterHash(CSession *pSession);
    HRESULT FindInMasterHash(const CSessionId &Id, CSession **ppSession);

    // Insert/remove session into the timeout bucket hash table
    HRESULT AddSessionToTOBucket(CSession *pSession);
    HRESULT RemoveSessionFromTOBucket(CSession *pSession, BOOL fLock = TRUE);

    // Delete session now or queue for deletion
    HRESULT DeleteSession(CSession *pSession, BOOL fInSessActivity = FALSE);

    // Delete expired sessions from a given bucket
    HRESULT DeleteExpiredSessions(DWORD iBucket);

    // Delete all sessions (application shut-down code)
    HRESULT DeleteAllSessions(BOOL fForce);
    // Static iterator call back to delete all sessions
    static IteratorCallbackCode DeleteAllSessionsCB(void *, void *, void *);

    // The Session Killer 
    static VOID WINAPI SessionKillerSchedulerCallback(VOID *pv);

    // Incr/Decr/Get number of posted Session Cleanup requests
    void  IncrementSessionCleanupRequestCount();
    void  DecrementSessionCleanupRequestCount();
    DWORD GetNumSessionCleanupRequests();

    // AssertValid()
public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif
	};

inline BOOL CSessionMgr::FIsSessionKillerScheduled()
    {
    return (m_idSessionKiller != 0);
    }
    
inline HRESULT CSessionMgr::LockMaster()
    {
    m_htidMaster.Lock();
    return S_OK;
    }
    
inline HRESULT CSessionMgr::UnLockMaster()
    {
    m_htidMaster.UnLock();
    return S_OK;
    }
    
inline HRESULT CSessionMgr::LockTOBucket(DWORD iBucket)
    {
    Assert(m_rgolTOBuckets);
    Assert(iBucket < m_cTimeoutBuckets);
    m_rgolTOBuckets[iBucket].Lock();
    return S_OK;
    }
    
inline HRESULT CSessionMgr::UnLockTOBucket(DWORD iBucket)
    {
    Assert(m_rgolTOBuckets);
    Assert(iBucket < m_cTimeoutBuckets);
    m_rgolTOBuckets[iBucket].UnLock();
    return S_OK;
    }

inline DWORD CSessionMgr::GetCurrentTime()
    {
    return m_dwmCurrentTime;
    }

inline HRESULT CSessionMgr::UpdateSessionTimeoutTime(CSession *pSession)
    {
    Assert(pSession);

    // remember when the session times out
    pSession->m_dwmTimeoutTime =
        m_dwmCurrentTime + pSession->m_nTimeout + 1;

    return S_OK;    
    }

inline DWORD CSessionMgr::GetSessionTOBucket(CSession *pSession)
    {
    Assert(pSession->m_fInited);
    return (pSession->m_dwmTimeoutTime % m_cTimeoutBuckets);
    }

inline HRESULT CSessionMgr::AddToMasterHash(CSession *pSession)
    {
    Assert(m_fInited);
 	return m_htidMaster.AddObject(pSession->GetId(), pSession);
    }
    
inline HRESULT CSessionMgr::RemoveFromMasterHash(CSession *pSession)
    {
    Assert(m_fInited);
	return m_htidMaster.RemoveObject(pSession->GetId());
    }

inline void CSessionMgr::IncrementSessionCleanupRequestCount()
    {
    InterlockedIncrement((LPLONG)&m_cSessionCleanupRequests);
    }
    
inline void CSessionMgr::DecrementSessionCleanupRequestCount()
    {
    InterlockedDecrement((LPLONG)&m_cSessionCleanupRequests);
    }

inline DWORD CSessionMgr::GetNumSessionCleanupRequests()
    {
    return m_cSessionCleanupRequests;
    }

/*===================================================================
  G l o b a l s
===================================================================*/

// There are multiple session managers (one per application)
// The following variables are 1 per ASP.DLL

extern unsigned long g_nSessions;
extern CIdGenerator  g_SessionIdGenerator;
extern CIdGenerator  g_ExposedSessionIdGenerator;     

#endif // SESSMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\scrptmgr.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Script Manager

File: ScrptMgr.cpp

Owner: AndrewS

This file contains the implementation of the Scrip Manager,
ie: siting an ActiveX Scripting engine (in our case VBScript) for Denali.

===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "dbgcxt.h"
#include "SMHash.h"
#include "perfdata.h"
#include <txnscrpt.h>
#include "debugger.h"
#include "wraptlib.h"

// ATQ Scheduler
#include "issched.hxx"

#include "MemChk.h"

CScriptManager g_ScriptManager;
IWrapTypeLibs *g_pWrapTypelibs = NULL;

#define RESPONSE_END_ERRORCODE ERROR_OPERATION_ABORTED

HRESULT GetProgLangIdOfName(LPCSTR szProgLangName, PROGLANG_ID *pProgLangId);

//*****************************************************************************
// The following macros are used to catch exceptions thrown from the external
// scripting engines.
//
// Use of TRY/CATCH blocks around calls to the script engine is controlled by
// the DBG compile #define.  If DBG is 1, then the TRY/CATCH blocks are NOT
// used so that checked builds break into the debugger and we can examine why
// the error occurred.  If DBG is 0, then the TRY/CATCH blocks are used and
// exceptions are captured and logged to the browser (if possible) and the NT
// Event log.
//
// The TRYCATCH macros are:
//
//  TRYCATCH(_s, _IFStr)
//      _s      - statement to execute inside of TRY/CATCH block.
//      _IFStr  - string containing the name of interface invoked
//  TRYCATCH_HR(_s, _hr, _IFStr)
//      _s      - statement to execute inside of TRY/CATCH block.
//      _hr     - HRESULT to store return from _s
//      _IFStr  - string containing the name of interface invoked
//  TRYCATCH_NOHITOBJ(_s, _IFStr)
//      Same as TRYCATCH() except there is no Hitobj in the "this" object
//  TRYCATCH_HR_NOHITOBJ(_s, _hr, _IFStr)
//      Same as TRYCATCH_HR() except there is no Hitobj in the "this" object
//
//  NOTES:
//  The macros also expect that there is a local variable defined in the function
//  the macros is used of type char * named _pFuncName.
//  
//  A minimal test capability is included to allow for random errors to be throw.
//  The test code is compiled in based on the TEST_TRYCATCH #define.
//
//*****************************************************************************

//*****************************************************************************
// TEST_TRYCATCH definitions
//*****************************************************************************
#define TEST_TRYCATCH 0

#if TEST_TRYCATCH
#define  THROW_INTERVAL 57

int g_TryCatchCount = 0;

#define TEST_THROW_ERROR  g_TryCatchCount++; if ((g_TryCatchCount % THROW_INTERVAL) == 0) {THROW(0x80070000+g_TryCatchCount);}
#else
#define TEST_THROW_ERROR  
#endif

//*****************************************************************************
// The following is the heart of the TRYCATCH macros.  The definitions here are
// based on the definition of DBG.  Again, note that when DBG is off that the
// TRYCATCH defines are removed.
//*****************************************************************************

#if DBG == 0

#define START_TRYCATCH do { TRY
#define END_TRYCATCH(_hr, _hitobj, _IFStr) \
    CATCH(nException) \
        HandleErrorMissingFilename(IDE_SCRIPT_ENGINE_GPF, _hitobj,TRUE,nException,_IFStr,_pFuncName); \
        _hr = nException; \
    END_TRY } while(0)
#else
#define START_TRYCATCH do {
#define END_TRYCATCH(_hr, _hitobj, _IFStr) } while (0)
#endif

//*****************************************************************************
// Definition of TRYCATCH_INT which is used by all of the TRYCATCH macros
// described above.
//*****************************************************************************

#define TRYCATCH_INT(_s, _hr, _hitobj, _IFStr) \
    START_TRYCATCH \
    TEST_THROW_ERROR \
    _hr = _s; \
    END_TRYCATCH(_hr, _hitobj, _IFStr)

//*****************************************************************************
// Here are the actual definitions of the TRYCATCH macros described above.
//*****************************************************************************

#define TRYCATCH(_s, _IFStr) \
    do { \
        HRESULT     _tempHR; \
        TRYCATCH_INT(_s, _tempHR, m_pHitObj, _IFStr); \
    } while (0)
#define TRYCATCH_HR(_s, _hr, _IFStr) TRYCATCH_INT(_s, _hr, m_pHitObj, _IFStr)
#define TRYCATCH_NOHITOBJ(_s, _IFStr) \
    do { \
        HRESULT     _tempHR; \
        TRYCATCH_INT(_s, _tempHR, NULL, _IFStr); \
    } while (0)
#define TRYCATCH_HR_NOHITOBJ(_s, _hr, _IFStr) TRYCATCH_INT(_s, _hr, NULL, _IFStr)

/*===================================================================
CActiveScriptEngine::CActiveScriptEngine

Constructor for CActiveScriptEngine object

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
CActiveScriptEngine::CActiveScriptEngine()
	: m_cRef(1), m_fInited(FALSE), m_fZombie(FALSE), m_fScriptLoaded(FALSE), 
	  m_fObjectsLoaded(FALSE), m_fTemplateNameAllocated(FALSE),
	  m_pAS(NULL), m_pASP(NULL), m_pDisp(NULL), m_pHIUpdate(NULL), m_lcid(LOCALE_SYSTEM_DEFAULT),
	  m_pHitObj(NULL), m_szTemplateName(NULL), m_fScriptAborted(FALSE), m_fScriptTimedOut(FALSE), 
	  m_fScriptHadError(FALSE), m_fCorrupted(FALSE), m_fBeingDebugged(FALSE), m_pTemplate(NULL),
	  m_dwInstanceID(0xBADF00D), m_dwSourceContext(0xBADF00D)
	{
	}

/*===================================================================
CActiveScriptEngine::~CActiveScriptEngine

Destructor for CActiveScriptEngine object

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
CActiveScriptEngine::~CActiveScriptEngine()
	{

	if (m_fTemplateNameAllocated)
    	delete[] m_szTemplateName;

	if (m_pTemplate)
		m_pTemplate->Release();
	}

/*===================================================================
CActiveScriptEngine::FinalRelease

Call this when we are done with the object - Like release but
it removes all of the interfaces we got, so that the ref.
count can vanish when last external user is done with the engine

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
ULONG CActiveScriptEngine::FinalRelease()
	{
    static const char *_pFuncName = "CActiveScriptEngine::FinalRelease()";

	if (m_pDisp)
		{
		TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
		m_pDisp = NULL;
		}

	if (m_pASP)
		{
		TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
		m_pASP = NULL;
		}

	if (m_pHIUpdate)
		{
		TRYCATCH(m_pHIUpdate->Release(),"IHostInfoUpdate::Release()");
		m_pHIUpdate = NULL;
		}

	if (m_pAS)
		{
		HRESULT hr;
		
		// First "close" the engine
		TRYCATCH_HR(m_pAS->Close(), hr, "IActiveScript::Close()");
		Assert(SUCCEEDED(hr));

		// Then we can release it
		TRYCATCH(m_pAS->Release(), "IActiveScript::Release()");

		m_pAS = NULL;
		}

	ULONG cRefs = Release();
	Assert (cRefs == 0);
	return cRefs;
	}

/*===================================================================
CActiveScriptEngine::Init

Init the script site object.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::Init
(
PROGLANG_ID proglang_id,
LPCTSTR szTemplateName,
LCID lcid,
CHitObj *pHitObj,
CTemplate *pTemplate,
DWORD dwSourceContext
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::Init()";
	HRESULT hr;
	UINT cTrys = 0;
	
	if (m_fInited)
		{
		Assert(FALSE);
		return(ERROR_ALREADY_INITIALIZED);
		}

	// Note: need to init these first, because we will need them if AS calls back into us during init.
	m_lcid = lcid;
	m_proglang_id = proglang_id;
	m_pHitObj = pHitObj;
	m_dwSourceContext = dwSourceContext;
	m_dwInstanceID = pHitObj->DWInstanceID();
	m_pTemplate = pTemplate;
	m_pTemplate->AddRef();

lRetry:
	// Create an instance of the script engine for the given language
	hr = CoCreateInstance(proglang_id, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void**)&m_pAS);
	if (FAILED(hr))
		{
		/*
		 * If some control (or other component) does a CoUninitialize on our thread, we will
		 * never be able to create another object.  In this case, we will get back CO_E_NOTINITIALIZED.
		 * Try (once) to re-initialize and then create the object
		 */
		if (hr == CO_E_NOTINITIALIZED && cTrys++ == 0)
			{
			MSG_Error(IDS_COUNINITIALIZE);
			hr = CoInitialize(NULL);
            if (SUCCEEDED(hr))
			    goto lRetry;
			}
		goto LFail;
		}

    // Remember template name
    hr = StoreTemplateName(szTemplateName);
	if (FAILED(hr))
		goto LFail;
    
	// Tell ActiveScripting that this is our script site
    TRYCATCH_HR(m_pAS->SetScriptSite((IActiveScriptSite *)this), hr, "IActiveScript::SetScriptSite()");
	if (FAILED(hr))
		{
		goto LFail;
		}

	// Tell ActiveScripting which exceptions we want caught
	IActiveScriptProperty *pScriptProperty;
    TRYCATCH_HR(m_pAS->QueryInterface(IID_IActiveScriptProperty, reinterpret_cast<void **>(&pScriptProperty)), hr, "IActiveScript::QueryInterface()");
    if (SUCCEEDED(hr))
    	{
    	static const int rgnExceptionsToCatch[] =
							{
							STATUS_GUARD_PAGE_VIOLATION      ,
							STATUS_DATATYPE_MISALIGNMENT     ,
							STATUS_ACCESS_VIOLATION          ,
							STATUS_INVALID_HANDLE            ,
							STATUS_NO_MEMORY                 ,
							STATUS_ILLEGAL_INSTRUCTION       ,
							STATUS_INVALID_DISPOSITION       , // what's this?  Do we need to catch it?
							STATUS_ARRAY_BOUNDS_EXCEEDED     ,
							STATUS_FLOAT_DENORMAL_OPERAND    ,
							STATUS_FLOAT_DIVIDE_BY_ZERO      ,
							STATUS_FLOAT_INVALID_OPERATION   ,
							STATUS_FLOAT_OVERFLOW            ,
							STATUS_FLOAT_STACK_CHECK         ,
							STATUS_INTEGER_DIVIDE_BY_ZERO    ,
							STATUS_INTEGER_OVERFLOW          ,
							STATUS_PRIVILEGED_INSTRUCTION    ,
							STATUS_STACK_OVERFLOW
							};

    	VARIANT varBoolTrue;
    	VARIANT varExceptionType;

    	V_VT(&varExceptionType) = VT_I4;
    	V_VT(&varBoolTrue) = VT_BOOL;
    	V_BOOL(&varBoolTrue) = -1;

		for (int i = 0; i < (sizeof rgnExceptionsToCatch) / sizeof(int); ++i)
			{
			V_I4(&varExceptionType) = rgnExceptionsToCatch[i];
			TRYCATCH(pScriptProperty->SetProperty(SCRIPTPROP_CATCHEXCEPTION, &varExceptionType, &varBoolTrue), "IActiveScriptProperty::SetProperty");
			}

		pScriptProperty->Release();
		}

	// Get ActiveScriptParse interface
	hr = GetASP();
	if (FAILED(hr))
		goto LFail;

	// Tell the script parser to init itself
    TRYCATCH_HR(m_pASP->InitNew(), hr, "IActiveScriptParse::InitNew()");
	if (FAILED(hr))
		goto LFail;

	// Get IDisp interface
	hr = GetIDisp();
	if (FAILED(hr))
		goto LFail;

	// Get IHostInfoUpdate interface
	hr = GetIHostInfoUpdate();
	if (FAILED(hr))
		goto LFail;

	m_fInited = TRUE;

LFail:
	if (FAILED(hr))
		{
		if (m_pAS)
			{
			TRYCATCH(m_pAS->Release(),"IActiveScript::Release()");
			m_pAS = NULL;
			}
		if (m_pASP)
			{
            TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
			m_pASP = NULL;
			}
		if (m_pDisp)
			{
			TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
			m_pDisp = NULL;
			}
		if (m_pTemplate)
			{
			m_pTemplate->Release();
			m_pTemplate = NULL;
			}
		if (m_pHIUpdate)
		    {
		    TRYCATCH(m_pHIUpdate->Release(),"IHostInfoUpdate::Release()");
		    m_pHIUpdate = NULL;
		    }
		}

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::StoreTemplateName

Stores template name inside CActiveScriptEngine. Allocates
buffer or uses internal one if the name fits.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Might allocate memory for long template names
===================================================================*/
HRESULT CActiveScriptEngine::StoreTemplateName
(
LPCTSTR szTemplateName
)
    {
    DWORD cch = _tcslen(szTemplateName);

    if (((cch+1)*sizeof(TCHAR)) <= sizeof(m_szTemplateNameBuf))
        {
        m_szTemplateName = m_szTemplateNameBuf;
        m_fTemplateNameAllocated = FALSE;
        }
    else
        {
    	m_szTemplateName = new TCHAR[cch+1];
    	if (!m_szTemplateName)
            return E_OUTOFMEMORY;
        m_fTemplateNameAllocated = TRUE;
        }
        
	_tcscpy(m_szTemplateName, szTemplateName);
    return S_OK;
    }

/*===================================================================
CActiveScriptEngine::GetASP

Get an ActiveScriptParser interface from ActiveScripting

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Fills in member variables
===================================================================*/
HRESULT CActiveScriptEngine::GetASP
(
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::GetASP()";
	HRESULT hr;

	Assert(m_pASP == NULL);
	
	m_pASP = NULL;
			
	// Get OLE Scripting parser interface, if any
    TRYCATCH_HR(m_pAS->QueryInterface(IID_IActiveScriptParse, (void **)&m_pASP), hr, "IActiveScript::QueryInterface()");

	if (m_pASP == NULL && SUCCEEDED(hr))
		hr = E_FAIL;
	if (FAILED(hr))
		{
		goto LFail;
		}

LFail:
	if (FAILED(hr))
		{
		if (m_pASP)
			{
            TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
			m_pASP = NULL;
			}
		}

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::GetIDisp

Get an IDispatch interface from ActiveScripting

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Fills in member variables
===================================================================*/
HRESULT CActiveScriptEngine::GetIDisp
(
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::GetIDisp()";

	HRESULT hr;

	Assert(m_pDisp == NULL);
	
	m_pDisp = NULL;
			
	// Get an IDispatch interface to be able to call functions in the script
    
    TRYCATCH_HR(m_pAS->GetScriptDispatch(NULL, &m_pDisp),hr,"IActiveScript::GetScriptDispatch()");

	if (m_pDisp == NULL && SUCCEEDED(hr))
		hr = E_FAIL;
	if (FAILED(hr))
		{
		goto LFail;
		}

LFail:
	if (FAILED(hr))
		{
		if (m_pDisp)
			{
			TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
			m_pDisp = NULL;
			}
		}

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::GetIHostInfoUpdate

Get an IHostInfoUpdate interface from ActiveScripting.
This interface is used to advise the scripting engine that
we have new information about the host (change in LCID for example)
If we can't find the interface, we exit succesfully anyway.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Fills in member variables
===================================================================*/
HRESULT CActiveScriptEngine::GetIHostInfoUpdate
(
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::GetIHostInfoUpdate()";
	HRESULT hr = S_OK;

	Assert(m_pHIUpdate == NULL);
	m_pHIUpdate = NULL;
			
	// Get an IHostInfoUpdate interface to be able to call functions in the script
    TRYCATCH_HR(m_pAS->QueryInterface(IID_IHostInfoUpdate, (void **) &m_pHIUpdate),
                hr,
                "IActiveScript::QueryInterface()");

	Assert(SUCCEEDED(hr) || hr == E_NOINTERFACE);

	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::ResetToUninitialized

When we want to reuse and engine, we reset it to an uninited state
before putting it on the FSQ

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::ResetToUninitialized
(
IASPObjectContextCustom *pTxnScriptContextCustom
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::ResetToUninitialized()";
	HRESULT hr = S_OK;
	
	// Reset our flags
	m_fScriptAborted = FALSE;
	m_fScriptTimedOut = FALSE;
	m_fScriptHadError = FALSE;
	m_fBeingDebugged = FALSE;

	// Release interfaces, they will need to be re-gotten when
	// the engine is reused
	if (m_pASP)
		{
        TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
		m_pASP = NULL;
		}

	if (m_pDisp)
		{
		TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
		m_pDisp = NULL;
		}

	if(m_pHIUpdate)
		{
		TRYCATCH(m_pHIUpdate->Release(),"IHostInfoUpdate::Release()");
		m_pHIUpdate = NULL;
		}

	// Hitobj will no longer be valid
	m_pHitObj = NULL;

	// Set the script state to Uninited
	if (m_pAS)
		{
		if (pTxnScriptContextCustom)
                       { 
#ifdef _WIN64
                        // Win64 fix -- use UINT64 instead of LONG_PTR since LONG_PTR is broken for Win64 1/21/2000
			TRYCATCH_HR(pTxnScriptContextCustom->ResetScript(
                        reinterpret_cast<UINT64>(static_cast<CScriptEngine *>(this))),
                        hr,
                        "IASPObjectContextCustom::ResetScript()");
#else
			TRYCATCH_HR(pTxnScriptContextCustom->ResetScript(
                        reinterpret_cast<LONG_PTR>(static_cast<CScriptEngine *>(this))),
                        hr,
                        "IASPObjectContextCustom::ResetScript()");
#endif
                        }
		else
                        {
                        TRYCATCH_HR(ResetScript(), hr, "IActiveScript::SetScriptState()");
                        }
		}

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::ReuseEngine

Reusing an engine from the FSQ.  Reset stuff

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Sets member variables.
===================================================================*/
HRESULT CActiveScriptEngine::ReuseEngine
(
CHitObj *pHitObj,
CTemplate *pTemplate,
DWORD dwSourceContext,
DWORD dwInstanceID
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::ReuseEngine()";
	HRESULT hr = S_OK;

	/* NOTE: we must reset the hitobj & other members BEFORE calling
	 * any Active Scripting methods (esp. SetScriptSite)  This is
	 * because SetScriptSite queries us for the debug application, which
	 * relies on the hitobj being set.
	 */

	// reset the hitobj
	m_pHitObj = pHitObj;

	// Reset the debug document
	if (pTemplate)
		{
		if (m_pTemplate)
			m_pTemplate->Release();

		m_dwSourceContext = dwSourceContext;
		m_dwInstanceID = dwInstanceID;
		m_pTemplate = pTemplate;
		m_pTemplate->AddRef();
		}

	// If the engine is in the UNITIALIZED state ONLY then tell ActiveScripting
	// that this is our script site.  (Scripts in the debug cache are already initialized)
	SCRIPTSTATE nScriptState;
    TRYCATCH_HR(m_pAS->GetScriptState(&nScriptState), hr, "IActiveScript::GetScriptState()");
	if (FAILED(hr))
		goto LFail;

	if (nScriptState == SCRIPTSTATE_UNINITIALIZED)
		{
        TRYCATCH_HR(m_pAS->SetScriptSite(static_cast<IActiveScriptSite *>(this)),hr, "IActiveScript::SetScriptState()");
		if (FAILED(hr))
			goto LFail;
		}

	// Get ActiveScriptParse interface
	hr = GetASP();
	if (FAILED(hr))
		goto LFail;

	// Get IDisp interface
	hr = GetIDisp();
	if (FAILED(hr))
		goto LFail;

	// Get IHostInfoUpdate interface
	hr = GetIHostInfoUpdate();
	if (FAILED(hr))
		goto LFail;

	AssertValid();
LFail:
	return(hr);
	}

/*===================================================================
CActiveScriptEngine::MakeClone

We are cloning a running script engine.  Fill this new ActiveScriptEngine
with the cloned ActiveScript.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::MakeClone
(
PROGLANG_ID proglang_id,
LPCTSTR szTemplateName,
LCID lcid,
CHitObj *pHitObj,
CTemplate *pTemplate,
DWORD dwSourceContext,
DWORD dwInstanceID,
IActiveScript *pAS			// The cloned script engine
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::MakeClone()";
	HRESULT hr;
	
	if (m_fInited)
		{
		Assert(FALSE);
		return(ERROR_ALREADY_INITIALIZED);
		}

	// Note: need to init these first, because we will need them if AS calls back into us during init.
	m_lcid = lcid;
	m_proglang_id = proglang_id;
	m_pHitObj = pHitObj;

	m_pAS = pAS;

	StoreTemplateName(szTemplateName);

	if (m_pTemplate)
		m_pTemplate->Release();

	m_dwSourceContext = dwSourceContext;
	m_dwInstanceID = dwInstanceID;
	m_pTemplate = pTemplate;
	m_pTemplate->AddRef();

	// We are not yet inited fully but SetScriptSite may call back into us so we must flag inited now.
	m_fInited = TRUE;

	// Tell ActiveScripting that this is our script site
    TRYCATCH_HR(m_pAS->SetScriptSite((IActiveScriptSite *)this), hr, "IActiveScript::SetScriptSite()");

	if (FAILED(hr))
		{
		goto LFail;
		}

	// Get ActiveScriptParse interface
	hr = GetASP();
	if (FAILED(hr))
		goto LFail;

	// Get IDisp interface
	hr = GetIDisp();
	if (FAILED(hr))
		goto LFail;

	// Get IHostInfoUpdate interface
	hr = GetIHostInfoUpdate();
	if (FAILED(hr))
		goto LFail;

	// Because we are a clone of an already loaded engine, we have script and objects loaded.
	m_fScriptLoaded = TRUE;
	m_fObjectsLoaded = TRUE;

	// We should be valid now.
	AssertValid();
	
LFail:
	if (FAILED(hr))
		{
		m_fInited = FALSE;
		
		if (m_pAS)
			{
			// dont release the passed in script engine on failure
			m_pAS = NULL;
			}
		if (m_pASP)
			{
			TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
			m_pASP = NULL;
			}
		if (m_pDisp)
			{
			TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
			m_pDisp = NULL;
			}
		if (m_pTemplate)
			{
			m_pTemplate->Release();
			m_pTemplate = NULL;
			}
		if (m_pHIUpdate)
		    {
		    TRYCATCH(m_pHIUpdate->Release(),"IHostInfoUpdate::Release()");
		    m_pHIUpdate = NULL;
		    }
		}

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::InterruptScript

Stop the script from running

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Stops the script from running
===================================================================*/
HRESULT CActiveScriptEngine::InterruptScript
(
BOOL fAbnormal				// = TRUE
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::InterruptScript()";
	HRESULT hr;
	EXCEPINFO excepinfo;

	AssertValid();

	// Fill in the excepinfo.  This will be passed to OnScriptError
	memset(&excepinfo, 0x0, sizeof(EXCEPINFO));
	if (fAbnormal)
		{
		m_fScriptTimedOut = TRUE;
		excepinfo.wCode = ERROR_SERVICE_REQUEST_TIMEOUT;
		}
	else
		{
		m_fScriptAborted = TRUE;
		excepinfo.wCode = RESPONSE_END_ERRORCODE;		// Error code to ourselves - means Response.End was invoked
		}
	
        TRYCATCH_HR(m_pAS->InterruptScriptThread(SCRIPTTHREADID_BASE,		// The thread in which the engine was instantiated
		           						  &excepinfo,
								          0),
                    hr,
                    "IActiveScript::InterruptScriptThread()");
	return(hr);
	}

/*===================================================================
CActiveScriptEngine::UpdateLocaleInfo

Advise the script engine that we want to update the lcid or
code page

Returns:
	HRESULT.  S_OK on success.
===================================================================*/
HRESULT CActiveScriptEngine::UpdateLocaleInfo
(
hostinfo hiNew
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::UpdateLocaleInfo()";
	HRESULT hr = S_OK;
	
	// If no IUpdateHost ineterface is available 
	// just skip the call to UpdateInfo;
	if (m_pHIUpdate)
		TRYCATCH_HR(m_pHIUpdate->UpdateInfo(hiNew), hr, "IHostInfoUpdate::UpdateInfo()");

	return hr;
	}

#ifdef DBG
/*===================================================================
CActiveScriptEngine::AssertValid

Test to make sure that the CActiveScriptEngine object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
	None.
===================================================================*/
VOID CActiveScriptEngine::AssertValid() const
	{
	Assert(m_fInited);
	Assert(m_pAS != NULL);
	Assert(m_pTemplate != NULL);
	}
#endif // DBG

/*
 *
 *
 *
 * I U n k n o w n   M e t h o d s
 *
 *
 *
 *
 */ 

/*===================================================================
CActiveScriptEngine::QueryInterface
CActiveScriptEngine::AddRef
CActiveScriptEngine::Release

IUnknown members for CActiveScriptEngine object.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::QueryInterface
(
REFIID riid,
PVOID *ppvObj
)
	{
	if (ppvObj == NULL)
		{
		Assert(FALSE);
		return E_POINTER;
		} 

	*ppvObj = NULL;

	if (IsEqualIID(riid, IID_IUnknown))
	    {
	    // this IS NOT derived directly from IUnknown
	    // typecast this to something that IS
		*ppvObj = static_cast<IActiveScriptSite *>(this);
        }
	else if (IsEqualIID(riid, IID_IActiveScriptSite))
	    {
		*ppvObj = static_cast<IActiveScriptSite *>(this);
        }
	else if (IsEqualIID(riid, IID_IActiveScriptSiteDebug))
	    {
		*ppvObj = static_cast<IActiveScriptSiteDebug *>(this);
        }
	else if (IsEqualIID(riid, IID_IHostInfoProvider))
	    {
		*ppvObj = static_cast<IHostInfoProvider *>(this);
        }
        
	if (*ppvObj != NULL)
		{
		AddRef();
		return(S_OK);
		}
	
	return(E_NOINTERFACE);
	}

STDMETHODIMP_(ULONG) CActiveScriptEngine::AddRef()
	{
	++m_cRef;

	return(m_cRef);
	}

STDMETHODIMP_(ULONG) CActiveScriptEngine::Release()
	{
	if (--m_cRef)
		return(m_cRef);

	delete this;
	return(0);
	}

/*
 *
 *
 *
 * I A c t i v e S c r i p t S i t e   M e t h o d s
 *
 *
 *
 *
 */ 

/*===================================================================
CActiveScriptEngine::GetLCID

Provide the local id for the script to the script engine.

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::GetLCID
(
LCID *plcid
)
	{
	// It is OK to call this before we are fully inited.
	//AssertValid();

	*plcid = ((CActiveScriptEngine *)this)->m_lcid;
	
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::GetItemInfo

Provide requested info for a named item to the script engine.  May be
asked for IUnknown, ITypeInfo or both.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::GetItemInfo
(
LPCOLESTR pcszName,
DWORD dwReturnMask,IUnknown **ppiunkItem,
ITypeInfo **ppti
)
	{
	HRESULT hr;
	AssertValid();
	
	// Assume none
	if (ppti)
		*ppti = NULL;
	if (ppiunkItem)
		*ppiunkItem = NULL;

    CHitObj *pHitObj = m_pHitObj;
    if (pHitObj == NULL)
        {
        // could happen when debugging and re-initializing
        // the scripting engine when storing it in the template
        // in this case GetItemInfo() is called for TYPELIB stuff
        ViperGetHitObjFromContext(&pHitObj);
    	if (pHitObj == NULL)
	        return TYPE_E_ELEMENTNOTFOUND;
        }

    // Calculate name length once
    
    DWORD cbName = CbWStr((LPWSTR)pcszName);
    
	// Special case for intrinsics
	
	IUnknown *punkIntrinsic = NULL;
	hr = pHitObj->GetIntrinsic((LPWSTR)pcszName, cbName, &punkIntrinsic);
	
	if (hr == S_OK)
	    {
    	if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
	    	{
    		Assert(ppiunkItem);
    		Assert(punkIntrinsic);
    		punkIntrinsic->AddRef();
    		*ppiunkItem = punkIntrinsic;
		    }
		return S_OK;
	    }
	else if (hr == S_FALSE)
	    {
	    // Missing intrinsic case
	    return TYPE_E_ELEMENTNOTFOUND;
	    }

	// It's not an intrinsic -- try component collection
	
	CComponentObject *pObj = NULL;
	hr = pHitObj->GetComponent(csUnknown, (LPWSTR)pcszName, cbName, &pObj);

	if (hr == S_OK) // object found
	    {
    	if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
	    	{
    		Assert(ppiunkItem != NULL);
	    	hr = pObj->GetAddRefdIUnknown(ppiunkItem);
		    }

		if (SUCCEEDED(hr))
		    return S_OK;
	    }

	// Could'n find -- output an error

	HandleItemNotFound(pcszName);
    	
	return hr;
	}

/*===================================================================
CActiveScriptEngine::HandleItemNotFound

Error handling due to item not found in GetItemInfo().

Parameters:
    pcszName        name of the item not found

Returns:
===================================================================*/
void CActiveScriptEngine::HandleItemNotFound
(
LPCOLESTR pcszName
)
    {
    HRESULT         hr = TYPE_E_ELEMENTNOTFOUND;
    
	CHAR 	        *szErrT		= NULL;
	CHAR	        szEngineT[255];
	CHAR	        szErr[255];
	TCHAR	        *szFileNameT = NULL;
    CHAR            *szFileName = NULL;
	CHAR 	        *szLineNum  = NULL;
	CHAR	        *szEngine	= NULL;
	CHAR	        *szErrCode	= NULL;
	CHAR	        *szLongDes	= NULL;
	ULONG 	        ulLineError = 0;
	DWORD	        dwMask = 0x3;
	BOOLB	        fGuessedLine = FALSE;
	UINT	        ErrId = IDE_OOM;
    CWCharToMBCS    convName;

	m_pTemplate->GetScriptSourceInfo(m_dwSourceContext, ulLineError, &szFileNameT, NULL, &ulLineError, NULL, &fGuessedLine);
	//Make a copy for error handling
#if UNICODE
	szFileName = StringDupUTF8(szFileNameT);
#else
    szFileName = StringDupA(szFileNameT);
#endif

	//get line num
	if (ulLineError)
		{
		szLineNum = (CHAR *)malloc(sizeof(CHAR)*10);
		if (szLineNum)
			_ltoa(ulLineError, szLineNum, 10);
		else
			{
			hr = E_OUTOFMEMORY;
			goto lCleanUp;
			}
		}
	//get engine
	CchLoadStringOfId(IDS_ENGINE, szEngineT, 255);
	szEngine = StringDupA(szEngineT);

	//get informative string

    if (FAILED(hr = convName.Init((LPWSTR)pcszName))) {
        goto lCleanUp;
    }
		
	// Error string is: "Failed to create object 'objname'.  Error code (code)."
	ErrId = IDE_SCRIPT_CANT_LOAD_OBJ;
	LoadErrResString(ErrId, &dwMask, NULL, NULL, szErr);
	if (szErr)
		{
		INT	cch = strlen(szErr);
		szErrT = (CHAR *)malloc((CHAR)(cch + strlen(convName.GetString()) + 1));
		if (!szErrT)
			{
			hr = E_OUTOFMEMORY;
			goto lCleanUp;
			}

		sprintf(szErrT, szErr, convName.GetString());
		szErrCode = SzScodeToErrorCode(hr);
		}
		
lCleanUp:		
	
	//szErrT is the long description		
	HandleError(ErrId, szFileName, szLineNum, szEngine, szErrCode, szErrT, NULL, m_pHitObj);
    }

/*===================================================================
CActiveScriptEngine::GetDocVersionString

Return a string uniquely identifying the current document version
from Denali's point of view.

I dont think we need this. It is mostly interesting if
the scripting engine is persisting scripts so that it can decide
if a script needs a recompile.  Since the scripting engine is
not persisting anything for us, we dont need to do anything here.

Returns:
	HRESULT.  Always returns E_NOTIMPL.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::GetDocVersionString
(
BSTR *pbstrVersion
)
	{
	return(E_NOTIMPL);
	}

/*===================================================================
CActiveScriptEngine::RequestItems

If this is called, it means that the Script engine wants us to call
IActiveScript::AddNameItem() for each named item associated with the 
script.

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::RequestItems
(
BOOL fPersistNames			// = TRUE
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::RequestItems()";
	HRESULT hr = S_OK;

	AssertValid();
	Assert (m_pHitObj != NULL);

	DWORD grf = SCRIPTITEM_ISVISIBLE;
	if (fPersistNames)
		grf |= SCRIPTITEM_ISPERSISTENT;

	/*
	 * Intrinsics
	 */

    START_TRYCATCH

	if (m_pHitObj->FIsBrowserRequest())
	    {
        hr = m_pAS->AddNamedItem(WSZ_OBJ_RESPONSE, grf);
        Assert(SUCCEEDED(hr));

        hr = m_pAS->AddNamedItem(WSZ_OBJ_REQUEST, grf);
        Assert(SUCCEEDED(hr));
        }
	
    hr = m_pAS->AddNamedItem(WSZ_OBJ_SERVER, grf);
	Assert(SUCCEEDED(hr));

	if (m_pHitObj->FHasSession())
	    {
        hr = m_pAS->AddNamedItem(WSZ_OBJ_SESSION, grf);
	    Assert(SUCCEEDED(hr));
	    }

    hr = m_pAS->AddNamedItem(WSZ_OBJ_APPLICATION, grf);
	Assert(SUCCEEDED(hr));
	
    hr = m_pAS->AddNamedItem(WSZ_OBJ_OBJECTCONTEXT, grf);
	Assert(SUCCEEDED(hr));

	/*
	 * Components from different collections
	 */

	CComponentIterator CompIter(m_pHitObj);
    LPWSTR strObjName;
        
    while (strObjName = CompIter.WStrNextComponentName())
        {
   		hr = m_pAS->AddNamedItem(strObjName, grf);
        if (FAILED(hr))
   			break;
        }
	
	Assert(SUCCEEDED(hr));

	/*
	 * Type library wrappers. (Has to be last in order to be called
	 * only when everything else fails.
	 */

	// Special flag value for typelib wrappers
	grf |= SCRIPTITEM_GLOBALMEMBERS;

	if (m_pHitObj->PTypeLibWrapper())
	    {
        hr = m_pAS->AddNamedItem(WSZ_OBJ_ASPPAGETLB, grf);
    	Assert(SUCCEEDED(hr));
	    }

    // GLOBAL.ASA typelib wrapper is added always
    // because each page does not pick up changes to
    // GLOBAL.ASA and there's no way to figure out
    // when TYPELIBs get added to GLOBAL.ASA
    hr = m_pAS->AddNamedItem(WSZ_OBJ_ASPGLOBALTLB, grf);
  	Assert(SUCCEEDED(hr));

    END_TRYCATCH(hr, m_pHitObj, "IActiveScript::AddNamedItem");

	// We are required to return OK
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::RequestTypeLibs 

If this is called, it means that the Script engine wants us to call
IActiveScript::AddTypeLib() for each typelib associated with the 
script.  It is unclear to me that this will ever be called in our case.

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::RequestTypeLibs()
	{
	AssertValid();

	// We have no typelibs for the namespace	
	
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::OnEnterScript

Host callback to indicate that the script has started executing

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnEnterScript()
	{
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::OnLeaveScript

Host callback to indicate that the script has stopped executing

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnLeaveScript()
	{
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::GetHostInfo

Host callback to for furnishing LCID and code page info

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::GetHostInfo(hostinfo hostinfoRequest, void **ppvInfo)
	{

	Assert(hostinfoRequest == hostinfoLocale || hostinfoRequest == hostinfoCodePage);

	HRESULT hr = S_OK;
	
	if (hostinfoRequest == hostinfoLocale)
		{
		// Allocate an LCID and set it to the current
		// value for the HitObj
		*ppvInfo = CoTaskMemAlloc(sizeof(UINT));
		if (!*ppvInfo)
			hr = E_OUTOFMEMORY;
		else
			(*(UINT *)*ppvInfo) = m_pHitObj->GetLCID();
		}
	else if (hostinfoRequest == hostinfoCodePage)
		{
		// Allocate an code page and set it to the current
		// value for the HitObj
		*ppvInfo = CoTaskMemAlloc(sizeof(UINT));
		if (!*ppvInfo)
			hr = E_OUTOFMEMORY;
		else
			(*(UINT *)*ppvInfo) = m_pHitObj->GetCodePage();
		}
	else
		hr = E_FAIL;
		
	return(hr);
	}

/*===================================================================
CActiveScriptEngine::OnScriptTerminate

Host callback to indicate that the script has completed.

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnScriptTerminate
(
const VARIANT *pvarResult,
const EXCEPINFO *pexcepinfo
)
	{
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::OnStateChange

Host callback to indicate that the script has changed state (e.g. from
Uninitialized to Loaded.)

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnStateChange
(
SCRIPTSTATE ssScriptState
)
	{
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::OnScriptError

Host callback to indicate that an error has occured in the script.
We should handle the error.  We will return E_FAIL to indicate that we 
want the script to terminate.

Returns:
	HRESULT.  E_FAIL -- Terminate executing the script.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnScriptError
(
IActiveScriptError __RPC_FAR *pscripterror
)
	{
	Assert(pscripterror);
	AssertValid();

	// Bug 153: If we terminate the script due to Response.End, dont show an error
	// NOTE: ActiveXScripting was failing to pass us our excepinfo.  Use member flags
	// ALSO: ActiveXScripting has fixed the problem of failing to pass us our excepinfo, but the
	// way we are doing this with flags works just fine.  
	if (m_fScriptAborted)
		{
		goto LRet;
		}
	
	if (m_fScriptTimedOut)
		{
            //Load Default Engine from resource
        char  szEngine[128];
        DWORD cch;
        cch = CchLoadStringOfId(IDS_ENGINE, szEngine, 128);
        szEngine[cch] = '\0';
        CHAR    *szFileName;
#if UNICODE
        szFileName = StringDupUTF8(m_pHitObj->PSzCurrTemplateVirtPath());
#else
        szFileName = StringDupA(m_pHitObj->PSzCurrTemplateVirtPath());
#endif

	    HandleError(IDE_SCRIPT_TIMEOUT, 
                    szFileName, 
                    NULL, 
                    StringDupA(szEngine), 
                    NULL, 
                    NULL, 
                    NULL, 
                    m_pHitObj,
                    NULL);

		if(m_pHitObj)
			{
			m_pHitObj->SetExecStatus(eExecTimedOut);
			}
		goto LRet;
		}

	// OnScriptErrorDebug calls OnScriptError.  use this test to be sure we don't log error
	// twice if we are called twice.  (won't happen with present debugging implementation,
	// but externals may change.)
	if (m_fScriptHadError)
		{
		goto LRet;
		}

	m_fScriptHadError = TRUE;				// Note that the script had an error so we can abort transactions (if any)
		
	if (pscripterror)
		{
		// If there was an error in the script, first see if we should pop up the debugger
		// (ONLY bring up Script Debugger; VID will do the right thing on its own)
		//
		// NEW CHANGE: always bring error description to browser, since VID does not
		// give sufficient description.
		//
		if (FCaesars() && m_pHitObj->PAppln()->FDebuggable())
			DebugError(pscripterror, m_pTemplate, m_dwSourceContext, g_pDebugApp);

		HandleError(pscripterror, m_pTemplate, m_dwSourceContext, NULL, m_pHitObj);
		}

LRet:
	// Bug 99718 return S_OK to tell the script engine that we handled the error ok.
	// Returning E_FAIL would not stop the scripting engine, this was a doc error.
	return(S_OK);
	}


/*
 *
 *
 *
 * I A c t i v e S c r i p t S i t e D e b u g   M e t h o d s
 *
 *
 *
 *
 */ 

/*===================================================================
CActiveScriptEngine::OnScriptErrorDebug

Callback for debugger to query host on what to do on exception.

NOTE: Theoretically, we would set *pfCallOnScriptErrorWhenContinuing
      to TRUE and not call OnScriptError, and set *pfEnterDebugger
      to TRUE or FALSE based on whether debugging is enabled and
      whether user wants to debug.

      However, in practice, *pfCallOnScriptErrorWhenContinuing is
      not honored (OnScriptError is NOT called in any case), and
      the VID team wants us to pretend like we don't implement
      this interface.  However, we always need our "OnScriptError"
      code to execute, so we call our OnScriptError function
      explicitly, then fail

Returns:
	HRESULT.  always returns E_NOTIMPL

Side effects:
	calls OnScriptError
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnScriptErrorDebug
(
IActiveScriptErrorDebug *pscripterror,
BOOL *pfEnterDebugger,
BOOL *pfCallOnScriptErrorWhenContinuing
)
	{
	OnScriptError(pscripterror);
	return E_NOTIMPL;
	} 

/*===================================================================
CActiveScriptEngine::GetDocumentContextFromPosition

Create a document context (file + offset + length) from an offset in the
script.

Returns:
	HRESULT.  S_OK on success.
===================================================================*/
HRESULT CActiveScriptEngine::GetDocumentContextFromPosition
(
/* [in] */ DWORD_PTR dwSourceContext,
/* [in] */ ULONG cchTargetOffset,
/* [in] */ ULONG cchText,
/* [out] */ IDebugDocumentContext **ppDocumentContext)
	{
    static const char *_pFuncName = "CActiveScriptEngine::GetDocumentContextFromPosition()";
	TCHAR *szSourceFile;
	ULONG cchSourceOffset;
	ULONG cchSourceText;
	IActiveScriptDebug *pASD;

	// Convert offset in script engine to source location, and get debugging interfaces
	m_pTemplate->GetSourceOffset(m_dwSourceContext, cchTargetOffset, &szSourceFile, &cchSourceOffset, &cchSourceText);
    
    HRESULT  hr;

    TRYCATCH_HR(m_pAS->QueryInterface(IID_IActiveScriptDebug, reinterpret_cast<void **>(&pASD)), 
                                      hr,
                                      "IActiveScript::QueryInterface()");

    if (FAILED(hr))
        return(E_FAIL);

	// If this is in the main file, create a document context based on the CTemplate compiled source
	if (_tcscmp(szSourceFile, m_pTemplate->GetSourceFileName()) == 0)
		{
		if (
			(*ppDocumentContext = new CTemplateDocumentContext(m_pTemplate, cchSourceOffset, cchSourceText, pASD, m_dwSourceContext, cchTargetOffset))
			 == NULL
		   )
			{
			pASD->Release();
			return E_OUTOFMEMORY;
			}
		}

	// source refers to an include file, so create a documet context based on cached CIncFile dependency graph
	else
		{
		CIncFile *pIncFile;
		if (FAILED(g_IncFileMap.GetIncFile(szSourceFile, &pIncFile)))
			return E_FAIL;

		if (
			(*ppDocumentContext = new CIncFileDocumentContext(pIncFile, cchSourceOffset, cchSourceText))
			 == NULL
		   )
			{
			TRYCATCH(pASD->Release(),"IActiveScriptDebug::Release()");
			pIncFile->Release();
			return E_OUTOFMEMORY;
			}

		pIncFile->Release();
		}

	TRYCATCH(pASD->Release(),"IActiveScriptDebug::Release()");
	m_fBeingDebugged = TRUE;
	return S_OK;
	}

/*===================================================================
CActiveScriptEngine::GetApplication

Return a pointer to the application that the script resides in.

Returns:
	HRESULT.  Always succeeds.
===================================================================*/
HRESULT CActiveScriptEngine::GetApplication
(
/* [out] */ IDebugApplication **ppDebugApp
)
	{
	Assert (m_pTemplate != NULL);
	if (m_pTemplate->FDebuggable())
		{
		Assert (g_pDebugApp);

		*ppDebugApp = g_pDebugApp;
		(*ppDebugApp)->AddRef();

		return S_OK;
		}
	else
		{
		*ppDebugApp = NULL;
		return E_FAIL;
		}
	}

/*===================================================================
CActiveScriptEngine::GetRootApplicationNode

Return a pointer to the top level node (for browsing)

Returns:
	HRESULT.  Always succeeds.
===================================================================*/
HRESULT CActiveScriptEngine::GetRootApplicationNode
(
/* [out] */ IDebugApplicationNode **ppRootNode
)
	{
	Assert (m_pTemplate != NULL);
	if (m_pTemplate->FDebuggable())
		{
		Assert (g_pDebugAppRoot);

		*ppRootNode = g_pDebugAppRoot;
		(*ppRootNode)->AddRef();
		return S_OK;
		}
	else
		{
		*ppRootNode = NULL;
		return E_FAIL;
		}
	}

/*
 *
 *
 *
 * C S c r i p t E n g i n e   M e t h o d s
 *
 *
 *
 *
 */ 

/*===================================================================
CActiveScriptEngine::AddScriptlet

Add a piece of code to the script engine.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Adds script code to the engine. Potentially allocates memory.
===================================================================*/
HRESULT CActiveScriptEngine::AddScriptlet
(
LPCOLESTR wstrScript // scriptlet text
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::AddScriptlet()";
	HRESULT hr;
	EXCEPINFO excepinfo;

	AssertValid();

	// Tell ActiveScripting to add the script to the engine

    TRYCATCH_HR(m_pASP->ParseScriptText(
						wstrScript,			// the scriptlet text
						NULL,				// pstrItemName
						NULL,				// punkContext
						L"</SCRIPT>",		// End Delimiter -- Engine will never see this, but does tell it to strip comments.
						m_dwSourceContext,	// dwSourceContextCookie
						1,					// ulStartingLineNumber
						SCRIPTTEXT_ISPERSISTENT | SCRIPTTEXT_HOSTMANAGESSOURCE,
						NULL,				// pvarResult
						&excepinfo),		// exception info filled in on error
                hr,
                "IActiveScriptParse::ParseScriptText()");

	if (SUCCEEDED(hr))
		m_fScriptLoaded = TRUE;

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::AddObjects

Add named objects to the script name space

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::AddObjects
(
BOOL fPersistNames			// = TRUE
)
	{
	HRESULT hr = S_OK;
	AssertValid();

	// There must be a hit object set
	Assert(m_pHitObj != NULL);

	// Leverage RequestItems to give AS all the names
	hr = RequestItems(fPersistNames);

	if (SUCCEEDED(hr))
		m_fObjectsLoaded = TRUE;

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::AddAdditionalObject

Add additional named objects to the script name space beyond the
names already added with AddObject.  Note: the caller MUST have
added then names to the HitObj before making this call

Returns:
	HRESULT.  S_OK on success

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::AddAdditionalObject
(
LPWSTR strObjName,
BOOL fPersistNames			// = TRUE
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::AddAdditionalObject()";
	HRESULT hr = S_OK;
	DWORD grf;
	
	AssertValid();

	// There must be a hit object set
	Assert(m_pHitObj != NULL);

	// CONSIDER: It would be nice in debug code to walk the hitobj objlist and make sure
	//			that the given name is in there

	/*
	 * Give AS the names
	 */
	grf = SCRIPTITEM_ISVISIBLE;
	if (fPersistNames)
		grf |= SCRIPTITEM_ISPERSISTENT;
		
    TRYCATCH_HR(m_pAS->AddNamedItem(strObjName, grf), hr, "IActiveScript::AddNamedItem()");

    Assert(SUCCEEDED(hr));		// Should never fail!

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::AddScriptingNamespace

Add the given scripting namespace object to the engine.

Note that it is added as GLOBALMEMBERS, and Not as ISPERSISTENT

Returns:
	HRESULT.  S_OK on success

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::AddScriptingNamespace
(
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::AddScriptingNamespace()";
	HRESULT hr = S_OK;
	
	AssertValid();
	Assert(m_pHitObj != NULL);
	
	/*
	 * Give AXS the name and mark it GLOBALMEMBERS so all members are top level names
	 * in the namespace
	 */
    TRYCATCH_HR(m_pAS->AddNamedItem(WSZ_OBJ_SCRIPTINGNAMESPACE, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_GLOBALMEMBERS), 
                hr,
                "IActiveScript::AddNamedItem()");
	Assert(SUCCEEDED(hr));		// Should never fail!

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::CheckEntryPoint

Determines if the specific named entry point exists in the given script.

Returns:
	S_OK if found
	DISP_E_UNKNOWNNAME if not found
	Other OLE errors may be returned

Side effects:
	None
===================================================================*/
HRESULT CActiveScriptEngine::CheckEntryPoint
(
LPCOLESTR strEntryPoint		// The name of the sub/fn to look for
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::CheckEntryPoint()";
	HRESULT hr;
	DISPID dispid;

	AssertValid();

	if (strEntryPoint == NULL)
		{
		Assert(FALSE);
		hr = DISP_E_UNKNOWNNAME;
		}
	else
		{
		// Get the DISPID of the method to call

        TRYCATCH_HR(m_pDisp->GetIDsOfNames(IID_NULL,		// REFIID - Reserved, must be NULL
	    							 (LPOLESTR *)&strEntryPoint, // Array of names to look up
		    						 1,					// Number of names in array
			    					 m_lcid,			// Locale id
				    				 &dispid),			// returned dispid
                    hr,
                    "IScriptDispatch::GetIDsOfNames()");
								 
		// Only error we expect is DISP_E_UNKNOWNNAME (or DISP_E_MEMBERNOTFOUND)
		Assert(hr == S_OK || hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND);
		}
		
	return(hr);
	}

/*===================================================================
CActiveScriptEngine::Call

Runs the specified function.

If a specific named entry point is provided (e.g. Session_OnStart)
then we will call that by name.  Otherwise (e.g. a "main" script),
pass NULL for the name and we will run just the mainline code.

Calls TryCall (optionally from under TRY CATCH) to do the job

Returns:
	HRESULT.  S_OK on success.

Side effects:
	May have various side effects depending on the script run
===================================================================*/
HRESULT CActiveScriptEngine::Call
(
LPCOLESTR strEntryPoint		// The name of the sub/fn to call (may be NULL for "main")
)
{
	HRESULT hr;
	
	AssertValid();

	if (Glob(fExceptionCatchEnable)) {
    	// Catch any GPFs in VBS, OleAut, or external components

        TRY

            hr = TryCall(strEntryPoint);
        
    	CATCH(nExcept)
    		/*
    		 * Catching a GPF or stack overflow
    		 * Report it to the user, Assert (if debug), and exit with E_UNEXPECTED.
    		 */
    		if (STATUS_STACK_OVERFLOW == nExcept) {
    			HandleErrorMissingFilename(IDE_STACK_OVERFLOW, m_pHitObj);
#if UNICODE
                DBGPRINTF((DBG_CONTEXT, "Invoking the script '%S' overflowed the stack", m_szTemplateName));
#else
                DBGPRINTF((DBG_CONTEXT, "Invoking the script '%s' overflowed the stack", m_szTemplateName));
#endif
            }
    		else {	
    			HandleErrorMissingFilename(IDE_SCRIPT_GPF, m_pHitObj, TRUE, nExcept);
#if UNICODE
                DBGPRINTF((DBG_CONTEXT, "Invoking the script '%S' threw an exception (%x).", m_szTemplateName, nExcept));
#else
                DBGPRINTF((DBG_CONTEXT, "Invoking the script '%s' threw an exception (%x).", m_szTemplateName, nExcept));
#endif
            }

    		// Dont reuse the engine
    		m_fCorrupted = TRUE;
    		
    		hr = E_UNEXPECTED;
    	END_TRY
    }
    else {
        // Don't catch exceptions
        hr = TryCall(strEntryPoint);
    }

	return(hr);
}

/*===================================================================
CActiveScriptEngine::TryCall

Runs the specified function.

If a specific named entry point is provided (e.g. Session_OnStart)
then we will call that by name.  Otherwise (e.g. a "main" script),
pass NULL for the name and we will run just the mainline code.

Called from Call (optionally from under TRY CATCH)

Returns:
	HRESULT.  S_OK on success.

Side effects:
	May have various side effects depending on the script run
===================================================================*/
HRESULT CActiveScriptEngine::TryCall
(
LPCOLESTR strEntryPoint		// The name of the sub/fn to call (may be NULL for "main")
)
	{
	HRESULT hr;
	DISPID dispid;
	DISPPARAMS dispparams;
	UINT nArgErr;

	/*
	 * Before calling any code we will transition the script to "STARTED" state.
	 * This is part of the ActiveXScripting Reset work.
	 */
    hr = m_pAS->SetScriptState(SCRIPTSTATE_STARTED);

	if (FAILED(hr))
		{
		Assert(FALSE);
		goto LRet;
		}
		
	if (strEntryPoint != NULL)
		{
		// Get the DISPID of the method to call
		hr = m_pDisp->GetIDsOfNames(IID_NULL,		// REFIID - Reserved, must be NULL
								 (LPOLESTR *)&strEntryPoint, // Array of names to look up
								 1,					// Number of names in array
								 m_lcid,			// Locale id
								 &dispid);			// returned dispid
		if (FAILED(hr))
			{
			// Only error we expect is DISP_E_UNKNOWNNAME (or DISP_E_MEMBERNOTFOUND)
			Assert(hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND);
			goto LRet;
			}

		// There are no arguments
		memset(&dispparams, 0, sizeof(dispparams));

		// Invoke it
		hr = m_pDisp->Invoke(dispid,			// dispid to invoke
						IID_NULL,				// REFIID - Reserved, must be NULL
						 m_lcid,				// Locale id
						 DISPATCH_METHOD,		// Calling a method, not a property get/put
						 &dispparams,			// pass arguments
						 NULL,					// return value
						 NULL,					// We aren't interested in the exception info
						 &nArgErr);				// if there is a Type Mismatch, which argument was the problem
		}
	
LRet:
	return(hr);
	}


/*
 *
 *
 *
 * C S c r i p t M a n a g e r
 *
 *
 *
 *
 */ 

/*===================================================================
CScriptManager::CScriptManager

Constructor for CScriptManager object

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
CScriptManager::CScriptManager()
	: m_fInited(FALSE), m_idScriptKiller(0)
	{
	}

/*===================================================================
CScriptManager::~CScriptManager

Destructor for CScriptManager object

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
CScriptManager::~CScriptManager()
	{
	}

/*===================================================================
CScriptManager::Init

Init the script manager.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::Init
(
)
	{
    static const char *_pFuncName = "CScriptManager::Init()";
	HRESULT hr;
	BOOL fPLLInited = FALSE;
	BOOL fcsPLLInited = FALSE;
	BOOL fFSQInited = FALSE;
	BOOL fcsFSQInited = FALSE;
	BOOL fRSLInited = FALSE;
	BOOL fcsRSLInited = FALSE;
	DWORD cBuckets;
	DWORD rgPrime[] = { 3, 11, 23, 57, 89 };
	WORD iP;
    IActiveScript *pAST = NULL;
	static const GUID uid_VBScript	= { 0xB54F3741, 0x5B07, 0x11cf, { 0xA4, 0xB0, 0x00, 0xAA, 0x00, 0x4A, 0x55, 0xE8}};
	
	// Illegal to re-init
	if (m_fInited)
		{
		Assert(FALSE);
		return(ERROR_ALREADY_INITIALIZED);
		}

	// Create the critical sections for serializing access to lists
	ErrInitCriticalSection(&m_cSPLL, hr);
	if (FAILED(hr))
		goto LError;
	fcsPLLInited = TRUE;
	ErrInitCriticalSection(&m_csFSQ, hr);
	if (FAILED(hr))
		goto LError;
	fcsFSQInited = TRUE;
	ErrInitCriticalSection(&m_csRSL, hr);
	if (FAILED(hr))
		goto LError;
	fcsRSLInited = TRUE;

	// List of programming language clsid's
	hr = m_hTPLL.Init();
	if (FAILED(hr))
		goto LError;
	fPLLInited = TRUE;

	// Free Script Queue
	// Init it with a prime # of buckets in relation to script engine cache max
	cBuckets = (Glob(dwScriptEngineCacheMax) / 2) + 1;
	for (iP = (sizeof(rgPrime) / sizeof(DWORD)) - 1; iP > 0; iP--)
		if (rgPrime[iP] < cBuckets)
			{
			cBuckets = rgPrime[iP];
			break;
			}
	if (cBuckets < rgPrime[1])
		cBuckets = rgPrime[0];
			
	hr = m_htFSQ.Init(cBuckets);
	if (FAILED(hr))
		goto LError;
	fFSQInited = TRUE;

	// Running Script List
	// Init it with a prime # of buckets in relation to max # of threads
	cBuckets = Glob(dwThreadMax) / 2;
	for (iP = (sizeof(rgPrime) / sizeof(DWORD)) - 1; iP > 0; iP--)
		if (rgPrime[iP] < cBuckets)
			{
			cBuckets = rgPrime[iP];
			break;
			}
	if (cBuckets < rgPrime[1])
		cBuckets = rgPrime[0];
		
	hr = m_htRSL.Init(cBuckets);
	if (FAILED(hr))
		goto LError;
	fRSLInited = TRUE;

	// Schedule script killer
    m_msecScriptKillerTimeout = Glob(dwScriptTimeout) * 500;
	m_idScriptKiller = ScheduleWorkItem
	    (
	    CScriptManager::ScriptKillerSchedulerCallback,  // callback
	    this,                                           // context
        m_msecScriptKillerTimeout,                      // timeout
        TRUE                                            // periodic
        );
    if (!m_idScriptKiller)
        {
        hr = E_FAIL;
        goto LError;
        }

    // TypeLib support: Create a scripting engine and QI it for the TypeLib wrapper support
    hr = CoCreateInstance(uid_VBScript, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void**)&pAST);
    if (FAILED(hr))
        goto LError;
    TRYCATCH_HR_NOHITOBJ(pAST->QueryInterface(IID_IWrapTypeLibs, (VOID **)&g_pWrapTypelibs),
                         hr,
                         "IActiveScript::QueryInterface()");
    TRYCATCH_NOHITOBJ(pAST->Release(),"IActiveScript::Release()");        // No longer need the pointer to the engine
    if (FAILED(hr))
        goto LError;
    
	// All OK.  We are inited.
	m_fInited = TRUE;

	goto LExit;
	
LError:
    if (m_idScriptKiller)
        RemoveWorkItem(m_idScriptKiller);
	if (fcsPLLInited)
		DeleteCriticalSection(&m_cSPLL);
	if (fcsFSQInited)
		DeleteCriticalSection(&m_csFSQ);
	if (fcsRSLInited)
		DeleteCriticalSection(&m_csRSL);
	if (fPLLInited)
		m_hTPLL.UnInit();
	if (fFSQInited)
		m_htFSQ.UnInit();
	if (fRSLInited)
		m_htRSL.UnInit();
	if (pAST)
	    TRYCATCH_NOHITOBJ(pAST->Release(),"IActiveScript::Release()");
	if (g_pWrapTypelibs)
	    {
	    TRYCATCH_NOHITOBJ(g_pWrapTypelibs->Release(),"IWrapTypeLibs::Release()");
	    g_pWrapTypelibs = NULL;
	    }

LExit:	
	return(hr);
	}

/*===================================================================
CScriptManager::UnInit

UnInit the script manager.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::UnInit
(
)
	{
    static const char *_pFuncName = "CScriptManager::UnInit()";
	HRESULT hr = S_OK, hrT;
	
	if (m_fInited)
		{
		// Un-schedule script killer
        if (m_idScriptKiller)
            {
            RemoveWorkItem(m_idScriptKiller);
            m_idScriptKiller = 0;
            }
        
		// Uninit each of the lists.  Attempt to uninit them all, even if we get an error.
		// Dont lose any errors along the way.
		hr = UnInitASEElems();
		hrT = UnInitPLL();
		if (SUCCEEDED(hr))
			hr = hrT;	
		hrT = m_hTPLL.UnInit();
		if (SUCCEEDED(hr))
			hr = hrT;	
		hrT = m_htFSQ.UnInit();
		if (SUCCEEDED(hr))
			hr = hrT;	
		hrT = m_htRSL.UnInit();
		if (SUCCEEDED(hr))
			hr = hrT;	

        if (g_pWrapTypelibs)
            {
            TRYCATCH_NOHITOBJ(g_pWrapTypelibs->Release(),"IWrapTypeLibs::Release()");
            g_pWrapTypelibs = NULL;
            }
            
		// Free the critical sections (bug 1140: do this after freeing everything else)
		DeleteCriticalSection(&m_cSPLL);
		DeleteCriticalSection(&m_csFSQ);
		DeleteCriticalSection(&m_csRSL);

		m_fInited = FALSE;
		}

	return(hr);
	}


/*===================================================================
CScriptManager::AdjustScriptKillerTimeout

Adjust (shorten) script killer timeout when needed.
The caller should take care of the critical sectioning.

Parameters:
    msecNewTimeout    new suggested timeout value (in ms)

Returns:
	HRESULT.  S_OK on success.
===================================================================*/
HRESULT CScriptManager::AdjustScriptKillerTimeout
(
DWORD msecNewTimeout
)
    {
    const DWORD MSEC_MIN_SCRIPT_TIMEOUT = 5000;   // 5 seconds

    if (!m_idScriptKiller)
        return E_FAIL;  // no script killer scheduled

    // don't set to < minimum
    if (msecNewTimeout < MSEC_MIN_SCRIPT_TIMEOUT)
        msecNewTimeout = MSEC_MIN_SCRIPT_TIMEOUT;
        
    if (m_msecScriptKillerTimeout <= msecNewTimeout)
        return S_OK; // the timeout already short enough

    if (ScheduleAdjustTime(
            m_idScriptKiller, 
            msecNewTimeout) == S_OK)
        {
        m_msecScriptKillerTimeout = msecNewTimeout;
        return S_OK;
        }
    else
        {
        return E_FAIL;
        }
    }

/*===================================================================
CScriptManager::GetEngine

Return an engine to the caller.  Ideally, we will find an engine
that already has the given script in it in our Free Script Queue
and will just hand it out.  If there isnt one, then we will look
in the Running Script List and attempt to clone a running script.
Failing that, we will create a new script
engine.  We return an ENGINESTATE state indicating if the engine
is filled with script or not.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially allocates memory.
===================================================================*/
HRESULT CScriptManager::GetEngine
(
LCID lcid,					// The system language to use
PROGLANG_ID& progLangId,	// prog lang id of the script
LPCTSTR szTemplateName,		// Template we want an engine for
CHitObj *pHitObj,			// Hit obj to use in this engine
CScriptEngine **ppSE,		// Returned script engine
ENGINESTATE *pdwState,		// Current state of the engine
CTemplate *pTemplate,		// template which engine is based from
DWORD dwSourceContext		// source context cookie (engine ID)
)
	{
	HRESULT hr = S_OK;
	CActiveScriptEngine *pASE = NULL;
	CASEElem *pASEElem = NULL;
	DWORD dwInstanceID = pHitObj->DWInstanceID();
	
	AssertValid();

	/*	NOTE progLangId must be valid because CTemplate::Compile() 
		fails way upstream of this point if it cannot generate a valid progLangId.
		Unfortunately there is no easy way to assert progLangId is valid ...
	*/

	/*
	 * First try to find the engine in the FSQ
	 *
	 * Note: We are going to enter our CS now, and keep it until we have
	 * secured the engine for ourselves.  Otherwise, it might be possible
	 * for us to get an engine, and then have another thread get the
	 * same engine before we manage to get it off of the FSQ.
	 * This makes the code a little hard to read, but is nessecary.
	 */
	EnterCriticalSection(&m_csFSQ);
#ifndef REUSE_ENGINE

    // This will only find fully loaded engines
	hr = FindEngineInList(szTemplateName, progLangId, dwInstanceID, /*fFSQ*/TRUE, &pASEElem);
	
#endif
	if (FAILED(hr))
		{
    	LeaveCriticalSection(&m_csFSQ);
		goto LFail;
		}

	if (pASEElem == NULL || pASEElem->PASE() == NULL)
		{
    	LeaveCriticalSection(&m_csFSQ);
		}
	else
		{
		// We got an engine we want to use, remove it from FSQ
		(VOID)m_htFSQ.RemoveElem(pASEElem);
#ifndef PERF_DISABLE
        g_PerfData.Decr_SCRIPTFREEENG();
#endif
    	LeaveCriticalSection(&m_csFSQ);

		pASE = pASEElem->PASE();
		Assert(!pASE->FIsZombie());
		Assert(pASE->FFullyLoaded());
		hr = pASE->ReuseEngine(pHitObj, pTemplate, dwSourceContext, dwInstanceID);
		if (FAILED(hr))
			goto LFail;
		}
		
	/*
	 * If not found, try to find the engine in the RSL and clone it
	 */
	if (pASE == NULL)
		{
		CASEElem *pASEElemRunning = NULL;
		CActiveScriptEngine *pASERunning = NULL;

		// If we do find an engine to clone, dont let anyone at it until we've cloned it
    	EnterCriticalSection(&m_csRSL);

#ifndef CLONE
		hr = FindEngineInList(szTemplateName, progLangId, dwInstanceID, /*fFSQ*/FALSE, &pASEElemRunning);
#else	// CLONE
		// Clone turned off - pretend one wasnt found
		pASEElemRunning = NULL;
#endif
		/*
		 * If we didnt find an element, or it was null, or (bug 1225) it was corrupted
		 * by a GPF running a script, or it was a zombie, then leave the CS and continue.
		 */
		if (FAILED(hr) || pASEElemRunning == NULL || pASEElemRunning->PASE() == NULL ||
			pASEElemRunning->PASE()->FIsCorrupted() || pASEElemRunning->PASE()->FIsZombie())
			{
			LeaveCriticalSection(&m_csRSL);
			if (FAILED(hr))
				goto LFail;
			}
		else
	        {
			pASERunning = pASEElemRunning->PASE();
			Assert(pASERunning != NULL);
			}

		if (pASERunning != NULL)
			{
			IActiveScript *pAS, *pASClone;

    		Assert(!pASERunning->FIsZombie());
	    	Assert(pASERunning->FFullyLoaded());

			// Found a running engine, clone it
			pAS = pASERunning->GetActiveScript();
			Assert(pAS != NULL);
			hr = pAS->Clone(&pASClone);

			// We've cloned the engine, we can let go of the CS
			LeaveCriticalSection(&m_csRSL);

			// Scripting engines are not required to implement clone.  If we get an error,
			// just continue on and create a new engine
			if (FAILED(hr))
				{
				Assert(hr == E_NOTIMPL);		// I only expect E_NOTIMPL
				Assert(pASE == NULL);			// the ASE should not be filled in
				pASE = NULL;
				hr = S_OK;
				}
			else
				{
				// Got back a cloned IActiveScript.  Create a new ASE and fill it in
				pASE = new CActiveScriptEngine;
				if (!pASE)
					{
					hr = E_OUTOFMEMORY;
					pASClone->Release();
					goto LFail;
					}
				hr = pASE->MakeClone(progLangId, szTemplateName, lcid, pHitObj, pTemplate, dwSourceContext, dwInstanceID, pASClone);
				if (FAILED(hr))
					{
					// if we failed, we must release the clone AS
					pASClone->Release();
					goto LFail;
					}
				}
			}
		}

	/*
	 * Have an engine that we can reuse
	 */
	if (pASE != NULL)
		{
		// Reusing an engine.  Let the caller know that it is already initialized
		*pdwState = SCRIPTSTATE_INITIALIZED;

		goto LHaveEngine;
		}

	/*
	 * No suitable engine to reuse.  Return a new one
	 */
	pASE = new CActiveScriptEngine;
	if (!pASE)
		{
		hr = E_OUTOFMEMORY;
		goto LFail;
		}
	hr = pASE->Init(progLangId, szTemplateName, lcid, pHitObj, pTemplate, dwSourceContext);
	if (FAILED(hr))
		goto LFail;

	// This is a new engine, let the caller know it is uninitialized
	*pdwState = SCRIPTSTATE_UNINITIALIZED;

LHaveEngine:
	// Return the engine as a CScriptEngine -- the caller only needs those interfaces
	pASE->AssertValid();				// The engine we're about to give back should be valid
	*ppSE = (CScriptEngine *)pASE;
	
	// Put the engine on the Running Scrips List
	// If we got this engine from the FSQ, reuse that elem.
	if (pASEElem == NULL)
		{
		pASEElem = new CASEElem;
		if (!pASEElem)
			{
			hr = E_OUTOFMEMORY;
			goto LFail;
			}
		hr = pASEElem->Init(pASE);
		if (FAILED(hr))
			{
			Assert(FALSE);		// Shouldnt fail
			delete pASEElem;
			goto LFail;
			}
		}

    /*
     * Above, we may have gotten an engine from the FSQ or cloned on from the RSL or
     * created a new one.  And, we are about to put that engine on the RSL.  However,
     * it is possible that the template in question was flushed due to a change notification
     * while this was going on.  Regardless of how we got the engine, there is the possibility
     * that the template was flushed while we were holding onto an engine which was not on
     * any list (the FSQ or RSL), and so we have an engine which should be flushed but isnt.
     * We can detect this by seeing if the template is marked as being a Zombie.  If it is
     * we must mark this engine as being a zombie too, so it wont be returned to the FSQ when
     * it is done running.  Note that once we add this engine to the RSL we are "safe", because
     * any flushes after that point would correctly zombify the engine.
     */
    EnterCriticalSection(&m_csRSL);    
    if (pTemplate->FIsZombie())
        {
        // The template asking for this engine is obsolete. Make sure that no
        // one else will use this engine by marking it zombie
        DBGPRINTF((DBG_CONTEXT, "[CScriptManager] Zombie template found.\n"));
        (*ppSE)->Zombify();
        }

	(VOID)m_htRSL.AddElem(pASEElem);
	LeaveCriticalSection(&m_csRSL);


	// Set the time that the engine was handed out so we will know when to kill it
	pASE->SetTimeStarted(time(NULL));

LFail:

	Assert(SUCCEEDED(hr) || hr == TYPE_E_ELEMENTNOTFOUND);
	return(hr);
	}

/*===================================================================
CScriptManager::ReturnEngineToCache

Caller is done with the engine.  Return it to the cache.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially allocates memory.
===================================================================*/
HRESULT CScriptManager::ReturnEngineToCache
(
CScriptEngine **ppSE,
CAppln *pAppln,
IASPObjectContextCustom *pTxnScriptContextCustom
)
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElem;
	CActiveScriptEngine *pASE;

	Assert(ppSE != NULL);
	Assert(*ppSE != NULL);

	pASE = static_cast<CActiveScriptEngine *>(*ppSE);
	
	// Remove the engine from the Running Script List
	EnterCriticalSection( &m_csRSL );
	hr = FindASEElemInList(static_cast<CActiveScriptEngine *>(*ppSE), /*fFSQ*/FALSE, &pASEElem);
	if (FAILED(hr))
		{
		LeaveCriticalSection( &m_csRSL );
		goto LExit;
		}
		
	// Note: Sometimes a script will not be in the RSL!  This occurs when
	//       we are reusing a script that is stored in the CTemplate object.
	//       (When the script is reloaded, it is retrieved directly from the
	//        template, bypassing our code which places engines on the RSL)
	//
	if (pASEElem != NULL)
		m_htRSL.RemoveElem(pASEElem);

	LeaveCriticalSection( &m_csRSL );

	/*
	 * If the engine was zombified while it was running, deallocate it.
	 * Or, if there was a GPF while then engine was running, then it might
	 * be in a corrupted state (bug 1225).  Also remove it in that case.
	 */
	pASE = static_cast<CActiveScriptEngine *>(*ppSE);
	if (pASE->FIsZombie() || pASE->FIsCorrupted())
		{
		delete pASEElem;
		pASE->FinalRelease();
		goto LExit;
		}


	HRESULT hrT;
	/*
	 * We want to reuse this engine.  Try to return it to the "Uninitialized"
	 * state.  Some engine languages arent able to do this.  If it fails, deallocate
	 * the engine; it cant be reused.
	 */
	hrT = pASE->ResetToUninitialized(pTxnScriptContextCustom);
	if (FAILED(hrT))
		{
		// Engine doesnt support this, sigh.  Deallocate and continue.
		delete pASEElem;
		pASE->FinalRelease();
		goto LExit;
		}

    // Get the pTemplate for this engine
	CTemplate *pTemplate;
	DWORD dwEngine;
	pASE->GetDebugDocument(&pTemplate, &dwEngine);

	// CONSIDER: Better strategy for keeping live scripts?
	// Only remember good (no compiler errors) scripts in the template
	if (pAppln->FDebuggable() && pASE->FFullyLoaded() && pTemplate && !pTemplate->FDontAttach())
		{
		// Template is marked as incomplete (invalid) when change notification occurs
		// and template is flushed from cache.  In this case, don't cache in CTemplate
		// object!

		if (pTemplate->FIsValid())
			pTemplate->AddScript(dwEngine, pASE);

		// NOTE: Always release the scripting engine.  Exec code is structured so that it
		//       consumes a reference (either through GetEngine() or CTemplate::GetActiveScript())
		//       and assumes that ReturnToCache will release its reference.
		// CONSIDER: Bad design.  Caller should do the release

		delete pASEElem;
		pASE->Release();
		}
	else
	    {
	    // reuse engines, not debugging
		/*
		 * We removed the engine from the RSL, put it onto the FSQ for potential reuse.
		 *
		 * In certain multi-threaded change-notify situations it is possible
		 * that the template was flushed (zombied) while we were in the middle
		 * of returning this engine to the cache.  That is to say, between the time
		 * that we took the engine off the RSL and when we are going to put it on the FSQ
		 * it might have been flushed. In that case, this engine should
		 * not go into the FSQ, but should be deleted instead.  Check for that case.
		 * Do that inside the FSQ CS so that we are safe from the template getting zombied
		 * after we do the test but before the engine goes into the FSQ.  Also, do not
		 * put template on FSQ during shut down phase, since FSQ may go away soon, and
		 * the final destination of the engine is FinalRelease() anyway.
		 */
    	EnterCriticalSection(&m_csFSQ);
    	if (!pTemplate->FIsZombie() && !IsShutDownInProgress())
    	    {
    		AddToFSQ(pASEElem);
    		}
    	else
    	    {
    		delete pASEElem;
    		pASE->FinalRelease();
    	    }
		LeaveCriticalSection(&m_csFSQ);
		}

LExit:
	return(hr);
	}

/*===================================================================
CScriptManager::FlushCache

A script has been edited; cached versions must be discarded

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially allocates memory.
===================================================================*/
HRESULT CScriptManager::FlushCache
(
LPCTSTR szTemplateName
)
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElem;
	CASEElem *pASEElemNext = NULL;
	CActiveScriptEngine *pASE;
	
	AssertValid();

	EnterCriticalSection(&m_csRSL);
	EnterCriticalSection(&m_csFSQ);

	// First Zombify engines on the RSL of the given name.
	// Note: must explicitly loop through all elements, since the hash table implementation
	//		doesnt support FindNext to find subsequent elements of the same name.  Repeated
	//		calls to find returns the same element over and over
	// CONSIDER: I have written a custom FindElem.  Consider using it.
	
	pASEElem = (CASEElem *)m_htRSL.Head();
	while (pASEElem != NULL)
		{
		pASEElemNext = (CASEElem *)pASEElem->m_pNext;
		pASE = pASEElem->PASE();

		if (_tcsicmp(pASE->SzTemplateName(), szTemplateName) == 0)
			pASE->Zombify();
		
		pASEElem = pASEElemNext;
		}


	// Now throw out engines on the FSQ of the given name
	// Delete any item with the given name (may be several)
	pASEElem = (CASEElem *)m_htFSQ.Head();
	while (pASEElem != NULL)
		{
		pASEElemNext = (CASEElem *)pASEElem->m_pNext;
		pASE = pASEElem->PASE();

		if (_tcsicmp(pASE->SzTemplateName(), szTemplateName) == 0)
			{
			(VOID)m_htFSQ.RemoveElem(pASEElem);
#ifndef PERF_DISABLE
            g_PerfData.Decr_SCRIPTFREEENG();
#endif
			pASE->FinalRelease();
			delete pASEElem;
			}
		
		pASEElem = pASEElemNext;
		}

	LeaveCriticalSection(&m_csFSQ);
	LeaveCriticalSection(&m_csRSL);

	return(hr);
	}

/*===================================================================
CScriptManager::FlushAll

global.asa changed, everything must go

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially allocates memory.
===================================================================*/
HRESULT CScriptManager::FlushAll
(
)
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElem;
	CASEElem *pASEElemNext = NULL;
	CActiveScriptEngine *pASE;
	
	AssertValid();

	EnterCriticalSection(&m_csRSL);
	EnterCriticalSection(&m_csFSQ);

	// First Zombify all engines on the RSL
	// Note: must explicitly loop through all elements, since the hash table implementation
	//		doesnt support FindNext to find subsequent elements of the same name.  Repeated
	//		calls to find returns the same element over and over
	// CONSIDER: I have written a custom FindElem.  Consider using it.
	
	pASEElem = (CASEElem *)m_htRSL.Head();
	while (pASEElem != NULL)
		{
		pASEElemNext = (CASEElem *)pASEElem->m_pNext;
		pASEElem->PASE()->Zombify();
		pASEElem = pASEElemNext;
		}

	// Now throw out engines on the FSQ
	pASEElem = (CASEElem *)m_htFSQ.Head();
	while (pASEElem != NULL)
		{
		pASEElemNext = (CASEElem *)pASEElem->m_pNext;
		(VOID)m_htFSQ.RemoveElem(pASEElem);
#ifndef PERF_DISABLE
		g_PerfData.Decr_SCRIPTFREEENG();
#endif
		pASEElem->PASE()->FinalRelease();
		delete pASEElem;
		pASEElem = pASEElemNext;
		}

	LeaveCriticalSection(&m_csFSQ);
	LeaveCriticalSection(&m_csRSL);

	return(hr);
	}

/*===================================================================
CScriptManager::GetDebugScript

Try to find an engine via template pointer, and query for IActiveScriptDebug,
in the RSL.

Returns:
	An AddRef'ed copy of the script engine if found, or NULL if not.
===================================================================*/
IActiveScriptDebug *
CScriptManager::GetDebugScript
(
CTemplate *pTemplate,
DWORD dwSourceContext
)
	{
	EnterCriticalSection(&m_csRSL);

	CASEElem *pASEElem = static_cast<CASEElem *>(m_htRSL.Head());
	while (pASEElem != NULL)
		{
		CTemplate *pScriptTemplate = NULL;
		DWORD dwScriptSourceContext = -1;
		CActiveScriptEngine *pASE = pASEElem->PASE();
		pASE->GetDebugDocument(&pScriptTemplate, &dwScriptSourceContext);

		if (pTemplate == pScriptTemplate && dwSourceContext == dwScriptSourceContext)
			{
			IActiveScript *pActiveScript = pASE->GetActiveScript();
			void *pDebugScript;
			if (SUCCEEDED(pActiveScript->QueryInterface(IID_IActiveScriptDebug, &pDebugScript)))
				{
				pASE->IsBeingDebugged();
				LeaveCriticalSection(&m_csRSL);
				return reinterpret_cast<IActiveScriptDebug *>(pDebugScript);
				}
			else
				{
				LeaveCriticalSection(&m_csRSL);
				return NULL;
				}
			}

		pASEElem = static_cast<CASEElem *>(pASEElem->m_pNext);
		}

	LeaveCriticalSection(&m_csRSL);

	return NULL;
	}

/*===================================================================
CScriptManager::FindEngineInList

Try to find an engine of the given name in the given list (either
the FSQ or the RSL.)

Returns:
	HRESULT.  S_OK on success.
	ppASEElem contains found engine
===================================================================*/
HRESULT CScriptManager::FindEngineInList
(
LPCTSTR szTemplateName,	// Template we want an engine for
PROGLANG_ID progLangId,	// what language do we want this engine for
DWORD dwInstanceID,     // which server instance
BOOL fFSQ,				// TRUE -> look in FSQ, FALSE -> look in RSQ
CASEElem **ppASEElem
)
	{
	HRESULT hr = S_OK;
	DWORD cb;
	
	AssertValid();
	Assert(ppASEElem != NULL);

	*ppASEElem = NULL;
	
	// Key is name
	cb = _tcslen(szTemplateName)*sizeof(TCHAR);
	if (fFSQ)
		{
		EnterCriticalSection(&m_csFSQ);
		*ppASEElem = static_cast<CASEElem *>(m_htFSQ.FindElem((VOID *)szTemplateName, cb, 
											progLangId, dwInstanceID, /*fCheckLoaded*/TRUE));
		LeaveCriticalSection(&m_csFSQ);
		}
	else
		{
		EnterCriticalSection(&m_csRSL);
		*ppASEElem = static_cast<CASEElem *>(m_htRSL.FindElem((VOID *)szTemplateName, cb,
											progLangId, dwInstanceID, /*fCheckLoaded*/TRUE));
		LeaveCriticalSection(&m_csRSL);
		}

	return(hr);
	}

/*===================================================================
CScriptManager::FindASEElemInList

Given an ASE, find its corresponding ASEElem in the hash table. Note
that this is relatively slow because it is doing a linked list traversal
not a hash table lookup.  

CONSIDER: create second hash table to do this quickly.

Returns:
	HRESULT.  S_OK on success.
	ppASEElem contains found engine
===================================================================*/
HRESULT CScriptManager::FindASEElemInList
(
CActiveScriptEngine *pASE,
BOOL fFSQ,				// TRUE -> look in FSQ, FALSE -> look in RSQ
CASEElem **ppASEElem
)
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElem;
	
	AssertValid();
	Assert(pASE != NULL);
	Assert(ppASEElem != NULL);

	*ppASEElem = NULL;
	
	if (fFSQ)
		{
		EnterCriticalSection(&m_csFSQ);
		pASEElem = static_cast<CASEElem *>(m_htFSQ.Head());
		}
	else
		{
		EnterCriticalSection(&m_csRSL);
		pASEElem = static_cast<CASEElem *>(m_htRSL.Head());
		}

	while (pASEElem != NULL)
		{
		if (pASE == pASEElem->PASE())
			break;
		pASEElem = static_cast<CASEElem *>(pASEElem->m_pNext);
		}

	if (fFSQ)
		LeaveCriticalSection(&m_csFSQ);
	else
		LeaveCriticalSection(&m_csRSL);

	*ppASEElem = pASEElem;
		
	return(hr);
	}

/*===================================================================
CScriptManager::KillOldEngines

Loops through all running engines and kills any engines which are "old"
(presumably they are stuck in an infinite loop in VBS.)

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially kills off engines
===================================================================*/
HRESULT CScriptManager::KillOldEngines
(
BOOLB fKillNow // Kill all engines now if TRUE
)
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElem, *pASEElemNext;
	time_t timeNow;
	time_t timeRunning;
	CActiveScriptEngine *pASE;
	
	AssertValid();

	timeNow = time(NULL);

	EnterCriticalSection(&m_csRSL);
	
	pASEElemNext = static_cast<CASEElem *>(m_htRSL.Head());

	/*
	 * Loop through each element.  Turn it into an ASE.
	 * If it is older than cSeconds, then kill it.
	 */
	while (pASEElemNext)
		{
		pASEElem = pASEElemNext;
		pASEElemNext = static_cast<CASEElem *>(pASEElemNext->m_pNext);
		pASE = pASEElem->PASE();

		timeRunning = timeNow - pASE->TimeStarted();

		if (TRUE == fKillNow || timeRunning >= pASE->GetTimeout())
			{
			// Too old. Kill it.
			pASE->InterruptScript();
			}
		}
	
	LeaveCriticalSection(&m_csRSL);

	return(hr);
	}

/*===================================================================
CScriptManager::EmptyRunningScriptList

When we are going to shut down, the RSL must be empty.  This routine
kills off all running engines, then waits up to 5 minutes
for the engines to leave the RSL.  Added for Bug 1140

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially kills off engines
===================================================================*/
HRESULT CScriptManager::EmptyRunningScriptList
(
)
	{
	HRESULT hr;
	UINT cTrys;

	hr = KillOldEngines(TRUE);
	Assert(SUCCEEDED(hr));
	for (cTrys = 0; cTrys < 300; cTrys++)
		{
		if (static_cast<CASEElem *>(m_htRSL.Head()) == NULL)
			break;
		Sleep(1000);			// sleep 1 seconds
		}

	return(S_OK);
	}

/*===================================================================
CScriptManager::UnInitASEElems

Free engines in FSQ and RSL

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Frees memory
===================================================================*/
HRESULT CScriptManager::UnInitASEElems()
	{
	CASEElem *pASEElem = NULL;
	CASEElem *pASEElemNext = NULL;

	// First the FSQ
	EnterCriticalSection(&m_csFSQ);
	pASEElem = static_cast<CASEElem *>(m_htFSQ.Head());
	while (pASEElem != NULL)
		{
		pASEElemNext = static_cast<CASEElem *>(pASEElem->m_pNext);
		pASEElem->PASE()->FinalRelease();
		delete pASEElem;
		pASEElem = pASEElemNext;
		}
	LeaveCriticalSection(&m_csFSQ);

	/*
	 * Next the RSL (note: this really should be empty)
	 *
	 * Bug 1140: This is very dangerous, but we have no choice left at this point
	 */
	EnterCriticalSection(&m_csRSL);
	pASEElem = static_cast<CASEElem *>(m_htRSL.Head());
	while (pASEElem != NULL)
		{
		pASEElemNext = static_cast<CASEElem *>(pASEElem->m_pNext);
		pASEElem->PASE()->FinalRelease();
		delete pASEElem;
		pASEElem = pASEElemNext;
		}
	LeaveCriticalSection(&m_csRSL);
	
	return(S_OK);
	}

/*===================================================================
CScriptManager::AddToFSQ

Add the given ASEElem to the FSQ and to the front of the LRU list

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::AddToFSQ
(
CASEElem *pASEElem
)
	{
	HRESULT hr = S_OK;

	Assert(pASEElem != NULL);

	// If CacheMax is 0, this is a NoOp
	if (Glob(dwScriptEngineCacheMax) <= 0)
		{
		// delete the passed in ASEElem because it wont be saved
		pASEElem->PASE()->FinalRelease();
		delete pASEElem;

		return(S_OK);
		}

	EnterCriticalSection(&m_csFSQ);

	// Add the element to the FSQ
	(VOID)m_htFSQ.AddElem(pASEElem);

#ifndef PERF_DISABLE
    g_PerfData.Incr_SCRIPTFREEENG();
#endif

	// Check the FSQ LRU too see if it is too long
	CheckFSQLRU();

	LeaveCriticalSection(&m_csFSQ);

	return(hr);
	}

/*===================================================================
CScriptManager::CheckFSQLRU

Check to see if the FSQ is too long, and if so throw out the LRU engine

WARNING: Caller must enter FSQ critical section before calling

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::CheckFSQLRU()
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElemOld;
	CActiveScriptEngine *pASE;

	// If the list isnt too long, noop
	if (m_htFSQ.Count() <= Glob(dwScriptEngineCacheMax) || Glob(dwScriptEngineCacheMax) == 0xFFFFFFFF)
		return(S_OK);

	// FSQLRU list is too long, remove oldest
	Assert (! m_htFSQ.FLruElemIsEmpty( m_htFSQ.End() ));
	pASEElemOld = static_cast<CASEElem *>(m_htFSQ.RemoveElem(m_htFSQ.End()));
	Assert(pASEElemOld != NULL);
	pASE = pASEElemOld->PASE();

#ifndef PERF_DISABLE
    g_PerfData.Decr_SCRIPTFREEENG();
#endif

	// Delete the engine
	delete pASEElemOld;
	pASE->FinalRelease();

	return(hr);
	}

/*===================================================================
CScriptManager::UnInitPLL

Free the names of the script engines

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Frees memory
===================================================================*/
HRESULT CScriptManager::UnInitPLL()
	{
	CPLLElem *pPLLElem = NULL;
	CPLLElem *pPLLElemNext = NULL;

	pPLLElem = (CPLLElem *)m_hTPLL.Head();

	while (pPLLElem != NULL)
		{
		pPLLElemNext = (CPLLElem *)pPLLElem->m_pNext;
		if (pPLLElem->m_pKey != NULL)
			free((CHAR *)(pPLLElem->m_pKey));
		pPLLElem->m_pKey = NULL;
		delete pPLLElem;
		pPLLElem = pPLLElemNext;
		}
	
	return(S_OK);
	}

/*===================================================================
CScriptManager::ProgLangIdOfLangName

Given a programming language name, get the CLSID of the ActiveX Scripting
Engine which runs that language.

WARNING: Needs to look in the registry for this info.  Maybe slow

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::ProgLangIdOfLangName
(
LPCSTR szProgLang,			// The programming lang of the script
PROGLANG_ID *pProgLangId	// The programming language id
)
	{
	HRESULT hr = S_OK;
	CPLLElem *pPLLElem;
	
	AssertValid();
	
	EnterCriticalSection(&m_cSPLL);
	pPLLElem = (CPLLElem *) m_hTPLL.FindElem((VOID *)szProgLang, strlen(szProgLang));
	if (pPLLElem != NULL)
		{
		*pProgLangId = pPLLElem->ProgLangId();
		}
	else
		{
		// Not already in list, look in registry
		hr = GetProgLangIdOfName(szProgLang, pProgLangId);
		if (FAILED(hr))
			{
			hr = TYPE_E_ELEMENTNOTFOUND;
			goto LExit;
			}

		// Add it to the list so we dont have to re-look it up
		hr = AddProgLangToPLL((CHAR *)szProgLang, *pProgLangId);
		if (FAILED(hr))
			goto LExit;
		}

LExit:
	LeaveCriticalSection(&m_cSPLL);
	return(hr);
	}

/*===================================================================
CScriptManager::AddProgLangToPLL

Keep list of programming language CLSIDs so we dont have to look
them up every time.  Add the given programming language name/id pair
to the Programming Language List.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::AddProgLangToPLL
(
CHAR *szProgLangName,
PROGLANG_ID progLangId
)
	{
	HRESULT hr;
	CPLLElem *pPLLElem = NULL;

	// Put the language clsid on the Programming Language List
	pPLLElem = new CPLLElem;
	if (!pPLLElem)
		{
		hr = E_OUTOFMEMORY;
		goto LFail;
		}

	hr = pPLLElem->Init(szProgLangName, progLangId);
	if (FAILED(hr))
		{
		Assert(FALSE);		// Shouldnt fail
		goto LFail;
		}

	EnterCriticalSection(&m_cSPLL);
	(VOID)m_hTPLL.AddElem(pPLLElem);
	LeaveCriticalSection(&m_cSPLL);

LFail:
	return(hr);
	}

/*===================================================================
CScriptManager::ScriptKillerSchedulerCallback

Static method implements ATQ scheduler callback functions.
Replaces script killer thread 

Parameters:
    void *pv    context pointer (points to script mgr)
    
Returns:

Side effects:
	None.
===================================================================*/
void WINAPI CScriptManager::ScriptKillerSchedulerCallback
(
void *pv
)
    {
    if (IsShutDownInProgress())
        return;

    Assert(pv);
    
    CScriptManager *pScriptMgr = reinterpret_cast<CScriptManager *>(pv);
    if (pScriptMgr->m_fInited)
        {
        pScriptMgr->KillOldEngines();
        }
    }

#ifdef DBG
/*===================================================================
CScriptManager::AssertValid

Test to make sure that the CScriptManager object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
	None.
===================================================================*/
VOID CScriptManager::AssertValid() const
	{
	Assert(m_fInited);
	}
#endif // DBG



/*
 *
 *
 *
 * C A S E E l e m
 *
 * Active Script Engine Elements
 *
 *
 *
 */ 

/*===================================================================
CASEElem::~CASEElem

Destructor for CASEElem object.

Returns:
	Nothing

Side effects:
	None
===================================================================*/
CASEElem::~CASEElem()
	{
	}

/*===================================================================
CASEElem::Init

Init the Active Script Engine Elem.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CASEElem::Init
(
CActiveScriptEngine *pASE
)
	{
	HRESULT hr = S_OK;
	TCHAR *szT = pASE->SzTemplateName();

	if (szT == NULL)
		{
		Assert(FALSE);
		return(E_FAIL);
		}

	// Key is name
	hr = CLinkElem::Init((LPVOID) szT, _tcslen(szT)*sizeof(TCHAR));
	if (FAILED(hr))
		{
		Assert(FALSE);		// Shouldnt fail
		return(hr);
		}

	m_pASE = pASE;

	return(hr);
	}




/*
 *
 *
 *
 * C P L L E l e m
 *
 * Programming Language List Element
 *
 *
 *
 *
 */ 

/*===================================================================
CPLLElem::~CPLLElem

Destructor for CPLLElem object.

Returns:
	Nothing

Side effects:
	Deallocates memory
===================================================================*/
CPLLElem::~CPLLElem()
	{
	CHAR *szT;

	// Free the memory allocated for the key string
	szT = (CHAR *)m_pKey;
	if (szT != NULL)
		free(szT);
	m_pKey = NULL;
	}

/*===================================================================
CPLLElem::Init

Init the Prog Lang Elem.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Allocates memory
===================================================================*/
HRESULT CPLLElem::Init
(
CHAR *szProgLangName,
PROGLANG_ID progLangId
)
	{
	HRESULT hr = S_OK;
	CHAR *szT;
	UINT cch;

	if (szProgLangName == NULL)
		{
		Assert(FALSE);
		return(E_FAIL);
		}
		
	cch = strlen(szProgLangName);
	szT = (CHAR *)malloc(cch+1);
	if (!szT)
		{
		return(E_OUTOFMEMORY);
		}
	strcpy(szT, szProgLangName);
	hr = CLinkElem::Init((LPVOID) szT, cch);
	if (FAILED(hr))
		{
		Assert(FALSE);		// Shouldnt fail
		free(szT);
		return(hr);
		}

	m_ProgLangId = progLangId;

	return(hr);
	}


/*===================================================================
GetProgLangIdOfName

Given the name of a programming language, get its programming
language Id from the registry.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT GetProgLangIdOfName
(
LPCSTR szProgLangName,
PROGLANG_ID *pProgLangId
)
	{
	HRESULT hr = S_OK;
	LONG lT;
	HKEY hkeyRoot, hkeyCLSID;
	DWORD dwType;
	CLSID clsid;
	CHAR szClsid[40];
	DWORD cbData;
	LPOLESTR strClsid;
    CMBCSToWChar    convStr;
	
	// The programming language id is really the CLSID of the scripting engine
	// It is in the registry under HKEY_CLASSES_ROOT.  Under the script name,
	// there is a key for "CLSID".  The CLSID is a value under the 
	// engine name.  E.g. \HKEY_CLASSES_ROOT\VBScript\CLSID
	lT = RegOpenKeyExA(HKEY_CLASSES_ROOT, szProgLangName, 0,
						KEY_READ, &hkeyRoot);
	if (lT != ERROR_SUCCESS)
		return(HRESULT_FROM_WIN32(lT));
	lT = RegOpenKeyExA(hkeyRoot, "CLSID", 0,
						KEY_READ, &hkeyCLSID);
	RegCloseKey(hkeyRoot);
	if (lT != ERROR_SUCCESS)
		return(HRESULT_FROM_WIN32(lT));

	cbData = sizeof(szClsid);
	lT = RegQueryValueExA(hkeyCLSID, NULL, 0, &dwType, (BYTE *)szClsid, &cbData);
	if (lT != ERROR_SUCCESS)
		{
		hr = HRESULT_FROM_WIN32(lT);
		goto lExit;
		}
	Assert(cbData <= sizeof(szClsid));

	// What we got back was the GUID as a string (e.g. {089999-444....}). Convert to a CLSID

    convStr.Init(szClsid);
	strClsid = convStr.GetString();
	hr = CLSIDFromString(strClsid, &clsid);

	*pProgLangId = clsid;

lExit:
	RegCloseKey(hkeyCLSID);

	return(hr);
	}




/*
 *
 *
 *
 * C S c r i p t i n g N a m e s p a c e
 *
 * Scripting namespace object
 *
 *
 *
 */ 

/*===================================================================
CScriptingNamespace::CScriptingNamespace

Constructor for CScriptingNamespace object.

Returns:
	Nothing

Side effects:
	None
===================================================================*/
CScriptingNamespace::CScriptingNamespace()
	: m_fInited(FALSE), m_cRef(1), m_cEngDispMac(0) 
	{
	}

/*===================================================================
CScriptingNamespace::~CScriptingNamespace

Destructor for CScriptingNamespace object.

Returns:
	Nothing

Side effects:
	Deallocates memory
===================================================================*/
CScriptingNamespace::~CScriptingNamespace()
	{
	UnInit();
	}

/*===================================================================
CScriptingNamespace::Init

Init the CScriptingNamespace object.

Returns:
	S_OK on success
===================================================================*/
HRESULT CScriptingNamespace::Init()
	{
	Assert(m_fInited == FALSE);
	
	m_fInited = TRUE;

	AssertValid();

	return(S_OK);
	}

/*===================================================================
CScriptingNamespace::UnInit

Free the script engine dispatch's

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Frees memory
===================================================================*/
HRESULT CScriptingNamespace::UnInit()
	{
    static const char *_pFuncName = "CScriptingNamespace::UnInit()";
	CEngineDispElem *pElem = NULL;
	ENGDISPBUCKET *pBucket = NULL;

	if (!m_fInited)
		return(S_OK);
		
	while (!m_listSE.FIsEmpty())
		{
		pElem = static_cast<CEngineDispElem *>(m_listSE.PNext());
		TRYCATCH_NOHITOBJ(pElem->m_pDisp->Release(),"IScriptDispatch::Release()");
        if (pElem->m_pDispEx) {
		        TRYCATCH_NOHITOBJ(pElem->m_pDispEx->Release(),"IScriptDispatchEx::Release()");
        }
		delete pElem;
		}

    while (!m_listEngDisp.FIsEmpty())
        {
        pBucket = static_cast<ENGDISPBUCKET *>(m_listEngDisp.PNext());
        delete pBucket;
        }
		
	m_cEngDispMac = 0;
	m_fInited = FALSE;

	return(S_OK);
	}

/*===================================================================
CScriptingNamespace::ReInit

Reinit the scripting namespace object

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Frees memory
===================================================================*/
HRESULT CScriptingNamespace::ReInit()
	{
	HRESULT hr;

	hr = UnInit();
	if (SUCCEEDED(hr))
		hr = Init();

	return(hr);
	}

/*===================================================================
CScriptingNamespace::AddEngineToNamespace

Add an engine to the list of engines

Returns:
	S_OK on success
===================================================================*/
HRESULT CScriptingNamespace::AddEngineToNamespace(CActiveScriptEngine *pASE)
	{
    static const char *_pFuncName = "CScriptingNamespace::AddEngineToNamespace()";
	HRESULT hr;
	IDispatch *pDisp = NULL;
	CEngineDispElem *pElem;

	AssertValid();
	Assert(pASE != NULL);
	pASE->AssertValid();

    TRYCATCH_HR_NOHITOBJ(pASE->GetActiveScript()->GetScriptDispatch(NULL, &pDisp), 
                         hr,
                         "IActiveScript::GetScriptDispatch()");	// FYI - does addref

	if (FAILED(hr))
		{
		goto LFail;
		}
	else
		if (pDisp == NULL)
			{
			hr = E_FAIL;
			goto LFail;
			}

	// Add the engine to the engine hash table.
	pElem = new CEngineDispElem;
	if (pElem == NULL)
		{
		hr = E_OUTOFMEMORY;
		goto LFail;
		}
	pElem->m_pDisp = pDisp;
    pElem->m_pDispEx = NULL;

    // QI for IDispatchEx if available
    TRYCATCH_NOHITOBJ(pDisp->QueryInterface(IID_IDispatchEx, (void **)&pElem->m_pDispEx),"IScriptDispatch::QueryInterface()");
	
	pElem->AppendTo(m_listSE);

	return(S_OK);
	
LFail:
    if (pDisp) {
		TRYCATCH_NOHITOBJ(pDisp->Release(),"IScriptDispatch::Release()");
    }
	return(hr);
	}

/*===================================================================
CScriptingNamespace::QueryInterface
CScriptingNamespace::AddRef
CScriptingNamespace::Release

IUnknown members for CScriptingNamespace object.
===================================================================*/
STDMETHODIMP CScriptingNamespace::QueryInterface(REFIID iid, void **ppvObj)
	{
	AssertValid();

	if (iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_IDispatchEx)
	    {
		*ppvObj = this;
        AddRef();
		return S_OK;
		}

	*ppvObj = NULL;
	return E_NOINTERFACE;
	}

STDMETHODIMP_(ULONG) CScriptingNamespace::AddRef(void)
	{
	AssertValid();

	return ++m_cRef;
	}

STDMETHODIMP_(ULONG) CScriptingNamespace::Release(void)
	{
	if (--m_cRef > 0)
		return m_cRef;

    delete this;
	return 0;
	}

/*===================================================================
CScriptingNamespace::GetTypeInfoCount

We have no typeinfo, so 0.

Parameters:
	pcInfo		UINT * to the location to receive
				the count of interfaces.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
STDMETHODIMP CScriptingNamespace::GetTypeInfoCount(UINT *pcInfo)
	{
	AssertValid();
	
	*pcInfo = 0;
	return S_OK;
	}

/*===================================================================
CScriptingNamespace::GetTypeInfo

We dont have a typeinfo

Parameters:
	itInfo			UINT reserved.	Must be zero.
	lcid			LCID providing the locale for the type
					information.	If the object does not support
					localization, this is ignored.
	ppITypeInfo		ITypeInfo ** in which to store the ITypeInfo
					interface for the object.

Return Value:
	HRESULT			S_OK or a general error code.
===================================================================*/
STDMETHODIMP CScriptingNamespace::GetTypeInfo
(
UINT itInfo,
LCID lcid,
ITypeInfo **ppITypeInfo
)
	{
	AssertValid();

	*ppITypeInfo = NULL;
	return(E_NOTIMPL);
	}

/*===================================================================
CScriptingNamespace::GetIDsOfNames

Looks through all the engines we know about, calling GetIdsOfNames on
them till we find the requested name.

Parameters:
	riid			REFIID reserved. Must be IID_NULL.
	rgszNames		OLECHAR ** pointing to the array of names to be mapped.
	cNames			UINT number of names to be mapped.
	lcid			LCID of the locale.
	rgDispID		DISPID * caller allocated array containing IDs
					corresponging to those names in rgszNames.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
STDMETHODIMP CScriptingNamespace::GetIDsOfNames
(
REFIID riid,
OLECHAR **rgszNames,
UINT cNames,
LCID lcid,
DISPID *rgDispID
)
	{
    static const char *_pFuncName = "CScriptingNamespace::GetIDsOfNames()";
	HRESULT hr;
	CEngineDispElem *pElem;

	AssertValid();

	if (IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

	/*
	 * Loop through the engines we know about until we find the one that has the requested name
	 * (or hit the end of the list, in which case it is not found)
	 */
	for (pElem = static_cast<CEngineDispElem *>(m_listSE.PNext());
		 pElem != &m_listSE;
		 pElem = static_cast<CEngineDispElem *>(pElem->PNext()))
		{
		Assert(pElem->m_pDisp != NULL);
		
		    TRYCATCH_HR_NOHITOBJ(pElem->m_pDisp->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispID), 
                                 hr,
                                 "IScriptDispatch::GetIDsOfNames()");
		
		if (SUCCEEDED(hr))
		    {
            return CacheDispID(pElem, rgDispID[0], rgDispID);
			}
		}

	return DISP_E_UNKNOWNNAME;
	}

/*===================================================================
CScriptingNamespace::Invoke

Map the dispID to the correct engine, and pass the invoke on to that
engine.

Parameters:
	dispID			DISPID of the method or property of interest.
	riid			REFIID reserved, must be IID_NULL.
	lcid			LCID of the locale.
	wFlags			USHORT describing the context of the invocation.
	pDispParams		DISPPARAMS * to the array of arguments.
	pVarResult		VARIANT * in which to store the result.	Is
					NULL if the caller is not interested.
	pExcepInfo		EXCEPINFO * to exception information.
	puArgErr		UINT * in which to store the index of an
					invalid parameter if DISP_E_TYPEMISMATCH
					is returned.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
STDMETHODIMP CScriptingNamespace::Invoke
(
DISPID dispID,
REFIID riid,
LCID lcid,
unsigned short wFlags,
DISPPARAMS *pDispParams,
VARIANT *pVarResult,
EXCEPINFO *pExcepInfo,
UINT *puArgErr
)
	{
    static const char *_pFuncName = "CScriptingNamespace::Invoke()";
	HRESULT hr;
    ENGDISP *pEngDisp;

	AssertValid();
	
	// riid is supposed to be IID_NULL always
	if (IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    // navigate to the correct ENGDISP structure 
    hr = FetchDispID(dispID, &pEngDisp);
    if (FAILED(hr))
        return hr;
	
	Assert(pEngDisp->pDisp != NULL);
	
    // invoke
	TRYCATCH_HR_NOHITOBJ(pEngDisp->pDisp->Invoke
	                        (
	                        pEngDisp->dispid, 
	                        riid, 
	                        lcid,
		                    wFlags, 
		                    pDispParams, 
		                    pVarResult, 
		                    pExcepInfo, 
		                    puArgErr
		                    ),
                         hr,
                         "IScriptDispatch::Invoke()");
	
	return hr;
	}

/*===================================================================
CScriptingNamespace::  IDispatchEx implementation stubs
===================================================================*/
STDMETHODIMP CScriptingNamespace::DeleteMemberByDispID(DISPID id)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::DeleteMemberByName(BSTR bstrName, DWORD grfdex)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::GetMemberName(DISPID id, BSTR *pbstrName)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::GetNameSpaceParent(IUnknown **ppunk)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
    {
    return E_NOTIMPL;
    }
    
/*===================================================================
CScriptingNamespace::GetDispID

IDispatchEx replacement for GetIDsOfNames
===================================================================*/
STDMETHODIMP CScriptingNamespace::GetDispID
(
BSTR bstrName, 
DWORD grfdex, 
DISPID *pid
)
    {
    static const char *_pFuncName = "CScriptingNamespace::GetDispID()";
    HRESULT hr;
	CEngineDispElem *pElem = NULL;
    grfdex &= ~fdexNameEnsure;  // engines shouldn't create new names

    // Try IDispatchEx for all engines that have it
    
	for (pElem = static_cast<CEngineDispElem *>(m_listSE.PNext());
		 pElem != &m_listSE;
		 pElem = static_cast<CEngineDispElem *>(pElem->PNext()))
		{
		if (pElem->m_pDispEx != NULL)
		    {
		    TRYCATCH_HR_NOHITOBJ(pElem->m_pDispEx->GetDispID(bstrName, grfdex, pid), 
                                 hr,
                                 "IScriptDispatchEx::GetDispID()");
		    
    		if (SUCCEEDED(hr))
	    	    {
                return CacheDispID(pElem, *pid, pid);
			    }
		    }
		}

    // Try IDispatch for engines that don't have IDispatchEx
	for (pElem = static_cast<CEngineDispElem *>(m_listSE.PNext());
		 pElem != &m_listSE;
		 pElem = static_cast<CEngineDispElem *>(pElem->PNext()))
		{
		if (pElem->m_pDispEx == NULL)
		    {
    		Assert(pElem->m_pDisp != NULL);
    		TRYCATCH_HR_NOHITOBJ(pElem->m_pDisp->GetIDsOfNames
            		                (
    	        	                IID_NULL,
    		                        &bstrName,
    		                        1,
    		                        LOCALE_SYSTEM_DEFAULT,
    		                        pid
    		                        ),
                                 hr,
                                 "IScriptDispatch::GetIDsOfNames()");
    		    
    		if (SUCCEEDED(hr))
	    	    {
                return CacheDispID(pElem, *pid, pid);
			    }
		    }
		}
	
	return DISP_E_UNKNOWNNAME;
    }
    
/*===================================================================
CScriptingNamespace::Invoke

IDispatchEx replacement for Invoke
===================================================================*/
STDMETHODIMP CScriptingNamespace::InvokeEx
(
DISPID id, 
LCID lcid, 
WORD wFlags, 
DISPPARAMS *pdp,
VARIANT *pVarRes,    
EXCEPINFO *pei,    
IServiceProvider *pspCaller 
)
    {
    static const char *_pFuncName = "CScriptingNamespace::InvokeEx()";
	HRESULT hr;
    ENGDISP *pEngDisp;

    // navigate to the correct ENGDISP structure 
    hr = FetchDispID(id, &pEngDisp);
    if (FAILED(hr))
        return hr;
	
    if (pEngDisp->pDispEx != NULL)
        {
        // InvokeEx if the engine supports IDispatchEx
        
    	TRYCATCH_HR_NOHITOBJ(pEngDisp->pDispEx->InvokeEx
    	                            (
    	                            pEngDisp->dispid, 
                                    lcid, 
                                    wFlags, 
                                    pdp,
                                    pVarRes,    
                                    pei,    
                                    pspCaller 
    	                            ),
                             hr,
                             "IScriptDispatchEx::InvokeEx()");
        }
    else
        {
        // use IDispatch::Invoke if the engine doesn't support IDispatchEx
    	Assert(pEngDisp->pDisp != NULL);

    	UINT uArgErr;
        
    	TRYCATCH_HR_NOHITOBJ(pEngDisp->pDisp->Invoke
    	                            (
    	                            pEngDisp->dispid, 
    	                            IID_NULL, 
    	                            lcid,
    		                        wFlags, 
    		                        pdp, 
    		                        pVarRes, 
    		                        pei, 
    		                        &uArgErr
    		                        ),
                             hr,
                             "IScriptDispatch::Invoke()");
	    }
	
	return hr;
    }

/*===================================================================
CScriptingNamespace::CacheDispID

Adds new DISPID to the list

Parameters
    pEngine         -- engine for which disp id found
    dispidEngine    -- found dispid
    pdispidCached   -- [out] cached dispid (for ScriptingNamespace)

Returns
    HRESULT    
===================================================================*/
HRESULT CScriptingNamespace::CacheDispID
(
CEngineDispElem *pEngine,
DISPID dispidEngine,
DISPID *pdispidCached
)
	{
	ENGDISPBUCKET *pEngDispBucket;
	
	// See if we need to add another bucket
	if ((m_cEngDispMac % ENGDISPMAX) == 0)
		{
		pEngDispBucket = new ENGDISPBUCKET;
		if (pEngDispBucket == NULL)
			return E_OUTOFMEMORY;

		pEngDispBucket->AppendTo(m_listEngDisp);
		}

    // Navigate to the correct bucket
	unsigned iEngDisp = m_cEngDispMac;
	pEngDispBucket = static_cast<ENGDISPBUCKET *>(m_listEngDisp.PNext());
	while (iEngDisp > ENGDISPMAX)
		{
		iEngDisp -= ENGDISPMAX;
		pEngDispBucket = static_cast<ENGDISPBUCKET *>(pEngDispBucket->PNext());
		}

	pEngDispBucket->rgEngDisp[iEngDisp].dispid  = dispidEngine;
	pEngDispBucket->rgEngDisp[iEngDisp].pDisp   = pEngine->m_pDisp;
	pEngDispBucket->rgEngDisp[iEngDisp].pDispEx = pEngine->m_pDispEx;

	// Return index as the dispid
	*pdispidCached = (DISPID)m_cEngDispMac;
	m_cEngDispMac++;
	return S_OK;
	}
    
/*===================================================================
CScriptingNamespace::FetchDispID

Find ENGDISP by DISPID

Parameters
    dispid      - in
    ppEngDisp   - out

Returns
    HRESULT    
===================================================================*/
HRESULT CScriptingNamespace::FetchDispID
(
DISPID dispid, 
ENGDISP **ppEngDisp
)
    {
	if (dispid >= (DISPID)m_cEngDispMac)
	    return E_FAIL;

	unsigned iEngDisp = dispid;
	ENGDISPBUCKET *pEngDispBucket = static_cast<ENGDISPBUCKET *>(m_listEngDisp.PNext());
	while (iEngDisp > ENGDISPMAX)
		{
		iEngDisp -= ENGDISPMAX;
		pEngDispBucket = static_cast<ENGDISPBUCKET *>(pEngDispBucket->PNext());
		}

    *ppEngDisp = &pEngDispBucket->rgEngDisp[iEngDisp];
    return S_OK;
    }
    

#ifdef DBG
/*===================================================================
CScriptingNamespace::AssertValid

Test to make sure that the CScriptingNamespace object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
	None.
===================================================================*/
VOID CScriptingNamespace::AssertValid() const
	{
	Assert(m_fInited);
	Assert(m_cRef > 0);
	}
	
#endif // DBG



/*
 *
 *
 * U t i l i t i e s
 *
 * General utility functions
 *
 */



/*===================================================================
WrapTypeLibs

Utility routine to take an array of Typelibs, and return an IDispatch
implementation that wraps the array of typelibs.

Parameters:
    ITypeLib **prgpTypeLib  - pointer to an array of typelibs
    UINT cTypeLibs          - count of typelibs in array
    IDispatch **ppDisp      - returned IDispatch

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
HRESULT WrapTypeLibs
(
ITypeLib **prgpTypeLib,
UINT cTypeLibs,
IDispatch **ppDisp
)
	{
	HRESULT hr;
	Assert(g_pWrapTypelibs != NULL);
	Assert(prgpTypeLib != NULL);
	Assert(cTypeLibs > 0);
	Assert(ppDisp != NULL);

    hr = g_pWrapTypelibs->WrapTypeLib(prgpTypeLib, cTypeLibs, ppDisp);
    
	return(hr);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\scrptmgr.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Script Manager

File: ScrptMgr.h

Owner: AndrewS

This file contains the declarations for the Script Manager, ie. siting an
ActiveX Scripting engine (in our case VBScript) for Denali.
===================================================================*/

#ifndef __ScrptMgr_h
#define __ScrptMgr_h

#include <dispex.h>

#include "activscp.h"
#include "activdbg.h"
#include "hostinfo.h"
#include "util.h"
#include "HitObj.h"
#include "hashing.h"
#include "memcls.h"
#include "scrpteng.h"


typedef SCRIPTSTATE ENGINESTATE;	// Uninited, Loaded, etc
typedef CLSID PROGLANG_ID;
const CBPROGLANG_ID = sizeof(PROGLANG_ID);

class CActiveScriptSite;
class CActiveScriptEngine;
class CASEElem;
class CScriptingNamespace;
class CAppln;

// SMHash depends on stuff in this include file which must be defined first.
#include "SMHash.h"

/*
 *
 *
 * C S c r i p t M a n a g e r
 *
 *
 * Manages script engines, potentially caching them for future use,
 * hands script engines to callers for use.
 *
 */
class CScriptManager
	{
private:
	// private data members
	BOOLB m_fInited;				// Are we initialized?

	/*
	 * Script Engines that are not in use can be reused and 
	 * go on the Free Script Queue.  It is a queue so we can
	 * discard the oldest if we need to.
	 *
	 * Engines that are in use cant be reused.  When an engine
	 * is handed out to be used, it is removed from the FSQ.  When a thread
	 * is done using an engine, it calls ReturnEngineToCache to put it back on
	 * the FSQ.  If the Queue is at max length, the oldest engine on the queue is
	 * freed at that point.  The one returned is put on the front of the queue.
	 *
	 * We also maintain a Running Script List.  This is needed so that if we 
	 * are told to flush a given script from our cache, we can "zombify" any
	 * running scripts that have that script in them (so they will be discarded
	 * when they are done running.)
	 *
	 * Additional note: Though we cant have multiple users of the *same* runing engine
	 * we can "clone" a running engine.  If we get two simulanteous requests for Foo.ASP
	 * we expect that it will be faster to clone the second one from the first one than
	 * to create a second engine for the second request.  Thus, the RSL will be searched
	 * for a given engine to clone if no suitable engine is found on the FSQ.
	 *
	 * DEBUGGING NOTE:
	 *    Once the debugger asks a script engine for a code context cookie, we cannot
	 *    ever let go of the script engine until the debugger detaches.  Therefore, we
	 *    don't cache scripts in the FSQ if debugging is active.  Instead, the scripts
	 *    are placed in the template when execution is finished, there to be doled back
	 *    out when that engine is needed by the debugging engine.
	 *
	 *    CONSIDER:
	 *       We could be smarter about this, and cache scripts UNTIL the debugger either
	 *          a. Asks for a code context from a document context, or
	 *          b. Calls GetDocumentContextFromPosition, in which case, the debugger
	 *             got a code context "behind our virtual backs".
	 *
	 *       If we don't do this, we could, at the very least, only implement this
	 *       debugging behavior when a debugger attaches to our application.
	 *       (i.e. stop caching on attach, then on detach, resume caching, and also
	 *        free scripts that the template objects are holding onto.)
	 */
	CSMHash m_htFSQ;				// Free Script Queue
	CRITICAL_SECTION m_csFSQ;		// Serialize access to FSQ
	CSMHash m_htRSL;				// Running Script List
	CRITICAL_SECTION m_csRSL;		// Serialize access to RSL

	CHashTable 		m_hTPLL;		// Hash table of language engine classid's
	CRITICAL_SECTION m_cSPLL;		// Serialize access to PLL

	DWORD m_idScriptKiller;         // Script killer sched workitem id
	DWORD m_msecScriptKillerTimeout;// Current script killer timeout

	// private methods
	HRESULT UnInitASEElems();
	HRESULT UnInitPLL();
	HRESULT AddProgLangToPLL(CHAR *szProgLangName, PROGLANG_ID progLangId);

    // script killer
	static VOID WINAPI ScriptKillerSchedulerCallback(VOID *pv);

public:	
	// public methods
	CScriptManager();
	~CScriptManager();

	HRESULT Init();
	HRESULT UnInit();

	// Resolves a language name into a prog lang id, adding to engine list (m_hTPLL) if not already there
	HRESULT ProgLangIdOfLangName(LPCSTR szProgLang, PROGLANG_ID *pProgLangId);

	// Return an engine, preferably filled with the script for the given template/language
	HRESULT GetEngine(	LCID lcid,					// The system language to use
						PROGLANG_ID& progLangId,	// prog lang id of the script
						LPCTSTR szTemplateName,		// Template we want an engine for
						CHitObj *pHitObj,			// Hit obj to use in this engine
						CScriptEngine **ppSE,		// Returned script engine
						ENGINESTATE *pdwState,		// Current state of the engine
						CTemplate *pTemplate,		// template (debug document)
						DWORD dwSourceContext);		// script engine index

	HRESULT ReturnEngineToCache(CScriptEngine **, CAppln *, IASPObjectContextCustom *);

	// Throw out any cached engines containing a given template
	// (presumably the script changed on disk so the cache is obsolete.)
	HRESULT FlushCache(LPCTSTR szTemplateName);	// Template to throw out of the cache

	HRESULT FlushAll();    // Clear the entire FSQ

	HRESULT KillOldEngines(BOOLB fKillNow = FALSE); // Kill expired scripting engines

	// Bug 1140: Called prior to shutting down script manager to make sure RSL is empty
	HRESULT EmptyRunningScriptList();

    // Adjust (shorten) script killer timeout
    HRESULT AdjustScriptKillerTimeout(DWORD msecNewTimeout);

	// Find running script that corresponds to a template (in one of its script blocks)
	IActiveScriptDebug *GetDebugScript(CTemplate *pTemplate, DWORD dwSourceContext);

private:
	HRESULT FindEngineInList(LPCTSTR szTemplateName, PROGLANG_ID progLangId, DWORD dwInstanceID, BOOL fFSQ, CASEElem **ppASEElem);
	HRESULT FindASEElemInList(CActiveScriptEngine *pASE, BOOL fFSQ, CASEElem **ppASEElem);

	// For threading a FIFO queue through the hash table
	HRESULT AddToFSQ(CASEElem *pASEElem);
	HRESULT CheckFSQLRU();

#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif
	};

extern CScriptManager g_ScriptManager;


/*
 *
 *
 * C A c t i v e S c r i p t E n g i n e
 *
 * Object defining methods required to host an ActiveXScripting engine &
 * service requests to that engine.
 *
 */
class CActiveScriptEngine :
				public CScriptEngine,
				public IActiveScriptSite,
				public IActiveScriptSiteDebug,
				public IHostInfoProvider
	{
private:
	// private data members
	UINT m_cRef;				// Reference count
	IDispatch *m_pDisp;			// IDispatch interface on script
	CHitObj *m_pHitObj;			// The hit object contains a list of objects for this run
	LPTSTR m_szTemplateName;	// The name of the template this engine has loaded
	DWORD m_dwInstanceID;		// server instance ID of template this engine has loaded
	TCHAR m_szTemplateNameBuf[64]; // Buffer for short templates to fit to avoid allocs
	PROGLANG_ID m_proglang_id;	// What programming language?
	LCID m_lcid;				// what system language
	IActiveScript *m_pAS;		// The script object sited here
	IActiveScriptParse *m_pASP;	// The script object parser
	IHostInfoUpdate *m_pHIUpdate;// Interface for advising the script that we have new host info
	time_t m_timeStarted;		// Time when the script engine was handed out last.
	CTemplate *m_pTemplate;		// template that acts as debugging document
	DWORD m_dwSourceContext;	// "Cookie" value which is really script engine
	DWORD m_fInited : 1;		// Have we been inited?
	DWORD m_fZombie : 1;		// Do we need to be deleted on last use
	DWORD m_fScriptLoaded : 1;	// Have we been called with script to load yet? (Used for clone)
	DWORD m_fObjectsLoaded : 1;	// Have we been called with a set of objects yet? (Used for clone)
	DWORD m_fBeingDebugged : 1;	// Is this script being debugged now?
	DWORD m_fTemplateNameAllocated : 1; // Is name allocated? (need to free?)

	/*
	 * NOTE: ActiveXScripting:
	 * ActiveXScripting had an undone such that the excepinfo filled in in InteruptScript
	 * was not passed to OnScriptError.  We would have liked to use that mechanism to cause
	 * correct error loging (or suppression) if we interrupt a script.  However,
	 * since ActiveXScripting wasnt passing the info, we didnt know.  We wrote this code to 
	 * handle it ourselves.  They have now fixed it, but the mechanism we implemented works very
	 * well, so we are not going to change it.
	 */
	DWORD m_fScriptAborted : 1;		// The script did a Response.End
	DWORD m_fScriptTimedOut : 1;	// We killed the script on timeout
	DWORD m_fScriptHadError : 1;	// The script had an error while running.  Transacted script should autoabort

	/*
	 * BUG 1225: If there is a GPF running a script, we shouldnt reuse the engine
	 */
	DWORD m_fCorrupted : 1;		// Might the engine be "unsafe" for reuse?

    // handle GetItemInfo() failure
	void HandleItemNotFound(LPCOLESTR pcszName);

	HRESULT StoreTemplateName(LPCTSTR szTemplateName);

public:
	CActiveScriptEngine();
	~CActiveScriptEngine();

	HRESULT Init(
				PROGLANG_ID proglang_id,
				LPCTSTR szTemplateName,
				LCID lcid,
				CHitObj *pHitObj,
				CTemplate *pTemplate,
				DWORD dwSourceContext);

	HRESULT MakeClone(
				PROGLANG_ID proglang_id,
				LPCTSTR szTemplateName,
				LCID lcid,
				CHitObj *pHitObj,
				CTemplate *pTemplate,
				DWORD dwSourceContext,
				DWORD dwInstanceID,
				IActiveScript *pAS);			// The cloned script engine

	HRESULT ReuseEngine(
						CHitObj *pHitObj,
						CTemplate *pTemplate,
						DWORD dwSourceContext,
						DWORD dwInstanceID
						);

	time_t TimeStarted();
	VOID SetTimeStarted(time_t timeStarted);

	BOOL FBeingDebugged();			// Is the script being debugged?
	VOID IsBeingDebugged();			// Notify script that it is being debugged

	HRESULT ResetToUninitialized(IASPObjectContextCustom *);
	HRESULT GetASP();
	HRESULT GetIDisp();
	HRESULT GetIHostInfoUpdate();
	IActiveScript *GetActiveScript();
	LPTSTR SzTemplateName();
	BOOL FIsZombie();
	BOOL FIsCorrupted();
	PROGLANG_ID ProgLang_Id();
	DWORD DWInstanceID();
	BOOL FFullyLoaded();
	long GetTimeout();
	BOOL FScriptTimedOut();
	BOOL FScriptHadError();
	void GetDebugDocument(CTemplate **ppTemplate, DWORD *pdwSourceContext);


	/*
	 * C S c r i p t E n g i n e   M e t h o d s
	 */
	HRESULT AddScriptlet(LPCOLESTR wstrScript);

	HRESULT AddObjects(BOOL fPersistNames = TRUE);

	HRESULT AddAdditionalObject(LPWSTR strObjName, BOOL fPersistNames = TRUE);

	HRESULT AddScriptingNamespace();
	
	HRESULT Call(LPCOLESTR strEntryPoint);

	HRESULT CheckEntryPoint(LPCOLESTR strEntryPoint);

	HRESULT MakeEngineRunnable()  { return(Call(NULL)); };

	HRESULT ResetScript() { return m_pAS? m_pAS->SetScriptState(SCRIPTSTATE_UNINITIALIZED) : E_FAIL; }

	VOID Zombify();

	HRESULT InterruptScript(BOOL fAbnormal = TRUE);

	HRESULT UpdateLocaleInfo(hostinfo hi);

	HRESULT TryCall(LPCOLESTR strEntryPoint);

	ULONG FinalRelease();

	/*
	 * I U n k n o w n   M e t h o d s
	 */
	STDMETHOD(QueryInterface)(REFIID riid, PVOID *ppvObject);
	STDMETHOD_(ULONG, AddRef)(VOID);
	STDMETHOD_(ULONG, Release)(VOID);

	/*
	 * C A c t i v e S c r i p t S i t e   M e t h o d s
	 */
	STDMETHOD(GetLCID)(LCID *plcid);

	STDMETHOD(GetItemInfo)(LPCOLESTR pcszName,
							DWORD dwReturnMask,
							IUnknown **ppiunkItem,
							ITypeInfo **ppti);

	STDMETHOD(GetDocVersionString)(BSTR *pszVersion);

	STDMETHOD(RequestItems)(BOOL fPersistNames = TRUE);

	STDMETHOD(RequestTypeLibs)(VOID);

	STDMETHOD(OnScriptTerminate)(const VARIANT *pvarResult,
								const EXCEPINFO *pexcepinfo);
	STDMETHOD(OnStateChange)(SCRIPTSTATE ssScriptState);

	STDMETHOD(OnScriptError)(IActiveScriptError __RPC_FAR *pscripterror);

	STDMETHOD(OnEnterScript)(VOID);

	STDMETHOD(OnLeaveScript)(VOID);

	/*
	 * C A c t i v e S c r i p t S i t e D e b u g   M e t h o d s
	 */
	STDMETHOD(GetDocumentContextFromPosition)(
			/* [in] */ DWORD_PTR dwSourceContext,
			/* [in] */ ULONG uCharacterOffset,
			/* [in] */ ULONG uNumChars,
			/* [out] */ IDebugDocumentContext **ppsc);

	STDMETHOD(GetApplication)(/* [out] */ IDebugApplication **ppda);

	STDMETHOD(GetRootApplicationNode)(/* [out] */ IDebugApplicationNode **);

	STDMETHOD(OnScriptErrorDebug)(
			/* [in] */ IActiveScriptErrorDebug *pErrorDebug,
			/* [out] */ BOOL *pfEnterDebugger,
			/* [out] */ BOOL *pfCallOnScriptErrorWhenContinuing);
        
        
	/*
	 * IHostInfoProvider methods
	 */

	 STDMETHOD(GetHostInfo)(hostinfo hostinfoRequest, void **ppvInfo);

public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline VOID CActiveScriptEngine::Zombify() { m_fZombie = TRUE; }
inline BOOL CActiveScriptEngine::FFullyLoaded() { return(m_fScriptLoaded && m_fObjectsLoaded); }
inline BOOL CActiveScriptEngine::FIsZombie() { return(m_fZombie); }
inline BOOL CActiveScriptEngine::FIsCorrupted() { return(m_fCorrupted); }
inline time_t CActiveScriptEngine::TimeStarted() { return(m_timeStarted); }
inline VOID CActiveScriptEngine::SetTimeStarted(time_t timeStarted) { m_timeStarted = timeStarted; }
inline IActiveScript *CActiveScriptEngine::GetActiveScript() { return(m_pAS); }
inline LPTSTR CActiveScriptEngine::SzTemplateName() { return(m_szTemplateName); }
inline PROGLANG_ID CActiveScriptEngine::ProgLang_Id() { return(m_proglang_id); }
inline DWORD CActiveScriptEngine::DWInstanceID() { return(m_dwInstanceID); }
inline BOOL CActiveScriptEngine::FBeingDebugged() { return(m_fBeingDebugged); }			// Is the script being debugged?
inline VOID CActiveScriptEngine::IsBeingDebugged() { m_fBeingDebugged = TRUE; }
inline BOOL CActiveScriptEngine::FScriptTimedOut() { return m_fScriptTimedOut; }
inline BOOL CActiveScriptEngine::FScriptHadError() { return m_fScriptHadError; }
inline long CActiveScriptEngine::GetTimeout() { return m_fBeingDebugged? LONG_MAX : m_pHitObj->GetScriptTimeout(); }
inline void CActiveScriptEngine::GetDebugDocument(CTemplate **ppTemplate, DWORD *pdwSourceContext)
	{
	if (ppTemplate) *ppTemplate = m_pTemplate;
	if (pdwSourceContext) *pdwSourceContext = m_dwSourceContext;
	}

/*
 *
 *
 * C A S E E l e m
 *
 * Script element.  For keeping lists and queues of script engines
 *
 */
class CASEElem : public CLruLinkElem
	{
private:
	CActiveScriptEngine *m_pASE;

public:
	CASEElem() : m_pASE(NULL) {}
	~CASEElem();

	HRESULT Init(CActiveScriptEngine *pASE);
	CActiveScriptEngine *PASE();
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

inline CActiveScriptEngine *CASEElem::PASE() { return(m_pASE); }


/*
 *
 *
 * C P L L E l e m
 *
 * Hash table list element for a Programming Language List.
 *
 */
class CPLLElem : public CLinkElem
	{
private:
	PROGLANG_ID m_ProgLangId;			// clsid for the language
	
public:
	CPLLElem() : m_ProgLangId(CLSID_NULL) {};
	~CPLLElem();

	HRESULT Init(CHAR *szProgLangName, PROGLANG_ID progLangId);
	PROGLANG_ID ProgLangId();
	};

inline PROGLANG_ID CPLLElem::ProgLangId() { return(m_ProgLangId); }


/*
 *
 *
 * C S c r i p t i n g N a m e s p a c e
 *
 * We need to keep track of all of the names which different engines (and typeinfos)
 * contribute to the namespace.   All of these names go into this object
 * which we give to each engine with the SCRIPTITEM_GLOBALMEMBERS flag. When
 * ActiveXScripting calls us back on GetIdsOfNames, we will call the engines
 * we have cached until we find the name.  When AXS calls us with Invoke,
 * we will map the id to the appropriate engine and pass on the invoke
 *
 * Data structure note:
 *   We implement the ScriptingNamespace with a linked list of arrays.
 *   This gives reasonable access time and should minimize heap
 *   fragmentation.  In debug mode, the number of buckets is small to
 *   excersize the resize code.
 *
 * NOTE: "ENGDISPMAX" should be a power of two - this will allow the optimizer
 *       to optimize the integer divide and modulus operations with bit-ands and
 *       shifts.  However, the code does not assume that "ENGDISPMAX" is a power
 *       of two.
 */

#ifdef DBG
#define ENGDISPMAX 2
#else
#define ENGDISPMAX 32
#endif

typedef struct _engdisp
	{
	DISPID dispid;				// the dispid that the engine really uses
	IDispatch *pDisp;			// the engine to call for this dispid
	IDispatchEx *pDispEx;	    // the engine to call for this dispid
	} ENGDISP;

typedef struct _engdispbucket : CDblLink
	{
	ENGDISP rgEngDisp[ENGDISPMAX+1];
	} ENGDISPBUCKET;

class CEngineDispElem : public CDblLink
	{
public:
	IDispatch *m_pDisp;
	IDispatchEx *m_pDispEx;
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

class CScriptingNamespace : public IDispatchEx
	{
private:
	ULONG m_cRef;				// Reference count
	BOOLB m_fInited;
	CDblLink m_listSE;			// List of scripting engines (list of CSEElem's)
	UINT m_cEngDispMac;
	CDblLink m_listEngDisp;

    HRESULT CacheDispID(CEngineDispElem *pEngine, DISPID dispidEngine, DISPID *pdispidCached);
    HRESULT FetchDispID(DISPID dispid, ENGDISP **ppEngDisp);

public:
	// public methods
	CScriptingNamespace();
	~CScriptingNamespace();

	HRESULT Init();
	HRESULT UnInit();
	HRESULT ReInit();
	HRESULT AddEngineToNamespace(CActiveScriptEngine *pASE);

    // IUnknown
	STDMETHODIMP QueryInterface(REFIID, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
    // IDispatch
	STDMETHODIMP GetTypeInfoCount(UINT *);
	STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
	STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
	STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD,
						DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);
    // IDispatchEx
    STDMETHODIMP DeleteMemberByDispID(DISPID id);
    STDMETHODIMP DeleteMemberByName(BSTR bstrName, DWORD grfdex);
    STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName);
    STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk);
    STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid);
    STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
    STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
                          VARIANT *pVarRes, EXCEPINFO *pei, IServiceProvider *pspCaller);

public:
#ifdef DBG
	VOID AssertValid() const;
#else
	VOID AssertValid() const {}
#endif

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};


/*
 *
 *
 * U t i l i t i e s
 *
 * General utility functions
 *
 */
HRESULT WrapTypeLibs(ITypeLib **prgpTypeLib, UINT cTypeLibs, IDispatch **ppDisp);

#endif // __ScrptMgr_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\response.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Response object

File: response.h

Owner: CGrant

This file contains the header info for defining the Response object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef _RESPONSE_H
#define _RESPONSE_H

#include "debug.h"
#include "util.h"
#include "template.h"
#include "disptch2.h"
#include "hashing.h"
#include "memcls.h" 
#include "ftm.h"

const DWORD RESPONSE_BUFFER_SIZE = 32768;
const DWORD BUFFERS_INCREMENT = 256;
const DWORD ALLOCA_LIMIT = 4096;
const DWORD MAX_RESPONSE = 32768;
const DWORD MAX_MESSAGE_LENGTH = 512;

class CScriptEngine;

#ifdef USE_LOCALE
extern DWORD	 g_dwTLS;
#endif

// fixed size allocator for response buffers
ACACHE_FSA_EXTERN(ResponseBuffer)

// forward refs
class CResponse;
class CRequest;

//This file is generated from MKTYPLIB on denali.obj
#include "asptlb.h"

//Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);

//Type for the "Get Active Script Engine" callback
typedef CScriptEngine *(*PFNGETSCRIPT)(int iScriptEngine, void *pvContext);

/*
 * C H T T P H e a d e r L i n k
 *
 */

class CHTTPHeader
	{
private:
    DWORD m_fInited : 1;
    DWORD m_fNameAllocated : 1;
    DWORD m_fValueAllocated : 1;
    
	char *m_szName;
	char *m_szValue;
	
    DWORD m_cchName;
    DWORD m_cchValue;

    CHTTPHeader *m_pNext;

	char m_rgchLtoaBuffer[20];  // enough for atol

public:
	CHTTPHeader();
	~CHTTPHeader();

	HRESULT InitHeader(BSTR wszName, BSTR wszValue, UINT lCodePage = CP_ACP);
	HRESULT InitHeader(char *szName, BSTR wszValue, UINT lCodePage = CP_ACP);
	HRESULT InitHeader(char *szName, char *szValue, BOOL fCopyValue);
	HRESULT InitHeader(char *szName, long lValue);

	char *PSzName();
	char *PSzValue();
	DWORD CchLength();
	
	void  Print(char *szBuf);

	void  SetNext(CHTTPHeader *pHeader);
	CHTTPHeader *PNext();
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

// CHTTPHeader inlines

inline char *CHTTPHeader::PSzName()
    {
    Assert(m_fInited);
    return m_szName; 
    }
    
inline char *CHTTPHeader::PSzValue()
    {
    Assert(m_fInited);
    return m_szValue; 
    }
	
inline DWORD CHTTPHeader::CchLength()
    {
    Assert(m_fInited);
    return (m_cchName + m_cchValue + 4); // account for ": " and "\r\n"
    }

inline void CHTTPHeader::SetNext(CHTTPHeader *pHeader)
    {
    Assert(m_fInited);
    Assert(!m_pNext);
    m_pNext = pHeader;
    }
    
inline CHTTPHeader *CHTTPHeader::PNext()
    {
    return m_pNext;
    }

/*
 * C R e s p o n s e B u f f e r
 *
 */

class CResponseBuffer
	{
	CResponse*			m_pResponse;				// Pointer to enclosing response
	char				**m_rgpchBuffers;			// Array of pointers to buffers
	char                *m_pchBuffer0;              // In case of 1 element array of pointers
	DWORD				m_cBufferPointers;			// Count of buffer pointers
	DWORD				m_cBuffers;					// Count of buffers we have allocated
	DWORD				m_iCurrentBuffer;			// Array index for the buffer we are currently filling
	DWORD				m_cchOffsetInCurrentBuffer;	// Offset within the current buffer
	DWORD				m_cchTotalBuffered;			// Total of ouput bytes buffered
	BOOL				m_fInited;					// Initialization status for the object

	HRESULT				GrowBuffers(DWORD cchNewRequest);	// Increase the size of the buffers

public:
	CResponseBuffer();
	~CResponseBuffer();      
	HRESULT Init(CResponse* pResponse);
	char * GetBuffer(UINT i);
	DWORD GetBufferSize(UINT i);
	DWORD CountOfBuffers();
	DWORD BytesBuffered();
	HRESULT Write(char* pszSource, DWORD cch);
	HRESULT Flush(CIsapiReqInfo *pIReq);
	HRESULT Clear();

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

inline char * CResponseBuffer::GetBuffer(UINT i)
    {
    Assert( i < m_cBuffers );
    return m_rgpchBuffers[i];
    }

inline DWORD CResponseBuffer::GetBufferSize(UINT i)
    {
    Assert( i < m_cBuffers );

    // if buffer is final one, its content-length is current offset
    if ( i == (m_cBuffers - 1 ) )
        {
        return m_cchOffsetInCurrentBuffer;
        }

    // if buffer is other than final one, its content-length is default buffer size
    return RESPONSE_BUFFER_SIZE;
    }

inline DWORD CResponseBuffer::CountOfBuffers()
    {
    return m_cBuffers; 
    }

inline DWORD CResponseBuffer::BytesBuffered()
    {
    return m_cchTotalBuffered; 
    }

/*
 * C D e b u g R e s p o n s e B u f f e r
 *
 */

class CDebugResponseBuffer : public CResponseBuffer
    {
private:
    HRESULT Write(const char* pszSource);

public:
	inline CDebugResponseBuffer() {}
	inline ~CDebugResponseBuffer() {}     

    HRESULT Start();
    HRESULT End();

    HRESULT InitAndStart(CResponse* pResponse);
    HRESULT ClearAndStart();

    // the only real method
	HRESULT AppendRecord
	    (
	    const int cchBlockOffset,
	    const int cchBlockLength,
	    const int cchSourceOffset,
	    const char *pszSourceFile = NULL
	    );
	    
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline HRESULT CDebugResponseBuffer::Write(const char* pszSource)
    {
    return CResponseBuffer::Write((char *)pszSource, strlen(pszSource));
    }

inline HRESULT CDebugResponseBuffer::Start()
    {
    return Write("<!--METADATA TYPE=\"ASP_DEBUG_INFO\"\r\n");
    }

inline HRESULT CDebugResponseBuffer::End()
    {
    return Write("-->\r\n");
    }
    
inline HRESULT CDebugResponseBuffer::InitAndStart(CResponse* pResponse)
    {
    HRESULT hr = CResponseBuffer::Init(pResponse);
    if (SUCCEEDED(hr))
        hr = Start();
    return hr;
    }

inline HRESULT CDebugResponseBuffer::ClearAndStart()
    {
    HRESULT hr = CResponseBuffer::Clear();
    if (SUCCEEDED(hr))
        hr = Start();
    return hr;
    }

/*
 * C R e s p o n s e C o o k i e s
 *
 * Implements the IRequestDictionary interface for writing cookies.
 */

class CResponseCookies : public IRequestDictionaryImpl
	{
private:
    IUnknown *          m_punkOuter;        // for addrefs
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr
	CRequest *			m_pRequest;			// pointer to request object
	CResponse *			m_pResponse;		// pointer to parent object

public:
	CResponseCookies(CResponse *, IUnknown *);
	~CResponseCookies();
	
	HRESULT Init()
		{
		return S_OK;
		}

	HRESULT ReInit(CRequest *);

	// The Big Three
	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface
	STDMETHODIMP	get_Item(VARIANT varKey, VARIANT *pvarReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);

	// C++ interface to write headers

	size_t QueryHeaderSize();
	char *GetHeaders(char *szBuffer);
	};

/*
 * C R e s p o n s e D a t a
 *
 * Structure that holds the intrinsic's properties.
 * The instrinsic keeps pointer to it (NULL when lightweight)
 */
class CResponseData : public IUnknown
    {
friend CResponse;
friend CResponseCookies;
friend CResponseBuffer;
    
private:
    // constructor to pass params to members and init members
    CResponseData(CResponse *pResponse);
    ~CResponseData();
    
    HRESULT Init(CResponse *pResponse);

	CSupportErrorInfo	    m_ISupportErrImp;	    // Interface to indicate that we support ErrorInfo reporting
	CIsapiReqInfo *         m_pIReq;				    // CIsapiReqInfo block for HTTP info
	CHitObj*				m_pHitObj;			    // pointer to hitobj for this request
	CTemplate*				m_pTemplate;		    // Pointer to the template for this request
    CHTTPHeader*            m_pFirstHeader;	        // List of
    CHTTPHeader*            m_pLastHeader;	        //      headers
	time_t					m_tExpires;			    // date that the HTML output page expires; -1 if no date assigned
	const char*				m_szCookieVal;		    // Value of session id
	const char*             m_pszDefaultContentType;// Default content type (pointer to static string)
    const char*             m_pszDefaultExpires;    // Default expires header value
	char*					m_pszContentType;	    // Content type of response (set by user)
	char*					m_pszCharSet;			// CharSet header of response
	char*					m_pszCacheControl;		// cache-control header of response
	char*					m_pszStatus;		    // HTTP Status to be returned
	BYTE					m_dwVersionMajor;		// Major version of HTTP supported by client
	BYTE					m_dwVersionMinor;		// Minor version of HTTP supported by client
	CResponseBuffer *		m_pResponseBuffer;	    // Pointer to response buffer object
	CDebugResponseBuffer *  m_pClientDebugBuffer;   // Pointer to response buffer object for client debugging data
	int						m_IsHeadRequest;	    // HEAD request flag 0=uninit, 1=not head, 2=head
	PFNGETSCRIPT			m_pfnGetScript;		    // Pointer to callback function for obtaining CActiveEngine pointers
	void*					m_pvGetScriptContext;   // Pointer to data for for callback function for CActiveEngines
	CResponseCookies		m_WriteCookies;		    // write-only cookie collection
	BOOL					m_fHeadersWritten : 1;	// Have the output headers been written?
	BOOL					m_fResponseAborted : 1;	// Was "Response.End" invoked?
	BOOL					m_fWriteClientError : 1;// Write Client Failed
	BOOL                    m_fIgnoreWrites : 1;    // Ignore all writes? (in case of custom error)
	BOOL					m_fBufferingOn : 1;		// Buffer response output
	BOOL                    m_fFlushed : 1;         // Has flush been called?             
	BOOL                    m_fChunked : 1;         // Doing HTTP 1.1 chunking?
	BOOL                    m_fClientDebugMode : 1; // In client debug mode?
	BOOL                    m_fClientDebugFlushIgnored : 1; // Flush request ignored due to client debug?
	ULONG                   m_cRefs;                // ref count

    void AppendHeaderToList(CHTTPHeader *pHeader);
        
public:	
	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline void CResponseData::AppendHeaderToList(CHTTPHeader *pHeader)
    {
    if (!m_pLastHeader)
        {
        Assert(!m_pFirstHeader);
        m_pFirstHeader = pHeader;
        }
    else
        {
        Assert(m_pFirstHeader);
        m_pLastHeader->SetNext(pHeader);
        }
    m_pLastHeader = pHeader;
    }


    
/*
 * C R e s p o n s e
 *
 * Implements the Response object
 */
class CResponse : public IResponseImpl, public CFTMImplementation, public IStream
	{

friend CResponseCookies;
friend CResponseBuffer;

private:
    // Flags
	DWORD m_fInited : 1;	    // Is initialized?
	DWORD m_fDiagnostics : 1;   // Display ref count in debug output
	DWORD m_fOuterUnknown : 1;  // Ref count outer unknown?

    // Ref count / Outer unknown
    union
    {
    DWORD m_cRefs;
    IUnknown *m_punkOuter;
    };

    // Properties
    CResponseData *m_pData;   // pointer to structure that holds
                              // CResponse properties

	VOID	GetClientVerison(VOID);
	HRESULT WriteClient(BYTE *pb, DWORD cb);
	HRESULT WriteClientChunked(BYTE *pb, DWORD cb);

#ifdef DBG
    inline void TurnDiagsOn()  { m_fDiagnostics = TRUE; }
    inline void TurnDiagsOff() { m_fDiagnostics = FALSE; }
    void AssertValid() const;
#else
    inline void TurnDiagsOn()  {}
    inline void TurnDiagsOff() {}
    inline void AssertValid() const {}
#endif

public:
	CResponse(IUnknown *punkOuter = NULL);
	~CResponse();

    HRESULT CleanUp();
	HRESULT	Init();
	HRESULT UnInit();
	
	HRESULT	ReInitTemplate(CTemplate* pTemplate, const char *szCookie);

	CTemplate *SwapTemplate(CTemplate* pNewTemplate);
	
	HRESULT	ReInit(CIsapiReqInfo *pIReq, const char *szCookie, CRequest *pRequest,
 				   PFNGETSCRIPT pfnGetScript, void *pvGetScriptContext, CHitObj *pHitObj);

	HRESULT	WriteHeaders(BOOL fSendEntireResponse = FALSE);
	HRESULT	FinalFlush(HRESULT);
	HRESULT	WriteSz(CHAR *sz, DWORD cch);
	HRESULT	WriteBSTR(BSTR bstr);

    // append headers of different kind
	HRESULT AppendHeader(BSTR wszName, BSTR wszValue);
	HRESULT AppendHeader(char *szName, BSTR wszValue);
	HRESULT AppendHeader(char *szName, char *szValue, BOOL fCopyValue = FALSE);
	HRESULT AppendHeader(char *szName, long lValue);

	// inlines
	inline BOOL	FHeadersWritten();
	inline BOOL	IsHeadRequest(void);
	inline BOOL	FResponseAborted();
	inline BOOL	FWriteClientError();
	inline BOOL FDontWrite();
	inline void	SetHeadersWritten();
	inline void SetIgnoreWrites();
    inline CIsapiReqInfo* GetIReq();
    inline const char* PContentType() const;
    inline char *PCustomStatus();
    inline void *SwapScriptEngineInfo(void *pvEngineInfo);
		
	//Non-delegating object IUnknown
	STDMETHODIMP		 QueryInterface(REFIID, PPVOID);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

    // GetIDsOfNames special-case implementation
	STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);

    // Tombstone stub
	HRESULT CheckForTombstone();

	//IResponse functions
	STDMETHODIMP	Write(VARIANT varInput);
	STDMETHODIMP	BinaryWrite(VARIANT varInput);
	STDMETHODIMP	WriteBlock(short iBlockNumber);
	STDMETHODIMP	Redirect(BSTR bstrURL);
	STDMETHODIMP	AddHeader(BSTR bstrHeaderName, BSTR bstrHeaderValue);
	STDMETHODIMP	Pics(BSTR bstrHeaderValue);	
	STDMETHODIMP	Add(BSTR bstrHeaderValue, BSTR bstrHeaderName);
	STDMETHODIMP	SetCookie(BSTR bstrHeader, BSTR bstrValue, VARIANT varExpires,
							VARIANT varDomain, VARIANT varPath, VARIANT varSecure);
	STDMETHODIMP	Clear(void);
	STDMETHODIMP	Flush(void);
	STDMETHODIMP	End(void);
	STDMETHODIMP	AppendToLog(BSTR bstrLogEntry);
	STDMETHODIMP	get_ContentType(BSTR *pbstrContentTypeRet);
	STDMETHODIMP	put_ContentType(BSTR bstrContentType);
	STDMETHODIMP	get_CharSet(BSTR *pbstrContentTypeRet);
	STDMETHODIMP	put_CharSet(BSTR bstrContentType);
	STDMETHODIMP	get_CacheControl(BSTR *pbstrCacheControl);
	STDMETHODIMP	put_CacheControl(BSTR bstrCacheControl);	
	STDMETHODIMP	get_Status(BSTR *pbstrStatusRet);	
	STDMETHODIMP	put_Status(BSTR bstrStatus);
	STDMETHODIMP	get_Expires(VARIANT *pvarExpiresMinutesRet);
	STDMETHODIMP	put_Expires(long lExpiresMinutes);
	STDMETHODIMP	get_ExpiresAbsolute(VARIANT *pvarTimeRet);
	STDMETHODIMP	put_ExpiresAbsolute(DATE dtExpires);
	STDMETHODIMP	get_Buffer(VARIANT_BOOL* fIsBuffering);
	STDMETHODIMP	put_Buffer(VARIANT_BOOL fIsBuffering);
	STDMETHODIMP	get_Cookies(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	IsClientConnected(VARIANT_BOOL* fIsBuffering);
    STDMETHODIMP    get_CodePage(long *plVar);
    STDMETHODIMP    put_CodePage(long var);
    STDMETHODIMP    get_LCID(long *plVar);
    STDMETHODIMP    put_LCID(long var);

    // static method to send the entire block using SyncWriteClient
    static HRESULT SyncWrite(CIsapiReqInfo *pIReq,
                             char *pchBuf, 
                             DWORD cchBuf = 0);

    // static method to send contents of several memory blocks as the entire response (sync)
    static HRESULT SyncWriteBlocks(CIsapiReqInfo *pIReq, 
                                   DWORD cBlocks,
                                   DWORD cbTotal,
                                   void **rgpvBlock, 
                                   DWORD *rgcbBlock, 
                                   char *szMimeType = NULL, 
                                   char *szStatus = NULL,
                                   char *szExtraHeaders = NULL);
    
    // static method to send contents of a memory block as the entire response (sync)
    inline static HRESULT SyncWriteBlock(CIsapiReqInfo *pIReq,
                                         void *pvBlock, 
                                         DWORD cbBlock, 
                                         char *szMimeType = NULL,
                                         char *szStatus = NULL,
                                         char *szExtraHeaders = NULL)
        {
        return SyncWriteBlocks(pIReq, 1, cbBlock, &pvBlock, &cbBlock,
                               szMimeType, szStatus, szExtraHeaders);
        }

    // static method to send contents of a file as the entire response (sync)
    static HRESULT SyncWriteFile(CIsapiReqInfo *pIReq, 
                                 TCHAR *szFile, 
                                 char *szMimeType = NULL, 
                                 char *szStatus = NULL,
                                 char *szExtraHeaders = NULL);

    // static method to send contents of a scriptless template as the entire response (sync)
    static HRESULT SyncWriteScriptlessTemplate(CIsapiReqInfo *pIReq, 
                                               CTemplate *pTemplate);

    // IStream implementation

    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(const void *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin,
                      ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb,
                        ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                            DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                              DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppstm);
        
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline BOOL CResponse::FHeadersWritten() 
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_fHeadersWritten; 
    }
    
inline BOOL CResponse::FResponseAborted()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_fResponseAborted;
    }

inline BOOL CResponse::FWriteClientError() 
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_fWriteClientError; 
    }

inline BOOL CResponse::FDontWrite()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return (m_pData->m_fWriteClientError || m_pData->m_fIgnoreWrites);
    }
    
inline void	CResponse::SetHeadersWritten() 
    {
    Assert(m_fInited);
    Assert(m_pData);
    m_pData->m_fHeadersWritten = TRUE; 
    }

inline void CResponse::SetIgnoreWrites()
    {
    Assert(m_fInited);
    Assert(m_pData);
    m_pData->m_fIgnoreWrites = TRUE; 
    }

inline CIsapiReqInfo* CResponse::GetIReq()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_pIReq;
    }

inline const char* CResponse::PContentType() const
    {
    Assert(m_fInited);
    Assert(m_pData);
    if (m_pData->m_pszContentType)
        return m_pData->m_pszContentType;
	else
		return m_pData->m_pszDefaultContentType;
    }

inline char* CResponse::PCustomStatus()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_pszStatus;
    }

inline void *CResponse::SwapScriptEngineInfo(void *pvEngineInfo)
    {
    Assert(m_fInited);
    Assert(m_pData);
    void *pvOldEngineInfo = m_pData->m_pvGetScriptContext;
    m_pData->m_pvGetScriptContext = pvEngineInfo;
    return pvOldEngineInfo;
    }

#endif //_RESPONSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\server.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Server object

File: Server.cpp

Owner: CGrant

This file contains the code for the implementation of the Server object.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "Server.h"
#include "tlbcache.h"
#include "memchk.h"

/*
 *
 * C S e r v e r
 *
 */

/*===================================================================
CServer::CServer

Constructor

Parameters:
    punkOuter   object to ref count (can be NULL)
					
Returns:
===================================================================*/
CServer::CServer(IUnknown *punkOuter)
    :
	m_fInited(FALSE),
	m_fDiagnostics(FALSE),
    m_pData(NULL)
	{
	CDispatch::Init(IID_IServer);

    if (punkOuter)
        {
        m_punkOuter = punkOuter;
        m_fOuterUnknown = TRUE;
        }
    else
        {
        m_cRefs = 1;
        m_fOuterUnknown = FALSE;
        }
	
#ifdef DBG
	m_fDiagnostics = TRUE;
#endif // DBG
	}

/*===================================================================
CServer::~CServer

Destructor

Parameters:
					
Returns:
===================================================================*/
CServer::~CServer()
    {
	Assert(!m_fInited);
    Assert(m_fOuterUnknown || m_cRefs == 0);  // must have 0 ref count
    }
    
/*===================================================================
CServer::Init

Allocates m_pData.
Performs any intiailization of a CServer that's prone to failure
that we also use internally before exposing the object outside.

Parameters:
	None
					
Returns:
	S_OK on success.
===================================================================*/

HRESULT CServer::Init()
	{
	if (m_fInited)
	    return S_OK; // already inited
	    
	Assert(!m_pData);

    m_pData = new CServerData;
    if (!m_pData)
        return E_OUTOFMEMORY;

	m_pData->m_pIReq = NULL;
	m_pData->m_pHitObj = NULL;
	
	m_pData->m_ISupportErrImp.Init(static_cast<IServer *>(this), 
	            static_cast<IServer *>(this), 
	            IID_IServer);
	    
	m_fInited = TRUE;
	return S_OK;
	}
	
/*===================================================================
CServer::UnInit

Remove m_pData. Make tombstone (UnInited state).

Parameters:
					
Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CServer::UnInit()
	{
	if (!m_fInited)
	    return S_OK; // already uninited

	Assert(m_pData);
    delete m_pData;
    m_pData = NULL;

    m_fInited = FALSE;
	return S_OK;
	}

/*===================================================================
CServer::ReInit

The only need for a re-init here is to update the CIsapiReqInfo
for this request, the CIsapiReqInfo is required to access the
MapPath Method. Ideally this method should be part of the Request 
object

Parameters:
	CIsapiReqInfo *
	CHitObj *
					
Returns:
	S_OK on success.

===================================================================*/
HRESULT CServer::ReInit
(
CIsapiReqInfo * pIReq,
CHitObj *pHitObj
)
	{
	Assert(m_fInited);
	Assert(m_pData);
	
	m_pData->m_pIReq	   = pIReq;
	m_pData->m_pHitObj = pHitObj;
	return S_OK;
	}

/*===================================================================
CServer::MapPathInternal

Map virtual path BSTR into single char buffer
Used by MapPath(), Execute(), Transfer()

Parameters:
    dwContextId     for error messages
    wszVirtPath     path to translate
    szPhysPath      [out] translate into this buffer (MAX_PATH sized)
    szVirtPath      [out, optional] mb virtual path buffer (MAX_PATH sized)
					
Returns:
	S_OK on success.
===================================================================*/
HRESULT CServer::MapPathInternal
(
DWORD dwContextId, 
WCHAR *wszVirtPath, 
TCHAR *szPhysPath,
TCHAR *szVirtPath
)
    {
	// increment the pointer past leading white spaces
	wchar_t *wszLogicalPath = wszVirtPath;
	while (iswspace(*wszLogicalPath))
		++wszLogicalPath;

	unsigned cchLogicalPath = wcslen(wszLogicalPath);
	if (cchLogicalPath > MAX_PATH-1)
		{
		if (dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_EXCEDED_MAX_PATH);
		return E_FAIL;
		}

	else if (cchLogicalPath == 0)
		{
		if (dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_INVALID_STR);
		return E_FAIL;
		}		

	// Is this a physical path?
	if (iswalpha(wszLogicalPath[0]) && wszLogicalPath[1] == L':')
		{		
		if (dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_PHY_STR);
		return E_FAIL;
		}

	// simple validation: look for invalid characters in string [*?<>,;:'"]
	// and multiple slash characters ie "//" or "\\"
	//
	BOOL fParentPath = FALSE;
	BOOL fEnableParentPaths = m_pData->m_pHitObj->QueryAppConfig()->fEnableParentPaths();
	BOOL fAnyBackslashes = FALSE;
	wchar_t *pwchT = wszLogicalPath;
	while (*pwchT != L'\0')
		{
		switch (*pwchT)
			{
			case L'*': case L':': case L'?': case L'<': 
			case L'>': case L',': case L'"': 
        		if (dwContextId)
		    		ExceptionId( IID_IServer, dwContextId, IDE_SERVER_MAPPATH_INVALID_CHR);
				return E_FAIL;

			case L'.': 				
				if (*++pwchT == L'.') 
					{
					if (!fEnableParentPaths)
						{
                		if (dwContextId)
   				    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_INVALID_CHR3);
   						return E_FAIL;
   						}
   					else
   						{
   						fParentPath = TRUE;
   						++pwchT;
   						}
   					}
				break;
	
			case L'\\':
			    fAnyBackslashes = TRUE;
			case L'/': 
				++pwchT;
				if (*pwchT == '/' || *pwchT == '\\')
					{
            		if (dwContextId)
   			    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_INVALID_CHR2);
   					return E_FAIL;
					}
				break;

			default:
				++pwchT;
			}
		}

	// whew! Error handling done!
	// Convert wszLogicalPath to multi-byte

    TCHAR szLogicalPath[MAX_PATH];
#if UNICODE
    wcscpy(szLogicalPath, wszLogicalPath);
#else 
    HRESULT hr;
    CWCharToMBCS    convStr;

    if (hr = convStr.Init(wszLogicalPath)) {
        if ((hr == E_OUTOFMEMORY) && dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_OOM);
        return hr;
    }
    
    if (convStr.GetStringLen() > (MAX_PATH-1)) {
		if (dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_EXCEDED_MAX_PATH);
		return E_FAIL;
    }
    strcpy(szLogicalPath,convStr.GetString());
#endif

    // change all backslashes to forward slashes
	if (fAnyBackslashes)
	    {
	    TCHAR *pbBackslash = szLogicalPath;
	    while (pbBackslash = _tcschr(pbBackslash, _T('\\')))
	        *pbBackslash = _T('/');
	    }

	// is this a Relative path request. I.E. no leading slash
	// if so prepend the path_info string to szLogicalPath

	BOOL fPathAlreadyIsMapped = FALSE;		// Some cases map the path earlier
	if (szLogicalPath[0] != _T('/'))
		{
		TCHAR szParentPath[MAX_PATH];
		_tcscpy(szParentPath, m_pData->m_pIReq->QueryPszPathInfo());

		// Trim off the ASP file name from the PATH_INFO
		TCHAR *pchT = _tcsrchr(szParentPath, _T('/'));
		if (pchT != NULL) *pchT = '\0';

		// If there were parent paths, map the parent now, then append the relative path
		// the relative path to the parent path
		if (fParentPath)
			{
			Assert (fEnableParentPaths);			// Errors should have been flagged upstairs
			DWORD dwPathSize = sizeof(szParentPath);
			if (! m_pData->m_pIReq->MapUrlToPath(szParentPath, &dwPathSize))
				{
        		if (dwContextId)
		    		ExceptionId(IID_IServer,
			    				dwContextId,
				    			::GetLastError() == ERROR_INSUFFICIENT_BUFFER? IDE_SERVER_EXCEDED_MAX_PATH : IDE_SERVER_MAPPATH_FAILED);
				return E_FAIL;
				}

			fPathAlreadyIsMapped = TRUE;
			}

		// Resolve relative paths
		if (! DotPathToPath(szLogicalPath, szLogicalPath, szParentPath))
			{
    		if (dwContextId)
	    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_FAILED);
			return E_FAIL;
			}
		}

    // return virtual path if requested
	if (szVirtPath)
	    _tcscpy(szVirtPath, szLogicalPath);

	// Map this to a physical file name (if required)
	if (!fPathAlreadyIsMapped)
		{
		DWORD dwPathSize = sizeof(szLogicalPath);
		if (! m_pData->m_pIReq->MapUrlToPath(szLogicalPath, &dwPathSize))
			{
    		if (dwContextId)
	    		ExceptionId(IID_IServer,
		    				dwContextId,
			    			::GetLastError() == ERROR_INSUFFICIENT_BUFFER? IDE_SERVER_EXCEDED_MAX_PATH : IDE_SERVER_MAPPATH_FAILED);
			return E_FAIL;
			}
		}

	// remove any ending delimiters (unless it's the root directory. The root always starts with drive letter)
	TCHAR *pchT = CharPrev(szLogicalPath, szLogicalPath + _tcslen(szLogicalPath));
	if ((*pchT == _T('/') || *pchT == _T('\\')) && pchT[-1] != _T(':'))
		{
		*pchT = _T('\0');
		}

	// Replace forward slash with back slash
	for (pchT = szLogicalPath; *pchT != _T('\0'); ++pchT)
	    {
		if (*pchT == _T('/'))
			*pchT = _T('\\');
        }

    _tcscpy(szPhysPath, szLogicalPath);
	return S_OK;
    }

/*===================================================================
CServer::QueryInterface
CServer::AddRef
CServer::Release

IUnknown members for CServer object.
===================================================================*/
STDMETHODIMP CServer::QueryInterface
(
REFIID riid,
PPVOID ppv
)
	{
	*ppv = NULL;

	/*
	 * The only calls for IUnknown are either in a nonaggregated
	 * case or when created in an aggregation, so in either case
	 * always return our IUnknown for IID_IUnknown.
	 */

	// BUG FIX 683 added IID_IDenaliIntrinsic to prevent the user from 
	// storing intrinsic objects in the application and session object

	if (IID_IUnknown == riid ||
		IID_IDispatch == riid ||
		IID_IServer == riid ||
		IID_IDenaliIntrinsic == riid)
		*ppv = static_cast<IServer *>(this);

	//Indicate that we support error information
	if (IID_ISupportErrorInfo == riid)
	    {
	    if (m_pData)
    		*ppv = & (m_pData->m_ISupportErrImp);
		}

    if (IID_IMarshal == riid)
        {
        *ppv = static_cast<IMarshal *>(this);
        }

	//AddRef any interface we'll return.
	if (NULL != *ppv)
		{
		((LPUNKNOWN)*ppv)->AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;
	}

STDMETHODIMP_(ULONG) CServer::AddRef()
	{
	if (m_fOuterUnknown)
	    return m_punkOuter->AddRef();
	    
	return InterlockedIncrement((LPLONG)&m_cRefs);
	}

STDMETHODIMP_(ULONG) CServer::Release()
	{
	if (m_fOuterUnknown)
	    return m_punkOuter->Release();
	    
    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
	if (cRefs)
		return cRefs;

	delete this;
	return 0;
	}

/*===================================================================
CServer::GetIDsOfNames

Special-case implementation for CreateObject, Execute, Transfer

Parameters:
	riid			REFIID reserved. Must be IID_NULL.
	rgszNames		OLECHAR ** pointing to the array of names to be mapped.
	cNames			UINT number of names to be mapped.
	lcid			LCID of the locale.
	rgDispID		DISPID * caller allocated array containing IDs
					corresponging to those names in rgszNames.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
STDMETHODIMP CServer::GetIDsOfNames
(
REFIID riid,
OLECHAR **rgszNames,
UINT cNames,
LCID lcid,
DISPID *rgDispID
)
    {
    const DISPID dispidCreateObject = 0x60020002;
    const DISPID dispidExecute      = 0x60020007;
    const DISPID dispidTransfer     = 0x60020008;

    if (cNames == 1)
        {
        switch (rgszNames[0][0])
            {
        case L'C':
        case L'c':
            if (wcsicmp(rgszNames[0]+1, L"reateobject") == 0)
                {
                *rgDispID = dispidCreateObject;
                return S_OK;
                }
            break;

        case L'E':
        case L'e':
            if (wcsicmp(rgszNames[0]+1, L"xecute") == 0)
                {
                *rgDispID = dispidExecute;
                return S_OK;
                }
            break;
        
        case L'T':
        case L't':
            if (wcsicmp(rgszNames[0]+1, L"ransfer") == 0)
                {
                *rgDispID = dispidTransfer;
                return S_OK;
                }
            break;
            }
        }
        
    // default to CDispatch's implementation
    return CDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispID);
    }

/*===================================================================
CServer::CheckForTombstone

Tombstone stub for IServer methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:
    
Returns:
	HRESULT     E_FAIL  if Tombstone
	            S_OK if not
===================================================================*/
HRESULT CServer::CheckForTombstone()
    {
    if (m_fInited)
        {
        // inited - good object
        Assert(m_pData); // must be present for inited objects
        return S_OK;
        }
        
	ExceptionId
	    (
	    IID_IServer, 
	    IDE_SERVER, 
	    IDE_INTRINSIC_OUT_OF_SCOPE
	    );
    return E_FAIL;
    }

/*===================================================================
CServer::CreateObject

Parameters: BSTR containing ProgID
			Variant to fillin with IUknown pointer

Returns: S_OK if successful E_FAIL otherwise

Side effects:
	Creates an instance of an ole automation object
===================================================================*/
STDMETHODIMP CServer::CreateObject(BSTR bstrProgID, IDispatch **ppDispObj)
	{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
    if (bstrProgID == NULL)
        {
        ExceptionId(IID_IServer, IDE_SERVER, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    Assert(m_pData->m_pHitObj);
        
	*ppDispObj = NULL;

    HRESULT hr;
    CLSID clsid;

	if (Glob(fEnableTypelibCache))
	    {
	    // Use typelib cache to create the component
	    
        hr = g_TypelibCache.CreateComponent
                (
                bstrProgID,
                m_pData->m_pHitObj,
                ppDispObj,
                &clsid
                );

    	if (FAILED(hr) && clsid == CLSID_NULL)
            {
            // bad prog id or something
    		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_FAILED, hr);
    	    return hr;
            }
	    }
	else
	    {
	    // Don't use typelib cache
	    
    	hr = CLSIDFromProgID((LPCOLESTR)bstrProgID, &clsid);
    	if (FAILED(hr))
    	    {
    		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_FAILED, hr);
    	    return hr;
    	    }
    	    
        hr = m_pData->m_pHitObj->CreateComponent(clsid, ppDispObj);
        }
        
    if (SUCCEEDED(hr))
        return S_OK;

    // Check if a custom error was already posted
    IErrorInfo *pErrInfo = NULL;
    if (GetErrorInfo(0, &pErrInfo) == S_OK && pErrInfo)
        {
		SetErrorInfo(0, pErrInfo);
        pErrInfo->Release();
        }
    // Standard errors
	else if (hr == E_ACCESSDENIED)
		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_DENIED);
	else
	    {
	    if (hr == REGDB_E_CLASSNOTREG)
    	    {
    		BOOL fInProc;
            if (SUCCEEDED(CompModelFromCLSID(clsid, NULL, &fInProc)) && !fInProc)
            	{
        		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_NOTINPROC);
            	}
    	    }
    	else
    		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_FAILED, hr);
    	}
    return hr;
    }
	
/*===================================================================
CServer::MapPath

Return the physical path translated from a logical path

Parameters:
	BSTR		bstrLogicalPath
	BSTR FAR *	pbstrPhysicalPath

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::MapPath(BSTR bstrLogicalPath, BSTR FAR * pbstrPhysicalPath)
	{	
	if (FAILED(CheckForTombstone()))
        return E_FAIL;

	// Bug 1361: error if no CIsapiReqInfo (presumably called during
	//           Application_OnEnd or Session_OnEnd)
	if (m_pData->m_pIReq == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_SERVER_INVALID_CALL);
		return E_FAIL;
		}

	AssertValid();
	Assert (pbstrPhysicalPath != NULL);
	*pbstrPhysicalPath = NULL;

    // use MapPathInternal() to do the mapping
	TCHAR szLogicalPath[MAX_PATH];
    HRESULT  hr = MapPathInternal(IDE_SERVER_MAPPATH, bstrLogicalPath, szLogicalPath);
    if (FAILED(hr))
        return hr;

#if UNICODE
    *pbstrPhysicalPath = SysAllocString(szLogicalPath);
    if (*pbstrPhysicalPath == NULL) {
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_OOM);
		return E_FAIL;
    }
#else
	// Convert the path to wide character
	if (FAILED(SysAllocStringFromSz(szLogicalPath, 0, pbstrPhysicalPath, CP_ACP))) {
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_OOM);
		return E_FAIL;
		}
#endif
	return S_OK;
	}

/*===================================================================
CServer::HTMLEncode

Encodes a string to HTML standards

Parameters:
	BSTR		bstrIn			value: string to be encoded
	BSTR FAR *	pbstrEncoded	value: pointer to HTML encoded version of string

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::HTMLEncode ( BSTR bstrIn, BSTR FAR * pbstrEncoded )
	{	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	char*	        pszstrIn 			= NULL;	
	char*	        pszEncodedstr		= NULL;
	char*	        pszStartEncodestr	= NULL;
	int		        nbstrLen 			= 0;
	int		        nstrLen				= 0;
	HRESULT	        hr					= S_OK;
	UINT 	        uCodePage			= m_pData->m_pHitObj->GetCodePage();
    CWCharToMBCS    convIn;

    STACK_BUFFER( tempHTML, 2048 );

	if (bstrIn)
		nbstrLen = wcslen(bstrIn);
	else
		nbstrLen = 0;

	if (nbstrLen <= 0)
		return S_OK;

    if (FAILED(hr = convIn.Init(bstrIn, uCodePage))) {
        if (hr == E_OUTOFMEMORY)
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
        goto L_Exit;
    }

    pszstrIn = convIn.GetString();
				
	nstrLen = HTMLEncodeLen(pszstrIn, uCodePage, bstrIn);
	
	if (nstrLen > 0)
		{
		
		//Encode string	, NOTE this function returns a pointer to the
		// NULL so you need to keep a pointer to the start of the string
		//

        if (!tempHTML.Resize(nstrLen + 2)) {
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
        }

        pszEncodedstr = (char*)tempHTML.QueryPtr();

		pszStartEncodestr	= pszEncodedstr;
		pszEncodedstr = ::HTMLEncode( pszEncodedstr, pszstrIn, uCodePage, bstrIn);
	
		// convert result to bstr
		//
		if (FAILED(SysAllocStringFromSz(pszStartEncodestr, 0, pbstrEncoded, uCodePage)))
			{
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
			}
		}

	L_Exit:
			
	return hr;
	}


/*===================================================================
CServer::URLEncode

Encodes a query string to URL standards

Parameters:
	BSTR		bstrIn			value: string to be URL encoded
	BSTR FAR *	pbstrEncoded	value: pointer to URL encoded version of string

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::URLEncode ( BSTR bstrIn, BSTR FAR * pbstrEncoded )
	{	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	char*	        pszstrIn 			= NULL;	
	char*	        pszEncodedstr		= NULL;
	char*	        pszStartEncodestr	= NULL;
	int		        nbstrLen 			= 0;
	int		        nstrLen				= 0;
	HRESULT	        hr					= S_OK;
    CWCharToMBCS    convIn;

    STACK_BUFFER( tempURL, 256 );

	if (bstrIn)
		nbstrLen = wcslen(bstrIn);
	else
		nbstrLen = 0;

	if (nbstrLen <= 0)
		return S_OK;

    if (FAILED(hr = convIn.Init(bstrIn, m_pData->m_pHitObj->GetCodePage()))) {
        if (hr == E_OUTOFMEMORY)
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
        goto L_Exit;
    }
	
    pszstrIn = convIn.GetString();
				
	nstrLen = URLEncodeLen(pszstrIn);
	if (nstrLen > 0)
		{
		
		//Encode string	, NOTE this function returns a pointer to the
		// NULL so you need to keep a pointer to the start of the string
		//

        if (!tempURL.Resize(nstrLen + 2)) {
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
        }

        pszEncodedstr = (char *)tempURL.QueryPtr();

		pszStartEncodestr	= pszEncodedstr;
		pszEncodedstr = ::URLEncode( pszEncodedstr, pszstrIn );
	
		// convert result to bstr
		//
		if (FAILED(SysAllocStringFromSz(pszStartEncodestr, 0, pbstrEncoded)))
			{
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
			}
		}

	L_Exit:
	
	return hr;
	}

/*===================================================================
CServer::URLPathEncode

Encodes the path portion of a URL or a full URL.  All characters
up to the first '?' are encoded with the following rules:
	o Charcters that are needed to parse the URL are left alone
	o RFC 1630 safe characters are left alone
	o Non-foreign alphanumberic characters are left alone
	o Anything else is escape encoded
Everything after the '?' is not encoded.

Parameters:
	BSTR		bstrIn			value: string to be URL path encoded
	BSTR FAR *	pbstrEncoded	value: pointer to URL path encoded version of string

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::URLPathEncode ( BSTR bstrIn, BSTR FAR * pbstrEncoded )
	{	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	char*	        pszstrIn 			= NULL;	
	char*	        pszEncodedstr		= NULL;
	char*	        pszStartEncodestr	= NULL;
	int		        nbstrLen 			= 0;
	int		        nstrLen				= 0;
	HRESULT	        hr					= S_OK;
    CWCharToMBCS    convIn;

    STACK_BUFFER( tempPath, 256 );

	if (bstrIn)
		nbstrLen = wcslen(bstrIn);
	else
		nbstrLen = 0;

	if (nbstrLen <= 0)
		return S_OK;

    if (FAILED(hr = convIn.Init(bstrIn, m_pData->m_pHitObj->GetCodePage()))) {
        if (hr == E_OUTOFMEMORY)
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
        goto L_Exit;
    }
    
    pszstrIn = convIn.GetString();
				
	nstrLen = URLPathEncodeLen(pszstrIn);
	if (nstrLen > 0)
		{
		
		//Encode string	, NOTE this function returns a pointer to the
		// NULL so you need to keep a pointer to the start of the string
		//

        if (!tempPath.Resize(nstrLen+2)) {
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
        }

        pszEncodedstr = (char *)tempPath.QueryPtr();

		pszStartEncodestr	= pszEncodedstr;
		pszEncodedstr = ::URLPathEncode( pszEncodedstr, pszstrIn );
	
		// convert result to bstr
		//
		if (FAILED(SysAllocStringFromSz(pszStartEncodestr, 0, pbstrEncoded)))
			{
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
			}
		}

	L_Exit:
	
	return hr;
	}

/*===================================================================
CServer::get_ScriptTimeout

Will return the script timeout interval (in seconds)

Parameters:
	long *plTimeoutSeconds

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::get_ScriptTimeout( long * plTimeoutSeconds )
{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	if (m_pData->m_pHitObj == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_SERVER_INVALID_CALL);
		return(E_FAIL);
		}
	*plTimeoutSeconds = m_pData->m_pHitObj->GetScriptTimeout();
	return S_OK;
}

/*===================================================================
CServer::put_ScriptTimeout

Allows the user to set the timeout interval for a script (in seconds)

Parameters:
	long lTimeoutSeconds

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::put_ScriptTimeout( long lTimeoutSeconds ) 
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	if ( lTimeoutSeconds < 0 )
    	{
		ExceptionId( IID_IServer, IDE_SERVER, IDE_SERVER_INVALID_TIMEOUT );
		return E_FAIL;
	    }
	else
    	{
		if (m_pData->m_pHitObj == NULL)
			{
			ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_SERVER_INVALID_CALL);
			return(E_FAIL);
			}
		m_pData->m_pHitObj->SetScriptTimeout(lTimeoutSeconds);
		return S_OK;
	    }
    }

/*===================================================================
CServer::Execute

Execute an ASP

Parameters:
	bstrURL     URL to execute

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::Execute(BSTR bstrURL)
    {
	if (FAILED(CheckForTombstone()))
        return E_FAIL;

	if (m_pData->m_pIReq == NULL || m_pData->m_pHitObj == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_INVALID_CALL);
		return E_FAIL;
		}

	TCHAR szTemplate[MAX_PATH], szVirtTemp[MAX_PATH];
    HRESULT  hr = MapPathInternal(IDE_SERVER, bstrURL, szTemplate, szVirtTemp);
    if (FAILED(hr))
        {
        ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_EXECUTE_INVALID_PATH);
        return hr;
        }
    Normalize(szTemplate);

    hr = m_pData->m_pHitObj->ExecuteChildRequest(FALSE, szTemplate, szVirtTemp);
    if (FAILED(hr))
        {
        if (m_pData->m_pHitObj->FHasASPError()) // error already reported
            return hr;
            
		ExceptionId(IID_IServer, IDE_SERVER, (hr == E_COULDNT_OPEN_SOURCE_FILE) ?
    		IDE_SERVER_EXECUTE_CANTLOAD : IDE_SERVER_EXECUTE_FAILED);
		return E_FAIL;
        }

    return S_OK;
    }
    
/*===================================================================
CServer::Transfer

Transfer execution an ASP

Parameters:
	bstrURL     URL to execute

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::Transfer(BSTR bstrURL)
    {
	if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	if (m_pData->m_pIReq == NULL || m_pData->m_pHitObj == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_SERVER_INVALID_CALL);
		return E_FAIL;
		}

	TCHAR szTemplate[MAX_PATH], szVirtTemp[MAX_PATH];
    HRESULT  hr = MapPathInternal(IDE_SERVER, bstrURL, szTemplate, szVirtTemp);
    if (FAILED(hr))
        {
        ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_TRANSFER_INVALID_PATH);
        return hr;
        }
    Normalize(szTemplate);

    hr = m_pData->m_pHitObj->ExecuteChildRequest(TRUE, szTemplate, szVirtTemp);
    if (FAILED(hr))
        {
        if (m_pData->m_pHitObj->FHasASPError()) // error already reported
            return hr;
            
		ExceptionId(IID_IServer, IDE_SERVER, (hr == E_COULDNT_OPEN_SOURCE_FILE) ?
    		IDE_SERVER_TRANSFER_CANTLOAD : IDE_SERVER_TRANSFER_FAILED);
		return E_FAIL;
        }

    return S_OK;
    }

/*===================================================================
CServer::GetLastError

Get ASPError object for the last error

Parameters:
	ppASPErrorObject    [out] the error object

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::GetLastError(IASPError **ppASPErrorObject)
    {
    *ppASPErrorObject = NULL;
    
	if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	if (m_pData->m_pIReq == NULL || m_pData->m_pHitObj == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_INVALID_CALL);
		return E_FAIL;
		}

    HRESULT hr = m_pData->m_pHitObj->GetASPError(ppASPErrorObject);
    
    if (FAILED(hr))
        {
		ExceptionId(IID_IServer, IDE_SERVER, IDE_UNEXPECTED);
		return hr;
        }

    return S_OK;
    }

#ifdef DBG
/*===================================================================
CServer::AssertValid

Test to make sure that the CServer object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
	None.
===================================================================*/
void CServer::AssertValid() const
	{
	Assert(m_fInited);
	Assert(m_pData);
	Assert(m_pData->m_pIReq);
	}
#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\sessmgr.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Session Object Manager

File: Sessmgr.cpp

Owner: PramodD

This is the Session Manager source file.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "idgener.h"
#include "perfdata.h"
#include "randgen.h"

// ATQ Scheduler
#include "issched.hxx"

#include "MemChk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

/*===================================================================
  G l o b a l s
===================================================================*/

PTRACE_LOG CSession::gm_pTraceLog = NULL;
unsigned long g_nSessions = 0;
CIdGenerator  g_SessionIdGenerator;
CIdGenerator  g_ExposedSessionIdGenerator;        
LONG    g_nSessionObjectsActive = 0;

// On app restart post session cleanup requests so many at a time
#define SUGGESTED_SESSION_CLEANUP_REQUESTS_MAX 500

/*===================================================================
   C S e s s i o n V a r i a n t s
===================================================================*/

/*===================================================================
CSessionVariants::CSessionVariants

Constructor

Parameters:

Returns:
===================================================================*/
CSessionVariants::CSessionVariants()
	: 
	m_cRefs(1),
	m_pSession(NULL), 
	m_ctColType(ctUnknown),
    m_ISupportErrImp(this, this, IID_IVariantDictionary)
	{
	CDispatch::Init(IID_IVariantDictionary);
	}

/*===================================================================
CSessionVariants::~CSessionVariants

Destructor

Parameters:

Returns:
===================================================================*/
CSessionVariants::~CSessionVariants()
	{
	Assert(!m_pSession);
	}
	
/*===================================================================
CSessionVariants::Init

Initialize object

Parameters:
	pSession    Session
	ctColType   Type of variables to expose in the collection
	                e.g. Tagged objects or Properties

Returns:
    HRESULT
===================================================================*/
HRESULT CSessionVariants::Init
(
CSession *pSession, 
CompType ctColType
)
	{
	Assert(pSession);
	pSession->AddRef();

	Assert(!m_pSession);

	m_pSession  = pSession;
	m_ctColType = ctColType;
	return S_OK;
	}

/*===================================================================
CSessionVariants::UnInit

UnInitialize object

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CSessionVariants::UnInit()
	{
	if (m_pSession)
	    {
	    m_pSession->Release();
	    m_pSession = NULL;
	    }
	return S_OK;
	}
	
/*===================================================================
CSessionVariants::QueryInterface
CSessionVariants::AddRef
CSessionVariants::Release

IUnknown members for CSessionVariables object.
===================================================================*/
STDMETHODIMP CSessionVariants::QueryInterface
(
REFIID iid, 
void **ppvObj
)
	{
	if (iid == IID_IUnknown || iid == IID_IDispatch ||
	    iid == IID_IVariantDictionary)
	    {
	    AddRef();
		*ppvObj = this;
		return S_OK;
        }
	else if (iid == IID_ISupportErrorInfo)
	    {
	    m_ISupportErrImp.AddRef();
		*ppvObj = &m_ISupportErrImp;
		return S_OK;
        }
        
	*ppvObj = NULL;
	return E_NOINTERFACE;
	}

STDMETHODIMP_(ULONG) CSessionVariants::AddRef()
	{
	return InterlockedIncrement((LPLONG)&m_cRefs);
	}

STDMETHODIMP_(ULONG) CSessionVariants::Release()
	{
	if (InterlockedDecrement((LPLONG)&m_cRefs) > 0)
		return m_cRefs;

	delete this;
	return 0;
	}

/*===================================================================
CSessionVariants::ObjectNameFromVariant

Gets name from variant. Resolves operations by index.
Allocates memory for name.

Parameters:
	vKey		VARIANT
	ppwszName   [out] allocated name
	fVerify     flag - check existance if named

	
Returns:
    HRESULT
===================================================================*/
HRESULT CSessionVariants::ObjectNameFromVariant
(
VARIANT &vKey,
WCHAR **ppwszName,
BOOL fVerify
)
    {
    *ppwszName = NULL;
    
	VARIANT *pvarKey = &vKey;
	VARIANT varKeyCopy;
	VariantInit(&varKeyCopy);
	if (V_VT(pvarKey) != VT_BSTR && V_VT(pvarKey) != VT_I2 && V_VT(pvarKey) != VT_I4)
		{
		if (FAILED(VariantResolveDispatch(&varKeyCopy, &vKey, IID_IVariantDictionary, IDE_SESSION)))
            {
		    ExceptionId(IID_IVariantDictionary, IDE_SESSION, IDE_EXPECTING_STR);
        	VariantClear(&varKeyCopy);
		    return E_FAIL;
		    }
		pvarKey = &varKeyCopy;
		}

    LPWSTR pwszName = NULL;

	switch (V_VT(pvarKey))
		{
		case VT_BSTR:
		    {
		    pwszName = V_BSTR(pvarKey);

		    if (fVerify && pwszName)
		        {
		        CComponentObject *pObj = NULL;

                Assert(m_pSession);
                Assert(m_pSession->PCompCol());

		        if (m_ctColType == ctTagged)
                    m_pSession->PCompCol()->GetTagged(pwszName, &pObj);
                else
                    m_pSession->PCompCol()->GetProperty(pwszName, &pObj);

                if (!pObj || pObj->GetType() != m_ctColType)
                    pwszName = NULL; // as if not found        
                }
		    break;
		    }

   		case VT_I1:  case VT_I2:               case VT_I8:
		case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
		case VT_R4:  case VT_R8:
			// Coerce all integral types to VT_I4
			if (FAILED(VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
				return E_FAIL;

			// fallthru to VT_I4

		case VT_I4:
		    {
		    int i;
			HRESULT hr;

			// Look up the object by index
			i = V_I4(pvarKey);

            if (i > 0)
                {
                Assert(m_pSession);
                Assert(m_pSession->PCompCol());
                
                hr = m_pSession->PCompCol()->GetNameByIndex
                    (
                    m_ctColType, 
                    i,
                    &pwszName
                    );

				if (FAILED(hr))
					return DISP_E_BADINDEX;
                }
			else 
				{
				ExceptionId(IID_IVariantDictionary, IDE_SESSION, IDE_BAD_ARRAY_INDEX);
				return E_FAIL;
				}
            break;
            }		        
		}
  	VariantClear(&varKeyCopy);

    if (!pwszName)
        return S_OK;

    // Copy name
	*ppwszName = StringDupW(pwszName);

  	return S_OK;
    }

/*===================================================================
CSessionVariants::get_Item

Function called from DispInvoke to get values from the 
SessionVariables collection.

Parameters:
	vKey		VARIANT [in], which parameter to get the value of 
	                        - integers access collection as an array
	pvarReturn	VARIANT *, [out] value of the requested parameter

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CSessionVariants::get_Item
(
VARIANT varKey, 
VARIANT *pVar
)
	{
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;
        
    // Initialize return value
	VariantInit(pVar);

	if (!m_pSession->PHitObj() || !m_pSession->PCompCol())
	    return S_OK;  // return empty variant
	CHitObj *pHitObj = m_pSession->PHitObj();

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        return S_OK; // bogus index - no error

    // Find object by name
	CComponentObject *pObj = NULL;

	if (m_ctColType == ctTagged)
   		{
        pHitObj->GetComponent(csSession, pwszName, CbWStr(pwszName), &pObj);
		if (pObj && (pObj->GetType() != ctTagged))
    		pObj = NULL;
    	}
	else 
	    {
        pHitObj->GetPropertyComponent(csSession, pwszName, &pObj);
		}

    free(pwszName);

    if (!pObj)
        return S_OK;

    // return the variant
    return pObj->GetVariant(pVar);
	}

/*===================================================================
CSessionVariants::put_Item

IVariantsDictionary implementation.

Implement property put by dereferencing variants before
calling putref.

Parameters:
	VARIANT varKey	Name of the variable to set
	VARIANT Var		Value/object to set for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSessionVariants::put_Item
(
VARIANT varKey,
VARIANT Var 
)
    {	
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_ctColType == ctTagged)
	    {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION, 
	                IDE_CANT_MOD_STATICOBJECTS);
	    return E_FAIL;
	    }

	if (!m_pSession->PHitObj())
	    return E_FAIL;

    Assert(m_ctColType == ctProperty);

    // Resolve the variant
	VARIANT varResolved;
	HRESULT hr = VariantResolveDispatch
	    (
	    &varResolved, 
	    &Var,
        IID_ISessionObject, 
        IDE_SESSION
        );
	if (FAILED(hr))
		return hr;		// exception already raised

    // Get name
    WCHAR *pwszName = NULL;
    hr = ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        return hr;

   	hr = m_pSession->PHitObj()->SetPropertyComponent
    	(
    	csSession, 
    	pwszName,
    	&varResolved
    	);

    free(pwszName);
    VariantClear(&varResolved);
	return hr;
    }

/*===================================================================
CSessionVariants::putref_Item

IVariantsDictionary implementation.

Implement property put be reference.

Parameters:
	VARIANT varKey	Name of the variable to set
	VARIANT Var		Value/object to set for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSessionVariants::putref_Item
(
VARIANT varKey,
VARIANT Var 
)
    {	
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_ctColType == ctTagged)
	    {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION,
	                IDE_CANT_MOD_STATICOBJECTS);
	    return E_FAIL;
	    }

    if (FIsIntrinsic(&Var))
        {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION,
	                IDE_SESSION_CANT_STORE_INTRINSIC);
	    return E_FAIL;
        }

	if (!m_pSession->PHitObj())
	    return E_FAIL;

    Assert(m_ctColType == ctProperty);

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        return hr;

   	hr = m_pSession->PHitObj()->SetPropertyComponent
    	(
    	csSession, 
    	pwszName,
    	&Var
    	);

    free(pwszName);
	return hr;
    }

/*===================================================================
CSessionVariants::get_Key

Function called from DispInvoke to get Keys from the SessionVariables collection.

Parameters:
	vKey		VARIANT [in], which parameter to get the value of - integers access collection as an array
	pvarReturn	VARIANT *, [out] value of the requested parameter

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CSessionVariants::get_Key
(
VARIANT varKey,
VARIANT *pVar
)
	{
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;
        
	VariantInit(pVar);

	if (!m_pSession->PHitObj() || !m_pSession->PCompCol())
	    return S_OK;

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName, TRUE);
    if (!pwszName)
        return S_OK;  // no error if bogus index

    // Return BSTr
   	BSTR bstrT = SysAllocString(pwszName);
   	free(pwszName);
   	
	if (!bstrT)
		return E_OUTOFMEMORY;
		
    V_VT(pVar) = VT_BSTR;
	V_BSTR(pVar) = bstrT;
	return S_OK;
	}

/*===================================================================
CSessionVariants::get_Count

Parameters:
	pcValues - count is stored in *pcValues
===================================================================*/
STDMETHODIMP CSessionVariants::get_Count
(
int *pcValues
)
	{
	*pcValues = 0;

	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_pSession->PCompCol())
	    {
    	if (m_ctColType == ctTagged)
    		*pcValues = m_pSession->PCompCol()->GetTaggedObjectCount();
    	else
    		*pcValues = m_pSession->PCompCol()->GetPropertyCount();
   		}
		
	return S_OK;
	}

/*===================================================================
CSessionVariants::get__NewEnum

Return a new enumerator
===================================================================*/
HRESULT CSessionVariants::get__NewEnum
(
IUnknown **ppEnumReturn
)
	{
	*ppEnumReturn = NULL;

	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;
	
	CVariantsIterator *pIterator = new CVariantsIterator
	    (
	    m_pSession, 
	    m_ctColType
	    );
	if (pIterator == NULL)
		{
		ExceptionId(IID_IVariantDictionary, IDE_SESSION, IDE_OOM);
		return E_OUTOFMEMORY;
		}

	*ppEnumReturn = pIterator;
	return S_OK;
	}

/*===================================================================
CSessionVariants::Remove

Remove item from the collection

Parameters:
	varKey		VARIANT [in]

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
STDMETHODIMP CSessionVariants::Remove
(
VARIANT varKey
)
	{
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_ctColType == ctTagged)
	    {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION,
	                IDE_CANT_MOD_STATICOBJECTS);
	    return E_FAIL;
	    }

    Assert(m_ctColType == ctProperty);

    // Get name
    WCHAR *pwszName = NULL;
    ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        return S_OK;

    CComponentCollection *pCompCol = m_pSession->PCompCol();

    if (pCompCol)
        pCompCol->RemoveProperty(pwszName);
        
    free(pwszName);
	return S_OK;
	}

/*===================================================================
CSessionVariants::RemoveAll

Remove all items from the collection

Parameters:

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
STDMETHODIMP CSessionVariants::RemoveAll()
	{
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_ctColType == ctTagged)
	    {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION,
	                IDE_CANT_MOD_STATICOBJECTS);
	    return E_FAIL;
	    }

    Assert(m_ctColType == ctProperty);

    CComponentCollection *pCompCol = m_pSession->PCompCol();

    if (pCompCol)
        {
        pCompCol->RemoveAllProperties();
        }
        
	return S_OK;
	}

/*===================================================================
  C  S e s s i o n
===================================================================*/

/*===================================================================
CSession::CSession

Constructor

Parameters:

Returns:
===================================================================*/
CSession::CSession()
    :
    m_fInited(FALSE),
    m_fLightWeight(FALSE),
    m_fOnStartFailed(FALSE),
    m_fOnStartInvoked(FALSE),
    m_fOnEndPresent(FALSE),
    m_fTimedOut(FALSE), 
    m_fStateAcquired(FALSE),
    m_fCustomTimeout(FALSE), 
    m_fAbandoned(FALSE),
    m_fTombstone(FALSE),
    m_fInTOBucket(FALSE),
	m_fSessCompCol(FALSE),
    m_fCodePageSet(FALSE),
    m_fLCIDSet(FALSE),
    m_Request(static_cast<ISessionObject *>(this)),
	m_Response(static_cast<ISessionObject *>(this)),
	m_Server(static_cast<ISessionObject *>(this)),
	m_pAppln(NULL),
	m_pHitObj(NULL),
	m_pTaggedObjects(NULL),
	m_pProperties(NULL),
	m_Id(INVALID_ID, 0, 0),
	m_dwExternId(INVALID_ID),
    m_cRefs(1), 
	m_cRequests(0),
    m_dwmTimeoutTime(0),
	m_nTimeout(0),
#ifndef PERF_DISABLE
    m_dwtInitTimestamp(0),
#endif
	m_lCodePage(0),
	m_lcid(LOCALE_SYSTEM_DEFAULT),
	m_fSecureSession(FALSE)
    {
	m_ISuppErrImp.Init(static_cast<ISessionObject *>(this), 
	                static_cast<ISessionObject *>(this), 
	                IID_ISessionObject);
	CDispatch::Init(IID_ISessionObject);

    InterlockedIncrement(&g_nSessionObjectsActive);

	IF_DEBUG(SESSION)
		WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);
    }

/*===================================================================
CSession::~CSession

Destructor

Parameters:

Returns:
===================================================================*/
CSession::~CSession()
    {
    Assert(m_fTombstone); // must be tombstoned before destructor
    Assert(m_cRefs == 0);  // must have 0 ref count

    InterlockedDecrement(&g_nSessionObjectsActive);

    }

/*===================================================================
CSession::Init

Initialize CSession object

Parameters:
    pAppln          session's application to remember
    Id              session id

Returns:
    HRESULT
===================================================================*/
HRESULT CSession::Init
(
CAppln *pAppln, 
const CSessionId &Id
)
	{
	// Update global sessions counter
    InterlockedIncrement((LPLONG)&g_nSessions);
    
#ifndef PERF_DISABLE
    g_PerfData.Incr_SESSIONCURRENT();
    g_PerfData.Incr_SESSIONSTOTAL();
    m_dwtInitTimestamp = GetTickCount();
#endif

	// Setup the object

	HRESULT hr = S_OK;

	m_pAppln = pAppln;
    m_Id     = Id;
    m_dwExternId = g_ExposedSessionIdGenerator.NewId();     
    
    // Update application's session count
    
	m_pAppln->IncrementSessionCount();

	// default to system's ansi code page
	m_lCodePage = pAppln->QueryAppConfig()->uCodePage();
	
    m_lcid = pAppln->QueryAppConfig()->uLCID();

	// default session timeout
	m_nTimeout = pAppln->QueryAppConfig()->dwSessionTimeout();

	// initialize Viper activity
	if (SUCCEEDED(hr))
   	    hr = m_Activity.Init(pAppln->QueryAppConfig()->fExecuteInMTA());

    // mark as Inited and update timestamp
	if (SUCCEEDED(hr))
    	m_fInited = TRUE;

    return hr;
    }
    
/*===================================================================
CSession::UnInit

UnInitialize CSession object. Convert to tombstone state.

Parameters:

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CSession::UnInit()
	{
	Assert(!m_fTombstone);  // don't do it twice

	// Remove from timeout bucket if any
	if (m_fInTOBucket)
        m_pAppln->PSessionMgr()->RemoveSessionFromTOBucket(this);

	// Cleanup the object
    RemoveComponentCollection();

    // Get rid of the intrinsics
    m_Request.UnInit();
	m_Response.UnInit();
	m_Server.UnInit();
    
    // Get rid of Viper activity
    m_Activity.UnInit();

	// Update global counters
#ifndef PERF_DISABLE
	if (m_fTimedOut)
	    g_PerfData.Incr_SESSIONTIMEOUT();
    g_PerfData.Decr_SESSIONCURRENT();
    DWORD dwt = GetTickCount();
	if (dwt >= m_dwtInitTimestamp)
	    dwt = dwt - m_dwtInitTimestamp;
    else
        dwt = (DWT_MAX - m_dwtInitTimestamp) + dwt;
    g_PerfData.Set_SESSIONLIFETIME(dwt);
#endif

	m_pAppln->DecrementSessionCount();
    InterlockedDecrement((LPLONG)&g_nSessions);

    m_pAppln = NULL;
    m_pHitObj = NULL;

    // Mark this session as Tombstone
	
	m_fTombstone = TRUE;

	// Disconnect proxies NOW (in case we are in shutdown, or enter shutdown later & a proxy has a ref.)

	CoDisconnectObject(static_cast<ISessionObject *>(this), 0);

	return S_OK;
    }
    
/*===================================================================
CSession::MakeLightWeight

Convert to 'light-weight' state if possible

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CSession::MakeLightWeight()
    {
    Assert(m_fInited);
    
    if (m_fLightWeight)
        return S_OK;
    
    if (m_cRequests > 1)   // requests pending for this session?
        return S_OK;

    if (m_fSessCompCol && !m_SessCompCol.FHasStateInfo())
        {
        // don't remove component collection from under enumerators
        if (!m_pTaggedObjects && !m_pProperties)
            RemoveComponentCollection();
        }

    m_fLightWeight = TRUE;
    return S_OK;
    }

/*===================================================================
CSession::CreateComponentCollection

Create and Init Session's component collection.

The actual object is aggregated by the session. Its state
is controlled be m_fSessCompCol flag.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CSession::CreateComponentCollection()
    {
    Assert(!m_fSessCompCol);

    HRESULT hr = m_SessCompCol.Init(csSession);

    if (SUCCEEDED(hr))
        {
        m_fSessCompCol = TRUE;
        }
    else
        {
        RemoveComponentCollection();
        }
        
	return hr;
    }

/*===================================================================
CSession::RemoveComponentCollection

Remove Session's component collection

The actual object is aggregated by the session. Its state
is controlled be m_fSessCompCol flag.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CSession::RemoveComponentCollection()
    {
    if (m_pTaggedObjects)
        {
        m_pTaggedObjects->UnInit();
        m_pTaggedObjects->Release();
        m_pTaggedObjects = NULL;
        }

    if (m_pProperties)
        {
        m_pProperties->UnInit();
        m_pProperties->Release();
        m_pProperties = NULL;
        }
        
    if (m_fSessCompCol)
        {
   	    m_SessCompCol.UnInit();
   	    m_fSessCompCol = FALSE;
   	    }

    return S_OK;
    }

/*===================================================================
CSession::FShouldBeDeletedNow

Tests if the session should be deleted

Parameters:
    BOOL fAtEndOfRequest    TRUE if at the end of a request

Returns:
    BOOL    TRUE (should be deleted) or FALSE (shouldn't)
===================================================================*/
BOOL CSession::FShouldBeDeletedNow
(
BOOL fAtEndOfRequest
)
    {
    if (fAtEndOfRequest)
        {
        // Any OTHER requests pending -> don't delete
    	if (m_cRequests > 1)
	        return FALSE;
        }
    else
        {
        // Any requests pending -> don't delete
    	if (m_cRequests > 0)
	        return FALSE;
        }

    // GLOBAL.ASA changed - delete
   	if (m_pAppln->FGlobalChanged())
   	    return TRUE;

    // Failed to start or abandoned - delete
	if (m_fOnStartFailed || m_fAbandoned)
	    return TRUE;

    // Is stateless session? No need for Session_OnEnd?
    if (!m_fSessCompCol    &&  // CompCol gone in MakeLightWeight()
        !m_fStateAcquired  &&  // no other properties set
        !m_fOnStartInvoked &&  // on start was never invoked
        !m_fOnEndPresent)      // on end is not present
        return TRUE;           // -> delete this session

    // don't check timeout here
    return FALSE;
    }

/*===================================================================
CSession::QueryInterface

QueryInterface() -- IUnknown implementation.

Parameters:
    REFIID riid
    void **ppv
    
Returns:
	HRESULT
===================================================================*/
STDMETHODIMP CSession::QueryInterface
(
REFIID riid,
void **ppv
)
    {
	*ppv = NULL;

	if (IID_IUnknown         == riid ||
	    IID_IDispatch        == riid ||
	    IID_ISessionObject   == riid || 
	    IID_IDenaliIntrinsic == riid)
	    {
		*ppv = static_cast<ISessionObject *>(this);
        ((IUnknown *)*ppv)->AddRef();
		return S_OK;
		}
		
    else if (IID_ISupportErrorInfo == riid)
        {
        m_ISuppErrImp.AddRef();
		*ppv = &m_ISuppErrImp;
		return S_OK;
		}
    else if (IID_IMarshal == riid)
        {
        *ppv = static_cast<IMarshal *>(this);
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
        }
	else
	    {
    	return E_NOINTERFACE;
    	}
    	
	}

/*===================================================================
CSession::AddRef

AddRef() -- IUnknown implementation.

Parameters:
    
Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CSession::AddRef()
    {
    DWORD cRefs = InterlockedIncrement((LPLONG)&m_cRefs);

	IF_DEBUG(SESSION)
		WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);

	return cRefs;
    }

/*===================================================================
CSession::Release

Release() -- IUnknown implementation.

Parameters:
    
Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CSession::Release()
    {
    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);

	IF_DEBUG(SESSION)
		WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);

	if (cRefs)
		return cRefs;

	delete this;
	return 0;
    }

/*===================================================================
CSession::CheckForTombstone

Tombstone stub for ISessionObject methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:
    
Returns:
	HRESULT     E_FAIL  if Tombstone
	            S_OK if not
===================================================================*/
HRESULT CSession::CheckForTombstone()
    {
    if (!m_fTombstone)
        return S_OK;
        
	ExceptionId
	    (
	    IID_ISessionObject, 
	    IDE_SESSION, 
	    IDE_INTRINSIC_OUT_OF_SCOPE
	    );
    return E_FAIL;
    }

/*===================================================================
CSession::get_SessionID

ISessionObject implementation.

Return the session ID to the caller

Parameters:
	BSTR *pbstrRet      [out] session id value
    
Returns:
	HRESULT
===================================================================*/
STDMETHODIMP CSession::get_SessionID
(
BSTR *pbstrRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	HRESULT hr = S_OK;

	wchar_t	wszId[15];
	_ultow(m_dwExternId, wszId, 10);
	*pbstrRet = SysAllocString(wszId);
	
	if (*pbstrRet == NULL)
    	{
		ExceptionId
		    (
		    IID_ISessionObject, 
		    IDE_SESSION_ID, 
		    IDE_SESSION_MAP_FAILED
		    );
		hr = E_FAIL;
	    }

	m_fStateAcquired = TRUE;                
	return hr;
    }
    
/*===================================================================
CSession::get_Timeout

ISessionObject implementation.

Return the default or user set timeout interval (in minutes)

Parameters:
    long *plVar         [out] timeout value (in minutes)
    
Returns:
	HRESULT
===================================================================*/
STDMETHODIMP CSession::get_Timeout
(
long *plVar
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	*plVar = m_nTimeout;
	return S_OK;
    }
    
/*===================================================================
CSession::put_Timeout

ISessionObject implementation.

Allows the user to set the timeout interval (in minutes)

Parameters:
    long lVar         timeout value (in minutes)
    
Returns:
	HRESULT
===================================================================*/
STDMETHODIMP CSession::put_Timeout
(
long lVar
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	if (lVar < SESSION_TIMEOUT_MIN || lVar > SESSION_TIMEOUT_MAX)
    	{
		ExceptionId
    		(
	    	IID_ISessionObject, 
	    	IDE_SESSION_ID, 
	    	IDE_SESSION_INVALID_TIMEOUT 
	    	);
		return E_FAIL;
	    }

	m_fStateAcquired = TRUE;
	m_fCustomTimeout = TRUE;
	
	m_nTimeout = lVar;
	return S_OK;
    }

/*===================================================================
CSession::get_CodePage

ISessionObject implementation.

Returns the current code page value for the request

Parameters:
    long *plVar     [out] code page value

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::get_CodePage
(
long *plVar 
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	Assert(m_pHitObj);

	*plVar = m_lCodePage;

	// If code page is 0, look up default ANSI code page
	if (*plVar == 0)
		{
		*plVar = (long) GetACP();
		}
		
	return S_OK;
    }

/*===================================================================
CSession::put_CodePage

ISessionObject implementation.

Sets the current code page value for the request

Parameters:
    long lVar       code page to assign to this session

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::put_CodePage
(
long lVar 
) 
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	// set code page member variable 
	Assert(m_pHitObj);
	HRESULT hr = m_pHitObj->SetCodePage(lVar);

	if (FAILED(hr))
		{
		ExceptionId
		    (
		    IID_ISessionObject,
		    IDE_SESSION_ID, 
		    IDE_SESSION_INVALID_CODEPAGE 
		    );
		return E_FAIL;
		}

    m_fCodePageSet = TRUE;

    m_lCodePage = lVar;
		
	// we need to preserve session since the user has set 
	// its code page member variable
	m_fStateAcquired = TRUE;
	return S_OK;
    }


/*===================================================================
CSession::get_LCID

ISessionObject implementation.

Returns the current lcid value for the request

Parameters:
    long *plVar     [out] code page value

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::get_LCID
(
long *plVar 
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	Assert(m_pHitObj);

	*plVar = m_lcid;

    if (*plVar == LOCALE_SYSTEM_DEFAULT) {
        *plVar = GetSystemDefaultLCID();
    }
	return S_OK;
    }

/*===================================================================
CSession::put_LCID

ISessionObject implementation.

Sets the current LCID value for the request

Parameters:
    long lVar   LCID to assign to this session

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::put_LCID
(
long lVar 
) 
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	// set code page member variable 
	Assert(m_pHitObj);
	HRESULT hr = m_pHitObj->SetLCID(lVar);	

	if (FAILED(hr))
		{
		ExceptionId
		    (
		    IID_ISessionObject,
		    IDE_SESSION_ID, 
		    IDE_TEMPLATE_BAD_LCID 
		    );
		return E_FAIL;
		}
	
    m_fLCIDSet = TRUE;
    m_lcid = lVar;

	// we need to preserve session since the user has set 
	// its lcid member variable
	m_fStateAcquired = TRUE;
	return S_OK;
    }

/*===================================================================
CSession::get_Value

ISessionObject implementation.

Will allow the user to retreive a session state variable, 
the variable will come as a named pair, bstr is the name and
var is the value or object to be returned for that name

Parameters:
	BSTR     bstrName	Name of the variable to get
	VARIANT *pVar		Value/object to get for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::get_Value
(
BSTR bstrName, 
VARIANT *pVar
)
    {	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

   	if (bstrName == NULL)
	    {
		ExceptionId(IID_ISessionObject, IDE_SESSION, IDE_EXPECTING_STR);
		return E_FAIL;
		}

	VariantInit(pVar); // default variant empty
	
    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);
    
	if (pwszName == NULL)
	    return S_OK; // no name - no value - no error
	//_wcsupr(pwszName);

	CComponentObject *pObj = NULL;
	HRESULT hr = S_OK;

    Assert(m_pHitObj);
    m_pHitObj->AssertValid();
    
	hr = m_pHitObj->GetPropertyComponent(csSession, pwszName, &pObj);
	
    if (SUCCEEDED(hr) && pObj)
        hr = pObj->GetVariant(pVar);

	return S_OK;
    }

/*===================================================================
CSession::putref_Value

ISessionObject implementation.

Will allow the user to assign a session state variable to be saved
the variable will come as a named pair, bstr is the name and
var is the value or object to be stored for that name

Parameters:
	BSTR 	bstrName	Name of the variable to set
	VARIANT Var			Value/object to set for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::putref_Value
(
BSTR bstrName, 
VARIANT Var
) 
    {	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FIsIntrinsic(&Var))
        {
	    ExceptionId(IID_ISessionObject, IDE_SESSION,
	                IDE_SESSION_CANT_STORE_INTRINSIC);
	    return E_FAIL;
        }

   	if (bstrName == NULL)
	    {
		ExceptionId(IID_ISessionObject, IDE_SESSION, IDE_EXPECTING_STR);
		return E_FAIL;
		}
        
	HRESULT hr;

    Assert(m_pHitObj);
    m_pHitObj->AssertValid();

    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);
    
	if (pwszName == NULL)
	    {
		ExceptionId
		    (
		    IID_ISessionObject,
		    IDE_SESSION,
		    IDE_EXPECTING_STR
		    );
		return E_FAIL;
		}
	//_wcsupr(pwszName);

    hr = m_pHitObj->SetPropertyComponent(csSession, pwszName, &Var);

	return hr;
    }

/*===================================================================
CSession::put_Value

ISessionObject implementation.

Implement property put by dereferencing variants before
calling putref.

Parameters:
	BSTR    bstrName	Name of the variable to set
	VARIANT Var			Value/object to set for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::put_Value
(
BSTR bstrName,
VARIANT Var 
)
    {	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
   	if (bstrName == NULL)
	    {
		ExceptionId(IID_ISessionObject, IDE_SESSION, IDE_EXPECTING_STR);
		return E_FAIL;
		}
        
	HRESULT hr;
	VARIANT varResolved;
	
	hr = VariantResolveDispatch
	    (
	    &varResolved, 
	    &Var,
        IID_ISessionObject, 
        IDE_SESSION
        );
        
	if (FAILED(hr))
		return hr;		// exception already raised

    Assert(m_pHitObj);
    m_pHitObj->AssertValid();

    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);
    
	if (pwszName == NULL)
	    {
		ExceptionId
		    (
		    IID_ISessionObject, 
		    IDE_SESSION,
		    IDE_EXPECTING_STR
		    );
    	VariantClear( &varResolved );
		return E_FAIL;
		}
	//_wcsupr(pwszName);
    
    hr = m_pHitObj->SetPropertyComponent
        (
        csSession, 
        pwszName,
        &varResolved
        );
        
	VariantClear( &varResolved );
                                         
	return hr;
    }

/*===================================================================
CSession::Abandon

ISessionObject implementation.

Abandon reassignes session id to avoid hitting this session
with incoming requests. Abandoned sessions get deleted ASAP.

Parameters:
	None

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::Abandon()
    {	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	m_fAbandoned = TRUE;

	// The new session logic allows only one session id per
	// client need to disassociate session from client
	// (good idea when abandoning anyway)
	Assert(m_pHitObj);

    // If execution Session_OnEnd (not a browser request), do nothing
	if (!m_pHitObj->FIsBrowserRequest())
	    return S_OK;
	    
   	return m_pHitObj->ReassignAbandonedSession();
    }

/*===================================================================
CSession::get_StaticObjects

Return the session static objects dictionary
===================================================================*/
STDMETHODIMP CSession::get_StaticObjects
(
IVariantDictionary **ppDictReturn
)
	{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (!m_pTaggedObjects)
        {
        m_pTaggedObjects = new CSessionVariants;
        if (!m_pTaggedObjects)
            return E_OUTOFMEMORY;
        
        HRESULT hr = m_pTaggedObjects->Init(this, ctTagged);
        if (FAILED(hr))
            {
            m_pTaggedObjects->UnInit();
            m_pTaggedObjects->Release();
            m_pTaggedObjects = NULL;
            }
        }

    Assert(m_pTaggedObjects);
	return m_pTaggedObjects->QueryInterface(IID_IVariantDictionary, reinterpret_cast<void **>(ppDictReturn));
	}

/*===================================================================
CSession::get_Contents

Return the session contents dictionary
===================================================================*/
STDMETHODIMP CSession::get_Contents
(
IVariantDictionary **ppDictReturn
)
	{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (!m_pProperties)
        {
        m_pProperties = new CSessionVariants;
        if (!m_pProperties)
            return E_OUTOFMEMORY;
            
        HRESULT hr = m_pProperties->Init(this, ctProperty);
        if (FAILED(hr))
            {
            m_pProperties->UnInit();
            m_pProperties->Release();
            m_pProperties = NULL;
            }
        }
        
    Assert(m_pProperties);
	return m_pProperties->QueryInterface(IID_IVariantDictionary, reinterpret_cast<void **>(ppDictReturn));
	}

#ifdef DBG
/*===================================================================
CSession::AssertValid

Test to make sure that the CSession object is currently 
correctly formed and assert if it is not.

Returns:
	None

Side effects:
	None.
===================================================================*/
VOID CSession::AssertValid() const
    {	
    Assert(m_fInited);

    if (!m_fTombstone)
        Assert(m_pAppln);
    }
#endif // DBG


/*===================================================================
  C  S e s s i o n  M g r
===================================================================*/

/*===================================================================
CSessionMgr::CSessionMgr

CSessionMgr constructor.

Parameters:
	NONE

Returns:
===================================================================*/
CSessionMgr::CSessionMgr()
    :
    m_fInited(FALSE),
    m_pAppln(NULL),
    m_cSessionCleanupRequests(0),
	m_cTimeoutBuckets(0),
	m_rgolTOBuckets(NULL),
    m_idSessionKiller(0),
    m_dwmCurrentTime(0),
    m_dwtNextSessionKillerTime(0)
    {
    }
    
/*===================================================================
CSessionMgr::~CSessionMgr

CSessionMgr destructor.

Parameters:
	NONE

Returns:
===================================================================*/
CSessionMgr::~CSessionMgr()
    {
    UnInit(); 
    }

/*===================================================================
HRESULT CSessionMgr::Init

Initializes the Session Manager.
Initializes hash tables.
Schedules session killer.

Parameters:
	pAppln      Application

Returns:
    HRESULT
===================================================================*/
HRESULT CSessionMgr::Init
(
CAppln *pAppln
)
    {
    Assert(!m_fInited);

    HRESULT hr;
	m_pAppln = pAppln;

    // Master hash table
	hr = m_htidMaster.Init
	    (
        SESSION_MASTERHASH_SIZE1_MAX,
        SESSION_MASTERHASH_SIZE2_MAX,
        SESSION_MASTERHASH_SIZE3_MAX
	    );
	if (FAILED(hr))
	    return hr;

    // Number of timeout buckets = session timeout in minutes + 1
    m_cTimeoutBuckets = 
        m_pAppln->QueryAppConfig()->dwSessionTimeout() + 1;
    
    if (m_cTimeoutBuckets < SESSION_TIMEOUTBUCKETS_MIN)
        m_cTimeoutBuckets = SESSION_TIMEOUTBUCKETS_MIN;
    else if (m_cTimeoutBuckets > SESSION_TIMEOUTBUCKETS_MAX)
        m_cTimeoutBuckets = SESSION_TIMEOUTBUCKETS_MAX;

	// Timeout buckets hash tables array
	m_rgolTOBuckets = new CObjectListWithLock[m_cTimeoutBuckets];
	if (!m_rgolTOBuckets)
	    return E_OUTOFMEMORY;

    // Each timeout bucket hash table
    for (DWORD i = 0; i < m_cTimeoutBuckets; i++)
        {
    	hr = m_rgolTOBuckets[i].Init
    	    (
    	    OBJECT_LIST_ELEM_FIELD_OFFSET(CSession, m_TOBucketElem)
    	    );
    	if (FAILED(hr))
    	    return hr;
        }

    // Schedule session killer
    hr = ScheduleSessionKiller();
    if (FAILED(hr))
        return hr;

    // Start counting time
    m_dwmCurrentTime = 0;
    
    // Remember the time of the next session killer
    m_dwtNextSessionKillerTime = ::GetTickCount() + MSEC_ONE_MINUTE;

	m_fInited = TRUE;
	return S_OK;
    }

/*===================================================================
HRESULT CSessionMgr::UnInit

UnInitializes the Session Manager.

Parameters:

Returns:
	S_OK
===================================================================*/
HRESULT CSessionMgr::UnInit( void )
    {
    // Un-schedule session killer
    if (m_idSessionKiller)
        UnScheduleSessionKiller();

    // Timeout buckets
	if (m_rgolTOBuckets)
	    {
        for (DWORD i = 0; i < m_cTimeoutBuckets; i++)
        	m_rgolTOBuckets[i].UnInit();
	    delete [] m_rgolTOBuckets;
	    m_rgolTOBuckets = NULL;
	    }
    m_cTimeoutBuckets = 0;	    

    // Master hash
	m_htidMaster.UnInit();

	m_fInited = FALSE;
	return S_OK;
    }

/*===================================================================
CSessionMgr::ScheduleSessionKiller

Sets up the session killer workitem for ATQ scheduler

Parameters:
    
Returns:
    HRESULT
===================================================================*/
HRESULT CSessionMgr::ScheduleSessionKiller()
    {
    Assert(!m_idSessionKiller);
    
    m_idSessionKiller = ScheduleWorkItem
        (
        CSessionMgr::SessionKillerSchedulerCallback,  // callback
        this,                                         // context
        MSEC_ONE_MINUTE,                              // timeout
        TRUE                                          // periodic
        );
        
    return m_idSessionKiller ? S_OK : E_FAIL;
    }
    
/*===================================================================
CSessionMgr::UnScheduleSessionKiller

Removes the session killer workitem for ATQ scheduler

Parameters:
    
Returns:
    S_OK
===================================================================*/
HRESULT CSessionMgr::UnScheduleSessionKiller()
    {
    if (m_idSessionKiller)
        {
        RemoveWorkItem(m_idSessionKiller);
        m_idSessionKiller = 0;
        }
    return S_OK;
    }

/*===================================================================
CSessionMgr::GenerateIdAndCookie

Generate new ID and cookie to be used create new session
or reassign the session ID for an existing session.

Parameters:
    pId             [out] ID
    pszNewCookie    [out] Cookie (buf must be long enough)

Returns:
    S_OK
===================================================================*/
HRESULT CSessionMgr::GenerateIdAndCookie
(
CSessionId *pId,
char  *pszNewCookie
)
    {
    pId->m_dwId = g_SessionIdGenerator.NewId();
    GenerateRandomDwords(&pId->m_dwR1, 2);
 
    EncodeSessionIdCookie
        (
        pId->m_dwId,
        pId->m_dwR1,
        pId->m_dwR2,
        pszNewCookie
        );
    
    return S_OK;
    }

/*===================================================================
CSessionMgr::NewSession

Creates and Inits a new CSession object

Parameters:
    Id            session id
    ppSession     [out] session created

Returns:
    HRESULT
===================================================================*/
HRESULT CSessionMgr::NewSession
(
const CSessionId &Id,
CSession **ppSession
)
    {
    Assert(m_fInited);
    
    HRESULT hr = S_OK;
    
	CSession *pSession = new CSession;
	if (!pSession)
	    hr = E_OUTOFMEMORY;

	if (SUCCEEDED(hr))
	    hr = pSession->Init(m_pAppln, Id);

	if (SUCCEEDED(hr))
	    {
	    Assert(pSession);
        *ppSession = pSession;
	    }
	else
	    {
	    // failed - do cleanup
	    if (pSession)
	        {
	        pSession->UnInit();
	        pSession->Release();
	        }
        *ppSession = NULL;
	    }
		
	return hr;
    }

/*===================================================================
CSessionMgr::ChangeSessionId

Reassigns different session Id to a session.
Updates the master hash.

This method is called when abandoning a session
to disassociate it from the client.

Parameters:
	pSession        session to change id on
    Id		        new session id to assign

Returns:
	S_OK on success
	E_FAIL	on failure
===================================================================*/
HRESULT CSessionMgr::ChangeSessionId
(
CSession *pSession,
const CSessionId &Id
)
    {
    HRESULT hr;
    
    // During request processing session's not supposed to be
    // in any timeout bucket
    Assert(!pSession->m_fInTOBucket);

    LockMaster();

    // Remove from master hash by Id
    hr = RemoveFromMasterHash(pSession);
    
    if (SUCCEEDED(hr))
        {
        // Assign new id
        pSession->AssignNewId(Id);

        // Reinsert into master hash by id
        hr = AddToMasterHash(pSession);
        }

    UnLockMaster();
    
    return hr;
    }

/*===================================================================
CSessionMgr::FindInMasterHash

Finds Session in master hash session id.
Doesn't Lock.

Parameters:
        Id            session id to find
        **ppSession   [out] session found
	
Returns:
	S_OK     good session found
	S_FALSE     session not found or bad session found
===================================================================*/
HRESULT CSessionMgr::FindInMasterHash
(
const CSessionId &Id, 
CSession **ppSession
)
    {
    Assert(m_fInited);
    
	// Find in the hash table
	HRESULT hr = m_htidMaster.FindObject(Id.m_dwId, (void **)ppSession);
	if (hr != S_OK)
	    {
	    // Not found
	    *ppSession = NULL;
	    return hr;
	    }

    // Session found, check if valid
	if ((*ppSession)->m_fAbandoned ||
	    (*ppSession)->m_fTombstone ||
	    !(*ppSession)->FPassesIdSecurityCheck(Id.m_dwR1, Id.m_dwR2))
	    {
	    // Bad session
        hr = S_FALSE;
	    }

	return hr;
	}

/*===================================================================
CSessionMgr::AddSessionToTOBucket

Adds session to the correct timeout bucket.
Locks the timeout bucket.

Parameters:
	pSession        - session to add
    
Returns:
	HRESULT
===================================================================*/
HRESULT CSessionMgr::AddSessionToTOBucket
(
CSession *pSession
)
    {
    HRESULT hr;
    
    // Should not be already in a timeout bucket
    Assert(!pSession->m_fInTOBucket);

    DWORD iBucket = GetSessionTOBucket(pSession);

    LockTOBucket(iBucket);
    
    hr = m_rgolTOBuckets[iBucket].AddObject(pSession);
    
    if (SUCCEEDED(hr))
        pSession->m_fInTOBucket = TRUE;
        
    UnLockTOBucket(iBucket);
    
    return hr;
    }
    
/*===================================================================
CSessionMgr::RemoveSessionToTOBucket

Removes from its timeout bucket if any.
Locks the timeout bucket.

Parameters:
	pSession        - session to remove
	fLock           - lock bucket? (not needed during shutdown)
    
Returns:
	HRESULT
===================================================================*/
HRESULT CSessionMgr::RemoveSessionFromTOBucket
(
CSession *pSession,
BOOL fLock
)
    {
    HRESULT hr;
    
    Assert(m_fInited);
    Assert(pSession->m_fInited);

    if (!pSession->m_fInTOBucket)   // not there - no error
        return S_OK;

    DWORD iBucket = GetSessionTOBucket(pSession);

    if (fLock)
        LockTOBucket(iBucket);

    if (pSession->m_fInTOBucket)    // recheck after locking
        hr = m_rgolTOBuckets[iBucket].RemoveObject(pSession);
    else
        hr = S_OK;

    if (SUCCEEDED(hr))
        pSession->m_fInTOBucket = FALSE;

    if (fLock)
        UnLockTOBucket(iBucket);
        
    return hr;
    }

/*===================================================================
CSessionMgr::DeleteSession

Delete now or post for deletion.
Should be called after the session is gone from the hash table

Parameters:
	CSession *pSession        - session to release
    BOOL fInSessionActivity   - TRUE when deleting HitObj's session
                                at the end of request (no Async 
                                calls needed)
    
Returns:
	HRESULT (S_OK)
===================================================================*/
HRESULT CSessionMgr::DeleteSession
(
CSession *pSession,
BOOL fInSessionActivity
)
    {
    Assert(pSession);
    pSession->AssertValid();

    // Take care of DELETE NOW case

    BOOL fDeleteNow = pSession->FCanDeleteWithoutExec();

    // If called not from the session's activity and session
    // has objects then need to switch to the right activity
    // to remove the session level objects

    if (!fInSessionActivity && pSession->FHasObjects())
        fDeleteNow = FALSE; 
    
    if (fDeleteNow)
        {
        pSession->UnInit();
        pSession->Release();
		return S_OK;
		}

    // THE ASYNC DELETE LOGIC

	HRESULT hr = S_OK;

	// Make sure session object exists after AsyncCall
	pSession->AddRef(); 

    // Create new HitObj and init it for session delete
    
	CHitObj *pHitObj = new CHitObj;
	if (pHitObj)
	    {
	    pHitObj->SessionCleanupInit(pSession);

    	if (fInSessionActivity)
    	    {
    	    // Already inside the correct activity no need to 
    	    // push the call through Viper
    	    
            BOOL fRequestReposted = FALSE;
            pHitObj->ViperAsyncCallback(&fRequestReposted);
            Assert(!fRequestReposted);  // this better not happen
            delete pHitObj;
    	    }
        else
            {
            // Ask Viper to post the request
        	hr = pHitObj->PostViperAsyncCall();
            if (FAILED(hr))
                delete pHitObj;
        	}
        }
    else
    	{
		hr = E_OUTOFMEMORY;
	    }

    if (FAILED(hr))
        {
        // Out of memery or Viper failed to post a request
        // Force the issue inside TRY CATCH
        // (not always safe to delete in the wrong thread)
        TRY
            hr = pSession->UnInit();
    	CATCH(nExcept)
    	    pSession->m_fTombstone = TRUE;
			CoDisconnectObject(static_cast<ISessionObject *>(pSession), 0);
	        hr = E_UNEXPECTED;
        END_TRY
        pSession->Release();
        }

    pSession->Release(); // Undo AddRef()
    return S_OK;
    }
    
/*===================================================================
CSessionMgr::DeleteExpiredSessions

Removes expired Sessions from a given timeout bucket

Parameters:
    iBucket     timeout bucket #

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CSessionMgr::DeleteExpiredSessions
(
DWORD iBucket
)
    {
    LockTOBucket(iBucket);

    void *pvSession = m_rgolTOBuckets[iBucket].PFirstObject();

    while (pvSession && !IsShutDownInProgress())
        {
        CSession *pSession = reinterpret_cast<CSession *>(pvSession);
        pvSession = m_rgolTOBuckets[iBucket].PNextObject(pvSession);

        if (pSession->GetRequestsCount() == 0)
            {
            BOOL fTimedOut = pSession->GetTimeoutTime() <= GetCurrentTime();
            BOOL fRemovedFromMasterHash = FALSE;
            
            if (fTimedOut || pSession->FShouldBeDeletedNow(FALSE))
                {
                LockMaster();

                if (pSession->GetRequestsCount() == 0) // recheck after lock
                    {
                    RemoveFromMasterHash(pSession);
                    fRemovedFromMasterHash = TRUE;
                    }
                    
          	    UnLockMaster();
                }

            if (fRemovedFromMasterHash)
                {
                if (fTimedOut)
                    pSession->m_fTimedOut = TRUE;

                // delete from timeout bucket
                m_rgolTOBuckets[iBucket].RemoveObject(pSession);
                pSession->m_fInTOBucket = FALSE;

                // delete session object itself (or schedule for deletion)
                DeleteSession(pSession);
                }
            }
        }

    UnLockTOBucket(iBucket);
    return S_OK;
    }

/*===================================================================
CSessionMgr::DeleteAllSessions

Application shutdown code.

Parameters:
    fForce      flag - force delete?

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CSessionMgr::DeleteAllSessions
(
BOOL fForce
)
    {
    // Remove session killer so that it wouldn't interfere
    UnScheduleSessionKiller();
    
    LockMaster();

    HRESULT hr = m_htidMaster.IterateObjects
        (
        DeleteAllSessionsCB,
        this,
        &fForce
        );

    if (fForce)
        m_htidMaster.RemoveAllObjects();
    
    UnLockMaster();
    return hr;
    }
    
/*===================================================================
CSessionMgr::DeleteAllSessionsCB

Static iterator callback. 
Removes Session regardless.

Parameters:
    pvSession       session passed as void*
    pvSessionMgr    session manager passed as void*
    pvfForce        flag if TRUE - force the issue

Returns:
    IteratorCallbackCode
===================================================================*/
IteratorCallbackCode CSessionMgr::DeleteAllSessionsCB
(
void *pvSession,
void *pvSessionMgr,
void *pvfForce
)
    {
    IteratorCallbackCode rc = iccContinue;
    
    CSession *pSession = reinterpret_cast<CSession *>(pvSession);
    CSessionMgr *pMgr = reinterpret_cast<CSessionMgr *>(pvSessionMgr);
    BOOL fForce = *(reinterpret_cast<BOOL *>(pvfForce));

	// Try for 5 seconds to post delete for each session
	for (int iT = 0; iT < 10; iT++)
	    {
	    if (pSession->GetRequestsCount() == 0)
	        {
	        if (fForce)
	            {
	            // When forcing delete and there are too many
	            // session cleanup requests quequed
	            // wait for the queue to drain
	            while (pMgr->GetNumSessionCleanupRequests() >= SUGGESTED_SESSION_CLEANUP_REQUESTS_MAX)
	                Sleep(100);
	            }
	        else // if (!fForce)
	            {
	            // When not forcing delete (on application restart)
	            // don't queue too many sessions at one time
	            
	            if (pMgr->GetNumSessionCleanupRequests() < SUGGESTED_SESSION_CLEANUP_REQUESTS_MAX)
                    rc = iccRemoveAndContinue;
                else
                    rc = iccRemoveAndStop;
                }
                
            if (pSession->FInTOBucket())
                pMgr->RemoveSessionFromTOBucket(pSession, !fForce);
                
       		pMgr->DeleteSession(pSession);
   		    break;
            }

        if (!fForce)
            break;
            
		Sleep(500);
		}

    return rc;
    }

/*===================================================================
CSessionMgr::SessionKillerSchedulerCallback

Static method implements ATQ scheduler callback functions.
Replaces session killer thread

Parameters:
    void *pv    context pointer (points to appl)

Returns:

Side effects:
    None.
===================================================================*/
void WINAPI CSessionMgr::SessionKillerSchedulerCallback
(
void *pv
)
    {
    if (IsShutDownInProgress())
        return;

    Assert(pv);
    CSessionMgr *pMgr = reinterpret_cast<CSessionMgr *>(pv);

    // Advance session killer time by 1 [minute]
    pMgr->m_dwmCurrentTime++;

    // Choose the bucket
    DWORD iBucket = pMgr->m_dwmCurrentTime % pMgr->m_cTimeoutBuckets;

    // Kill the sessions
    pMgr->DeleteExpiredSessions(iBucket);

    // Adjust the timeout to stay on the minute boundary
    pMgr->m_dwtNextSessionKillerTime += MSEC_ONE_MINUTE;

    // Calculate wait till next callback wakes up    
    DWORD dwtCur  = ::GetTickCount();
    DWORD dwtWait = 5000; //  5 sec if we are already late

//    if (dwtCur < pMgr->m_dwtNextSessionKillerTime)
//        {
        dwtWait = pMgr->m_dwtNextSessionKillerTime - dwtCur;
        if (dwtWait > MSEC_ONE_MINUTE)
            dwtWait = MSEC_ONE_MINUTE; // in case of wrap-around
//        }

    ScheduleAdjustTime(pMgr->m_idSessionKiller, dwtWait);
    }

#ifdef DBG
/*===================================================================
CSessionMgr::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CSessionMgr::AssertValid() const
    {
    Assert(m_fInited);
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\strlist.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: StringList object

File: strlist.cpp

Owner: DGottner

This file contains the code for the implementation of the String List object.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "strlist.h"
#include "MemChk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init


/*===================================================================
CStringListElem::CStringListElem

Constructor
===================================================================*/
CStringListElem::CStringListElem()
    : 
    m_fBufferInUse(FALSE),
    m_fAllocated(FALSE),
    m_pNext(NULL),
    m_szPointer(NULL)
	{
	}

/*===================================================================
CStringListElem::~CStringListElem

Destructor
===================================================================*/
CStringListElem::~CStringListElem()
	{
	if (m_fAllocated)
		delete [] m_szPointer;

    if (m_pNext)
    	delete m_pNext;
	}

/*===================================================================
CStringListElem::Init

Init CStringListElem

Parameters
	szValue         the string
	fMakeCopy       if FALSE - just store the pointer
    lCodePage       codepage to use to convert to UNICODE
===================================================================*/
HRESULT CStringListElem::Init(
    char    *szValue,
    BOOL    fMakeCopy,
    UINT    lCodePage)
{
    // for now, always make a copy of the string.  This is to ensure
    // that any string lists placed in session state via a dictionary
    // object do not have their elements freed from under them when
    // the request completes.

	if (1 /*fMakeCopy*/) {

        CMBCSToWChar    convStr;
        HRESULT         hr = S_OK;

        if (FAILED(hr = convStr.Init(szValue, lCodePage))) {
            return hr;
        }

        // now we will move the string into the elements memory.  If the 
        // converted string is bigger than the internal buffer, then
        // set the element's pointer to an allocated copy of the converted
        // string.

        if ((convStr.GetStringLen() + 1) > (sizeof(m_szBuffer)/sizeof(WCHAR))) {
            m_szPointer = convStr.GetString(TRUE);
            if (!m_szPointer)
                return E_OUTOFMEMORY;
		    m_fBufferInUse = FALSE;
		    m_fAllocated = TRUE;
        }
        else {

            // if it fits, simply copy it into the internal buffer.

            wcscpy(m_szBuffer, convStr.GetString());
		    m_fBufferInUse = TRUE;
		    m_fAllocated = FALSE;
        }
    }
#if 0
	else {
	    m_szPointer = szValue;
	    m_fBufferInUse = FALSE;
	    m_fAllocated = FALSE;
	}
#endif

    m_pNext = NULL;
    return S_OK;
}

/*===================================================================
CStringListElem::Init

Init CStringListElem

Parameters
	szValue         the string
	fMakeCopy       if FALSE - just store the pointer
===================================================================*/
HRESULT CStringListElem::Init(
    WCHAR   *wszValue,
    BOOL    fMakeCopy)
{
    // for now, always make a copy of the string.  This is to ensure
    // that any string lists placed in session state via a dictionary
    // object do not have their elements freed from under them when
    // the request completes.

	if (1 /*fMakeCopy*/) {

        // now we will move the string into the elements memory.  If the 
        // converted string is bigger than the internal buffer, then
        // set the element's pointer to an allocated copy

        if ((wcslen(wszValue) + 1) > (sizeof(m_szBuffer)/sizeof(WCHAR))) {
            m_szPointer = StringDupW(wszValue);
            if (!m_szPointer)
                return E_OUTOFMEMORY;
		    m_fBufferInUse = FALSE;
		    m_fAllocated = TRUE;
        }
        else {

            // if it fits, simply copy it into the internal buffer.

            wcscpy(m_szBuffer, wszValue);
		    m_fBufferInUse = TRUE;
		    m_fAllocated = FALSE;
        }
    }
#if 0
	else {
	    m_szPointer = szValue;
	    m_fBufferInUse = FALSE;
	    m_fAllocated = FALSE;
	}
#endif

    m_pNext = NULL;
    return S_OK;
}


/*===================================================================
CStringList::CStringList

Constructor
===================================================================*/

CStringList::CStringList(IUnknown *pUnkOuter, PFNDESTROYED pfnDestroy)
	: m_ISupportErrImp(this, pUnkOuter, IID_IStringList)
	{
	m_pBegin = m_pEnd = NULL;
	m_cValues = 0;
	m_cRefs = 1;
	m_pfnDestroy = pfnDestroy;
	CDispatch::Init(IID_IStringList);
	m_lCodePage = CP_ACP;
	}



/*===================================================================
CStringList::~CStringList

Destructor
===================================================================*/

CStringList::~CStringList()
	{
	if (m_pBegin)
    	delete m_pBegin;
	}



/*===================================================================
CStringList::AddValue

Parameters:
	szValue - value to add to the string list
	lCodePage - the CodePage used when construct return value
===================================================================*/

HRESULT CStringList::AddValue(char *szValue, BOOL fDuplicate, UINT lCodePage)
	{
	CStringListElem *pElem = new CStringListElem;
	if (!pElem)
    	return E_OUTOFMEMORY;

	m_lCodePage = lCodePage;

	HRESULT hr = pElem->Init(szValue, fDuplicate, lCodePage);
    if (FAILED(hr)) {
        delete pElem;
	    return hr;
    }

	if (m_pBegin == NULL)
	    {
		m_pBegin = m_pEnd = pElem;
		}
	else
		{
		m_pEnd->SetNext(pElem);
		m_pEnd = pElem;
		}

	++m_cValues;
	return S_OK;
	}

/*===================================================================
CStringList::AddValue

Parameters:
	szValue - value to add to the string list
	lCodePage - the CodePage used when construct return value
===================================================================*/

HRESULT CStringList::AddValue(WCHAR *szValue, BOOL fDuplicate)
	{
	CStringListElem *pElem = new CStringListElem;
	if (!pElem)
    	return E_OUTOFMEMORY;

	HRESULT hr = pElem->Init(szValue, fDuplicate);

    if (FAILED(hr)) {
        delete pElem;
	    return hr;
    }

	if (m_pBegin == NULL)
	    {
		m_pBegin = m_pEnd = pElem;
		}
	else
		{
		m_pEnd->SetNext(pElem);
		m_pEnd = pElem;
		}

	++m_cValues;
	return S_OK;
	}



/*===================================================================
CStringList::QueryInterface
CStringList::AddRef
CStringList::Release

IUnknown members for CStringList object.
===================================================================*/

STDMETHODIMP CStringList::QueryInterface(const IID &iid, void **ppvObj)
	{
	*ppvObj = NULL;

	if (iid == IID_IUnknown || iid == IID_IDispatch ||
	    iid == IID_IStringList || iid == IID_IDenaliIntrinsic)
	    {
		*ppvObj = this;
		}

	if (iid == IID_ISupportErrorInfo)
		*ppvObj = &m_ISupportErrImp;

	if (*ppvObj != NULL)
		{
		static_cast<IUnknown *>(*ppvObj)->AddRef();
		return S_OK;
		}

	return ResultFromScode(E_NOINTERFACE);
	}


STDMETHODIMP_(ULONG) CStringList::AddRef()
	{
	return ++m_cRefs;
	}


STDMETHODIMP_(ULONG) CStringList::Release()
	{
	if (--m_cRefs != 0)
		return m_cRefs;

	if (m_pfnDestroy != NULL)
		(*m_pfnDestroy)();

	delete this;
	return 0;
	}



/*===================================================================
CStringList::get_Count

Parameters:
	pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CStringList::get_Count(int *pcValues)
	{
	*pcValues = m_cValues;
	return S_OK;
	}



/*===================================================================
CStringList::ConstructDefaultReturn

Return comma-separated list for the case where the CStringList
is not indexed.
===================================================================*/

HRESULT CStringList::ConstructDefaultReturn(VARIANT *pvarOut) {
	VariantClear(pvarOut);

	//
	// NEW SEMANTIC: we now return Empty (and not "") if nothing is in the collection
	//
	if (m_cValues == 0)
		return S_OK;		// VariantClear set pvarOut to Empty

    STACK_BUFFER( tempValues, 1024 );

	register CStringListElem *pElem;
	int cBytes = 0;

	for (pElem = m_pBegin; pElem != NULL; pElem = pElem->QueryNext())
		cBytes += (wcslen(pElem->QueryValue()) * sizeof(WCHAR));

    // need to account for the ", " and NULL Termination

	cBytes += sizeof(WCHAR) + ((2*(m_cValues - 1)) * sizeof(WCHAR));

    if (!tempValues.Resize(cBytes)) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_OOM);
		return E_FAIL;
    }

	WCHAR *szReturn = (WCHAR *)tempValues.QueryPtr();
	szReturn[0] = L'\0';
    WCHAR *szNext = szReturn;

	for (pElem = m_pBegin; pElem != NULL; pElem = pElem->QueryNext()) {
		szNext = strcpyExW(szNext, pElem->QueryValue());
		if (pElem->QueryNext() != NULL)
			szNext = strcpyExW(szNext, L", ");
    }

	BSTR bstrT;
	if ((bstrT = SysAllocString(szReturn)) == NULL) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_OOM);
		return E_FAIL;
    }

	V_VT(pvarOut) = VT_BSTR;
	V_BSTR(pvarOut) = bstrT;

	return S_OK;
}



/*===================================================================
CStringList::get_Item
===================================================================*/

STDMETHODIMP CStringList::get_Item(VARIANT varIndex, VARIANT *pvarOut)
	{
	long i;
	VariantInit(pvarOut);


	if (V_VT(&varIndex) == VT_ERROR) {
		return ConstructDefaultReturn(pvarOut);
    }

	// BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing variants
	//   Loop through while we have a VT_BYREF until we get the real variant.
	//
	// and changed again...
	//
	// BUG 1609 the prior code was only checking for VT_I4 and jscript passed in a
	// VT_R8 and it failed so now we use the VariantChangeType call to solve the
	// problem

	VARIANT var;		
	VariantInit(&var);
	
	
	HRESULT hr = S_OK;
	if((hr = VariantChangeType(&var, &varIndex ,0,VT_I4)) != S_OK) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_EXPECTING_INT);
		return E_FAIL;
    }

	i = V_I4(&var);		
	VariantClear(&var);

	// END bug 1609

	if (i <= 0 || i > m_cValues) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
		return E_FAIL;
    }

	register CStringListElem *pElem = m_pBegin;
	while (--i > 0)
		pElem = pElem->QueryNext();

	BSTR bstrT;
	if ((bstrT = SysAllocString(pElem->QueryValue())) == NULL ) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_OOM);
		return E_FAIL;
    }

	V_VT(pvarOut) = VT_BSTR;
	V_BSTR(pvarOut) = bstrT;

	return S_OK;
}


/*===================================================================
CStringList::get__NewEnum
===================================================================*/

STDMETHODIMP CStringList::get__NewEnum(IUnknown **ppEnumReturn)
	{
	*ppEnumReturn = new CStrListIterator(this);
	if (*ppEnumReturn == NULL)
		{
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_OOM);
		return E_OUTOFMEMORY;
		}

	return S_OK;
	}



/*------------------------------------------------------------------
 * C S t r L i s t I t e r a t o r
 */

/*===================================================================
CStrListIterator::CStrListIterator

Constructor

NOTE: CRequest is (currently) not refcounted.  AddRef/Release
      added to protect against future changes.
===================================================================*/

CStrListIterator::CStrListIterator(CStringList *pStrings)
	{
	Assert (pStrings != NULL);

	m_pStringList = pStrings;
	m_pCurrent    = m_pStringList->m_pBegin;
	m_cRefs       = 1;

	m_pStringList->AddRef();
	}



/*===================================================================
CStrListIterator::CStrListIterator

Destructor
===================================================================*/

CStrListIterator::~CStrListIterator()
	{
	m_pStringList->Release();
	}



/*===================================================================
CStrListIterator::QueryInterface
CStrListIterator::AddRef
CStrListIterator::Release

IUnknown members for CServVarsIterator object.
===================================================================*/

STDMETHODIMP CStrListIterator::QueryInterface(REFIID iid, void **ppvObj)
	{
	if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
		{
		AddRef();
		*ppvObj = this;
		return S_OK;
		}

	*ppvObj = NULL;
	return E_NOINTERFACE;
	}


STDMETHODIMP_(ULONG) CStrListIterator::AddRef()
	{
	return ++m_cRefs;
	}


STDMETHODIMP_(ULONG) CStrListIterator::Release()
	{
	if (--m_cRefs > 0)
		return m_cRefs;

	delete this;
	return 0;
	}



/*===================================================================
CStrListIterator::Clone

Clone this iterator (standard method)
===================================================================*/

STDMETHODIMP CStrListIterator::Clone(IEnumVARIANT **ppEnumReturn)
	{
	CStrListIterator *pNewIterator = new CStrListIterator(m_pStringList);
	if (pNewIterator == NULL)
		return E_OUTOFMEMORY;

	// new iterator should point to same location as this.
	pNewIterator->m_pCurrent = m_pCurrent;

	*ppEnumReturn = pNewIterator;
	return S_OK;
	}



/*===================================================================
CStrListIterator::Next

Get next value (standard method)

To rehash standard OLE semantics:

	We get the next "cElements" from the collection and store them
	in "rgVariant" which holds at least "cElements" items.  On
	return "*pcElementsFetched" contains the actual number of elements
	stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
	otherwise.
===================================================================*/

STDMETHODIMP CStrListIterator::Next(unsigned long cElementsRequested, VARIANT *rgVariant, unsigned long *pcElementsFetched)
	{
	// give a valid pointer value to 'pcElementsFetched'
	//
	unsigned long cElementsFetched;
	if (pcElementsFetched == NULL)
		pcElementsFetched = &cElementsFetched;

	// Loop through the collection until either we reach the end or
	// cElements becomes zero
	//
	unsigned long cElements = cElementsRequested;
	*pcElementsFetched = 0;

	while (cElements > 0 && m_pCurrent != NULL)
		{
		BSTR bstrT = SysAllocString(m_pCurrent->QueryValue());
		if (bstrT == NULL)
			return E_OUTOFMEMORY;
		V_VT(rgVariant) = VT_BSTR;
		V_BSTR(rgVariant) = bstrT;

		++rgVariant;
		--cElements;
		++*pcElementsFetched;
		m_pCurrent = m_pCurrent->QueryNext();
		}

	// initialize the remaining variants
	//
	while (cElements-- > 0)
		VariantInit(rgVariant++);

	return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
	}



/*===================================================================
CStrListIterator::Skip

Skip items (standard method)

To rehash standard OLE semantics:

	We skip over the next "cElements" from the collection.
	Returns S_FALSE if less than "cElements" were skipped, S_OK
	otherwise.
===================================================================*/

STDMETHODIMP CStrListIterator::Skip(unsigned long cElements)
	{
	/* Loop through the collection until either we reach the end or
	 * cElements becomes zero
	 */
	while (cElements > 0 && m_pCurrent != NULL)
		{
		--cElements;
		m_pCurrent = m_pCurrent->QueryNext();
		}

	return (cElements == 0)? S_OK : S_FALSE;
	}



/*===================================================================
CStrListIterator::Reset

Reset the iterator (standard method)
===================================================================*/

STDMETHODIMP CStrListIterator::Reset()
	{
	m_pCurrent = m_pStringList->m_pBegin;
	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\thrdgate.h ===
/*===================================================================
Microsoft IIS 5.0 (ASP)

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: Thread Gate header

File: thrdgate.h

Owner: DmitryR

This file contains the definitons for the Thread Gate
===================================================================*/

#ifndef THRDGATE_H
#define THRDGATE_H

typedef struct _THREADGATE_CONFIG {

    BOOL  fEnabled;
    DWORD msTimeSlice;
    DWORD msSleepDelay;
    DWORD nSleepMax;
    DWORD nLoadLow;
    DWORD nLoadHigh;
    DWORD nMinProcessorThreads;
    DWORD nMaxProcessorThreads;

}   THREADGATE_CONFIG;

HRESULT InitThreadGate(THREADGATE_CONFIG *);

void UnInitThreadGate();

void EnterThreadGate(DWORD msCurrentTickCount);
void LeaveThreadGate();

#endif // THRDGATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\tlbcache.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Typelibrary cache

File: tlbcache.h

Owner: DmitryR

This is the typelibrary cache header file.
===================================================================*/

#ifndef _ASP_TLBCACHE_H
#define _ASP_TLBCACHE_H

/*===================================================================
  Includes
===================================================================*/

#include "compcol.h"
#include "hashing.h"
#include "idhash.h"
#include "dbllink.h"
#include "util.h"
#include "viperint.h"
#include "memcls.h"

/*===================================================================
  Defines
===================================================================*/

class CHitObj;

/*===================================================================
  C  T y p e l i b  C a c h e  E n t r y
===================================================================*/

class CTypelibCacheEntry : public CLinkElem
    {
    
friend class CTypelibCache;
    
private:
    DWORD       m_fInited : 1;
    DWORD       m_fIdsCached : 1;
    DWORD       m_fStrAllocated : 1;

    WCHAR      *m_wszProgId;
    CLSID       m_clsid;
    CompModel   m_cmModel;
    DISPID      m_idOnStartPage;
    DISPID      m_idOnEndPage;
    DWORD       m_gipTypelib;

    // buffer to keep prog id (when it fits)
    WCHAR       m_rgbStrBuffer[60];


    CTypelibCacheEntry();
    ~CTypelibCacheEntry();

    HRESULT StoreProgID(LPWSTR wszProgid, DWORD cbProgid);
    HRESULT InitByProgID(LPWSTR wszProgid, DWORD cbProgid);
    HRESULT InitByCLSID(const CLSID &clsid, LPWSTR wszProgid);
    
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*===================================================================
  C  T y p e l i b  C a c h e
===================================================================*/

class CTypelibCache
    {
private:
    DWORD m_fInited : 1;
    CHashTableStr m_htProgIdEntries;
    CHashTableCLSID m_htCLSIDEntries;
    CRITICAL_SECTION m_csLock;

    void Lock()   { EnterCriticalSection(&m_csLock); }
    void UnLock() { LeaveCriticalSection(&m_csLock); }

public:
    CTypelibCache();
    ~CTypelibCache();

    HRESULT Init();
    HRESULT UnInit();

    // to be called from Server.CreateObject
    HRESULT CreateComponent
        (
        BSTR         bstrProgID,
        CHitObj     *pHitObj,
        IDispatch  **ppdisp,
        CLSID       *pclsid
        );

    // to be called from template after mapping ProgId to CLSID
    HRESULT RememberProgidToCLSIDMapping
        (
        WCHAR *wszProgid, 
        const CLSID &clsid
        );
    // to be called from object creation code to update CLSID
    // if changed since mapping
    HRESULT UpdateMappedCLSID
        (
        CLSID *pclsid
        );
        
    };


/*===================================================================
  Globals
===================================================================*/

extern CTypelibCache g_TypelibCache;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\template.h ===
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

File:           template.h
Maintained by:  DaveK
Component:      include file for Denali Compiled Template object
==============================================================================*/

#ifndef _TEMPLATE_H
#define _TEMPLATE_H

#include "vector.h"
#include "LinkHash.h"
#include "Compcol.h"
#include "util.h"
#include "activdbg.h"
#include "ConnPt.h"
#include "DblLink.h"
#include "aspdmon.h"
#include "ie449.h"
#include "memcls.h"

#define PER_TEMPLATE_REFLOG 0

/*  NOTE we ensure that C_COUNTS_IN_HEADER is a multiple of 4 because the offsets which follow
    the counts in template header are dword-aligned.  It is easiest (and fastest at runtime)
    to make sure those offsets start on a dword-alignment point; thus no runtime alignment calc
    is needed in GetAddress().
*/
#define C_REAL_COUNTS_IN_HEADER     3       // actual number of count fields in template header
#define C_COUNTS_IN_HEADER          (C_REAL_COUNTS_IN_HEADER/4 + 1) * 4     // allocated number of count fields in template header

#define C_OFFOFFS_IN_HEADER         4       // number of 'ptr-to-ptr' fields in template header
#define CB_TEMPLATE_DEFAULT         2500    // default memory allocation for new template
#define C_TARGET_LINES_DEFAULT      50      // default count of target script lines per engine

#define C_TEMPLATES_PER_INCFILE_DEFAULT 4   // default count of templates per inc-file

#define         SZ_NULL         "\0"
#define         WSTR_NULL      L"\0"
#define         SZ_NEWLINE      "\r\n"
const unsigned  CB_NEWLINE      = strlen(SZ_NEWLINE);

const   LPSTR   g_szWriteBlockOpen  = "Response.WriteBlock(";
const   LPSTR   g_szWriteBlockClose = ")";
const   LPSTR   g_szWriteOpen       = "Response.Write(";
const   LPSTR   g_szWriteClose      = ")";

// defaults for buffering interim compile results
#define     C_SCRIPTENGINESDEFAULT  2       // default count of script engines
#define     C_SCRIPTSEGMENTSDEFAULT 20      // default count of script segments
#define     C_OBJECTINFOS_DEFAULT   10      // default count of object-infos
#define     C_HTMLSEGMENTSDEFAULT   20      // default count of HTML segments
#define     C_INCLUDELINESDEFAULT   5       // default count of include lines
#define     CB_TOKENS_DEFAULT       400     // default byte count for tokens

#define     CH_ATTRIBUTE_SEPARATOR  '='     // separator for attribute-value pair
#define     CH_SINGLE_QUOTE         '\''    // single-quote character
#define     CH_DOUBLE_QUOTE         '"'     // double-quote character
#define     CH_ESCAPE               '\\'    // escape character - tells us to ignore following token

// ACLs: the following code should in future be shared with IIS (see creatfil.cxx in IIS project)
// NOTE we want SECURITY_DESC_DEFAULT_SIZE to be relatively small, since it affects template memory reqt dramatically
#define     SECURITY_DESC_GRANULARITY   128        // 'chunk' size for re-sizing file security descriptor
#define     SECURITY_DESC_DEFAULT_SIZE  256        // initial default size of file security descriptor
#define     SIZE_PRIVILEGE_SET          128        // size of privilege set

// macros
// use outside of CTokenList class
#define SZ_TOKEN(i)                 (*gm_pTokenList).m_bufTokens.PszLocal(i)
#define CCH_TOKEN(i)                (*gm_pTokenList)[i]->m_cb
#define _TOKEN                      CTemplate::CTokenList::TOKEN
// use within CTokenList class
#define CCH_TOKEN_X(i)              (*this)[i]->m_cb
#define BR_TOKEN_X(i)               *((*this)[i])

// Use to specify which source file name you want (pathInfo or pathTranslated)
#ifndef _SRCPATHTYPE_DEFINED
#define _SRCPATHTYPE_DEFINED
enum SOURCEPATHTYPE
    {
    SOURCEPATHTYPE_VIRTUAL = 0,
    SOURCEPATHTYPE_PHYSICAL = 1
    };
#endif

// CTemplate error codes
#define E_COULDNT_OPEN_SOURCE_FILE              0x8000D001L
#define E_SOURCE_FILE_IS_EMPTY                  0x8000D002L
#define E_TEMPLATE_COMPILE_FAILED               0x8000D003L
#define E_USER_LACKS_PERMISSIONS                0x8000D004L
#define E_TEMPLATE_COMPILE_FAILED_DONT_CACHE    0x8000D005L
#define E_TEMPLATE_MAGIC_FAILURE                0x8000D006L

inline BOOL FIsPreprocessorError(HRESULT hr)
    {
    return
        (
        hr == E_SOURCE_FILE_IS_EMPTY                ||
        hr == E_TEMPLATE_COMPILE_FAILED             ||
        hr == E_TEMPLATE_COMPILE_FAILED_DONT_CACHE  ||
        hr == E_TEMPLATE_MAGIC_FAILURE
        );
    }

//Can not use same index as CErrorInfo anymore.
//Index for lastErrorInfo in Template
#define ILE_szFileName      0
#define ILE_szLineNum       1
#define ILE_szEngine        2
#define ILE_szErrorCode     3
#define ILE_szShortDes      4
#define ILE_szLongDes       5
#define ILE_MAX             6

// forward references
class CTemplate;
class CTemplateCacheManager;
class CHitObj;
class CTokenList;
class CIncFile;
typedef CLSID PROGLANG_ID;  // NOTE also defined in scrptmgr.h; we define here to avoid include file circularity

/*  ============================================================================
    Class:      CByteRange
    Synopsis:   A range of bytes
    NOTE fLocal member is only used if the byte range is stored in a CBuffer

    NOTE 2
        m_pfilemap is really a pointer to a CFileMap - however, it's impossible
        to declare that type here because the CFileMap struct is nested inside
        CTemplate, and C++ won't let you forward declare nested classes.  Since
        the CTemplate definition depends on CByteRange, properly declaring the
        type of "m_pfilemap" is impossible.
*/
class CByteRange
{
public:
    BYTE*   m_pb;               // ptr to bytes
    ULONG   m_cb;               // count of bytes
    ULONG   m_fLocal:1;         // whether bytes are stored in buffer (TRUE) or elsewhere (FALSE)
    UINT    m_idSequence:31;    // byte range's sequence id
    void*   m_pfilemap;         // file the byte range comes from

            CByteRange(): m_pb(NULL), m_cb(0), m_fLocal(FALSE), m_idSequence(0), m_pfilemap(NULL) {}
            CByteRange(BYTE* pb, ULONG cb): m_fLocal(FALSE), m_idSequence(0) {m_pb = pb; m_cb = cb;}
    BOOLB   IsNull() { return((m_pb == NULL) || (m_cb == 0)) ; }
    void    Nullify() { m_pb = NULL; m_cb = 0; }
    void    operator=(const CByteRange& br)
                { m_pb = br.m_pb; m_cb = br.m_cb; m_fLocal = br.m_fLocal; m_idSequence = br.m_idSequence; }
    BOOLB   FMatchesSz(LPCSTR psz);
    void    Advance(UINT i);
    BYTE*   PbString(LPSTR psz, LONG lCodePage);
    BYTE*   PbOneOfAspOpenerStringTokens(LPSTR rgszTokens[], UINT rgcchTokens[],
                                         UINT nTokens, UINT *pidToken);
    BOOLB   FEarlierInSourceThan(CByteRange& br);
};

/*  ============================================================================
    Enum type:  TEMPLATE_COMPONENT
    Synopsis:   A component of a template, e.g. script block, html block, etc.
*/
enum TEMPLATE_COMPONENT
{
    // NOTE enum values and order are tightly coupled with template layout order
    // DO NOT CHANGE
    tcompScriptEngine = 0,
    tcompScriptBlock,
    tcompObjectInfo,
    tcompHTMLBlock,
};

/*  ****************************************************************************
    Class:      CTemplateConnPt
    Synopsis:   Connection point for IDebugDocumentTextEvents
*/
class CTemplateConnPt : public CConnectionPoint
{
public:
    // ctor
    CTemplateConnPt(IConnectionPointContainer *pContainer, const GUID &uidConnPt)
        : CConnectionPoint(pContainer, uidConnPt) {}

    // IUnknown methods
    STDMETHOD(QueryInterface)(const GUID &, void **);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
};

/*	****************************************************************************
	Class:		CTemplateKey
	Synopsis:	Packaged data to locate template in hash table
	               (instance ID, and template name)
*/	
#define MATCH_ALL_INSTANCE_IDS 0xFFFBAD1D	// unlikely instance ID.  sort of spells "BAD ID"
struct CTemplateKey
	{
	const TCHAR *	szPathTranslated;
	DWORD			dwInstanceID;

	CTemplateKey(const TCHAR *_szPathTranslated = NULL, UINT _dwInstanceID = MATCH_ALL_INSTANCE_IDS)
		: szPathTranslated(_szPathTranslated),
		  dwInstanceID(_dwInstanceID)  {}
	};


/*  ****************************************************************************
    Class:      CTemplate
    Synopsis:   A Denali compiled template.

    NOTE: CTemplate's primary client is CTemplateCacheManager, which maintains
    a cache of compiled templates.

    USAGE
    -----
    The CTemplate class must be used as follows:

    CLASS INIT - InitClass must be called before any CTemplate can be created.

    NEW TEMPLATE - For each new template the client wants to create, the client
      must do the following, in order:
      1) New a CTemplate
      2) Initialize the CTemplate by calling Init, passing a source file name
      3) Load the CTemplate by calling Load; when Load returns, the new CTemplate is ready for use.

    EXISTING TEMPLATE - To use an existing template, the client must:
      1) Call Deliver; when Deliver returns, the existing CTemplate is ready for use.

    CLASS UNINIT - UnInitClass must be called after the last CTemplate has been destroyed.

    To ensure thread-safety, the client must implement a critical section
    around the call to Init.  Init is designed to be as fast as possible,
    so the client can quickly learn that it has a pending template for a given
    source file, and queue up other requests for the same source file.

    CTemplate provides implementations for Debug documents, namely
    IDebugDocumentProvider & IDebugDocumentText
*/
class CActiveScriptEngine;

class CTemplate :
            public CDblLink,
            public IDebugDocumentProvider,
            public IDebugDocumentText,
            public IConnectionPointContainer    // Source of IDebugDocumentTextEvents
{
private:
#include "templcap.h"   // 'captive' classes, only used internally within CTemplate

friend HRESULT InitMemCls();
friend HRESULT UnInitMemCls();

friend class	CTemplateCacheManager;			// TODO: decouple CTemplate class from it's manager class
friend class    CFileMap;
friend class    CIncFile;                       // IncFiles are privy to debugging data structures

// CScriptStore::Init() must access gm_brDefaultScriptLanguage, gm_progLangIdDefault
friend HRESULT  CTemplate::CScriptStore::Init(LPCSTR szDefaultScriptLanguage, CLSID *pCLSIDDefaultEngine);

private:
    CWorkStore* m_pWorkStore;               // ptr to working storage for source segments
    HANDLE      m_hEventReadyForUse;        // ready-for-use event handle
public:
    BYTE*       m_pbStart;                  // ptr to start of template memory
    ULONG       m_cbTemplate;               // bytes allocated for template
    LONG        m_cRefs;                    // ref count - NOTE LONG required by InterlockedIncrement
private:
    CTemplateConnPt m_CPTextEvents;         // Connection point for IDebugDocumentTextEvents

    // support for compile-time errors
    BYTE*       m_pbErrorLocation;          // ptr to error location in source file
    UINT        m_idErrMsg;                 // error message id
    UINT        m_cMsgInserts;              // count of insert strings for error msg
    char**      m_ppszMsgInserts;           // array of ptrs to error msg insert strings
    // support for run-time errors and debugging
    UINT        m_cScriptEngines;           // count of script engines
    CActiveScriptEngine **m_rgpDebugScripts;// array (indexed by engine) of scripts CURRENTLY BEING DEBUGGED
    vector<CSourceInfo> *m_rgrgSourceInfos; // array of arrays of script source line infos, one per script engine per target line
	ULONG       m_cbTargetOffsetPrevT;		// running total of last source offset processed
    CRITICAL_SECTION m_csDebuggerDetach;    // CS needed to avoid race condition with detaching from debugger
    CDblLink    m_listDocNodes;             // list of document nodes we are attached to
    CFileMap**  m_rgpFilemaps;              // array of ptrs to filemaps of source files
    CTemplateKey m_LKHashKey;               // bundled info for key (contains copy of m_rgpfilemaps[0] filename to make things simpler
    UINT        m_cFilemaps;                // count of filemaps of source files
    CFileMap**  m_rgpSegmentFilemaps;       // array of filemap ptrs per source segment
    UINT        m_cSegmentFilemapSlots;     // count of per-source-segment filemap ptrs
    LPSTR       m_pszLastErrorInfo[6];      // text of last error - cached for new requests on this template
                                            //  FileName, LineNum, Engine, ShortDes, LongDes
    DWORD       m_dwLastErrorMask;          // cached for new requests on this template
	DWORD		m_hrOnNoCache;				// HRESULT when don't cache is set.
    TCHAR*      m_szApplnVirtPath;          // application virtual path (substring of Application URL)
    TCHAR*      m_szApplnURL;               // application URL (starts with "http://")
    // for best structure packing we all boleans here as bitfields
    unsigned    m_fGlobalAsa:1;             // is template for global.asa file?
    unsigned    m_fIsValid:1;               // is template in valid state?
    unsigned    m_fDontCache:1;             // don't cache this template
    unsigned    m_fReadyForUse:1;           // is template ready for use?

    unsigned    m_fDebuggerDetachCSInited:1;// has debugger attach critical section been initialized?
    unsigned    m_fDontAttach:1;            // should not be attached to debugger (not in cache)
    unsigned    m_fSession:1;               // does this page require session state
    unsigned    m_fScriptless:1;            // doesn't have any scripts

    unsigned    m_fDebuggable:1;            // is this page part of at least one debuggable app?
    unsigned    m_fZombie:1;                // File template is based on has changed since obtained from cache
    unsigned    m_fCodePageSet:1;           // Did template contain a code page directive
    unsigned    m_fLCIDSet:1;               // Did template contain an LCID directive

    unsigned    m_fIsPersisted:1;
    TransType   m_ttTransacted;             // type of transaction support

    // class-wide support for compilation
    static      CTokenList*     gm_pTokenList;              // array of tokens
    unsigned    m_wCodePage;                                // Compiler Time CodePage
    long        m_lLCID;                                    // Compile Time LCID

    vector<ITypeLib *>  m_rgpTypeLibs;          // array of ptrs to typelibs
    IDispatch*          m_pdispTypeLibWrapper;  // typelib wrapper object

    vector<C449Cookie *> m_rgp449;              // array of ptrs to 449 requests

    LPSTR               m_szPersistTempName;    // filename of persisted template, if any
    void               *m_pHashTable;           // CacheMgr hash table that this template is on

    static  HANDLE sm_hSmallHeap;
    static  HANDLE sm_hLargeHeap;

public:
    /**
     **  Initialization and destruction public interfaces
     **/

    // Initializes CTemplate static members; must be called on denali.dll load
    static HRESULT InitClass();

    // Un-initilaizes CTemplate static members; must be called on denali.dll unload
    static void UnInitClass();

    //  Inits template in preparation for compilation
    //  Called by template cache mgr before calling Load
    HRESULT Init(CHitObj* pHitObj, BOOL fGlobalAsp, const CTemplateKey &rTemplateKey);

    //  Compiles the template from its main source file (and include files, if any)
    HRESULT Compile(CHitObj* pHitObj);

    // Called by requestor of existing template to determine if template is ready for use
    HRESULT Deliver(CHitObj* pHitObj);

            CTemplate();
            ~CTemplate();
    void    RemoveIncFile(CIncFile* pIncFile);

	// Trace Log info
	static PTRACE_LOG gm_pTraceLog;

public:
#if PER