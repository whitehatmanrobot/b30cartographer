s:

    There IS NO NonVolatileContext stored outside of the trap
    frame on a 386, with the exception of floating point.  Hence,
    the NonVolatileContextPointers argument to Get/SetContext is
    always NULL on the 386.

--*/

#include "psp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PspGetContext )
#pragma alloc_text(PAGE,PspGetSetContextSpecialApc )
#pragma alloc_text(PAGE,PspSetContext)
#endif


VOID
PspGetContext(
    IN PKTRAP_FRAME TrapFrame,
    IN PKNONVOLATILE_CONTEXT_POINTERS NonVolatileContext,
    IN OUT PCONTEXT Context
    )

/*++

Routine Description:

    This function moves the contents of the specified trap and NonVolatile
    context into the specified context record. It's primary user will
    be NtGetContextThread.

    N.B. - NonVolatileContext is IGNORED on the 386.

Arguments:

    TrapFrame - Supplies the contents of a trap frame that should be
                restored copied into the proper location in the context
                record.

    Context - Returns the threads current context.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( NonVolatileContext );

    PAGED_CODE();

    KeContextFromKframes(TrapFrame, NULL, Context);
}

VOID
PspSetContext(
    OUT PKTRAP_FRAME TrapFrame,
    OUT PKNONVOLATILE_CONTEXT_POINTERS NonVolatileContext,
    IN PCONTEXT Context,
    KPROCESSOR_MODE Mode
    )

/*++

Routine Description:

    This function moves the contents of the specified context record
    into the specified trap frame, and modifies the thread's non volatile
    context by storing through the thread's nonvolatile context pointers.

    N.B. - NonVolatileContext is IGNORED on the 386.

Arguments:

    TrapFrame - Returns selected pieces of the context record.

    Context - Supplies a context record to be copied in the trap and
              nonvolatile context.

    Mode - Supplies the mode to be used when sanitizing the psr, epsr and fsr

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( NonVolatileContext );

    PAGED_CODE();

    KeContextToKframes(TrapFrame, NULL, Context, Context->ContextFlags, Mode);
}

VOID
PspGetSetContextSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function either captures the usermode state of the current
    thread, or sets the usermode state of the current thread. The
    operation type is determined by the value of SystemArgument1. A
    NULL value is used for get context, and a non-NULL value is used
    for set context.

Arguments:

    Apc - Supplies a pointer to the APC control object that caused entry
          into this routine.

    NormalRoutine - Supplies a pointer to a pointer to the normal routine
        function that was specifed when the APC was initialized.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1, SystemArgument2 - Supplies a set of two pointer to two
        arguments that contain untyped data.

Return Value:

    None.

--*/

{
    PGETSETCONTEXT Ctx;
    PKTRAP_FRAME TrapFrame;
    PETHREAD Thread;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( NormalRoutine );
    UNREFERENCED_PARAMETER( NormalContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    Ctx = CONTAINING_RECORD(Apc,GETSETCONTEXT,Apc);

    Thread = Apc->SystemArgument2;

    TrapFrame = NULL;

    if (Ctx->Mode == KernelMode) {
        TrapFrame = Thread->Tcb.TrapFrame;
    }

    if (TrapFrame == NULL) {
        TrapFrame = PspGetBaseTrapFrame (Thread);
    }

    if ( Apc->SystemArgument1 ) {

        //
        // Set Context
        //

        PspSetContext(TrapFrame,NULL,&Ctx->Context,Ctx->Mode);

    } else {

        //
        // Get Context
        //

        PspGetContext(TrapFrame,NULL,&Ctx->Context);
    }

    KeSetEvent(&Ctx->OperationComplete,0,FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\raw\create.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for Raw called by the
    dispatch driver.

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawCreate)
#endif


NTSTATUS
RawCreate (
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Open the volume.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the read

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    BOOLEAN DeleteVolume = FALSE;

    PAGED_CODE();

    //
    //  This is an open/create request.  The only valid operation that
    //  is supported by the RAW file system is if the caller:
    //
    //    o  Specifies the device itself (file name == ""),
    //    o  specifies that this is an OPEN operation,
    //    o  and does not ask to create a directory.
    //

    Status = KeWaitForSingleObject( &Vcb->Mutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );
    ASSERT( NT_SUCCESS( Status ) );

    //
    // Don't allow any relative opens as well as opens with a filename. These opens have
    // only been checked for traverse access by the I/O manager.
    //
    if (((IrpSp->FileObject == NULL) || ((IrpSp->FileObject->FileName.Length == 0) &&
                                          IrpSp->FileObject->RelatedFileObject == NULL)) &&
        ((IrpSp->Parameters.Create.Options >> 24) == FILE_OPEN) &&
        ((IrpSp->Parameters.Create.Options & FILE_DIRECTORY_FILE) == 0)) {

        //
        //  If the volume is locked or dismounted we cannot open it again.
        //

        if ( FlagOn(Vcb->VcbState,  VCB_STATE_FLAG_LOCKED) ) {

            Status = STATUS_ACCESS_DENIED;
            Irp->IoStatus.Information = 0;

        } if ( FlagOn(Vcb->VcbState,  VCB_STATE_FLAG_DISMOUNTED) ) {

            Status = STATUS_VOLUME_DISMOUNTED;
            Irp->IoStatus.Information = 0;

        } else {

            //
            //  If the volume is already opened by someone then we need to check
            //  the share access
            //

            USHORT ShareAccess;
            ACCESS_MASK DesiredAccess;

            ShareAccess = IrpSp->Parameters.Create.ShareAccess;
            DesiredAccess = IrpSp->Parameters.Create.SecurityContext->DesiredAccess;

            if ((Vcb->OpenCount > 0) &&
                !NT_SUCCESS(Status = IoCheckShareAccess( DesiredAccess,
                                                         ShareAccess,
                                                         IrpSp->FileObject,
                                                         &Vcb->ShareAccess,
                                                         TRUE ))) {

                Irp->IoStatus.Information = 0;

            } else {

                //
                //  This is a valid create.  Increment the "OpenCount" and
                //  stuff the Vpb into the file object.
                //

                if (Vcb->OpenCount == 0) {

                    IoSetShareAccess( DesiredAccess,
                                      ShareAccess,
                                      IrpSp->FileObject,
                                      &Vcb->ShareAccess );
                }

                Vcb->OpenCount += 1;

                IrpSp->FileObject->Vpb = Vcb->Vpb;

                Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = FILE_OPENED;

                IrpSp->FileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;
            }
        }

    } else {

        //
        //  Fail this I/O request since one of the above conditions was
        //  not met.
        //
        Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;
    }

    //
    //  If this was not successful and this was the first open on the
    //  volume, we must implicitly dis-mount the volume.
    //

    if (!NT_SUCCESS(Status) && (Vcb->OpenCount == 0)) {

        DeleteVolume = RawCheckForDismount( Vcb, TRUE );
    }

    if (!DeleteVolume) {
        (VOID)KeReleaseMutex( &Vcb->Mutex, FALSE );
    }

    RawCompleteRequest( Irp, Status );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\raw\fileinfo.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    FileInfo.c

Abstract:

    This module implements the File Information routines for Raw called by
    the dispatch driver.

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawQueryInformation)
#pragma alloc_text(PAGE, RawSetInformation)
#endif

NTSTATUS
RawQueryInformation (
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine for querying file information, though only
    query current file position is supported.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the query


Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    PFILE_POSITION_INFORMATION Buffer;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    Length = &IrpSp->Parameters.QueryFile.Length;
    FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  The only request that is valid for raw is to query file position.
    //

    if ( FileInformationClass == FilePositionInformation ) {

        //
        //  Make sure the buffer is large enough
        //

        if (*Length < sizeof(FILE_POSITION_INFORMATION)) {

            Irp->IoStatus.Information = 0;

            Status = STATUS_BUFFER_OVERFLOW;

        } else {

            //
            //  Get the current position found in the file object.
            //

            Buffer->CurrentByteOffset = IrpSp->FileObject->CurrentByteOffset;

            //
            //  Update the length, irp info, and status output variables
            //

            *Length -= sizeof( FILE_POSITION_INFORMATION );

            Irp->IoStatus.Information = sizeof( FILE_POSITION_INFORMATION );

            Status = STATUS_SUCCESS;
        }

    } else {

        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    RawCompleteRequest( Irp, Status );

    UNREFERENCED_PARAMETER( Vcb );

    return Status;
}

NTSTATUS
RawSetInformation (
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine for setting file information, though only
    setting current file position is supported.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the set


Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    FILE_INFORMATION_CLASS FileInformationClass;
    PFILE_POSITION_INFORMATION Buffer;
    PFILE_OBJECT FileObject;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    FileInformationClass = IrpSp->Parameters.SetFile.FileInformationClass;
    Buffer = (PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer;
    FileObject= IrpSp->FileObject;

    //
    //  The only request that is valid for raw is to set file position.
    //

    if ( FileInformationClass == FilePositionInformation ) {

        //
        //  Check that the new position we're supplied is aligned properly
        //  for the device.
        //

        PDEVICE_OBJECT DeviceObject;

        DeviceObject = IoGetRelatedDeviceObject( IrpSp->FileObject );

        if ((Buffer->CurrentByteOffset.LowPart & DeviceObject->AlignmentRequirement) != 0) {

            Status = STATUS_INVALID_PARAMETER;

        } else {

            //
            //  The input parameter is fine so set the current byte offset.
            //

            FileObject->CurrentByteOffset = Buffer->CurrentByteOffset;

            Status = STATUS_SUCCESS;
        }

    } else {

        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    RawCompleteRequest( Irp, Status );

    UNREFERENCED_PARAMETER( Vcb );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\raw\fsctrl.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    FsCtrl.c

Abstract:

    This module implements the File System Control routines for Raw called
    by the dispatch driver.

--*/

#include "RawProcs.h"

//
//  Local procedure prototypes
//

NTSTATUS
RawMountVolume (
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawVerifyVolume (
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb
    );

NTSTATUS
RawUserFsCtrl (
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawMountVolume)
#pragma alloc_text(PAGE, RawUserFsCtrl)
#pragma alloc_text(PAGE, RawFileSystemControl)
#endif


NTSTATUS
RawFileSystemControl (
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine implements the FileSystem control operations

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the FileSystem control operation.

Return Value:

    NTSTATUS - The status for the IRP

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call an internal worker routine.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_USER_FS_REQUEST:

        Status = RawUserFsCtrl( IrpSp, Vcb );
        break;

    case IRP_MN_MOUNT_VOLUME:

        Status = RawMountVolume( IrpSp );
        break;

    case IRP_MN_VERIFY_VOLUME:

        Status = RawVerifyVolume( IrpSp, Vcb );
        break;

    default:

        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    RawCompleteRequest( Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
RawMountVolume (
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine performs the mount volume operation.

Arguments:

    IrpSp - Supplies the IrpSp parameters to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PDEVICE_OBJECT DeviceObjectWeTalkTo;

    PVOLUME_DEVICE_OBJECT VolumeDeviceObject;

    PAGED_CODE();

    //
    //  Save some references to make our life a little easier
    //

    DeviceObjectWeTalkTo = IrpSp->Parameters.MountVolume.DeviceObject;

    //
    // A mount operation has been requested.  Create a
    // new device object to represent this volume.
    //

    Status = IoCreateDevice( IrpSp->DeviceObject->DriverObject,
                             sizeof(VOLUME_DEVICE_OBJECT) - sizeof(DEVICE_OBJECT),
                             NULL,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             (PDEVICE_OBJECT *)&VolumeDeviceObject );

    if ( !NT_SUCCESS( Status ) ) {

        return Status;
    }

    //
    //  Our alignment requirement is the larger of the processor alignment requirement
    //  already in the volume device object and that in the DeviceObjectWeTalkTo
    //

    if (DeviceObjectWeTalkTo->AlignmentRequirement > VolumeDeviceObject->DeviceObject.AlignmentRequirement) {

        VolumeDeviceObject->DeviceObject.AlignmentRequirement = DeviceObjectWeTalkTo->AlignmentRequirement;
    }

    //
    // Set sector size to the same value as the DeviceObjectWeTalkTo.
    //

    VolumeDeviceObject->DeviceObject.SectorSize = DeviceObjectWeTalkTo->SectorSize;

    VolumeDeviceObject->DeviceObject.Flags |= DO_DIRECT_IO;

    //
    //  Initialize the Vcb for this volume
    //

    Status = RawInitializeVcb( &VolumeDeviceObject->Vcb,
                               IrpSp->Parameters.MountVolume.DeviceObject,
                               IrpSp->Parameters.MountVolume.Vpb );


    if ( !NT_SUCCESS( Status ) ) {

        //
        //  Unlike the other points of teardown we do not need to deref the target device
        //  a iosubsys will automatically do that for a failed mount
        //  

        IoDeleteDevice( (PDEVICE_OBJECT)VolumeDeviceObject );
        return Status;
    }

    //
    //  Finally, make it look as if the volume has been
    //  mounted.  This includes storing the
    //  address of this file system's device object (the one
    //  that was created to handle this volume) in the VPB so
    //  all requests are directed to this file system from
    //  now until the volume is initialized with a real file
    //  structure.
    //

    VolumeDeviceObject->Vcb.Vpb->DeviceObject = (PDEVICE_OBJECT)VolumeDeviceObject;
    VolumeDeviceObject->Vcb.Vpb->SerialNumber = 0xFFFFFFFF;
    VolumeDeviceObject->Vcb.Vpb->VolumeLabelLength = 0;

    VolumeDeviceObject->DeviceObject.Flags &= ~DO_DEVICE_INITIALIZING;
    VolumeDeviceObject->DeviceObject.StackSize = (UCHAR) (DeviceObjectWeTalkTo->StackSize + 1);

    {
        PFILE_OBJECT VolumeFileObject = NULL;

        //
        //  We need a file object to do the notification.
        //
        
        try {
            VolumeFileObject = IoCreateStreamFileObjectLite( NULL, &VolumeDeviceObject->DeviceObject );
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }

        if (!NT_SUCCESS(Status)) {
            IoDeleteDevice( (PDEVICE_OBJECT)VolumeDeviceObject );
            return Status;
        }

        //
        //  We need to bump the count up 2 now so that the close we do in a few lines
        //  doesn't make the Vcb go away now.
        //
        
        VolumeDeviceObject->Vcb.OpenCount += 2;
        FsRtlNotifyVolumeEvent( VolumeFileObject, FSRTL_VOLUME_MOUNT );
        ObDereferenceObject( VolumeFileObject );

        //
        //  Okay, the close is over, now we can safely decrement the open count again
       //  (back to 0) so the Vcb can go away when we're really done with it.
        //
        
        VolumeDeviceObject->Vcb.OpenCount -= 2;
    }
    
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
RawVerifyVolume (
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine verifies a volume.

Arguments:

    IrpSp - Supplies the IrpSp parameters to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    BOOLEAN DeleteVolume = FALSE;
    KIRQL   Irql;
    PVPB    vpb;
    BOOLEAN Mounted;

    //
    //  If the volume is somehow stale, dismount.  We must synchronize
    //  our inspection of the close count so we don't rip the volume up
    //  while racing with a close, for instance.  The VPB refcount drops
    //  *before* the close comes into the filesystem.
    //

    //
    // By this time its possible that the volume has been dismounted by
    // RawClose. So check if its mounted. If so, take a reference on the VPB
    // The reference on the VPB will prevent close from deleting the device.
    //

    IoAcquireVpbSpinLock(&Irql);

    Mounted = FALSE;
    vpb = IrpSp->Parameters.VerifyVolume.Vpb;
    if (vpb->Flags & VPB_MOUNTED) {
        vpb->ReferenceCount++;
        Mounted = TRUE;
    }

    IoReleaseVpbSpinLock(Irql);

    if (!Mounted) {
        return STATUS_WRONG_VOLUME;
    }

    Status = KeWaitForSingleObject( &Vcb->Mutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );
    ASSERT( NT_SUCCESS( Status ) );

    //
    //  Since we ignore all verify errors from the disk driver itself,
    //  this request must have originated from a file system, thus
    //  since we weren't the originators, we're going to say this isn't
    //  our volume, and if the open count is zero, dismount the volume.
    //

    IoAcquireVpbSpinLock(&Irql);
    vpb->ReferenceCount--;
    IoReleaseVpbSpinLock(Irql);

    Vcb->Vpb->RealDevice->Flags &= ~DO_VERIFY_VOLUME;

    if (Vcb->OpenCount == 0) {

        DeleteVolume = RawCheckForDismount( Vcb, FALSE );
    }

    if (!DeleteVolume) {
        (VOID)KeReleaseMutex( &Vcb->Mutex, FALSE );
    }

    return STATUS_WRONG_VOLUME;
}



//
//  Local Support Routine
//

NTSTATUS
RawUserFsCtrl (
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This is the common routine for implementing the user's requests made
    through NtFsControlFile.

Arguments:

    IrpSp - Supplies the IrpSp parameters to process

    Vcb - Supplies the volume we are working on.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    ULONG FsControlCode;
    PFILE_OBJECT FileObject;

    PAGED_CODE();

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;
    FileObject = IrpSp->FileObject;

    //
    //  Do pre-notification before entering the volume mutex so that we
    //  can be reentered by good threads cleaning up their resources.
    //

    switch (FsControlCode) {
        case FSCTL_LOCK_VOLUME:
            
            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_LOCK );
            break;

        case FSCTL_DISMOUNT_VOLUME:

            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_DISMOUNT );
            break;

        default:
            break;
    }
    
    Status = KeWaitForSingleObject( &Vcb->Mutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );
    ASSERT( NT_SUCCESS( Status ) );

    switch ( FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPLOCK_BREAK_NOTIFY:

        Status = STATUS_NOT_IMPLEMENTED;
        break;

    case FSCTL_LOCK_VOLUME:

        if ( !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_LOCKED) &&
             (Vcb->OpenCount == 1) ) {

            Vcb->VcbState |= VCB_STATE_FLAG_LOCKED;

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_ACCESS_DENIED;
        }

        break;

    case FSCTL_UNLOCK_VOLUME:

        if ( !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_LOCKED) ) {

            Status = STATUS_NOT_LOCKED;

        } else {

            Vcb->VcbState &= ~VCB_STATE_FLAG_LOCKED;

            Status = STATUS_SUCCESS;
        }

        break;

    case FSCTL_DISMOUNT_VOLUME:

        //
        //  Right now the logic in cleanup.c assumes that there can
        //  only be one handle on the volume if locked.  The code
        //  there needs to be fixed if forced dismounts are allowed.
        //

        if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_LOCKED)) {

            Vcb->VcbState |=  VCB_STATE_FLAG_DISMOUNTED;
            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_ACCESS_DENIED;
        }

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    (VOID)KeReleaseMutex( &Vcb->Mutex, FALSE );

    //
    //  Now perform post-notification as required.
    //

    if (NT_SUCCESS( Status )) {
    
        switch ( FsControlCode ) {
            case FSCTL_UNLOCK_VOLUME:

                FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_UNLOCK );
                break;
            
            default:
                break;
        }
    
    } else {
        
        switch ( FsControlCode ) {
            case FSCTL_LOCK_VOLUME:
                
                FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_LOCK_FAILED );
                break;

            case FSCTL_DISMOUNT_VOLUME:

                FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_DISMOUNT_FAILED );
                break;

            default:
                break;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\raw\rawprocs.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    RawProcs.h

Abstract:

    This module defines all of the globally used procedures in the Raw
    file system.

--*/

#ifndef _RAWPROCS_
#define _RAWPROCS_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses

#include <string.h>
#include <ntos.h>
#include <zwapi.h>
#include <FsRtl.h>
#include <ntdddisk.h>

#include "nodetype.h"
#include "RawStruc.h"


//
//  This is the main entry point to the Raw File system.
//

NTSTATUS
RawDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );


//
//  MAJOR FUNCTIONS
//
//  These routines are called by RawDispatch via the I/O system via the
//  dispatch table in the Driver Object.  If the status returned is not
//  STATUS_PENDING, the Irp will be complete with this status.
//

NTSTATUS
RawCleanup (                         //  implemented in Cleanup.c
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawClose (                           //  implemented in Close.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawCreate (                          //  implemented in Create.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawFileSystemControl (               //  implemented in FsCtrl.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawReadWriteDeviceControl (          //  implemented in ReadWrit.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawQueryInformation (                //  implemented in FileInfo.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawSetInformation (                  //  implemented in FileInfo.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawQueryVolumeInformation (          //  implemented in VolInfo.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );


//
//  Miscellaneous support routines
//

//
//  Completion routine for read, write, and device control to deal with
//  verify issues.  Implemented in RawDisp.c
//

NTSTATUS
RawCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
//  In-memory structure support routines, implemented in StrucSup.c
//

NTSTATUS
RawInitializeVcb (
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb
    );

BOOLEAN
RawCheckForDismount (
    PVCB Vcb,
    BOOLEAN CalledFromCreate
    );

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define BooleanFlagOn(Flags,SingleFlag) (                          \
    ((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE) 
    
//
//  This macro just returns the particular flag if its set
//  

#define FlagOn(F,SF) ( \
    (((F) & (SF)))     \
)

    
//
//  This macro completes a request
//

#define RawCompleteRequest(IRP,STATUS) {           \
                                                   \
    (IRP)->IoStatus.Status = (STATUS);             \
                                                   \
    IoCompleteRequest( (IRP), IO_DISK_INCREMENT ); \
}

#endif // _RAWPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\raw\rawstruc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    RawStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Raw file system.

--*/

#ifndef _RAWSTRUC_
#define _RAWSTRUC_


//
//  The Vcb (Volume control Block) record corresponds to every volume mounted
//  by the file system.  This structure must be allocated from non-paged pool.
//

typedef struct _VCB {

    //
    //  The type and size of this record (must be RAW_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A pointer the device object passed in by the I/O system on a mount
    //  This is the target device object that the file system talks to when it
    //  needs to do any I/O (e.g., the disk stripper device object).
    //
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    //  A pointer to the VPB for the volume passed in by the I/O system on
    //  a mount.
    //

    PVPB Vpb;

    //
    //  A pointer to a spare Vpb used for explicit dismount
    // 

    PVPB SpareVpb;


    //
    //  The internal state of the device.
    //

    USHORT VcbState;

    //
    //  A mutex to control access to VcbState, OpenCount and ShareAccess
    //

    KMUTEX Mutex;

    //
    //  A count of the number of file objects that have opened the volume
    //  and their share access state.
    //

    CLONG OpenCount;

    SHARE_ACCESS ShareAccess;

    //
    //  Information about the disk geometry
    //

    ULONG BytesPerSector;

    LARGE_INTEGER SectorsOnDisk;

} VCB;
typedef VCB *PVCB;

#define VCB_STATE_FLAG_LOCKED            (0x0001)
#define VCB_STATE_FLAG_DISMOUNTED        (0x0002)

//
//  The Volume Device Object is an I/O system device object with a
//  VCB record appended to the end.  There are multiple of these
//  records, one for every mounted volume, and are created during
//  a volume mount operation.
//

typedef struct _VOLUME_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;

} VOLUME_DEVICE_OBJECT;
typedef VOLUME_DEVICE_OBJECT *PVOLUME_DEVICE_OBJECT;

#endif // _RAWSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\raw\nodetype.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

--*/

#ifndef _NODETYPE_
#define _NODETYPE_

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x0000)

#define RAW_NTC_VCB                      ((NODE_TYPE_CODE)0x0600)

typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\raw\rawinit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    RawInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for Raw

--*/

#include "RawProcs.h"
#include <zwapi.h>

NTSTATUS
RawInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
RawUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
RawShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, RawInitialize)
#pragma alloc_text(PAGE, RawUnload)
#pragma alloc_text(PAGE, RawShutdown)
#endif
PDEVICE_OBJECT RawDeviceCdRomObject;
PDEVICE_OBJECT RawDeviceTapeObject;
PDEVICE_OBJECT RawDeviceDiskObject;


NTSTATUS
RawInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the Raw file system
    device driver.  This routine creates the device object for the FileSystem
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING NameString;

    UNREFERENCED_PARAMETER (RegistryPath);

    //
    //  First create a device object for the Disk file system queue
    //

    RtlInitUnicodeString( &NameString, L"\\Device\\RawDisk" );
    Status = IoCreateDevice( DriverObject,
                             0L,
                             &NameString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             &RawDeviceDiskObject );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    DriverObject->DriverUnload = RawUnload;
    //
    //  Now create one for the CD ROM file system queue
    //

    RtlInitUnicodeString( &NameString, L"\\Device\\RawCdRom" );
    Status = IoCreateDevice( DriverObject,
                             0L,
                             &NameString,
                             FILE_DEVICE_CD_ROM_FILE_SYSTEM,
                             0,
                             FALSE,
                             &RawDeviceCdRomObject );
    if (!NT_SUCCESS( Status )) {
        IoDeleteDevice (RawDeviceDiskObject);
        return Status;
    }

    //
    //  And now create one for the Tape file system queue
    //

    RtlInitUnicodeString( &NameString, L"\\Device\\RawTape" );
    Status = IoCreateDevice( DriverObject,
                             0L,
                             &NameString,
                             FILE_DEVICE_TAPE_FILE_SYSTEM,
                             0,
                             FALSE,
                             &RawDeviceTapeObject );
    if (!NT_SUCCESS( Status )) {
        IoDeleteDevice (RawDeviceCdRomObject);
        IoDeleteDevice (RawDeviceDiskObject);
        return Status;
    }

    //
    // Register a shutdown handler to enable us to unregister the file system objects
    //
    Status = IoRegisterShutdownNotification (RawDeviceTapeObject);
    if (!NT_SUCCESS( Status )) {
        IoDeleteDevice (RawDeviceTapeObject);
        IoDeleteDevice (RawDeviceCdRomObject);
        IoDeleteDevice (RawDeviceDiskObject);
        return Status;
    }
    //
    //  Raw does direct IO
    //

    RawDeviceDiskObject->Flags |= DO_DIRECT_IO;
    RawDeviceCdRomObject->Flags |= DO_DIRECT_IO;
    RawDeviceTapeObject->Flags |= DO_DIRECT_IO;

    //
    //  Initialize the driver object with this driver's entry points.  Note
    //  that only a limited capability is supported by the raw file system.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]                   =
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                  =
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                    =
    DriverObject->MajorFunction[IRP_MJ_READ]                     =
    DriverObject->MajorFunction[IRP_MJ_WRITE]                    =
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]        =
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]          =
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION] =
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                  =
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL]      =
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]           =
    DriverObject->MajorFunction[IRP_MJ_PNP]                      =

                                                (PDRIVER_DISPATCH)RawDispatch;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN]                 = RawShutdown;


    //
    // Finally, register this file system in the system.
    //

    IoRegisterFileSystem( RawDeviceDiskObject );
    IoRegisterFileSystem( RawDeviceCdRomObject );
    IoRegisterFileSystem( RawDeviceTapeObject );
    ObReferenceObject (RawDeviceDiskObject);
    ObReferenceObject (RawDeviceCdRomObject);
    ObReferenceObject (RawDeviceTapeObject);

    //
    //  And return to our caller
    //

    return( STATUS_SUCCESS );
}

NTSTATUS
RawShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    UNREFERENCED_PARAMETER (DeviceObject);

    //
    // Unregister the file system objects so we can unload
    //
    IoUnregisterFileSystem (RawDeviceDiskObject);
    IoUnregisterFileSystem (RawDeviceCdRomObject);
    IoUnregisterFileSystem (RawDeviceTapeObject);

    IoDeleteDevice (RawDeviceTapeObject);
    IoDeleteDevice (RawDeviceCdRomObject);
    IoDeleteDevice (RawDeviceDiskObject);

    RawCompleteRequest( Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


VOID
RawUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This is the unload routine for the Raw file system

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER (DriverObject);

    ObDereferenceObject (RawDeviceTapeObject);
    ObDereferenceObject (RawDeviceCdRomObject);
    ObDereferenceObject (RawDeviceDiskObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\raw\readwrit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    ReadWrit.c

Abstract:

    This module implements the File Read and Write routines called by the
    dispatch driver.

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawReadWriteDeviceControl)
#endif

NTSTATUS
RawReadWriteDeviceControl (
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the a common routine for both reading and writing a volume.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp to process

    IrpSp - Supplies parameters describing the read or write

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION NextIrpSp;
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  If this was for a zero byte read or write transfer, just complete
    //  it with success.
    //

    if (((IrpSp->MajorFunction == IRP_MJ_READ) ||
         (IrpSp->MajorFunction == IRP_MJ_WRITE)) &&
        (IrpSp->Parameters.Read.Length == 0)) {

        RawCompleteRequest( Irp, STATUS_SUCCESS );

        return STATUS_SUCCESS;
    }

    //
    //  This is a very simple operation.  Simply forward the
    //  request to the device driver since exact blocks are
    //  being read and return whatever status was given.
    //
    //  Get the next stack location, and copy over the stack location
    //

    NextIrpSp = IoGetNextIrpStackLocation( Irp );

    *NextIrpSp = *IrpSp;

    //
    //  Prohibit verifies all together.
    //

    NextIrpSp->Flags |= SL_OVERRIDE_VERIFY_VOLUME;

    //
    //  Set up the completion routine
    //

    IoSetCompletionRoutine( Irp,
                            RawCompletionRoutine,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request.
    //

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\raw\rawdisp.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    RawDisp.c

Abstract:

    This module is the main entry point for all major function codes.
    It is responsible for dispatching the request to the appropriate
    routine.

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawDispatch)
#endif


NTSTATUS
RawDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Dispatch the request to the appropriate function.  It is the worker
    function's responsibility to appropriately complete the IRP.

Arguments:

    VolumeDeviceObject - Supplies the volume device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the IRP

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PVCB Vcb;

    PAGED_CODE();

    //
    //  Get a pointer to the current stack location.  This location contains
    //  the function codes and parameters for this particular request.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Check for operations associated with our FileSystemDeviceObjects
    //  as opposed to our VolumeDeviceObjects.  Only mount is allowed to
    //  continue through the normal dispatch in this case.
    //

    if ((((PDEVICE_OBJECT)VolumeDeviceObject)->Size == sizeof(DEVICE_OBJECT)) &&
        !((IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
          (IrpSp->MinorFunction == IRP_MN_MOUNT_VOLUME))) {

        if ((IrpSp->MajorFunction == IRP_MJ_CREATE) ||
            (IrpSp->MajorFunction == IRP_MJ_CLEANUP) ||
            (IrpSp->MajorFunction == IRP_MJ_CLOSE)) {

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_INVALID_DEVICE_REQUEST;
        }

        RawCompleteRequest( Irp, Status );

        return Status;
    }

    FsRtlEnterFileSystem();

    //
    //  Get a pointer to the Vcb.  Note that is we are mount a volume this
    //  pointer will not have meaning, but that is OK since we will not
    //  use it in that case.
    //

    Vcb = &VolumeDeviceObject->Vcb;

    //
    //  Case on the function that is being performed by the requestor.  We
    //  should only see expected requests since we filled the dispatch table
    //  by hand.
    //

    try {

        switch ( IrpSp->MajorFunction ) {

            case IRP_MJ_CLEANUP:

                Status = RawCleanup( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_CLOSE:

                Status = RawClose( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_CREATE:

                Status = RawCreate( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_FILE_SYSTEM_CONTROL:

                Status = RawFileSystemControl( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_PNP: 

                if(IrpSp->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE) {
                    Status = STATUS_DEVICE_BUSY;
                    RawCompleteRequest(Irp, Status);
                    break;
                } 

            case IRP_MJ_READ:
            case IRP_MJ_WRITE:
            case IRP_MJ_DEVICE_CONTROL:

                Status = RawReadWriteDeviceControl( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_QUERY_INFORMATION:

                Status = RawQueryInformation( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_SET_INFORMATION:

                Status = RawSetInformation( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_QUERY_VOLUME_INFORMATION:

                Status = RawQueryVolumeInformation( Vcb, Irp, IrpSp );
                break;

            default:

                //
                //  We should never get a request we don't expect.
                //

                KdPrint(("Raw: Illegal Irp major function code 0x%x.\n", IrpSp->MajorFunction));
                KeBugCheckEx( FILE_SYSTEM, 0, 0, 0, 0 );
        }

    } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
              EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

        //
        //  No routine we call should ever generate an exception
        //

        Status = GetExceptionCode();

        KdPrint(("Raw: Unexpected exception %X.\n", Status));
    }

    //
    //  And return to our caller
    //

    FsRtlExitFileSystem();

    return Status;
}

//
//  Completion routine for read, write, and device control to deal with
//  verify issues.  Implemented in RawDisp.c
//

NTSTATUS
RawCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Simply update the file pointer context in the file object if we
    //  were successful and this was a synrchonous read or write.
    //

    if (((IrpSp->MajorFunction == IRP_MJ_READ) ||
         (IrpSp->MajorFunction == IRP_MJ_WRITE)) &&
        (IrpSp->FileObject != NULL) &&
        FlagOn(IrpSp->FileObject->Flags, FO_SYNCHRONOUS_IO) &&
        NT_SUCCESS(Irp->IoStatus.Status)) {

        IrpSp->FileObject->CurrentByteOffset.QuadPart =
            IrpSp->FileObject->CurrentByteOffset.QuadPart +
            Irp->IoStatus.Information;
    }

    //
    //  If IoCallDriver returned PENDING, mark our stack location
    //  with pending.
    //

    if ( Irp->PendingReturned ) {

        IoMarkIrpPending( Irp );
    }

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Context );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\add2stra.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
//
// You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#undef UNICODE
#undef _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <stdio.h>
#include <tchar.h>

#define RtlIpv6AddressToStringT RtlIpv6AddressToStringA
#define RtlIpv4AddressToStringT RtlIpv4AddressToStringA
#define RtlIpv6AddressToStringExT RtlIpv6AddressToStringExA
#define RtlIpv4AddressToStringExT RtlIpv4AddressToStringExA

#include "add2strt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\raw\volinfo.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    VolInfo.c

Abstract:

    This module implements the volume information routines for Raw called by
    the dispatch driver.

--*/

#include "RawProcs.h"

NTSTATUS
RawQueryFsVolumeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
RawQueryFsSizeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
RawQueryFsDeviceInfo (
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
RawQueryFsAttributeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawQueryVolumeInformation)
#pragma alloc_text(PAGE, RawQueryFsVolumeInfo)
#pragma alloc_text(PAGE, RawQueryFsSizeInfo)
#pragma alloc_text(PAGE, RawQueryFsDeviceInfo)
#pragma alloc_text(PAGE, RawQueryFsAttributeInfo)
#endif


NTSTATUS
RawQueryVolumeInformation (
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine implements the NtQueryVolumeInformation API call.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the read

Return Value:

    NTSTATUS - The status for the Irp.

--*/

{
    NTSTATUS Status;

    ULONG Length;
    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryVolume.Length;
    FsInformationClass = IrpSp->Parameters.QueryVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Based on the information class we'll do different actions.  Each
    //  of the procedures that we're calling fills up the output buffer
    //  if possible and returns true if it successfully filled the buffer
    //  and false if it couldn't wait for any I/O to complete.
    //

    switch (FsInformationClass) {

    case FileFsVolumeInformation:

        Status = RawQueryFsVolumeInfo( Vcb, Buffer, &Length );
        break;

    case FileFsSizeInformation:

        Status = RawQueryFsSizeInfo( Vcb, Buffer, &Length );
        break;

    case FileFsDeviceInformation:

        Status = RawQueryFsDeviceInfo( Vcb, Buffer, &Length );
        break;

    case FileFsAttributeInformation:

        Status = RawQueryFsAttributeInfo( Vcb, Buffer, &Length );
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    //
    //  Set the information field to the number of bytes actually filled in,
    //  and complete the request.
    //

    Irp->IoStatus.Information = IrpSp->Parameters.QueryVolume.Length - Length;

    RawCompleteRequest( Irp, Status );

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
RawQueryFsVolumeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume info call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return receives the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    PAGED_CODE();

    //
    //  Zero out the buffer, then extract and fill up the non zero fields.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_FS_VOLUME_INFORMATION) );

    Buffer->VolumeSerialNumber = Vcb->Vpb->SerialNumber;

    Buffer->SupportsObjects = FALSE;

    Buffer->VolumeLabelLength = 0;

    *Length -= FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel[0]);

    //
    //  Set our status and return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
RawQueryFsSizeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume size call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return receives the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    PIRP Irp;
    KEVENT Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    PDEVICE_OBJECT RealDevice;

    DISK_GEOMETRY DiskGeometry;
    PARTITION_INFORMATION PartitionInformation;
    GET_LENGTH_INFORMATION GetLengthInformation;

    BOOLEAN DriveIsPartitioned;

    PAGED_CODE();

    //
    //  Make sure the buffer is large enough
    //

    if (*Length < sizeof(FILE_FS_SIZE_INFORMATION)) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlZeroMemory( Buffer, sizeof(FILE_FS_SIZE_INFORMATION) );

    //
    //  Prepare for our device control below.  The device drivers only
    //  have to copy geometry and partition info from in-memory structures,
    //  so it is OK to make these calls even when we can't wait.
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    RealDevice = Vcb->Vpb->RealDevice;

    //
    //  Query the disk geometry
    //

    Irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                         RealDevice,
                                         NULL,
                                         0,
                                         &DiskGeometry,
                                         sizeof(DISK_GEOMETRY),
                                         FALSE,
                                         &Event,
                                         &Iosb );

    if ( Irp == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( (Status = IoCallDriver( RealDevice, Irp )) == STATUS_PENDING ) {

        (VOID) KeWaitForSingleObject( &Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER)NULL );

        Status = Iosb.Status;
    }

    //
    //  If this call didn't succeed, the drive hasn't even been low-level
    //  formatted, and thus geometry information is undefined.
    //

    if (!NT_SUCCESS( Status )) {

        *Length = 0;
        return Status;
    }

    //
    //  See if we have to check the partition information (floppy disks are
    //  the only type that can't have partitions )
    //

    if ( FlagOn( RealDevice->Characteristics, FILE_FLOPPY_DISKETTE )) {

        DriveIsPartitioned = FALSE;
        PartitionInformation.PartitionLength.QuadPart = 0;

    } else {

        //
        //  Query the length info.
        //

        KeResetEvent( &Event );

        Irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_GET_LENGTH_INFO,
                                             RealDevice,
                                             NULL,
                                             0,
                                             &GetLengthInformation,
                                             sizeof(GET_LENGTH_INFORMATION),
                                             FALSE,
                                             &Event,
                                             &Iosb );

        if ( Irp == NULL ) {
           return STATUS_INSUFFICIENT_RESOURCES;
        }

        if ( (Status = IoCallDriver( RealDevice, Irp )) == STATUS_PENDING ) {

            (VOID) KeWaitForSingleObject( &Event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER)NULL );

            Status = Iosb.Status;
        }

        PartitionInformation.PartitionLength = GetLengthInformation.Length;

        if ( !NT_SUCCESS (Status) ) {

            //
            //  Query the partition table
            //

            KeResetEvent( &Event );

            Irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_GET_PARTITION_INFO,
                                                 RealDevice,
                                                 NULL,
                                                 0,
                                                 &PartitionInformation,
                                                 sizeof(PARTITION_INFORMATION),
                                                 FALSE,
                                                 &Event,
                                                 &Iosb );

            if ( Irp == NULL ) {
               return STATUS_INSUFFICIENT_RESOURCES;
            }

            if ( (Status = IoCallDriver( RealDevice, Irp )) == STATUS_PENDING ) {

                (VOID) KeWaitForSingleObject( &Event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER)NULL );

                Status = Iosb.Status;
            }

            //
            //  If we get back invalid device request, the disk is not partitioned
            //

            if ( !NT_SUCCESS (Status) ) {

                DriveIsPartitioned = FALSE;

            } else {

                DriveIsPartitioned = TRUE;
            }

        } else {

            DriveIsPartitioned = TRUE;
        }
    }

    //
    //  Set the output buffer
    //

    Buffer->BytesPerSector = DiskGeometry.BytesPerSector;

    Buffer->SectorsPerAllocationUnit = 1;

    //
    //  Now, based on whether the disk is partitioned, compute the
    //  total number of sectors on this disk.
    //

    Buffer->TotalAllocationUnits =
    Buffer->AvailableAllocationUnits = ( DriveIsPartitioned == TRUE ) ?

        RtlExtendedLargeIntegerDivide( PartitionInformation.PartitionLength,
                                       DiskGeometry.BytesPerSector,
                                       NULL )

                                        :

        RtlExtendedIntegerMultiply( DiskGeometry.Cylinders,
                                    DiskGeometry.TracksPerCylinder *
                                    DiskGeometry.SectorsPerTrack );

    //
    //  Adjust the length variable
    //

    *Length -= sizeof(FILE_FS_SIZE_INFORMATION);

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
RawQueryFsDeviceInfo (
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume device call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return receives the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    PAGED_CODE();

    //
    //  Make sure the buffer is large enough
    //

    if (*Length < sizeof(FILE_FS_DEVICE_INFORMATION)) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlZeroMemory( Buffer, sizeof(FILE_FS_DEVICE_INFORMATION) );

    //
    //  Set the output buffer
    //

    Buffer->DeviceType = FILE_DEVICE_DISK;

    Buffer->Characteristics = Vcb->TargetDeviceObject->Characteristics;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof(FILE_FS_DEVICE_INFORMATION);

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
RawQueryFsAttributeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume attribute call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return receives the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    ULONG LengthUsed;

    UNREFERENCED_PARAMETER( Vcb );

    PAGED_CODE();

    //
    //  Check if the buffer we're given is long enough to contain "Raw"
    //

    LengthUsed = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0]) + 6;

    if (*Length < LengthUsed) {

        return STATUS_BUFFER_OVERFLOW;
    }

    //
    //  Set the output buffer
    //

    Buffer->FileSystemAttributes       = 0;
    Buffer->MaximumComponentNameLength = 0;
    Buffer->FileSystemNameLength       = 6;
    RtlCopyMemory( &Buffer->FileSystemName[0], L"RAW", 6 );

    //
    //  Adjust the length variable
    //

    *Length -= LengthUsed;

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\add2strw.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
//
// You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <stdio.h>
#include <tchar.h>

#define RtlIpv4AddressToStringT RtlIpv4AddressToStringW
#define RtlIpv6AddressToStringT RtlIpv6AddressToStringW
#define RtlIpv4AddressToStringExT RtlIpv4AddressToStringExW
#define RtlIpv6AddressToStringExT RtlIpv6AddressToStringExW

#include "add2strt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\add2strt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    add2strt.h

Abstract:

    Code for IP address-to-string translation routines.

--*/

struct in6_addr {
    union {
        UCHAR Byte[16];
        USHORT Word[8];
    } u;
};
#define s6_bytes   u.Byte
#define s6_words   u.Word

struct in_addr {
        union {
                struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { USHORT s_w1,s_w2; } S_un_w;
                ULONG S_addr;
        } S_un;
};
#define s_addr  S_un.S_addr
#define AF_INET 2
#define AF_INET6 23
#define INET_ADDRSTRLEN  22
#define INET6_ADDRSTRLEN 65

LPTSTR
RtlIpv6AddressToStringT(
    __in const struct in6_addr *Addr,
    __out_ecount(INET6_ADDRSTRLEN) LPTSTR S
    )

/*++

Routine Description:

    Generates an IPv6 string literal corresponding to the address Addr.
    The shortened canonical forms are used (RFC 1884 etc).
    The basic string representation consists of 8 hex numbers
    separated by colons, with a couple embellishments:
    - a string of zero numbers (at most one) is replaced
    with a double-colon.
    - the last 32 bits are represented in IPv4-style dotted-octet notation
    if the address is a v4-compatible or ISATAP address.

    For example,
        ::
        ::1
        ::157.56.138.30
        ::ffff:156.56.136.75
        ff01::
        ff02::2
        0:1:2:3:4:5:6:7

Arguments:

    S - Receives a pointer to the buffer in which to place the
        string literal.

    Addr - Receives the IPv6 address.

Return Value:

    Pointer to the null byte at the end of the string inserted.
    This can be used by the caller to easily append more information.

--*/

{
    int maxFirst, maxLast;
    int curFirst, curLast;
    int i;
    int endHex = 8;

    // Check for IPv6-compatible, IPv4-mapped, and IPv4-translated
    // addresses
    if ((Addr->s6_words[0] == 0) && (Addr->s6_words[1] == 0) &&
        (Addr->s6_words[2] == 0) && (Addr->s6_words[3] == 0) &&
        (Addr->s6_words[6] != 0)) {
        if ((Addr->s6_words[4] == 0) &&
             ((Addr->s6_words[5] == 0) || (Addr->s6_words[5] == 0xffff)))
        {
            // compatible or mapped
            S += _stprintf(S, _T("::%hs%u.%u.%u.%u"),
                           Addr->s6_words[5] == 0 ? "" : "ffff:",
                           Addr->s6_bytes[12], Addr->s6_bytes[13],
                           Addr->s6_bytes[14], Addr->s6_bytes[15]);
            return S;
        }
        else if ((Addr->s6_words[4] == 0xffff) && (Addr->s6_words[5] == 0)) {
            // translated
            S += _stprintf(S, _T("::ffff:0:%u.%u.%u.%u"),
                           Addr->s6_bytes[12], Addr->s6_bytes[13],
                           Addr->s6_bytes[14], Addr->s6_bytes[15]);
            return S;
        }
    }


    // Find largest contiguous substring of zeroes
    // A substring is [First, Last), so it's empty if First == Last.

    maxFirst = maxLast = 0;
    curFirst = curLast = 0;

    // ISATAP EUI64 starts with 00005EFE (or 02005EFE)...
    if (((Addr->s6_words[4] & 0xfffd) == 0) && (Addr->s6_words[5] == 0xfe5e)) {
        endHex = 6;
    }

    for (i = 0; i < endHex; i++) {

        if (Addr->s6_words[i] == 0) {
            // Extend current substring
            curLast = i+1;

            // Check if current is now largest
            if (curLast - curFirst > maxLast - maxFirst) {

                maxFirst = curFirst;
                maxLast = curLast;
            }
        }
        else {
            // Start a new substring
            curFirst = curLast = i+1;
        }
    }

    // Ignore a substring of length 1.
    if (maxLast - maxFirst <= 1)
        maxFirst = maxLast = 0;

        // Write colon-separated words.
        // A double-colon takes the place of the longest string of zeroes.
        // All zeroes is just "::".

    for (i = 0; i < endHex; i++) {

        // Skip over string of zeroes
        if ((maxFirst <= i) && (i < maxLast)) {

            S += _stprintf(S, _T("::"));
            i = maxLast-1;
            continue;
        }

        // Need colon separator if not at beginning
        if ((i != 0) && (i != maxLast))
            S += _stprintf(S, _T(":"));

        S += _stprintf(S, _T("%x"), RtlUshortByteSwap(Addr->s6_words[i]));
    }

    if (endHex < 8) {
        S += _stprintf(S, _T(":%u.%u.%u.%u"),
                       Addr->s6_bytes[12], Addr->s6_bytes[13],
                       Addr->s6_bytes[14], Addr->s6_bytes[15]);
    }

    return S;
}

NTSTATUS
RtlIpv6AddressToStringExT(
    __in const struct in6_addr *Address,
    __in ULONG ScopeId,
    __in USHORT Port,
    __out_ecount_part(*AddressStringLength, *AddressStringLength) LPTSTR AddressString,
    __inout PULONG AddressStringLength
    )

/*++

Routine Description:

    This is the extension routine which handles a full address conversion
    including address, scopeid and port (scopeid and port are optional).

Arguments:

    Address - The address part to be translated.

    ScopeId - The Scope ID of the address (optional).

    Port - The port number of the address (optional). 
           Port is in network byte order.

    AddressString - Pointer to output buffer where we will fill in address string.

    AddressStringLength - For input, it is the length of the input buffer; for 
                          output it is the length we actual returned.
Return Value:

    STATUS_SUCCESS if the operation is successful, error code otherwise.

--*/
{
    TCHAR String[INET6_ADDRSTRLEN];
    LPTSTR S;
    ULONG Length;
    
    if ((Address == NULL) ||
        (AddressString == NULL) ||
        (AddressStringLength == NULL)) {

        return STATUS_INVALID_PARAMETER;
    }
    S = String;
    if (Port) {
        S += _stprintf(S, _T("["));
    }

    //
    // Now translate this address.
    //
    S = RtlIpv6AddressToStringT(Address, S);
    if (ScopeId != 0) {
        S += _stprintf(S, _T("%%%u"), ScopeId);
    }
    if (Port != 0) {
        S += _stprintf(S, _T("]:%u"), RtlUshortByteSwap(Port));
    }
    Length = (ULONG)(S - String + 1);
    if (*AddressStringLength < Length) {
        //
        // Before return, tell the caller how big 
        // the buffer we need.
        //
        *AddressStringLength = Length;
        return STATUS_INVALID_PARAMETER;
    }
    *AddressStringLength = Length;
    RtlCopyMemory(AddressString, String, Length * sizeof(TCHAR));
    return STATUS_SUCCESS;

}
    

LPTSTR
RtlIpv4AddressToStringT(
    __in const struct in_addr *Addr,
    __out_ecount(16) LPTSTR S
    )

/*++

Routine Description:

    Generates an IPv4 string literal corresponding to the address Addr.

Arguments:

    S - Receives a pointer to the buffer in which to place the
        string literal.

    Addr - Receives the IPv4 address.

Return Value:

    Pointer to the null byte at the end of the string inserted.
    This can be used by the caller to easily append more information.

--*/

{
    S += _stprintf(S, _T("%u.%u.%u.%u"),
                  ( Addr->s_addr >>  0 ) & 0xFF,
                  ( Addr->s_addr >>  8 ) & 0xFF,
                  ( Addr->s_addr >> 16 ) & 0xFF,
                  ( Addr->s_addr >> 24 ) & 0xFF );

    return S;
}


NTSTATUS
RtlIpv4AddressToStringExT(
    __in const struct in_addr *Address,
    __in USHORT Port,
    __out_ecount_part(*AddressStringLength, *AddressStringLength) LPTSTR AddressString,
    __inout PULONG AddressStringLength
    )

/*++

Routine Description:

    This is the extension routine which handles a full address conversion
    including address and port (port is optional).
    
Arguments:

    Address - The address part to translate.

    Port - Port number if there is any, otherwise 0. Port is in network 
           byte order. 

    AddressString - Receives the formatted address string.
    
    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    STATUS_SUCCESS if the operation is successful, error code otherwise.

--*/

{

    TCHAR String[INET_ADDRSTRLEN];
    LPTSTR S;
    ULONG Length;

    //
    // Quick sanity checks.
    //
    if ((Address == NULL) ||
        (AddressString == NULL) ||
        (AddressStringLength == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }
    S = String;

    //
    // Now translate this address.
    //
    S = RtlIpv4AddressToStringT(Address, S);
    if (Port != 0) {
        S += _stprintf(S, _T(":%u"), RtlUshortByteSwap(Port));
    }
    Length = (ULONG)(S - String + 1);
    if (*AddressStringLength < Length) {
        //
        // Before return, tell the caller how big
        // the buffer we need. 
        //
        *AddressStringLength = Length;
        return STATUS_INVALID_PARAMETER;
    }
    RtlCopyMemory(AddressString, String, Length * sizeof(TCHAR));
    *AddressStringLength = Length;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\raw\strucsup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    StrucSup.c

Abstract:

    This module implements the Raw in-memory data structure manipulation
    routines

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawInitializeVcb)
#endif


NTSTATUS
RawInitializeVcb (
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb
    )

/*++

Routine Description:

    This routine initializes and inserts a new Vcb record into the in-memory
    data structure.  The Vcb record "hangs" off the end of the Volume device
    object and must be allocated by our caller.

Arguments:

    Vcb - Supplies the address of the Vcb record being initialized.

    TargetDeviceObject - Supplies the address of the target device object to
        associate with the Vcb record.

    Vpb - Supplies the address of the Vpb to associate with the Vcb record.

Return Value:

    NTSTATUS for any errors

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  We start by first zeroing out all of the VCB, this will guarantee
    //  that any stale data is wiped clean
    //

    RtlZeroMemory( Vcb, sizeof(VCB) );

    //
    //  Set the proper node type code and node byte size
    //

    Vcb->NodeTypeCode = RAW_NTC_VCB;
    Vcb->NodeByteSize = sizeof(VCB);

    //
    //  Set the Target Device Object, Vpb, and Vcb State fields
    //

    //
    //  No need to take a extra reference on the Target Device object as
    //  IopMountVolume already has taken a reference.
    //

    Vcb->TargetDeviceObject = TargetDeviceObject;
    Vcb->Vpb = Vpb;

    //
    //  Initialize the Mutex.
    //

    KeInitializeMutex( &Vcb->Mutex, MUTEX_LEVEL_FILESYSTEM_RAW_VCB );

    //
    //  allocate the spare vpb for forced dismount
    //

    Vcb->SpareVpb = ExAllocatePoolWithTag( NonPagedPool, sizeof( VPB ), 'Raw ');
    if (Vcb->SpareVpb == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  and return to our caller
    //

    return Status;
}

BOOLEAN
RawCheckForDismount (
    PVCB Vcb,
    BOOLEAN CalledFromCreate
    )

/*++

Routine Description:

    This routine determines if a volume is ready for deletion.  It
    correctly synchronizes with creates en-route to the file system.
    On exit if the vcb is deleted the mutex is released
    
Arguments:

    Vcb - Supplies the value to examine

    CalledFromCreate - Tells us if we should allow 0 or 1 in VpbRefCount

Return Value:

    BOOLEAN - TRUE if the volume was deleted, FALSE otherwise.

--*/

{

    KIRQL SavedIrql;
    ULONG ReferenceCount = 0;
    BOOLEAN DeleteVolume = FALSE;

    //
    //  We must enter with the vcb mutex acquired
    //  

    ASSERT( KeReadStateMutant( &Vcb->Mutex ) == 0 );

    IoAcquireVpbSpinLock( &SavedIrql );

    ReferenceCount = Vcb->Vpb->ReferenceCount;

    {
        PVPB Vpb;

        Vpb = Vcb->Vpb;

        //
        //  If a create is in progress on this volume, don't
        //  delete it.
        //

        if ( ReferenceCount != (ULONG)(CalledFromCreate ? 1 : 0) ) {

            //
            //  Cleanup the vpb on a forced dismount even if we can't delete the vcb if
            //  we haven't already done so
            //   

            if ((Vcb->SpareVpb != NULL) && 
                FlagOn( Vcb->VcbState,  VCB_STATE_FLAG_DISMOUNTED )) {

                //
                //  Setup the spare vpb and put it on the real device
                //  

                RtlZeroMemory( Vcb->SpareVpb, sizeof( VPB ) );

                Vcb->SpareVpb->Type = IO_TYPE_VPB;
                Vcb->SpareVpb->Size = sizeof( VPB );
                Vcb->SpareVpb->RealDevice = Vcb->Vpb->RealDevice;
                Vcb->SpareVpb->DeviceObject = NULL;
                Vcb->SpareVpb->Flags = FlagOn( Vcb->Vpb->Flags, VPB_REMOVE_PENDING );

                Vcb->Vpb->RealDevice->Vpb = Vcb->SpareVpb;

                //
                //  The spare vpb now belongs to the iosubsys and we own the original one
                //  

                Vcb->SpareVpb = NULL;
                Vcb->Vpb->Flags |=  VPB_PERSISTENT;

            }

            DeleteVolume = FALSE;

        } else {

            DeleteVolume = TRUE;

            if ( Vpb->RealDevice->Vpb == Vpb ) {

                Vpb->DeviceObject = NULL;

                Vpb->Flags &= ~VPB_MOUNTED;
            }
        }
    }
    IoReleaseVpbSpinLock( SavedIrql );

    if (DeleteVolume) {

        (VOID)KeReleaseMutex( &Vcb->Mutex, FALSE );

        //
        //  Free the spare vpb if we didn't use it or the original one if 
        //  we did use it and there are no more reference counts. Otherwise i/o
        //  subsystem still has a ref and will free the vpb itself
        // 

        if (Vcb->SpareVpb) {
            ExFreePool( Vcb->SpareVpb );
        } else if (ReferenceCount == 0) {
            ExFreePool( Vcb->Vpb );
        }
        
        ObDereferenceObject( Vcb->TargetDeviceObject );
        IoDeleteDevice( (PDEVICE_OBJECT)CONTAINING_RECORD( Vcb,
                                                           VOLUME_DEVICE_OBJECT,
                                                           Vcb));
    }
    
    return DeleteVolume;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\assert.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    assert.c

Abstract:

    This module implements the RtlAssert function that is referenced by the
    debugging version of the ASSERT macro defined in NTDEF.H

--*/

#include <nt.h>
#include <ntrtl.h>
#include <zwapi.h>

//
// RtlAssert is not called unless the caller is compiled with DBG non-zero
// therefore it does no harm to always have this routine in the kernel.
// This allows checked drivers to be thrown on the system and have their
// asserts be meaningful.
//

#define RTL_ASSERT_ALWAYS_ENABLED 1

#ifdef _X86_
#pragma optimize("y", off)      // RtlCaptureContext needs EBP to be correct
#endif

#undef RtlAssert

typedef CONST CHAR * PCSTR;

#if defined(_M_AMD64)

DECLSPEC_NOINLINE

#endif

NTSYSAPI
VOID
NTAPI
RtlAssert(
    __in PVOID VoidFailedAssertion,
    __in PVOID VoidFileName,
    __in ULONG LineNumber,
    __in_opt PSTR MutableMessage
    )
{
#if DBG || RTL_ASSERT_ALWAYS_ENABLED
    char Response[ 2 ];

    CONST PCSTR FailedAssertion = (PCSTR)VoidFailedAssertion;
    CONST PCSTR FileName = (PCSTR)VoidFileName;
    CONST PCSTR Message  = (PCSTR)MutableMessage;

    CONTEXT Context;

    RtlCaptureContext( &Context );

    while (TRUE) {
        DbgPrint( "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );
        DbgPrompt( "Break repeatedly, break Once, Ignore, terminate Process, or terminate Thread (boipt)? ",
                   Response,
                   sizeof( Response )
                 );
        switch (Response[0]) {
            case 'B':
            case 'b':
            case 'O':
            case 'o':
                DbgPrint( "Execute '.cxr %p' to dump context\n", &Context);
                DbgBreakPoint();
                if (Response[0] == 'o' || Response[0] == 'O')
                    return;
                break;

            case 'I':
            case 'i':
                return;

            case 'P':
            case 'p':
                ZwTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
                break;

            case 'T':
            case 't':
                ZwTerminateThread( NtCurrentThread(), STATUS_UNSUCCESSFUL );
                break;
            }
        }

    DbgBreakPoint();
    ZwTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
#endif
}

#ifdef _X86_
#pragma optimize("", on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\atom.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    atom.c

Abstract:

    This file contains the common code to implement atom tables.  It is called
    by both the user mode Win32 Atom API functions (Local/GlobalxxxAtom) and
    by the kernel mode window manager code to access global atoms.

--*/

#include "ntrtlp.h"
#include "atom.h"

#if defined(ALLOC_PRAGMA)
PVOID
RtlpAllocateAtom(
    IN ULONG NumberOfBytes,
    IN ULONG Tag
    );
void
RtlpFreeAtom(
    IN PVOID p
    );
void
RtlpInitializeLockAtomTable(
    IN OUT PRTL_ATOM_TABLE AtomTable
    );
BOOLEAN
RtlpLockAtomTable(
    IN PRTL_ATOM_TABLE AtomTable
    );
void
RtlpUnlockAtomTable(
    IN PRTL_ATOM_TABLE AtomTable
    );
void
RtlpDestroyLockAtomTable(
    IN OUT PRTL_ATOM_TABLE AtomTable
    );
BOOLEAN
RtlpInitializeHandleTableForAtomTable(
    PRTL_ATOM_TABLE AtomTable
    );
void
RtlpDestroyHandleTableForAtomTable(
    PRTL_ATOM_TABLE AtomTable
    );
PRTL_ATOM_TABLE_ENTRY
RtlpAtomMapAtomToHandleEntry(
    IN PRTL_ATOM_TABLE AtomTable,
    IN ULONG HandleIndex
    );
BOOLEAN
RtlpCreateHandleForAtom(
    PRTL_ATOM_TABLE p,
    PRTL_ATOM_TABLE_ENTRY a
    );
void
RtlpFreeHandleForAtom(
    PRTL_ATOM_TABLE p,
    PRTL_ATOM_TABLE_ENTRY a
    );
BOOLEAN
RtlpGetIntegerAtom(
    PWSTR Name,
    PRTL_ATOM Atom OPTIONAL
    );
PRTL_ATOM_TABLE_ENTRY
RtlpHashStringToAtom(
    IN PRTL_ATOM_TABLE p,
    IN PWSTR Name,
    OUT PRTL_ATOM_TABLE_ENTRY **PreviousAtom OPTIONAL,
    OUT PULONG NameLength
    );
#pragma alloc_text(PAGE,RtlpAllocateAtom)
#pragma alloc_text(PAGE,RtlpFreeAtom)
#pragma alloc_text(PAGE,RtlpInitializeLockAtomTable)
#pragma alloc_text(PAGE,RtlInitializeAtomPackage)
#pragma alloc_text(PAGE,RtlpLockAtomTable)
#pragma alloc_text(PAGE,RtlpUnlockAtomTable)
#pragma alloc_text(PAGE,RtlpDestroyLockAtomTable)
#pragma alloc_text(PAGE,RtlpInitializeHandleTableForAtomTable)
#pragma alloc_text(PAGE,RtlpDestroyHandleTableForAtomTable)
#pragma alloc_text(PAGE,RtlpAtomMapAtomToHandleEntry)
#pragma alloc_text(PAGE,RtlpCreateHandleForAtom)
#pragma alloc_text(PAGE,RtlpFreeHandleForAtom)
#pragma alloc_text(PAGE,RtlInitializeAtomPackage)
#pragma alloc_text(PAGE,RtlCreateAtomTable)
#pragma alloc_text(PAGE,RtlDestroyAtomTable)
#pragma alloc_text(PAGE,RtlEmptyAtomTable)
#pragma alloc_text(PAGE,RtlpGetIntegerAtom)
#pragma alloc_text(PAGE,RtlpHashStringToAtom)
#pragma alloc_text(PAGE,RtlAddAtomToAtomTable)
#pragma alloc_text(PAGE,RtlLookupAtomInAtomTable)
#pragma alloc_text(PAGE,RtlDeleteAtomFromAtomTable)
#pragma alloc_text(PAGE,RtlPinAtomInAtomTable)
#pragma alloc_text(PAGE,RtlQueryAtomInAtomTable)
#pragma alloc_text(PAGE,RtlQueryAtomsInAtomTable)
#endif

#if defined(ALLOC_DATA_PRAGMA)
#pragma data_seg("PAGEDATA")
#endif

ULONG RtlpAtomAllocateTag;

typedef struct _RTLP_ATOM_QUOTA {
    PEPROCESS_QUOTA_BLOCK QuotaBlock;
    SIZE_T PagedAmount;
} RTLP_ATOM_QUOTA, *PRTLP_ATOM_QUOTA;

PVOID
RtlpAllocateAtom(
    IN ULONG NumberOfBytes,
    IN ULONG Tag
    )
{
    PRTLP_ATOM_QUOTA AllocatedBlock;

    NumberOfBytes += sizeof(RTLP_ATOM_QUOTA);

    AllocatedBlock = ExAllocatePoolWithTag( PagedPool,
                                            NumberOfBytes,
                                            Tag );
    if (AllocatedBlock) {
        AllocatedBlock->QuotaBlock
            = PsChargeSharedPoolQuota( PsGetCurrentProcess(),
                                       NumberOfBytes,
                                       0 );
        if (! AllocatedBlock->QuotaBlock) {
            ExFreePoolWithTag( AllocatedBlock, Tag );
            AllocatedBlock = NULL;
        } else {
            AllocatedBlock->PagedAmount = NumberOfBytes;
            AllocatedBlock++;
        }
    }

    return AllocatedBlock;
}


void
RtlpFreeAtom(
    IN PVOID p
    )
{
    PRTLP_ATOM_QUOTA AllocatedBlock = (PRTLP_ATOM_QUOTA) p;

    ASSERT( AllocatedBlock );
    AllocatedBlock--;
    ASSERT( AllocatedBlock );
    ASSERT( AllocatedBlock->QuotaBlock );
    ASSERT( AllocatedBlock->PagedAmount );
    PsReturnSharedPoolQuota( AllocatedBlock->QuotaBlock,
                             AllocatedBlock->PagedAmount,
                             0 );
    
    ExFreePool( AllocatedBlock );
    return;
}


void
RtlpInitializeLockAtomTable(
    IN OUT PRTL_ATOM_TABLE AtomTable
    )
{
    ExInitializePushLock( &AtomTable->PushLock );
    return;
}

BOOLEAN
RtlpLockAtomTable(
    IN PRTL_ATOM_TABLE AtomTable
    )
{
    if (AtomTable == NULL || AtomTable->Signature != RTL_ATOM_TABLE_SIGNATURE) {
        return FALSE;
        }

    KeEnterCriticalRegion ();
    ExAcquirePushLockExclusive( &AtomTable->PushLock );

    return TRUE;
}

void
RtlpUnlockAtomTable(
    IN PRTL_ATOM_TABLE AtomTable
    )
{
    ExReleasePushLockExclusive( &AtomTable->PushLock );
    KeLeaveCriticalRegion ();
}


void
RtlpDestroyLockAtomTable(
    IN OUT PRTL_ATOM_TABLE AtomTable
    )
{
}


BOOLEAN
RtlpInitializeHandleTableForAtomTable(
    PRTL_ATOM_TABLE AtomTable
    )
{
    AtomTable->ExHandleTable = ExCreateHandleTable( NULL );
    if (AtomTable->ExHandleTable != NULL) {
        //
        // Make sure atom handle tables are NOT part of object handle enumeration
        //

        ExRemoveHandleTable( AtomTable->ExHandleTable );
        return TRUE;
        }
    else {
        return FALSE;
        }
}

void
RtlpDestroyHandleTableForAtomTable(
    PRTL_ATOM_TABLE AtomTable
    )
{
    ExDestroyHandleTable( AtomTable->ExHandleTable, NULL );
    return;
}

PRTL_ATOM_TABLE_ENTRY
RtlpAtomMapAtomToHandleEntry(
    IN PRTL_ATOM_TABLE AtomTable,
    IN ULONG HandleIndex
    )
{
    PHANDLE_TABLE_ENTRY ExHandleEntry;
    PRTL_ATOM_TABLE_ENTRY a;
    EXHANDLE ExHandle;

    ExHandle.GenericHandleOverlay = 0;
    ExHandle.Index = HandleIndex;

    ExHandleEntry = ExMapHandleToPointer( AtomTable->ExHandleTable,
                                          ExHandle.GenericHandleOverlay
                                        );
    if (ExHandleEntry != NULL) {
        a = ExHandleEntry->Object;
        ExUnlockHandleTableEntry( AtomTable->ExHandleTable, ExHandleEntry );
        return a;
        }
    return NULL;
}

BOOLEAN
RtlpCreateHandleForAtom(
    PRTL_ATOM_TABLE p,
    PRTL_ATOM_TABLE_ENTRY a
    )
{
    EXHANDLE ExHandle;
    HANDLE_TABLE_ENTRY ExHandleEntry;

    ExHandleEntry.Object = a;
    ExHandleEntry.GrantedAccess = 0;
    ExHandle.GenericHandleOverlay = ExCreateHandle( p->ExHandleTable, &ExHandleEntry );
    if (ExHandle.GenericHandleOverlay != NULL) {
        a->HandleIndex = (USHORT)ExHandle.Index;
        a->Atom = (RTL_ATOM)((USHORT)a->HandleIndex | RTL_ATOM_MAXIMUM_INTEGER_ATOM);
        return TRUE;
        }
    return FALSE;
}

void
RtlpFreeHandleForAtom(
    PRTL_ATOM_TABLE p,
    PRTL_ATOM_TABLE_ENTRY a
    )
{
    EXHANDLE ExHandle;

    ExHandle.GenericHandleOverlay = 0;
    ExHandle.Index = a->HandleIndex;
    ExDestroyHandle( p->ExHandleTable, ExHandle.GenericHandleOverlay, NULL );
    return;
}

NTSTATUS
RtlInitializeAtomPackage(
    IN ULONG AllocationTag
    )
{
    RTL_PAGED_CODE();
    RtlpAtomAllocateTag = AllocationTag;
    return STATUS_SUCCESS;
}

NTSTATUS
RtlCreateAtomTable(
    IN ULONG NumberOfBuckets,
    OUT PVOID *AtomTableHandle
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p;
    ULONG Size;

    RTL_PAGED_CODE();
    Status = STATUS_SUCCESS;
    if (*AtomTableHandle == NULL) {
        if (NumberOfBuckets <= 1) {
            NumberOfBuckets = RTL_ATOM_TABLE_DEFAULT_NUMBER_OF_BUCKETS;
            }

        Size = sizeof( RTL_ATOM_TABLE ) +
               (sizeof( RTL_ATOM_TABLE_ENTRY ) * (NumberOfBuckets-1));

        p = (PRTL_ATOM_TABLE)RtlpAllocateAtom( Size, 'TmtA' );
        if (p == NULL) {
            Status = STATUS_NO_MEMORY;
            }
        else {
            RtlZeroMemory( p, Size );
            p->NumberOfBuckets = NumberOfBuckets;
            if (RtlpInitializeHandleTableForAtomTable( p )) {
                RtlpInitializeLockAtomTable( p );
                p->Signature = RTL_ATOM_TABLE_SIGNATURE;
                *AtomTableHandle = p;
                }
            else {
                Status = STATUS_NO_MEMORY;
                RtlpFreeAtom( p );
                }
            }
        }

    return Status;
}


NTSTATUS
RtlDestroyAtomTable(
    IN PVOID AtomTableHandle
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a, aNext, *pa;
    ULONG i;

    RTL_PAGED_CODE();
    Status = STATUS_SUCCESS;
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        pa = &p->Buckets[ 0 ];
        for (i=0; i<p->NumberOfBuckets; i++) {
            aNext = *pa;
            *pa++ = NULL;
            while ((a = aNext) != NULL) {
                aNext = a->HashLink;
                a->HashLink = NULL;
                RtlpFreeAtom( a );
                }
            }
        p->Signature = 0;
        RtlpUnlockAtomTable( p );

        RtlpDestroyHandleTableForAtomTable( p );
        RtlpDestroyLockAtomTable( p );
        RtlZeroMemory( p, sizeof( RTL_ATOM_TABLE ) );
        RtlpFreeAtom( p );
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    return Status;
}

NTSTATUS
RtlEmptyAtomTable(
    IN PVOID AtomTableHandle,
    IN BOOLEAN IncludePinnedAtoms
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a, aNext, *pa, *pa1;
    ULONG i;

    RTL_PAGED_CODE();
    Status = STATUS_SUCCESS;
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        pa = &p->Buckets[ 0 ];
        for (i=0; i<p->NumberOfBuckets; i++) {
            pa1 = pa++;
            while ((a = *pa1) != NULL) {
                if (IncludePinnedAtoms || !(a->Flags & RTL_ATOM_PINNED)) {
                    *pa1 = a->HashLink;
                    a->HashLink = NULL;
                    RtlpFreeHandleForAtom( p, a );
                    RtlpFreeAtom( a );
                    }
                else {
                    pa1 = &a->HashLink;
                    }
                }
            }

        RtlpUnlockAtomTable( p );
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    return Status;
}

BOOLEAN
RtlpGetIntegerAtom(
    PWSTR Name,
    PRTL_ATOM Atom OPTIONAL
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PWSTR s;
    ULONG n;
    RTL_ATOM Temp;

    if (((ULONG_PTR)Name & -0x10000) == 0) {
        Temp = (RTL_ATOM)(USHORT)PtrToUlong(Name);
        if (Temp >= RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
            return FALSE;
            }
        else {
            if (Temp == RTL_ATOM_INVALID_ATOM) {
                Temp = RTL_ATOM_MAXIMUM_INTEGER_ATOM;
                }

            if (ARGUMENT_PRESENT( Atom )) {
                *Atom = Temp;
                }

            return TRUE;
            }
        }
    else
    if (*Name != L'#') {
        return FALSE;
        }

    s = ++Name;
    while (*s != UNICODE_NULL) {
        if (*s < L'0' || *s > L'9') {
            return FALSE;
            }
        else {
            s++;
            }
        }

    n = 0;
    UnicodeString.Buffer = Name;
    UnicodeString.Length = (USHORT)((PCHAR)s - (PCHAR)Name);
    UnicodeString.MaximumLength = UnicodeString.Length;
    Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &n );
    if (NT_SUCCESS( Status )) {
        if (ARGUMENT_PRESENT( Atom )) {
            if (n == 0 || n > RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
                *Atom = RTL_ATOM_MAXIMUM_INTEGER_ATOM;
                }
            else {
                *Atom = (RTL_ATOM)n;
                }
            }

        return TRUE;
        }
    else {
        return FALSE;
        }
}

PRTL_ATOM_TABLE_ENTRY
RtlpHashStringToAtom(
    IN PRTL_ATOM_TABLE p,
    IN PWSTR Name,
    OUT PRTL_ATOM_TABLE_ENTRY **PreviousAtom OPTIONAL,
    OUT PULONG NameLength
    )
{
    ULONG Length, Hash;
    WCHAR c;
    PWCH s;
    RTL_ATOM Atom;
    PRTL_ATOM_TABLE_ENTRY *pa, a;

    if (((ULONG_PTR)Name & -0x10000) == 0) {
        Atom = (RTL_ATOM)(USHORT)PtrToUlong(Name);
        a = NULL;
        if (Atom >= RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
            a = RtlpAtomMapAtomToHandleEntry( p,
                                              (ULONG)(Atom & (USHORT)~RTL_ATOM_MAXIMUM_INTEGER_ATOM)
                                            );
            }

        if (ARGUMENT_PRESENT( PreviousAtom )) {
            *PreviousAtom = NULL;
            }

        return a;
        }

    s = Name;
    Hash = 0;
    while (*s != UNICODE_NULL) {
        c = *s++;
        if (c < 'a') {
            NOTHING;

        } else if (c > 'z') {
            c = RtlUpcaseUnicodeChar(c);

        } else {
            c -= ('a' - 'A');
        }

        Hash = Hash + (c << 1) + (c >> 1) + c;
    }

    Length = (ULONG) (s - Name);
    if (Length > RTL_ATOM_MAXIMUM_NAME_LENGTH) {
        pa = NULL;
        a = NULL;
        }
    else {
        pa = &p->Buckets[ Hash % p->NumberOfBuckets ];
        while (a = *pa) {
            if (a->NameLength == Length && !_wcsicmp( a->Name, Name )) {
                break;
                }
            else {
                pa = &a->HashLink;
                }
            }
        }

    if (ARGUMENT_PRESENT( PreviousAtom )) {
        *PreviousAtom = pa;
        }

    if (a == NULL && ARGUMENT_PRESENT( NameLength )) {
        *NameLength = Length * sizeof( WCHAR );
        }

    return a;
}


NTSTATUS
RtlAddAtomToAtomTable(
    __in PVOID AtomTableHandle,
    __in PWSTR AtomName,
    __inout_opt PRTL_ATOM Atom
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a, *pa;
    ULONG NameLength;
    RTL_ATOM Temp;

    RTL_PAGED_CODE();
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        if (RtlpGetIntegerAtom( AtomName, &Temp )) {
            if (Temp >= RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
                Temp = RTL_ATOM_INVALID_ATOM;
                Status = STATUS_INVALID_PARAMETER;
                }
            else {
                Status = STATUS_SUCCESS;
                }

            if (ARGUMENT_PRESENT( Atom )) {
                *Atom = Temp;
                }
            }
        else
        if (*AtomName == UNICODE_NULL) {
            Status = STATUS_OBJECT_NAME_INVALID;
            }
        else {
            a = RtlpHashStringToAtom( p, AtomName, &pa, &NameLength );
            if (a == NULL) {
                if (pa != NULL) {
                    Status = STATUS_NO_MEMORY;
                    a = RtlpAllocateAtom( FIELD_OFFSET( RTL_ATOM_TABLE_ENTRY, Name ) +
                                          NameLength + sizeof( UNICODE_NULL ),
                                          'AmtA'
                                        );
                    if (a != NULL) {
                        a->HashLink = NULL;
                        a->ReferenceCount = 1;
                        a->Flags = 0;
                        RtlCopyMemory( a->Name, AtomName, NameLength );
                        a->NameLength = (UCHAR)(NameLength / sizeof( WCHAR ));
                        a->Name[ a->NameLength ] = UNICODE_NULL;
                        if (RtlpCreateHandleForAtom( p, a )) {
                            a->Atom = (RTL_ATOM)a->HandleIndex | RTL_ATOM_MAXIMUM_INTEGER_ATOM;
                            *pa = a;
                            if (ARGUMENT_PRESENT( Atom )) {
                                *Atom = a->Atom;
                                }

                            Status = STATUS_SUCCESS;
                            }
                        else {
                            RtlpFreeAtom( a );
                            }
                        }
                    }
                else {
                    Status = STATUS_INVALID_PARAMETER;
                    }
                }
            else {
                if (!(a->Flags & RTL_ATOM_PINNED)) {
                    if (a->ReferenceCount == 0xFFFF) {
                        KdPrint(( "RTL: Pinning atom (%x) as reference count about to wrap\n", Atom ));
                        a->Flags |= RTL_ATOM_PINNED;
                        }
                    else {
                        a->ReferenceCount += 1;
                        }
                    }

                if (ARGUMENT_PRESENT( Atom )) {
                    *Atom = a->Atom;
                    }

                Status = STATUS_SUCCESS;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    RtlpUnlockAtomTable( p );

    return Status;
}

NTSTATUS
RtlLookupAtomInAtomTable(
    __in PVOID AtomTableHandle,
    __in PWSTR AtomName,
    __out_opt PRTL_ATOM Atom
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a;
    RTL_ATOM Temp;

    RTL_PAGED_CODE();
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        if (RtlpGetIntegerAtom( AtomName, &Temp )) {
            if (Temp >= RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
                Temp = RTL_ATOM_INVALID_ATOM;
                Status = STATUS_INVALID_PARAMETER;
                }
            else {
                Status = STATUS_SUCCESS;
                }

            if (ARGUMENT_PRESENT( Atom )) {
                *Atom = Temp;
                }
            }
        else
        if (*AtomName == UNICODE_NULL) {
            Status = STATUS_OBJECT_NAME_INVALID;
            }
        else {
            a = RtlpHashStringToAtom( p, AtomName, NULL, NULL );
            if (a == NULL) {
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                }
            else {
                if (RtlpAtomMapAtomToHandleEntry( p, (ULONG)a->HandleIndex ) != NULL) {
                    Status = STATUS_SUCCESS;
                    if (ARGUMENT_PRESENT( Atom )) {
                        *Atom = a->Atom;
                        }
                    }
                else {
                    Status = STATUS_INVALID_HANDLE;
                    }
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    RtlpUnlockAtomTable( p );

    return Status;
}


NTSTATUS
RtlDeleteAtomFromAtomTable(
    IN PVOID AtomTableHandle,
    IN RTL_ATOM Atom
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a, *pa;

    RTL_PAGED_CODE();
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        Status = STATUS_INVALID_HANDLE;
        if (Atom >= RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
            a = RtlpAtomMapAtomToHandleEntry( p,
                                              (ULONG)(Atom & (USHORT)~RTL_ATOM_MAXIMUM_INTEGER_ATOM)
                                            );
            if (a != NULL && a->Atom == Atom) {
                Status = STATUS_SUCCESS;
                if (a->Flags & RTL_ATOM_PINNED) {
                    KdPrint(( "RTL: Ignoring attempt to delete a pinned atom (%x)\n", Atom ));
                    Status = STATUS_WAS_LOCKED;        // This is a success status code!
                    }
                else
                if (--a->ReferenceCount == 0) {
                    a = RtlpHashStringToAtom( p, a->Name, &pa, NULL );
                    if (a != NULL) {
                        if (pa != NULL) {
                            *pa = a->HashLink;
                        }
                        RtlpFreeHandleForAtom( p, a );
                        RtlpFreeAtom( a );
                        }
                    }
                }
            }
        else
        if (Atom != RTL_ATOM_INVALID_ATOM) {
            Status = STATUS_SUCCESS;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    RtlpUnlockAtomTable( p );

    return Status;
}

NTSTATUS
RtlPinAtomInAtomTable(
    IN PVOID AtomTableHandle,
    IN RTL_ATOM Atom
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a, *pa;

    RTL_PAGED_CODE();
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        Status = STATUS_INVALID_HANDLE;
        if (Atom >= RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
            a = RtlpAtomMapAtomToHandleEntry( p,
                                              (ULONG)(Atom & (USHORT)~RTL_ATOM_MAXIMUM_INTEGER_ATOM)
                                            );
            if (a != NULL && a->Atom == Atom) {
                Status = STATUS_SUCCESS;
                a->Flags |= RTL_ATOM_PINNED;
                }
            }
        else
        if (Atom != RTL_ATOM_INVALID_ATOM) {
            Status = STATUS_SUCCESS;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    RtlpUnlockAtomTable( p );

    return Status;
}

NTSTATUS
RtlQueryAtomInAtomTable(
    __in PVOID AtomTableHandle,
    __in RTL_ATOM Atom,
    __out_opt PULONG AtomUsage,
    __out_opt PULONG AtomFlags,
    __inout_bcount_part_opt(*AtomNameLength, *AtomNameLength) PWSTR AtomName,
    __inout_opt PULONG AtomNameLength
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a;
    WCHAR AtomNameBuffer[ 16 ];
    ULONG CopyLength;

    RTL_PAGED_CODE();
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        if (Atom < RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
            if (Atom == RTL_ATOM_INVALID_ATOM) {
                Status = STATUS_INVALID_PARAMETER;
                }
            else {
                Status = STATUS_SUCCESS;
                if (ARGUMENT_PRESENT( AtomUsage )) {
                    *AtomUsage = 1;
                    }

                if (ARGUMENT_PRESENT( AtomFlags )) {
                    *AtomFlags = RTL_ATOM_PINNED;
                    }

                if (ARGUMENT_PRESENT( AtomName )) {
                    CopyLength = _snwprintf( AtomNameBuffer,
                                             sizeof( AtomNameBuffer ) / sizeof( WCHAR ),
                                             L"#%u",
                                             Atom
                                           ) * sizeof( WCHAR );
                    if (CopyLength >= *AtomNameLength) {
                        if (*AtomNameLength >= sizeof( UNICODE_NULL )) {
                            CopyLength = *AtomNameLength - sizeof( UNICODE_NULL );
                            }
                        else {
                            CopyLength = 0;
                            }
                        }

                    if (CopyLength != 0) {
                        RtlCopyMemory( AtomName, AtomNameBuffer, CopyLength );
                        AtomName[ CopyLength / sizeof( WCHAR ) ] = UNICODE_NULL;
                        *AtomNameLength = CopyLength;
                        }
                    else {
                        Status = STATUS_BUFFER_TOO_SMALL;
                        }
                    }
                }
            }
        else {
            a = RtlpAtomMapAtomToHandleEntry( p,
                                              (ULONG)(Atom & (USHORT)~RTL_ATOM_MAXIMUM_INTEGER_ATOM)
                                            );
            if (a != NULL && a->Atom == Atom) {
                Status = STATUS_SUCCESS;
                if (ARGUMENT_PRESENT( AtomUsage )) {
                    *AtomUsage = a->ReferenceCount;
                    }

                if (ARGUMENT_PRESENT( AtomFlags )) {
                    *AtomFlags = a->Flags;
                    }

                if (ARGUMENT_PRESENT( AtomName )) {
                    //
                    // Fill in as much of the atom string as possible, and
                    // always zero terminate. This is what win3.1 does.
                    //

                    CopyLength = a->NameLength * sizeof( WCHAR );
                    if (CopyLength >= *AtomNameLength) {
                        if (*AtomNameLength >= sizeof( UNICODE_NULL )) {
                            CopyLength = *AtomNameLength - sizeof( UNICODE_NULL );
                            }
                        else {
                            *AtomNameLength = CopyLength;
                            CopyLength = 0;
                            }
                        }
                    if (CopyLength != 0) {
                        RtlCopyMemory( AtomName, a->Name, CopyLength );
                        AtomName[ CopyLength / sizeof( WCHAR ) ] = UNICODE_NULL;
                        *AtomNameLength = CopyLength;
                        }
                    else {
                        Status = STATUS_BUFFER_TOO_SMALL;
                        }
                    }
                }
            else {
                Status = STATUS_INVALID_HANDLE;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    RtlpUnlockAtomTable( p );

    return Status;
}

NTSTATUS
RtlQueryAtomsInAtomTable(
    IN PVOID AtomTableHandle,
    IN ULONG MaximumNumberOfAtoms,
    OUT PULONG NumberOfAtoms,
    OUT PRTL_ATOM Atoms
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a;
    ULONG i;
    ULONG CurrentAtomIndex;

    RTL_PAGED_CODE();
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }

    Status = STATUS_SUCCESS;
    try {
        CurrentAtomIndex = 0;
        for (i=0; i<p->NumberOfBuckets; i++) {
            a = p->Buckets[ i ];
            while (a) {
                if (CurrentAtomIndex < MaximumNumberOfAtoms) {
                    Atoms[ CurrentAtomIndex ] = a->Atom;
                    }
                else {
                    Status = STATUS_INFO_LENGTH_MISMATCH;
                    }

                CurrentAtomIndex += 1;
                a = a->HashLink;
                }
            }

        *NumberOfAtoms = CurrentAtomIndex;
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    RtlpUnlockAtomTable( p );

    return Status;
}

#if defined(ALLOC_DATA_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\acledit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Acledit.c

Abstract:

    This Module implements the Acl rtl editing functions that are defined in
    ntseapi.h

--*/

#include <ntrtlp.h>
#include <seopaque.h>

//
//  Define the local macros and procedure for this module
//

//
//  Return a pointer to the first Ace in an Acl (even if the Acl is empty).
//
//      PACE_HEADER
//      FirstAce (
//          IN PACL Acl
//          );
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))

//
//  Return a pointer to the next Ace in a sequence (even if the input
//  Ace is the one in the sequence).
//
//      PACE_HEADER
//      NextAce (
//          IN PACE_HEADER Ace
//          );
//

#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

#define LongAligned( ptr )  (LongAlign(ptr) == ((PVOID)(ptr)))
#define WordAligned( ptr )  (WordAlign(ptr) == ((PVOID)(ptr)))


    VOID
RtlpAddData (
    IN PVOID From,
    IN ULONG FromSize,
    IN PVOID To,
    IN ULONG ToSize
    );

VOID
RtlpDeleteData (
    IN PVOID Data,
    IN ULONG RemoveSize,
    IN ULONG TotalSize
    );

#if defined(ALLOC_PRAGMA)
NTSTATUS
RtlpAddKnownAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid,
    IN UCHAR NewType
    );
NTSTATUS
RtlpAddKnownObjectAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN GUID *ObjectTypeGuid OPTIONAL,
    IN GUID *InheritedObjectTypeGuid OPTIONAL,
    IN PSID Sid,
    IN UCHAR NewType
    );
#pragma alloc_text(PAGE,RtlCreateAcl)
#pragma alloc_text(PAGE,RtlValidAcl)
#pragma alloc_text(PAGE,RtlQueryInformationAcl)
#pragma alloc_text(PAGE,RtlSetInformationAcl)
#pragma alloc_text(PAGE,RtlAddAce)
#pragma alloc_text(PAGE,RtlDeleteAce)
#pragma alloc_text(PAGE,RtlGetAce)
#pragma alloc_text(PAGE,RtlAddCompoundAce)
#pragma alloc_text(PAGE,RtlpAddKnownAce)
#pragma alloc_text(PAGE,RtlpAddKnownObjectAce)
#pragma alloc_text(PAGE,RtlAddAccessAllowedAce)
#pragma alloc_text(PAGE,RtlAddAccessAllowedAceEx)
#pragma alloc_text(PAGE,RtlAddAccessDeniedAce)
#pragma alloc_text(PAGE,RtlAddAccessDeniedAceEx)
#pragma alloc_text(PAGE,RtlAddAuditAccessAce)
#pragma alloc_text(PAGE,RtlAddAuditAccessAceEx)
#pragma alloc_text(PAGE,RtlAddAccessAllowedObjectAce)
#pragma alloc_text(PAGE,RtlAddAccessDeniedObjectAce)
#pragma alloc_text(PAGE,RtlAddAuditAccessObjectAce)
#pragma alloc_text(PAGE,RtlFirstFreeAce)
#pragma alloc_text(PAGE,RtlpAddData)
#pragma alloc_text(PAGE,RtlpDeleteData)
#endif


NTSTATUS
RtlCreateAcl (
    IN PACL Acl,
    IN ULONG AclLength,
    IN ULONG AclRevision
    )

/*++

Routine Description:

    This routine initializes an ACL data structure.  After initialization
    it is an ACL with no ACE (i.e., a deny all access type ACL)

Arguments:

    Acl - Supplies the buffer containing the ACL being initialized

    AclLength - Supplies the length of the ace buffer in bytes

    AclRevision - Supplies the revision for this Acl

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful

               STATUS_BUFFER_TOO_SMALL if the AclLength is too small,

               STATUS_INVALID_PARAMETER if the revision is out of range

--*/

{
    RTL_PAGED_CODE();

    //
    //  Check to see the size of the buffer is large enough to hold at
    //  least the ACL header
    //

    if (AclLength < sizeof(ACL)) {

        //
        //  Buffer to small even for the ACL header
        //

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    //  Check to see if the revision is currently valid.  Later versions
    //  of this procedure might accept more revision levels
    //

    if (AclRevision < MIN_ACL_REVISION || AclRevision > MAX_ACL_REVISION) {

        //
        //  Revision not current
        //

        return STATUS_INVALID_PARAMETER;

    }

    if ( AclLength > MAX_USTRING ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Initialize the ACL
    //

    Acl->AclRevision = (UCHAR)AclRevision;  // Used to hardwire ACL_REVISION2 here
    Acl->Sbz1 = 0;
    Acl->AclSize = (USHORT) (AclLength & 0xfffc);
    Acl->AceCount = 0;
    Acl->Sbz2 = 0;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


BOOLEAN
RtlValidAcl (
    IN PACL Acl
    )

/*++

Routine Description:

    This procedure validates an ACL.

    This involves validating the revision level of the ACL and ensuring
    that the number of ACEs specified in the AceCount fit in the space
    specified by the AclSize field of the ACL header.

Arguments:

    Acl - Pointer to the ACL structure to validate.

Return Value:

    BOOLEAN - TRUE if the structure of Acl is valid.

--*/

{
    RTL_PAGED_CODE();

    try {
        PACE_HEADER Ace;
        PISID Sid;
        PISID Sid2;
        ULONG i;
        UCHAR AclRevision = ACL_REVISION2;


        //
        //  Check the ACL revision level
        //
        if (!ValidAclRevision(Acl)) {
            return(FALSE);
        }


        if (!WordAligned(&Acl->AclSize)) {
            return(FALSE);
        }

        if (Acl->AclSize < sizeof(ACL)) {
            return(FALSE);
        }
        //
        // Validate all of the ACEs.
        //

        Ace = ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)));

        for (i = 0; i < Acl->AceCount; i++) {

            //
            //  Check to make sure we haven't overrun the Acl buffer
            //  with our ace pointer.  Make sure the ACE_HEADER is in
            //  the ACL also.
            //

            if ((PUCHAR)Ace + sizeof(ACE_HEADER) >= ((PUCHAR)Acl + Acl->AclSize)) {
                return(FALSE);
            }

            if (!WordAligned(&Ace->AceSize)) {
                return(FALSE);
            }

            if ((PUCHAR)Ace + Ace->AceSize > ((PUCHAR)Acl + Acl->AclSize)) {
                return(FALSE);
            }

            //
            // It is now safe to reference fields in the ACE header.
            //

            //
            // The ACE header fits into the ACL, if this is a known type of ACE,
            // make sure the SID is within the bounds of the ACE
            //

            if (IsKnownAceType(Ace)) {

                if (!LongAligned(Ace->AceSize)) {
                    return(FALSE);
                }

                if (Ace->AceSize < sizeof(KNOWN_ACE) - sizeof(ULONG) + sizeof(SID) - sizeof(ULONG)) {
                    return(FALSE);
                }

                //
                // It's now safe to reference the parts of the SID structure, though
                // not the SID itself.
                //

                Sid = (PISID) & (((PKNOWN_ACE)Ace)->SidStart);

                if (Sid->Revision != SID_REVISION) {
                    return(FALSE);
                }

                if (Sid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                    return(FALSE);
                }

                //
                // SeLengthSid computes the size of the SID based on the subauthority count,
                // so it is safe to use even though we don't know that the body of the SID
                // is safe to reference.
                //

                if (Ace->AceSize < sizeof(KNOWN_ACE) - sizeof(ULONG) + SeLengthSid( Sid )) {
                    return(FALSE);
                }


            //
            // If it's a compound ACE, then perform roughly the same set of tests, but
            // check the validity of both SIDs.
            //

            } else if (IsCompoundAceType(Ace)) {

                //
                // Compound ACEs became valid in revision 3
                //
                if ( Acl->AclRevision < ACL_REVISION3 ) {
                    return FALSE;
                }

                if (!LongAligned(Ace->AceSize)) {
                    return(FALSE);
                }

                if (Ace->AceSize < sizeof(KNOWN_COMPOUND_ACE) - sizeof(ULONG) + sizeof(SID)) {
                    return(FALSE);
                }

                //
                // The only currently defined Compound ACE is an Impersonation ACE.
                //

                if (((PKNOWN_COMPOUND_ACE)Ace)->CompoundAceType != COMPOUND_ACE_IMPERSONATION) {
                    return(FALSE);
                }

                //
                // Examine the first SID and make sure it's structurally valid,
                // and it lies within the boundaries of the ACE.
                //

                Sid = (PISID) & (((PKNOWN_COMPOUND_ACE)Ace)->SidStart);

                if (Sid->Revision != SID_REVISION) {
                    return(FALSE);
                }

                if (Sid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                    return(FALSE);
                }

                //
                // Compound ACEs contain two SIDs.  Make sure this ACE is large enough to contain
                // not only the first SID, but the body of the 2nd.
                //

                if (Ace->AceSize < sizeof(KNOWN_COMPOUND_ACE) - sizeof(ULONG) + SeLengthSid( Sid ) + sizeof(SID)) {
                    return(FALSE);
                }

                //
                // It is safe to reference the interior of the 2nd SID.
                //

                Sid2 = (PISID) ((PUCHAR)Sid + SeLengthSid( Sid ));

                if (Sid2->Revision != SID_REVISION) {
                    return(FALSE);
                }

                if (Sid2->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                    return(FALSE);
                }

                if (Ace->AceSize < sizeof(KNOWN_COMPOUND_ACE) - sizeof(ULONG) + SeLengthSid( Sid ) + SeLengthSid( Sid2 )) {
                    return(FALSE);
                }


            //
            // If it's an object ACE, then perform roughly the same set of tests.
            //

            } else if (IsObjectAceType(Ace)) {
                ULONG GuidSize=0;

                //
                // Object ACEs became valid in revision 4
                //
                if ( Acl->AclRevision < ACL_REVISION4 ) {
                    return FALSE;
                }

                if (!LongAligned(Ace->AceSize)) {
                    return(FALSE);
                }

                //
                // Ensure there is room for the ACE header.
                //
                if (Ace->AceSize < sizeof(KNOWN_OBJECT_ACE) - sizeof(ULONG)) {
                    return(FALSE);
                }


                //
                // Ensure there is room for the GUIDs and SID header
                //
                if ( RtlObjectAceObjectTypePresent( Ace ) ) {
                    GuidSize += sizeof(GUID);
                }

                if ( RtlObjectAceInheritedObjectTypePresent( Ace ) ) {
                    GuidSize += sizeof(GUID);
                }

                if (Ace->AceSize < sizeof(KNOWN_OBJECT_ACE) - sizeof(ULONG) + GuidSize + sizeof(SID)) {
                    return(FALSE);
                }

                //
                // It's now safe to reference the parts of the SID structure, though
                // not the SID itself.
                //

                Sid = (PISID) RtlObjectAceSid( Ace );

                if (Sid->Revision != SID_REVISION) {
                    return(FALSE);
                }

                if (Sid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                    return(FALSE);
                }

                if (Ace->AceSize < sizeof(KNOWN_OBJECT_ACE) - sizeof(ULONG) + GuidSize + SeLengthSid( Sid ) ) {
                    return(FALSE);
                }
           
            } else {

                //
                // It is an unknown ace type.  Verify that it is large enough 
                // to contain an ACE_HEADER. 
                //

                if (Ace->AceSize < sizeof(ACE_HEADER)) {

                    return FALSE;
                }
            }

            //
            //  And move Ace to the next ace position
            //

            Ace = ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize));
        }

        return(TRUE);

    } except(EXCEPTION_EXECUTE_HANDLER) {

        return FALSE;
    }

}


NTSTATUS
RtlQueryInformationAcl (
    IN PACL Acl,
    OUT PVOID AclInformation,
    IN ULONG AclInformationLength,
    IN ACL_INFORMATION_CLASS AclInformationClass
    )

/*++

Routine Description:

    This routine returns to the caller information about an ACL.  The requested
    information can be AclRevisionInformation, or AclSizeInformation.

Arguments:

    Acl - Supplies the Acl being examined

    AclInformation - Supplies the buffer to receive the information being
        requested

    AclInformationLength - Supplies the length of the AclInformation buffer
        in bytes

    AclInformationClass - Supplies the type of information being requested

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    PACL_REVISION_INFORMATION RevisionInfo;
    PACL_SIZE_INFORMATION SizeInfo;


    PVOID FirstFree;
    NTSTATUS Status;

    RTL_PAGED_CODE();

    //
    //  Check the ACL revision level
    //

    if (!ValidAclRevision( Acl )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Case on the information class being requested
    //

    switch (AclInformationClass) {

    case AclRevisionInformation:

        //
        //  Make sure the buffer size is correct
        //

        if (AclInformationLength < sizeof(ACL_REVISION_INFORMATION)) {

            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  Get the Acl revision and return
        //

        RevisionInfo = (PACL_REVISION_INFORMATION)AclInformation;
        RevisionInfo->AclRevision = Acl->AclRevision;

        break;

    case AclSizeInformation:

        //
        //  Make sure the buffer size is correct
        //

        if (AclInformationLength < sizeof(ACL_SIZE_INFORMATION)) {

            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  Locate the first free spot in the Acl
        //

        if (!RtlFirstFreeAce( Acl, &FirstFree )) {

            //
            //  The input Acl is ill-formed
            //

            return STATUS_INVALID_PARAMETER;

        }

        //
        //  Given a pointer to the first free spot we can now easily compute
        //  the number of free bytes and used bytes in the Acl.
        //

        SizeInfo = (PACL_SIZE_INFORMATION)AclInformation;
        SizeInfo->AceCount = Acl->AceCount;

        if (FirstFree == NULL) {

            //
            //  With a null first free we don't have any free space in the Acl
            //

            SizeInfo->AclBytesInUse = Acl->AclSize;

            SizeInfo->AclBytesFree = 0;

        } else {

            //
            //  The first free is not null so we have some free room left in
            //  the acl
            //

            SizeInfo->AclBytesInUse = (ULONG)((PUCHAR)FirstFree - (PUCHAR)Acl);

            SizeInfo->AclBytesFree = Acl->AclSize - SizeInfo->AclBytesInUse;

        }

        break;

    default:

        return STATUS_INVALID_INFO_CLASS;

    }

    //
    //  and return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlSetInformationAcl (
    IN PACL Acl,
    IN PVOID AclInformation,
    IN ULONG AclInformationLength,
    IN ACL_INFORMATION_CLASS AclInformationClass
    )

/*++

Routine Description:

    This routine sets the state of an ACL.  For now only the revision
    level can be set and for now only a revision level of 1 is accepted
    so this procedure is rather simple

Arguments:

    Acl - Supplies the Acl being altered

    AclInformation - Supplies the buffer containing the information being
        set

    AclInformationLength - Supplies the length of the Acl information buffer

    AclInformationClass - Supplies the type of information begin set

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    PACL_REVISION_INFORMATION RevisionInfo;

    RTL_PAGED_CODE();

    //
    //  Check the ACL revision level
    //

    if (!ValidAclRevision( Acl )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Case on the information class being requested
    //

    switch (AclInformationClass) {

    case AclRevisionInformation:

        //
        //  Make sure the buffer size is correct
        //

        if (AclInformationLength < sizeof(ACL_REVISION_INFORMATION)) {

            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  Get the Acl requested ACL revision level
        //

        RevisionInfo = (PACL_REVISION_INFORMATION)AclInformation;

        //
        //  Don't let them lower the revision of an ACL.
        //

        if (RevisionInfo->AclRevision < Acl->AclRevision ) {

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Assign the new revision.
        //

        Acl->AclRevision = (UCHAR)RevisionInfo->AclRevision;

        break;

    default:

        return STATUS_INVALID_INFO_CLASS;

    }

    //
    //  and return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlAddAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG StartingAceIndex,
    IN PVOID AceList,
    IN ULONG AceListLength
    )

/*++

Routine Description:

    This routine adds a string of ACEs to an ACL.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    StartingAceIndex - Supplies the ACE index which will be the index of
        the first ace inserted in the acl. 0 for the beginning of the list
        and MAXULONG for the end of the list.

    AceList - Supplies the list of Aces to be added to the Acl

    AceListLength - Supplies the size, in bytes, of the AceList buffer

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful, and an appropriate error
        status otherwise

--*/

{
    PVOID FirstFree;

    PACE_HEADER Ace;
    ULONG NewAceCount;

    PVOID AcePosition;
    ULONG i;
    UCHAR NewRevision;

    RTL_PAGED_CODE();

    //
    //  Check the ACL structure
    //

    if (!RtlValidAcl(Acl)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Locate the first free ace and check to see that the Acl is
    //  well formed.
    //

    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // If the AceRevision is greater than the ACL revision, then we want to
    // increase the ACL revision to be the same as the new ACE revision.
    // We can do this because our previously defined ACE types ( 0 -> 3 ) have
    // not changed structure nor been discontinued in the new revision.  So
    // we can bump the revision and the older types will not be misinterpreted.
    //
    // Compute what the final revision of the ACL is going to be, and save it
    // for later so we can update it once we know we're going to succeed.
    //

    NewRevision = (UCHAR)AceRevision > Acl->AclRevision ? (UCHAR)AceRevision : Acl->AclRevision;

    //
    // Check that the AceList is well formed, we do this by simply zooming
    // down the Ace list until we're equal to or have exceeded the ace list
    // length.  If we are equal to the length then we're well formed otherwise
    // we're ill-formed.  We'll also calculate how many Ace's there are
    // in the AceList
    //
    // In addition, now we have to make sure that we haven't been handed an
    // ACE type that is inappropriate for the AceRevision that was passed
    // in.
    //

    for (Ace = AceList, NewAceCount = 0;
         Ace < (PACE_HEADER)((PUCHAR)AceList + AceListLength);
         Ace = NextAce( Ace ), NewAceCount++) {

        //
        // Ensure the ACL revision allows this ACE type.
        //

        if ( Ace->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE ) {
            // V2 ACE are always valid.
        } else if ( Ace->AceType <= ACCESS_MAX_MS_V3_ACE_TYPE ) {
            if ( AceRevision < ACL_REVISION3 ) {
                return STATUS_INVALID_PARAMETER;
            }
        } else if ( Ace->AceType <= ACCESS_MAX_MS_V4_ACE_TYPE ) {
            if ( AceRevision < ACL_REVISION4 ) {
                return STATUS_INVALID_PARAMETER;
            }
        }
    }

    //
    //  Check to see if we've exceeded the ace list length
    //

    if (Ace > (PACE_HEADER)((PUCHAR)AceList + AceListLength)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Check to see if there is enough room in the Acl to store the additional
    //  Ace list
    //

    if (FirstFree == NULL ||
        (PUCHAR)FirstFree + AceListLength > (PUCHAR)Acl + Acl->AclSize) {

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    //  All of the input has checked okay, we now need to locate the position
    //  where to insert the new ace list.  We won't check the acl for
    //  validity because we did earlier when got the first free ace position.
    //

    AcePosition = FirstAce( Acl );

    for (i = 0; i < StartingAceIndex && i < Acl->AceCount; i++) {

        AcePosition = NextAce( AcePosition );

    }

    //
    //  Now Ace points to where we want to insert the ace list,  We do the
    //  insertion by adding ace list to the acl and shoving over the remainder
    //  of the list down the acl.  We know this will work because we earlier
    //  check to make sure the new acl list will fit in the acl size
    //

    RtlpAddData( AceList, AceListLength,
             AcePosition, (ULONG) ((PUCHAR)FirstFree - (PUCHAR)AcePosition));

    //
    //  Update the Acl Header
    //

    Acl->AceCount = (USHORT)(Acl->AceCount + NewAceCount);

    Acl->AclRevision = NewRevision;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDeleteAce (
    IN OUT PACL Acl,
    IN ULONG AceIndex
    )

/*++

Routine Description:

    This routine deletes one ACE from an ACL.

Arguments:

    Acl - Supplies the Acl being modified

    AceIndex - Supplies the index of the Ace to delete.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    PVOID FirstFree;

    PACE_HEADER Ace;
    ULONG i;

    RTL_PAGED_CODE();

    //
    //  Check the ACL structure
    //

    if (!RtlValidAcl(Acl)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Make sure the AceIndex is within proper range, it's ulong so we know
    //  it can't be negative
    //

    if (AceIndex >= Acl->AceCount) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Locate the first free spot, this will tell us how much data
    //  we'll need to colapse.  If the results is false then the acl is
    //  ill-formed
    //

    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Now locate the ace that we're going to delete.  This loop
    //  doesn't need to check the acl for being well formed.
    //

    Ace = FirstAce( Acl );

    for (i = 0; i < AceIndex; i++) {

        Ace = NextAce( Ace );

    }

    //
    //  We've found the ace to delete to simply copy over the rest of
    //  the acl over this ace.  The delete data procedure also deletes
    //  rest of the string that it's moving over so we don't have to
    //

    RtlpDeleteData( Ace, Ace->AceSize, (ULONG) ((PUCHAR)FirstFree - (PUCHAR)Ace));

    //
    //  Update the Acl header
    //

    Acl->AceCount--;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlGetAce (
    IN PACL Acl,
    ULONG AceIndex,
    OUT PVOID *Ace
    )

/*++

Routine Description:

    This routine returns a pointer to an ACE in an ACl referenced by
    ACE index

Arguments:

    Acl - Supplies the ACL being queried

    AceIndex - Supplies the Ace index to locate

    Ace - Receives the address of the ACE within the ACL

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    ULONG i;

    RTL_PAGED_CODE();

    //
    //  Check the ACL revision level
    //

    if (!ValidAclRevision(Acl)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Check the AceIndex against the Ace count of the Acl, it's ulong so
    //  we know it can't be negative
    //

    if (AceIndex >= Acl->AceCount) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  To find the Ace requested by zooming down the Ace List.
    //

    *Ace = FirstAce( Acl );

    for (i = 0; i < AceIndex; i++) {

        //
        //  Check to make sure we haven't overrun the Acl buffer
        //  with our ace pointer.  If we have then our input is bogus
        //

        if (*Ace >= (PVOID)((PUCHAR)Acl + Acl->AclSize)) {

            return STATUS_INVALID_PARAMETER;

        }

        //
        //  And move Ace to the next ace position
        //

        *Ace = NextAce( *Ace );

    }

    //
    //  Now Ace points to the Ace we're after, but make sure we aren't
    //  beyond the Acl.
    //

    if (*Ace >= (PVOID)((PUCHAR)Acl + Acl->AclSize)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  The Ace is still within the Acl so return success to our caller
    //

    return STATUS_SUCCESS;

}


NTSTATUS
RtlAddCompoundAce (
    IN PACL Acl,
    IN ULONG AceRevision,
    IN UCHAR CompoundAceType,
    IN ACCESS_MASK AccessMask,
    IN PSID ServerSid,
    IN PSID ClientSid
    )

/*++

Routine Description:

    This routine adds a KNOWN_COMPOUND_ACE to an ACL.  This is
    expected to be a common form of ACL modification.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    CompoundAceType - Supplies the type of compound ACE being added.
        Currently the only defined type is COMPOUND_ACE_IMPERSONATION.

    AccessMask - The mask of accesses to be granted to the specified SID pair.

    ServerSid - Pointer to the Server SID to be placed in the ACE.

    ClientSid - Pointer to the Client SID to be placed in the ACE.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/




{
    PVOID FirstFree;
    USHORT AceSize;
    PKNOWN_COMPOUND_ACE GrantAce;
    UCHAR NewRevision;

    RTL_PAGED_CODE();

    //
    // Validate the structure of the SID
    //

    if (!RtlValidSid(ServerSid) || !RtlValidSid(ClientSid)) {
        return STATUS_INVALID_SID;
    }

    //
    // Check the ACL & ACE revision levels
    // Compound ACEs become valid in version 3.
    //

    if ( Acl->AclRevision > ACL_REVISION4 ||
         AceRevision < ACL_REVISION3 ||
         AceRevision > ACL_REVISION4 ) {
        return STATUS_REVISION_MISMATCH;
    }

    //
    // Calculate the new revision of the ACL.  The new revision is the maximum
    // of the old revision and and new ACE's revision.  This is possible because
    // the format of previously defined ACEs did not change across revisions.
    //

    NewRevision = Acl->AclRevision > (UCHAR)AceRevision ? Acl->AclRevision : (UCHAR)AceRevision;

    //
    //  Locate the first free ace and check to see that the Acl is
    //  well formed.
    //

    if (!RtlValidAcl( Acl )) {
        return STATUS_INVALID_ACL;
    }

    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_ACL;
    }

    //
    //  Check to see if there is enough room in the Acl to store the new
    //  ACE
    //

    AceSize = (USHORT)(sizeof(KNOWN_COMPOUND_ACE) -
                       sizeof(ULONG)              +
                       SeLengthSid(ClientSid)    +
                       SeLengthSid(ServerSid)
                       );

    if (  FirstFree == NULL ||
          ((PUCHAR)FirstFree + AceSize > ((PUCHAR)Acl + Acl->AclSize))
       ) {

        return STATUS_ALLOTTED_SPACE_EXCEEDED;
    }

    //
    // Add the ACE to the end of the ACL
    //

    GrantAce = (PKNOWN_COMPOUND_ACE)FirstFree;
    GrantAce->Header.AceFlags = 0;
    GrantAce->Header.AceType = ACCESS_ALLOWED_COMPOUND_ACE_TYPE;
    GrantAce->Header.AceSize = AceSize;
    GrantAce->Mask = AccessMask;
    GrantAce->CompoundAceType = CompoundAceType;
    RtlCopySid( SeLengthSid(ServerSid), (PSID)(&GrantAce->SidStart), ServerSid );
    RtlCopySid( SeLengthSid(ClientSid), (PSID)(((PCHAR)&GrantAce->SidStart) + SeLengthSid(ServerSid)), ClientSid );

    //
    // Increment the number of ACEs by 1.
    //

    Acl->AceCount += 1;

    //
    // Adjust the Acl revision, if necessary
    //

    Acl->AclRevision = NewRevision;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlpAddKnownAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid,
    IN UCHAR NewType
    )

/*++

Routine Description:

    This routine adds KNOWN_ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.  The type is specified by the caller.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be denied to the specified SID.

    Sid - Pointer to the SID being denied access.

    NewType - Type of ACE to be added.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    PVOID FirstFree;
    USHORT AceSize;
    PKNOWN_ACE GrantAce;
    UCHAR NewRevision;
    ULONG TestedAceFlags;

    RTL_PAGED_CODE();

    //
    // Validate the structure of the SID
    //

    if (!RtlValidSid(Sid)) {
        return STATUS_INVALID_SID;
    }

    //
    //  Check the ACL & ACE revision levels
    //

    if ( Acl->AclRevision > ACL_REVISION4 || AceRevision > ACL_REVISION4 ) {

        return STATUS_REVISION_MISMATCH;
    }

    //
    // Calculate the new revision of the ACL.  The new revision is the maximum
    // of the old revision and and new ACE's revision.  This is possible because
    // the format of previously defined ACEs did not change across revisions.
    //

    NewRevision = Acl->AclRevision > (UCHAR)AceRevision ? Acl->AclRevision : (UCHAR)AceRevision;

    //
    // Validate the AceFlags.
    //

    TestedAceFlags = AceFlags & ~VALID_INHERIT_FLAGS;
    if ( TestedAceFlags != 0 ) {

        if ( NewType == SYSTEM_AUDIT_ACE_TYPE ) {
            TestedAceFlags &=
                ~(SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG);
        }

        if ( TestedAceFlags != 0 ) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Locate the first free ace and check to see that the Acl is
    //  well formed.
    //

    if (!RtlValidAcl( Acl )) {
        return STATUS_INVALID_ACL;
    }
    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_ACL;
    }

    //
    //  Check to see if there is enough room in the Acl to store the new
    //  ACE
    //

    AceSize = (USHORT)(sizeof(ACE_HEADER) +
                      sizeof(ACCESS_MASK) +
                      SeLengthSid(Sid));

    if (  FirstFree == NULL ||
          ((PUCHAR)FirstFree + AceSize > ((PUCHAR)Acl + Acl->AclSize))
       ) {

        return STATUS_ALLOTTED_SPACE_EXCEEDED;
    }

    //
    // Add the ACE to the end of the ACL
    //

    GrantAce = (PKNOWN_ACE)FirstFree;
    GrantAce->Header.AceFlags = (UCHAR)AceFlags;
    GrantAce->Header.AceType = NewType;
    GrantAce->Header.AceSize = AceSize;
    GrantAce->Mask = AccessMask;
    RtlCopySid( SeLengthSid(Sid), (PSID)(&GrantAce->SidStart), Sid );

    //
    // Increment the number of ACEs by 1.
    //

    Acl->AceCount += 1;

    //
    // Adjust the Acl revision, if necessary
    //

    Acl->AclRevision = NewRevision;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}

NTSTATUS
RtlpAddKnownObjectAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN GUID *ObjectTypeGuid OPTIONAL,
    IN GUID *InheritedObjectTypeGuid OPTIONAL,
    IN PSID Sid,
    IN UCHAR NewType
    )

/*++

Routine Description:

    This routine adds KNOWN_ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.  The type is specified by the caller.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be denied to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    Sid - Pointer to the SID being denied access.

    NewType - Type of ACE to be added.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    PVOID FirstFree;
    USHORT AceSize;
    PKNOWN_OBJECT_ACE GrantAce;
    UCHAR NewRevision;
    ULONG TestedAceFlags;
    ULONG AceObjectFlags = 0;
    ULONG SidSize;
    PCHAR Where;

    RTL_PAGED_CODE();

    //
    // Validate the structure of the SID
    //

    if (!RtlValidSid(Sid)) {
        return STATUS_INVALID_SID;
    }

    //
    //  Check the ACL & ACE revision levels
    // Object ACEs became valid in version 4.
    //

    if ( Acl->AclRevision > ACL_REVISION4 || AceRevision != ACL_REVISION4 ) {

        return STATUS_REVISION_MISMATCH;
    }

    //
    // Calculate the new revision of the ACL.  The new revision is the maximum
    // of the old revision and and new ACE's revision.  This is possible because
    // the format of previously defined ACEs did not change across revisions.
    //

    NewRevision = Acl->AclRevision > (UCHAR)AceRevision ? Acl->AclRevision : (UCHAR)AceRevision;

    //
    // Validate the AceFlags.
    //


    TestedAceFlags = AceFlags & ~VALID_INHERIT_FLAGS;
    if ( TestedAceFlags != 0 ) {

        if ( NewType == SYSTEM_AUDIT_ACE_TYPE ||
             NewType == SYSTEM_AUDIT_OBJECT_ACE_TYPE ) {
            TestedAceFlags &=
                ~(SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG);
        }

        if ( TestedAceFlags != 0 ) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Locate the first free ace and check to see that the Acl is
    //  well formed.
    //

    if (!RtlValidAcl( Acl )) {
        return STATUS_INVALID_ACL;
    }
    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_ACL;
    }

    //
    //  Check to see if there is enough room in the Acl to store the new
    //  ACE
    //

    SidSize = SeLengthSid(Sid);
    AceSize = (USHORT)(sizeof(ACE_HEADER) +
                      sizeof(ACCESS_MASK) +
                      sizeof(ULONG) +
                      SidSize);

    if ( ARGUMENT_PRESENT(ObjectTypeGuid) ) {
        AceObjectFlags |= ACE_OBJECT_TYPE_PRESENT;
        AceSize += sizeof(GUID);
    }

    if ( ARGUMENT_PRESENT(InheritedObjectTypeGuid) ) {
        AceObjectFlags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
        AceSize += sizeof(GUID);
    }

    if (  FirstFree == NULL ||
          ((PUCHAR)FirstFree + AceSize > ((PUCHAR)Acl + Acl->AclSize))
       ) {

        return STATUS_ALLOTTED_SPACE_EXCEEDED;
    }

    //
    // Add the ACE to the end of the ACL
    //

    GrantAce = (PKNOWN_OBJECT_ACE)FirstFree;
    GrantAce->Header.AceFlags = (UCHAR) AceFlags;
    GrantAce->Header.AceType = NewType;
    GrantAce->Header.AceSize = AceSize;
    GrantAce->Mask = AccessMask;
    GrantAce->Flags = AceObjectFlags;
    Where = (PCHAR) (&GrantAce->SidStart);
    if ( ARGUMENT_PRESENT(ObjectTypeGuid) ) {
        RtlCopyMemory( Where, ObjectTypeGuid, sizeof(GUID) );
        Where += sizeof(GUID);
    }
    if ( ARGUMENT_PRESENT(InheritedObjectTypeGuid) ) {
        RtlCopyMemory( Where, InheritedObjectTypeGuid, sizeof(GUID) );
        Where += sizeof(GUID);
    }
    RtlCopySid( SidSize, (PSID)Where, Sid );
    Where += SidSize;

    //
    // Increment the number of ACEs by 1.
    //

    Acl->AceCount += 1;

    //
    // Adjust the Acl revision, if necessary
    //

    Acl->AclRevision = NewRevision;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlAddAccessAllowedAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine adds an ACCESS_ALLOWED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be granted to the specified SID.

    Sid - Pointer to the SID being granted access.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

--*/

{
    RTL_PAGED_CODE();

    return RtlpAddKnownAce (
               Acl,
               AceRevision,
               0,   // No inherit flags
               AccessMask,
               Sid,
               ACCESS_ALLOWED_ACE_TYPE
               );
}


NTSTATUS
RtlAddAccessAllowedAceEx (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine adds an ACCESS_ALLOWED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    Sid - Pointer to the SID being granted access.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    RTL_PAGED_CODE();

    return RtlpAddKnownAce (
               Acl,
               AceRevision,
               AceFlags,
               AccessMask,
               Sid,
               ACCESS_ALLOWED_ACE_TYPE
               );
}


NTSTATUS
RtlAddAccessDeniedAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine adds an ACCESS_DENIED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be denied to the specified SID.

    Sid - Pointer to the SID being denied access.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

--*/

{
    RTL_PAGED_CODE();

    return RtlpAddKnownAce (
               Acl,
               AceRevision,
               0,   // No inherit flags
               AccessMask,
               Sid,
               ACCESS_DENIED_ACE_TYPE
               );

}


NTSTATUS
RtlAddAccessDeniedAceEx (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine adds an ACCESS_DENIED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be denied to the specified SID.

    Sid - Pointer to the SID being denied access.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    RTL_PAGED_CODE();

    return RtlpAddKnownAce (
               Acl,
               AceRevision,
               AceFlags,
               AccessMask,
               Sid,
               ACCESS_DENIED_ACE_TYPE
               );

}


NTSTATUS
RtlAddAuditAccessAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid,
    IN BOOLEAN AuditSuccess,
    IN BOOLEAN AuditFailure
    )

/*++

Routine Description:

    This routine adds a SYSTEM_AUDIT ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance.

    Parameters are used to indicate whether auditing is to be performed
    on success, failure, or both.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be denied to the specified SID.

    Sid - Pointer to the SID to be audited.

    AuditSuccess - If TRUE, indicates successful access attempts are to be
        audited.

    AuditFailure - If TRUE, indicated failed access attempts are to be
        audited.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

--*/

{
    ULONG AceFlags = 0;
    RTL_PAGED_CODE();

    if (AuditSuccess) {
        AceFlags |= SUCCESSFUL_ACCESS_ACE_FLAG;
    }
    if (AuditFailure) {
        AceFlags |= FAILED_ACCESS_ACE_FLAG;
    }

    return RtlpAddKnownAce (
                Acl,
                AceRevision,
                AceFlags,
                AccessMask,
                Sid,
                SYSTEM_AUDIT_ACE_TYPE );

}

NTSTATUS
RtlAddAuditAccessAceEx (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid,
    IN BOOLEAN AuditSuccess,
    IN BOOLEAN AuditFailure
    )

/*++

Routine Description:

    This routine adds a SYSTEM_AUDIT ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance.

    Parameters are used to indicate whether auditing is to be performed
    on success, failure, or both.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be denied to the specified SID.

    Sid - Pointer to the SID to be audited.

    AuditSuccess - If TRUE, indicates successful access attempts are to be
        audited.

    AuditFailure - If TRUE, indicated failed access attempts are to be
        audited.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    RTL_PAGED_CODE();

    if (AuditSuccess) {
        AceFlags |= SUCCESSFUL_ACCESS_ACE_FLAG;
    }
    if (AuditFailure) {
        AceFlags |= FAILED_ACCESS_ACE_FLAG;
    }

    return RtlpAddKnownAce (
                Acl,
                AceRevision,
                AceFlags,
                AccessMask,
                Sid,
                SYSTEM_AUDIT_ACE_TYPE );

}


NTSTATUS
RtlAddAccessAllowedObjectAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN GUID *ObjectTypeGuid OPTIONAL,
    IN GUID *InheritedObjectTypeGuid OPTIONAL,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine adds an object specific ACCESS_ALLOWED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    Sid - Pointer to the SID being granted access.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    RTL_PAGED_CODE();

    //
    // If no object types are specified,
    //  build a non-object ACE.
    //
    if (ObjectTypeGuid == NULL && InheritedObjectTypeGuid == NULL ) {
        return RtlpAddKnownAce (
                   Acl,
                   AceRevision,
                   AceFlags,
                   AccessMask,
                   Sid,
                   ACCESS_ALLOWED_ACE_TYPE
                   );
    }

    return RtlpAddKnownObjectAce (
               Acl,
               AceRevision,
               AceFlags,
               AccessMask,
               ObjectTypeGuid,
               InheritedObjectTypeGuid,
               Sid,
               ACCESS_ALLOWED_OBJECT_ACE_TYPE
               );
}


NTSTATUS
RtlAddAccessDeniedObjectAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN GUID *ObjectTypeGuid OPTIONAL,
    IN GUID *InheritedObjectTypeGuid OPTIONAL,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine adds an object specific ACCESS_DENIED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    Sid - Pointer to the SID being denied access.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    RTL_PAGED_CODE();

    //
    // If no object types are specified,
    //  build a non-object ACE.
    //
    if (ObjectTypeGuid == NULL && InheritedObjectTypeGuid == NULL ) {
        return RtlpAddKnownAce (
                   Acl,
                   AceRevision,
                   AceFlags,
                   AccessMask,
                   Sid,
                   ACCESS_DENIED_ACE_TYPE
                   );
    }

    return RtlpAddKnownObjectAce (
               Acl,
               AceRevision,
               AceFlags,
               AccessMask,
               ObjectTypeGuid,
               InheritedObjectTypeGuid,
               Sid,
               ACCESS_DENIED_OBJECT_ACE_TYPE
               );
}


NTSTATUS
RtlAddAuditAccessObjectAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN GUID *ObjectTypeGuid OPTIONAL,
    IN GUID *InheritedObjectTypeGuid OPTIONAL,
    IN PSID Sid,
    IN BOOLEAN AuditSuccess,
    IN BOOLEAN AuditFailure
    )

/*++

Routine Description:

    This routine adds an object specific ACCESS_DENIED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    Sid - Pointer to the SID to be audited.

    AuditSuccess - If TRUE, indicates successful access attempts are to be
        audited.

    AuditFailure - If TRUE, indicated failed access attempts are to be
        audited.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    RTL_PAGED_CODE();

    if (AuditSuccess) {
        AceFlags |= SUCCESSFUL_ACCESS_ACE_FLAG;
    }
    if (AuditFailure) {
        AceFlags |= FAILED_ACCESS_ACE_FLAG;
    }

    //
    // If no object types are specified,
    //  build a non-object ACE.
    //
    if (ObjectTypeGuid == NULL && InheritedObjectTypeGuid == NULL ) {
        return RtlpAddKnownAce (
                   Acl,
                   AceRevision,
                   AceFlags,
                   AccessMask,
                   Sid,
                   SYSTEM_AUDIT_ACE_TYPE
                   );
    }

    return RtlpAddKnownObjectAce (
               Acl,
               AceRevision,
               AceFlags,
               AccessMask,
               ObjectTypeGuid,
               InheritedObjectTypeGuid,
               Sid,
               SYSTEM_AUDIT_OBJECT_ACE_TYPE
               );
}


//
//  Internal support routine
//

BOOLEAN
RtlFirstFreeAce (
    IN PACL Acl,
    OUT PVOID *FirstFree
    )

/*++

Routine Description:

    This routine returns a pointer to the first free byte in an Acl
    or NULL if the acl is ill-formed.  If the Acl is full then the
    return pointer is to the byte immediately following the acl, and
    TRUE will be returned.

Arguments:

    Acl - Supplies a pointer to the Acl to examine

    FirstFree - Receives a pointer to the first free position in the Acl

Return Value:

    BOOLEAN - TRUE if the Acl is well formed and FALSE otherwise

--*/

{
    PACE_HEADER Ace;
    ULONG i;

    RTL_PAGED_CODE();

    //
    //  To find the first free spot in the Acl we need to search for
    //  the last ace.  We do this by zooming down the list until
    //  we've exhausted the ace count or the ace size (which ever comes
    //  first).  In the following loop Ace points to the next spot
    //  for an Ace and I is the ace index
    //

    *FirstFree = NULL;

    for ( i=0, Ace = FirstAce( Acl );
          i < Acl->AceCount;
          i++, Ace = NextAce( Ace )) {

        //
        //  Check to make sure we haven't overrun the Acl buffer
        //  with our Ace pointer.  If we have then our input is bogus.
        //

        if (Ace >= (PACE_HEADER)((PUCHAR)Acl + Acl->AclSize)) {

            return FALSE;

        }

    }

    //
    //  Now Ace points to the first free spot in the Acl so set the
    //  output variable and check to make sure it is still in the Acl
    //  or just one beyond the end of the acl (i.e., the acl is full).
    //

    if (Ace <= (PACE_HEADER)((PUCHAR)Acl + Acl->AclSize)) {

        *FirstFree = Ace;
    }

    //
    //  The Acl is well formed so return the first free spot we've found
    //  (or NULL if there is no free space for another ACE)
    //

    return TRUE;

}


//
//  Internal support routine
//

VOID
RtlpAddData (
    IN PVOID From,
    IN ULONG FromSize,
    IN PVOID To,
    IN ULONG ToSize
    )

/*++

Routine Description:

    This routine copies data to a string of bytes.  It does this by moving
    over data in the to string so that the from string will fit.  It also
    assumes that the checks that the data will fit in memory have already
    been done.  Pictorially the results are as follows.

    Before:

        From -> ffffffffff

        To   -> tttttttttttttttt

    After:

        From -> ffffffffff

        To   -> fffffffffftttttttttttttttt

Arguments:

    From - Supplies a pointer to the source buffer

    FromSize - Supplies the size of the from buffer in bytes

    To - Supplies a pointer to the destination buffer

    ToSize - Supplies the size of the to buffer in bytes

Return Value:

    None

--*/

{
    LONG i;

    //
    //  Shift over the To buffer enough to fit in the From buffer
    //

    for (i = ToSize - 1; i >= 0; i--) {

        ((PUCHAR)To)[i+FromSize] = ((PUCHAR)To)[i];
    }

    //
    //  Now copy over the From buffer
    //

    for (i = 0; (ULONG)i < FromSize; i += 1) {

        ((PUCHAR)To)[i] = ((PUCHAR)From)[i];

    }

    //
    //  and return to our caller
    //

    return;

}


//
//  Internal support routine
//

VOID
RtlpDeleteData (
    IN PVOID Data,
    IN ULONG RemoveSize,
    IN ULONG TotalSize
    )

/*++

Routine Description:

    This routine deletes a string of bytes from the front of a data buffer
    and compresses the data.  It also zeros out the part of the string
    that is no longer in use.  Pictorially the results are as follows

    Before:

        Data       = DDDDDddddd
        RemoveSize = 5
        TotalSize  = 10

    After:

        Data      = ddddd00000

Arguments:

    Data - Supplies a pointer to the data being altered

    RemoveSize - Supplies the number of bytes to delete from the front
        of the data buffer

    TotalSize - Supplies the total number of bytes in the data buffer
        before the delete operation

Return Value:

    None

--*/

{
    ULONG i;

    //
    //  Shift over the buffer to remove the amount
    //

    for (i = RemoveSize; i < TotalSize; i++) {

        ((PUCHAR)Data)[i-RemoveSize] = ((PUCHAR)Data)[i];

    }

    //
    //  Now as a safety precaution we'll zero out the rest of the string
    //

    for (i = TotalSize - RemoveSize; i < TotalSize; i++) {

        ((PUCHAR)Data)[i] = 0;
    }

    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\bitmap.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    BitMap.c

Abstract:

    Implementation of the bit map routines for the NT rtl.

    Bit numbers within the bit map are zero based.  The first is numbered
    zero.

    The bit map routines keep track of the number of bits clear or set by
    subtracting or adding the number of bits operated on as bit ranges
    are cleared or set; individual bit states are not tested.
    This means that if a range of bits is set,
    it is assumed that the total range is currently clear.

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,RtlInitializeBitMap)
#endif


#if DBG
VOID
DumpBitMap (
    PRTL_BITMAP BitMap
    )
{
    ULONG i;
    BOOLEAN AllZeros, AllOnes;

    DbgPrint(" BitMap:%08lx", BitMap);

    DbgPrint(" (%08x)", BitMap->SizeOfBitMap);
    DbgPrint(" %08lx\n", BitMap->Buffer);

    AllZeros = FALSE;
    AllOnes = FALSE;

    for (i = 0; i < ((BitMap->SizeOfBitMap + 31) / 32); i += 1) {

        if (BitMap->Buffer[i] == 0) {

            if (AllZeros) {

                NOTHING;

            } else {

                DbgPrint("%4d:", i);
                DbgPrint(" %08lx\n", BitMap->Buffer[i]);
            }

            AllZeros = TRUE;
            AllOnes = FALSE;

        } else if (BitMap->Buffer[i] == 0xFFFFFFFF) {

            if (AllOnes) {

                NOTHING;

            } else {

                DbgPrint("%4d:", i);
                DbgPrint(" %08lx\n", BitMap->Buffer[i]);
            }

            AllZeros = FALSE;
            AllOnes = TRUE;

        } else {

            AllZeros = FALSE;
            AllOnes = FALSE;

            DbgPrint("%4d:", i);
            DbgPrint(" %08lx\n", BitMap->Buffer[i]);
        }
    }
}
#endif


//
//  There are three macros to make reading the bytes in a bitmap easier.
//

#define GET_BYTE_DECLARATIONS() \
    PUCHAR _CURRENT_POSITION;

#define GET_BYTE_INITIALIZATION(RTL_BITMAP,BYTE_INDEX) {               \
    _CURRENT_POSITION = &((PUCHAR)((RTL_BITMAP)->Buffer))[BYTE_INDEX]; \
}

#define GET_BYTE(THIS_BYTE)  (         \
    THIS_BYTE = *(_CURRENT_POSITION++) \
)


//
//  Lookup table that tells how many contiguous bits are clear (i.e., 0) in
//  a byte
//

CONST CCHAR RtlpBitsClearAnywhere[] =
         { 8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,
           4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
           5,4,3,3,2,2,2,2,3,2,2,2,2,2,2,2,
           4,3,2,2,2,2,2,2,3,2,2,2,2,2,2,2,
           6,5,4,4,3,3,3,3,3,2,2,2,2,2,2,2,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           7,6,5,5,4,4,4,4,3,3,3,3,3,3,3,3,
           4,3,2,2,2,2,2,2,3,2,2,2,2,2,2,2,
           5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           6,5,4,4,3,3,3,3,3,2,2,2,2,2,2,2,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,0 };

//
//  Lookup table that tells how many contiguous LOW order bits are clear
//  (i.e., 0) in a byte
//

CONST CCHAR RtlpBitsClearLow[] =
          { 8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0 };

//
//  Lookup table that tells how many contiguous HIGH order bits are clear
//  (i.e., 0) in a byte
//

CONST CCHAR RtlpBitsClearHigh[] =
          { 8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,
            3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };

//
//  Lookup table that tells how many clear bits (i.e., 0) there are in a byte
//

CONST CCHAR RtlpBitsClearTotal[] =
          { 8,7,7,6,7,6,6,5,7,6,6,5,6,5,5,4,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            4,3,3,2,3,2,2,1,3,2,2,1,2,1,1,0 };

//
//  Bit Mask for clearing and setting bits within bytes.  FillMask[i] has the first
//  i bits set to 1.  ZeroMask[i] has the first i bits set to zero.
//

static CONST UCHAR FillMask[] = { 0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF };

static CONST UCHAR ZeroMask[] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xf0, 0xe0, 0xc0, 0x80, 0x00 };


VOID
RtlInitializeBitMap (
    IN PRTL_BITMAP BitMapHeader,
    IN PULONG BitMapBuffer,
    IN ULONG SizeOfBitMap
    )

/*++

Routine Description:

    This procedure initializes a bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the BitMap Header to initialize

    BitMapBuffer - Supplies a pointer to the buffer that is to serve as the
        BitMap.  This must be an a multiple number of longwords in size.

    SizeOfBitMap - Supplies the number of bits required in the Bit Map.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    //
    //  Initialize the BitMap header.
    //

    BitMapHeader->SizeOfBitMap = SizeOfBitMap;
    BitMapHeader->Buffer = BitMapBuffer;

    //
    //  And return to our caller
    //

    return;
}

VOID
RtlClearBit (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG BitNumber
    )

/*++

Routine Description:

    This procedure clears a single bit in the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bit map.

    BitNumber - Supplies the number of the bit to be cleared in the bit map.

Return Value:

    None.

--*/

{

#if defined(_AMD64_)

    ASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

    BitTestAndReset((PLONG)BitMapHeader->Buffer, BitNumber);

#else

    PCHAR ByteAddress;
    ULONG ShiftCount;

    ASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

    ByteAddress = (PCHAR)BitMapHeader->Buffer + (BitNumber >> 3);
    ShiftCount = BitNumber & 0x7;
    *ByteAddress &= (CHAR)(~(1 << ShiftCount));

#endif

    return;
}

VOID
RtlSetBit (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG BitNumber
    )

/*++

Routine Description:

    This procedure sets a single bit in the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bit map.

    BitNumber - Supplies the number of the bit to be set in the bit map.

Return Value:

    None.

--*/

{

#if defined(_AMD64_)

    ASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

    BitTestAndSet((PLONG)BitMapHeader->Buffer, BitNumber);

#else

    PCHAR ByteAddress;
    ULONG ShiftCount;

    ASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

    ByteAddress = (PCHAR)BitMapHeader->Buffer + (BitNumber >> 3);
    ShiftCount = BitNumber & 0x7;
    *ByteAddress |= (CHAR)(1 << ShiftCount);

#endif

    return;
}

BOOLEAN
RtlTestBit (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG BitNumber
    )

/*++

Routine Description:

    This procedure tests the state of a single bit in the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bit map.

    BitNumber - Supplies the number of the bit to be tested in the bit map.

Return Value:

    The state of the specified bit is returned as the function value.

--*/

{

#if defined(_AMD64_)

    ASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

    return BitTest((PLONG)BitMapHeader->Buffer, BitNumber);

#else

    PCHAR ByteAddress;
    ULONG ShiftCount;

    ASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

    ByteAddress = (PCHAR)BitMapHeader->Buffer + (BitNumber >> 3);
    ShiftCount = BitNumber & 0x7;
    return (BOOLEAN)((*ByteAddress >> ShiftCount) & 1);

#endif

}

VOID
RtlClearAllBits (
    IN PRTL_BITMAP BitMapHeader
    )

/*++

Routine Description:

    This procedure clears all bits in the specified Bit Map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap

Return Value:

    None.

--*/

{
    //
    //  Clear all the bits
    //

    RtlZeroMemory( BitMapHeader->Buffer,
                   ((BitMapHeader->SizeOfBitMap + 31) / 32) * 4
                 );

    //
    //  And return to our caller
    //

    return;
}


VOID
RtlSetAllBits (
    IN PRTL_BITMAP BitMapHeader
    )

/*++

Routine Description:

    This procedure sets all bits in the specified Bit Map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap

Return Value:

    None.

--*/

{
    //
    //  Set all the bits
    //

    RtlFillMemoryUlong( BitMapHeader->Buffer,
                        ((BitMapHeader->SizeOfBitMap + 31) / 32) * 4,
                        0xffffffff
                      );

    //
    //  And return to our caller
    //

    return;
}

typedef ULONG_PTR      CHUNK, *PCHUNK;
#define CHUNK_BYTES    (sizeof(CHUNK))
#define CHUNK_BITS     (CHUNK_BYTES * 8)
#define CHUNK_CLEAR    ((CHUNK)0)
#define CHUNK_SET      ((CHUNK)-1)
#define CHUNK_HIGH_BIT ((CHUNK)1 << (CHUNK_BITS - 1))

#define RTL_INVALID_INDEX ((ULONG)-1)

#if defined(_WIN64)
#define BitScanForwardChunk BitScanForward64
#define BitScanReverseChunk BitScanReverse64
#else
#define BitScanForwardChunk _BitScanForward
#define BitScanReverseChunk _BitScanReverse
#endif


LOGICAL
FORCEINLINE
RtlpFindClearRunInChunk (
    IN CHUNK Chunk,
    IN ULONG RunLength,
    OUT ULONG *StartBit
    )

/*++

Routine Description:

    This routine determines whether a run of clear bits of length RunLength
    exists in a chunk, and if so returns the starting index of the first
    such run.

Arguments:

    Chunk - The chunk to examine.

    RunLength - The length of the desired run.

    StartBit - Supplies a pointer to the value that will contain the bit index
               of the first suitable run found within Chunk.
                                        
Return Value:

    TRUE - A suitable run was found, and *StartBit containts the bit index
           of that run

    FALSE - A suitable run was not found.

--*/

{
    CHUNK chunkMask;
    ULONG shift;
    ULONG shiftsRemaining;

    ASSERT(RunLength < CHUNK_BITS);
    ASSERT(RunLength > 1);

    //
    // This algorithm works by inverting the bits, then masking and shifting
    // (RunLength-1) times.  The lowest bit set, if any, marks the start
    // of the run.
    //
    // For example, given
    //
    // Chunk = 0y11000000011111000000000001111000
    // RunLength = 11
    //
    //
    // 0y00111111100000111111111110000111     shift = 5
    // 0y00000001100000000001111110000100     shift = 3
    // 0y00000000000000000000001110000000     shift = 1
    // 0y00000000000000000000000110000000     shift = 1
    // 0y00000000000000000000000010000000
    // 

    chunkMask = ~Chunk;
    shiftsRemaining = RunLength;

    do {
        shift = shiftsRemaining / 2;
        chunkMask &= chunkMask >> shift;
        if (chunkMask == 0) {
            return FALSE;
        }
        shiftsRemaining -= shift;
    } while (shiftsRemaining > 1);

    BitScanForwardChunk(StartBit,chunkMask);
    return TRUE;
}


ULONG
FORCEINLINE
RtlpClearMSBInChunk (
    IN CHUNK Chunk
    )

/*++

Routine Description:

    This routine calculates the number of consecutive, clear, most significant
    bits in Chunk.

Arguments:

    The chunk to examine.

Return Value:

    The number of consecutive, most significant, clear bits in Chunk.

--*/

{
    ULONG Index;

    if (BitScanReverseChunk(&Index, Chunk) == FALSE) {
        Index = CHUNK_BITS;
    } else {
        Index = CHUNK_BITS - Index - 1;
    }
    return Index;
}


ULONG
FORCEINLINE
RtlpClearLSBInChunk (
    IN CHUNK Chunk
    )

/*++

Routine Description:

    This routine calculates the number of consecutive, clear, least
    significant bits in Chunk.

Arguments:

    The chunk to examine.

Return Value:

    The number of consecutive, most significant, clear bits in Chunk.

--*/

{
    ULONG Index;

    if (BitScanForwardChunk(&Index, Chunk) == FALSE) {
        Index = CHUNK_BITS;
    }
    return Index;
}


ULONG
FORCEINLINE
RtlpFindClearBitsRange (
    IN PULONG BitMap,
    IN ULONG NumberToFind,
    IN ULONG RangeStart,
    IN ULONG RangeEnd,
    IN LOGICAL Invert
    )

/*++

Routine Description:

    This procedure searches the specified bit map for the specified
    contiguous region of clear bits.  If a run is not found from the
    hint to the end of the bitmap, we will search again from the
    beginning of the bitmap.

Arguments:

    BitMap - Supplies a pointer to a ULONG arrayto the previously initialized BitMap.

    NumberToFind - Supplies the size of the contiguous region to find.

    RangeStart - Supplies the index (zero based) of where we should start
        the search from within the bitmap.

    RangeEnd - Supplies the index of the last possible bit to include in the
        range.

    Invert - Evaluated at compile time, if TRUE changes this routine to
        RtlpFindSetBitsRange.

Return Value:

    ULONG - Receives the starting index (zero based) of the contiguous
        region of clear bits found.  If not such a region cannot be found
        a -1 (i.e. 0xffffffff) is returned.

--*/

{
    ULONG  bitsRemaining;
    CHUNK  chunk;
    PCHUNK chunkArray;
    PCHUNK chunkPtr;
    PCHUNK clearChunkRunEnd;
    ULONG  clearChunksRequired;
    CHUNK  firstChunk;
    CHUNK  headChunkMask;
    ULONG  headClearBits;
    PCHUNK lastPossibleClearChunk;
    ULONG  lastPossibleStartBit;
    PCHUNK lastPossibleStartChunk;
    ULONG  rangeEnd;
    PCHUNK rangeStartChunk;
    PCHUNK rangeEndChunk;
    ULONG  rangeStart;
    ULONG  runStartBit;
    ULONG  tailClearBits;

    #define READ_CHUNK(n) (Invert ? ~(*(chunkPtr+(n))) : (*(chunkPtr+(n))))

    rangeStart = RangeStart;
    rangeEnd = RangeEnd;
    chunkArray = (PCHUNK)BitMap;

    if ((rangeEnd - rangeStart + 1) < NumberToFind) {
        return RTL_INVALID_INDEX;
    }

    //
    // Calculate the address of the first chunk that could contain the
    // start of a suitable run.
    // 

    rangeStartChunk = chunkArray + (rangeStart / CHUNK_BITS);

    //
    // Calculate the last possible bit and chunk at which the run must
    // begin in order to fit in the given range.
    // 

    lastPossibleStartBit = rangeEnd - NumberToFind + 1;
    lastPossibleStartChunk = chunkArray + lastPossibleStartBit / CHUNK_BITS;

    //
    // Calculate a mask of bits to apply to the first chunk.  This is used
    // to mask off bits in the first chunk that fall outside of the range.
    // 

    headChunkMask = ((CHUNK)1 << (rangeStart % CHUNK_BITS)) - 1;

    //
    // Retrieve the first chunk and mask off inelligible bits.
    // 

    chunkPtr = rangeStartChunk;
    firstChunk = READ_CHUNK(0) | headChunkMask;

    //
    // Determine which of four search algorithms to use based on the desired
    // run length.
    // 

    if (NumberToFind > (2 * CHUNK_BITS - 1)) {

        //
        // The desired run length is such that the run must include at least
        // one clear chunk.
        //
        // Search strategy:
        //
        // 1) Scan forward looking for a clear chunk.
        //    If end of range reached, search failed.
        //
        // 2) Add in number of head bits (tail clear bits in previous chunk)
        //
        // 3) Ensure remaining number of clear chunks required exist
        //    If not, go to 1
        //
        // 4) Finally check that any tail bits are clear in the last chunk
        //    If not, go to 1
        // 

        //
        // First determine the last possible clear chunk in the array.
        // If a clear chunk is not located by this point, then a suitable
        // run does not exist.
        // 

        lastPossibleClearChunk = lastPossibleStartChunk;
        if ((lastPossibleStartBit % CHUNK_BITS) != 0) {
            lastPossibleClearChunk += 1;
        }

        //
        // If the first chunk is clear, set headClearBits to zero and branch
        // into the loop, skipping the code that checks for clear bits in
        // the previous chunk.
        // 

        if (firstChunk == CHUNK_CLEAR) {
            headClearBits = 0;
            goto largeLoopEntry;
        }
        chunkPtr += 1;

        //
        // If the second chunk is clear, set headClearBits according to
        // firstChunk (which contains the masked value of the first chunk).
        //

        if (READ_CHUNK(0) == CHUNK_CLEAR) {
            headClearBits = RtlpClearMSBInChunk(firstChunk);
            goto largeLoopEntry;
        }

        //
        // Scan forward looking for an all-zero chunk
        //

        while (TRUE) {

findRunStartLarge:

            if (chunkPtr > lastPossibleClearChunk) {
                return RTL_INVALID_INDEX;
            }

            chunkPtr += 1;

            if (READ_CHUNK(0) == CHUNK_CLEAR) {
                break;
            }
        }

        //
        // An all-zero chunk has been located, record this as the
        // potential start of a clear run, backing up by
        // the number of clear tail bits in the previous chunk.
        //

        headClearBits = RtlpClearMSBInChunk(READ_CHUNK(-1));

largeLoopEntry:

        runStartBit = (ULONG)((chunkPtr - chunkArray) * CHUNK_BITS);
        runStartBit -= headClearBits;

        if (runStartBit > lastPossibleStartBit) {
            return RTL_INVALID_INDEX;
        }

        //
        // Calculate how many clear chunks are needed in this potential
        // run.
        // 

        clearChunksRequired =
            (NumberToFind - headClearBits) / CHUNK_BITS;

        clearChunkRunEnd = chunkPtr + clearChunksRequired;

        //
        // We know we've got at least one chunk's worth of clear bits.
        // Make sure any necessary remaining chunks are zero as well.
        //

        chunkPtr += 1;
        while (chunkPtr != clearChunkRunEnd) {

            if (READ_CHUNK(0) != CHUNK_CLEAR) {

                //
                // This run isn't long enough.  Look for the start of
                // another run.
                //

                goto findRunStartLarge;
            }
            chunkPtr += 1;
        }

        //
        // Finally, calculate the needed number of bits in the tail and make
        // sure they are clear as well.
        // 

        tailClearBits = (NumberToFind - headClearBits) % CHUNK_BITS;
        if (tailClearBits != 0) {

            if (RtlpClearLSBInChunk(READ_CHUNK(0)) < tailClearBits) {

                //
                // Not enough bits in the last partial chunk.
                //

                goto findRunStartLarge;
            }
        }

        //
        // A suitable run has been found.  runStartBit is the index of the
        // first bit in the run, relative to chunkArray.
        // 

    } else if (NumberToFind >= CHUNK_BITS) {

        //
        // The sought run does not necessarily include a clear chunk.  It may
        // consume one chunk, or may span 2 or 3 chunks.
        //
        // Again, special case the first chunk as it has been masked.
        //
        // Search strategy:
        //
        // 1) Scan forward looking for a chunk with 1 or more clear tail bits
        //    If end of range reached, search failed.
        //
        // 2) Check for any additional necessary clear bits.
        //    If not found, go to 1
        //

        chunk = firstChunk;
        while (TRUE) {

            //
            // Look for a chunk that has at least one clear tail bit.
            //

            while (TRUE) {

                if ((chunk & CHUNK_HIGH_BIT) == 0) {
                    break;
                }
    
                chunkPtr += 1;

                if (chunkPtr > lastPossibleStartChunk) {
                    return RTL_INVALID_INDEX;
                }

                chunk = READ_CHUNK(0);
            }

            //
            // This chunk has some bits that can be used as the head portion
            // of the run.  Record the start of this potentially suitable
            // bit run.
            //
    
            headClearBits = RtlpClearMSBInChunk(chunk);
            runStartBit = (ULONG)((chunkPtr - chunkArray) * CHUNK_BITS);
            runStartBit += CHUNK_BITS - headClearBits;
            if (runStartBit > lastPossibleStartBit) {
                return RTL_INVALID_INDEX;
            }
    
            //
            // If bitsRemaining indicate that a clear chunk is needed next,
            // check for that.
            // 

            ASSERT(NumberToFind >= headClearBits);

            bitsRemaining = NumberToFind - headClearBits;
            if (bitsRemaining == 0) {
                break;
            }

            chunkPtr += 1;
            chunk = READ_CHUNK(0);

            if (bitsRemaining >= CHUNK_BITS) {

                if (chunk != CHUNK_CLEAR) {
                    continue;
                }

                bitsRemaining -= CHUNK_BITS;
                if (bitsRemaining == 0) {
                    break;
                }

                chunkPtr += 1;
                chunk = READ_CHUNK(0);
            }

            tailClearBits = RtlpClearLSBInChunk(chunk);
            if (tailClearBits >= bitsRemaining) {
                break;
            }
        }

    } else if (NumberToFind > 1) {

        //
        // NumberToFind is < CHUNK_BITS, and so could span two chunks or
        // lie anywhere within a chunk.
        //
        // Search strategy:
        //
        // 1) Scan forward looking for a chunk != CHUNK_SET.
        //    If end of range reached, search failed.
        //
        // 2) If the current chunk contains clear head bits, determine
        //    whether those combined with any clear tail bits from the
        //    previous chunk result in a suitable run.
        //    If so, search succeeds.
        //
        // 3) Search within the chunk for the first suitable run of clear
        //    bits.  If found, search succeeds.
        //
        // 4) Record the number of clear tail bits in the chunk, go to 1.
        //

        //
        // We'll use tailClearBits to track the clear MSB bits in the
        // last chunk we've examined.
        //

        tailClearBits = 0;
        rangeEndChunk = chunkArray + (rangeEnd / CHUNK_BITS);

        //
        // As always, start with a masked initial chunk.
        //

        chunk = firstChunk;
        while (TRUE) {

            //
            // Look for a chunk that has some clear bits.
            //

            if (chunk == CHUNK_SET) {
                do {
                    chunkPtr += 1;
                    if (chunkPtr > lastPossibleStartChunk) {
                        return RTL_INVALID_INDEX;
                    }
                    chunk = READ_CHUNK(0);
                } while (chunk == CHUNK_SET);

                tailClearBits = 0;
            }

            headClearBits = RtlpClearLSBInChunk(chunk);
            if ((headClearBits + tailClearBits) >= NumberToFind) {
    
                runStartBit = 0-tailClearBits;
    
            } else {
    
                //
                // The chunk does not start with a run of clear bits,
                // determine whether a suitable run is embedded within the
                // chunk.
                //
    
                if (RtlpFindClearRunInChunk(chunk,
                                            NumberToFind,
                                            &runStartBit) == FALSE) {
    
                    //
                    // The chunk does not contain a suitable run of clear
                    // bits.  If this is the last chunk in the range,
                    // then a suitable run does not exist.
                    //

                    if (chunkPtr == rangeEndChunk) {
                        return RTL_INVALID_INDEX;
                    }

                    //
                    // Record the number of clear tail bits in this chunk.
                    // 

                    tailClearBits = RtlpClearMSBInChunk(chunk);

                    chunkPtr += 1;
                    chunk = READ_CHUNK(0);
                    continue;
                }
            }

            runStartBit += (ULONG)((chunkPtr - chunkArray) * CHUNK_BITS);

            if (runStartBit > lastPossibleStartBit) {
                return RTL_INVALID_INDEX;
            } else {
                break;
            }
        }

    } else {

        //
        // NumberToFind == 1.  Just find a chunk that isn't all ones,
        // then find the first clear bit in the chunk.
        //

        chunk = firstChunk;

        while (chunk == CHUNK_SET) {
            chunkPtr += 1;
            if (chunkPtr > lastPossibleStartChunk) {
                return RTL_INVALID_INDEX;
            }
            chunk = READ_CHUNK(0);
        }

        BitScanForwardChunk(&runStartBit,~chunk);
        runStartBit += (ULONG)((chunkPtr - chunkArray) * CHUNK_BITS);
        if (runStartBit > lastPossibleStartBit) {
            return RTL_INVALID_INDEX;
        }
    }

    //
    // At this point, a suitable run has been found.  runStartBit represents
    // the bit offset of the start of the run, relative to chunkArray.
    //

    return runStartBit;
}



ULONG
RtlFindClearBits (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG NumberToFind,
    IN ULONG HintIndex
    )

/*++

Routine Description:

    This procedure searches the specified bit map for the specified
    contiguous region of clear bits.  If a run is not found from the
    hint to the end of the bitmap, we will search again from the
    beginning of the bitmap.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    NumberToFind - Supplies the size of the contiguous region to find.

    HintIndex - Supplies the index (zero based) of where we should start
        the search from within the bitmap.

Return Value:

    ULONG - Receives the starting index (zero based) of the contiguous
        region of clear bits found.  If not such a region cannot be found
        a -1 (i.e. 0xffffffff) is returned.

--*/

{
    ULONG BitIndex;
    ULONG SizeOfBitMap;
    ULONG RangeEnd;
    ULONG RangeStart;
    PULONG Buffer;
    ULONG BufferAdjust;
    ULONG BufferAdjustBits;

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    if (HintIndex >= SizeOfBitMap) {
        RangeStart = 0;
    } else {
        RangeStart = HintIndex;
    }
    RangeEnd = SizeOfBitMap - 1;
    Buffer = BitMapHeader->Buffer;

    //
    // Special case zero-length bitmap routines, to return the same value
    // as the old bitmap routines would.
    // 

    if (NumberToFind == 0) {
        return RangeStart & ~7;
    }

#if defined(_WIN64)

    //
    // RTL_BITMAP contains a buffer that is merely DWORD aligned.  On 64-bit
    // platforms a QWORD aligned buffer is required.  If necessary, align
    // the buffer pointer down and adjust the range bit offsets accordingly.
    //

    if (((ULONG_PTR)Buffer & 0x4) != 0) {
        BufferAdjust = 1;
        BufferAdjustBits = 32;
    } else

#endif
    {
        BufferAdjust = 0;
        BufferAdjustBits = 0;
    }

    while (TRUE) {

        BitIndex = RtlpFindClearBitsRange(Buffer - BufferAdjust,
                                          NumberToFind,
                                          RangeStart + BufferAdjustBits,
                                          RangeEnd + BufferAdjustBits,
                                          FALSE);

        if ((BitIndex != RTL_INVALID_INDEX) || (RangeStart == 0)) {
            break;
        }

        RangeEnd = HintIndex + NumberToFind;
        if (RangeEnd > SizeOfBitMap) {
            RangeEnd = SizeOfBitMap;
        }
        RangeEnd -= 1;
        RangeStart = 0;
    }

#if defined(_WIN64)

    //
    // Compensate for any buffer alignment performed above.
    //

    if (BitIndex != RTL_INVALID_INDEX) {
        BitIndex -= BufferAdjustBits;
    }

#endif

    return BitIndex;
}



ULONG
RtlFindSetBits (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG NumberToFind,
    IN ULONG HintIndex
    )

/*++

Routine Description:

    This procedure searches the specified bit map for the specified
    contiguous region of set bits.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    NumberToFind - Supplies the size of the contiguous region to find.

    HintIndex - Supplies the index (zero based) of where we should start
        the search from within the bitmap.

Return Value:

    ULONG - Receives the starting index (zero based) of the contiguous
        region of set bits found.  If such a region cannot be found then
        a -1 (i.e., 0xffffffff) is returned.

--*/

{
    ULONG BitIndex;
    ULONG SizeOfBitMap;
    ULONG RangeEnd;
    ULONG RangeStart;
    PULONG Buffer;
    ULONG BufferAdjust;
    ULONG BufferAdjustBits;

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    if (HintIndex >= SizeOfBitMap) {
        RangeStart = 0;
    } else {
        RangeStart = HintIndex;
    }
    RangeEnd = SizeOfBitMap - 1;
    Buffer = BitMapHeader->Buffer;

    //
    // Special case zero-length bitmap routines, to return the same value
    // as the old bitmap routines would.
    // 

    if (NumberToFind == 0) {
        return RangeStart & ~7;
    }

#if defined(_WIN64)

    //
    // RTL_BITMAP contains a buffer that is merely DWORD aligned.  On 64-bit
    // platforms a QWORD aligned buffer is required.  If necessary, align
    // the buffer pointer down and adjust the range bit offsets accordingly.
    //

    if (((ULONG_PTR)Buffer & 0x4) != 0) {
        BufferAdjust = 1;
        BufferAdjustBits = 32;
    } else

#endif
    {
        BufferAdjust = 0;
        BufferAdjustBits = 0;
    }

    while (TRUE) {

        BitIndex = RtlpFindClearBitsRange(Buffer - BufferAdjust,
                                          NumberToFind,
                                          RangeStart + BufferAdjustBits,
                                          RangeEnd + BufferAdjustBits,
                                          TRUE);

        if ((BitIndex != RTL_INVALID_INDEX) || (RangeStart == 0)) {
            break;
        }

        RangeEnd = HintIndex + NumberToFind;
        if (RangeEnd > SizeOfBitMap) {
            RangeEnd = SizeOfBitMap;
        }
        RangeEnd -= 1;
        RangeStart = 0;
    }

#if defined(_WIN64)

    //
    // Compensate for any buffer alignment performed above.
    //

    if (BitIndex != RTL_INVALID_INDEX) {
        BitIndex -= BufferAdjustBits;
    }

#endif

    return BitIndex;
}


ULONG
RtlFindClearBitsAndSet (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG NumberToFind,
    IN ULONG HintIndex
    )

/*++

Routine Description:

    This procedure searches the specified bit map for the specified
    contiguous region of clear bits, sets the bits and returns the
    number of bits found, and the starting bit number which was clear
    then set.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    NumberToFind - Supplies the size of the contiguous region to find.

    HintIndex - Supplies the index (zero based) of where we should start
        the search from within the bitmap.

Return Value:

    ULONG - Receives the starting index (zero based) of the contiguous
        region found.  If such a region cannot be located a -1 (i.e.,
        0xffffffff) is returned.

--*/

{
    ULONG StartingIndex;

    //
    //  First look for a run of clear bits that equals the size requested
    //

    StartingIndex = RtlFindClearBits( BitMapHeader,
                                      NumberToFind,
                                      HintIndex );

    if (StartingIndex != 0xffffffff) {

        //
        //  We found a large enough run of clear bits so now set them
        //

        RtlSetBits( BitMapHeader, StartingIndex, NumberToFind );
    }

    //
    //  And return to our caller
    //

    return StartingIndex;

}


ULONG
RtlFindSetBitsAndClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG NumberToFind,
    IN ULONG HintIndex
    )

/*++

Routine Description:

    This procedure searches the specified bit map for the specified
    contiguous region of set bits, clears the bits and returns the
    number of bits found and the starting bit number which was set then
    clear.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    NumberToFind - Supplies the size of the contiguous region to find.

    HintIndex - Supplies the index (zero based) of where we should start
        the search from within the bitmap.

Return Value:

    ULONG - Receives the starting index (zero based) of the contiguous
        region found.  If such a region cannot be located a -1 (i.e.,
        0xffffffff) is returned.


--*/

{
    ULONG StartingIndex;

    //
    //  First look for a run of set bits that equals the size requested
    //

    if ((StartingIndex = RtlFindSetBits( BitMapHeader,
                                         NumberToFind,
                                         HintIndex )) != 0xffffffff) {

        //
        //  We found a large enough run of set bits so now clear them
        //

        RtlClearBits( BitMapHeader, StartingIndex, NumberToFind );
    }

    //
    //  And return to our caller
    //

    return StartingIndex;
}


VOID
RtlClearBits (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG StartingIndex,
    IN ULONG NumberToClear
    )

/*++

Routine Description:

    This procedure clears the specified range of bits within the
    specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized Bit Map.

    StartingIndex - Supplies the index (zero based) of the first bit to clear.

    NumberToClear - Supplies the number of bits to clear.

Return Value:

    None.

--*/

{
    PCHAR CurrentByte;
    ULONG BitOffset;

    ASSERT( StartingIndex + NumberToClear <= BitMapHeader->SizeOfBitMap );

    //
    //  Special case the situation where the number of bits to clear is
    //  zero.  Turn this into a noop.
    //

    if (NumberToClear == 0) {

        return;
    }

    //
    //  Get a pointer to the first byte that needs to be cleared.
    //

    CurrentByte = ((PCHAR) BitMapHeader->Buffer) + (StartingIndex / 8);

    //
    //  If all the bit's we're setting are in the same byte just do it and
    //  get out.
    //

    BitOffset = StartingIndex % 8;
    if ((BitOffset + NumberToClear) <= 8) {

        *CurrentByte &= ~(FillMask[ NumberToClear ] << BitOffset);

    }  else {

        //
        //  Do the first byte manually because the first bit may not be byte aligned.
        //
        //  Note:   The first longword will always be cleared byte wise to simplify the
        //          logic of checking for short copies (<32 bits).
        //

        if (BitOffset > 0) {

            *CurrentByte &= FillMask[ BitOffset ];
            CurrentByte += 1;
            NumberToClear -= 8 - BitOffset;

        }

        //
        //  Fill the full bytes in the middle.  Use the RtlZeroMemory() because its
        //  going to be hand tuned asm code spit out by the compiler.
        //

        if (NumberToClear > 8) {

            RtlZeroMemory( CurrentByte, NumberToClear / 8 );
            CurrentByte += NumberToClear / 8;
            NumberToClear %= 8;

        }

        //
        //  Clear the remaining bits, if there are any, in the last byte.
        //

        if (NumberToClear > 0) {

            *CurrentByte &= ZeroMask[ NumberToClear ];

        }

    }

    //
    //  And return to our caller
    //

    return;
}

VOID
RtlSetBits (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG StartingIndex,
    IN ULONG NumberToSet
    )

/*++

Routine Description:

    This procedure sets the specified range of bits within the
    specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    StartingIndex - Supplies the index (zero based) of the first bit to set.

    NumberToSet - Supplies the number of bits to set.

Return Value:

    None.

--*/
{
    PCHAR CurrentByte;
    ULONG BitOffset;

    ASSERT( StartingIndex + NumberToSet <= BitMapHeader->SizeOfBitMap );

    //
    //  Special case the situation where the number of bits to set is
    //  zero.  Turn this into a noop.
    //

    if (NumberToSet == 0) {

        return;
    }

    //
    //  Get a pointer to the first byte that needs to be set.
    //

    CurrentByte = ((PCHAR) BitMapHeader->Buffer) + (StartingIndex / 8);

    //
    //  If all the bit's we're setting are in the same byte just do it and
    //  get out.
    //

    BitOffset = StartingIndex % 8;
    if ((BitOffset + NumberToSet) <= 8) {

        *CurrentByte |= (FillMask[ NumberToSet ] << BitOffset);

    } else {

        //
        //  Do the first byte manually because the first bit may not be byte aligned.
        //
        //  Note:   The first longword will always be set byte wise to simplify the
        //          logic of checking for short copies (<32 bits).
        //

        if (BitOffset > 0) {

            *CurrentByte |= ZeroMask[ BitOffset ];
            CurrentByte += 1;
            NumberToSet -= 8 - BitOffset;

        }

        //
        //  Fill the full bytes in the middle.  Use the RtlFillMemory() because its
        //  going to be hand tuned asm code spit out by the compiler.
        //

        if (NumberToSet > 8) {

            RtlFillMemory( CurrentByte, NumberToSet / 8, 0xff );
            CurrentByte += NumberToSet / 8;
            NumberToSet %= 8;

        }

        //
        //  Set the remaining bits, if there are any, in the last byte.
        //

        if (NumberToSet > 0) {

            *CurrentByte |= FillMask[ NumberToSet ];

        }

    }

    //
    //  And return to our caller
    //

    return;
}


#if DBG
BOOLEAN NtfsDebugIt = FALSE;
#endif

ULONG
RtlFindClearRuns (
    IN PRTL_BITMAP BitMapHeader,
    PRTL_BITMAP_RUN RunArray,
    ULONG SizeOfRunArray,
    BOOLEAN LocateLongestRuns
    )

/*++

Routine Description:

    This procedure finds N contiguous runs of clear bits
    within the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    RunArray - Receives the bit position, and length of each of the free runs
        that the procedure locates.  The array will be sorted according to
        length.

    SizeOfRunArray - Supplies the maximum number of entries the caller wants
        returned in RunArray

    LocateLongestRuns - Indicates if this routine is to return the longest runs
        it can find or just the first N runs.


Return Value:

    ULONG - Receives the number of runs that the procedure has located and
        returned in RunArray

--*/

{
    ULONG RunIndex;
    ULONG i;
    LONG j;

    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG CurrentRunSize;
    ULONG CurrentRunIndex;
    ULONG CurrentByteIndex;
    UCHAR CurrentByte;

    UCHAR BitMask;
    UCHAR TempNumber;

    GET_BYTE_DECLARATIONS();

    //
    //  Reference the bitmap header to make the loop run faster
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  Set any unused bits in the last byte so we won't count them.  We do
    //  this by first checking if there is any odd bits in the last byte.
    //

    if ((SizeOfBitMap % 8) != 0) {

        //
        //  The last byte has some odd bits so we'll set the high unused
        //  bits in the last byte to 1's
        //

        ((PUCHAR)BitMapHeader->Buffer)[SizeInBytes - 1] |= ZeroMask[SizeOfBitMap % 8];
    }

    //
    //  Set it up so we can the use GET_BYTE macro
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, 0);

    //
    //  Set our RunIndex and current run variables.  Run Index allays is the index
    //  of the next location to fill in or it could be one beyond the end of the
    //  array.
    //

    RunIndex = 0;
    for (i = 0; i < SizeOfRunArray; i += 1) { RunArray[i].NumberOfBits = 0; }

    CurrentRunSize = 0;
    CurrentRunIndex = 0;

    //
    //  Examine every byte in the BitMap
    //

    for (CurrentByteIndex = 0;
         CurrentByteIndex < SizeInBytes;
         CurrentByteIndex += 1) {

        GET_BYTE( CurrentByte );

#if DBG
        if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx\n",__LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte); }
#endif

        //
        //  If the current byte is not all zeros we need to (1) check if
        //  the current run is big enough to be inserted in the output
        //  array, and (2) check if the current byte inside of itself can
        //  be inserted, and (3) start a new current run
        //

        if (CurrentByte != 0x00) {

            //
            //  Compute the final size of the current run
            //

            CurrentRunSize += RtlpBitsClearLow[CurrentByte];

            //
            //  Check if the current run be stored in the output array by either
            //  there being room in the array or the last entry is smaller than
            //  the current entry
            //

            if (CurrentRunSize > 0) {

                if ((RunIndex < SizeOfRunArray) ||
                    (RunArray[RunIndex-1].NumberOfBits < CurrentRunSize)) {

                    //
                    //  If necessary increment the RunIndex and shift over the output
                    //  array until we find the slot where the new run belongs.  We only
                    //  do the shifting if we're returning longest runs.
                    //

                    if (RunIndex < SizeOfRunArray) { RunIndex += 1; }

                    for (j = RunIndex-2; LocateLongestRuns && (j >= 0) && (RunArray[j].NumberOfBits < CurrentRunSize); j -= 1) {

                        RunArray[j+1] = RunArray[j];
                    }

                    RunArray[j+1].NumberOfBits = CurrentRunSize;
                    RunArray[j+1].StartingIndex = CurrentRunIndex;

#if DBG
                    if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                        __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
#endif

                    //
                    //  Now if the array is full and we are not doing longest runs return
                    //  to our caller
                    //

                    if (!LocateLongestRuns && (RunIndex >= SizeOfRunArray)) {

                        return RunIndex;
                    }
                }
            }

            //
            //  The next run starts with the remaining clear bits in the
            //  current byte.  We set this up before we check inside the
            //  current byte for a longer run, because the latter test
            //  might require extra work.
            //

            CurrentRunSize = RtlpBitsClearHigh[ CurrentByte ];
            CurrentRunIndex = (CurrentByteIndex * 8) + (8 - CurrentRunSize);

            //
            //  Set the low and high bits, otherwise we'll wind up thinking that we have a
            //  small run that needs to get added to the array, but these bits have
            //  just been accounting for
            //

            CurrentByte |= FillMask[RtlpBitsClearLow[CurrentByte]] |
                           ZeroMask[8-RtlpBitsClearHigh[CurrentByte]];

            //
            //  Check if the current byte contains a run inside of it that
            //  should go into the output array.  There may be multiple
            //  runs in the byte that we need to insert.
            //

            while ((CurrentByte != 0xff)

                        &&

                   ((RunIndex < SizeOfRunArray) ||
                    (RunArray[RunIndex-1].NumberOfBits < (ULONG)RtlpBitsClearAnywhere[CurrentByte]))) {

                TempNumber = RtlpBitsClearAnywhere[CurrentByte];

                //
                //  Somewhere in the current byte is a run to be inserted of
                //  size TempNumber.  All we need to do is find the index for this run.
                //

                BitMask = FillMask[ TempNumber ];

                for (i = 0; (BitMask & CurrentByte) != 0; i += 1) {

                    BitMask <<= 1;
                }

                //
                //  If necessary increment the RunIndex and shift over the output
                //  array until we find the slot where the new run belongs.  We only
                //  do the shifting if we're returning longest runs.
                //

                if (RunIndex < SizeOfRunArray) { RunIndex += 1; }

                for (j = RunIndex-2; LocateLongestRuns && (j >= 0) && (RunArray[j].NumberOfBits < TempNumber); j -= 1) {

                    RunArray[j+1] = RunArray[j];
                }

                RunArray[j+1].NumberOfBits = TempNumber;
                RunArray[j+1].StartingIndex = (CurrentByteIndex * 8) + i;

#if DBG
                if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                    __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
#endif

                //
                //  Now if the array is full and we are not doing longest runs return
                //  to our caller
                //

                if (!LocateLongestRuns && (RunIndex >= SizeOfRunArray)) {

                    return RunIndex;
                }

                //
                //  Mask out the bits and look for another run in the current byte
                //

                CurrentByte |= BitMask;
            }

        //
        //  Otherwise the current byte is all zeros and
        //  we simply continue with the current run
        //

        } else {

            CurrentRunSize += 8;
        }
    }

#if DBG
    if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx\n",__LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte); }
#endif

    //
    //  See if we finished looking over the bitmap with an open current
    //  run that should be inserted in the output array
    //

    if (CurrentRunSize > 0) {

        if ((RunIndex < SizeOfRunArray) ||
            (RunArray[RunIndex-1].NumberOfBits < CurrentRunSize)) {

            //
            //  If necessary increment the RunIndex and shift over the output
            //  array until we find the slot where the new run belongs.
            //

            if (RunIndex < SizeOfRunArray) { RunIndex += 1; }

            for (j = RunIndex-2; LocateLongestRuns && (j >= 0) && (RunArray[j].NumberOfBits < CurrentRunSize); j -= 1) {

                RunArray[j+1] = RunArray[j];
            }

            RunArray[j+1].NumberOfBits = CurrentRunSize;
            RunArray[j+1].StartingIndex = CurrentRunIndex;

#if DBG
            if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
#endif
        }
    }

    //
    //  Return to our caller
    //

    return RunIndex;
}


ULONG
RtlFindLongestRunClear (
    IN PRTL_BITMAP BitMapHeader,
    OUT PULONG StartingIndex
    )

/*++

Routine Description:

    This procedure finds the largest contiguous range of clear bits
    within the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    StartingIndex - Receives the index (zero based) of the first run
        equal to the longest run of clear bits in the BitMap.

Return Value:

    ULONG - Receives the number of bits contained in the largest contiguous
        run of clear bits.

--*/

{
    RTL_BITMAP_RUN RunArray[1];

    //
    //  Locate the longest run in the bitmap.  If there is one then
    //  return that run otherwise return the error condition.
    //

    if (RtlFindClearRuns( BitMapHeader, RunArray, 1, TRUE ) == 1) {

        *StartingIndex = RunArray[0].StartingIndex;
        return RunArray[0].NumberOfBits;
    }

    *StartingIndex = 0;
    return 0;
}


ULONG
RtlFindFirstRunClear (
    IN PRTL_BITMAP BitMapHeader,
    OUT PULONG StartingIndex
    )

/*++

Routine Description:

    This procedure finds the first contiguous range of clear bits
    within the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    StartingIndex - Receives the index (zero based) of the first run
        equal to the longest run of clear bits in the BitMap.

Return Value:

    ULONG - Receives the number of bits contained in the first contiguous
        run of clear bits.

--*/

{
    return RtlFindNextForwardRunClear(BitMapHeader, 0, StartingIndex);
}


#define GET_CHUNK(THIS_CHUNK) {                     \
    THIS_CHUNK = *((CHUNK *)_CURRENT_POSITION);     \
    _CURRENT_POSITION += sizeof(CHUNK); }

#if defined(_WIN64)


FORCEINLINE
ULONG
RtlpNumberOfSetBitsInChunk (
    IN CHUNK Target
    )

/*++

Routine Description:

    This procedure counts and returns the number of set bits within
    a the chunk.

Arguments:

    Target - The integer containing the bits to be counted.

Return Value:

    ULONG - The total number of set bits in Target.
           
--*/

{
    //
    // The following algorithm was taken from the AMD publication
    // "Software Optimization Guide for the AMD Hammer Processor",
    // revision 1.19, section 8.6.
    //

    //
    // First break the chunk up into a set of two-bit fields, each field
    // representing the count of set bits.  Each field undergoes the
    // following transformation:
    //
    // 00b -> 00b
    // 01b -> 01b
    // 10b -> 01b
    // 11b -> 10b
    // 

    Target -= (Target >> 1) & 0x5555555555555555;

    //
    // Next, combine the totals in adjacent two-bit fields into a four-bit
    // field.
    // 

    Target = (Target & 0x3333333333333333) +
             ((Target >> 2) & 0x3333333333333333);

    //
    // Now, combine adjacent four-bit fields to end up with a set of 8-bit
    // totals.
    //

    Target = (Target + (Target >> 4)) & 0x0F0F0F0F0F0F0F0F;

    //
    // Finally, sum all of the 8-bit totals.  The result will be the
    // number of bits that were set in Target.
    //

    Target = (Target * 0x0101010101010101) >> 56;
    return (ULONG)Target;
}

#else


FORCEINLINE
ULONG
RtlpNumberOfSetBitsInChunk (
    IN CHUNK Target
    )

/*++

Routine Description:

    This procedure counts and returns the number of set bits within
    a the chunk.

Arguments:

    Target - The integer containing the bits to be counted.

Return Value:

    ULONG - The total number of set bits in Target.
           
--*/

{
    UCHAR setBits;

    Target = ~Target;
    setBits  = RtlpBitsClearTotal[ (UCHAR)Target ];
    Target >>= 8;

    setBits += RtlpBitsClearTotal[ (UCHAR)Target ];
    Target >>= 8;

    setBits += RtlpBitsClearTotal[ (UCHAR)Target ];
    Target >>= 8;

    setBits += RtlpBitsClearTotal[ Target ];
    return setBits;
}

#endif

ULONG
RtlNumberOfSetBits (
    IN PRTL_BITMAP BitMapHeader
    )

/*++

Routine Description:

    This procedure counts and returns the number of set bits within
    the specified bitmap.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bitmap.

Return Value:

    ULONG - The total number of set bits in the bitmap

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    UCHAR CurrentByte;
    CHUNK Chunk;

    ULONG BytesHead;
    ULONG BytesMiddle;
    ULONG BytesTail;

    ULONG TotalSet;

    GET_BYTE_DECLARATIONS();

    //
    //  Reference the bitmap header to make the loop run faster
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  Clear any unused bits in the last byte so we don't count them.  We
    //  do this by first checking if there are any odd bits in the last byte
    //

    if ((SizeOfBitMap % 8) != 0) {

        //
        //  The last byte has some odd bits so we'll set the high unused
        //  bits in the last byte to 0's
        //

        ((PUCHAR)BitMapHeader->Buffer)[SizeInBytes - 1] &=
                                                    FillMask[SizeOfBitMap % 8];
    }

    //
    //  Set if up so we can use the GET_BYTE macro
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, 0 );

    //
    //  Examine every byte in the bitmap.  The head and tail portions,
    //  if any, are examined byte-wise while the middle portion is processed
    //  8 bytes at a time.
    //

    TotalSet= 0;
    BytesHead = (ULONG)(-(LONG_PTR)BitMapHeader->Buffer & (sizeof(CHUNK)-1));
    BytesTail = (SizeInBytes - BytesHead) % sizeof(ULONG64);
    BytesMiddle = SizeInBytes - (BytesHead + BytesTail);

    while (BytesHead > 0) {

        GET_BYTE( CurrentByte );
        TotalSet += RtlpBitsSetTotal(CurrentByte);
        BytesHead -= 1;
    }

    while (BytesMiddle > 0) {

        GET_CHUNK( Chunk );
        TotalSet += RtlpNumberOfSetBitsInChunk( Chunk );
        BytesMiddle -= sizeof(CHUNK);
    }

    while (BytesTail > 0) {

        GET_BYTE( CurrentByte );
        TotalSet += RtlpBitsSetTotal(CurrentByte);
        BytesTail -= 1;
    }

    return TotalSet;
}


ULONG
RtlNumberOfClearBits (
    IN PRTL_BITMAP BitMapHeader
    )

/*++

Routine Description:

    This procedure counts and returns the number of clears bits within
    the specified bitmap.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bitmap.

Return Value:

    ULONG - The total number of clear bits in the bitmap

--*/

{
    return BitMapHeader->SizeOfBitMap - RtlNumberOfSetBits( BitMapHeader );
}



BOOLEAN
RtlAreBitsClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG StartingIndex,
    IN ULONG Length
    )

/*++

Routine Description:

    This procedure determines if the range of specified bits are all clear.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bitmap.

    StartingIndex - Supplies the starting bit index to examine

    Length - Supplies the number of bits to examine

Return Value:

    BOOLEAN - TRUE if the specified bits in the bitmap are all clear, and
        FALSE if any are set or if the range is outside the bitmap or if
        Length is zero.

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG EndingIndex;

    ULONG StartingByte;
    ULONG EndingByte;

    ULONG StartingOffset;
    ULONG EndingOffset;

    ULONG i;
    UCHAR Byte;

    GET_BYTE_DECLARATIONS();

    //
    //  To make the loops in our test run faster we'll extract the fields
    //  from the bitmap header
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  First make sure that the specified range is contained within the
    //  bitmap, and the length is not zero.
    //

    if ((StartingIndex + Length > SizeOfBitMap) || (Length == 0)) {

        return FALSE;
    }

    //
    //  Compute the ending index, starting and ending byte, and the starting
    //  and ending offset within each byte
    //

    EndingIndex = StartingIndex + Length - 1;

    StartingByte = StartingIndex / 8;
    EndingByte = EndingIndex / 8;

    StartingOffset = StartingIndex % 8;
    EndingOffset = EndingIndex % 8;

    //
    //  Set ourselves up to get the next byte
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, StartingByte );

    //
    //  Special case the situation where the starting byte and ending
    //  byte are one in the same
    //

    if (StartingByte == EndingByte) {

        //
        //  Get the single byte we are to look at
        //

        GET_BYTE( Byte );

        //
        //  Now we compute the mask of bits we're after and then AND it with
        //  the byte.  If it is zero then the bits in question are all clear
        //  otherwise at least one of them is set.
        //

        if ((ZeroMask[StartingOffset] & FillMask[EndingOffset+1] & Byte) == 0) {

            return TRUE;

        } else {

            return FALSE;
        }

    } else {

        //
        //  Get the first byte that we're after, and then
        //  compute the mask of bits we're after for the first byte then
        //  AND it with the byte itself.
        //

        GET_BYTE( Byte );

        if ((ZeroMask[StartingOffset] & Byte) != 0) {

            return FALSE;
        }

        //
        //  Now for every whole byte inbetween read in the byte,
        //  and make sure it is all zeros
        //

        for (i = StartingByte+1; i < EndingByte; i += 1) {

            GET_BYTE( Byte );

            if (Byte != 0) {

                return FALSE;
            }
        }

        //
        //  Get the last byte we're after, and then
        //  compute the mask of bits we're after for the last byte then
        //  AND it with the byte itself.
        //

        GET_BYTE( Byte );

        if ((FillMask[EndingOffset+1] & Byte) != 0) {

            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
RtlAreBitsSet (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG StartingIndex,
    IN ULONG Length
    )

/*++

Routine Description:

    This procedure determines if the range of specified bits are all set.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bitmap.

    StartingIndex - Supplies the starting bit index to examine

    Length - Supplies the number of bits to examine

Return Value:

    BOOLEAN - TRUE if the specified bits in the bitmap are all set, and
        FALSE if any are clear or if the range is outside the bitmap or if
        Length is zero.

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG EndingIndex;

    ULONG StartingByte;
    ULONG EndingByte;

    ULONG StartingOffset;
    ULONG EndingOffset;

    ULONG i;
    UCHAR Byte;

    GET_BYTE_DECLARATIONS();

    //
    //  To make the loops in our test run faster we'll extract the fields
    //  from the bitmap header
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  First make sure that the specified range is contained within the
    //  bitmap, and the length is not zero.
    //

    if ((StartingIndex + Length > SizeOfBitMap) || (Length == 0)) {

        return FALSE;
    }

    //
    //  Compute the ending index, starting and ending byte, and the starting
    //  and ending offset within each byte
    //

    EndingIndex = StartingIndex + Length - 1;

    StartingByte = StartingIndex / 8;
    EndingByte = EndingIndex / 8;

    StartingOffset = StartingIndex % 8;
    EndingOffset = EndingIndex % 8;

    //
    //  Set ourselves up to get the next byte
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, StartingByte );

    //
    //  Special case the situation where the starting byte and ending
    //  byte are one in the same
    //

    if (StartingByte == EndingByte) {

        //
        //  Get the single byte we are to look at
        //

        GET_BYTE( Byte );

        //
        //  Now we compute the mask of bits we're after and then AND it with
        //  the complement of the byte If it is zero then the bits in question
        //  are all clear otherwise at least one of them is clear.
        //

        if ((ZeroMask[StartingOffset] & FillMask[EndingOffset+1] & ~Byte) == 0) {

            return TRUE;

        } else {

            return FALSE;
        }

    } else {

        //
        //  Get the first byte that we're after, and then
        //  compute the mask of bits we're after for the first byte then
        //  AND it with the complement of the byte itself.
        //

        GET_BYTE( Byte );

        if ((ZeroMask[StartingOffset] & ~Byte) != 0) {

            return FALSE;
        }

        //
        //  Now for every whole byte inbetween read in the byte,
        //  and make sure it is all ones
        //

        for (i = StartingByte+1; i < EndingByte; i += 1) {

            GET_BYTE( Byte );

            if (Byte != 0xff) {

                return FALSE;
            }
        }

        //
        //  Get the last byte we're after, and then
        //  compute the mask of bits we're after for the last byte then
        //  AND it with the complement of the byte itself.
        //

        GET_BYTE( Byte );

        if ((FillMask[EndingOffset+1] & ~Byte) != 0) {

            return FALSE;
        }
    }

    return TRUE;
}

static CONST ULONG FillMaskUlong[] = {
    0x00000000, 0x00000001, 0x00000003, 0x00000007,
    0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
    0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
    0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
    0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
    0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
    0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
    0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
    0xffffffff
};


ULONG
RtlFindNextForwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    )
{
    ULONG Start;
    ULONG End;
    PULONG PHunk, BitMapEnd;
    ULONG Hunk;

    //
    // Take care of the boundary case of the null bitmap
    //

    if (BitMapHeader->SizeOfBitMap == 0) {

        *StartingRunIndex = FromIndex;
        return 0;
    }

    //
    //  Compute the last word address in the bitmap
    //

    BitMapEnd = BitMapHeader->Buffer + ((BitMapHeader->SizeOfBitMap - 1) / 32);

    //
    //  Scan forward for the first clear bit
    //

    Start = FromIndex;

    //
    //  Build pointer to the ULONG word in the bitmap
    //  containing the Start bit
    //

    PHunk = BitMapHeader->Buffer + (Start / 32);

    //
    //  If the first subword is set then we can proceed to
    //  take big steps in the bitmap since we are now ULONG
    //  aligned in the search. Make sure we aren't improperly
    //  looking at the last word in the bitmap.
    //

    if (PHunk != BitMapEnd) {

        //
        //  Read in the bitmap hunk. Set the previous bits in this word.
        //

        Hunk = *PHunk | FillMaskUlong[Start % 32];

        if (Hunk == (ULONG)~0) {

            //
            //  Adjust the pointers forward
            //

            Start += 32 - (Start % 32);
            PHunk++;

            while ( PHunk < BitMapEnd ) {

                //
                //  Stop at first word with unset bits
                //

                if (*PHunk != (ULONG)~0) break;

                PHunk++;
                Start += 32;
            }
        }
    }

    //
    //  Bitwise search forward for the clear bit
    //

    while ((Start < BitMapHeader->SizeOfBitMap) && (RtlCheckBit( BitMapHeader, Start ) == 1)) { Start += 1; }

    //
    //  Scan forward for the first set bit
    //

    End = Start;

    //
    //  If we aren't in the last word of the bitmap we may be
    //  able to keep taking big steps
    //

    if (PHunk != BitMapEnd) {

        //
        //  We know that the clear bit was in the last word we looked at,
        //  so continue from there to find the next set bit, clearing the
        //  previous bits in the word
        //

        Hunk = *PHunk & ~FillMaskUlong[End % 32];

        if (Hunk == (ULONG)0) {

            //
            //  Adjust the pointers forward
            //

            End += 32 - (End % 32);
            PHunk++;

            while ( PHunk < BitMapEnd ) {

                //
                //  Stop at first word with set bits
                //

                if (*PHunk != (ULONG)0) break;

                PHunk++;
                End += 32;
            }
        }
    }

    //
    //  Bitwise search forward for the set bit
    //

    while ((End < BitMapHeader->SizeOfBitMap) && (RtlCheckBit( BitMapHeader, End ) == 0)) { End += 1; }

    //
    //  Compute the index and return the length
    //

    *StartingRunIndex = Start;
    return (End - Start);
}


ULONG
RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    )
{
    ULONG Start;
    ULONG End;
    PULONG PHunk;
    ULONG Hunk;

    RTL_PAGED_CODE();

    //
    //  Take care of the boundary case of the null bitmap
    //

    if (BitMapHeader->SizeOfBitMap == 0) {

        *StartingRunIndex = FromIndex;
        return 0;
    }

    //
    //  Scan backwards for the first clear bit
    //

    End = FromIndex;

    //
    //  Build pointer to the ULONG word in the bitmap
    //  containing the End bit, then read in the bitmap
    //  hunk. Set the rest of the bits in this word, NOT
    //  inclusive of the FromIndex bit.
    //

    PHunk = BitMapHeader->Buffer + (End / 32);
    Hunk = *PHunk | ~FillMaskUlong[(End % 32) + 1];

    //
    //  If the first subword is set then we can proceed to
    //  take big steps in the bitmap since we are now ULONG
    //  aligned in the search
    //

    if (Hunk == (ULONG)~0) {

        //
        //  Adjust the pointers backwards
        //

        End -= (End % 32) + 1;
        PHunk--;

        while ( PHunk > BitMapHeader->Buffer ) {

            //
            //  Stop at first word with set bits
            //

            if (*PHunk != (ULONG)~0) break;

            PHunk--;
            End -= 32;
        }
    }

    //
    //  Bitwise search backward for the clear bit
    //

    while ((End != MAXULONG) && (RtlCheckBit( BitMapHeader, End ) == 1)) { End -= 1; }

    //
    //  Scan backwards for the first set bit
    //

    Start = End;

    //
    //  We know that the clear bit was in the last word we looked at,
    //  so continue from there to find the next set bit, clearing the
    //  previous bits in the word.
    //

    Hunk = *PHunk & FillMaskUlong[Start % 32];

    //
    //  If the subword is unset then we can proceed in big steps
    //

    if (Hunk == (ULONG)0) {

        //
        //  Adjust the pointers backward
        //

        Start -= (Start % 32) + 1;
        PHunk--;

        while ( PHunk > BitMapHeader->Buffer ) {

            //
            //  Stop at first word with set bits
            //

            if (*PHunk != (ULONG)0) break;

            PHunk--;
            Start -= 32;
        }
    }

    //
    //  Bitwise search backward for the set bit
    //

    while ((Start != MAXULONG) && (RtlCheckBit( BitMapHeader, Start ) == 0)) { Start -= 1; }

    //
    //  Compute the index and return the length
    //

    *StartingRunIndex = Start + 1;
    return (End - Start);
}

#define BM_4567 0xFFFFFFFF00000000UI64
#define BM_67   0xFFFF000000000000UI64
#define BM_7    0xFF00000000000000UI64
#define BM_5    0x0000FF0000000000UI64
#define BM_23   0x00000000FFFF0000UI64
#define BM_3    0x00000000FF000000UI64
#define BM_1    0x000000000000FF00UI64

#define BM_0123 0x00000000FFFFFFFFUI64
#define BM_01   0x000000000000FFFFUI64
#define BM_0    0x00000000000000FFUI64
#define BM_2    0x0000000000FF0000UI64
#define BM_45   0x0000FFFF00000000UI64
#define BM_4    0x000000FF00000000UI64
#define BM_6    0x00FF000000000000UI64

CCHAR
RtlFindMostSignificantBit (
    IN ULONGLONG Set
    )
/*++

Routine Description:

    This procedure finds the most significant non-zero bit in Set and
    returns it's zero-based position.

Arguments:

    Set - Supplies the 64-bit bitmap.

Return Value:

    Set != 0:
        Bit position of the most significant set bit in Set.

    Set == 0:
        -1.

--*/
{

#if defined(_AMD64_)

    ULONG bitOffset;

    if (BitScanReverse64(&bitOffset, Set)) {
        return (CCHAR)bitOffset;

    } else {
        return -1;
    }

#else

    UCHAR index;
    UCHAR bitOffset;
    UCHAR lookup;

    if ((Set & BM_4567) != 0) {
        if ((Set & BM_67) != 0) {
            if ((Set & BM_7) != 0) {
                bitOffset = 7 * 8;
            } else {
                bitOffset = 6 * 8;
            }
        } else {
            if ((Set & BM_5) != 0) {
                bitOffset = 5 * 8;
            } else {
                bitOffset = 4 * 8;
            }
        }
    } else {
        if ((Set & BM_23) != 0) {
            if ((Set & BM_3) != 0) {
                bitOffset = 3 * 8;
            } else {
                bitOffset = 2 * 8;
            }
        } else {
            if ((Set & BM_1) != 0) {
                bitOffset = 1 * 8;
            } else {

                //
                // The test for Set == 0 is postponed to here, it is expected
                // to be rare.  Note that if we had our own version of
                // RtlpBitsClearHigh[] we could eliminate this test entirely,
                // reducing the average number of tests from 3.125 to 3.
                //

                if (Set == 0) {
                    return -1;
                }

                bitOffset = 0 * 8;
            }
        }
    }

    lookup = (UCHAR)(Set >> bitOffset);
    index = (7 - RtlpBitsClearHigh[lookup]) + bitOffset;
    return index;

#endif

}

CCHAR
RtlFindLeastSignificantBit (
    IN ULONGLONG Set
    )
/*++

Routine Description:

    This procedure finds the least significant non-zero bit in Set and
    returns it's zero-based position.

Arguments:

    Set - Supplies the 64-bit bitmap.

Return Value:

    Set != 0:
        Bit position of the least significant non-zero bit in Set.

    Set == 0:
        -1.

--*/
{

#if defined(_AMD64_)

    ULONG bitOffset;

    if (BitScanForward64(&bitOffset, Set)) {
        return (CCHAR)bitOffset;

    } else {
        return -1;
    }

#else

    UCHAR index;
    UCHAR bitOffset;
    UCHAR lookup;

    if ((Set & BM_0123) != 0) {
        if ((Set & BM_01) != 0) {
            if ((Set & BM_0) != 0) {
                bitOffset = 0 * 8;
            } else {
                bitOffset = 1 * 8;
            }
        } else {
            if ((Set & BM_2) != 0) {
                bitOffset = 2 * 8;
            } else {
                bitOffset = 3 * 8;
            }
        }
    } else {
        if ((Set & BM_45) != 0) {
            if ((Set & BM_4) != 0) {
                bitOffset = 4 * 8;
            } else {
                bitOffset = 5 * 8;
            }
        } else {
            if ((Set & BM_6) != 0) {
                bitOffset = 6 * 8;
            } else {

                //
                // The test for Set == 0 is postponed to here, it is expected
                // to be rare.  Note that if we had our own version of
                // RtlpBitsClearHigh[] we could eliminate this test entirely,
                // reducing the average number of tests from 3.125 to 3.
                //

                if (Set == 0) {
                    return -1;
                }

                bitOffset = 7 * 8;
            }
        }
    }

    lookup = (UCHAR)(Set >> bitOffset);
    index = RtlpBitsClearLow[lookup] + bitOffset;
    return index;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\byteswap.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    byteswap.c

Abstract:

    This module defines functions for performing endian conversions.

--*/

#include "nt.h"
#include "ntrtlp.h"


#undef RtlUshortByteSwap
USHORT
FASTCALL
RtlUshortByteSwap(
    IN USHORT Source
    )

/*++

Routine Description:

    The RtlUshortByteSwap function exchanges bytes 0 and 1 of Source
    and returns the resulting USHORT.

Arguments:

    Source - 16-bit value to byteswap.

Return Value:

    Swapped 16-bit value.

--*/
{
    USHORT swapped;

    swapped = ((Source) << (8 * 1)) |
              ((Source) >> (8 * 1));

    return swapped;
}


#undef RtlUlongByteSwap
ULONG
FASTCALL
RtlUlongByteSwap(
    IN ULONG Source
    )

/*++

Routine Description:

    The RtlUlongByteSwap function exchanges byte pairs 0:3 and 1:2 of
    Source and returns the resulting ULONG.

Arguments:

    Source - 32-bit value to byteswap.

Return Value:

    Swapped 32-bit value.

--*/
{
    ULONG swapped;

    swapped = ((Source)              << (8 * 3)) |
              ((Source & 0x0000FF00) << (8 * 1)) |
              ((Source & 0x00FF0000) >> (8 * 1)) |
              ((Source)              >> (8 * 3));

    return swapped;
}


#undef RtlUlonglongByteSwap
ULONGLONG
FASTCALL
RtlUlonglongByteSwap(
    IN ULONGLONG Source
    )

/*++

Routine Description:

    The RtlUlongByteSwap function exchanges byte pairs 0:7, 1:6, 2:5, and
    3:4 of Source and returns the resulting ULONGLONG.

Arguments:

    Source - 64-bit value to byteswap.

Return Value:

    Swapped 64-bit value.

--*/
{
    ULONGLONG swapped;

    swapped = ((Source)                      << (8 * 7)) |
              ((Source & 0x000000000000FF00) << (8 * 5)) |
              ((Source & 0x0000000000FF0000) << (8 * 3)) |
              ((Source & 0x00000000FF000000) << (8 * 1)) |
              ((Source & 0x000000FF00000000) >> (8 * 1)) |
              ((Source & 0x0000FF0000000000) >> (8 * 3)) |
              ((Source & 0x00FF000000000000) >> (8 * 5)) |
              ((Source)                      >> (8 * 7));

    return swapped;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\avltable.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    AvlTable.c

Abstract:

    This module implements a new version of the generic table package based on balanced
    binary trees (later named AVL), as described in Knuth, "The Art of Computer Programming,
    Volume 3, Sorting and Searching", and refers directly to algorithms as they are presented
    in the second edition Copyrighted in 1973.  Whereas gentable.c relys on splay.c for
    its tree support, this module is self-contained in that it implements the balanced
    binary trees directly.

--*/

#include <nt.h>

#include <ntrtl.h>

#pragma pack(8)

//
//  The checkit routine or macro may be defined to check occurrences of the link pointers for
//  valid pointer values, if structures are being corrupted.
//

#define checkit(p) (p)

//
//  Build a table of the best case efficiency of a balanced binary tree, holding the
//  most possible nodes that can possibly be held in a binary tree with a given number
//  of levels.  The answer is always (2**n) - 1.
//
//  (Used for debug only.)
//

ULONG BestCaseFill[33] = {  0,          1,          3,          7,          0xf,        0x1f,       0x3f,       0x7f,
                            0xff,       0x1ff,      0x3ff,      0x7ff,      0xfff,      0x1fff,     0x3fff,     0x7fff,
                            0xffff,     0x1ffff,    0x3ffff,    0x7ffff,    0xfffff,    0x1fffff,   0x3fffff,   0x7fffff,
                            0xffffff,   0x1ffffff,  0x3ffffff,  0x7ffffff,  0xfffffff,  0x1fffffff, 0x3fffffff, 0x7fffffff,
                            0xffffffff  };

//
//  Build a table of the worst case efficiency of a balanced binary tree, holding the
//  fewest possible nodes that can possibly be contained in a balanced binary tree with
//  the given number of levels.  After the first two levels, each level n is obviously
//  occupied by a root node, plus one subtree the size of level n-1, and another subtree
//  which is the size of n-2, i.e.:
//
//      WorstCaseFill[n] = 1 + WorstCaseFill[n-1] + WorstCaseFill[n-2]
//
//  The efficiency of a typical balanced binary tree will normally fall between the two
//  extremes, typically closer to the best case.  Note however that even with the worst
//  case, it only takes 32 compares to find an element in a worst case tree populated with
//  ~3.5M nodes.  Unbalanced trees and splay trees, on the other hand, can and will sometimes
//  degenerate to a straight line, requiring on average n/2 compares to find a node.
//
//  A specific case (that will frequently occur in TXF), is one where the nodes are inserted
//  in collated order.  In this case an unbalanced or a splay tree will generate a straight
//  line, yet the balanced binary tree will always create a perfectly balanced tree (best-case
//  fill) in this situation.
//
//  (Used for debug only.)
//

ULONG WorstCaseFill[33] = { 0,          1,          2,          4,          7,          12,         20,         33,
                            54,         88,         143,        232,        376,        609,        986,        1596,
                            2583,       4180,       6764,       10945,      17710,      28656,      46367,      75024,
                            121392,     196417,     317810,     514228,     832039,     1346268,    2178308,    3524577,
                            5702886     };

//
//  This structure is the header for a generic table entry.
//  Align this structure on a 8 byte boundary so the user
//  data is correctly aligned.
//

typedef struct _TABLE_ENTRY_HEADER {

    RTL_BALANCED_LINKS BalancedLinks;
    LONGLONG UserData;

} TABLE_ENTRY_HEADER, *PTABLE_ENTRY_HEADER;

#pragma pack()

//
//  The default matching function which matches everything.
//

NTSTATUS
MatchAll (
    IN PRTL_AVL_TABLE Table,
    IN PVOID P1,
    IN PVOID P2
    )

{
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(Table);
    UNREFERENCED_PARAMETER(P1);
    UNREFERENCED_PARAMETER(P2);
}


TABLE_SEARCH_RESULT
FindNodeOrParent(
    IN PRTL_AVL_TABLE Table,
    IN PVOID Buffer,
    OUT PRTL_BALANCED_LINKS *NodeOrParent
    )

/*++

Routine Description:

    This routine is used by all of the routines of the generic
    table package to locate the a node in the tree.  It will
    find and return (via the NodeOrParent parameter) the node
    with the given key, or if that node is not in the tree it
    will return (via the NodeOrParent parameter) a pointer to
    the parent.

Arguments:

    Table - The generic table to search for the key.

    Buffer - Pointer to a buffer holding the key.  The table
             package doesn't examine the key itself.  It leaves
             this up to the user supplied compare routine.

    NodeOrParent - Will be set to point to the node containing the
                   the key or what should be the parent of the node
                   if it were in the tree.  Note that this will *NOT*
                   be set if the search result is TableEmptyTree.

Return Value:

    TABLE_SEARCH_RESULT - TableEmptyTree: The tree was empty.  NodeOrParent
                                          is *not* altered.

                          TableFoundNode: A node with the key is in the tree.
                                          NodeOrParent points to that node.

                          TableInsertAsLeft: Node with key was not found.
                                             NodeOrParent points to what would be
                                             parent.  The node would be the left
                                             child.

                          TableInsertAsRight: Node with key was not found.
                                              NodeOrParent points to what would be
                                              parent.  The node would be the right
                                              child.

--*/

{

    if (RtlIsGenericTableEmptyAvl(Table)) {

        return TableEmptyTree;

    } else {

        //
        //  Used as the iteration variable while stepping through
        //  the generic table.
        //

        PRTL_BALANCED_LINKS NodeToExamine = Table->BalancedRoot.RightChild;

        //
        //  Just a temporary.  Hopefully a good compiler will get
        //  rid of it.
        //

        PRTL_BALANCED_LINKS Child;

        //
        //  Holds the value of the comparasion.
        //

        RTL_GENERIC_COMPARE_RESULTS Result;

        ULONG NumberCompares = 0;

        while (TRUE) {

            //
            //  Compare the buffer with the key in the tree element.
            //

            Result = Table->CompareRoutine(
                         Table,
                         Buffer,
                         &((PTABLE_ENTRY_HEADER) NodeToExamine)->UserData
                         );

            //
            //  Make sure the depth of tree is correct.
            //

            ASSERT(++NumberCompares <= Table->DepthOfTree);

            if (Result == GenericLessThan) {

                if (Child = NodeToExamine->LeftChild) {

                    NodeToExamine = Child;

                } else {

                    //
                    //  Node is not in the tree.  Set the output
                    //  parameter to point to what would be its
                    //  parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return TableInsertAsLeft;
                }

            } else if (Result == GenericGreaterThan) {

                if (Child = NodeToExamine->RightChild) {

                    NodeToExamine = Child;

                } else {

                    //
                    //  Node is not in the tree.  Set the output
                    //  parameter to point to what would be its
                    //  parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return TableInsertAsRight;
                }

            } else {

                //
                //  Node is in the tree (or it better be because of the
                //  assert).  Set the output parameter to point to
                //  the node and tell the caller that we found the node.
                //

                ASSERT(Result == GenericEqual);
                *NodeOrParent = NodeToExamine;
                return TableFoundNode;
            }
        }
    }
}


VOID
PromoteNode (
    IN PRTL_BALANCED_LINKS C
    )

/*++

Routine Description:

    This routine performs the fundamental adjustment required for balancing
    the binary tree during insert and delete operations.  Simply put, the designated
    node is promoted in such a way that it rises one level in the tree and its parent
    drops one level in the tree, becoming now the child of the designated node.
    Generally the path length to the subtree "opposite" the original parent.  Balancing
    occurs as the caller chooses which nodes to promote according to the balanced tree
    algorithms from Knuth.

    This is not the same as a splay operation, typically a splay "promotes" a designated
    node twice.

    Note that the pointer to the root node of the tree is assumed to be contained in a
    RTL_BALANCED_LINK structure itself, to allow the algorithms below to change the root
    of the tree without checking for special cases.  Note also that this is an internal
    routine, and the caller guarantees that it never requests to promote the root itself.

    This routine only updates the tree links; the caller must update the balance factors
    as appropriate.

Arguments:

    C - pointer to the child node to be promoted in the tree.

Return Value:

    None.

--*/

{
    PRTL_BALANCED_LINKS P, G;

    //
    //  Capture the current parent and grandparent (may be the root).
    //

    P = C->Parent;
    G = P->Parent;

    //
    //  Break down the promotion into two cases based upon whether C is a left or right child.
    //

    if (P->LeftChild == C) {

        //
        //  This promotion looks like this:
        //
        //          G           G
        //          |           |
        //          P           C
        //         / \   =>    / \
        //        C   z       x   P
        //       / \             / \
        //      x   y           y   z
        //

        P->LeftChild = checkit(C->RightChild);

        if (P->LeftChild != NULL) {
            P->LeftChild->Parent = checkit(P);
        }

        C->RightChild = checkit(P);

        //
        //  Fall through to update parent and G <-> C relationship in common code.
        //

    } else {

        ASSERT(P->RightChild == C);

        //
        //  This promotion looks like this:
        //
        //        G               G
        //        |               |
        //        P               C
        //       / \     =>      / \
        //      x   C           P   z
        //         / \         / \
        //        y   z       x   y
        //

        P->RightChild = checkit(C->LeftChild);

        if (P->RightChild != NULL) {
            P->RightChild->Parent = checkit(P);
        }

        C->LeftChild = checkit(P);
    }

    //
    //  Update parent of P, for either case above.
    //

    P->Parent = checkit(C);

    //
    //  Finally update G <-> C links for either case above.
    //

    if (G->LeftChild == P) {
        G->LeftChild = checkit(C);
    } else {
        ASSERT(G->RightChild == P);
        G->RightChild = checkit(C);
    }
    C->Parent = checkit(G);
}


ULONG
RebalanceNode (
    IN PRTL_BALANCED_LINKS S
    )

/*++

Routine Description:

    This routine performs a rebalance around the input node S, for which the
    Balance factor has just effectively become +2 or -2.  When called, the
    Balance factor still has a value of +1 or -1, but the respective longer
    side has just become one longer as the result of an insert or delete operation.

    This routine effectively implements steps A7.iii (test for Case 1 or Case 2) and
    steps A8 and A9 of Knuths balanced insertion algorithm, plus it handles Case 3
    identified in the delete section, which can only happen on deletes.

    The trick is, to convince yourself that while traveling from the insertion point
    at the bottom of the tree up, that there are only these two cases, and that when
    traveling up from the deletion point, that there are just these three cases.
    Knuth says it is obvious!

Arguments:

    S - pointer to the node which has just become unbalanced.

Return Value:

    TRUE if Case 3 was detected (causes delete algorithm to terminate).

--*/

{
    PRTL_BALANCED_LINKS R, P;
    CHAR a;

    //
    //  Capture which side is unbalanced.
    //

    a = S->Balance;
    if (a == +1) {
        R = S->RightChild;
    } else {
        R = S->LeftChild;
    }

    //
    //  If the balance of R and S are the same (Case 1 in Knuth) then a single
    //  promotion of R will do the single rotation.  (Step A8, A10)
    //
    //  Here is a diagram of the Case 1 transformation, for a == +1 (a mirror
    //  image transformation occurs when a == -1), and where the subtree
    //  heights are h and h+1 as shown (++ indicates the node out of balance):
    //
    //                  |                   |
    //                  S++                 R
    //                 / \                 / \
    //               (h)  R+     ==>      S  (h+1)
    //                   / \             / \
    //                 (h) (h+1)       (h) (h)
    //
    //  Note that on an insert we can hit this case by inserting an item in the
    //  right subtree of R.  The original height of the subtree before the insert
    //  was h+2, and it is still h+2 after the rebalance, so insert rebalancing may
    //  terminate.
    //
    //  On a delete we can hit this case by deleting a node from the left subtree
    //  of S.  The height of the subtree before the delete was h+3, and after the
    //  rebalance it is h+2, so rebalancing must continue up the tree.
    //

    if (R->Balance == a) {

        PromoteNode( R );
        R->Balance = 0;
        S->Balance = 0;
        return FALSE;

    //
    //  Otherwise, we have to promote the appropriate child of R twice (Case 2
    //  in Knuth).  (Step A9, A10)
    //
    //  Here is a diagram of the Case 2 transformation, for a == +1 (a mirror
    //  image transformation occurs when a == -1), and where the subtree
    //  heights are h and h-1 as shown.  There are actually two minor subcases,
    //  differing only in the original balance of P (++ indicates the node out
    //  of balance).
    //
    //                  |                   |
    //                  S++                 P
    //                 / \                 / \
    //                /   \               /   \
    //               /     \             /     \
    //             (h)      R-   ==>    S-      R
    //                     / \         / \     / \
    //                    P+ (h)     (h)(h-1)(h) (h)
    //                   / \
    //               (h-1) (h)
    //
    //
    //                  |                   |
    //                  S++                 P
    //                 / \                 / \
    //                /   \               /   \
    //               /     \             /     \
    //             (h)      R-   ==>    S       R+
    //                     / \         / \     / \
    //                    P- (h)     (h) (h)(h-1)(h)
    //                   / \
    //                 (h) (h-1)
    //
    //  Note that on an insert we can hit this case by inserting an item in the
    //  left subtree of R.  The original height of the subtree before the insert
    //  was h+2, and it is still h+2 after the rebalance, so insert rebalancing may
    //  terminate.
    //
    //  On a delete we can hit this case by deleting a node from the left subtree
    //  of S.  The height of the subtree before the delete was h+3, and after the
    //  rebalance it is h+2, so rebalancing must continue up the tree.
    //

    }  else if (R->Balance == -a) {

        //
        //  Pick up the appropriate child P for the double rotation (Link(-a,R)).
        //

        if (a == 1) {
            P = R->LeftChild;
        } else {
            P = R->RightChild;
        }

        //
        //  Promote him twice to implement the double rotation.
        //

        PromoteNode( P );
        PromoteNode( P );

        //
        //  Now adjust the balance factors.
        //

        S->Balance = 0;
        R->Balance = 0;
        if (P->Balance == a) {
            S->Balance = -a;
        } else if (P->Balance == -a) {
            R->Balance = a;
        }

        P->Balance = 0;
        return FALSE;

    //
    //  Otherwise this is Case 3 which can only happen on Delete (identical to Case 1 except
    //  R->Balance == 0).  We do a single rotation, adjust the balance factors appropriately,
    //  and return TRUE.  Note that the balance of S stays the same.
    //
    //  Here is a diagram of the Case 3 transformation, for a == +1 (a mirror
    //  image transformation occurs when a == -1), and where the subtree
    //  heights are h and h+1 as shown (++ indicates the node out of balance):
    //
    //                  |                   |
    //                  S++                 R-
    //                 / \                 / \
    //               (h)  R      ==>      S+ (h+1)
    //                   / \             / \
    //                (h+1)(h+1)       (h) (h+1)
    //
    //  This case can not occur on an insert, because it is impossible for a single insert to
    //  balance R, yet somehow grow the right subtree of S at the same time.  As we move up
    //  the tree adjusting balance factors after an insert, we terminate the algorithm if a
    //  node becomes balanced, because that means the subtree length did not change!
    //
    //  On a delete we can hit this case by deleting a node from the left subtree
    //  of S.  The height of the subtree before the delete was h+3, and after the
    //  rebalance it is still h+3, so rebalancing may terminate in the delete path.
    //

    } else {

        PromoteNode( R );
        R->Balance = -a;
        return TRUE;
    }
}


VOID
DeleteNodeFromTree (
    IN PRTL_AVL_TABLE Table,
    IN PRTL_BALANCED_LINKS NodeToDelete
    )

/*++

Routine Description:

    This routine deletes the specified node from the balanced tree, rebalancing
    as necessary.  If the NodeToDelete has at least one NULL child pointers, then
    it is chosen as the EasyDelete, otherwise a subtree predecessor or successor
    is found as the EasyDelete.  In either case the EasyDelete is deleted
    and the tree is rebalanced.  Finally if the NodeToDelete was different
    than the EasyDelete, then the EasyDelete is linked back into the tree in
    place of the NodeToDelete.

Arguments:

    Table - The generic table in which the delete is to occur.

    NodeToDelete - Pointer to the node which the caller wishes to delete.

Return Value:

    None.

--*/

{
    PRTL_BALANCED_LINKS EasyDelete;
    PRTL_BALANCED_LINKS P;
    CHAR a;

    //
    //  If the NodeToDelete has at least one NULL child pointer, then we can
    //  delete it directly.
    //

    if ((NodeToDelete->LeftChild == NULL) || (NodeToDelete->RightChild == NULL)) {

        EasyDelete = NodeToDelete;

    //
    //  Otherwise, we may as well pick the longest side to delete from (if one is
    //  is longer), as that reduces the probability that we will have to rebalance.
    //

    } else if (NodeToDelete->Balance >= 0) {

        //
        //  Pick up the subtree successor.
        //

        EasyDelete = NodeToDelete->RightChild;
        while (EasyDelete->LeftChild != NULL) {
            EasyDelete = EasyDelete->LeftChild;
        }
    } else {

        //
        //  Pick up the subtree predecessor.
        //

        EasyDelete = NodeToDelete->LeftChild;
        while (EasyDelete->RightChild != NULL) {
            EasyDelete = EasyDelete->RightChild;
        }
    }

    //
    //  Rebalancing must know which side of the first parent the delete occurred
    //  on.  Assume it is the left side and otherwise correct below.
    //

    a = -1;

    //
    //  Now we can do the simple deletion for the no left child case.
    //

    if (EasyDelete->LeftChild == NULL) {

        if (RtlIsLeftChild(EasyDelete)) {
            EasyDelete->Parent->LeftChild = checkit(EasyDelete->RightChild);
        } else {
            EasyDelete->Parent->RightChild = checkit(EasyDelete->RightChild);
            a = 1;
        }

        if (EasyDelete->RightChild != NULL) {
            EasyDelete->RightChild->Parent = checkit(EasyDelete->Parent);
        }

    //
    //  Now we can do the simple deletion for the no right child case,
    //  plus we know there is a left child.
    //

    } else {

        if (RtlIsLeftChild(EasyDelete)) {
            EasyDelete->Parent->LeftChild = checkit(EasyDelete->LeftChild);
        } else {
            EasyDelete->Parent->RightChild = checkit(EasyDelete->LeftChild);
            a = 1;
        }

        EasyDelete->LeftChild->Parent = checkit(EasyDelete->Parent);
    }

    //
    //  For delete rebalancing, set the balance at the root to 0 to properly
    //  terminate the rebalance without special tests, and to be able to detect
    //  if the depth of the tree actually decreased.
    //

    Table->BalancedRoot.Balance = 0;
    P = EasyDelete->Parent;

    //
    //  Loop until the tree is balanced.
    //

    while (TRUE) {

        //
        //  First handle the case where the tree became more balanced.  Zero
        //  the balance factor, calculate a for the next loop and move on to
        //  the parent.
        //

        if (P->Balance == a) {

            P->Balance = 0;

        //
        //  If this node is curently balanced, we can show it is now unbalanced
        //  and terminate the scan since the subtree length has not changed.
        //  (This may be the root, since we set Balance to 0 above!)
        //

        } else if (P->Balance == 0) {

            P->Balance = -a;

            //
            //  If we shortened the depth all the way back to the root, then the tree really
            //  has one less level.
            //

            if (Table->BalancedRoot.Balance != 0) {
                Table->DepthOfTree -= 1;
            }

            break;

        //
        //  Otherwise we made the short side 2 levels less than the long side,
        //  and rebalancing is required.  On return, some node has been promoted
        //  to above node P.  If Case 3 from Knuth was not encountered, then we
        //  want to effectively resume rebalancing from P's original parent which
        //  is effectively its grandparent now.
        //

        } else {

            //
            //  We are done if Case 3 was hit, i.e., the depth of this subtree is
            //  now the same as before the delete.
            //

            if (RebalanceNode(P)) {
                break;
            }

            P = P->Parent;
        }

        a = -1;
        if (RtlIsRightChild(P)) {
            a = 1;
        }
        P = P->Parent;
    }

    //
    //  Finally, if we actually deleted a predecessor/successor of the NodeToDelete,
    //  we will link him back into the tree to replace NodeToDelete before returning.
    //  Note that NodeToDelete did have both child links filled in, but that may no
    //  longer be the case at this point.
    //

    if (NodeToDelete != EasyDelete) {
        *EasyDelete = *NodeToDelete;
        if (RtlIsLeftChild(NodeToDelete)) {
            EasyDelete->Parent->LeftChild = checkit(EasyDelete);
        } else {
            ASSERT(RtlIsRightChild(NodeToDelete));
            EasyDelete->Parent->RightChild = checkit(EasyDelete);
        }
        if (EasyDelete->LeftChild != NULL) {
            EasyDelete->LeftChild->Parent = checkit(EasyDelete);
        }
        if (EasyDelete->RightChild != NULL) {
            EasyDelete->RightChild->Parent = checkit(EasyDelete);
        }
    }
}


PRTL_BALANCED_LINKS
RealSuccessor (
    IN PRTL_BALANCED_LINKS Links
    )

/*++

Routine Description:

    The RealSuccessor function takes as input a pointer to a balanced link
    in a tree and returns a pointer to the successor of the input node within
    the entire tree.  If there is not a successor, the return value is NULL.

Arguments:

    Links - Supplies a pointer to a balanced link in a tree.

Return Value:

    PRTL_BALANCED_LINKS - returns a pointer to the successor in the entire tree

--*/

{
    PRTL_BALANCED_LINKS Ptr;

    /*
        first check to see if there is a right subtree to the input link
        if there is then the real successor is the left most node in
        the right subtree.  That is find and return S in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  S
                   \
    */

    if ((Ptr = Links->RightChild) != NULL) {

        while (Ptr->LeftChild != NULL) {
            Ptr = Ptr->LeftChild;
        }

        return Ptr;

    }

    /*
        we do not have a right child so check to see if have a parent and if
        so find the first ancestor that we are a left descendent of. That
        is find and return S in the following diagram

                       S
                      /
                     .
                      .
                       .
                      Links

        Note that this code depends on how the BalancedRoot is initialized, which is
        Parent points to self, and the RightChild points to an actual node which is
        the root of the tree, and LeftChild does not point to self.
    */

    Ptr = Links;
    while (RtlIsRightChild(Ptr)) {
        Ptr = Ptr->Parent;
    }

    if (RtlIsLeftChild(Ptr)) {
        return Ptr->Parent;
    }

    //
    //  otherwise we are do not have a real successor so we simply return
    //  NULL.
    //
    //  This can only occur when we get back to the root, and we can tell
    //  that since the Root is its own parent.
    //

    ASSERT(Ptr->Parent == Ptr);

    return NULL;
}


PRTL_BALANCED_LINKS
RealPredecessor (
    IN PRTL_BALANCED_LINKS Links
    )

/*++

Routine Description:

    The RealPredecessor function takes as input a pointer to a balanced link
    in a tree and returns a pointer to the predecessor of the input node
    within the entire tree.  If there is not a predecessor, the return value
    is NULL.

Arguments:

    Links - Supplies a pointer to a balanced link in a tree.

Return Value:

    PRTL_BALANCED_LINKS - returns a pointer to the predecessor in the entire tree

--*/

{
    PRTL_BALANCED_LINKS Ptr;

    /*
      first check to see if there is a left subtree to the input link
      if there is then the real predecessor is the right most node in
      the left subtree.  That is find and return P in the following diagram

                  Links
                   /
                  .
                   .
                    .
                     P
                    /
    */

    if ((Ptr = Links->LeftChild) != NULL) {

        while (Ptr->RightChild != NULL) {
            Ptr = Ptr->RightChild;
        }

        return Ptr;

    }

    /*
      we do not have a left child so check to see if have a parent and if
      so find the first ancestor that we are a right descendent of. That
      is find and return P in the following diagram

                       P
                        \
                         .
                        .
                       .
                    Links

        Note that this code depends on how the BalancedRoot is initialized, which is
        Parent points to self, and the RightChild points to an actual node which is
        the root of the tree.
    */

    Ptr = Links;
    while (RtlIsLeftChild(Ptr)) {
        Ptr = Ptr->Parent;
    }

    if (RtlIsRightChild(Ptr) && (Ptr->Parent->Parent != Ptr->Parent)) {
        return Ptr->Parent;
    }

    //
    //  otherwise we are do not have a real predecessor so we simply return
    //  NULL
    //

    return NULL;

}


VOID
RtlInitializeGenericTableAvl (
    IN PRTL_AVL_TABLE Table,
    IN PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    IN PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    IN PRTL_AVL_FREE_ROUTINE FreeRoutine,
    IN PVOID TableContext
    )

/*++

Routine Description:

    The procedure InitializeGenericTableAvl takes as input an uninitialized
    generic table variable and pointers to the three user supplied routines.
    This must be called for every individual generic table variable before
    it can be used.

Arguments:

    Table - Pointer to the generic table to be initialized.

    CompareRoutine - User routine to be used to compare to keys in the
                     table.

    AllocateRoutine - User routine to call to allocate memory for a new
                      node in the generic table.

    FreeRoutine - User routine to call to deallocate memory for
                        a node in the generic table.

    TableContext - Supplies user supplied context for the table.

Return Value:

    None.

--*/

{

#ifdef NTFS_FREE_ASSERTS
    ULONG i;

    for (i=2; i < 33; i++) {
        ASSERT(WorstCaseFill[i] == (1 + WorstCaseFill[i-1] + WorstCaseFill[i-2]));
    }
#endif

    //
    //  Initialize each field of the Table parameter.
    //

    RtlZeroMemory( Table, sizeof(RTL_AVL_TABLE) );
    Table->BalancedRoot.Parent = &Table->BalancedRoot;
    Table->CompareRoutine = CompareRoutine;
    Table->AllocateRoutine = AllocateRoutine;
    Table->FreeRoutine = FreeRoutine;
    Table->TableContext = TableContext;

}


PVOID
RtlInsertElementGenericTableAvl (
    IN PRTL_AVL_TABLE Table,
    IN PVOID Buffer,
    IN CLONG BufferSize,
    OUT PBOOLEAN NewElement OPTIONAL
    )

/*++

Routine Description:

    The function InsertElementGenericTableAvl will insert a new element
    in a table.  It does this by allocating space for the new element
    (this includes splay links), inserting the element in the table, and
    then returning to the user a pointer to the new element (which is
    the first available space after the splay links).  If an element
    with the same key already exists in the table the return value is a pointer
    to the old element.  The optional output parameter NewElement is used
    to indicate if the element previously existed in the table.  Note: the user
    supplied Buffer is only used for searching the table, upon insertion its
    contents are copied to the newly created element.  This means that
    pointer to the input buffer will not point to the new element.

Arguments:

    Table - Pointer to the table in which to (possibly) insert the
            key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

    BufferSize - The amount of space to allocate when the (possible)
                 insertion is made.  Note that if we actually do
                 not find the node and we do allocate space then we
                 will add the size of the BALANCED_LINKS to this buffer
                 size.  The user should really take care not to depend
                 on anything in the first sizeof(BALANCED_LINKS) bytes
                 of the memory allocated via the memory allocation
                 routine.

    NewElement - Optional Flag.  If present then it will be set to
                 TRUE if the buffer was not "found" in the generic
                 table.

Return Value:

    PVOID - Pointer to the user defined data.

--*/

{

    //
    //  Holds a pointer to the node in the table or what would be the
    //  parent of the node.
    //

    PRTL_BALANCED_LINKS NodeOrParent;

    //
    //  Holds the result of the table lookup.
    //

    TABLE_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent(
                 Table,
                 Buffer,
                 &NodeOrParent
                 );

    //
    //  Call the full routine to do the real work.
    //

    return RtlInsertElementGenericTableFullAvl(
                Table,
                Buffer,
                BufferSize,
                NewElement,
                NodeOrParent,
                Lookup
                );
}


PVOID
RtlInsertElementGenericTableFullAvl (
    IN PRTL_AVL_TABLE Table,
    IN PVOID Buffer,
    IN CLONG BufferSize,
    OUT PBOOLEAN NewElement OPTIONAL,
    IN PVOID NodeOrParent,
    IN TABLE_SEARCH_RESULT SearchResult
    )

/*++

Routine Description:

    The function InsertElementGenericTableFullAvl will insert a new element
    in a table.  It does this by allocating space for the new element
    (this includes splay links), inserting the element in the table, and
    then returning to the user a pointer to the new element.  If an element
    with the same key already exists in the table the return value is a pointer
    to the old element.  The optional output parameter NewElement is used
    to indicate if the element previously existed in the table.  Note: the user
    supplied Buffer is only used for searching the table, upon insertion its
    contents are copied to the newly created element.  This means that
    pointer to the input buffer will not point to the new element.
    This routine is passed the NodeOrParent and SearchResult from a
    previous RtlLookupElementGenericTableFullAvl.

Arguments:

    Table - Pointer to the table in which to (possibly) insert the
            key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

    BufferSize - The amount of space to allocate when the (possible)
                 insertion is made.  Note that if we actually do
                 not find the node and we do allocate space then we
                 will add the size of the BALANCED_LINKS to this buffer
                 size.  The user should really take care not to depend
                 on anything in the first sizeof(BALANCED_LINKS) bytes
                 of the memory allocated via the memory allocation
                 routine.

    NewElement - Optional Flag.  If present then it will be set to
                 TRUE if the buffer was not "found" in the generic
                 table.

   NodeOrParent - Result of prior RtlLookupElementGenericTableFullAvl.

   SearchResult - Result of prior RtlLookupElementGenericTableFullAvl.

Return Value:

    PVOID - Pointer to the user defined data.

--*/

{
    //
    //  Node will point to the splay links of what
    //  will be returned to the user.
    //

    PTABLE_ENTRY_HEADER NodeToReturn;

    if (SearchResult != TableFoundNode) {

        //
        //  We just check that the table isn't getting
        //  too big.
        //

        ASSERT(Table->NumberGenericTableElements != (MAXULONG-1));

        //
        //  The node wasn't in the (possibly empty) tree.
        //  Call the user allocation routine to get space
        //  for the new node.
        //

        NodeToReturn = Table->AllocateRoutine(
                           Table,
                           BufferSize+FIELD_OFFSET( TABLE_ENTRY_HEADER, UserData )
                           );

        //
        //  If the return is NULL, return NULL from here to indicate that
        //  the entry could not be added.
        //

        if (NodeToReturn == NULL) {

            if (ARGUMENT_PRESENT(NewElement)) {

                *NewElement = FALSE;
            }

            return(NULL);
        }

        RtlZeroMemory( NodeToReturn, sizeof(RTL_BALANCED_LINKS) );

        Table->NumberGenericTableElements++;

        //
        //  Insert the new node in the tree.
        //

        if (SearchResult == TableEmptyTree) {

            Table->BalancedRoot.RightChild = &NodeToReturn->BalancedLinks;
            NodeToReturn->BalancedLinks.Parent = &Table->BalancedRoot;
            ASSERT(Table->DepthOfTree == 0);
            Table->DepthOfTree = 1;

        } else {

            PRTL_BALANCED_LINKS R = &NodeToReturn->BalancedLinks;
            PRTL_BALANCED_LINKS S = (PRTL_BALANCED_LINKS)NodeOrParent;

            if (SearchResult == TableInsertAsLeft) {

                ((PRTL_BALANCED_LINKS)NodeOrParent)->LeftChild = checkit(&NodeToReturn->BalancedLinks);

            } else {

                ((PRTL_BALANCED_LINKS)NodeOrParent)->RightChild = checkit(&NodeToReturn->BalancedLinks);
            }

            NodeToReturn->BalancedLinks.Parent = NodeOrParent;

            //
            //  The above completes the standard binary tree insertion, which
            //  happens to correspond to steps A1-A5 of Knuth's "balanced tree
            //  search and insertion" algorithm.  Now comes the time to adjust
            //  balance factors and possibly do a single or double rotation as
            //  in steps A6-A10.

            //
            //  Set the Balance factor in the root to a convenient value
            //  to simplify loop control.
            //

            Table->BalancedRoot.Balance = -1;

            //
            //  Now loop to adjust balance factors and see if any balance operations
            //  must be performed, using NodeOrParent to ascend the tree.
            //

            while (TRUE) {

                CHAR a;

                //
                //  Calculate the next adjustment.
                //

                a = 1;
                if (RtlIsLeftChild(R)) {
                    a = -1;
                }

                //
                //  If this node was balanced, show that it is no longer and keep looping.
                //  This is essentially A6 of Knuth's algorithm, where he updates all of
                //  the intermediate nodes on the insertion path which previously had
                //  balance factors of 0.  We are looping up the tree via Parent pointers
                //  rather than down the tree as in Knuth.
                //

                if (S->Balance == 0) {

                    S->Balance = a;
                    R = S;
                    S = S->Parent;

                //
                //  If this node has the opposite balance, then the tree got more balanced
                //  (or we hit the root) and we are done.
                //

                } else if (S->Balance != a) {

                    //
                    //  Step A7.ii
                    //

                    S->Balance = 0;

                    //
                    //  If S is actually the root, then this means the depth of the tree
                    //  just increased by 1!  (This is essentially A7.i, but we just
                    //  initialized the root balance to force it through here.)
                    //

                    if (Table->BalancedRoot.Balance == 0) {
                        Table->DepthOfTree += 1;
                    }

                    break;

                //
                //  Otherwise the tree became unbalanced (path length differs by 2 below us)
                //  and we need to do one of the balancing operations, and then we are done.
                //  The RebalanceNode routine does steps A7.iii, A8 and A9.
                //

                } else {

                    RebalanceNode( S );
                    break;
                }
            }
        }

        //
        //  Copy the users buffer into the user data area of the table.
        //

        RtlCopyMemory( &NodeToReturn->UserData, Buffer, BufferSize );

    } else {

        NodeToReturn = NodeOrParent;
    }

    //
    //  Optionally return the NewElement boolean.
    //

    if (ARGUMENT_PRESENT(NewElement)) {
        *NewElement = ((SearchResult == TableFoundNode)?(FALSE):(TRUE));
    }

    //
    //  Sanity check tree size and depth.
    //

    ASSERT((Table->NumberGenericTableElements >= WorstCaseFill[Table->DepthOfTree]) &&
           (Table->NumberGenericTableElements <= BestCaseFill[Table->DepthOfTree]));

    //
    //  Insert the element on the ordered list;
    //

    return &NodeToReturn->UserData;
}


BOOLEAN
RtlDeleteElementGenericTableAvl (
    IN PRTL_AVL_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The function DeleteElementGenericTableAvl will find and delete an element
    from a generic table.  If the element is located and deleted the return
    value is TRUE, otherwise if the element is not located the return value
    is FALSE.  The user supplied input buffer is only used as a key in
    locating the element in the table.

Arguments:

    Table - Pointer to the table in which to (possibly) delete the
            memory accessed by the key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

Return Value:

    BOOLEAN - If the table contained the key then true, otherwise false.

--*/

{

    //
    //  Holds a pointer to the node in the table or what would be the
    //  parent of the node.
    //
    PRTL_BALANCED_LINKS NodeOrParent;

    //
    //  Holds the result of the table lookup.
    //
    TABLE_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent(
                 Table,
                 Buffer,
                 &NodeOrParent
                 );

    if (Lookup != TableFoundNode) {

        return FALSE;

    } else {

        //
        //  Make RtlEnumerateGenericTableAvl safe by replacing the RestartKey
        //  with its predecessor if it gets deleted.  A NULL means return the
        //  first node in the tree.  (The Splay routines do not always correctly
        //  resume from predecessor on delete!)
        //

        if (NodeOrParent == Table->RestartKey) {
            Table->RestartKey = RealPredecessor( NodeOrParent );
        }

        //
        //  Make RtlEnumerateGenericTableLikeADirectory safe by incrementing the
        //  DeleteCount.
        //

        Table->DeleteCount += 1;

        //
        //  Delete the node from the splay tree.
        //

        DeleteNodeFromTree( Table, NodeOrParent );
        Table->NumberGenericTableElements--;

        //
        //  On all deletes, reset the ordered pointer to force a recount from 0.
        //

        Table->WhichOrderedElement = 0;
        Table->OrderedPointer = NULL;

        //
        //  Sanity check tree size and depth.
        //

        ASSERT((Table->NumberGenericTableElements >= WorstCaseFill[Table->DepthOfTree]) &&
               (Table->NumberGenericTableElements <= BestCaseFill[Table->DepthOfTree]));

        //
        //  The node has been deleted from the splay table.
        //  Now give the node to the user deletion routine.
        //  NOTE: We are giving the deletion routine a pointer
        //  to the splay links rather then the user data.  It
        //  is assumed that the deallocation is rather bad.
        //

        Table->FreeRoutine(Table,NodeOrParent);
        return TRUE;
    }
}


PVOID
RtlLookupElementGenericTableAvl (
    IN PRTL_AVL_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The function LookupElementGenericTable will find an element in a generic
    table.  If the element is located the return value is a pointer to
    the user defined structure associated with the element, otherwise if
    the element is not located the return value is NULL.  The user supplied
    input buffer is only used as a key in locating the element in the table.

Arguments:

    Table - Pointer to the users Generic table to search for the key.

    Buffer - Used for the comparasion.

Return Value:

    PVOID - returns a pointer to the user data.

--*/

{
    //
    //  Holds a pointer to the node in the table or what would be the
    //  parent of the node.
    //
    PRTL_BALANCED_LINKS NodeOrParent;

    //
    //  Holds the result of the table lookup.
    //
    TABLE_SEARCH_RESULT Lookup;

    return RtlLookupElementGenericTableFullAvl(
                Table,
                Buffer,
                &NodeOrParent,
                &Lookup
                );
}


PVOID
NTAPI
RtlLookupElementGenericTableFullAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT TABLE_SEARCH_RESULT *SearchResult
    )

/*++

Routine Description:

    The function LookupElementGenericTableFullAvl will find an element in a generic
    table.  If the element is located the return value is a pointer to
    the user defined structure associated with the element.  If the element is not
    located then a pointer to the parent for the insert location is returned.  The
    user must look at the SearchResult value to determine which is being returned.
    The user can use the SearchResult and parent for a subsequent FullInsertElement
    call to optimize the insert.

Arguments:

    Table - Pointer to the users Generic table to search for the key.

    Buffer - Used for the comparasion.

    NodeOrParent - Address to store the desired Node or parent of the desired node.

    SearchResult - Describes the relationship of the NodeOrParent with the desired Node.

Return Value:

    PVOID - returns a pointer to the user data.

--*/

{

    //
    //  Lookup the element and save the result.
    //

    *SearchResult = FindNodeOrParent(
                        Table,
                        Buffer,
                        (PRTL_BALANCED_LINKS *)NodeOrParent
                        );

    if (*SearchResult != TableFoundNode) {

        return NULL;

    } else {

        //
        //  Return a pointer to the user data.
        //

        return &((PTABLE_ENTRY_HEADER)*NodeOrParent)->UserData;
    }
}


PVOID
RtlEnumerateGenericTableAvl (
    IN PRTL_AVL_TABLE Table,
    IN BOOLEAN Restart
    )

/*++

Routine Description:

    The function EnumerateGenericTableAvl will return to the caller one-by-one
    the elements of of a table.  The return value is a pointer to the user
    defined structure associated with the element.  The input parameter
    Restart indicates if the enumeration should start from the beginning
    or should return the next element.  If there are no more new elements to
    return the return value is NULL.  As an example of its use, to enumerate
    all of the elements in a table the user would write:

        for (ptr = EnumerateGenericTableAvl(Table,TRUE);
             ptr != NULL;
             ptr = EnumerateGenericTableAvl(Table, FALSE)) {
                :
        }

    For a summary of when to use each of the four enumeration routines, see
    RtlEnumerateGenericTableLikeADirectory.

Arguments:

    Table - Pointer to the generic table to enumerate.

    Restart - Flag that if true we should start with the least
              element in the tree otherwise, return we return
              a pointer to the user data for the root and make
              the real successor to the root the new root.

Return Value:

    PVOID - Pointer to the user data.

--*/

{
    //
    //  If he said Restart, then zero Table->RestartKey before calling the
    //  common routine.
    //

    if (Restart) {
        Table->RestartKey = NULL;
    }

    return RtlEnumerateGenericTableWithoutSplayingAvl( Table, &Table->RestartKey );
}


BOOLEAN
RtlIsGenericTableEmptyAvl (
    IN PRTL_AVL_TABLE Table
    )

/*++

Routine Description:

    The function IsGenericTableEmptyAvl will return to the caller TRUE if
    the input table is empty (i.e., does not contain any elements) and
    FALSE otherwise.

Arguments:

    Table - Supplies a pointer to the Generic Table.

Return Value:

    BOOLEAN - if enabled the tree is empty.

--*/

{
    //
    //  Table is empty if the root pointer is null.
    //

    return ((Table->NumberGenericTableElements)?(FALSE):(TRUE));
}


PVOID
RtlGetElementGenericTableAvl (
    IN PRTL_AVL_TABLE Table,
    IN ULONG I
    )

/*++

Routine Description:


    The function GetElementGenericTableAvl will return the i'th element in the
    generic table by collation order.  I = 0 implies the first/lowest element,
    I = (RtlNumberGenericTableElements2(Table)-1) will return the last/highest
    element in the generic table.  The type of I is ULONG.  Values
    of I > than (NumberGenericTableElements(Table)-1) will return NULL.  If
    an arbitrary element is deleted from the generic table it will cause
    all elements inserted after the deleted element to "move up".

    For a summary of when to use each of the four enumeration routines, see
    RtlEnumerateGenericTableLikeADirectory.

    NOTE!!!  THE ORIGINAL GENERIC TABLE PACKAGE RETURNED ITEMS FROM THIS ROUTINE
    IN INSERT ORDER, BUT THIS ROUTINE RETURNS ELEMENTS IN COLLATION ORDER. MOST
    CALLERS MAY NOT CARE, BUT IF INSERT ORDER IS REQUIRED, THE CALLER MUST MAINTAIN
    INSERT ORDER VIA LINKS IN USERDATA, BECAUSE THIS TABLE PACKAGE DOES NOT MAINTAIN
    INSERT ORDER.  ALSO, LIKE THE PREVIOUS IMPLEMENTATION, THIS ROUTINE MAY SKIP OR
    REPEAT NODES IF ENUMERATION OCCURS IN PARALLEL WITH INSERTS AND DELETES.

    IN CONCLUSION, THIS ROUTINE IS NOT RECOMMENDED, AND IS SUPPLIED FOR BACKWARDS
    COMPATIBILITY ONLY.  SEE COMMENTS ABOUT WHICH ROUTINE TO CHOOSE IN THE ROUTINE
    COMMENTS FOR RtlEnumerateGenericTableLikeADirectory.

Arguments:

    Table - Pointer to the generic table from which to get the ith element.

    I - Which element to get.


Return Value:

    PVOID - Pointer to the user data.

--*/

{
    //
    //  Current location in the table, 0-based like I.
    //

    ULONG CurrentLocation = Table->WhichOrderedElement;

    //
    //  Hold the number of elements in the table.
    //

    ULONG NumberInTable = Table->NumberGenericTableElements;

    //
    //  Will hold distances to travel to the desired node;
    //

    ULONG ForwardDistance,BackwardDistance;

    //
    //  Will point to the current element in the linked list.
    //

    PRTL_BALANCED_LINKS CurrentNode = (PRTL_BALANCED_LINKS)Table->OrderedPointer;

    //
    //  If it's out of bounds get out quick.
    //

    if ((I == MAXULONG) || ((I + 1) > NumberInTable)) return NULL;

    //
    //  NULL means first node.  We just loop until we find the leftmost child of the root.
    //  Because of the above test, we know there is at least one element in the table.
    //

    if (CurrentNode == NULL) {

        for (
            CurrentNode = Table->BalancedRoot.RightChild;
            CurrentNode->LeftChild;
            CurrentNode = CurrentNode->LeftChild
            ) {
            NOTHING;
        }
        CurrentLocation = 0;

        //
        //  Update the table to save repeating this loop on a subsequent call.
        //

        Table->OrderedPointer = CurrentNode;
        Table->WhichOrderedElement = 0;
    }

    //
    //  If we're already at the node then return it.
    //

    if (I == CurrentLocation) {

        return &((PTABLE_ENTRY_HEADER)CurrentNode)->UserData;
    }

    //
    //  Calculate the forward and backward distance to the node.
    //

    if (CurrentLocation > I) {

        //
        //  When CurrentLocation is greater than where we want to go,
        //  if moving forward gets us there quicker than moving backward
        //  then it follows that moving forward from the first node in tree is
        //  going to take fewer steps. (This is because, moving forward
        //  in this case must move *through* the listhead.)
        //
        //  The work here is to figure out if moving backward would be quicker.
        //
        //  Moving backward would be quicker only if the location we wish  to
        //  go to is half way or more between the listhead and where we
        //  currently are.
        //

        if (I >= (CurrentLocation/2)) {

            //
            //  Where we want to go is more than half way from the listhead
            //  We can traval backwards from our current location.
            //

            for (
                BackwardDistance = CurrentLocation - I;
                BackwardDistance;
                BackwardDistance--
                ) {

                CurrentNode = RealPredecessor(CurrentNode);
            }

        } else {

            //
            //  We just loop until we find the leftmost child of the root,
            //  which is the lowest entry in the tree.
            //

            for (
                CurrentNode = Table->BalancedRoot.RightChild;
                CurrentNode->LeftChild;
                CurrentNode = CurrentNode->LeftChild
                ) {
                NOTHING;
            }

            //
            //  Where we want to go is less than halfway between the start
            //  and where we currently are.  Start from the first node.
            //

            for (
                ;
                I;
                I--
                ) {

                CurrentNode = RealSuccessor(CurrentNode);
            }
        }

    } else {


        //
        //  When CurrentLocation is less than where we want to go,
        //  if moving backwards gets us there quicker than moving forwards
        //  then it follows that moving backwards from the last node is
        //  going to take fewer steps.
        //

        ForwardDistance = I - CurrentLocation;

        //
        //  Do the backwards calculation assuming we are starting with the
        //  last element in the table.  (Thus BackwardDistance is 0 for the
        //  last element in the table.)
        //

        BackwardDistance = NumberInTable - (I + 1);

        //
        //  For our heuristic check, bias BackwardDistance by 1, so that we
        //  do not always have to loop down the right side of the tree to
        //  return the last element in the table!
        //

        if (ForwardDistance <= (BackwardDistance + 1)) {

            for (
                ;
                ForwardDistance;
                ForwardDistance--
                ) {

                CurrentNode = RealSuccessor(CurrentNode);
            }

        } else {

            //
            //  We just loop until we find the rightmost child of the root,
            //  which is the highest entry in the tree.
            //

            for (
                CurrentNode = Table->BalancedRoot.RightChild;
                CurrentNode->RightChild;
                CurrentNode = CurrentNode->RightChild
                ) {
                NOTHING;
            }

            for (
                ;
                BackwardDistance;
                BackwardDistance--
                ) {

                CurrentNode = RealPredecessor(CurrentNode);
            }
        }
    }

    //
    //  We're where we want to be.  Save our current location and return
    //  a pointer to the data to the user.
    //

    Table->OrderedPointer = CurrentNode;
    Table->WhichOrderedElement = I;

    return &((PTABLE_ENTRY_HEADER)CurrentNode)->UserData;
}


ULONG
RtlNumberGenericTableElementsAvl (
    IN PRTL_AVL_TABLE Table
    )

/*++

Routine Description:

    The function NumberGenericTableElements2 returns a ULONG value
    which is the number of generic table elements currently inserted
    in the generic table.

Arguments:

    Table - Pointer to the generic table from which to find out the number
    of elements.


Return Value:

    ULONG - The number of elements in the generic table.

--*/

{
    return Table->NumberGenericTableElements;
}


PVOID
RtlEnumerateGenericTableWithoutSplayingAvl (
    IN PRTL_AVL_TABLE Table,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    The function EnumerateGenericTableWithoutSplayingAvl will return to the
    caller one-by-one the elements of of a table.  The return value is a
    pointer to the user defined structure associated with the element.
    The input parameter RestartKey indicates if the enumeration should
    start from the beginning or should return the next element.  If the
    are no more new elements to return the return value is NULL.  As an
    example of its use, to enumerate all of the elements in a table the
    user would write:

        *RestartKey = NULL;

        for (ptr = EnumerateGenericTableWithoutSplayingAvl(Table, &RestartKey);
             ptr != NULL;
             ptr = EnumerateGenericTableWithoutSplayingAvl(Table, &RestartKey)) {
                :
        }

    For a summary of when to use each of the four enumeration routines, see
    RtlEnumerateGenericTableLikeADirectory.

Arguments:

    Table - Pointer to the generic table to enumerate.

    RestartKey - Pointer that indicates if we should restart or return the next
                element.  If the contents of RestartKey is NULL, the search
                will be started from the beginning.

Return Value:

    PVOID - Pointer to the user data.

--*/

{
    if (RtlIsGenericTableEmptyAvl(Table)) {

        //
        //  Nothing to do if the table is empty.
        //

        return NULL;

    } else {

        //
        //  Will be used as the "iteration" through the tree.
        //
        PRTL_BALANCED_LINKS NodeToReturn;

        //
        //  If the restart flag is true then go to the least element
        //  in the tree.
        //

        if (*RestartKey == NULL) {

            //
            //  We just loop until we find the leftmost child of the root.
            //

            for (
                NodeToReturn = Table->BalancedRoot.RightChild;
                NodeToReturn->LeftChild;
                NodeToReturn = NodeToReturn->LeftChild
                ) {
                ;
            }

            *RestartKey = NodeToReturn;

        } else {

            //
            //  The caller has passed in the previous entry found
            //  in the table to enable us to continue the search.  We call
            //  RealSuccessor to step to the next element in the tree.
            //

            NodeToReturn = RealSuccessor(*RestartKey);

            if (NodeToReturn) {
                *RestartKey = NodeToReturn;
            }
        }

        //
        //  If there actually is a next element in the enumeration
        //  then the pointer to return is right after the list links.
        //

        return ((NodeToReturn)?
                   ((PVOID)&((PTABLE_ENTRY_HEADER)NodeToReturn)->UserData)
                  :((PVOID)(NULL)));
    }
}


PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory (
    IN PRTL_AVL_TABLE Table,
    IN PRTL_AVL_MATCH_FUNCTION MatchFunction OPTIONAL,
    IN PVOID MatchData OPTIONAL,
    IN ULONG NextFlag,
    IN OUT PVOID *RestartKey,
    IN OUT PULONG DeleteCount,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The function EnumerateGenericTableLikeADirectory will return to the
    caller one-by-one the elements of a table in collation order.  The
    return value is a pointer to the user defined structure associated
    with the element.  The in/out parameter RestartKey indicates if the
    enumeration should start from a specified key or should return the
    next element.  If there are no more new elements to return the return
    value is NULL.  As an example of its use, to enumerate all *matched*
    elements in a table the user would write:

        NextFlag = FALSE;
        RestartKey = NULL;
        DeleteCount = 0;
        (Initialize Buffer for start/resume point)

        for (ptr = EnumerateGenericTableLikeADirectory(Table, ...);
             ptr != NULL;
             ptr = EnumerateGenericTableLikeADirectory(Table, ...)) {
                :
        }

    The primary goal of this routine is to provide directory enumeration
    style semantics, for components like TXF which stores lookaside information
    on directories for pending create/delete operations.  In addition a caller
    may be interested in using the extended functionality available for
    directory enumerations, such as the match function or flexible resume
    semantics.

    Enumerations via this routine across intermixed insert and delete operations
    are safe.  All names not involved in inserts and deletes will be returned
    exactly once (unless explicitly resumed from an earlier point), and
    all intermixed inserts and deletes will be seen or not seen based on their
    state at the time the enumeration processes the respective directory range.

    To summarize the four(!) enumeration routines and when to use them:

      - For the simplest way for a single thread to enumerate the entire table
        in collation order and safely across inserts and deletes, use
        RtlEnumerateGenericTableAvl.  This routine is not reentrant, and thus
        requires exclusive access to the table across the entire enumeration.
        (This routine often used by a caller who is deleting all elements of the
        table.)
      - For the simplest way for multiple threads to enumerate the entire table
        in collation order and in parallel, use RtlEnumerateGenericTableWithoutSplayingAvl.
        This routine is not safe across inserts and deletes, and thus should be
        synchronized with shared access to lock out changes across the entire
        enumeration.
      - For the simplest way for multiple threads to enumerate the entire table
        in collation order and in parallel, and with progress across inserts and deletes,
        use RtlGetElementGenericTableAvl.  This routine requires only shared access
        across each individual call (rather than across the entire enumeration).
        However, inserts and deletes can cause items to be repeated or dropped during
        the enumeration.  THEREFORE, THE ROUTINE IS NOT RECOMMENDED.  Use shared access
        across the entire enumeration with the previous routine, or use the LikeADirectory
        routine for shared access on each call only with no repeats or drops.
      - To enumerate the table in multiple threads in collation order, safely
        across inserts and deletes, and with shared access only across individual
        calls, use RtlEnumerateGenericTableLikeADirectory.  This is the only routine
        that supports collation order and synchronization only over individual calls
        without erroneously dropping or repeating names due to inserts or deletes.
        Use this routine also if a matching function or flexible resume semantics are
        required.

Arguments:

    Table - Pointer to the generic table to enumerate.

    MatchFunction - A match function to determine which entries are to be returned.
                    If not specified, all nodes will be returned.

    MatchData - Pointer to be passed to the match function - a simple example might
                be a string expression with wildcards.

    NextFlag - FALSE to return the first/current entry described by RestartKey or
               Buffer (if matched).  TRUE to return the next entry after that (if
               matched).

    RestartKey - Pointer that indicates if we should restart or return the next
                element.  If the contents of RestartKey is NULL, the enumeration
                will be started/resumed from the position described in Buffer.
                If not NULL, the enumeration will resume from the most recent point,
                if there were no intervening deletes.  If there was an intervening
                delete, enumeration will resume from the position described in
                Buffer.  On return this field is updated to remember the key being
                returned.

    DeleteCount - This field is effectively ignored if RestartKey is NULL (nonresume case).
                  Otherwise, enumeration will resume from the RestartKey iff there
                  have been no intervening deletes in the table.  On return this
                  field is always updated with the current DeleteCount from the table.

    Buffer - Passed to the comparison routine if not resuming from RestartKey, to navigate
             the table.  This buffer must contain a key expression.  To repeat a remembered
             key, pass the key here, and ensure RestartKey = NULL and NextFlag is FALSE.
             To return the next key after a remembered key, pass the key here, and ensure
             RestartKey = NULL and NextFlag = TRUE - In either case, if the remembered key
             is now deleted, the next matched key will be returned.

             To enumerate the table from the beginning, initialize Buffer to contain
             <min-key> before the first call with RestartKey = NULL.  To start from an
             arbitrary point in the table, initialize this key to contain the desired
             starting key (or approximate key) before the first call.  So, for example,
             with the proper collate and match functions, to get all entries starting with
             TXF, you could initialize Buffer to be TXF*.  The collate routine would position
             to the first key starting with TXF (as if * was 0), and the match function would
             return STATUS_NO_MORE_MATCHES when the first key was encountered lexigraphically
             beyond TXF* (as if * were 0xFFFF).

Return Value:

    PVOID - Pointer to the user data, or NULL if there are no more matching entries

--*/

{
    NTSTATUS Status;

    //
    //  Holds a pointer to the node in the table or what would be the
    //  parent of the node.
    //

    PTABLE_ENTRY_HEADER NodeOrParent = (PTABLE_ENTRY_HEADER)*RestartKey;

    //
    //  Holds the result of the table lookup.
    //

    TABLE_SEARCH_RESULT Lookup;

    //
    //  Get out if the table is empty.
    //

    if (RtlIsGenericTableEmptyAvl(Table)) {

        *RestartKey = NULL;
        return NULL;
    }

    //
    //  If no MatchFunction was specified, then match all.
    //

    if (MatchFunction == NULL) {
        MatchFunction = &MatchAll;
    }

    //
    //  If there was a delete since the last time DeleteCount was captured, then we
    //  cannot trust the RestartKey.
    //

    if (*DeleteCount != Table->DeleteCount) {
        NodeOrParent = NULL;
    }

    //
    //  No saved key at this pointer, position ourselves in the directory by the key value.
    //

    ASSERT(FIELD_OFFSET(TABLE_ENTRY_HEADER, BalancedLinks) == 0);

    if (NodeOrParent == NULL) {

        Lookup = FindNodeOrParent(
                     Table,
                     Buffer,
                     (PRTL_BALANCED_LINKS *)&NodeOrParent
                     );

        //
        //  If the exact key was not found, we can still use this position, but clea NextFlag
        //  so we do not skip over something that has not been returned yet.
        //

        if (Lookup != TableFoundNode) {

            NextFlag = FALSE;

            //
            //  NodeOrParent points to a parent at which our key buffer could be inserted.
            //  If we were to be the left child, then NodeOrParent just happens to be the correct
            //  successor, otherwise if we would be the right child, then the successor of the
            //  specified key is the successor of  the current NodeOrParent.
            //

            if (Lookup == TableInsertAsRight) {
                NodeOrParent = (PTABLE_ENTRY_HEADER)RealSuccessor((PRTL_BALANCED_LINKS)NodeOrParent);
            }
        }
    }

    //
    //  Now see if we are supposed to skip one.
    //

    if (NextFlag) {
        ASSERT(NodeOrParent != NULL);
        NodeOrParent = (PTABLE_ENTRY_HEADER)RealSuccessor((PRTL_BALANCED_LINKS)NodeOrParent);
    }

    //
    //  Continue to enumerate until we hit the end of the matches or get a match.
    //

    while ((NodeOrParent != NULL) && ((Status = (*MatchFunction)(Table, &NodeOrParent->UserData, MatchData)) == STATUS_NO_MATCH)) {
        NodeOrParent = (PTABLE_ENTRY_HEADER)RealSuccessor((PRTL_BALANCED_LINKS)NodeOrParent);
    }

    //
    //  If we terminated the above loop with a pointer, it is either because we got a match, or
    //  because the match function knows that there will be no more matches.  Fill in the OUT
    //  parameters the same in either case, but only return the UserData pointer if we really
    //  got a match.
    //

    if (NodeOrParent != NULL) {
        ASSERT((Status == STATUS_SUCCESS) || (Status == STATUS_NO_MORE_MATCHES));
        *RestartKey = NodeOrParent;
        *DeleteCount = Table->DeleteCount;
        if (Status == STATUS_SUCCESS) {
            return &NodeOrParent->UserData;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\eballoc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    eballoc.c

Abstract:

    Process/Thread Environment Block allocation functions

--*/

#include "ntrtlp.h"
#include <nturtl.h>

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,RtlAcquirePebLock)
#pragma alloc_text(INIT,RtlReleasePebLock)
#endif


#undef RtlAcquirePebLock

VOID
RtlAcquirePebLock( VOID )
{
}


#undef RtlReleasePebLock

VOID
RtlReleasePebLock( VOID )
{
}

#if DBG
VOID
RtlAssertPebLockOwned( VOID )
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\environ.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    environ.c

Abstract:

    Environment Variable support

--*/

#include "ntrtlp.h"
#include "zwapi.h"
#include "nturtl.h"
#include "string.h"
#include "ntrtlpath.h"
#include "wow64t.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,RtlCreateEnvironment          )
#pragma alloc_text(INIT,RtlDestroyEnvironment         )
#pragma alloc_text(INIT,RtlSetCurrentEnvironment      )
#pragma alloc_text(INIT,RtlQueryEnvironmentVariable_U )
#pragma alloc_text(INIT,RtlSetEnvironmentVariable     )
#pragma alloc_text(INIT,RtlSetEnvironmentStrings)
#endif

BOOLEAN RtlpEnvironCacheValid;

NTSTATUS
RtlCreateEnvironment(
    IN BOOLEAN CloneCurrentEnvironment OPTIONAL,
    OUT PVOID *Environment
    )
{
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemoryInformation;
    PVOID pNew, pOld;
    PPEB Peb;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;

    //
    // If not cloning a copy of the current process's environment variable
    // block, just allocate a block of committed memory and return its
    // address.
    //

    pNew = NULL;
    if (!CloneCurrentEnvironment) {
createEmptyEnvironment:
        MemoryInformation.RegionSize = 1;
        Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                          &pNew,
                                          0,
                                          &MemoryInformation.RegionSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (NT_SUCCESS( Status )) {
            *Environment = pNew;
        }

        return( Status );
    }

    Peb = NtCurrentPeb ();

    ProcessParameters = Peb->ProcessParameters;

    //
    // Acquire the Peb Lock for the duration while we munge the environment
    // variable storage block.
    //

    RtlAcquirePebLock();

    //
    // Capture the pointer to the current process's environment variable
    // block and initialize the new pointer to null for our finally clause.
    //

    pOld = ProcessParameters->Environment;
    if (pOld == NULL) {
        RtlReleasePebLock();
        goto createEmptyEnvironment;
    }

    try {
        try {
            //
            // Query the current size of the current process's environment
            // variable block.  Return status if failure.
            //

            Status = ZwQueryVirtualMemory (NtCurrentProcess (),
                                           pOld,
                                           MemoryBasicInformation,
                                           &MemoryInformation,
                                           sizeof (MemoryInformation),
                                           NULL);
            if (!NT_SUCCESS (Status)) {
                leave;
            }

            //
            // Allocate memory to contain a copy of the current process's
            // environment variable block.  Return status if failure.
            //

            Status = ZwAllocateVirtualMemory (NtCurrentProcess (),
                                              &pNew,
                                              0,
                                              &MemoryInformation.RegionSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE);
            if (!NT_SUCCESS (Status)) {
                leave;
            }

            //
            // Copy the current process's environment to the allocated memory
            // and return a pointer to the copy.
            //

            RtlCopyMemory (pNew, pOld, MemoryInformation.RegionSize);
            *Environment = pNew;
        } except (EXCEPTION_EXECUTE_HANDLER) {
              Status = STATUS_ACCESS_VIOLATION;
        }
    } finally {
        RtlReleasePebLock ();

        if (Status == STATUS_ACCESS_VIOLATION) {
            if (pNew != NULL) {
                ZwFreeVirtualMemory (NtCurrentProcess(),
                                     &pNew,
                                     &MemoryInformation.RegionSize,
                                     MEM_RELEASE);
            }
        }

    }

    return (Status);
}


NTSTATUS
RtlDestroyEnvironment(
    IN PVOID Environment
    )
{
    NTSTATUS Status;
    SIZE_T RegionSize;

    //
    // Free the specified environment variable block.
    //

    RtlpEnvironCacheValid = FALSE;

    RegionSize = 0;
    Status = ZwFreeVirtualMemory( NtCurrentProcess(),
                                  &Environment,
                                  &RegionSize,
                                  MEM_RELEASE
                                );
    //
    // Return status.
    //

    return( Status );
}


NTSTATUS
RtlSetCurrentEnvironment(
    IN PVOID Environment,
    OUT PVOID *PreviousEnvironment OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID pOld;
    PPEB Peb;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;

    //
    // Acquire the Peb Lock for the duration while we munge the environment
    // variable storage block.
    //

    Peb = NtCurrentPeb ();

    ProcessParameters = Peb->ProcessParameters;


    Status = STATUS_SUCCESS;

    RtlAcquirePebLock ();

    RtlpEnvironCacheValid = FALSE;

    //
    // Capture current process's environment variable block pointer to
    // return to caller or destroy.
    //

    pOld = ProcessParameters->Environment;

    //
    // Change current process's environment variable block pointer to
    // point to the passed block.
    //

    ProcessParameters->Environment = Environment;

    //
    // Release the Peb Lock
    //

    RtlReleasePebLock ();

    //
    // If caller requested it, return the pointer to the previous
    // process environment variable block and set the local variable
    // to NULL so we dont destroy it below.
    //

    if (ARGUMENT_PRESENT (PreviousEnvironment)) {
        *PreviousEnvironment = pOld;
    } else {
        //
        // If old environment not returned to caller, destroy it.
        //
 
        if (pOld != NULL) {
            RtlDestroyEnvironment (pOld);
        }
    }


    //
    // Return status
    //

    return (Status);
}

UNICODE_STRING RtlpEnvironCacheName;
UNICODE_STRING RtlpEnvironCacheValue;

NTSTATUS
RtlQueryEnvironmentVariable_U(
    IN PVOID Environment OPTIONAL,
    IN PCUNICODE_STRING Name,
    IN OUT PUNICODE_STRING Value
    )
{
    NTSTATUS Status;
    UNICODE_STRING CurrentName;
    UNICODE_STRING CurrentValue;
    PWSTR p, q;
    PPEB Peb;
    BOOLEAN PebLockLocked = FALSE;
    SIZE_T len;
    SIZE_T NameLength, NameChars;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;

    Status = STATUS_VARIABLE_NOT_FOUND;

    Peb = NtCurrentPeb();

    ProcessParameters = Peb->ProcessParameters;

    try {
        if (ARGUMENT_PRESENT (Environment)) {
            p = Environment;
            if (*p == UNICODE_NULL) {
                leave;
            }
        } else {


            //
            // Acquire the Peb Lock for the duration while we munge the
            // environment variable storage block.
            //

            PebLockLocked = TRUE;

            RtlAcquirePebLock ();

            //
            // Capture the pointer to the current process's environment variable
            // block.
            //

            p = ProcessParameters->Environment;

        }

        if (RtlpEnvironCacheValid && p == ProcessParameters->Environment) {
            if (RtlEqualUnicodeString (Name, &RtlpEnvironCacheName, TRUE)) {

                //
                // Names are equal.  Always return the length of the
                // value string, excluding the terminating null.  If
                // there is room in the caller's buffer, return a copy
                // of the value string and success status.  Otherwise
                // return an error status.  In the latter case, the caller
                // can examine the length field of their value string
                // so they can determine much memory is needed.
                //

                Value->Length = RtlpEnvironCacheValue.Length;
                if (Value->MaximumLength >= RtlpEnvironCacheValue.Length) {
                    RtlCopyMemory (Value->Buffer,
                                   RtlpEnvironCacheValue.Buffer,
                                   RtlpEnvironCacheValue.Length);
                    //
                    // Null terminate returned string if there is room.
                    //

                    if (Value->MaximumLength > RtlpEnvironCacheValue.Length) {
                        Value->Buffer[RtlpEnvironCacheValue.Length/sizeof(WCHAR)] = L'\0';
                    }

                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_BUFFER_TOO_SMALL;
                }
                leave;
            }
        }

        //
        // The environment variable block consists of zero or more null
        // terminated UNICODE strings.  Each string is of the form:
        //
        //      name=value
        //
        // where the null termination is after the value.
        //
        NameLength = Name->Length;
        NameChars = NameLength / sizeof (WCHAR);

        if (p != NULL) while (1) {

            //
            // Get the length of the terminated string. This should be in the
            // form 'keyword=value'
            //
            len = wcslen (p);
            if (len == 0) {
                break;
            }

            //
            // See if this environment variable is big enough to be our target.
            // If must be at least one bigger than the name we are searching
            // for since it must contain an '=' sign.
            //

            if (NameChars < len) {
                q = &p[NameChars];
                //
                // We have a possible match. See if there is an '=' at the correct point.
                //
                if (*q == L'=') {
                    //
                    // We have a possible match. Now compare the string out right
                    //
                    CurrentName.Length = (USHORT) NameLength;
                    CurrentName.Buffer = p;

                    //
                    // After comparing the strings we want to make sure we are not
                    // matching something that we shouldn't. For example if somebody
                    // did a lookup of "FRED=BOB" we don't want this to match "FRED=BOB=ALBERT".
                    // The lookup name is invalid and the environment variable is really FRED here
                    // not "FRED=BOB". To eliminate this case we make sure that the "=" character
                    // is at the appropriate place
                    // There are environment variable of the for =C:
                    // In order not to eliminate these we skip the first character in our search.
                    //
                    if (RtlEqualUnicodeString (Name, &CurrentName, TRUE) &&
                        (wcschr (p+1, L'=') == q)) {
                        //
                        // Names are equal.  Always return the length of the
                        // value string, excluding the terminating null.  If
                        // there is room in the caller's buffer, return a copy
                        // of the value string and success status.  Otherwise
                        // return an error status.  In the latter case, the caller
                        // can examine the length field of their value string
                        // so they can determine much memory is needed.
                        //
                        CurrentValue.Buffer = q+1;
                        CurrentValue.Length = (USHORT) ((len - 1) * sizeof (WCHAR) - NameLength);

                        Value->Length = CurrentValue.Length;
                        if (Value->MaximumLength >= CurrentValue.Length) {
                            RtlCopyMemory( Value->Buffer,
                                           CurrentValue.Buffer,
                                           CurrentValue.Length
                                         );
                            //
                            // Null terminate returned string if there is room.
                            //

                            if (Value->MaximumLength > CurrentValue.Length) {
                                Value->Buffer[ CurrentValue.Length/sizeof(WCHAR) ] = L'\0';
                            }

                            if (Environment == ProcessParameters->Environment) {
                                RtlpEnvironCacheValid = TRUE;
                                RtlpEnvironCacheName = CurrentName;
                                RtlpEnvironCacheValue = CurrentValue;
                            }

                            Status = STATUS_SUCCESS;
                        } else {
                            Status = STATUS_BUFFER_TOO_SMALL;
                        }

                        break;
                    }

                }
            }
            p += len + 1;
        }

        // If it's not in the real env block, let's see if it's a pseudo environment variable
        if (Status == STATUS_VARIABLE_NOT_FOUND) {
            static const UNICODE_STRING CurrentWorkingDirectoryPseudoVariable = RTL_CONSTANT_STRING(L"__CD__");
            static const UNICODE_STRING ApplicationDirectoryPseudoVariable = RTL_CONSTANT_STRING(L"__APPDIR__");

            if (RtlEqualUnicodeString(Name, &CurrentWorkingDirectoryPseudoVariable, TRUE)) {
                // Get the PEB lock if we don't already have it.
                if (!PebLockLocked) {
                    PebLockLocked = TRUE;
                    RtlAcquirePebLock();
                }

                // get cdw here...
                CurrentValue = ProcessParameters->CurrentDirectory.DosPath;
                Status = STATUS_SUCCESS;
            } else if (RtlEqualUnicodeString(Name, &ApplicationDirectoryPseudoVariable, TRUE)) {
                USHORT PrefixLength = 0;

                if (!PebLockLocked) {
                    PebLockLocked = TRUE;
                    RtlAcquirePebLock();
                }

                // get appdir here 
                CurrentValue = ProcessParameters->ImagePathName;

                Status = RtlFindCharInUnicodeString(
                                RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                                &CurrentValue,
                                &RtlDosPathSeparatorsString,
                                &PrefixLength);
                if (NT_SUCCESS(Status)) {
                    CurrentValue.Length = PrefixLength + sizeof(WCHAR);
                } else if (Status == STATUS_NOT_FOUND) {
                    // Use the whole thing; just translate the status to success.
                    Status = STATUS_SUCCESS;
                }
            }

            if (NT_SUCCESS(Status)) {
                Value->Length = CurrentValue.Length;
                if (Value->MaximumLength >= CurrentValue.Length) {
                    RtlCopyMemory(Value->Buffer, CurrentValue.Buffer, CurrentValue.Length);

                    //
                    // Null terminate returned string if there is room.
                    //

                    if (Value->MaximumLength > CurrentValue.Length)
                        Value->Buffer[ CurrentValue.Length/sizeof(WCHAR) ] = L'\0';
                }
            }
        }



    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_ACCESS_VIOLATION;
    }


    //
    // Release the Peb lock.
    //

    if (PebLockLocked) {
        RtlReleasePebLock();
    }

    //
    // Return status.
    //

    return Status;
}


NTSTATUS
RtlSetEnvironmentVariable(
    IN OUT PVOID *Environment OPTIONAL,
    IN PCUNICODE_STRING Name,
    IN PCUNICODE_STRING Value OPTIONAL
    )
{
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemoryInformation;
    UNICODE_STRING CurrentName;
    UNICODE_STRING CurrentValue;
    PVOID pOld, pNew;
    ULONG n, Size;
    SIZE_T NewSize;
    LONG CompareResult;
    PWSTR p, pStart, pEnd;
    PWSTR InsertionPoint;
    PPEB Peb;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;

    //
    // Validate passed in name and reject if zero length or anything but the first
    // character is an equal sign.
    //
    n = Name->Length / sizeof( WCHAR );
    if (n == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    try {
        p = Name->Buffer;
        while (--n) {
            if (*++p == L'=') {
                return STATUS_INVALID_PARAMETER;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    Peb = NtCurrentPeb ();

    ProcessParameters = Peb->ProcessParameters;

    Status = STATUS_VARIABLE_NOT_FOUND;

    pNew = NULL;
    InsertionPoint = NULL;

    if (ARGUMENT_PRESENT (Environment)) {
        pOld = *Environment;
    } else {
        //
        // Acquire the Peb Lock for the duration while we munge the
        // environment variable storage block.
        //

        RtlAcquirePebLock();

        //
        // Capture the pointer to the current process's environment variable
        // block.
        //

        pOld = ProcessParameters->Environment;
    }

    RtlpEnvironCacheValid = FALSE;

    try {
        try {

            //
            // The environment variable block consists of zero or more null
            // terminated UNICODE strings.  Each string is of the form:
            //
            //      name=value
            //
            // where the null termination is after the value.
            //

            p = pOld;
            pEnd = NULL;
            if (p != NULL) while (*p) {
                //
                // Determine the size of the name and value portions of
                // the current string of the environment variable block.
                //

                CurrentName.Buffer = p;
                CurrentName.Length = 0;
                CurrentName.MaximumLength = 0;
                while (*p) {
                    //
                    // If we see an equal sign, then compute the size of
                    // the name portion and scan for the end of the value.
                    //

                    if (*p == L'=' && p != CurrentName.Buffer) {
                        CurrentName.Length = (USHORT)(p - CurrentName.Buffer) * sizeof(WCHAR);
                        CurrentName.MaximumLength = (USHORT)(CurrentName.Length+sizeof(WCHAR));
                        CurrentValue.Buffer = ++p;

                        while(*p) {
                            p++;
                        }
                        CurrentValue.Length = (USHORT)(p - CurrentValue.Buffer) * sizeof(WCHAR);
                        CurrentValue.MaximumLength = (USHORT)(CurrentValue.Length+sizeof(WCHAR));

                        //
                        // At this point we have the length of both the name
                        // and value portions, so exit the loop so we can
                        // do the compare.
                        //
                        break;
                    }
                    else {
                        p++;
                    }
                }

                //
                // Skip over the terminating null character for this name=value
                // pair in preparation for the next iteration of the loop.
                //

                p++;

                //
                // Compare the current name with the one requested, ignore
                // case.
                //

                if (!(CompareResult = RtlCompareUnicodeString( Name, &CurrentName, TRUE ))) {
                    //
                    // Names are equal.  Now find the end of the current
                    // environment variable block.
                    //

                    pEnd = p;
                    while (*pEnd) {
                        while (*pEnd++) {
                        }
                    }
                    pEnd++;

                    if (!ARGUMENT_PRESENT( Value )) {
                        //
                        // If the caller did not specify a new value, then delete
                        // the entire name=value pair by copying up the remainder
                        // of the environment variable block.
                        //

                        RtlMoveMemory( CurrentName.Buffer,
                                       p,
                                       (ULONG) ((pEnd - p)*sizeof(WCHAR))
                                     );
                        Status = STATUS_SUCCESS;

                    } else if (Value->Length <= CurrentValue.Length) {
                        //
                        // New value is smaller, so copy new value, then null
                        // terminate it, and then move up the remainder of the
                        // variable block so it is immediately after the new
                        // null terminated value.
                        //

                        pStart = CurrentValue.Buffer;
                        RtlMoveMemory( pStart, Value->Buffer, Value->Length );
                        pStart += Value->Length/sizeof(WCHAR);
                        *pStart++ = L'\0';

                        RtlMoveMemory( pStart, p,(ULONG)((pEnd - p)*sizeof(WCHAR)) );
                        Status = STATUS_SUCCESS;
                    } else {
                        //
                        // New value is larger, so query the current size of the
                        // environment variable block.  Return status if failure.
                        //

                        Status = ZwQueryVirtualMemory( NtCurrentProcess(),
                                                       pOld,
                                                       MemoryBasicInformation,
                                                       &MemoryInformation,
                                                       sizeof( MemoryInformation ),
                                                       NULL
                                                     );
                        if (!NT_SUCCESS( Status )) {
                            leave;
                        }

                        //
                        // See if there is room for new, larger value.  If not
                        // allocate a new copy of the environment variable
                        // block.
                        //

                        NewSize = (pEnd - (PWSTR)pOld)*sizeof(WCHAR) +
                                    Value->Length - CurrentValue.Length;
                        if (NewSize >= MemoryInformation.RegionSize) {
                            //
                            // Allocate memory to contain a copy of the current
                            // process's environment variable block.  Return
                            // status if failure.
                            //

                            Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                                              &pNew,
                                                              0,
                                                              &NewSize,
                                                              MEM_COMMIT,
                                                              PAGE_READWRITE
                                                            );
                            if (!NT_SUCCESS( Status )) {
                                leave;
                            }

                            //
                            // Copy the current process's environment to the allocated memory
                            // inserting the new value as we do the copy.
                            //

                            Size = (ULONG) (CurrentValue.Buffer - (PWSTR)pOld);
                            RtlMoveMemory( pNew, pOld, Size*sizeof(WCHAR) );
                            pStart = (PWSTR)pNew + Size;
                            RtlMoveMemory( pStart, Value->Buffer, Value->Length );
                            pStart += Value->Length/sizeof(WCHAR);
                            *pStart++ = L'\0';
                            RtlMoveMemory( pStart, p,(ULONG)((pEnd - p)*sizeof(WCHAR)));

    			            if (ARGUMENT_PRESENT( Environment )) {
    			                *Environment = pNew;
                            } else {
    			                ProcessParameters->Environment = pNew;

#if defined(BUILD_WOW6432)
                                ((PRTL_USER_PROCESS_PARAMETERS64)(NtCurrentPeb64()->ProcessParameters))->Environment = (ULONGLONG)(ULONG)pNew;
#endif
                                Peb->EnvironmentUpdateCount += 1;
                            }

                            ZwFreeVirtualMemory (NtCurrentProcess(),
                                                 &pOld,
                                                 &MemoryInformation.RegionSize,
                                                 MEM_RELEASE);
                            pNew = pOld;
                        } else {
                            pStart = CurrentValue.Buffer + Value->Length/sizeof(WCHAR) + 1;
                            RtlMoveMemory (pStart, p, (ULONG)((pEnd - p)*sizeof(WCHAR)));
                            *--pStart = L'\0';

                            RtlMoveMemory (pStart - Value->Length/sizeof(WCHAR),
                                           Value->Buffer,
                                           Value->Length);
                        }
                    }

                    break;
                } else if (CompareResult < 0) {
                    //
                    // Requested name is less than the current name.  Save this
                    // spot in case the variable is not in a sorted position.
                    // The insertion point for the new variable is before the
                    // variable just examined.
                    //

                    if (InsertionPoint == NULL) {
                        InsertionPoint = CurrentName.Buffer;
                    }
                }
            }

            //
            // If we found an insertion point, reset the string
            // pointer back to it.
            //

            if (InsertionPoint != NULL) {
                p = InsertionPoint;
            }

            //
            // If variable name not found and a new value parameter was specified
            // then insert the new variable name and its value at the appropriate
            // place in the environment variable block (i.e. where p points to).
            //

            if (pEnd == NULL && ARGUMENT_PRESENT( Value )) {
                if (p != NULL) {
                    //
                    // Name not found.  Now find the end of the current
                    // environment variable block.
                    //

                    pEnd = p;
                    while (*pEnd) {
                        while (*pEnd++) {
                        }
                    }
                    pEnd++;

                    //
                    // New value is present, so query the current size of the
                    // environment variable block.  Return status if failure.
                    //

                    Status = ZwQueryVirtualMemory( NtCurrentProcess(),
                                                   pOld,
                                                   MemoryBasicInformation,
                                                   &MemoryInformation,
                                                   sizeof( MemoryInformation ),
                                                   NULL
                                                 );
                    if (!NT_SUCCESS( Status )) {
                        leave;
                    }

                    //
                    // See if there is room for new, larger value.  If not
                    // allocate a new copy of the environment variable
                    // block.
                    //

                    NewSize = (pEnd - (PWSTR)pOld) * sizeof(WCHAR) +
                              Name->Length +
                              sizeof(WCHAR) +
                              Value->Length +
                              sizeof(WCHAR);
                } else {
                    NewSize = Name->Length +
                              sizeof(WCHAR) +
                              Value->Length +
                              sizeof(WCHAR);
                    MemoryInformation.RegionSize = 0;
                }

                if (NewSize >= MemoryInformation.RegionSize) {
                    //
                    // Allocate memory to contain a copy of the current
                    // process's environment variable block.  Return
                    // status if failure.
                    //

                    Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                                      &pNew,
                                                      0,
                                                      &NewSize,
                                                      MEM_COMMIT,
                                                      PAGE_READWRITE
                                                    );
                    if (!NT_SUCCESS( Status )) {
                        leave;
                    }

                    //
                    // Copy the current process's environment to the allocated memory
                    // inserting the new value as we do the copy.
                    //

                    if (p != NULL) {
                        Size = (ULONG)(p - (PWSTR)pOld);
                        RtlMoveMemory( pNew, pOld, Size*sizeof(WCHAR) );
                    } else {
                        Size = 0;
                    }
                    pStart = (PWSTR)pNew + Size;
                    RtlMoveMemory( pStart, Name->Buffer, Name->Length );
                    pStart += Name->Length/sizeof(WCHAR);
                    *pStart++ = L'=';
                    RtlMoveMemory( pStart, Value->Buffer, Value->Length );
                    pStart += Value->Length/sizeof(WCHAR);
                    *pStart++ = L'\0';
                    if (p != NULL) {
                        RtlMoveMemory( pStart, p,(ULONG)((pEnd - p)*sizeof(WCHAR)) );
                    }

                    if (ARGUMENT_PRESENT( Environment )) {
    		            *Environment = pNew;
                    } else {
    		            ProcessParameters->Environment = pNew;
#if defined(BUILD_WOW6432)
                        ((PRTL_USER_PROCESS_PARAMETERS64)(NtCurrentPeb64()->ProcessParameters))->Environment = (ULONGLONG)(ULONG)pNew;
#endif
                        Peb->EnvironmentUpdateCount += 1;
                    }

                    ZwFreeVirtualMemory (NtCurrentProcess(),
                                         &pOld,
                                         &MemoryInformation.RegionSize,
                                         MEM_RELEASE);
                } else {
                    pStart = p + Name->Length/sizeof(WCHAR) + 1 + Value->Length/sizeof(WCHAR) + 1;
                    RtlMoveMemory( pStart, p,(ULONG)((pEnd - p)*sizeof(WCHAR)) );
                    RtlMoveMemory( p, Name->Buffer, Name->Length );
                    p += Name->Length/sizeof(WCHAR);
                    *p++ = L'=';
                    RtlMoveMemory( p, Value->Buffer, Value->Length );
                    p += Value->Length/sizeof(WCHAR);
                    *p++ = L'\0';
                }
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
              //
              // If abnormally terminating, assume access violation.
              //

              Status = STATUS_ACCESS_VIOLATION;
        }
    } finally {
        //
        // Release the Peb lock.
        //

        if (!ARGUMENT_PRESENT( Environment )) {
            RtlReleasePebLock();
        }
    }

    //
    // Return status.
    //

    return( Status );
}

NTSTATUS
NTAPI
RtlSetEnvironmentStrings(
    IN PWCHAR NewEnvironment,
    IN SIZE_T NewEnvironmentSize
    )
/*++

Routine Description:

    This routine allows the replacement of the current environment block with a new one.

Arguments:

    NewEnvironment - Pointer to a set of zero terminated strings terminated by two terminators

    NewEnvironmentSize - Size of the block to put in place in bytes

Return Value:

    NTSTATUS - Status of function call

--*/
{
    PPEB Peb;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID pOld, pNew;
    NTSTATUS Status, Status1;
    SIZE_T NewSize, OldSize;
    MEMORY_BASIC_INFORMATION MemoryInformation;


    //
    // Assert if the block is not well formed
    //
    ASSERT (NewEnvironmentSize > sizeof (WCHAR) * 2);
    ASSERT ((NewEnvironmentSize & (sizeof (WCHAR) - 1)) == 0);
    ASSERT (NewEnvironment[NewEnvironmentSize/sizeof(WCHAR)-1] == L'\0');
    ASSERT (NewEnvironment[NewEnvironmentSize/sizeof(WCHAR)-2] == L'\0');

    Peb = NtCurrentPeb ();

    ProcessParameters = Peb->ProcessParameters;

    RtlAcquirePebLock ();

    pOld = ProcessParameters->Environment;

    Status = ZwQueryVirtualMemory (NtCurrentProcess (),
                                   pOld,
                                   MemoryBasicInformation,
                                   &MemoryInformation,
                                   sizeof (MemoryInformation),
                                   NULL);
    if (!NT_SUCCESS (Status)) {
        goto unlock_and_exit;
    }

    if (MemoryInformation.RegionSize >= NewEnvironmentSize) {
        RtlpEnvironCacheValid = FALSE;
        RtlCopyMemory (pOld, NewEnvironment, NewEnvironmentSize);
        Status = STATUS_SUCCESS;
        goto unlock_and_exit;
    }

    //
    // Drop the lock around expensive operations
    //

    RtlReleasePebLock ();

    pOld = NULL;
    pNew = NULL;

    NewSize = NewEnvironmentSize;

    Status = ZwAllocateVirtualMemory (NtCurrentProcess (),
                                      &pNew,
                                      0,
                                      &NewSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Fill in the new block.
    //
    RtlCopyMemory (pNew, NewEnvironment, NewEnvironmentSize);

    //
    // Reacquire the lock. The existing block may have been reallocated
    // and so may now be big enough. Ignore this and use the block we
    // have created anyway.
    //

    RtlAcquirePebLock ();

    pOld = ProcessParameters->Environment;

    ProcessParameters->Environment = pNew;

#if defined(BUILD_WOW6432)
    ((PRTL_USER_PROCESS_PARAMETERS64)(NtCurrentPeb64()->ProcessParameters))->Environment = (ULONGLONG)(ULONG)pNew;
#endif

    RtlpEnvironCacheValid = FALSE;

    RtlReleasePebLock ();


    //
    // Release the old block.
    //

    OldSize = 0;

    Status1 = ZwFreeVirtualMemory (NtCurrentProcess(),
                                   &pOld,
                                   &OldSize,
                                   MEM_RELEASE);

    ASSERT (NT_SUCCESS (Status1));

    return STATUS_SUCCESS;


unlock_and_exit:;
    RtlReleasePebLock ();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\cnvint.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cnvint.c

Abstract:

    Text to integer and integer to text conversion routines.

--*/

#include <ntrtlp.h>

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,RtlIntegerToChar)
#pragma alloc_text(PAGE,RtlCharToInteger)
#pragma alloc_text(PAGE,RtlUnicodeStringToInteger)
#pragma alloc_text(PAGE,RtlIntegerToUnicode)
#pragma alloc_text(PAGE,RtlIntegerToUnicodeString)
#pragma alloc_text(PAGE,RtlLargeIntegerToChar)
#pragma alloc_text(PAGE,RtlLargeIntegerToUnicode)
#pragma alloc_text(PAGE,RtlInt64ToUnicodeString)
#endif

#if defined(ALLOC_DATA_PRAGMA)
#pragma const_seg("PAGECONST")
#endif
const CHAR RtlpIntegerChars[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                           '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

const WCHAR RtlpIntegerWChars[] = { L'0', L'1', L'2', L'3', L'4', L'5',
                              L'6', L'7', L'8', L'9', L'A', L'B',
                              L'C', L'D', L'E', L'F' };

NTSTATUS
RtlIntegerToChar (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR Result[33], *s;
    ULONG Shift, Mask, Digit, Length;

    RTL_PAGED_CODE();

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:    Base = 10;
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = (1 << Shift) - 1;
    }

    s = &Result[33];
    do {
        if (Shift != 0) {
            Digit = Value & Mask;
            Value >>= Shift;
        } else {
            Digit = Value % Base;
            Value = Value / Base;
        }

        *--s = RtlpIntegerChars[Digit];
    } while (Value != 0);

    Length = (ULONG) (&Result[33] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *String++ = '0';
            OutputLength--;
        }
    }

    if ((LONG)Length > OutputLength) {
        return (STATUS_BUFFER_OVERFLOW);
    } else {
        try {
            RtlCopyMemory (String, s, Length);

            if ((LONG)Length < OutputLength) {
                String[Length] = '\0';
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return (GetExceptionCode ());
        }

        return (STATUS_SUCCESS);
    }
}


NTSTATUS
RtlCharToInteger (
    IN PCSZ String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    CHAR c, Sign;
    ULONG Result, Digit, Shift;

    RTL_PAGED_CODE();

    while ((Sign = *String++) <= ' ') {
        if (!*String) {
            String--;
            break;
        }
    }

    c = Sign;
    if (c == '-' || c == '+') {
        c = *String++;
    }

    if (!ARGUMENT_PRESENT( Base )) {
        Base = 10;
        Shift = 0;
        if (c == '0') {
            c = *String++;
            if (c == 'x') {
                Base = 16;
                Shift = 4;
            } else if (c == 'o') {
                Base = 8;
                Shift = 3;
            } else if (c == 'b') {
                Base = 2;
                Shift = 1;
            } else {
                String--;
            }

            c = *String++;
        }
    } else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( STATUS_INVALID_PARAMETER );
        }
    }

    Result = 0;
    while (c) {
        if (c >= '0' && c <= '9') {
            Digit = c - '0';
        } else if (c >= 'A' && c <= 'F') {
            Digit = c - 'A' + 10;
        } else if (c >= 'a' && c <= 'f') {
            Digit = c - 'a' + 10;
        } else {
            break;
        }

        if (Digit >= Base) {
            break;
        }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
        } else {
            Result = (Result << Shift) | Digit;
        }

        c = *String++;
    }

    if (Sign == '-') {
        Result = (ULONG)(-(LONG)Result);
    }

    try {
        *Value = Result;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        return( GetExceptionCode() );
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlUnicodeStringToInteger (
    IN PCUNICODE_STRING String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    PCWSTR s;
    WCHAR c, Sign;
    ULONG nChars, Result, Digit, Shift;

    RTL_PAGED_CODE();

    s = String->Buffer;
    nChars = String->Length / sizeof( WCHAR );
    while (nChars-- && (Sign = *s++) <= ' ') {
        if (!nChars) {
            Sign = UNICODE_NULL;
            break;
            }
        }

    c = Sign;
    if (c == L'-' || c == L'+') {
        if (nChars) {
            nChars--;
            c = *s++;
            }
        else {
            c = UNICODE_NULL;
            }
        }

    if (!ARGUMENT_PRESENT( Base )) {
        Base = 10;
        Shift = 0;
        if (c == L'0') {
            if (nChars) {
                nChars--;
                c = *s++;
                if (c == L'x') {
                    Base = 16;
                    Shift = 4;
                    }
                else
                if (c == L'o') {
                    Base = 8;
                    Shift = 3;
                    }
                else
                if (c == L'b') {
                    Base = 2;
                    Shift = 1;
                    }
                else {
                    nChars++;
                    s--;
                    }
                }

            if (nChars) {
                nChars--;
                c = *s++;
                }
            else {
                c = UNICODE_NULL;
                }
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( STATUS_INVALID_PARAMETER );
            }
        }

    Result = 0;
    while (c != UNICODE_NULL) {
        if (c >= L'0' && c <= L'9') {
            Digit = c - L'0';
            }
        else
        if (c >= L'A' && c <= L'F') {
            Digit = c - L'A' + 10;
            }
        else
        if (c >= L'a' && c <= L'f') {
            Digit = c - L'a' + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        if (!nChars) {
            break;
            }
        nChars--;
        c = *s++;
        }

    if (Sign == L'-') {
        Result = (ULONG)(-(LONG)Result);
        }

    try {
        *Value = Result;
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        return( GetExceptionCode() );
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlIntegerToUnicode (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR Result[33], *s;
    ULONG Shift, Mask, Digit, Length;

    RTL_PAGED_CODE();

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:    Base = 10;
        case 10:    Shift = 0;  break;
        default:    return (STATUS_INVALID_PARAMETER);
    }

    if (Shift != 0) {
        Mask = (1 << Shift) - 1;
    }

    s = &Result[33];
    do {
        if (Shift != 0) {
            Digit = Value & Mask;
            Value >>= Shift;
        } else {
            Digit = Value % Base;
            Value = Value / Base;
        }

        *--s = RtlpIntegerWChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG) (&Result[33] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *String++ = L'0';
            OutputLength--;
        }
    }

    if ((LONG)Length > OutputLength) {
        return (STATUS_BUFFER_OVERFLOW);
    } else {
        try {
            RtlCopyMemory (String, s, Length * sizeof (WCHAR));

            if ((LONG)Length < OutputLength) {
                String[Length] = L'\0';
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return (GetExceptionCode ());
        }

        return (STATUS_SUCCESS);
    }
}


NTSTATUS
RtlIntegerToUnicodeString (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    )
{
    NTSTATUS Status;
    UCHAR ResultBuffer[16];
    ANSI_STRING AnsiString;

    RTL_PAGED_CODE();

    Status = RtlIntegerToChar (Value, Base, sizeof (ResultBuffer), ResultBuffer);
    if (NT_SUCCESS (Status)) {
        AnsiString.Buffer = ResultBuffer;
        AnsiString.MaximumLength = sizeof (ResultBuffer);
        AnsiString.Length = (USHORT)strlen (ResultBuffer);
        Status = RtlAnsiStringToUnicodeString (String, &AnsiString, FALSE);
     }

    return( Status );
}


#define MAX_DIGITS 65

NTSTATUS
RtlLargeIntegerToChar (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR Result[MAX_DIGITS], *s;
    ULONG Shift, Mask, Digit, Length;

    RTL_PAGED_CODE();

    Shift = 0;
    switch (Base) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:
        case 10:    Shift = 0;  break;
        default:    return (STATUS_INVALID_PARAMETER);
    }

    if (Shift != 0) {
        Mask = (1 << Shift) - 1;
    }

    s = &Result[MAX_DIGITS];

    if (Shift != 0) {
        ULONGLONG tValue;

        tValue = (ULONGLONG) Value->QuadPart;
        do {
            Digit  = (ULONG) (tValue & Mask);
            tValue = tValue >> Shift;
            *--s = RtlpIntegerChars[Digit];
        } while (tValue != 0);

    } else {
        LARGE_INTEGER TempValue = *Value;
        do {
            TempValue = RtlExtendedLargeIntegerDivide (TempValue, Base, &Digit);
            *--s = RtlpIntegerChars [Digit];
        } while (TempValue.QuadPart != 0);
    }

    Length = (ULONG)(&Result[MAX_DIGITS] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *String++ = '0';
            OutputLength--;
        }
    }

    if ((LONG)Length > OutputLength) {
        return (STATUS_BUFFER_OVERFLOW);
    } else {
        try {
            RtlCopyMemory (String, s, Length);

            if ((LONG)Length < OutputLength) {
                String[Length] = '\0';
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return (GetExceptionCode ());
        }

        return (STATUS_SUCCESS);
    }
}

NTSTATUS
RtlLargeIntegerToUnicode (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR Result [MAX_DIGITS], *s;
    ULONG Shift, Mask, Digit, Length;

    RTL_PAGED_CODE();

    Shift = 0;
    switch (Base) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:
        case 10:    Shift = 0;  break;
        default:    return (STATUS_INVALID_PARAMETER);
    }

    if (Shift != 0) {
        Mask = (1 << Shift) - 1;
    }

    s = &Result [MAX_DIGITS];
    if (Shift != 0) {
        ULONGLONG tValue;

        tValue = (ULONGLONG) Value->QuadPart;
        do {
            Digit  = (ULONG) (tValue & Mask);
            tValue = tValue >> Shift;
            *--s = RtlpIntegerWChars[Digit];
        } while (tValue != 0);
    } else {
        LARGE_INTEGER TempValue = *Value;
        do {
            TempValue = RtlExtendedLargeIntegerDivide (TempValue, Base, &Digit);
            *--s = RtlpIntegerWChars[Digit];
        } while (TempValue.QuadPart != 0);
    }

    Length = (ULONG)(&Result[MAX_DIGITS] - s);

    ASSERT (Length <= MAX_DIGITS);

    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *String++ = L'0';
            OutputLength--;
        }
    }

    if ((LONG)Length > OutputLength) {
        return (STATUS_BUFFER_OVERFLOW);
    } else {
        try {
            RtlCopyMemory (String, s, Length * sizeof(WCHAR));

            if ((LONG)Length < OutputLength) {
                String [Length] = L'\0';
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return (GetExceptionCode ());
        }

        return (STATUS_SUCCESS);
    }
}

NTSTATUS
RtlInt64ToUnicodeString (
    IN ULONGLONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    )

{

    NTSTATUS Status;
    UCHAR ResultBuffer[32];
    ANSI_STRING AnsiString;
    LARGE_INTEGER Temp;

    RTL_PAGED_CODE();

    Temp.QuadPart = Value;
    Status = RtlLargeIntegerToChar(&Temp,
                                   Base,
                                   sizeof(ResultBuffer),
                                   ResultBuffer);

    if (NT_SUCCESS(Status)) {
        AnsiString.Buffer = ResultBuffer;
        AnsiString.MaximumLength = sizeof(ResultBuffer);
        AnsiString.Length = (USHORT)strlen(ResultBuffer);
        Status = RtlAnsiStringToUnicodeString(String, &AnsiString, FALSE);
    }

    return Status;
}

#if defined(ALLOC_DATA_PRAGMA)
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\error.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    error.c

Abstract:

    This module contains a routine for converting NT status codes
    to DOS/OS|2 error codes.

--*/

#include <ntrtlp.h>
#include "winerror.h"
#include "error.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, RtlGetLastNtStatus)
#pragma alloc_text(PAGE, RtlGetLastWin32Error)
#pragma alloc_text(PAGE, RtlNtStatusToDosError)
#pragma alloc_text(PAGE, RtlRestoreLastWin32Error)
#pragma alloc_text(PAGE, RtlSetLastWin32Error)
#pragma alloc_text(PAGE, RtlSetLastWin32ErrorAndNtStatusFromNtStatus)
#endif

//
// Ensure that the Registry ERROR_SUCCESS error code and the
// NO_ERROR error code remain equal and zero.
//

#if ERROR_SUCCESS != 0 || NO_ERROR != 0
#error Invalid value for ERROR_SUCCESS.
#endif

ULONG
RtlNtStatusToDosError (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine converts an NT status code to its DOS/OS|2 equivalent.
    Remembers the Status code value in the TEB.

Arguments:

    Status - Supplies the status value to convert.

Return Value:

    The matching DOS/OS|2 error code.

--*/

{
    PTEB Teb;

    Teb = NtCurrentTeb();

    if (Teb) {
        try {
            Teb->LastStatusValue = Status;
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    return RtlNtStatusToDosErrorNoTeb( Status );
}

ULONG
RtlNtStatusToDosErrorNoTeb (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine converts an NT status code to its DOS/OS 2 equivalent
    and returns the translated value.

Arguments:

    Status - Supplies the status value to convert.

Return Value:

    The matching DOS/OS 2 error code.

--*/

{

    ULONG Offset;
    ULONG Entry;
    ULONG Index;

    //
    // Convert any HRESULTs to their original form of a NTSTATUS or a
    // WIN32 error
    //


    if (Status & 0x20000000) {

        //
        // The customer bit is set so lets just pass the
        // error code on thru
        //

        return Status;

    }
    else if ((Status & 0xffff0000) == 0x80070000) {

        //
        // The status code  was a win32 error already.
        //

        return(Status & 0x0000ffff);
    }
    else if ((Status & 0xf0000000) == 0xd0000000) {

        //
        // The status code is a HRESULT from NTSTATUS
        //

        Status &= 0xcfffffff;
    }
    

    //
    // Scan the run length table and compute the entry in the translation
    // table that maps the specified status code to a DOS error code.
    //

    Entry = 0;
    Index = 0;
    do {
        if ((ULONG)Status >= RtlpRunTable[Entry + 1].BaseCode) {
            Index += (RtlpRunTable[Entry].RunLength * RtlpRunTable[Entry].CodeSize);

        } else {
            Offset = (ULONG)Status - RtlpRunTable[Entry].BaseCode;
            if (Offset >= RtlpRunTable[Entry].RunLength) {
                break;

            } else {
                Index += (Offset * (ULONG)RtlpRunTable[Entry].CodeSize);
                if (RtlpRunTable[Entry].CodeSize == 1) {
                    return (ULONG)RtlpStatusTable[Index];

                } else {
                    return (((ULONG)RtlpStatusTable[Index + 1] << 16) |
                                                (ULONG)RtlpStatusTable[Index]);
                }
            }
        }

        Entry += 1;
    } while (Entry < (sizeof(RtlpRunTable) / sizeof(RUN_ENTRY)));

    //
    // The translation to a DOS error code failed.
    //
    // The redirector maps unknown OS/2 error codes by ORing 0xC001 into
    // the high 16 bits.  Detect this and return the low 16 bits if true.
    //

    if (((ULONG)Status >> 16) == 0xC001) {
        return ((ULONG)Status & 0xFFFF);
    }

    return ERROR_MR_MID_NOT_FOUND;
}

NTSTATUS
NTAPI
RtlGetLastNtStatus(
	VOID
	)
{
	return NtCurrentTeb()->LastStatusValue;
}

LONG
NTAPI
RtlGetLastWin32Error(
	VOID
	)
{
	return NtCurrentTeb()->LastErrorValue;
}

VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
	NTSTATUS Status
	)
{
	//
	// RtlNtStatusToDosError stores into NtCurrentTeb()->LastStatusValue.
	//
	RtlSetLastWin32Error(RtlNtStatusToDosError(Status));
}

VOID
NTAPI
RtlSetLastWin32Error(
	LONG Win32Error
	)
{
//
// Arguably this should clear or reset the last nt status, but it does not
// touch it.
//
	NtCurrentTeb()->LastErrorValue = Win32Error;
}

VOID
NTAPI
RtlRestoreLastWin32Error(
	LONG Win32Error
	)
{
#if DBG
	if ((LONG)NtCurrentTeb()->LastErrorValue != Win32Error)
#endif
		NtCurrentTeb()->LastErrorValue = Win32Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\debug.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    debug.c

Abstract:

    This module implements functions to support debugging on NT.

--*/

#include "stdarg.h"
#include "stdio.h"
#include "ntrtlp.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include <ntdbg.h>

//
// Forward referenced internal interface.
//

ULONG
vDbgPrintExWithPrefixInternal (
    __in PCH Prefix,
    __in ULONG ComponentId,
    __in ULONG Level,
    __in PCHAR Format,
    __in va_list arglist,
    __in BOOLEAN ControlC
    );

ULONG
DbgPrint (
    __in PCHAR Format,
    ...
    )

/*++

Routine Description:

    This routine provides a "printf" style capability for the kernel
    debugger.

    N.B. Control-C is consumed by the debugger and returned to this routine
        as status. If control-C was pressed, this routine breakpoints.

Arguments:

    Format - Supplies a pointer to a printf style format string.

    ... - Supplies additional arguments consumed according to the format
        string.

Return Value:

    Defined as returning a ULONG, actually returns status.

--*/

{

    va_list arglist;

    va_start(arglist, Format);
    return vDbgPrintExWithPrefixInternal("", -1, 0, Format, arglist, TRUE);
}

ULONG
DbgPrintReturnControlC (
    __in PCHAR Format,
    ...
    )

/*++

Routine Description:

    This routine provides a "printf" style capability for the kernel
    debugger.

    N.B. Control-C is consumed by the debugger and returned to this routine
        as status. If control-C was pressed, then the appropriate status is
        returned to the caller.

Arguments:

    Format - Supplies a pointer to a printf style format string.

    ... - Supplies additional arguments consumed according to the format
        string.

Return Value:

    Defined as returning a ULONG, actually returns status.

--*/

{

    va_list arglist;

    va_start(arglist, Format);
    return vDbgPrintExWithPrefixInternal("", -1, 0, Format, arglist, FALSE);
}

ULONG
DbgPrintEx (
    __in ULONG ComponentId,
    __in ULONG Level,
    __in PCHAR Format,
    ...
    )

/*++

Routine Description:

    This routine provides a "printf" style capability for the kernel
    debugger.

    N.B. Control-C is consumed by the debugger and returned to this routine
        as status. If control-C was pressed, this routine breakpoints.

Arguments:

    ComponentId - Supplies the Id of the calling component.

    Level - Supplies the output filter level.

    Format - Supplies a pointer to a printf style format string.

    ... - Supplies additional arguments consumed according to the format
        string.

Return Value:

    Defined as returning a ULONG, actually returns status.

--*/

{

    va_list arglist;

    va_start(arglist, Format);
    return vDbgPrintExWithPrefixInternal("",
                                         ComponentId,
                                         Level,
                                         Format,
                                         arglist,
                                         TRUE);
}

ULONG
vDbgPrintEx (
    __in ULONG ComponentId,
    __in ULONG Level,
    __in PCHAR Format,
    __in va_list arglist
    )

/*++

Routine Description:

    This routine provides a "printf" style capability for the kernel
    debugger.

    N.B. Control-C is consumed by the debugger and returned to this routine
        as status. If control-C was pressed, this routine breakpoints.

Arguments:

    ComponentId - Supplies the Id of the calling component.

    Level - Supplies the output filter level or mask.

    Format - Supplies a pointer to a printf style format string.

    arglist - Supplies a pointer to a variable argument list.

Return Value:

    Defined as returning a ULONG, actually returns status.

--*/

{

    return vDbgPrintExWithPrefixInternal("",
                                         ComponentId,
                                         Level,
                                         Format,
                                         arglist,
                                         TRUE);
}

ULONG
vDbgPrintExWithPrefix (
    __in PCH Prefix,
    __in ULONG ComponentId,
    __in ULONG Level,
    __in PCHAR Format,
    __in va_list arglist
    )

/*++

Routine Description:

    This routine provides a "printf" style capability for the kernel
    debugger.

    N.B. Control-C is consumed by the debugger and returned to this routine
        as status. If control-C was pressed, this routine breakpoints.

Arguments:

    Prefix - Supplies a pointer to text that is to prefix the formatted
        output.

    ComponentId - Supplies the Id of the calling component.

    Level - Supplies the output filter level or mask.

    Format - Supplies a pointer to a printf style format string.

    arglist - Supplies a pointer to a variable argument list.

Return Value:

    Defined as returning a ULONG, actually returns status.

--*/

{
    return vDbgPrintExWithPrefixInternal(Prefix,
                                         ComponentId,
                                         Level,
                                         Format,
                                         arglist,
                                         TRUE);
}

ULONG
vDbgPrintExWithPrefixInternal (
    __in PCH Prefix,
    __in ULONG ComponentId,
    __in ULONG Level,
    __in PCHAR Format,
    __in va_list arglist,
    __in BOOLEAN ControlC
    )

/*++

Routine Description:

    This routine provides a "printf" style capability for the kernel
    debugger.

Arguments:

    Prefix - Supplies a pointer to text that is to prefix the formatted
        output.

    ComponentId - Supplies the Id of the calling component.

    Level - Supplies the output filter level or mask.

    Format - Supplies a pointer to a "printf" style format string.

    arglist - Supplies a pointer to a variable argument list.

    ControlC - Supplies a boolean that determines whether control C is
        consumed or not.

Return Value:

    Defined as returning a ULONG, actually returns status.

--*/

{

    UCHAR Buffer[512];
    int cb;
    int Length;
    STRING Output;
    NTSTATUS Status;

    //
    // If the debug output will be suppressed, then return success
    // immediately.
    //

    if ((ComponentId != -1) &&
        (NtQueryDebugFilterState(ComponentId, Level) != TRUE)) {

        return STATUS_SUCCESS;
    }

    //
    // Format the output into a buffer and then print it.
    //

    try {
        cb = strlen(Prefix);
        if (cb > sizeof(Buffer)) {
            cb = sizeof(Buffer);
        }

        strncpy(Buffer, Prefix, cb);
        Length = _vsnprintf(Buffer + cb , sizeof(Buffer) - cb, Format, arglist);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode();
    }

    //
    // Check if buffer overflow occurred during formatting. If buffer overflow
    // occurred, then terminate the buffer with an end of line.
    //

    if (Length == -1) {
        Buffer[sizeof(Buffer) - 1] = '\n';
        Length = sizeof(Buffer);

    } else {
        Length += cb;
    }

    Output.Buffer = Buffer;
    Output.Length = (USHORT)Length;

    //
    // If APP is being debugged, raise an exception and the debugger
    // will catch and handle this. Otherwise, kernel debugger service
    // is called.
    //

    Status = DebugPrint(&Output, ComponentId, Level);
    if ((ControlC == TRUE) &&
        (Status == STATUS_BREAKPOINT)) {

        DbgBreakPointWithStatus(DBG_STATUS_CONTROL_C);
        Status = STATUS_SUCCESS;
    }

    return Status;
}

ULONG
DbgPrompt (
    __in PCHAR Prompt,
    __out_bcount(Length) PCHAR Response,
    __in ULONG Length
    )

/*++

Routine Description:

    This function displays the prompt string on the debug console and
    then reads a line of text from the debug console. The line read is
    returned in the memory pointed to by the second parameter. The third
    parameter specifies the maximum number of characters that can be
    stored in the response area.

Arguments:

    Prompt - Supplies a pointer to the text to display as the prompt.

    Response - Supplies a pointer to a buffer that receives the response
       read from the debug console.

    Length - Supplies the maximum number of characters that can be stored in
        the response buffer.

Return Value:

    Number of characters stored in the Response buffer including the
    terminating newline character, but not the ending null character.

--*/

{

    STRING Input;
    STRING Output;

    //
    // Output the prompt string and read input.
    //

    Input.MaximumLength = (USHORT)Length;
    Input.Buffer = Response;
    Output.Length = (USHORT)strlen(Prompt);
    Output.Buffer = Prompt;
    return DebugPrompt(&Output, &Input);
}

VOID
DbgLoadImageSymbols (
    __in PSTRING FileName,
    __in PVOID ImageBase,
    __in ULONG_PTR ProcessId
    )

/*++

Routine Description:

    Tells the debugger about newly loaded symbols.

Arguments:

Return Value:

--*/

{

    PIMAGE_NT_HEADERS NtHeaders;
    KD_SYMBOLS_INFO SymbolInfo;

    SymbolInfo.BaseOfDll = ImageBase;
    SymbolInfo.ProcessId = ProcessId;
    NtHeaders = RtlImageNtHeader( ImageBase );
    if (NtHeaders != NULL) {
        SymbolInfo.CheckSum = (ULONG)NtHeaders->OptionalHeader.CheckSum;
        SymbolInfo.SizeOfImage = (ULONG)NtHeaders->OptionalHeader.SizeOfImage;

    } else {

        SymbolInfo.SizeOfImage = 0;
        SymbolInfo.CheckSum    = 0;
    }

    DebugService2(FileName, &SymbolInfo, BREAKPOINT_LOAD_SYMBOLS);

    return;
}

VOID
DbgUnLoadImageSymbols (
    __in PSTRING FileName,
    __in PVOID ImageBase,
    __in ULONG_PTR ProcessId
    )

/*++

Routine Description:

    Tells the debugger about newly unloaded symbols.

Arguments:

Return Value:

--*/

{

    KD_SYMBOLS_INFO SymbolInfo;

    SymbolInfo.BaseOfDll = ImageBase;
    SymbolInfo.ProcessId = ProcessId;
    SymbolInfo.CheckSum    = 0;
    SymbolInfo.SizeOfImage = 0;

    DebugService2(FileName, &SymbolInfo, BREAKPOINT_UNLOAD_SYMBOLS);

    return;
}

VOID
DbgCommandString (
    __in PCH Name,
    __in PCH Command
    )

/*++

Routine Description:

    Tells the debugger to execute a command string

Arguments:

    Name - Identifies the originator of the command.

    Command - Command string.

Return Value:

--*/

{

    STRING NameStr, CommandStr;

    NameStr.Buffer = Name;
    NameStr.Length = (USHORT)strlen(Name);
    CommandStr.Buffer = Command;
    CommandStr.Length = (USHORT)strlen(Command);
    DebugService2(&NameStr, &CommandStr, BREAKPOINT_COMMAND_STRING);
}

NTSTATUS
DbgQueryDebugFilterState (
    __in ULONG ComponentId,
    __in ULONG Level
    )

/*++

Routine Description:

    This function queries the debug print enable for a specified component
    level.  If Level is > 31, it's assumed to be a mask otherwise, it indicates
    a specific debug level to test for (ERROR/WARNING/TRACE/INFO, etc).

Arguments:

    ComponentId - Supplies the component id.

    Level - Supplies the debug filter level number or mask.

Return Value:

    STATUS_INVALID_PARAMETER_1 is returned if the component id is not
        valid.

    TRUE is returned if output is enabled for the specified component
        and level or is enabled for the system.

    FALSE is returned if output is not enabled for the specified component
        and level and is not enabled for the system.

--*/

{

    return NtQueryDebugFilterState(ComponentId, Level);
}

NTSTATUS
DbgSetDebugFilterState (
    __in ULONG ComponentId,
    __in ULONG Level,
    __in BOOLEAN State
    )

/*++

Routine Description:

    This function sets the state of the debug print enable for a specified
    component and level. The debug print enable state for the system is set
    by specifying the distinguished value -1 for the component id.

Arguments:

    ComponentId - Supplies the Id of the calling component.

    Level - Supplies the output filter level or mask.

    State - Supplies a boolean value that determines the new state.

Return Value:

    STATUS_ACCESS_DENIED is returned if the required privilege is not held.

    STATUS_INVALID_PARAMETER_1 is returned if the component id is not
        valid.

    STATUS_SUCCESS  is returned if the debug print enable state is set for
        the specified component.

--*/

{
    return NtSetDebugFilterState(ComponentId, Level, State);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\excptdbg.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    excptdbg.c

Abstract:

    This module implements an exception dispatcher logging facility.

--*/

#include "ntrtlp.h"

PLAST_EXCEPTION_LOG RtlpExceptionLog = NULL;
ULONG RtlpExceptionLogCount;
ULONG RtlpExceptionLogSize;

#pragma alloc_text(INIT, RtlInitializeExceptionLog)

VOID
RtlInitializeExceptionLog(
    IN ULONG Entries
    )
/*++

Routine Description:

    This routine allocates space for the exception dispatcher logging
    facility, and records the address and size of the log area in globals
    where they can be found by the debugger.

    If memory is not available, the table pointer will remain NULL
    and the logging functions will do nothing.

Arguments:

    Entries - Supplies the number of entries to allocate for

Return Value:

    None

--*/
{

    RtlpExceptionLog = (PLAST_EXCEPTION_LOG)
        ExAllocatePoolWithTag( NonPagedPool, sizeof(LAST_EXCEPTION_LOG) * Entries, 'gbdE' );

    if (RtlpExceptionLog != NULL) {
        RtlpExceptionLogSize = Entries;
    }
}

ULONG
RtlpLogExceptionHandler(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN ULONG_PTR ControlPc,
    IN PVOID HandlerData,
    IN ULONG Size
    )
/*++

Routine Description:

    Records the dispatching of exceptions to frame-based handlers.
    The debugger may inspect the table later and interpret the data
    to discover the address of the filters and handlers.

Arguments:

    ExceptionRecord - Supplies an exception record

    ContextRecord - Supplies the context at the exception

    ControlPc - Supplies the PC where control left the frame being
        dispatched to.

    HandlerData - Supplies a pointer to the host-dependent exception
        data.  On the RISC machines this is a RUNTIME_FUNCTION record;
        on x86 it is the registration record from the stack frame.

    Size - Supplies the size of HandlerData

Returns:

    The index to the log entry used, so that if the handler returns
    a disposition it may be recorded.

--*/
{
    ULONG LogIndex;

    if (!RtlpExceptionLog) {
        return 0;
    }

    ASSERT(Size <= MAX_EXCEPTION_LOG_DATA_SIZE * sizeof(ULONG));

    do {
        LogIndex = RtlpExceptionLogCount;
    } while (LogIndex != (ULONG)InterlockedCompareExchange(
                                    (PLONG)&RtlpExceptionLogCount,
                                    ((LogIndex + 1) % MAX_EXCEPTION_LOG),
                                    LogIndex));

    //
    // the debugger will have to interpret the exception handler
    // data, because it cannot be done safely here.
    //

    RtlCopyMemory(RtlpExceptionLog[LogIndex].HandlerData,
                  HandlerData,
                  Size);
    RtlpExceptionLog[LogIndex].ExceptionRecord = *ExceptionRecord;
    RtlpExceptionLog[LogIndex].ContextRecord = *ContextRecord;
    RtlpExceptionLog[LogIndex].Disposition = -1;

    return LogIndex;
}

VOID
RtlpLogLastExceptionDisposition(
    ULONG LogIndex,
    EXCEPTION_DISPOSITION Disposition
    )
/*++

Routine Description:

    Records the disposition from an exception handler.

Arguments:

    LogIndex - Supplies the entry number of the exception log record.

    Disposition - Supplies the disposition code

Return Value:

    None

--*/

{
    // If MAX_EXCEPTION_LOG or more exceptions were dispatched while
    // this one was being handled, this disposition will get written
    // on the wrong record.  Oh well.
    if (RtlpExceptionLog != NULL) {
        RtlpExceptionLog[LogIndex].Disposition = Disposition;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\generr.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    generr.c

Abstract:

    This module contains code to generate the NT status code to DOS
    error code table that is used by the runtime to translate status
    codes.

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <wtypes.h>
#include <status.h>
//#include <clogerrs.h>
#include <ws03res.h>
#include "stdio.h"
#include "stdarg.h"
#include "stdlib.h"

//
// Ensure that the Registry ERROR_SUCCESS error code and the
// NO_ERROR error code remain equal and zero.
//

#if ERROR_SUCCESS != 0 || NO_ERROR != 0
#error Invalid value for ERROR_SUCCESS.
#endif

//
// The following error code table contains paired entries in a singly
// dimensioned array. The first member of a paired entry is an NT status
// code and the second member is the DOS error code that it translates to.
//
// To add a value to this table simply insert the NT status/DOS error code
// pair anywhere is the table. If multiple NT status codes map to a single
// DOS error code, then insert a paired entry for each of the code pairs.
//
#ifdef i386
#pragma warning (4:4018)        // lower to -W4
#endif
LONG CodePairs[] = {

    //
    // First some marker entries so that generr.exe can locate this table
    // in generr.obj.  The following line must appear first in the table.
    //

    'Begi','n ge','nerr',' tbl',

    //
    // Exception codes defined in WINNT.H can map to themselves.
    //

    STATUS_BREAKPOINT, STATUS_BREAKPOINT,
    STATUS_SINGLE_STEP, STATUS_SINGLE_STEP,
    STATUS_ILLEGAL_INSTRUCTION, STATUS_ILLEGAL_INSTRUCTION,
    STATUS_NONCONTINUABLE_EXCEPTION, STATUS_NONCONTINUABLE_EXCEPTION,
    STATUS_INVALID_DISPOSITION, STATUS_INVALID_DISPOSITION,
    STATUS_PARITY_ERROR, STATUS_PARITY_ERROR,
    STATUS_ARRAY_BOUNDS_EXCEEDED, STATUS_ARRAY_BOUNDS_EXCEEDED,
    STATUS_FLOAT_DENORMAL_OPERAND, STATUS_FLOAT_DENORMAL_OPERAND,
    STATUS_FLOAT_DIVIDE_BY_ZERO, STATUS_FLOAT_DIVIDE_BY_ZERO,
    STATUS_FLOAT_INEXACT_RESULT, STATUS_FLOAT_INEXACT_RESULT,
    STATUS_FLOAT_INVALID_OPERATION, STATUS_FLOAT_INVALID_OPERATION,
    STATUS_FLOAT_OVERFLOW, STATUS_FLOAT_OVERFLOW,
    STATUS_FLOAT_STACK_CHECK, STATUS_FLOAT_STACK_CHECK,
    STATUS_FLOAT_UNDERFLOW, STATUS_FLOAT_UNDERFLOW,
    STATUS_INTEGER_DIVIDE_BY_ZERO, STATUS_INTEGER_DIVIDE_BY_ZERO,
    STATUS_PRIVILEGED_INSTRUCTION, STATUS_PRIVILEGED_INSTRUCTION,
    STATUS_GUARD_PAGE_VIOLATION, STATUS_GUARD_PAGE_VIOLATION,

    //
    // These are also defined in WINNT.H, but we are stuck with these
    // mappings.
    //

    STATUS_DATATYPE_MISALIGNMENT, ERROR_NOACCESS,
    STATUS_ACCESS_VIOLATION, ERROR_NOACCESS,
    STATUS_DATATYPE_MISALIGNMENT_ERROR, ERROR_NOACCESS,

    STATUS_CTL_FILE_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    STATUS_PORT_ALREADY_SET, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_NOT_IMAGE, ERROR_INVALID_PARAMETER,
    STATUS_BAD_WORKING_SET_LIMIT, ERROR_INVALID_PARAMETER,
    STATUS_WORKING_SET_LIMIT_RANGE, ERROR_INVALID_PARAMETER,
    STATUS_INCOMPATIBLE_FILE_MAP, ERROR_INVALID_PARAMETER,
    STATUS_PORT_DISCONNECTED, ERROR_INVALID_HANDLE,
    STATUS_NOT_LOCKED, ERROR_NOT_LOCKED,
    STATUS_NOT_MAPPED_VIEW, ERROR_INVALID_ADDRESS,
    STATUS_UNABLE_TO_FREE_VM, ERROR_INVALID_PARAMETER,
    STATUS_UNABLE_TO_DELETE_SECTION, ERROR_INVALID_PARAMETER,
    STATUS_MORE_PROCESSING_REQUIRED, ERROR_MORE_DATA,
    STATUS_INVALID_CID, ERROR_INVALID_PARAMETER,
    STATUS_STACK_OVERFLOW, ERROR_STACK_OVERFLOW,
    STATUS_BAD_INITIAL_STACK, ERROR_STACK_OVERFLOW,
    STATUS_INVALID_VOLUME_LABEL, ERROR_LABEL_TOO_LONG,
    STATUS_SECTION_NOT_EXTENDED, ERROR_OUTOFMEMORY,
    STATUS_NOT_MAPPED_DATA, ERROR_INVALID_ADDRESS,

    STATUS_NO_LDT, ERROR_INVALID_THREAD_ID,

    STATUS_INFO_LENGTH_MISMATCH, ERROR_BAD_LENGTH,
    STATUS_INVALID_INFO_CLASS, ERROR_INVALID_PARAMETER,

    STATUS_SUSPEND_COUNT_EXCEEDED, ERROR_SIGNAL_REFUSED,

    STATUS_NOTIFY_ENUM_DIR, ERROR_NOTIFY_ENUM_DIR,

    STATUS_REGISTRY_RECOVERED, ERROR_REGISTRY_RECOVERED,

    STATUS_REGISTRY_IO_FAILED, ERROR_REGISTRY_IO_FAILED,

    STATUS_NOT_REGISTRY_FILE, ERROR_NOT_REGISTRY_FILE,

    STATUS_KEY_DELETED, ERROR_KEY_DELETED,

    STATUS_NO_LOG_SPACE, ERROR_NO_LOG_SPACE,

    STATUS_KEY_HAS_CHILDREN, ERROR_KEY_HAS_CHILDREN,

    STATUS_CHILD_MUST_BE_VOLATILE, ERROR_CHILD_MUST_BE_VOLATILE,

    STATUS_REGISTRY_CORRUPT, ERROR_BADDB,

    STATUS_DLL_NOT_FOUND, ERROR_MOD_NOT_FOUND,
    STATUS_DLL_INIT_FAILED, ERROR_DLL_INIT_FAILED,
    STATUS_INVALID_IMPORT_OF_NON_DLL, ERROR_INVALID_IMPORT_OF_NON_DLL,
    STATUS_DELAY_LOAD_FAILED, ERROR_DELAY_LOAD_FAILED,
    STATUS_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_UNABLE_TO_LOAD, ERROR_BAD_DRIVER,

    STATUS_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,
    STATUS_DRIVER_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_PENDING, ERROR_IO_PENDING,

    STATUS_MORE_ENTRIES, ERROR_MORE_DATA,

    STATUS_INTEGER_OVERFLOW, ERROR_ARITHMETIC_OVERFLOW,

    STATUS_BUFFER_OVERFLOW, ERROR_MORE_DATA,

    STATUS_NO_MORE_FILES, ERROR_NO_MORE_FILES,

    STATUS_NO_INHERITANCE, ERROR_NO_INHERITANCE,

    STATUS_NO_MORE_EAS, ERROR_NO_MORE_ITEMS,
    STATUS_NO_MORE_ENTRIES, ERROR_NO_MORE_ITEMS,
    STATUS_GUIDS_EXHAUSTED, ERROR_NO_MORE_ITEMS,
    STATUS_AGENTS_EXHAUSTED, ERROR_NO_MORE_ITEMS,

    STATUS_UNSUCCESSFUL, ERROR_GEN_FAILURE,

    STATUS_TOO_MANY_LINKS, ERROR_TOO_MANY_LINKS,

    STATUS_NOT_IMPLEMENTED, ERROR_INVALID_FUNCTION,
    STATUS_ILLEGAL_FUNCTION, ERROR_INVALID_FUNCTION,

    STATUS_IN_PAGE_ERROR, ERROR_SWAPERROR,

    STATUS_PAGEFILE_QUOTA, ERROR_PAGEFILE_QUOTA,
    STATUS_COMMITMENT_LIMIT, ERROR_COMMITMENT_LIMIT,
    STATUS_SECTION_TOO_BIG, ERROR_NOT_ENOUGH_MEMORY,

    RPC_NT_SS_IN_NULL_CONTEXT, ERROR_INVALID_HANDLE,
    RPC_NT_INVALID_BINDING, ERROR_INVALID_HANDLE,
    STATUS_INVALID_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_OBJECT_TYPE_MISMATCH, ERROR_INVALID_HANDLE,
    STATUS_FILE_CLOSED, ERROR_INVALID_HANDLE,
    STATUS_INVALID_PORT_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_HANDLE_NOT_CLOSABLE, ERROR_INVALID_HANDLE,

    STATUS_NOT_COMMITTED, ERROR_INVALID_ADDRESS,
    STATUS_PARTIAL_COPY, ERROR_PARTIAL_COPY,

    STATUS_LPC_REPLY_LOST, ERROR_INTERNAL_ERROR,
    STATUS_INVALID_PARAMETER, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_1, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_2, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_3, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_4, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_5, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_6, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_7, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_8, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_9, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_10, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_11, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_12, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_MIX, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PAGE_PROTECTION, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_PROTECTION, ERROR_INVALID_PARAMETER,

    STATUS_RESOURCE_DATA_NOT_FOUND, ERROR_RESOURCE_DATA_NOT_FOUND,
    STATUS_RESOURCE_TYPE_NOT_FOUND, ERROR_RESOURCE_TYPE_NOT_FOUND,
    STATUS_RESOURCE_NAME_NOT_FOUND, ERROR_RESOURCE_NAME_NOT_FOUND,
    STATUS_RESOURCE_LANG_NOT_FOUND, ERROR_RESOURCE_LANG_NOT_FOUND,

    STATUS_NO_SUCH_DEVICE, ERROR_FILE_NOT_FOUND,
    STATUS_NO_SUCH_FILE, ERROR_FILE_NOT_FOUND,

    STATUS_INVALID_DEVICE_REQUEST, ERROR_INVALID_FUNCTION,
    STATUS_VOLUME_NOT_UPGRADED, ERROR_INVALID_FUNCTION,

    STATUS_END_OF_FILE, ERROR_HANDLE_EOF,
    STATUS_FILE_FORCED_CLOSED, ERROR_HANDLE_EOF,

    STATUS_WRONG_VOLUME, ERROR_WRONG_DISK,

    STATUS_NO_MEDIA, ERROR_NO_MEDIA_IN_DRIVE,

    STATUS_NO_MEDIA_IN_DEVICE, ERROR_NOT_READY,

    STATUS_VOLUME_DISMOUNTED, ERROR_NOT_READY,

    STATUS_NONEXISTENT_SECTOR, ERROR_SECTOR_NOT_FOUND,

    STATUS_WORKING_SET_QUOTA, ERROR_WORKING_SET_QUOTA,
    STATUS_NO_MEMORY, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_CONFLICTING_ADDRESSES, ERROR_INVALID_ADDRESS,

    STATUS_INVALID_SYSTEM_SERVICE, ERROR_INVALID_FUNCTION,

    STATUS_THREAD_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_PROCESS_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_INVALID_LOCK_SEQUENCE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_VIEW_SIZE, ERROR_ACCESS_DENIED,
    STATUS_ALREADY_COMMITTED, ERROR_ACCESS_DENIED,
    STATUS_ACCESS_DENIED, ERROR_ACCESS_DENIED,
    STATUS_FILE_IS_A_DIRECTORY, ERROR_ACCESS_DENIED,
    STATUS_CANNOT_DELETE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_COMPUTER_NAME, ERROR_INVALID_COMPUTERNAME,
    STATUS_FILE_DELETED, ERROR_ACCESS_DENIED,
    STATUS_FILE_RENAMED, ERROR_ACCESS_DENIED,
    STATUS_DELETE_PENDING, ERROR_ACCESS_DENIED,
    STATUS_PORT_CONNECTION_REFUSED, ERROR_ACCESS_DENIED,

    STATUS_NO_SUCH_PRIVILEGE, ERROR_NO_SUCH_PRIVILEGE,

    STATUS_PRIVILEGE_NOT_HELD, ERROR_PRIVILEGE_NOT_HELD,

    STATUS_CANNOT_IMPERSONATE, ERROR_CANNOT_IMPERSONATE,

    STATUS_LOGON_FAILURE, ERROR_LOGON_FAILURE,
    STATUS_MUTUAL_AUTHENTICATION_FAILED, ERROR_MUTUAL_AUTH_FAILED,
    STATUS_TIME_DIFFERENCE_AT_DC, ERROR_TIME_SKEW,
    STATUS_PKINIT_FAILURE, ERROR_PKINIT_FAILURE,
    STATUS_SMARTCARD_SUBSYSTEM_FAILURE, ERROR_SMARTCARD_SUBSYSTEM_FAILURE,
    STATUS_DOWNGRADE_DETECTED, ERROR_DOWNGRADE_DETECTED,
    STATUS_SMARTCARD_CERT_REVOKED, SEC_E_SMARTCARD_CERT_REVOKED,
    STATUS_ISSUING_CA_UNTRUSTED, SEC_E_ISSUING_CA_UNTRUSTED,
    STATUS_REVOCATION_OFFLINE_C, SEC_E_REVOCATION_OFFLINE_C,
    STATUS_PKINIT_CLIENT_FAILURE, SEC_E_PKINIT_CLIENT_FAILURE,
    STATUS_SMARTCARD_CERT_EXPIRED,SEC_E_SMARTCARD_CERT_EXPIRED,
    STATUS_NO_S4U_PROT_SUPPORT,SEC_E_NO_S4U_PROT_SUPPORT,
    STATUS_CROSSREALM_DELEGATION_FAILURE, SEC_E_CROSSREALM_DELEGATION_FAILURE,
    STATUS_REVOCATION_OFFLINE_KDC, SEC_E_REVOCATION_OFFLINE_KDC,
    STATUS_ISSUING_CA_UNTRUSTED_KDC, SEC_E_ISSUING_CA_UNTRUSTED_KDC,
    STATUS_KDC_CERT_EXPIRED, SEC_E_KDC_CERT_EXPIRED,
    STATUS_KDC_CERT_REVOKED, SEC_E_KDC_CERT_REVOKED,
    STATUS_NO_KERB_KEY, SEC_E_NO_KERB_KEY,
    STATUS_CURRENT_DOMAIN_NOT_ALLOWED, ERROR_CURRENT_DOMAIN_NOT_ALLOWED,

    STATUS_SMARTCARD_WRONG_PIN, SCARD_W_WRONG_CHV,
    STATUS_SMARTCARD_CARD_BLOCKED, SCARD_W_CHV_BLOCKED,
    STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED, SCARD_W_CARD_NOT_AUTHENTICATED,
    STATUS_SMARTCARD_NO_CARD, SCARD_E_NO_SMARTCARD,
    STATUS_SMARTCARD_NO_KEY_CONTAINER, NTE_NO_KEY,
    STATUS_SMARTCARD_NO_CERTIFICATE, SCARD_E_NO_SUCH_CERTIFICATE,
    STATUS_SMARTCARD_NO_KEYSET, NTE_BAD_KEYSET,
    STATUS_SMARTCARD_IO_ERROR, SCARD_E_COMM_DATA_LOST,
    STATUS_SMARTCARD_SILENT_CONTEXT, NTE_SILENT_CONTEXT,

    STATUS_ACCOUNT_RESTRICTION, ERROR_ACCOUNT_RESTRICTION,

    STATUS_INVALID_LOGON_HOURS, ERROR_INVALID_LOGON_HOURS,

    STATUS_INVALID_WORKSTATION, ERROR_INVALID_WORKSTATION,

    STATUS_BUFFER_TOO_SMALL, ERROR_INSUFFICIENT_BUFFER,

    STATUS_UNABLE_TO_DECOMMIT_VM, ERROR_INVALID_ADDRESS,

    STATUS_DISK_CORRUPT_ERROR, ERROR_DISK_CORRUPT,
    STATUS_FT_MISSING_MEMBER, ERROR_IO_DEVICE,
    STATUS_FT_ORPHANING, ERROR_IO_DEVICE,

    STATUS_ILL_FORMED_SERVICE_ENTRY, ERROR_SERVICE_NOT_FOUND,

    STATUS_VARIABLE_NOT_FOUND, ERROR_ENVVAR_NOT_FOUND,

    STATUS_OBJECT_NAME_INVALID, ERROR_INVALID_NAME,

    STATUS_OBJECT_NAME_NOT_FOUND, ERROR_FILE_NOT_FOUND,

    STATUS_OBJECT_NAME_COLLISION, ERROR_ALREADY_EXISTS,

    STATUS_OBJECT_PATH_INVALID, ERROR_BAD_PATHNAME,

    STATUS_OBJECT_PATH_NOT_FOUND, ERROR_PATH_NOT_FOUND,
    STATUS_DFS_EXIT_PATH_FOUND, ERROR_PATH_NOT_FOUND,
    STATUS_DFS_UNAVAILABLE, ERROR_CONNECTION_UNAVAIL,

    STATUS_OBJECT_PATH_SYNTAX_BAD, ERROR_BAD_PATHNAME,

    STATUS_NAME_TOO_LONG, ERROR_FILENAME_EXCED_RANGE,

    STATUS_DATA_OVERRUN, ERROR_IO_DEVICE,
    STATUS_DATA_LATE_ERROR, ERROR_IO_DEVICE,
    STATUS_DATA_ERROR, ERROR_CRC,

    STATUS_CRC_ERROR, ERROR_CRC,

    STATUS_SHARING_VIOLATION, ERROR_SHARING_VIOLATION,

    STATUS_QUOTA_EXCEEDED, ERROR_NOT_ENOUGH_QUOTA,

    STATUS_MUTANT_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_SEMAPHORE_LIMIT_EXCEEDED, ERROR_TOO_MANY_POSTS,

    STATUS_DISK_FULL, ERROR_DISK_FULL,

    STATUS_LOCK_NOT_GRANTED, ERROR_LOCK_VIOLATION,

    STATUS_FILE_LOCK_CONFLICT, ERROR_LOCK_VIOLATION,  // FIX, FIX - is this right?

    STATUS_NOT_A_DIRECTORY, ERROR_DIRECTORY,          // FIX, FIX - is this right?

    STATUS_CANNOT_MAKE, ERROR_CANNOT_MAKE,

    STATUS_UNKNOWN_REVISION, ERROR_UNKNOWN_REVISION,

    STATUS_REVISION_MISMATCH, ERROR_REVISION_MISMATCH,

    STATUS_INVALID_OWNER, ERROR_INVALID_OWNER,

    STATUS_INVALID_PRIMARY_GROUP, ERROR_INVALID_PRIMARY_GROUP,

    STATUS_NO_IMPERSONATION_TOKEN, ERROR_NO_IMPERSONATION_TOKEN,

    STATUS_CANT_DISABLE_MANDATORY, ERROR_CANT_DISABLE_MANDATORY,

    STATUS_NO_LOGON_SERVERS, ERROR_NO_LOGON_SERVERS,
    STATUS_DOMAIN_CONTROLLER_NOT_FOUND, ERROR_DOMAIN_CONTROLLER_NOT_FOUND,

    STATUS_NO_SUCH_LOGON_SESSION, ERROR_NO_SUCH_LOGON_SESSION,

    STATUS_INVALID_ACCOUNT_NAME, ERROR_INVALID_ACCOUNT_NAME,

    STATUS_USER_EXISTS, ERROR_USER_EXISTS,

    STATUS_NO_SUCH_USER, ERROR_NO_SUCH_USER,

    STATUS_GROUP_EXISTS, ERROR_GROUP_EXISTS,

    STATUS_NO_SUCH_GROUP, ERROR_NO_SUCH_GROUP,

    STATUS_SPECIAL_GROUP, ERROR_SPECIAL_GROUP,

    STATUS_MEMBER_IN_GROUP, ERROR_MEMBER_IN_GROUP,

    STATUS_MEMBER_NOT_IN_GROUP, ERROR_MEMBER_NOT_IN_GROUP,

    STATUS_LAST_ADMIN, ERROR_LAST_ADMIN,

    STATUS_WRONG_PASSWORD, ERROR_INVALID_PASSWORD,
    STATUS_WRONG_PASSWORD_CORE, ERROR_INVALID_PASSWORD,

    STATUS_ILL_FORMED_PASSWORD, ERROR_ILL_FORMED_PASSWORD,

    STATUS_PASSWORD_RESTRICTION, ERROR_PASSWORD_RESTRICTION,

    STATUS_PASSWORD_EXPIRED, ERROR_PASSWORD_EXPIRED,
    STATUS_PASSWORD_MUST_CHANGE, ERROR_PASSWORD_MUST_CHANGE,

    STATUS_ACCOUNT_DISABLED, ERROR_ACCOUNT_DISABLED,
    STATUS_ACCOUNT_LOCKED_OUT, ERROR_ACCOUNT_LOCKED_OUT,

    STATUS_NONE_MAPPED, ERROR_NONE_MAPPED,

    STATUS_TOO_MANY_LUIDS_REQUESTED, ERROR_TOO_MANY_LUIDS_REQUESTED,

    STATUS_LUIDS_EXHAUSTED, ERROR_LUIDS_EXHAUSTED,

    STATUS_INVALID_SUB_AUTHORITY, ERROR_INVALID_SUB_AUTHORITY,

    STATUS_INVALID_ACL, ERROR_INVALID_ACL,

    STATUS_INVALID_SID, ERROR_INVALID_SID,

    STATUS_INVALID_SECURITY_DESCR, ERROR_INVALID_SECURITY_DESCR,

    STATUS_PROCEDURE_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_BAD_INITIAL_PC, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_FILE_FOR_SECTION, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_MP_UP_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_NOT_MZ, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_CHECKSUM_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_PROTECT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_LE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_NE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_WIN_16, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_WIN_32, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_WIN_64, ERROR_BAD_EXE_FORMAT,

    STATUS_NO_TOKEN, ERROR_NO_TOKEN,

    STATUS_RANGE_NOT_LOCKED, ERROR_NOT_LOCKED,

    STATUS_SERVER_DISABLED, ERROR_SERVER_DISABLED,

    STATUS_SERVER_NOT_DISABLED, ERROR_SERVER_NOT_DISABLED,

    STATUS_INVALID_ID_AUTHORITY, ERROR_INVALID_ID_AUTHORITY,

    STATUS_ALLOTTED_SPACE_EXCEEDED, ERROR_ALLOTTED_SPACE_EXCEEDED,

    STATUS_TOO_MANY_PAGING_FILES, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_INSUFFICIENT_RESOURCES, ERROR_NO_SYSTEM_RESOURCES,

    STATUS_INSUFF_SERVER_RESOURCES, ERROR_NOT_ENOUGH_SERVER_MEMORY,

    STATUS_FILE_INVALID, ERROR_FILE_INVALID,
    STATUS_MAPPED_FILE_SIZE_ZERO, ERROR_FILE_INVALID,

    STATUS_DEVICE_PAPER_EMPTY, ERROR_OUT_OF_PAPER,

    STATUS_DEVICE_POWERED_OFF, ERROR_NOT_READY,
    STATUS_DEVICE_OFF_LINE, ERROR_NOT_READY,

    STATUS_DEVICE_DATA_ERROR, ERROR_CRC,

    STATUS_DEVICE_NOT_READY, ERROR_NOT_READY,
    STATUS_DEVICE_NOT_CONNECTED, ERROR_DEVICE_NOT_CONNECTED,
    STATUS_DEVICE_POWER_FAILURE, ERROR_NOT_READY,

    STATUS_NOT_FOUND, ERROR_NOT_FOUND,
    STATUS_NO_MATCH, ERROR_NO_MATCH,
    STATUS_PROPSET_NOT_FOUND, ERROR_SET_NOT_FOUND,


    STATUS_DEVICE_BUSY, ERROR_BUSY,                   // FIX, FIX - is there a better choice?

    STATUS_FREE_VM_NOT_AT_BASE, ERROR_INVALID_ADDRESS,
    STATUS_MEMORY_NOT_ALLOCATED, ERROR_INVALID_ADDRESS,

    STATUS_NOT_SAME_DEVICE, ERROR_NOT_SAME_DEVICE,

    STATUS_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,

    STATUS_REMOTE_NOT_LISTENING, ERROR_REM_NOT_LIST,

    STATUS_DUPLICATE_NAME, ERROR_DUP_NAME,

    STATUS_BAD_NETWORK_PATH, ERROR_BAD_NETPATH,

    STATUS_NETWORK_BUSY, ERROR_NETWORK_BUSY,

    STATUS_ONLY_IF_CONNECTED, ERROR_ONLY_IF_CONNECTED,

    STATUS_DEVICE_DOES_NOT_EXIST, ERROR_DEV_NOT_EXIST,

    STATUS_TOO_MANY_COMMANDS, ERROR_TOO_MANY_CMDS,

    STATUS_ADAPTER_HARDWARE_ERROR, ERROR_ADAP_HDW_ERR,

    STATUS_REDIRECTOR_NOT_STARTED, ERROR_PATH_NOT_FOUND,

    STATUS_INVALID_EA_NAME, ERROR_INVALID_EA_NAME,

    STATUS_EA_LIST_INCONSISTENT, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EA_TOO_LARGE, ERROR_EA_LIST_INCONSISTENT,
    STATUS_INVALID_EA_FLAG, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EAS_NOT_SUPPORTED, ERROR_EAS_NOT_SUPPORTED,

    STATUS_FILE_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_EA_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_NONEXISTENT_EA_ENTRY, ERROR_FILE_CORRUPT,
    STATUS_NO_EAS_ON_FILE, ERROR_FILE_CORRUPT,

    STATUS_NOT_A_REPARSE_POINT, ERROR_NOT_A_REPARSE_POINT,
    STATUS_IO_REPARSE_TAG_INVALID, ERROR_REPARSE_TAG_INVALID,
    STATUS_IO_REPARSE_TAG_MISMATCH, ERROR_REPARSE_TAG_MISMATCH,
    STATUS_IO_REPARSE_TAG_NOT_HANDLED, ERROR_CANT_ACCESS_FILE,
    STATUS_REPARSE_POINT_NOT_RESOLVED, ERROR_CANT_RESOLVE_FILENAME,
    STATUS_DIRECTORY_IS_A_REPARSE_POINT, ERROR_BAD_PATHNAME,
    STATUS_REPARSE_ATTRIBUTE_CONFLICT, ERROR_REPARSE_ATTRIBUTE_CONFLICT,
    STATUS_IO_REPARSE_DATA_INVALID, ERROR_INVALID_REPARSE_DATA,

    STATUS_FILE_IS_OFFLINE, ERROR_FILE_OFFLINE,
    STATUS_REMOTE_STORAGE_NOT_ACTIVE, ERROR_REMOTE_STORAGE_NOT_ACTIVE,
    STATUS_REMOTE_STORAGE_MEDIA_ERROR, ERROR_REMOTE_STORAGE_MEDIA_ERROR,
    STATUS_NO_TRACKING_SERVICE, ERROR_NO_TRACKING_SERVICE,

    STATUS_JOURNAL_DELETE_IN_PROGRESS, ERROR_JOURNAL_DELETE_IN_PROGRESS,
    STATUS_JOURNAL_NOT_ACTIVE, ERROR_JOURNAL_NOT_ACTIVE,
    STATUS_JOURNAL_ENTRY_DELETED, ERROR_JOURNAL_ENTRY_DELETED,

    STATUS_INVALID_NETWORK_RESPONSE, ERROR_BAD_NET_RESP,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,
    STATUS_UNEXPECTED_NETWORK_ERROR, ERROR_UNEXP_NET_ERR,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,

    STATUS_BAD_REMOTE_ADAPTER, ERROR_BAD_REM_ADAP,

    STATUS_PRINT_QUEUE_FULL, ERROR_PRINTQ_FULL,

    STATUS_NO_SPOOL_SPACE, ERROR_NO_SPOOL_SPACE,

    STATUS_PRINT_CANCELLED, ERROR_PRINT_CANCELLED,

    STATUS_NETWORK_NAME_DELETED, ERROR_NETNAME_DELETED,

    STATUS_NETWORK_ACCESS_DENIED, ERROR_NETWORK_ACCESS_DENIED,

    STATUS_BAD_DEVICE_TYPE, ERROR_BAD_DEV_TYPE,

    STATUS_BAD_NETWORK_NAME, ERROR_BAD_NET_NAME,

    STATUS_TOO_MANY_NAMES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_GUIDS_REQUESTED, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_ADDRESSES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_NODES, ERROR_TOO_MANY_NAMES,

    STATUS_TOO_MANY_SESSIONS, ERROR_TOO_MANY_SESS,

    STATUS_SHARING_PAUSED, ERROR_SHARING_PAUSED,

    STATUS_REQUEST_NOT_ACCEPTED, ERROR_REQ_NOT_ACCEP,

    STATUS_REDIRECTOR_PAUSED, ERROR_REDIR_PAUSED,

    STATUS_NET_WRITE_FAULT, ERROR_NET_WRITE_FAULT,

    STATUS_VIRTUAL_CIRCUIT_CLOSED, ERROR_VC_DISCONNECTED,

    STATUS_INVALID_PIPE_STATE, ERROR_BAD_PIPE,
    STATUS_INVALID_READ_MODE, ERROR_BAD_PIPE,

    STATUS_PIPE_CLOSING, ERROR_NO_DATA,
    STATUS_PIPE_EMPTY, ERROR_NO_DATA,

    STATUS_PIPE_CONNECTED, ERROR_PIPE_CONNECTED,

    STATUS_PIPE_DISCONNECTED, ERROR_PIPE_NOT_CONNECTED,

    STATUS_PIPE_LISTENING, ERROR_PIPE_LISTENING,

    STATUS_PIPE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_INSTANCE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_PIPE_BUSY, ERROR_PIPE_BUSY,

    STATUS_PIPE_BROKEN, ERROR_BROKEN_PIPE,

    STATUS_DIRECTORY_NOT_EMPTY, ERROR_DIR_NOT_EMPTY,

    STATUS_TOO_MANY_OPENED_FILES, ERROR_TOO_MANY_OPEN_FILES,

    STATUS_IO_TIMEOUT, ERROR_SEM_TIMEOUT,

    STATUS_CANCELLED, ERROR_OPERATION_ABORTED,

    STATUS_UNRECOGNIZED_MEDIA, ERROR_UNRECOGNIZED_MEDIA,

    STATUS_INVALID_LEVEL, ERROR_INVALID_LEVEL,

    STATUS_UNRECOGNIZED_VOLUME, ERROR_UNRECOGNIZED_VOLUME,

    STATUS_MEDIA_WRITE_PROTECTED, ERROR_WRITE_PROTECT,
    STATUS_TOO_LATE, ERROR_WRITE_PROTECT,

    STATUS_SUCCESS, NO_ERROR,

    STATUS_FULLSCREEN_MODE, ERROR_FULLSCREEN_MODE,

    STATUS_END_OF_MEDIA, ERROR_END_OF_MEDIA,

    STATUS_EOM_OVERFLOW, ERROR_EOM_OVERFLOW,

    STATUS_BEGINNING_OF_MEDIA, ERROR_BEGINNING_OF_MEDIA,

    STATUS_MEDIA_CHANGED, ERROR_MEDIA_CHANGED,

    STATUS_BUS_RESET, ERROR_BUS_RESET,

    STATUS_FILEMARK_DETECTED, ERROR_FILEMARK_DETECTED,

    STATUS_SETMARK_DETECTED, ERROR_SETMARK_DETECTED,

    STATUS_NO_DATA_DETECTED, ERROR_NO_DATA_DETECTED,

    STATUS_PARTITION_FAILURE, ERROR_PARTITION_FAILURE,

    STATUS_INVALID_BLOCK_LENGTH, ERROR_INVALID_BLOCK_LENGTH,

    STATUS_DEVICE_NOT_PARTITIONED, ERROR_DEVICE_NOT_PARTITIONED,

    STATUS_UNABLE_TO_LOCK_MEDIA, ERROR_UNABLE_TO_LOCK_MEDIA,

    STATUS_UNABLE_TO_UNLOAD_MEDIA, ERROR_UNABLE_TO_UNLOAD_MEDIA,

    STATUS_UNMAPPABLE_CHARACTER, ERROR_NO_UNICODE_TRANSLATION,

    STATUS_NOT_ALL_ASSIGNED, ERROR_NOT_ALL_ASSIGNED,

    STATUS_SOME_NOT_MAPPED, ERROR_SOME_NOT_MAPPED,

    STATUS_NO_QUOTAS_FOR_ACCOUNT, ERROR_NO_QUOTAS_FOR_ACCOUNT,

    STATUS_LOCAL_USER_SESSION_KEY, ERROR_LOCAL_USER_SESSION_KEY,

    STATUS_NULL_LM_PASSWORD, ERROR_NULL_LM_PASSWORD,

    STATUS_BAD_INHERITANCE_ACL, ERROR_BAD_INHERITANCE_ACL,

    STATUS_INVALID_GROUP_ATTRIBUTES, ERROR_INVALID_GROUP_ATTRIBUTES,

    STATUS_BAD_IMPERSONATION_LEVEL, ERROR_BAD_IMPERSONATION_LEVEL,

    STATUS_CANT_OPEN_ANONYMOUS, ERROR_CANT_OPEN_ANONYMOUS,

    STATUS_BAD_VALIDATION_CLASS, ERROR_BAD_VALIDATION_CLASS,

    STATUS_BAD_TOKEN_TYPE, ERROR_BAD_TOKEN_TYPE,

    STATUS_BAD_MASTER_BOOT_RECORD, ERROR_INVALID_PARAMETER,

    STATUS_NO_SECURITY_ON_OBJECT, ERROR_NO_SECURITY_ON_OBJECT,

    STATUS_CANT_ACCESS_DOMAIN_INFO, ERROR_CANT_ACCESS_DOMAIN_INFO,

    STATUS_INVALID_SERVER_STATE, ERROR_INVALID_SERVER_STATE,

    STATUS_INVALID_DOMAIN_STATE, ERROR_INVALID_DOMAIN_STATE,

    STATUS_INVALID_DOMAIN_ROLE, ERROR_INVALID_DOMAIN_ROLE,

    STATUS_NO_SUCH_DOMAIN, ERROR_NO_SUCH_DOMAIN,

    STATUS_DOMAIN_EXISTS, ERROR_DOMAIN_EXISTS,

    STATUS_DOMAIN_LIMIT_EXCEEDED, ERROR_DOMAIN_LIMIT_EXCEEDED,

    STATUS_OPLOCK_NOT_GRANTED, ERROR_OPLOCK_NOT_GRANTED,
    STATUS_INVALID_OPLOCK_PROTOCOL, ERROR_INVALID_OPLOCK_PROTOCOL,

    STATUS_INTERNAL_DB_CORRUPTION, ERROR_INTERNAL_DB_CORRUPTION,

    STATUS_INTERNAL_ERROR, ERROR_INTERNAL_ERROR,

    STATUS_GENERIC_NOT_MAPPED, ERROR_GENERIC_NOT_MAPPED,

    STATUS_BAD_DESCRIPTOR_FORMAT, ERROR_BAD_DESCRIPTOR_FORMAT,

    STATUS_NOT_LOGON_PROCESS, ERROR_NOT_LOGON_PROCESS,

    STATUS_LOGON_SESSION_EXISTS, ERROR_LOGON_SESSION_EXISTS,

    STATUS_NO_SUCH_PACKAGE, ERROR_NO_SUCH_PACKAGE,

    STATUS_BAD_LOGON_SESSION_STATE, ERROR_BAD_LOGON_SESSION_STATE,

    STATUS_LOGON_SESSION_COLLISION, ERROR_LOGON_SESSION_COLLISION,

    STATUS_INVALID_LOGON_TYPE, ERROR_INVALID_LOGON_TYPE,

    STATUS_RXACT_INVALID_STATE, ERROR_RXACT_INVALID_STATE,

    STATUS_RXACT_COMMIT_FAILURE, ERROR_RXACT_COMMIT_FAILURE,

    STATUS_SPECIAL_ACCOUNT, ERROR_SPECIAL_ACCOUNT,

    STATUS_SPECIAL_USER, ERROR_SPECIAL_USER,

    STATUS_MEMBERS_PRIMARY_GROUP, ERROR_MEMBERS_PRIMARY_GROUP,

    STATUS_TOKEN_ALREADY_IN_USE, ERROR_TOKEN_ALREADY_IN_USE,

    STATUS_NO_SUCH_ALIAS, ERROR_NO_SUCH_ALIAS,

    STATUS_MEMBER_NOT_IN_ALIAS, ERROR_MEMBER_NOT_IN_ALIAS,

    STATUS_MEMBER_IN_ALIAS, ERROR_MEMBER_IN_ALIAS,

    STATUS_ALIAS_EXISTS, ERROR_ALIAS_EXISTS,

    STATUS_LOGON_NOT_GRANTED, ERROR_LOGON_NOT_GRANTED,

    STATUS_TOO_MANY_SECRETS, ERROR_TOO_MANY_SECRETS,

    STATUS_SECRET_TOO_LONG, ERROR_SECRET_TOO_LONG,

    STATUS_INTERNAL_DB_ERROR, ERROR_INTERNAL_DB_ERROR,

    STATUS_TOO_MANY_CONTEXT_IDS, ERROR_TOO_MANY_CONTEXT_IDS,

    STATUS_LOGON_TYPE_NOT_GRANTED, ERROR_LOGON_TYPE_NOT_GRANTED,

    STATUS_NT_CROSS_ENCRYPTION_REQUIRED, ERROR_NT_CROSS_ENCRYPTION_REQUIRED,

    STATUS_NO_SUCH_MEMBER, ERROR_NO_SUCH_MEMBER,

    STATUS_INVALID_MEMBER, ERROR_INVALID_MEMBER,

    STATUS_TOO_MANY_SIDS, ERROR_TOO_MANY_SIDS,

    STATUS_LM_CROSS_ENCRYPTION_REQUIRED, ERROR_LM_CROSS_ENCRYPTION_REQUIRED,

    STATUS_RECOVERY_FAILURE, ERROR_RECOVERY_FAILURE,

    STATUS_MESSAGE_NOT_FOUND, ERROR_MR_MID_NOT_FOUND,

    STATUS_LOCAL_DISCONNECT, ERROR_NETNAME_DELETED,
    STATUS_REMOTE_DISCONNECT, ERROR_NETNAME_DELETED,

    STATUS_REMOTE_RESOURCES, ERROR_REM_NOT_LIST,

    STATUS_LINK_FAILED, ERROR_UNEXP_NET_ERR,
    STATUS_LINK_TIMEOUT, ERROR_UNEXP_NET_ERR,

    STATUS_INVALID_CONNECTION, ERROR_UNEXP_NET_ERR,
    STATUS_INVALID_ADDRESS, ERROR_UNEXP_NET_ERR,

    STATUS_IO_DEVICE_ERROR, ERROR_IO_DEVICE,
    STATUS_DEVICE_PROTOCOL_ERROR, ERROR_IO_DEVICE,
    STATUS_DRIVER_INTERNAL_ERROR, ERROR_IO_DEVICE,
    STATUS_UNEXPECTED_IO_ERROR, ERROR_IO_DEVICE,

    STATUS_INVALID_DEVICE_STATE, ERROR_BAD_COMMAND,

    STATUS_DEVICE_CONFIGURATION_ERROR, ERROR_INVALID_PARAMETER,

    STATUS_SOURCE_ELEMENT_EMPTY,       ERROR_SOURCE_ELEMENT_EMPTY,
    STATUS_DESTINATION_ELEMENT_FULL,   ERROR_DESTINATION_ELEMENT_FULL,
    STATUS_ILLEGAL_ELEMENT_ADDRESS,    ERROR_ILLEGAL_ELEMENT_ADDRESS,
    STATUS_MAGAZINE_NOT_PRESENT,       ERROR_MAGAZINE_NOT_PRESENT,
    STATUS_REINITIALIZATION_NEEDED,    ERROR_DEVICE_REINITIALIZATION_NEEDED,
    STATUS_DEVICE_REQUIRES_CLEANING,   ERROR_DEVICE_REQUIRES_CLEANING,
    STATUS_DEVICE_DOOR_OPEN,           ERROR_DEVICE_DOOR_OPEN,
    STATUS_TRANSPORT_FULL,             ERROR_TRANSPORT_FULL,
    STATUS_CLEANER_CARTRIDGE_INSTALLED, ERROR_CLEANER_CARTRIDGE_INSTALLED,
    STATUS_REG_NAT_CONSUMPTION,        ERROR_REG_NAT_CONSUMPTION,

    STATUS_ENCRYPTION_FAILED,          ERROR_ACCESS_DENIED,
    STATUS_DECRYPTION_FAILED,          ERROR_ACCESS_DENIED,
    STATUS_NO_RECOVERY_POLICY,         ERROR_ACCESS_DENIED,
    STATUS_NO_EFS,                     ERROR_ACCESS_DENIED,
    STATUS_WRONG_EFS,                  ERROR_ACCESS_DENIED,
    STATUS_NO_USER_KEYS,               ERROR_ACCESS_DENIED,
    STATUS_FILE_NOT_ENCRYPTED,         ERROR_FILE_NOT_ENCRYPTED,
    STATUS_NOT_EXPORT_FORMAT,          ERROR_NOT_EXPORT_FORMAT,
    STATUS_FILE_ENCRYPTED,             ERROR_FILE_ENCRYPTED,
    STATUS_EFS_ALG_BLOB_TOO_BIG,       ERROR_EFS_ALG_BLOB_TOO_BIG,

    STATUS_INVALID_USER_BUFFER, ERROR_INVALID_USER_BUFFER,

    STATUS_SERIAL_NO_DEVICE_INITED, ERROR_SERIAL_NO_DEVICE,

    STATUS_SHARED_IRQ_BUSY, ERROR_IRQ_BUSY,

    STATUS_SERIAL_MORE_WRITES, ERROR_MORE_WRITES,

    STATUS_SERIAL_COUNTER_TIMEOUT, ERROR_COUNTER_TIMEOUT,

    STATUS_FLOPPY_ID_MARK_NOT_FOUND, ERROR_FLOPPY_ID_MARK_NOT_FOUND,

    STATUS_FLOPPY_WRONG_CYLINDER, ERROR_FLOPPY_WRONG_CYLINDER,

    STATUS_FLOPPY_UNKNOWN_ERROR, ERROR_FLOPPY_UNKNOWN_ERROR,

    STATUS_FLOPPY_BAD_REGISTERS, ERROR_FLOPPY_BAD_REGISTERS,

    STATUS_DISK_RECALIBRATE_FAILED, ERROR_DISK_RECALIBRATE_FAILED,

    STATUS_DISK_OPERATION_FAILED, ERROR_DISK_OPERATION_FAILED,

    STATUS_DISK_RESET_FAILED, ERROR_DISK_RESET_FAILED,

    STATUS_EVENTLOG_FILE_CORRUPT, ERROR_EVENTLOG_FILE_CORRUPT,

    STATUS_EVENTLOG_CANT_START, ERROR_EVENTLOG_CANT_START,

    STATUS_NETLOGON_NOT_STARTED, ERROR_NETLOGON_NOT_STARTED,

    STATUS_ACCOUNT_EXPIRED, ERROR_ACCOUNT_EXPIRED,

    STATUS_NETWORK_CREDENTIAL_CONFLICT, ERROR_SESSION_CREDENTIAL_CONFLICT,

    STATUS_REMOTE_SESSION_LIMIT, ERROR_REMOTE_SESSION_LIMIT_EXCEEDED,

    STATUS_INVALID_BUFFER_SIZE, ERROR_INVALID_USER_BUFFER,

    STATUS_INVALID_ADDRESS_COMPONENT, ERROR_INVALID_NETNAME,
    STATUS_INVALID_ADDRESS_WILDCARD, ERROR_INVALID_NETNAME,

    STATUS_ADDRESS_ALREADY_EXISTS, ERROR_DUP_NAME,

    STATUS_ADDRESS_CLOSED, ERROR_NETNAME_DELETED,
    STATUS_CONNECTION_DISCONNECTED, ERROR_NETNAME_DELETED,

    STATUS_CONNECTION_RESET, ERROR_NETNAME_DELETED,

    STATUS_TRANSACTION_ABORTED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_TIMED_OUT, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_RELEASE, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_MATCH, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_RESPONDED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_ID, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_TYPE, ERROR_UNEXP_NET_ERR,

    STATUS_NOT_SERVER_SESSION, ERROR_NOT_SUPPORTED,
    STATUS_NOT_CLIENT_SESSION, ERROR_NOT_SUPPORTED,

    STATUS_USER_MAPPED_FILE, ERROR_USER_MAPPED_FILE,

    STATUS_PLUGPLAY_NO_DEVICE, ERROR_SERVICE_DISABLED,

    STATUS_WMI_GUID_NOT_FOUND, ERROR_WMI_GUID_NOT_FOUND,
    STATUS_WMI_INSTANCE_NOT_FOUND, ERROR_WMI_INSTANCE_NOT_FOUND,
    STATUS_WMI_ITEMID_NOT_FOUND, ERROR_WMI_ITEMID_NOT_FOUND,
    STATUS_WMI_TRY_AGAIN, ERROR_WMI_TRY_AGAIN,
    STATUS_WMI_READ_ONLY, ERROR_WMI_READ_ONLY,
    STATUS_WMI_SET_FAILURE, ERROR_WMI_SET_FAILURE,
    STATUS_WMI_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    STATUS_WMI_GUID_DISCONNECTED, ERROR_WMI_GUID_DISCONNECTED,
    STATUS_WMI_ALREADY_DISABLED, ERROR_WMI_ALREADY_DISABLED,
    STATUS_WMI_ALREADY_ENABLED, ERROR_WMI_ALREADY_ENABLED,

    STATUS_COPY_PROTECTION_FAILURE    , STG_E_STATUS_COPY_PROTECTION_FAILURE,
    STATUS_CSS_AUTHENTICATION_FAILURE , STG_E_CSS_AUTHENTICATION_FAILURE,
    STATUS_CSS_KEY_NOT_PRESENT        , STG_E_CSS_KEY_NOT_PRESENT,
    STATUS_CSS_KEY_NOT_ESTABLISHED    , STG_E_CSS_KEY_NOT_ESTABLISHED,
    STATUS_CSS_SCRAMBLED_SECTOR       , STG_E_CSS_SCRAMBLED_SECTOR,
    STATUS_CSS_REGION_MISMATCH        , STG_E_CSS_REGION_MISMATCH,
    STATUS_CSS_RESETS_EXHAUSTED       , STG_E_RESETS_EXHAUSTED,

    RPC_NT_SERVER_UNAVAILABLE, RPC_S_SERVER_UNAVAILABLE,

    RPC_NT_INVALID_STRING_BINDING, RPC_S_INVALID_STRING_BINDING,

    RPC_NT_WRONG_KIND_OF_BINDING, RPC_S_WRONG_KIND_OF_BINDING,

    RPC_NT_PROTSEQ_NOT_SUPPORTED, RPC_S_PROTSEQ_NOT_SUPPORTED,

    RPC_NT_INVALID_RPC_PROTSEQ, RPC_S_INVALID_RPC_PROTSEQ,

    RPC_NT_INVALID_STRING_UUID, RPC_S_INVALID_STRING_UUID,

    RPC_NT_INVALID_ENDPOINT_FORMAT, RPC_S_INVALID_ENDPOINT_FORMAT,

    RPC_NT_INVALID_NET_ADDR, RPC_S_INVALID_NET_ADDR,

    RPC_NT_NO_ENDPOINT_FOUND, RPC_S_NO_ENDPOINT_FOUND,

    RPC_NT_INVALID_TIMEOUT, RPC_S_INVALID_TIMEOUT,

    RPC_NT_OBJECT_NOT_FOUND, RPC_S_OBJECT_NOT_FOUND,

    RPC_NT_ALREADY_REGISTERED, RPC_S_ALREADY_REGISTERED,

    RPC_NT_TYPE_ALREADY_REGISTERED, RPC_S_TYPE_ALREADY_REGISTERED,

    RPC_NT_ALREADY_LISTENING, RPC_S_ALREADY_LISTENING,

    RPC_NT_NO_PROTSEQS_REGISTERED, RPC_S_NO_PROTSEQS_REGISTERED,

    RPC_NT_NOT_LISTENING, RPC_S_NOT_LISTENING,

    RPC_NT_UNKNOWN_MGR_TYPE, RPC_S_UNKNOWN_MGR_TYPE,

    RPC_NT_UNKNOWN_IF, RPC_S_UNKNOWN_IF,

    RPC_NT_NO_BINDINGS, RPC_S_NO_BINDINGS,

    RPC_NT_NO_MORE_BINDINGS, RPC_S_NO_MORE_BINDINGS,

    RPC_NT_NO_PROTSEQS, RPC_S_NO_PROTSEQS,

    RPC_NT_CANT_CREATE_ENDPOINT, RPC_S_CANT_CREATE_ENDPOINT,

    RPC_NT_OUT_OF_RESOURCES, RPC_S_OUT_OF_RESOURCES,

    RPC_NT_SERVER_TOO_BUSY, RPC_S_SERVER_TOO_BUSY,

    RPC_NT_INVALID_NETWORK_OPTIONS, RPC_S_INVALID_NETWORK_OPTIONS,

    RPC_NT_NO_CALL_ACTIVE, RPC_S_NO_CALL_ACTIVE,

    RPC_NT_CALL_FAILED, RPC_S_CALL_FAILED,

    RPC_NT_CALL_FAILED_DNE, RPC_S_CALL_FAILED_DNE,

    RPC_NT_PROTOCOL_ERROR, RPC_S_PROTOCOL_ERROR,

    RPC_NT_UNSUPPORTED_TRANS_SYN, RPC_S_UNSUPPORTED_TRANS_SYN,

    RPC_NT_UNSUPPORTED_TYPE, RPC_S_UNSUPPORTED_TYPE,

    RPC_NT_INVALID_TAG, RPC_S_INVALID_TAG,

    RPC_NT_INVALID_BOUND, RPC_S_INVALID_BOUND,

    RPC_NT_NO_ENTRY_NAME, RPC_S_NO_ENTRY_NAME,

    RPC_NT_INVALID_NAME_SYNTAX, RPC_S_INVALID_NAME_SYNTAX,

    RPC_NT_UNSUPPORTED_NAME_SYNTAX, RPC_S_UNSUPPORTED_NAME_SYNTAX,

    RPC_NT_UUID_NO_ADDRESS, RPC_S_UUID_NO_ADDRESS,

    RPC_NT_DUPLICATE_ENDPOINT, RPC_S_DUPLICATE_ENDPOINT,

    RPC_NT_UNKNOWN_AUTHN_TYPE, RPC_S_UNKNOWN_AUTHN_TYPE,

    RPC_NT_MAX_CALLS_TOO_SMALL, RPC_S_MAX_CALLS_TOO_SMALL,

    RPC_NT_STRING_TOO_LONG, RPC_S_STRING_TOO_LONG,

    RPC_NT_PROTSEQ_NOT_FOUND, RPC_S_PROTSEQ_NOT_FOUND,

    RPC_NT_PROCNUM_OUT_OF_RANGE, RPC_S_PROCNUM_OUT_OF_RANGE,

    RPC_NT_BINDING_HAS_NO_AUTH, RPC_S_BINDING_HAS_NO_AUTH,

    RPC_NT_UNKNOWN_AUTHN_SERVICE, RPC_S_UNKNOWN_AUTHN_SERVICE,

    RPC_NT_UNKNOWN_AUTHN_LEVEL, RPC_S_UNKNOWN_AUTHN_LEVEL,

    RPC_NT_INVALID_AUTH_IDENTITY, RPC_S_INVALID_AUTH_IDENTITY,

    RPC_NT_UNKNOWN_AUTHZ_SERVICE, RPC_S_UNKNOWN_AUTHZ_SERVICE,

    EPT_NT_INVALID_ENTRY, EPT_S_INVALID_ENTRY,

    EPT_NT_CANT_PERFORM_OP, EPT_S_CANT_PERFORM_OP,

    EPT_NT_NOT_REGISTERED, EPT_S_NOT_REGISTERED,

    RPC_NT_NOTHING_TO_EXPORT, RPC_S_NOTHING_TO_EXPORT,

    RPC_NT_INCOMPLETE_NAME, RPC_S_INCOMPLETE_NAME,

    RPC_NT_INVALID_VERS_OPTION, RPC_S_INVALID_VERS_OPTION,

    RPC_NT_NO_MORE_MEMBERS, RPC_S_NO_MORE_MEMBERS,

    RPC_NT_NOT_ALL_OBJS_UNEXPORTED, RPC_S_NOT_ALL_OBJS_UNEXPORTED,

    RPC_NT_INTERFACE_NOT_FOUND, RPC_S_INTERFACE_NOT_FOUND,

    RPC_NT_ENTRY_ALREADY_EXISTS, RPC_S_ENTRY_ALREADY_EXISTS,

    RPC_NT_ENTRY_NOT_FOUND, RPC_S_ENTRY_NOT_FOUND,

    RPC_NT_NAME_SERVICE_UNAVAILABLE, RPC_S_NAME_SERVICE_UNAVAILABLE,

    RPC_NT_INVALID_NAF_ID, RPC_S_INVALID_NAF_ID,

    RPC_NT_CANNOT_SUPPORT, RPC_S_CANNOT_SUPPORT,

    RPC_NT_NO_CONTEXT_AVAILABLE, RPC_S_NO_CONTEXT_AVAILABLE,

    RPC_NT_INTERNAL_ERROR, RPC_S_INTERNAL_ERROR,

    RPC_NT_ZERO_DIVIDE, RPC_S_ZERO_DIVIDE,

    RPC_NT_ADDRESS_ERROR, RPC_S_ADDRESS_ERROR,

    RPC_NT_FP_DIV_ZERO, RPC_S_FP_DIV_ZERO,

    RPC_NT_FP_UNDERFLOW, RPC_S_FP_UNDERFLOW,

    RPC_NT_FP_OVERFLOW, RPC_S_FP_OVERFLOW,

    RPC_NT_NO_MORE_ENTRIES, RPC_X_NO_MORE_ENTRIES,

    RPC_NT_SS_CHAR_TRANS_OPEN_FAIL, RPC_X_SS_CHAR_TRANS_OPEN_FAIL,

    RPC_NT_SS_CHAR_TRANS_SHORT_FILE, RPC_X_SS_CHAR_TRANS_SHORT_FILE,

    RPC_NT_SS_CONTEXT_MISMATCH, ERROR_INVALID_HANDLE,

    RPC_NT_SS_CONTEXT_DAMAGED, RPC_X_SS_CONTEXT_DAMAGED,

    RPC_NT_SS_HANDLES_MISMATCH, RPC_X_SS_HANDLES_MISMATCH,

    RPC_NT_SS_CANNOT_GET_CALL_HANDLE, RPC_X_SS_CANNOT_GET_CALL_HANDLE,

    RPC_NT_NULL_REF_POINTER, RPC_X_NULL_REF_POINTER,

    RPC_NT_ENUM_VALUE_OUT_OF_RANGE, RPC_X_ENUM_VALUE_OUT_OF_RANGE,

    RPC_NT_BYTE_COUNT_TOO_SMALL, RPC_X_BYTE_COUNT_TOO_SMALL,

    RPC_NT_BAD_STUB_DATA, RPC_X_BAD_STUB_DATA,

    RPC_NT_INVALID_OBJECT, RPC_S_INVALID_OBJECT,

    STATUS_NO_TRUST_LSA_SECRET, ERROR_NO_TRUST_LSA_SECRET,

    STATUS_NO_TRUST_SAM_ACCOUNT, ERROR_NO_TRUST_SAM_ACCOUNT,

    STATUS_TRUSTED_DOMAIN_FAILURE, ERROR_TRUSTED_DOMAIN_FAILURE,

    STATUS_TRUSTED_RELATIONSHIP_FAILURE, ERROR_TRUSTED_RELATIONSHIP_FAILURE,

    STATUS_TRUST_FAILURE, ERROR_TRUST_FAILURE,

    RPC_NT_CALL_IN_PROGRESS, RPC_S_CALL_IN_PROGRESS,

    STATUS_LOG_FILE_FULL, ERROR_LOG_FILE_FULL,

    STATUS_EVENTLOG_FILE_CHANGED, ERROR_EVENTLOG_FILE_CHANGED,

    STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT, ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT,

    STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT, ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT,

    STATUS_NOLOGON_SERVER_TRUST_ACCOUNT, ERROR_NOLOGON_SERVER_TRUST_ACCOUNT,

    STATUS_DOMAIN_TRUST_INCONSISTENT, ERROR_DOMAIN_TRUST_INCONSISTENT,

    STATUS_NO_USER_SESSION_KEY, ERROR_NO_USER_SESSION_KEY,

    STATUS_POSSIBLE_DEADLOCK, ERROR_POSSIBLE_DEADLOCK,

    STATUS_IMAGE_ALREADY_LOADED, ERROR_SERVICE_ALREADY_RUNNING,

    RPC_NT_GROUP_MEMBER_NOT_FOUND, RPC_S_GROUP_MEMBER_NOT_FOUND,

    RPC_NT_NO_INTERFACES, RPC_S_NO_INTERFACES,

    RPC_NT_CALL_CANCELLED, RPC_S_CALL_CANCELLED,

    RPC_NT_BINDING_INCOMPLETE, RPC_S_BINDING_INCOMPLETE,

    RPC_NT_COMM_FAILURE, RPC_S_COMM_FAILURE,

    RPC_NT_UNSUPPORTED_AUTHN_LEVEL, RPC_S_UNSUPPORTED_AUTHN_LEVEL,

    RPC_NT_NO_PRINC_NAME, RPC_S_NO_PRINC_NAME,

    RPC_NT_NOT_RPC_ERROR, RPC_S_NOT_RPC_ERROR,

    RPC_NT_UUID_LOCAL_ONLY, RPC_S_UUID_LOCAL_ONLY,

    RPC_NT_SEC_PKG_ERROR, RPC_S_SEC_PKG_ERROR,

    RPC_NT_NOT_CANCELLED, RPC_S_NOT_CANCELLED,

    RPC_NT_INVALID_ES_ACTION, RPC_X_INVALID_ES_ACTION,
    RPC_NT_WRONG_ES_VERSION, RPC_X_WRONG_ES_VERSION,
    RPC_NT_WRONG_STUB_VERSION, RPC_X_WRONG_STUB_VERSION,

    RPC_NT_INVALID_PIPE_OBJECT,    RPC_X_INVALID_PIPE_OBJECT,
    RPC_NT_INVALID_PIPE_OPERATION, RPC_X_INVALID_PIPE_OPERATION,
    RPC_NT_WRONG_PIPE_VERSION,     RPC_X_WRONG_PIPE_VERSION,

    EPT_NT_CANT_CREATE,            EPT_S_CANT_CREATE,

    RPC_NT_SEND_INCOMPLETE,        RPC_S_SEND_INCOMPLETE,
    RPC_NT_INVALID_ASYNC_HANDLE,   RPC_S_INVALID_ASYNC_HANDLE,
    RPC_NT_INVALID_ASYNC_CALL,     RPC_S_INVALID_ASYNC_CALL,
    RPC_NT_PIPE_CLOSED,            RPC_X_PIPE_CLOSED,
    RPC_NT_PIPE_EMPTY,             RPC_X_PIPE_EMPTY,
    RPC_NT_PIPE_DISCIPLINE_ERROR,  RPC_X_PIPE_DISCIPLINE_ERROR,

    STATUS_NO_BROWSER_SERVERS_FOUND, ERROR_NO_BROWSER_SERVERS_FOUND,

    STATUS_MAPPED_ALIGNMENT, ERROR_MAPPED_ALIGNMENT,

    STATUS_CONNECTION_IN_USE, ERROR_DEVICE_IN_USE,

    STATUS_VERIFY_REQUIRED, ERROR_MEDIA_CHANGED,

    STATUS_ALREADY_DISCONNECTED, ERROR_ACTIVE_CONNECTIONS,

    STATUS_CONNECTION_REFUSED, ERROR_CONNECTION_REFUSED,

    STATUS_GRACEFUL_DISCONNECT, ERROR_GRACEFUL_DISCONNECT,

    STATUS_ADDRESS_ALREADY_ASSOCIATED, ERROR_ADDRESS_ALREADY_ASSOCIATED,

    STATUS_ADDRESS_NOT_ASSOCIATED, ERROR_ADDRESS_NOT_ASSOCIATED,

    STATUS_CONNECTION_INVALID, ERROR_CONNECTION_INVALID,

    STATUS_CONNECTION_ACTIVE, ERROR_CONNECTION_ACTIVE,

    STATUS_NETWORK_UNREACHABLE, ERROR_NETWORK_UNREACHABLE,

    STATUS_HOST_UNREACHABLE, ERROR_HOST_UNREACHABLE,

    STATUS_HOST_DOWN, ERROR_HOST_DOWN,

    STATUS_PROTOCOL_UNREACHABLE, ERROR_PROTOCOL_UNREACHABLE,

    STATUS_PORT_UNREACHABLE, ERROR_PORT_UNREACHABLE,

    STATUS_REQUEST_ABORTED, ERROR_REQUEST_ABORTED,

    STATUS_CONNECTION_ABORTED, ERROR_CONNECTION_ABORTED,

    STATUS_CONNECTION_COUNT_LIMIT, ERROR_CONNECTION_COUNT_LIMIT,

    STATUS_PATH_NOT_COVERED, ERROR_HOST_UNREACHABLE,

    STATUS_LOGIN_TIME_RESTRICTION, ERROR_LOGIN_TIME_RESTRICTION,
    STATUS_LOGIN_WKSTA_RESTRICTION, ERROR_LOGIN_WKSTA_RESTRICTION,
    STATUS_LICENSE_QUOTA_EXCEEDED, ERROR_LICENSE_QUOTA_EXCEEDED,

    STATUS_RESOURCE_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_DUPLICATE_OBJECTID, STATUS_DUPLICATE_OBJECTID,
    STATUS_OBJECTID_EXISTS, STATUS_OBJECTID_EXISTS,
    STATUS_OBJECTID_NOT_FOUND, ERROR_FILE_NOT_FOUND,
    STATUS_MFT_TOO_FRAGMENTED, ERROR_DISK_TOO_FRAGMENTED,
    SEC_E_INSUFFICIENT_MEMORY, ERROR_NO_SYSTEM_RESOURCES,
    SEC_E_INVALID_HANDLE, ERROR_INVALID_HANDLE,
    SEC_E_UNSUPPORTED_FUNCTION, ERROR_INVALID_FUNCTION,
    SEC_E_TARGET_UNKNOWN, ERROR_BAD_NETPATH,
    SEC_E_INTERNAL_ERROR, ERROR_INTERNAL_ERROR,
    SEC_E_SECPKG_NOT_FOUND, ERROR_NO_SUCH_PACKAGE,
    SEC_E_NOT_OWNER, ERROR_NOT_OWNER,
    SEC_E_CANNOT_INSTALL, ERROR_NO_SUCH_PACKAGE,
    SEC_E_INVALID_TOKEN, ERROR_INVALID_PARAMETER,
    SEC_E_CANNOT_PACK, ERROR_INVALID_PARAMETER,
    SEC_E_QOP_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    SEC_E_NO_IMPERSONATION, ERROR_CANNOT_IMPERSONATE,
    SEC_E_MULTIPLE_ACCOUNTS, ERROR_CANNOT_IMPERSONATE,
    SEC_E_LOGON_DENIED, ERROR_LOGON_FAILURE,
    SEC_E_UNKNOWN_CREDENTIALS, ERROR_INVALID_PARAMETER,
    SEC_E_INCOMPLETE_CREDENTIALS, ERROR_INVALID_PARAMETER,
    SEC_E_NO_CREDENTIALS, ERROR_NO_SUCH_LOGON_SESSION,
    SEC_E_MESSAGE_ALTERED, ERROR_ACCESS_DENIED,
    SEC_E_OUT_OF_SEQUENCE, ERROR_ACCESS_DENIED,
    SEC_E_NO_AUTHENTICATING_AUTHORITY, ERROR_NO_LOGON_SERVERS,
    SEC_E_BAD_PKGID, ERROR_NO_SUCH_PACKAGE,
    SEC_E_WRONG_PRINCIPAL, ERROR_WRONG_TARGET_NAME,
    SEC_E_INCOMPLETE_MESSAGE, ERROR_INVALID_USER_BUFFER,
    SEC_E_BUFFER_TOO_SMALL, ERROR_INSUFFICIENT_BUFFER,
    SEC_E_UNTRUSTED_ROOT, ERROR_TRUST_FAILURE,
    SEC_E_ILLEGAL_MESSAGE, ERROR_INVALID_PARAMETER,
    SEC_E_CERT_UNKNOWN, ERROR_INVALID_PARAMETER,
    SEC_E_CERT_EXPIRED, ERROR_PASSWORD_EXPIRED,
    SEC_E_ENCRYPT_FAILURE, ERROR_ENCRYPTION_FAILED,
    SEC_E_DECRYPT_FAILURE, ERROR_DECRYPTION_FAILED,
    SEC_E_ALGORITHM_MISMATCH, ERROR_INVALID_FUNCTION,
    SEC_E_CONTEXT_EXPIRED, ERROR_CONTEXT_EXPIRED,
    SEC_E_CERT_WRONG_USAGE, ERROR_BAD_TOKEN_TYPE,

    STATUS_BAD_BINDINGS, SEC_E_BAD_BINDINGS,

    TRUST_E_CERT_SIGNATURE, ERROR_MUTUAL_AUTH_FAILED,
    CRYPT_E_REVOKED, ERROR_MUTUAL_AUTH_FAILED,
    CRYPT_E_NO_REVOCATION_CHECK, ERROR_MUTUAL_AUTH_FAILED,
    CRYPT_E_REVOCATION_OFFLINE, ERROR_MUTUAL_AUTH_FAILED,

    STATUS_SHUTDOWN_IN_PROGRESS, ERROR_SHUTDOWN_IN_PROGRESS,
    STATUS_SERVER_SHUTDOWN_IN_PROGRESS, ERROR_SERVER_SHUTDOWN_IN_PROGRESS,
    STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY,ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY,

    STATUS_DS_NO_ATTRIBUTE_OR_VALUE,ERROR_DS_NO_ATTRIBUTE_OR_VALUE,

    STATUS_DS_INVALID_ATTRIBUTE_SYNTAX,ERROR_DS_INVALID_ATTRIBUTE_SYNTAX,

    STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED,ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED,

    STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS,ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS,

    STATUS_DS_BUSY,ERROR_DS_BUSY,

    STATUS_DS_UNAVAILABLE,ERROR_DS_UNAVAILABLE,

    STATUS_DS_NO_RIDS_ALLOCATED,ERROR_DS_NO_RIDS_ALLOCATED,

    STATUS_DS_NO_MORE_RIDS,ERROR_DS_NO_MORE_RIDS,

    STATUS_DS_INCORRECT_ROLE_OWNER,ERROR_DS_INCORRECT_ROLE_OWNER,

    STATUS_DS_RIDMGR_INIT_ERROR,ERROR_DS_RIDMGR_INIT_ERROR,

    STATUS_DS_OBJ_CLASS_VIOLATION,ERROR_DS_OBJ_CLASS_VIOLATION,

    STATUS_DS_CANT_ON_NON_LEAF,ERROR_DS_CANT_ON_NON_LEAF,

    STATUS_DS_CANT_ON_RDN,ERROR_DS_CANT_ON_RDN,

    STATUS_DS_CROSS_DOM_MOVE_FAILED,ERROR_DS_CROSS_DOM_MOVE_ERROR,

    STATUS_DS_GC_NOT_AVAILABLE,ERROR_DS_GC_NOT_AVAILABLE,

    STATUS_DS_CANT_MOD_OBJ_CLASS, ERROR_DS_CANT_MOD_OBJ_CLASS,

    STATUS_DS_ADMIN_LIMIT_EXCEEDED, ERROR_DS_ADMIN_LIMIT_EXCEEDED,

    STATUS_DIRECTORY_SERVICE_REQUIRED, ERROR_DS_DS_REQUIRED,

    STATUS_DS_SAM_INIT_FAILURE, ERROR_DS_SAM_INIT_FAILURE,

    STATUS_DS_CANT_START, ERROR_DS_CANT_START,

    STATUS_DS_INIT_FAILURE, ERROR_DS_INIT_FAILURE,

    STATUS_SAM_INIT_FAILURE, ERROR_SAM_INIT_FAILURE,

    STATUS_DS_SENSITIVE_GROUP_VIOLATION, ERROR_DS_SENSITIVE_GROUP_VIOLATION,

    STATUS_DS_CANT_MOD_PRIMARYGROUPID, ERROR_DS_CANT_MOD_PRIMARYGROUPID,

    STATUS_DS_INVALID_GROUP_TYPE, ERROR_DS_INVALID_GROUP_TYPE,

    STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN, ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN,

    STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN, ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN,

    STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER, ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER,

    STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER, ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER,

    STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER, ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER,

    STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER, ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER,

    STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER, ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER,

    STATUS_DS_HAVE_PRIMARY_MEMBERS, ERROR_DS_HAVE_PRIMARY_MEMBERS,

    STATUS_DS_GC_REQUIRED, ERROR_DS_GC_REQUIRED,

    STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY, ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY,

    STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS, ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS,

    STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED, ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED,

    STATUS_SAM_NEED_BOOTKEY_PASSWORD, ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD,

    STATUS_SAM_NEED_BOOTKEY_FLOPPY, ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY,

    STATUS_DS_INIT_FAILURE_CONSOLE, ERROR_DS_INIT_FAILURE_CONSOLE,

    STATUS_DS_SAM_INIT_FAILURE_CONSOLE, ERROR_DS_SAM_INIT_FAILURE_CONSOLE,

    STATUS_UNFINISHED_CONTEXT_DELETED, SEC_E_UNFINISHED_CONTEXT_DELETED,

    STATUS_NO_TGT_REPLY, SEC_E_NO_TGT_REPLY,

    STATUS_NO_IP_ADDRESSES, SEC_E_NO_IP_ADDRESSES,

    STATUS_WRONG_CREDENTIAL_HANDLE, SEC_E_WRONG_CREDENTIAL_HANDLE,

    STATUS_CRYPTO_SYSTEM_INVALID, SEC_E_CRYPTO_SYSTEM_INVALID,

    STATUS_MAX_REFERRALS_EXCEEDED, SEC_E_MAX_REFERRALS_EXCEEDED,

    STATUS_MUST_BE_KDC, SEC_E_MUST_BE_KDC,

    STATUS_STRONG_CRYPTO_NOT_SUPPORTED, SEC_E_STRONG_CRYPTO_NOT_SUPPORTED,

    STATUS_TOO_MANY_PRINCIPALS, SEC_E_TOO_MANY_PRINCIPALS,

    STATUS_NO_PA_DATA, SEC_E_NO_PA_DATA,

    STATUS_PKINIT_NAME_MISMATCH, SEC_E_PKINIT_NAME_MISMATCH,

    STATUS_SMARTCARD_LOGON_REQUIRED, SEC_E_SMARTCARD_LOGON_REQUIRED,

    STATUS_KDC_INVALID_REQUEST, SEC_E_KDC_INVALID_REQUEST,

    STATUS_KDC_UNABLE_TO_REFER, SEC_E_KDC_UNABLE_TO_REFER,

    STATUS_KDC_UNKNOWN_ETYPE, SEC_E_KDC_UNKNOWN_ETYPE,

    STATUS_UNSUPPORTED_PREAUTH, SEC_E_UNSUPPORTED_PREAUTH,

    STATUS_SHARED_POLICY,ERROR_SHARED_POLICY,

    STATUS_POLICY_OBJECT_NOT_FOUND,ERROR_POLICY_OBJECT_NOT_FOUND,

    STATUS_POLICY_ONLY_IN_DS,ERROR_POLICY_ONLY_IN_DS,

    STATUS_DEVICE_REMOVED,ERROR_DEVICE_REMOVED,

    STATUS_RETRY,ERROR_RETRY,

    STATUS_NOT_SUPPORTED_ON_SBS, ERROR_NOT_SUPPORTED_ON_SBS,

    STATUS_DRIVER_BLOCKED_CRITICAL, ERROR_DRIVER_BLOCKED,
    STATUS_DRIVER_BLOCKED, ERROR_DRIVER_BLOCKED,

    STATUS_PRENT4_MACHINE_ACCOUNT, ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4,

    STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER, ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER,

    STATUS_DS_SHUTTING_DOWN, ERROR_DS_SHUTTING_DOWN,

    STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT, ERROR_ACCESS_DISABLED_BY_POLICY,
    STATUS_ACCESS_DISABLED_BY_POLICY_PATH, ERROR_ACCESS_DISABLED_BY_POLICY,
    STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER, ERROR_ACCESS_DISABLED_BY_POLICY,
    STATUS_ACCESS_DISABLED_BY_POLICY_OTHER, ERROR_ACCESS_DISABLED_BY_POLICY,

    STATUS_FAIL_CHECK, ERROR_INVALID_PARAMETER,

    STATUS_PER_USER_TRUST_QUOTA_EXCEEDED,    ERROR_PER_USER_TRUST_QUOTA_EXCEEDED,
    STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED,    ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED,
    STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED, ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED,

    STATUS_DS_NAME_NOT_UNIQUE,              ERROR_DS_NAME_NOT_UNIQUE,
    STATUS_DS_DUPLICATE_ID_FOUND,           ERROR_DS_DUPLICATE_ID_FOUND,

    STATUS_DS_GROUP_CONVERSION_ERROR,       ERROR_DS_GROUP_CONVERSION_ERROR,
    STATUS_USER2USER_REQUIRED,              ERROR_LOGON_FAILURE,

    STATUS_STACK_BUFFER_OVERRUN,            ERROR_STACK_BUFFER_OVERRUN,

    STATUS_PARAMETER_QUOTA_EXCEEDED,        ERROR_PARAMETER_QUOTA_EXCEEDED,

    STATUS_AUTHENTICATION_FIREWALL_FAILED,  ERROR_AUTHENTICATION_FIREWALL_FAILED,

    STATUS_VDM_DISALLOWED,                  ERROR_VDM_DISALLOWED,

    // Terminal Server Entries

    STATUS_CTX_CLOSE_PENDING,               ERROR_CTX_CLOSE_PENDING,
    STATUS_CTX_NO_OUTBUF,                   ERROR_CTX_NO_OUTBUF,
    STATUS_CTX_MODEM_INF_NOT_FOUND,         ERROR_CTX_MODEM_INF_NOT_FOUND,
    STATUS_CTX_INVALID_MODEMNAME,           ERROR_CTX_INVALID_MODEMNAME,
    STATUS_CTX_RESPONSE_ERROR,              ERROR_CTX_MODEM_RESPONSE_ERROR,
    STATUS_CTX_MODEM_RESPONSE_TIMEOUT,      ERROR_CTX_MODEM_RESPONSE_TIMEOUT,
    STATUS_CTX_MODEM_RESPONSE_NO_CARRIER,   ERROR_CTX_MODEM_RESPONSE_NO_CARRIER,
    STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE,  ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE,
    STATUS_CTX_MODEM_RESPONSE_BUSY,         ERROR_CTX_MODEM_RESPONSE_BUSY,
    STATUS_CTX_MODEM_RESPONSE_VOICE,        ERROR_CTX_MODEM_RESPONSE_VOICE,
    STATUS_CTX_TD_ERROR,                    ERROR_CTX_TD_ERROR,
    STATUS_LPC_REPLY_LOST,                  ERROR_CONNECTION_ABORTED,
    STATUS_CTX_WINSTATION_NAME_INVALID,     ERROR_CTX_WINSTATION_NAME_INVALID,
    STATUS_CTX_WINSTATION_NOT_FOUND,        ERROR_CTX_WINSTATION_NOT_FOUND,
    STATUS_CTX_WINSTATION_NAME_COLLISION,   ERROR_CTX_WINSTATION_ALREADY_EXISTS,
    STATUS_CTX_WINSTATION_BUSY,             ERROR_CTX_WINSTATION_BUSY,
    STATUS_CTX_GRAPHICS_INVALID,            ERROR_CTX_GRAPHICS_INVALID,
    STATUS_CTX_BAD_VIDEO_MODE,              ERROR_CTX_BAD_VIDEO_MODE,
    STATUS_CTX_NOT_CONSOLE,                 ERROR_CTX_NOT_CONSOLE,
    STATUS_CTX_CLIENT_QUERY_TIMEOUT,        ERROR_CTX_CLIENT_QUERY_TIMEOUT,
    STATUS_CTX_CONSOLE_DISCONNECT,          ERROR_CTX_CONSOLE_DISCONNECT,
    STATUS_CTX_CONSOLE_CONNECT,             ERROR_CTX_CONSOLE_CONNECT,
    STATUS_CTX_SHADOW_DENIED,               ERROR_CTX_SHADOW_DENIED,
    STATUS_CTX_SHADOW_INVALID,              ERROR_CTX_SHADOW_INVALID,
    STATUS_CTX_SHADOW_DISABLED,             ERROR_CTX_SHADOW_DISABLED,
    STATUS_CTX_WINSTATION_ACCESS_DENIED,    ERROR_CTX_WINSTATION_ACCESS_DENIED,
    STATUS_CTX_INVALID_PD,                  ERROR_CTX_INVALID_PD,
    STATUS_CTX_PD_NOT_FOUND,                ERROR_CTX_PD_NOT_FOUND,
    STATUS_CTX_INVALID_WD,                  ERROR_CTX_INVALID_WD,
    STATUS_CTX_WD_NOT_FOUND,                ERROR_CTX_WD_NOT_FOUND,
    STATUS_CTX_CLIENT_LICENSE_IN_USE,       ERROR_CTX_CLIENT_LICENSE_IN_USE,
    STATUS_CTX_CLIENT_LICENSE_NOT_SET,      ERROR_CTX_CLIENT_LICENSE_NOT_SET,
    STATUS_CTX_LICENSE_NOT_AVAILABLE,       ERROR_CTX_LICENSE_NOT_AVAILABLE,
    STATUS_CTX_LICENSE_CLIENT_INVALID,      ERROR_CTX_LICENSE_CLIENT_INVALID,
    STATUS_CTX_LICENSE_EXPIRED,             ERROR_CTX_LICENSE_EXPIRED,
    STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE, ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE,
    STATUS_CTX_SHADOW_NOT_RUNNING,          ERROR_CTX_SHADOW_NOT_RUNNING,
    STATUS_LICENSE_VIOLATION,               ERROR_CTX_LICENSE_NOT_AVAILABLE,


    // Smb Server Entries

    STATUS_ENDPOINT_CLOSED,                 ERROR_DEV_NOT_EXIST,
    STATUS_DISCONNECTED,                    ERROR_DEV_NOT_EXIST,
    STATUS_NONEXISTENT_NET_NAME,            ERROR_DEV_NOT_EXIST,
    STATUS_NETWORK_SESSION_EXPIRED,         ERROR_NO_USER_SESSION_KEY,

    STATUS_FILES_OPEN,                      ERROR_OPEN_FILES,

    STATUS_SXS_SECTION_NOT_FOUND,           ERROR_SXS_SECTION_NOT_FOUND,
    STATUS_SXS_CANT_GEN_ACTCTX,             ERROR_SXS_CANT_GEN_ACTCTX,
    STATUS_SXS_INVALID_ACTCTXDATA_FORMAT,   ERROR_SXS_INVALID_ACTCTXDATA_FORMAT,
    STATUS_SXS_ASSEMBLY_NOT_FOUND,          ERROR_SXS_ASSEMBLY_NOT_FOUND,
    STATUS_SXS_MANIFEST_FORMAT_ERROR,       ERROR_SXS_MANIFEST_FORMAT_ERROR,
    STATUS_SXS_MANIFEST_PARSE_ERROR,        ERROR_SXS_MANIFEST_PARSE_ERROR,
    STATUS_SXS_ACTIVATION_CONTEXT_DISABLED, ERROR_SXS_ACTIVATION_CONTEXT_DISABLED,
    STATUS_SXS_KEY_NOT_FOUND,               ERROR_SXS_KEY_NOT_FOUND,
    STATUS_SXS_WRONG_SECTION_TYPE,          ERROR_SXS_WRONG_SECTION_TYPE,
    STATUS_SXS_THREAD_QUERIES_DISABLED,     ERROR_SXS_THREAD_QUERIES_DISABLED,
    STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET, ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET,

    STATUS_REDIRECTOR_STARTED,              ERROR_SERVICE_ALREADY_RUNNING,
    STATUS_AUDITING_DISABLED,               ERROR_AUDITING_DISABLED,

    // Cluster Entries
    STATUS_CLUSTER_NODE_ALREADY_UP,         ERROR_CLUSTER_NODE_ALREADY_UP,
    STATUS_CLUSTER_NODE_ALREADY_DOWN,       ERROR_CLUSTER_NODE_ALREADY_DOWN,
    STATUS_CLUSTER_NETWORK_ALREADY_ONLINE,  ERROR_CLUSTER_NETWORK_ALREADY_ONLINE,
    STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE, ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE,
    STATUS_CLUSTER_NODE_ALREADY_MEMBER,     ERROR_CLUSTER_NODE_ALREADY_MEMBER,

    STATUS_CLUSTER_INVALID_NODE,            ERROR_CLUSTER_INVALID_NODE,
    STATUS_CLUSTER_NODE_EXISTS,             ERROR_CLUSTER_NODE_EXISTS,
    STATUS_CLUSTER_JOIN_IN_PROGRESS,        ERROR_CLUSTER_JOIN_IN_PROGRESS,
    STATUS_CLUSTER_NODE_NOT_FOUND,          ERROR_CLUSTER_NODE_NOT_FOUND,
    STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND,    ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND,
    STATUS_CLUSTER_NETWORK_EXISTS,          ERROR_CLUSTER_NETWORK_EXISTS,
    STATUS_CLUSTER_NETWORK_NOT_FOUND,       ERROR_CLUSTER_NETWORK_NOT_FOUND,
    STATUS_CLUSTER_NETINTERFACE_EXISTS,     ERROR_CLUSTER_NETINTERFACE_EXISTS,
    STATUS_CLUSTER_NETINTERFACE_NOT_FOUND,  ERROR_CLUSTER_NETINTERFACE_NOT_FOUND,
    STATUS_CLUSTER_INVALID_REQUEST,         ERROR_CLUSTER_INVALID_REQUEST,
    STATUS_CLUSTER_INVALID_NETWORK_PROVIDER,ERROR_CLUSTER_INVALID_NETWORK_PROVIDER,
    STATUS_CLUSTER_NODE_DOWN,               ERROR_CLUSTER_NODE_DOWN,
    STATUS_CLUSTER_NODE_UNREACHABLE,        ERROR_CLUSTER_NODE_UNREACHABLE,
    STATUS_CLUSTER_NODE_NOT_MEMBER,         ERROR_CLUSTER_NODE_NOT_MEMBER,
    STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS,    ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS,
    STATUS_CLUSTER_INVALID_NETWORK,         ERROR_CLUSTER_INVALID_NETWORK,
    STATUS_CLUSTER_NODE_UP,                 ERROR_CLUSTER_NODE_UP,
    STATUS_CLUSTER_NODE_PAUSED,             ERROR_CLUSTER_NODE_PAUSED,
    STATUS_CLUSTER_NODE_NOT_PAUSED,         ERROR_CLUSTER_NODE_NOT_PAUSED,
    STATUS_CLUSTER_NO_SECURITY_CONTEXT,     ERROR_CLUSTER_NO_SECURITY_CONTEXT,
    STATUS_CLUSTER_NETWORK_NOT_INTERNAL,    ERROR_CLUSTER_NETWORK_NOT_INTERNAL,

    //
    // Common log file system error messages.
    //

    STATUS_LOG_SECTOR_INVALID,              ERROR_LOG_SECTOR_INVALID,
    STATUS_LOG_SECTOR_PARITY_INVALID,       ERROR_LOG_SECTOR_PARITY_INVALID,
    STATUS_LOG_SECTOR_REMAPPED,             ERROR_LOG_SECTOR_REMAPPED,
    STATUS_LOG_BLOCK_INCOMPLETE,            ERROR_LOG_BLOCK_INCOMPLETE,
    STATUS_LOG_INVALID_RANGE,               ERROR_LOG_INVALID_RANGE,
    STATUS_LOG_BLOCKS_EXHAUSTED,            ERROR_LOG_BLOCKS_EXHAUSTED,
    STATUS_LOG_READ_CONTEXT_INVALID,        ERROR_LOG_READ_CONTEXT_INVALID,
    STATUS_LOG_RESTART_INVALID,             ERROR_LOG_RESTART_INVALID,
    STATUS_LOG_BLOCK_VERSION,               ERROR_LOG_BLOCK_VERSION,
    STATUS_LOG_BLOCK_INVALID,               ERROR_LOG_BLOCK_INVALID,
    STATUS_LOG_READ_MODE_INVALID,           ERROR_LOG_READ_MODE_INVALID,
    STATUS_LOG_NO_RESTART,                  ERROR_LOG_NO_RESTART,
    STATUS_LOG_METADATA_CORRUPT,            ERROR_LOG_METADATA_CORRUPT,
    STATUS_LOG_METADATA_INVALID,            ERROR_LOG_METADATA_INVALID,
    STATUS_LOG_METADATA_INCONSISTENT,       ERROR_LOG_METADATA_INCONSISTENT,
    STATUS_LOG_RESERVATION_INVALID,         ERROR_LOG_RESERVATION_INVALID,
    STATUS_LOG_CANT_DELETE,                 ERROR_LOG_CANT_DELETE,
    STATUS_LOG_CONTAINER_LIMIT_EXCEEDED,    ERROR_LOG_CONTAINER_LIMIT_EXCEEDED,
    STATUS_LOG_START_OF_LOG,                ERROR_LOG_START_OF_LOG,
    STATUS_LOG_POLICY_ALREADY_INSTALLED,    ERROR_LOG_POLICY_ALREADY_INSTALLED,
    STATUS_LOG_POLICY_NOT_INSTALLED,        ERROR_LOG_POLICY_NOT_INSTALLED,
    STATUS_LOG_POLICY_INVALID,              ERROR_LOG_POLICY_INVALID,
    STATUS_LOG_POLICY_CONFLICT,             ERROR_LOG_POLICY_CONFLICT,
    STATUS_LOG_PINNED_ARCHIVE_TAIL,         ERROR_LOG_PINNED_ARCHIVE_TAIL,
    STATUS_LOG_RECORD_NONEXISTENT,          ERROR_LOG_RECORD_NONEXISTENT,
    STATUS_LOG_RECORDS_RESERVED_INVALID,    ERROR_LOG_RECORDS_RESERVED_INVALID,
    STATUS_LOG_SPACE_RESERVED_INVALID,      ERROR_LOG_SPACE_RESERVED_INVALID,
    STATUS_LOG_TAIL_INVALID,                ERROR_LOG_TAIL_INVALID,
    STATUS_LOG_FULL,                        ERROR_LOG_FULL,
    STATUS_LOG_MULTIPLEXED,                 ERROR_LOG_MULTIPLEXED,
    STATUS_COULD_NOT_RESIZE_LOG,            ERROR_COULD_NOT_RESIZE_LOG,
    STATUS_LOG_DEDICATED,                   ERROR_LOG_DEDICATED,
    STATUS_LOG_ARCHIVE_NOT_IN_PROGRESS,     ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS,
    STATUS_LOG_ARCHIVE_IN_PROGRESS,         ERROR_LOG_ARCHIVE_IN_PROGRESS,
    STATUS_LOG_EPHEMERAL,                   ERROR_LOG_EPHEMERAL,
    STATUS_LOG_NOT_ENOUGH_CONTAINERS,       ERROR_LOG_NOT_ENOUGH_CONTAINERS,
    STATUS_LOG_CLIENT_ALREADY_REGISTERED,   ERROR_LOG_CLIENT_ALREADY_REGISTERED,
    STATUS_LOG_CLIENT_NOT_REGISTERED,       ERROR_LOG_CLIENT_NOT_REGISTERED,
    STATUS_LOG_FULL_HANDLER_IN_PROGRESS,    ERROR_LOG_FULL_HANDLER_IN_PROGRESS,
    STATUS_LOG_CONTAINER_READ_FAILED,       ERROR_LOG_CONTAINER_READ_FAILED,
    STATUS_LOG_CONTAINER_WRITE_FAILED,      ERROR_LOG_CONTAINER_WRITE_FAILED,
    STATUS_LOG_CONTAINER_OPEN_FAILED,       ERROR_LOG_CONTAINER_OPEN_FAILED,
    STATUS_LOG_CONTAINER_STATE_INVALID,     ERROR_LOG_CONTAINER_STATE_INVALID,
    STATUS_LOG_STATE_INVALID,               ERROR_LOG_STATE_INVALID,
    STATUS_LOG_PINNED,                      ERROR_LOG_PINNED,
    STATUS_LOG_METADATA_FLUSH_FAILED,       ERROR_LOG_METADATA_FLUSH_FAILED,
    STATUS_LOG_INCONSISTENT_SECURITY,       ERROR_LOG_INCONSISTENT_SECURITY,
  
    //
    // The debugger closed the last handle to a debug object.
    //

    STATUS_DEBUGGER_INACTIVE,               ERROR_DEBUGGER_INACTIVE,

    0xffffffff, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\intbits.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    intbits.c

Abstract:

    This module contains routines to do interlocked bit manipulation

--*/

#include "ntrtlp.h"
#pragma hdrstop

ULONG
FASTCALL
RtlInterlockedSetClearBits (
    IN OUT PULONG Flags,
    IN ULONG sFlag,
    IN ULONG cFlag
    )

/*++

Routine Description:

    This function atomically sets and clears the specified flags in the target

Arguments:

    Flags - Pointer to variable containing current mask.

    sFlag  - Flags to set in target

    CFlag  - Flags to clear in target

Return Value:

    ULONG - Old value of mask before modification

--*/

{

    ULONG NewFlags, OldFlags;

    OldFlags = *Flags;
    NewFlags = (OldFlags | sFlag) & ~cFlag;
    while (NewFlags != OldFlags) {
        NewFlags = InterlockedCompareExchange ((PLONG) Flags, (LONG) NewFlags, (LONG) OldFlags);
        if (NewFlags == OldFlags) {
            break;
        }

        OldFlags = NewFlags;
        NewFlags = (NewFlags | sFlag) & ~cFlag;
    }

    return OldFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\error.h ===
//
// Define run length table entry structure type.
//

typedef struct _RUN_ENTRY {
    ULONG BaseCode;
    USHORT RunLength;
    USHORT CodeSize;
} RUN_ENTRY, *PRUN_ENTRY;

//
// Declare translation table array.
//

CONST USHORT RtlpStatusTable[] = {
    0x0000, 0x03e5, 0x00ea, 0x0514, 0x0515, 0x03fe, 0x0516, 
    0x2009, 0x0057, 0x0517, 0x0460, 0x03f6, 0x0461, 0x0518, 
    0x20ac, 0x0720, 0x0779, 0x19d3, 0x0001, 0x8000, 0x03e6, 0x0000, 
    0x0003, 0x8000, 0x0004, 0x8000, 0x00ea, 0x0000, 0x0012, 0x0000, 
    0x056f, 0x012b, 0x001c, 0x0015, 0x0015, 0x00aa, 0x0103, 
    0x00fe, 0x00ff, 0x00ff, 0x0456, 0x0103, 0x044d, 0x0456, 
    0x0457, 0x044c, 0x044e, 0x044f, 0x0450, 0x0962, 0x10f4, 
    0x048d, 0x048e, 0x05aa, 0x0006, 0x0001, 0x0035, 0x054f, 
    0x0554, 0x0120, 0x0554, 0x0057, 0x0057, 0x0032, 0x0558, 
    0x052e, 0x0057, 0x0520, 0x0005, 0x0005, 0x051f, 0x0554, 
    0x078b, 0x06f8, 0x0057, 0x007a, 0x0574, 0x06fe, 0x0057, 
    0x0057, 0x0532, 0x1770, 0x1771, 0x0001, 0x0558, 0x0545, 
    0x0575, 0x0575, 0x0575, 0x0575, 0x13c5, 0x13c6, 0x13c7, 
    0x13c8, 0x13c9, 0x19e5, 0x001f, 0x0001, 0x0057, 0x0018, 
    0x03e6, 0x03e7, 0x05ae, 0x0006, 0x03e9, 0x00c1, 0x0057, 
    0x0057, 0x0000, 0x0002, 0x0000, 0x0002, 0x0000, 0x0001, 0x0000, 
    0x0026, 0x0000, 0x0022, 0x0000, 0x0015, 0x0000, 0x06f9, 0x0000, 
    0x001b, 0x0000, 0x00ea, 0x0000, 0x0008, 0x0000, 0x01e7, 0x0000, 
    0x01e7, 0x0000, 0x0057, 0x0000, 0x0057, 0x0000, 0x0001, 0x0000, 
    0x001d, 0xc000, 0x0005, 0x0000, 0x0005, 0x0000, 0x00c1, 0x0000, 
    0x0005, 0x0000, 0x0005, 0x0000, 0x007a, 0x0000, 0x0006, 0x0000, 
    0x0025, 0xc000, 0x0026, 0xc000, 0x009e, 0x0000, 0x002b, 0xc000, 
    0x01e7, 0x0000, 0x01e7, 0x0000, 0x0057, 0x0571, 0x007b, 
    0x0002, 0x00b7, 0x0006, 0x00a1, 0x0000, 0x0003, 0x0000, 
    0x00a1, 0x0000, 0x045d, 0x0000, 0x045d, 0x0000, 0x0017, 0x0000, 
    0x0017, 0x0000, 0x0008, 0x0000, 0x0005, 0x0000, 0x0006, 0x0000, 
    0x0020, 0x0000, 0x0718, 0x0000, 0x0057, 0x0000, 0x0120, 0x0000, 
    0x012a, 0x0000, 0x0057, 0x0000, 0x0057, 0x0000, 0x009c, 0x0000, 
    0x0005, 0x0000, 0x0057, 0x0000, 0x0057, 0x0000, 0x0057, 0x0000, 
    0x011a, 0x0000, 0x00ff, 0x0000, 0x0570, 0x0000, 0x0570, 0x0000, 
    0x0570, 0x0000, 0x0021, 0x0000, 0x0021, 0x0000, 0x0005, 0x0000, 
    0x0032, 0x0000, 0x0519, 0x0000, 0x051a, 0x0000, 0x051b, 0x0000, 
    0x051c, 0x0000, 0x051d, 0x0000, 0x051e, 0x0000, 0x051f, 0x0000, 
    0x0520, 0x0000, 0x0521, 0x0000, 0x0522, 0x0000, 0x0523, 0x0000, 
    0x0524, 0x0000, 0x0525, 0x0000, 0x0526, 0x0000, 0x0527, 0x0000, 
    0x0528, 0x0000, 0x0529, 0x0000, 0x052a, 0x0000, 0x0056, 0x0000, 
    0x052c, 0x0000, 0x052d, 0x0000, 0x052e, 0x0000, 0x052f, 0x0000, 
    0x0530, 0x0000, 0x0531, 0x0000, 0x0532, 0x0000, 0x0533, 0x0000, 
    0x0534, 0x0000, 0x0535, 0x0000, 0x0536, 0x0000, 0x0537, 0x0000, 
    0x0538, 0x0000, 0x0539, 0x0000, 0x053a, 0x0000, 0x007f, 0x0000, 
    0x00c1, 0x0000, 0x03f0, 0x0000, 0x053c, 0x0000, 0x009e, 0x0000, 
    0x0070, 0x0000, 0x053d, 0x0000, 0x053e, 0x0000, 0x0044, 0x0000, 
    0x0103, 0x0000, 0x053f, 0x0000, 0x0103, 0x0000, 0x009a, 0x0000, 
    0x000e, 0x0000, 0x01e7, 0x0000, 0x0714, 0x0000, 0x0715, 0x0000, 
    0x0716, 0x0000, 0x008c, 0xc000, 0x008d, 0xc000, 0x008e, 0xc000, 
    0x008f, 0xc000, 0x0090, 0xc000, 0x0091, 0xc000, 0x0092, 0xc000, 
    0x0093, 0xc000, 0x0094, 0xc000, 0x0216, 0x0000, 0x0096, 0xc000, 
    0x0008, 0x0000, 0x03ee, 0x0000, 0x0540, 0x0000, 0x05aa, 0x0000, 
    0x0003, 0x0000, 0x0017, 0x0000, 0x048f, 0x0000, 0x0015, 0x0000, 
    0x01e7, 0x0000, 0x01e7, 0x0000, 0x05ad, 0x0000, 0x0013, 0x0000, 
    0x0015, 0x0000, 0x0541, 0x0000, 0x0542, 0x0000, 0x0543, 0x0000, 
    0x0544, 0x0000, 0x0545, 0x0000, 0x0057, 0x0000, 0x00e7, 
    0x00e7, 0x00e6, 0x00e7, 0x0001, 0x00e9, 0x00e8, 0x0217, 
    0x0218, 0x00e6, 0x0079, 0x0026, 0x0005, 0x0032, 0x0033, 
    0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 
    0x003b, 0x003c, 0x003d, 0x003e, 0x003f, 0x0040, 0x0041, 
    0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 
    0x0058, 0x0011, 0x0005, 0x00f0, 0x0546, 0x00e8, 0x0547, 
    0x0548, 0x0549, 0x054a, 0x054b, 0x054c, 0x054d, 0x012c, 
    0x012d, 0x054e, 0x054f, 0x0550, 0x0551, 0x06f8, 0x045d, 
    0x0552, 0x0553, 0x0057, 0x0057, 0x0057, 0x0057, 0x0057, 
    0x0057, 0x0057, 0x0057, 0x0057, 0x0057, 0x0057, 0x0057, 
    0x0003, 0x0420, 0x03e9, 0x0554, 0x00cb, 0x0091, 0x0570, 
    0x010b, 0x0555, 0x0556, 0x00ce, 0x0961, 0x0964, 0x013d, 
    0x0005, 0x0557, 0x0558, 0x0420, 0x05a4, 0x00c1, 0x0559, 
    0x055a, 0x03ee, 0x0004, 0x03e3, 0x0005, 0x04ba, 0x0005, 
    0x055b, 0x055c, 0x055d, 0x055e, 0x0006, 0x055f, 0x05af, 
    0x00c1, 0x00c1, 0x00c1, 0x00c1, 0x0576, 0x007e, 0x00b6, 
    0x007f, 0x0040, 0x0040, 0x0033, 0x003b, 0x003b, 0x003b, 
    0x003b, 0x045a, 0x007c, 0x0056, 0x006d, 0x03f1, 0x03f8, 
    0x03ed, 0x045e, 0x0560, 0x0561, 0x0562, 0x0563, 0x0564, 
    0x0565, 0x0566, 0x0567, 0x03ef, 0x0568, 0x0569, 0x03f9, 
    0x056a, 0x045d, 0x04db, 0x0459, 0x0462, 0x0463, 0x0464, 
    0x0465, 0x0466, 0x0467, 0x0468, 0x045f, 0x045d, 0x0451, 
    0x0452, 0x0453, 0x0454, 0x0455, 0x0469, 0x0458, 0x056b, 
    0x056c, 0x03fa, 0x03fb, 0x056d, 0x056e, 0x03fc, 0x03fd, 
    0x0057, 0x045d, 0x0016, 0x045d, 0x045d, 0x05de, 0x0013, 
    0x06fa, 0x06fb, 0x06fc, 0x06fd, 0x05dc, 0x05dd, 0x06fe, 
    0x0700, 0x0701, 0x046b, 0x04c3, 0x04c4, 0x05df, 0x070f, 
    0x0710, 0x0711, 0x0712, 0x0572, 0x003b, 0x003b, 0x0717, 
    0x046a, 0x06f8, 0x04be, 0x04be, 0x0044, 0x0034, 0x0040, 
    0x0040, 0x0040, 0x0044, 0x003b, 0x003b, 0x003b, 0x003b, 
    0x003b, 0x003b, 0x003b, 0x0032, 0x0032, 0x17e6, 0x046c, 
    0x00c1, 0x0773, 0x0490, 0x04ff, 0x0057, 0x0000, 0x022a, 0xc000, 
    0x022b, 0xc000, 0x04d5, 0x0492, 0x0774, 0x0775, 0x0006, 
    0x04c9, 0x04ca, 0x04cb, 0x04cc, 0x04cd, 0x04ce, 0x04cf, 
    0x04d0, 0x04d1, 0x04d2, 0x04d3, 0x04d4, 0x04c8, 0x04d6, 
    0x04d7, 0x04d8, 0x00c1, 0x04d4, 0x054f, 0x04d0, 0x0573, 
    0x0422, 0x00b6, 0x007f, 0x0120, 0x0476, 0x10fe, 0x1b8e, 
    0x07d1, 0x04b1, 0x0015, 0x0491, 0x1126, 0x1129, 0x112a, 
    0x1128, 0x0780, 0x0781, 0x00a1, 0x0488, 0x0489, 0x048a, 
    0x048b, 0x048c, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 
    0x0005, 0x1777, 0x1778, 0x1772, 0x1068, 0x1069, 0x106a, 
    0x106b, 0x201a, 0x201b, 0x201c, 0x0001, 0x10ff, 0x1100, 
    0x0494, 0x200a, 0x200b, 0x200c, 0x200d, 0x200e, 0x200f, 
    0x2010, 0x2011, 0x2012, 0x2013, 0x2014, 0x2015, 0x2016, 
    0x2017, 0x2018, 0x2019, 0x211e, 0x1127, 0x0651, 0x049a, 
    0x049b, 0x2024, 0x0575, 0x03e6, 0x1075, 0x1076, 0x04ed, 
    0x10e8, 0x2138, 0x04e3, 0x2139, 0x049d, 0x213a, 0x2141, 
    0x2142, 0x2143, 0x2144, 0x2145, 0x2146, 0x2147, 0x2148, 
    0x2149, 0x0032, 0x2151, 0x2152, 0x2153, 0x2154, 0x215d, 
    0x2163, 0x2164, 0x2165, 0x216d, 0x0577, 0x0052, 0x2171, 0x0000, 
    0x2172, 0x0000, 0x0333, 0x8009, 0x0334, 0x8009, 0x0002, 0x0000, 
    0x0335, 0x8009, 0x0336, 0x8009, 0x0337, 0x8009, 0x0338, 0x8009, 
    0x0339, 0x8009, 0x033a, 0x8009, 0x033b, 0x8009, 0x033c, 0x8009, 
    0x033d, 0x8009, 0x033e, 0x8009, 0x0340, 0x8009, 0x0341, 0x8009, 
    0x0342, 0x8009, 0x045b, 0x0000, 0x04e7, 0x0000, 0x04e6, 0x0000, 
    0x106f, 0x0000, 0x1074, 0x0000, 0x106e, 0x0000, 0x012e, 0x0000, 
    0x0305, 0x8003, 0x0306, 0x8003, 0x0307, 0x8003, 0x0308, 0x8003, 
    0x0309, 0x8003, 0x030a, 0x8003, 0x030b, 0x8003, 0x04ef, 0x0000, 
    0x04f0, 0x0000, 0x0348, 0x8009, 0x04e8, 0x0000, 0x0343, 0x8009, 
    0x177d, 0x0000, 0x0504, 0x0001, 0xc009, 0x217c, 0x0000, 
    0x2182, 0x0000, 0x00c1, 0x0000, 0x00c1, 0x0000, 0x0346, 0x8009, 
    0x0572, 0x0000, 0x04ec, 0x04ec, 0x04ec, 0x04ec, 0x04fb, 
    0x04fb, 0x04fc, 0x006b, 0x8010, 0x006c, 0x8010, 0x006f, 0x8010, 
    0x000c, 0x8010, 0x000d, 0x8009, 0x002c, 0x8010, 0x0016, 0x8009, 
    0x002f, 0x8010, 0x04f1, 0x0000, 0x0351, 0x8009, 0x0352, 0x8009, 
    0x0353, 0x8009, 0x0354, 0x8009, 0x0355, 0x8009, 0x0022, 0x8009, 
    0x078c, 0x078d, 0x078e, 0x217b, 0x219d, 0x219f, 0x052e, 0x0000, 
    0x0502, 0x0000, 0x0356, 0x8009, 0x0357, 0x8009, 0x0358, 0x8009, 
    0x0359, 0x8009, 0x035a, 0x8009, 0x035b, 0x8009, 0x0503, 0x0000, 
    0x0505, 0x078f, 0x0506, 0x06a4, 0x06a5, 0x0006, 0x06a7, 
    0x06a8, 0x06a9, 0x06aa, 0x06ab, 0x06ac, 0x06ad, 0x06ae, 
    0x06af, 0x06b0, 0x06b1, 0x06b2, 0x06b3, 0x06b4, 0x06b5, 
    0x06b6, 0x06b7, 0x06b8, 0x06b9, 0x06ba, 0x06bb, 0x06bc, 
    0x06bd, 0x06be, 0x06bf, 0x06c0, 0x06c2, 0x06c4, 0x06c5, 
    0x06c6, 0x06c7, 0x06c8, 0x06c9, 0x06cb, 0x06cc, 0x06cd, 
    0x06ce, 0x06cf, 0x06d0, 0x06d1, 0x06d2, 0x06d3, 0x06d4, 
    0x06d5, 0x06d6, 0x06d7, 0x06d8, 0x06d9, 0x06da, 0x06db, 
    0x06dc, 0x06dd, 0x06de, 0x06df, 0x06e0, 0x06e1, 0x06e2, 
    0x06e3, 0x06e4, 0x06e5, 0x06e6, 0x06e7, 0x06e8, 0x06e9, 
    0x06ea, 0x06eb, 0x06ff, 0x070e, 0x076a, 0x076b, 0x076c, 
    0x0719, 0x071a, 0x071b, 0x071c, 0x071d, 0x071e, 0x071f, 
    0x0721, 0x0722, 0x077a, 0x077b, 0x06ec, 0x06ed, 0x06ee, 
    0x0006, 0x0006, 0x06f1, 0x06f2, 0x06f3, 0x06f4, 0x06f5, 
    0x06f6, 0x06f7, 0x0723, 0x0724, 0x0725, 0x0726, 0x0727, 
    0x0728, 0x077c, 0x077d, 0x077e, 0x1b59, 0x1b5a, 0x1b5b, 
    0x1b5f, 0x1b60, 0x1b61, 0x1b62, 0x1b63, 0x1b64, 0x1b65, 
    0x1b66, 0x1b67, 0x1b68, 0x1b69, 0x1b8f, 0x1b8e, 0x1b90, 
    0x1b6e, 0x1b6f, 0x1b70, 0x1b71, 0x1b7b, 0x1b7e, 0x1b80, 
    0x1b81, 0x1b82, 0x1b84, 0x1b85, 0x1b89, 0x1b5c, 0x1b8a, 
    0x1b8b, 0x1b8d, 0x1b8c, 0x1b92, 0x1b91, 0x13af, 0x13b0, 
    0x13b1, 0x13b2, 0x13b3, 0x13b4, 0x13b5, 0x13b6, 0x13b7, 
    0x13b8, 0x13b9, 0x13ba, 0x13bb, 0x13bc, 0x13bd, 0x13be, 
    0x13c0, 0x13ce, 0x13c2, 0x13c3, 0x13c4, 0x36b0, 0x36b1, 
    0x36b2, 0x36b3, 0x36b4, 0x36b5, 0x36b6, 0x36b7, 0x36b9, 
    0x36ba, 0x36bb, 0x19c8, 0x19c9, 0x19ca, 0x19cb, 0x19cc, 
    0x19cd, 0x19ce, 0x19cf, 0x19d0, 0x19d1, 0x19d2, 0x19d4, 
    0x19d5, 0x19d6, 0x19d7, 0x19d8, 0x19d9, 0x19da, 0x19db, 
    0x19dc, 0x19dd, 0x19de, 0x19df, 0x19e0, 0x19e1, 0x19e2, 
    0x19e3, 0x19e4, 0x19e6, 0x19e7, 0x19e8, 0x19e9, 0x19ea, 
    0x19eb, 0x19ec, 0x19ed, 0x19ee, 0x19ef, 0x19f0, 0x19f1, 
    0x19f2, 0x19f3, 0x19f4, 0x19f5, 0x19f6, 0x0037, 0x0037, 
    0x0037, 0x0000, 0x0};

//
// Declare run length table array.
//

CONST RUN_ENTRY RtlpRunTable[] = {
    {0x00000000, 0x0001, 0x0001},
    {0x00000103, 0x0001, 0x0001},
    {0x00000105, 0x0003, 0x0001},
    {0x0000010c, 0x0002, 0x0001},
    {0x00000121, 0x0001, 0x0001},
    {0x40000002, 0x0001, 0x0001},
    {0x40000006, 0x0001, 0x0001},
    {0x40000008, 0x0002, 0x0001},
    {0x4000000c, 0x0002, 0x0001},
    {0x40000370, 0x0001, 0x0001},
    {0x40020056, 0x0001, 0x0001},
    {0x400200af, 0x0001, 0x0001},
    {0x401a000c, 0x0001, 0x0001},
    {0x80000001, 0x0006, 0x0002},
    {0x8000000b, 0x0001, 0x0001},
    {0x8000000d, 0x000a, 0x0001},
    {0x8000001a, 0x0006, 0x0001},
    {0x80000021, 0x0002, 0x0001},
    {0x80000025, 0x0001, 0x0001},
    {0x80000027, 0x0001, 0x0001},
    {0x80000288, 0x0002, 0x0001},
    {0x80090300, 0x0012, 0x0001},
    {0x80090316, 0x0003, 0x0001},
    {0x80090320, 0x0003, 0x0001},
    {0x80090325, 0x0005, 0x0001},
    {0x80090330, 0x0002, 0x0001},
    {0x80090347, 0x0001, 0x0001},
    {0x80090349, 0x0001, 0x0001},
    {0x80092010, 0x0001, 0x0001},
    {0x80092012, 0x0002, 0x0001},
    {0x80096004, 0x0001, 0x0001},
    {0x80130001, 0x0005, 0x0001},
    {0x80190009, 0x0001, 0x0001},
    {0xc0000001, 0x000b, 0x0001},
    {0xc000000d, 0x001a, 0x0002},
    {0xc000002a, 0x0004, 0x0002},
    {0xc0000030, 0x0001, 0x0001},
    {0xc0000032, 0x0004, 0x0001},
    {0xc0000037, 0x0001, 0x0001},
    {0xc0000039, 0x0071, 0x0002},
    {0xc00000ab, 0x000c, 0x0001},
    {0xc00000ba, 0x0019, 0x0001},
    {0xc00000d4, 0x0004, 0x0001},
    {0xc00000d9, 0x0002, 0x0001},
    {0xc00000dc, 0x000e, 0x0001},
    {0xc00000ed, 0x0012, 0x0001},
    {0xc0000100, 0x000c, 0x0001},
    {0xc000010d, 0x0002, 0x0001},
    {0xc0000117, 0x0001, 0x0001},
    {0xc000011b, 0x000e, 0x0001},
    {0xc000012b, 0x0001, 0x0001},
    {0xc000012d, 0x0005, 0x0001},
    {0xc0000133, 0x0001, 0x0001},
    {0xc0000135, 0x0001, 0x0001},
    {0xc0000138, 0x0002, 0x0001},
    {0xc000013b, 0x0008, 0x0001},
    {0xc0000148, 0x0002, 0x0001},
    {0xc000014b, 0x0003, 0x0001},
    {0xc000014f, 0x000f, 0x0001},
    {0xc000015f, 0x0002, 0x0001},
    {0xc0000162, 0x0001, 0x0001},
    {0xc0000165, 0x0009, 0x0001},
    {0xc0000172, 0x0007, 0x0001},
    {0xc000017a, 0x000d, 0x0001},
    {0xc0000188, 0x0009, 0x0001},
    {0xc0000192, 0x000a, 0x0001},
    {0xc0000202, 0x0002, 0x0001},
    {0xc0000203, 0x0015, 0x0001},
    {0xc000021c, 0x0001, 0x0001},
    {0xc0000220, 0x0002, 0x0001},
    {0xc0000224, 0x0002, 0x0001},
    {0xc0000227, 0x0001, 0x0001},
    {0xc0000229, 0x0003, 0x0002},
    {0xc000022d, 0x0001, 0x0001},
    {0xc0000230, 0x0001, 0x0001},
    {0xc0000233, 0x000f, 0x0001},
    {0xc0000243, 0x0001, 0x0001},
    {0xc0000246, 0x0004, 0x0001},
    {0xc0000253, 0x0001, 0x0001},
    {0xc0000253, 0x0001, 0x0001},
    {0xc0000257, 0x0001, 0x0001},
    {0xc0000259, 0x0001, 0x0001},
    {0xc000025e, 0x0001, 0x0001},
    {0xc0000262, 0x0004, 0x0001},
    {0xc0000267, 0x0001, 0x0001},
    {0xc000026a, 0x0001, 0x0001},
    {0xc000026c, 0x0003, 0x0001},
    {0xc0000272, 0x0001, 0x0001},
    {0xc0000275, 0x0005, 0x0001},
    {0xc0000280, 0x0002, 0x0001},
    {0xc0000283, 0x0005, 0x0001},
    {0xc000028a, 0x0002, 0x0001},
    {0xc000028d, 0x0007, 0x0001},
    {0xc0000295, 0x000b, 0x0001},
    {0xc00002a1, 0x0012, 0x0001},
    {0xc00002b6, 0x0003, 0x0001},
    {0xc00002c1, 0x0001, 0x0001},
    {0xc00002c3, 0x0001, 0x0001},
    {0xc00002c5, 0x0003, 0x0001},
    {0xc00002c9, 0x0005, 0x0001},
    {0xc00002cf, 0x0002, 0x0001},
    {0xc00002d4, 0x000a, 0x0001},
    {0xc00002df, 0x0009, 0x0001},
    {0xc00002e9, 0x0002, 0x0001},
    {0xc00002ec, 0x0020, 0x0002},
    {0xc0000320, 0x0003, 0x0002},
    {0xc0000350, 0x0003, 0x0002},
    {0xc0000354, 0x0001, 0x0001},
    {0xc0000356, 0x0007, 0x0002},
    {0xc0000361, 0x0004, 0x0001},
    {0xc000036b, 0x0002, 0x0001},
    {0xc000036f, 0x0001, 0x0001},
    {0xc0000380, 0x000e, 0x0002},
    {0xc000038f, 0x0001, 0x0002},
    {0xc0000401, 0x0006, 0x0001},
    {0xc0000408, 0x0009, 0x0002},
    {0xc0000412, 0x0003, 0x0001},
    {0xc0020001, 0x001d, 0x0001},
    {0xc002001f, 0x0001, 0x0001},
    {0xc0020021, 0x0006, 0x0001},
    {0xc0020028, 0x0026, 0x0001},
    {0xc002004f, 0x0007, 0x0001},
    {0xc0020057, 0x0002, 0x0001},
    {0xc0020062, 0x0002, 0x0001},
    {0xc0030001, 0x000c, 0x0001},
    {0xc0030059, 0x0009, 0x0001},
    {0xc00a0001, 0x0003, 0x0001},
    {0xc00a0006, 0x000b, 0x0001},
    {0xc00a0012, 0x0007, 0x0001},
    {0xc00a0022, 0x0001, 0x0001},
    {0xc00a0024, 0x0001, 0x0001},
    {0xc00a0026, 0x0003, 0x0001},
    {0xc00a002a, 0x0002, 0x0001},
    {0xc00a002e, 0x0004, 0x0001},
    {0xc00a0033, 0x0004, 0x0001},
    {0xc0130001, 0x0010, 0x0001},
    {0xc0130012, 0x0005, 0x0001},
    {0xc0150001, 0x0008, 0x0001},
    {0xc015000a, 0x0002, 0x0001},
    {0xc015000e, 0x0001, 0x0001},
    {0xc01a0001, 0x000b, 0x0001},
    {0xc01a000d, 0x0022, 0x0001},
    {0xc0980001, 0x0002, 0x0001},
    {0xc0980008, 0x0001, 0x0001},
    {0xffffffff, 0x0001, 0x0001},
    {0x0, 0x0, 0x0}};
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\ldrreloc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

   ldrreloc.c

Abstract:

    This module contains the code to relocate an image when
    the preferred base isn't available. This is called by the
    boot loader, device driver loader, and system loader.

--*/

#include "ntrtlp.h"

//
// Mark a HIGHADJ entry as needing an increment if reprocessing.
//
#define LDRP_RELOCATION_INCREMENT   0x1

//
// Mark a HIGHADJ entry as not suitable for reprocessing.
//
#define LDRP_RELOCATION_FINAL       0x2

PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlockLongLong(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONGLONG Diff
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,LdrRelocateImage)
#pragma alloc_text(PAGE,LdrRelocateImageWithBias)
#pragma alloc_text(PAGE,LdrProcessRelocationBlock)
#pragma alloc_text(PAGE,LdrProcessRelocationBlockLongLong)
#endif // ALLOC_PRAGMA

typedef LDR_RELOCATE_IMAGE_RETURN_TYPE NTSTATUS;

LDR_RELOCATE_IMAGE_RETURN_TYPE
LdrRelocateImage (
    __in PVOID NewBase,
    __in PCSTR LoaderName,
    __in LDR_RELOCATE_IMAGE_RETURN_TYPE Success,
    __in LDR_RELOCATE_IMAGE_RETURN_TYPE Conflict,
    __in LDR_RELOCATE_IMAGE_RETURN_TYPE Invalid
    )
/*++

Routine Description:

    This routine relocates an image file that was not loaded into memory
    at the preferred address.

Arguments:

    NewBase - Supplies a pointer to the image base.

    LoaderName - Indicates which loader routine is being called from.

    Success - Value to return if relocation successful.

    Conflict - Value to return if can't relocate.

    Invalid - Value to return if relocations are invalid.

Return Value:

    Success if image is relocated.
    Conflict if image can't be relocated.
    Invalid if image contains invalid fixups.

--*/

{
    //
    // Just call LdrRelocateImageWithBias() with a zero bias.
    //

    return LdrRelocateImageWithBias( NewBase,
                                     0,
                                     LoaderName,
                                     Success,
                                     Conflict,
                                     Invalid );
}


LDR_RELOCATE_IMAGE_RETURN_TYPE
LdrRelocateImageWithBias (
    __in PVOID NewBase,
    __in LONGLONG AdditionalBias,
    __in PCSTR LoaderName,
    __in LDR_RELOCATE_IMAGE_RETURN_TYPE Success,
    __in LDR_RELOCATE_IMAGE_RETURN_TYPE Conflict,
    __in LDR_RELOCATE_IMAGE_RETURN_TYPE Invalid
    )
/*++

Routine Description:

    This routine relocates an image file that was not loaded into memory
    at the preferred address.

Arguments:

    NewBase - Supplies a pointer to the image base.

    AdditionalBias - An additional quantity to add to all fixups.  The
                     32-bit X86 loader uses this when loading 64-bit images
                     to specify a NewBase that is actually a 64-bit value.

    LoaderName - Indicates which loader routine is being called from.

    Success - Value to return if relocation successful.

    Conflict - Value to return if can't relocate.

    Invalid - Value to return if relocations are invalid.

Return Value:

    Success if image is relocated.
    Conflict if image can't be relocated.
    Invalid if image contains invalid fixups.

--*/

{
    LONGLONG Diff;
    ULONG TotalCountBytes = 0;
    ULONG_PTR VA;
    ULONGLONG OldBase;
    ULONG SizeOfBlock;
    PUCHAR FixupVA;
    USHORT Offset;
    PUSHORT NextOffset = NULL;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_BASE_RELOCATION NextBlock;
    LDR_RELOCATE_IMAGE_RETURN_TYPE Status;

    RTL_PAGED_CODE();

    NtHeaders = RtlImageNtHeader( NewBase );
    if (NtHeaders == NULL) {
        Status = Invalid;
        goto Exit;
    }

    switch (NtHeaders->OptionalHeader.Magic) {
       
        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:

            OldBase =
                ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase;
            break;

        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:

            OldBase =
                ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase;
            break;

        default:

            Status = Invalid;
            goto Exit;
    }

    //
    // Locate the relocation section.
    //

    NextBlock = (PIMAGE_BASE_RELOCATION)RtlImageDirectoryEntryToData(
            NewBase, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &TotalCountBytes);

    //
    // It is possible for a file to have no relocations, but the relocations
    // must not have been stripped.
    //

    if (!NextBlock || !TotalCountBytes) {
    
        if (NtHeaders->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED) {

#if DBG

            DbgPrint("%s: Image can't be relocated, no fixup information.\n", LoaderName);

#endif // DBG

            Status = Conflict;

        } else {
            Status = Success;
        }

        goto Exit;
    }

    //
    // If the image has a relocation table, then apply the specified fixup
    // information to the image.
    //
    Diff = (ULONG_PTR)NewBase - OldBase + AdditionalBias;
    while (TotalCountBytes) {
        SizeOfBlock = NextBlock->SizeOfBlock;
        TotalCountBytes -= SizeOfBlock;
        SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
        SizeOfBlock /= sizeof(USHORT);
        NextOffset = (PUSHORT)((PCHAR)NextBlock + sizeof(IMAGE_BASE_RELOCATION));

        VA = (ULONG_PTR)NewBase + NextBlock->VirtualAddress;

        if ( !(NextBlock = LdrProcessRelocationBlockLongLong( VA,
                                                              SizeOfBlock,
                                                              NextOffset,
                                                              Diff)) ) {
#if DBG
            DbgPrint("%s: Unknown base relocation type\n", LoaderName);
#endif
            Status = Invalid;
            goto Exit;
        }
    }

    Status = Success;
Exit:
    return Status;
}

PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlock(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff
    )
{
    PIMAGE_BASE_RELOCATION baseRelocation;

    baseRelocation = LdrProcessRelocationBlockLongLong( VA,
                                                        SizeOfBlock,
                                                        NextOffset,
                                                        (LONGLONG)Diff );

    return baseRelocation;
}

// begin_rebase
PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlockLongLong(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONGLONG Diff
    )
{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;
    ULONG Temp32;
    ULONGLONG Value64;
    LONGLONG Temp64;

    RTL_PAGED_CODE();

    while (SizeOfBlock--) {

       Offset = *NextOffset & (USHORT)0xfff;
       FixupVA = (PUCHAR)(VA + Offset);

       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHLOW :
                //
                // HighLow - (32-bits) relocate the high and low half
                //      of an address.
                //
                *(LONG UNALIGNED *)FixupVA += (ULONG) Diff;
                break;

            case IMAGE_REL_BASED_HIGH :
                //
                // High - (16-bits) relocate the high half of an address.
                //
                Temp = *(PUSHORT)FixupVA << 16;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                break;

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //

                //
                // If the address has already been relocated then don't
                // process it again now or information will be lost.
                //
                if (Offset & LDRP_RELOCATION_FINAL) {
                    ++NextOffset;
                    --SizeOfBlock;
                    break;
                }

                Temp = *(PUSHORT)FixupVA << 16;
                ++NextOffset;
                --SizeOfBlock;
                Temp += (LONG)(*(PSHORT)NextOffset);
                Temp += (ULONG) Diff;
                Temp += 0x8000;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);

                break;

            case IMAGE_REL_BASED_LOW :
                //
                // Low - (16-bit) relocate the low half of an address.
                //
                Temp = *(PSHORT)FixupVA;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)Temp;
                break;

            case IMAGE_REL_BASED_IA64_IMM64:

                //
                // Align it to bundle address before fixing up the
                // 64-bit immediate value of the movl instruction.
                //

                FixupVA = (PUCHAR)((ULONG_PTR)FixupVA & ~(15));
                Value64 = (ULONGLONG)0;

                //
                // Extract the lower 32 bits of IMM64 from bundle
                //


                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X,
                        EMARCH_ENC_I17_IMM7B_SIZE_X,
                        EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM7B_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X,
                        EMARCH_ENC_I17_IMM9D_SIZE_X,
                        EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM9D_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X,
                        EMARCH_ENC_I17_IMM5C_SIZE_X,
                        EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM5C_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X,
                        EMARCH_ENC_I17_IC_SIZE_X,
                        EMARCH_ENC_I17_IC_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IC_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X,
                        EMARCH_ENC_I17_IMM41a_SIZE_X,
                        EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41a_VAL_POS_X);

                EXT_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41b_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41b_SIZE_X,
                        EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41b_VAL_POS_X);
                EXT_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41c_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41c_SIZE_X,
                        EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41c_VAL_POS_X);
                EXT_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_SIGN_INST_WORD_X),
                        EMARCH_ENC_I17_SIGN_SIZE_X,
                        EMARCH_ENC_I17_SIGN_INST_WORD_POS_X,
                        EMARCH_ENC_I17_SIGN_VAL_POS_X);
                //
                // Update 64-bit address
                //

                Value64+=Diff;

                //
                // Insert IMM64 into bundle
                //

                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X),
                        EMARCH_ENC_I17_IMM7B_SIZE_X,
                        EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM7B_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X),
                        EMARCH_ENC_I17_IMM9D_SIZE_X,
                        EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM9D_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X),
                        EMARCH_ENC_I17_IMM5C_SIZE_X,
                        EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM5C_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X),
                        EMARCH_ENC_I17_IC_SIZE_X,
                        EMARCH_ENC_I17_IC_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IC_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41a_SIZE_X,
                        EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41a_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41b_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41b_SIZE_X,
                        EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41b_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41c_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41c_SIZE_X,
                        EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41c_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_SIGN_INST_WORD_X),
                        EMARCH_ENC_I17_SIGN_SIZE_X,
                        EMARCH_ENC_I17_SIGN_INST_WORD_POS_X,
                        EMARCH_ENC_I17_SIGN_VAL_POS_X);
                break;

            case IMAGE_REL_BASED_DIR64:

                *(ULONGLONG UNALIGNED *)FixupVA += Diff;

                break;

            case IMAGE_REL_BASED_MIPS_JMPADDR :
                //
                // JumpAddress - (32-bits) relocate a MIPS jump address.
                //
                Temp = (*(PULONG)FixupVA & 0x3ffffff) << 2;
                Temp += (ULONG) Diff;
                *(PULONG)FixupVA = (*(PULONG)FixupVA & ~0x3ffffff) |
                                                ((Temp >> 2) & 0x3ffffff);

                break;

            case IMAGE_REL_BASED_ABSOLUTE :
                //
                // Absolute - no fixup required.
                //
                break;

            case IMAGE_REL_BASED_SECTION :
                //
                // Section Relative reloc.  Ignore for now.
                //
                break;

            case IMAGE_REL_BASED_REL32 :
                //
                // Relative intrasection. Ignore for now.
                //
                break;

            default :
                //
                // Illegal - illegal relocation type.
                //

                return (PIMAGE_BASE_RELOCATION)NULL;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}

// end_rebase
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\gentable.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Gentable.c

Abstract:

    This module implements the generic table package.

Revision History:

    Added ability to get elements out in the order
    inserted.  *NOTE* *NOTE* This depends on the implicit
    ordering of record fields:

        SPLAY_LINKS,
        LIST_ENTRY,
        USER_DATA

--*/

#include <nt.h>

#include <ntrtl.h>

#pragma pack(8)

//
// This structure is the header for a generic table entry.
// Align this structure on a 8 byte boundary so the user
// data is correctly aligned.
//

typedef struct _TABLE_ENTRY_HEADER {

    RTL_SPLAY_LINKS SplayLinks;
    LIST_ENTRY ListEntry;
    LONGLONG UserData;

} TABLE_ENTRY_HEADER, *PTABLE_ENTRY_HEADER;

#pragma pack()


static
TABLE_SEARCH_RESULT
FindNodeOrParent(
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer,
    OUT PRTL_SPLAY_LINKS *NodeOrParent
    )

/*++

Routine Description:

    This routine is used by all of the routines of the generic
    table package to locate the a node in the tree.  It will
    find and return (via the NodeOrParent parameter) the node
    with the given key, or if that node is not in the tree it
    will return (via the NodeOrParent parameter) a pointer to
    the parent.

Arguments:

    Table - The generic table to search for the key.

    Buffer - Pointer to a buffer holding the key.  The table
             package doesn't examine the key itself.  It leaves
             this up to the user supplied compare routine.

    NodeOrParent - Will be set to point to the node containing the
                   the key or what should be the parent of the node
                   if it were in the tree.  Note that this will *NOT*
                   be set if the search result is TableEmptyTree.

Return Value:

    TABLE_SEARCH_RESULT - TableEmptyTree: The tree was empty.  NodeOrParent
                                          is *not* altered.

                          TableFoundNode: A node with the key is in the tree.
                                          NodeOrParent points to that node.

                          TableInsertAsLeft: Node with key was not found.
                                             NodeOrParent points to what would be
                                             parent.  The node would be the left
                                             child.

                          TableInsertAsRight: Node with key was not found.
                                              NodeOrParent points to what would be
                                              parent.  The node would be the right
                                              child.

--*/



{

    if (RtlIsGenericTableEmpty(Table)) {

        return TableEmptyTree;

    } else {

        //
        // Used as the iteration variable while stepping through
        // the generic table.
        //
        PRTL_SPLAY_LINKS NodeToExamine = Table->TableRoot;

        //
        // Just a temporary.  Hopefully a good compiler will get
        // rid of it.
        //
        PRTL_SPLAY_LINKS Child;

        //
        // Holds the value of the comparasion.
        //
        RTL_GENERIC_COMPARE_RESULTS Result;

        while (TRUE) {

            //
            // Compare the buffer with the key in the tree element.
            //

            Result = Table->CompareRoutine(
                         Table,
                         Buffer,
                         &((PTABLE_ENTRY_HEADER) NodeToExamine)->UserData
                         );

            if (Result == GenericLessThan) {

                if (Child = RtlLeftChild(NodeToExamine)) {

                    NodeToExamine = Child;

                } else {

                    //
                    // Node is not in the tree.  Set the output
                    // parameter to point to what would be its
                    // parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return TableInsertAsLeft;

                }

            } else if (Result == GenericGreaterThan) {

                if (Child = RtlRightChild(NodeToExamine)) {

                    NodeToExamine = Child;

                } else {

                    //
                    // Node is not in the tree.  Set the output
                    // parameter to point to what would be its
                    // parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return TableInsertAsRight;

                }


            } else {

                //
                // Node is in the tree (or it better be because of the
                // assert).  Set the output parameter to point to
                // the node and tell the caller that we found the node.
                //

                ASSERT(Result == GenericEqual);
                *NodeOrParent = NodeToExamine;
                return TableFoundNode;

            }

        }

    }

}

VOID
RtlInitializeGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,
    IN PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
    IN PRTL_GENERIC_FREE_ROUTINE FreeRoutine,
    IN PVOID TableContext
    )

/*++

Routine Description:

    The procedure InitializeGenericTable takes as input an uninitialized
    generic table variable and pointers to the three user supplied routines.
    This must be called for every individual generic table variable before
    it can be used.

Arguments:

    Table - Pointer to the generic table to be initialized.

    CompareRoutine - User routine to be used to compare to keys in the
                     table.

    AllocateRoutine - User routine to call to allocate memory for a new
                      node in the generic table.

    FreeRoutine - User routine to call to deallocate memory for
                        a node in the generic table.

    TableContext - Supplies user supplied context for the table.

Return Value:

    None.

--*/

{

    //
    // Initialize each field of the Table parameter.
    //

    Table->TableRoot = NULL;
    InitializeListHead(&Table->InsertOrderList);
    Table->NumberGenericTableElements = 0;
    Table->OrderedPointer = &Table->InsertOrderList;
    Table->WhichOrderedElement = 0;
    Table->CompareRoutine = CompareRoutine;
    Table->AllocateRoutine = AllocateRoutine;
    Table->FreeRoutine = FreeRoutine;
    Table->TableContext = TableContext;

}


PVOID
RtlInsertElementGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer,
    IN CLONG BufferSize,
    OUT PBOOLEAN NewElement OPTIONAL
    )

/*++

Routine Description:

    The function InsertElementGenericTable will insert a new element
    in a table.  It does this by allocating space for the new element
    (this includes splay links), inserting the element in the table, and
    then returning to the user a pointer to the new element (which is
    the first available space after the splay links).  If an element
    with the same key already exists in the table the return value is a pointer
    to the old element.  The optional output parameter NewElement is used
    to indicate if the element previously existed in the table.  Note: the user
    supplied Buffer is only used for searching the table, upon insertion its
    contents are copied to the newly created element.  This means that
    pointer to the input buffer will not point to the new element.

Arguments:

    Table - Pointer to the table in which to (possibly) insert the
            key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

    BufferSize - The amount of space to allocate when the (possible)
                 insertion is made.  Note that if we actually do
                 not find the node and we do allocate space then we
                 will add the size of the SPLAY_LINKS to this buffer
                 size.  The user should really take care not to depend
                 on anything in the first sizeof(SPLAY_LINKS) bytes
                 of the memory allocated via the memory allocation
                 routine.

    NewElement - Optional Flag.  If present then it will be set to
                 TRUE if the buffer was not "found" in the generic
                 table.

Return Value:

    PVOID - Pointer to the user defined data.

--*/

{

    //
    // Holds a pointer to the node in the table or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the table lookup.
    //
    TABLE_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent(
                 Table,
                 Buffer,
                 &NodeOrParent
                 );

    //
    //  Call the full routine to do the real work.
    //

    return RtlInsertElementGenericTableFull(
                Table,
                Buffer,
                BufferSize,
                NewElement,
                NodeOrParent,
                Lookup
                );
}


PVOID
RtlInsertElementGenericTableFull (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer,
    IN CLONG BufferSize,
    OUT PBOOLEAN NewElement OPTIONAL,
    PVOID NodeOrParent,
    TABLE_SEARCH_RESULT SearchResult
    )

/*++

Routine Description:

    The function InsertElementGenericTableFull will insert a new element
    in a table.  It does this by allocating space for the new element
    (this includes splay links), inserting the element in the table, and
    then returning to the user a pointer to the new element.  If an element
    with the same key already exists in the table the return value is a pointer
    to the old element.  The optional output parameter NewElement is used
    to indicate if the element previously existed in the table.  Note: the user
    supplied Buffer is only used for searching the table, upon insertion its
    contents are copied to the newly created element.  This means that
    pointer to the input buffer will not point to the new element.
    This routine is passed the NodeOrParent and SearchResult from a
    previous RtlLookupElementGenericTableFull.

Arguments:

    Table - Pointer to the table in which to (possibly) insert the
            key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

    BufferSize - The amount of space to allocate when the (possible)
                 insertion is made.  Note that if we actually do
                 not find the node and we do allocate space then we
                 will add the size of the SPLAY_LINKS to this buffer
                 size.  The user should really take care not to depend
                 on anything in the first sizeof(SPLAY_LINKS) bytes
                 of the memory allocated via the memory allocation
                 routine.

    NewElement - Optional Flag.  If present then it will be set to
                 TRUE if the buffer was not "found" in the generic
                 table.

   NodeOrParent - Result of prior RtlLookupElementGenericTableFull.

   SearchResult - Result of prior RtlLookupElementGenericTableFull.

Return Value:

    PVOID - Pointer to the user defined data.

--*/

{
    //
    // Node will point to the splay links of what
    // will be returned to the user.
    //

    PRTL_SPLAY_LINKS NodeToReturn;

    if (SearchResult != TableFoundNode) {

        //
        // We just check that the table isn't getting
        // too big.
        //

        ASSERT(Table->NumberGenericTableElements != (MAXULONG-1));

        //
        // The node wasn't in the (possibly empty) tree.
        // Call the user allocation routine to get space
        // for the new node.
        //

        NodeToReturn = Table->AllocateRoutine(
                           Table,
                           BufferSize+FIELD_OFFSET( TABLE_ENTRY_HEADER, UserData )
                           );

        //
        // If the return is NULL, return NULL from here to indicate that
        // the entry could not be added.
        //

        if (NodeToReturn == NULL) {

            if (ARGUMENT_PRESENT(NewElement)) {

                *NewElement = FALSE;
            }

            return(NULL);
        }

        RtlInitializeSplayLinks(NodeToReturn);

        //
        // Insert the new node at the end of the ordered linked list.
        //

        InsertTailList(
            &Table->InsertOrderList,
            &((PTABLE_ENTRY_HEADER) NodeToReturn)->ListEntry
            );

        Table->NumberGenericTableElements++;

        //
        // Insert the new node in the tree.
        //

        if (SearchResult == TableEmptyTree) {

            Table->TableRoot = NodeToReturn;

        } else {

            if (SearchResult == TableInsertAsLeft) {

                RtlInsertAsLeftChild(
                    NodeOrParent,
                    NodeToReturn
                    );

            } else {

                RtlInsertAsRightChild(
                    NodeOrParent,
                    NodeToReturn
                    );
            }
        }

        //
        // Copy the users buffer into the user data area of the table.
        //

        RtlCopyMemory(
            &((PTABLE_ENTRY_HEADER) NodeToReturn)->UserData,
            Buffer,
            BufferSize
            );

    } else {

        NodeToReturn = NodeOrParent;
    }

    //
    // Always splay the (possibly) new node.
    //

    Table->TableRoot = RtlSplay(NodeToReturn);

    if (ARGUMENT_PRESENT(NewElement)) {

        *NewElement = ((SearchResult == TableFoundNode)?(FALSE):(TRUE));
    }

    //
    // Insert the element on the ordered list;
    //

    return &((PTABLE_ENTRY_HEADER) NodeToReturn)->UserData;
}


BOOLEAN
RtlDeleteElementGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The function DeleteElementGenericTable will find and delete an element
    from a generic table.  If the element is located and deleted the return
    value is TRUE, otherwise if the element is not located the return value
    is FALSE.  The user supplied input buffer is only used as a key in
    locating the element in the table.

Arguments:

    Table - Pointer to the table in which to (possibly) delete the
            memory accessed by the key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

Return Value:

    BOOLEAN - If the table contained the key then true, otherwise false.

--*/

{

    //
    // Holds a pointer to the node in the table or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the table lookup.
    //
    TABLE_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent(
                 Table,
                 Buffer,
                 &NodeOrParent
                 );

    if ((Lookup == TableEmptyTree) || (Lookup != TableFoundNode)) {

        return FALSE;

    } else {

        //
        // Delete the node from the splay tree.
        //

        Table->TableRoot = RtlDelete(NodeOrParent);

        //
        // Delete the element from the linked list.
        //

        RemoveEntryList(&((PTABLE_ENTRY_HEADER) NodeOrParent)->ListEntry);
        Table->NumberGenericTableElements--;
        Table->WhichOrderedElement = 0;
        Table->OrderedPointer = &Table->InsertOrderList;

        //
        // The node has been deleted from the splay table.
        // Now give the node to the user deletion routine.
        // NOTE: We are giving the deletion routine a pointer
        // to the splay links rather then the user data.  It
        // is assumed that the deallocation is rather bad.
        //

        Table->FreeRoutine(Table,NodeOrParent);
        return TRUE;

    }

}


PVOID
RtlLookupElementGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The function LookupElementGenericTable will find an element in a generic
    table.  If the element is located the return value is a pointer to
    the user defined structure associated with the element, otherwise if
    the element is not located the return value is NULL.  The user supplied
    input buffer is only used as a key in locating the element in the table.

Arguments:

    Table - Pointer to the users Generic table to search for the key.

    Buffer - Used for the comparasion.

Return Value:

    PVOID - returns a pointer to the user data.

--*/

{
    //
    // Holds a pointer to the node in the table or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the table lookup.
    //
    TABLE_SEARCH_RESULT Lookup;

    return RtlLookupElementGenericTableFull(
                Table,
                Buffer,
                &NodeOrParent,
                &Lookup
                );
}


PVOID
NTAPI
RtlLookupElementGenericTableFull (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT TABLE_SEARCH_RESULT *SearchResult
    )

/*++

Routine Description:

    The function LookupElementGenericTableFull will find an element in a generic
    table.  If the element is located the return value is a pointer to
    the user defined structure associated with the element.  If the element is not
    located then a pointer to the parent for the insert location is returned.  The
    user must look at the SearchResult value to determine which is being returned.
    The user can use the SearchResult and parent for a subsequent FullInsertElement
    call to optimize the insert.

Arguments:

    Table - Pointer to the users Generic table to search for the key.

    Buffer - Used for the comparasion.

    NodeOrParent - Address to store the desired Node or parent of the desired node.

    SearchResult - Describes the relationship of the NodeOrParent with the desired Node.

Return Value:

    PVOID - returns a pointer to the user data.

--*/

{

    //
    //  Lookup the element and save the result.
    //

    *SearchResult = FindNodeOrParent(
                        Table,
                        Buffer,
                        (PRTL_SPLAY_LINKS *)NodeOrParent
                        );

    if ((*SearchResult == TableEmptyTree) || (*SearchResult != TableFoundNode)) {

        return NULL;

    } else {

        //
        // Splay the tree with this node.
        //

        Table->TableRoot = RtlSplay(*NodeOrParent);

        //
        // Return a pointer to the user data.
        //

        return &((PTABLE_ENTRY_HEADER)*NodeOrParent)->UserData;
    }
}


PVOID
RtlEnumerateGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN BOOLEAN Restart
    )

/*++

Routine Description:

    The function EnumerateGenericTable will return to the caller one-by-one
    the elements of of a table.  The return value is a pointer to the user
    defined structure associated with the element.  The input parameter
    Restart indicates if the enumeration should start from the beginning
    or should return the next element.  If the are no more new elements to
    return the return value is NULL.  As an example of its use, to enumerate
    all of the elements in a table the user would write:

        for (ptr = EnumerateGenericTable(Table,TRUE);
             ptr != NULL;
             ptr = EnumerateGenericTable(Table, FALSE)) {
                :
        }

Arguments:

    Table - Pointer to the generic table to enumerate.

    Restart - Flag that if true we should start with the least
              element in the tree otherwise, return we return
              a pointer to the user data for the root and make
              the real successor to the root the new root.

Return Value:

    PVOID - Pointer to the user data.

--*/

{

    if (RtlIsGenericTableEmpty(Table)) {

        //
        // Nothing to do if the table is empty.
        //

        return NULL;

    } else {

        //
        // Will be used as the "iteration" through the tree.
        //
        PRTL_SPLAY_LINKS NodeToReturn;

        //
        // If the restart flag is true then go to the least element
        // in the tree.
        //

        if (Restart) {

            //
            // We just loop until we find the leftmost child of the root.
            //

            for (
                NodeToReturn = Table->TableRoot;
                RtlLeftChild(NodeToReturn);
                NodeToReturn = RtlLeftChild(NodeToReturn)
                ) {
                ;
            }

            Table->TableRoot = RtlSplay(NodeToReturn);

        } else {

            //
            // The assumption here is that the root of the
            // tree is the last node that we returned.  We
            // find the real successor to the root and return
            // it as next element of the enumeration.  The
            // node that is to be returned is splayed (thereby
            // making it the root of the tree).  Note that we
            // need to take care when there are no more elements.
            //

            NodeToReturn = RtlRealSuccessor(Table->TableRoot);

            if (NodeToReturn) {

                Table->TableRoot = RtlSplay(NodeToReturn);

            }

        }

        //
        // If there actually is a next element in the enumeration
        // then the pointer to return is right after the list links.
        //

        return ((NodeToReturn)?
                   ((PVOID)&((PTABLE_ENTRY_HEADER)NodeToReturn)->UserData)
                  :((PVOID)(NULL)));

    }

}


BOOLEAN
RtlIsGenericTableEmpty (
    IN PRTL_GENERIC_TABLE Table
    )

/*++

Routine Description:

    The function IsGenericTableEmpty will return to the caller TRUE if
    the input table is empty (i.e., does not contain any elements) and
    FALSE otherwise.

Arguments:

    Table - Supplies a pointer to the Generic Table.

Return Value:

    BOOLEAN - if enabled the tree is empty.

--*/

{

    //
    // Table is empty if the root pointer is null.
    //

    return ((Table->TableRoot)?(FALSE):(TRUE));

}

PVOID
RtlGetElementGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN ULONG I
    )

/*++

Routine Description:


    The function GetElementGenericTable will return the i'th element
    inserted in the generic table.  I = 0 implies the first element,
    I = (RtlNumberGenericTableElements(Table)-1) will return the last element
    inserted into the generic table.  The type of I is ULONG.  Values
    of I > than (NumberGenericTableElements(Table)-1) will return NULL.  If
    an arbitrary element is deleted from the generic table it will cause
    all elements inserted after the deleted element to "move up".

Arguments:

    Table - Pointer to the generic table from which to get the ith element.

    I - Which element to get.


Return Value:

    PVOID - Pointer to the user data.

--*/

{

    //
    // Current location in the table.
    //
    ULONG CurrentLocation = Table->WhichOrderedElement;

    //
    // Hold the number of elements in the table.
    //
    ULONG NumberInTable = Table->NumberGenericTableElements;

    //
    // Holds the value of I+1.
    //
    // Note that we don't care if this value overflows.
    // If we end up accessing it we know that it didn't.
    //
    ULONG NormalizedI = I + 1;

    //
    // Will hold distances to travel to the desired node;
    //
    ULONG ForwardDistance,BackwardDistance;

    //
    // Will point to the current element in the linked list.
    //
    PLIST_ENTRY CurrentNode = Table->OrderedPointer;


    //
    // If it's out of bounds get out quick.
    //

    if ((I == MAXULONG) || (NormalizedI > NumberInTable)) return NULL;

    //
    // If we're already at the node then return it.
    //

    if (NormalizedI == CurrentLocation) {

        return &((PTABLE_ENTRY_HEADER) CONTAINING_RECORD(CurrentNode, TABLE_ENTRY_HEADER, ListEntry))->UserData;
    }

    //
    // Calculate the forward and backward distance to the node.
    //

    if (CurrentLocation > NormalizedI) {

        //
        // When CurrentLocation is greater than where we want to go,
        // if moving forward gets us there quicker than moving backward
        // then it follows that moving forward from the listhead is
        // going to take fewer steps. (This is because, moving forward
        // in this case must move *through* the listhead.)
        //
        // The work here is to figure out if moving backward would be quicker.
        //
        // Moving backward would be quicker only if the location we wish  to
        // go to is more than half way between the listhead and where we
        // currently are.
        //

        if (NormalizedI > (CurrentLocation/2)) {

            //
            // Where we want to go is more than half way from the listhead
            // We can traval backwards from our current location.
            //

            for (
                BackwardDistance = CurrentLocation - NormalizedI;
                BackwardDistance;
                BackwardDistance--
                ) {

                CurrentNode = CurrentNode->Blink;

            }
        } else {

            //
            // Where we want to go is less than halfway between the start
            // and where we currently are.  Start from the listhead.
            //

            for (
                CurrentNode = &Table->InsertOrderList;
                NormalizedI;
                NormalizedI--
                ) {

                CurrentNode = CurrentNode->Flink;

            }

        }

    } else {


        //
        // When CurrentLocation is less than where we want to go,
        // if moving backwards gets us there quicker than moving forwards
        // then it follows that moving backwards from the listhead is
        // going to take fewer steps. (This is because, moving backwards
        // in this case must move *through* the listhead.)
        //

        ForwardDistance = NormalizedI - CurrentLocation;

        //
        // Do the backwards calculation as if we are starting from the
        // listhead.
        //

        BackwardDistance = (NumberInTable - NormalizedI) + 1;

        if (ForwardDistance <= BackwardDistance) {

            for (
                ;
                ForwardDistance;
                ForwardDistance--
                ) {

                CurrentNode = CurrentNode->Flink;

            }


        } else {

            for (
                CurrentNode = &Table->InsertOrderList;
                BackwardDistance;
                BackwardDistance--
                ) {

                CurrentNode = CurrentNode->Blink;

            }

        }

    }

    //
    // We're where we want to be.  Save our current location and return
    // a pointer to the data to the user.
    //

    Table->OrderedPointer = CurrentNode;
    Table->WhichOrderedElement = I+1;

    return &((PTABLE_ENTRY_HEADER) CONTAINING_RECORD(CurrentNode, TABLE_ENTRY_HEADER, ListEntry))->UserData;

}


ULONG
RtlNumberGenericTableElements(
    IN PRTL_GENERIC_TABLE Table
    )

/*++

Routine Description:

    The function NumberGenericTableElements returns a ULONG value
    which is the number of generic table elements currently inserted
    in the generic table.

Arguments:

    Table - Pointer to the generic table from which to find out the number
    of elements.


Return Value:

    ULONG - The number of elements in the generic table.

--*/
{

    return Table->NumberGenericTableElements;

}


PVOID
RtlEnumerateGenericTableWithoutSplaying (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    The function EnumerateGenericTableWithoutSplaying will return to the
    caller one-by-one the elements of of a table.  The return value is a
    pointer to the user defined structure associated with the element.
    The input parameter RestartKey indicates if the enumeration should
    start from the beginning or should return the next element.  If the
    are no more new elements to return the return value is NULL.  As an
    example of its use, to enumerate all of the elements in a table the
    user would write:

        PVOID RestartKey = NULL;

        for (ptr = RtlEnumerateGenericTableWithoutSplaying(Table, &RestartKey);
             ptr != NULL;
             ptr = RtlEnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
                :
        }

Arguments:

    Table - Pointer to the generic table to enumerate.

    RestartKey - Pointer that indicates if we should restart or return the next
                element.  If the contents of RestartKey is NULL, the search
                will be started from the beginning.

Return Value:

    PVOID - Pointer to the user data.

--*/

{

    if (RtlIsGenericTableEmpty(Table)) {

        //
        // Nothing to do if the table is empty.
        //

        return NULL;

    } else {

        //
        // Will be used as the "iteration" through the tree.
        //
        PRTL_SPLAY_LINKS NodeToReturn;

        //
        // If the restart flag is true then go to the least element
        // in the tree.
        //

        if (*RestartKey == NULL) {

            //
            // We just loop until we find the leftmost child of the root.
            //

            for (
                NodeToReturn = Table->TableRoot;
                RtlLeftChild(NodeToReturn);
                NodeToReturn = RtlLeftChild(NodeToReturn)
                ) {
                ;
            }

            *RestartKey = NodeToReturn;

        } else {

            //
            // The caller has passed in the previous entry found
            // in the table to enable us to continue the search.  We call
            // RtlRealSuccessor to step to the next element in the tree.
            //

            NodeToReturn = RtlRealSuccessor(*RestartKey);

            if (NodeToReturn) {

                *RestartKey = NodeToReturn;

            }

        }

        //
        // If there actually is a next element in the enumeration
        // then the pointer to return is right after the list links.
        //

        return ((NodeToReturn)?
                   ((PVOID)&((PTABLE_ENTRY_HEADER)NodeToReturn)->UserData)
                  :((PVOID)(NULL)));

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\imagedir.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    imagedir.c

Abstract:

    The module contains the code to translate an image directory type to
    the address of the data for that entry.

--*/

#include "ntrtlp.h"

VOID
RtlpTouchMemory(
    IN PVOID Address,
    IN ULONG Length
    );

VOID
RtlpMakeStackTraceDataPresentForImage(
    IN PVOID ImageBase
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,RtlpTouchMemory)
#pragma alloc_text(PAGE,RtlMakeStackTraceDataPresent)
#pragma alloc_text(PAGE,RtlpMakeStackTraceDataPresentForImage)
#endif

PIMAGE_SECTION_HEADER
RtlSectionTableFromVirtualAddress (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Address
    )

/*++

Routine Description:

    This function locates a VirtualAddress within the image header
    of a file that is mapped as a file and returns a pointer to the
    section table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Address - Supplies the virtual address to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the pointer of the section entry containing the data.

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if ((ULONG)Address >= NtSection->VirtualAddress &&
            (ULONG)Address < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}


PVOID
RtlAddressInSectionTable (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Address
    )

/*++

Routine Description:

    This function locates a VirtualAddress within the image header
    of a file that is mapped as a file and returns the seek address
    of the data the Directory describes.

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Address - Supplies the virtual address to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = RtlSectionTableFromVirtualAddress( NtHeaders,
                                                   Base,
                                                   Address
                                                 );
    if (NtSection != NULL) {
        return( ((PCHAR)Base + ((ULONG_PTR)Address - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }
    else {
        return( NULL );
        }
}


PVOID
RtlpImageDirectoryEntryToData32 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    PIMAGE_NT_HEADERS32 NtHeaders
    )
{
    ULONG DirectoryAddress;

    if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {
        return( NULL );
    }

    if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        return( NULL );
    }

    if (Base < MM_HIGHEST_USER_ADDRESS) {
        if ((PVOID)((PCHAR)Base + DirectoryAddress) >= MM_HIGHEST_USER_ADDRESS) {
            return( NULL );
        }
    }

    *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {
        return( (PVOID)((PCHAR)Base + DirectoryAddress) );
    }

    return( RtlAddressInSectionTable((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));
}


PVOID
RtlpImageDirectoryEntryToData64 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    PIMAGE_NT_HEADERS64 NtHeaders
    )
{
    ULONG DirectoryAddress;

    if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {
        return( NULL );
    }

    if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        return( NULL );
    }

    if (Base < MM_HIGHEST_USER_ADDRESS) {
        if ((PVOID)((PCHAR)Base + DirectoryAddress) >= MM_HIGHEST_USER_ADDRESS) {
            return( NULL );
        }
    }

    *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {
        return( (PVOID)((PCHAR)Base + DirectoryAddress) );
    }

    return( RtlAddressInSectionTable((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));
}


PVOID
RtlImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    )

/*++

Routine Description:

    This function locates a Directory Entry within the image header
    and returns either the virtual address or seek address of the
    data the Directory describes.

Arguments:

    Base - Supplies the base of the image or data file.

    MappedAsImage - FALSE if the file is mapped as a data file.
                  - TRUE if the file is mapped as an image.

    DirectoryEntry - Supplies the directory entry to locate.

    Size - Return the size of the directory.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;

    if (LDR_IS_DATAFILE(Base)) {
        Base = LDR_DATAFILE_TO_VIEW(Base);
        MappedAsImage = FALSE;
        }

    NtHeaders = RtlImageNtHeader(Base);

    if (!NtHeaders)
        return NULL;

    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        return (RtlpImageDirectoryEntryToData32(Base,
                                                MappedAsImage,
                                                DirectoryEntry,
                                                Size,
                                                (PIMAGE_NT_HEADERS32)NtHeaders));
    } else if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        return (RtlpImageDirectoryEntryToData64(Base,
                                                MappedAsImage,
                                                DirectoryEntry,
                                                Size,
                                                (PIMAGE_NT_HEADERS64)NtHeaders));
    } else {
        return (NULL);
    }
}


VOID
RtlMakeStackTraceDataPresent(
    VOID
    )

/*++

Routine Description:

    This function walks the loaded user-mode images and makes present the
    portions of the data necessary to support a kernel-debugger stack
    dump of the user-mode stack.

    N.B. The necessary pieces are merely touched to be brought in.  In a low
         memory situation, some of the previously-touched pages may be paged
         out in order for the new ones to be brought in.  This routine is
         not guaranteed to do anything useful, however it does more often than
         not.

Arguments:

    None.

Return value:

    None.

--*/

{
    PPEB peb;
    PLIST_ENTRY head;
    PLIST_ENTRY next;
    PVOID imageBase;
    ULONG imageCount;
    LDR_DATA_TABLE_ENTRY UNALIGNED *ldrDataTableEntry;

    RTL_PAGED_CODE();

    //
    // The image list is in user mode and is not to be trusted.  The
    // surrounding try/except block will guard against most forms of
    // list corruption.  imageCount is used to bail in finite time
    // in the event of a cyclic image list.
    //

    imageCount = 0;
    try {

        peb = NtCurrentPeb();
        head = &peb->Ldr->InLoadOrderModuleList;

        ProbeForReadSmallStructure( head,
                                    sizeof(LIST_ENTRY),
                                    PROBE_ALIGNMENT(LIST_ENTRY) );

        next = head;
        while (imageCount < 1000) {

            next = next->Flink;
            if (next == head) {
                break;
            }
            imageCount += 1;

            //
            // Locate the base address of the image
            //

            ldrDataTableEntry = CONTAINING_RECORD(next,
                                                  LDR_DATA_TABLE_ENTRY,
                                                  InLoadOrderLinks);

            ProbeForReadSmallStructure( ldrDataTableEntry,
                                        sizeof(LDR_DATA_TABLE_ENTRY),
                                        PROBE_ALIGNMENT(LDR_DATA_TABLE_ENTRY) );

            imageBase = ldrDataTableEntry->DllBase;
            ProbeForReadSmallStructure (imageBase, sizeof (IMAGE_DOS_HEADER), sizeof (UCHAR));

            //
            // Make the stack trace data present for this image.  Use a
            // separate try/except block here so that subsequent images
            // will be processed in the event of a failure.
            //

            try {
                RtlpMakeStackTraceDataPresentForImage(imageBase);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }
}

VOID
RtlpMakeStackTraceDataPresentForImage(
    IN PVOID ImageBase
    )

/*++

Routine Description:

    This function attempts to make present the portions of an image necessary
    to support a kernel-debugger stack dump of the user-mode stack.

Arguments:

    ImageBase - Supplies the VA of the base of the image to process.

Return value:

    None.

--*/

{
    PVOID directory;
    ULONG directorySize;
    PIMAGE_RUNTIME_FUNCTION_ENTRY functionEntry;
    PIMAGE_RUNTIME_FUNCTION_ENTRY lastFunctionEntry;
    PCHAR imageBase;

    RTL_PAGED_CODE();

    //
    // Make present the IMAGE_DIRECTORY_EXCEPTION section.
    //

    directory = RtlImageDirectoryEntryToData(ImageBase,
                                             TRUE,
                                             IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                                             &directorySize);
    if (directory == NULL) {
        return;
    }

    RtlpTouchMemory(directory, directorySize);
}

VOID
RtlpTouchMemory(
    IN PVOID Address,
    IN ULONG Length
    )
/*++

Routine Description:

    This function touches all of the pages within a given region.

Arguments:

    Address - Supplies the VA of the start of the image to make present.

    Length - Supplies the length, in bytes, of the image to make present.

Return value:

    None.

--*/
{
    PCHAR regionStart;
    PCHAR regionEnd;

    RTL_PAGED_CODE();

    regionStart = Address;
    regionEnd = regionStart + Length;

    while (regionStart < regionEnd) {
        *(volatile UCHAR *)regionStart;
        regionStart = PAGE_ALIGN(regionStart + PAGE_SIZE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\guid.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    guid.c

--*/

#include "nt.h"
#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA)
static
int
__cdecl
ScanHexFormat(
    IN const WCHAR* Buffer,
    IN ULONG MaximumLength,
    IN const WCHAR* Format,
    ...);

#pragma alloc_text(PAGE, RtlStringFromGUID)
#pragma alloc_text(PAGE, ScanHexFormat)
#pragma alloc_text(PAGE, RtlGUIDFromString)
#endif // ALLOC_PRAGMA

extern const WCHAR GuidFormat[];

#define GUID_STRING_SIZE 38


NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    IN REFGUID Guid,
    OUT PUNICODE_STRING GuidString
    )
/*++

Routine Description:

    Constructs the standard string version of a GUID, in the form:
    "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    Guid -
        Contains the GUID to translate.

    GuidString -
        Returns a string that represents the textual format of the GUID.
        Caller must call RtlFreeUnicodeString to free the buffer when done with
        it.

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS if the user string was succesfully
    initialized.

--*/
{
    RTL_PAGED_CODE();
    GuidString->Length = GUID_STRING_SIZE * sizeof(WCHAR);
    GuidString->MaximumLength = GuidString->Length + sizeof(UNICODE_NULL);
    if (!(GuidString->Buffer = RtlAllocateStringRoutine(GuidString->MaximumLength))) {
        return STATUS_NO_MEMORY;
    }
    swprintf(GuidString->Buffer, GuidFormat, Guid->Data1, Guid->Data2, Guid->Data3, Guid->Data4[0], Guid->Data4[1], Guid->Data4[2], Guid->Data4[3], Guid->Data4[4], Guid->Data4[5], Guid->Data4[6], Guid->Data4[7]);
    return STATUS_SUCCESS;
}


static
int
__cdecl
ScanHexFormat(
    IN const WCHAR* Buffer,
    IN ULONG MaximumLength,
    IN const WCHAR* Format,
    ...)
/*++

Routine Description:

    Scans a source Buffer and places values from that buffer into the parameters
    as specified by Format.

Arguments:

    Buffer -
        Contains the source buffer which is to be scanned.

    MaximumLength -
        Contains the maximum length in characters for which Buffer is searched.
        This implies that Buffer need not be UNICODE_NULL terminated.

    Format -
        Contains the format string which defines both the acceptable string format
        contained in Buffer, and the variable parameters which follow.

Return Value:

    Returns the number of parameters filled if the end of the Buffer is reached,
    else -1 on an error.

--*/
{
    va_list ArgList;
    int     FormatItems;

    va_start(ArgList, Format);
    for (FormatItems = 0;;) {
        switch (*Format) {
        case 0:
            return (MaximumLength && *Buffer) ? -1 : FormatItems;
        case '%':
            Format++;
            if (*Format != '%') {
                ULONG   Number;
                int     Width;
                int     Long;
                PVOID   Pointer;

                for (Long = 0, Width = 0;; Format++) {
                    if ((*Format >= '0') && (*Format <= '9')) {
                        Width = Width * 10 + *Format - '0';
                    } else if (*Format == 'l') {
                        Long++;
                    } else if ((*Format == 'X') || (*Format == 'x')) {
                        break;
                    }
                }
                Format++;
                for (Number = 0; Width--; Buffer++, MaximumLength--) {
                    if (!MaximumLength)
                        return -1;
                    Number *= 16;
                    if ((*Buffer >= '0') && (*Buffer <= '9')) {
                        Number += (*Buffer - '0');
                    } else if ((*Buffer >= 'a') && (*Buffer <= 'f')) {
                        Number += (*Buffer - 'a' + 10);
                    } else if ((*Buffer >= 'A') && (*Buffer <= 'F')) {
                        Number += (*Buffer - 'A' + 10);
                    } else {
                        return -1;
                    }
                }
                Pointer = va_arg(ArgList, PVOID);
                if (Long) {
                    *(PULONG)Pointer = Number;
                } else {
                    *(PUSHORT)Pointer = (USHORT)Number;
                }
                FormatItems++;
                break;
            }
            /* no break */
        default:
            if (!MaximumLength || (*Buffer != *Format)) {
                return -1;
            }
            Buffer++;
            MaximumLength--;
            Format++;
            break;
        }
    }
}


NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid
    )
/*++

Routine Description:

    Retrieves a the binary format of a textual GUID presented in the standard
    string version of a GUID: "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    GuidString -
        Place from which to retrieve the textual form of the GUID.

    Guid -
        Place in which to put the binary form of the GUID.

Return Value:

    Returns STATUS_SUCCESS if the buffer contained a valid GUID, else
    STATUS_INVALID_PARAMETER if the string was invalid.

--*/
{
    USHORT    Data4[8];
    int       Count;

    RTL_PAGED_CODE();
    if (ScanHexFormat(GuidString->Buffer, GuidString->Length / sizeof(WCHAR), GuidFormat, &Guid->Data1, &Guid->Data2, &Guid->Data3, &Data4[0], &Data4[1], &Data4[2], &Data4[3], &Data4[4], &Data4[5], &Data4[6], &Data4[7]) == -1) {
        return STATUS_INVALID_PARAMETER;
    }
    for (Count = 0; Count < sizeof(Data4)/sizeof(Data4[0]); Count++) {
        Guid->Data4[Count] = (UCHAR)Data4[Count];
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\ldrrsrc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    ldrrsrc.c

Abstract: 

    Loader API calls for accessing resource sections.

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,LdrAccessResource)
#pragma alloc_text(PAGE,LdrpAccessResourceData)
#pragma alloc_text(PAGE,LdrpAccessResourceDataNoMultipleLanguage)
#pragma alloc_text(PAGE,LdrFindEntryForAddress)
#pragma alloc_text(PAGE,LdrFindResource_U)
#pragma alloc_text(PAGE,LdrFindResourceEx_U)
#pragma alloc_text(PAGE,LdrFindResourceDirectory_U)
#pragma alloc_text(PAGE,LdrpCompareResourceNames_U)
#pragma alloc_text(PAGE,LdrpSearchResourceSection_U)
#pragma alloc_text(PAGE,LdrEnumResources)
#endif

#define USE_RC_CHECKSUM

// winuser.h
#define IS_INTRESOURCE(_r) (((ULONG_PTR)(_r) >> 16) == 0)
#define RT_VERSION                         16
#define RT_MANIFEST                        24
#define CREATEPROCESS_MANIFEST_RESOURCE_ID  1
#define ISOLATIONAWARE_MANIFEST_RESOURCE_ID 2
#define MINIMUM_RESERVED_MANIFEST_RESOURCE_ID 1
#define MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID 16

#define LDRP_MIN(x,y) (((x)<(y)) ? (x) : (y))

#define DPFLTR_LEVEL_STATUS(x) ((NT_SUCCESS(x) \
                                    || (x) == STATUS_OBJECT_NAME_NOT_FOUND    \
                                    || (x) == STATUS_RESOURCE_DATA_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_TYPE_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_NAME_NOT_FOUND  \
                                    ) \
                                ? DPFLTR_TRACE_LEVEL : DPFLTR_WARNING_LEVEL)

NTSTATUS
LdrAccessResource(
    IN PVOID DllHandle,
    IN const IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    )

/*++

Routine Description:

    This function locates the address of the specified resource in the
    specified DLL and returns its address.

Arguments:

    DllHandle - Supplies a handle to the image file that the resource is
        contained in.

    ResourceDataEntry - Supplies a pointer to the resource data entry in
        the resource data section of the image file specified by the
        DllHandle parameter.  This pointer should have been one returned
        by the LdrFindResource function.

    Address - Optional pointer to a variable that will receive the
        address of the resource specified by the first two parameters.

    Size - Optional pointer to a variable that will receive the size of
        the resource specified by the first two parameters.

--*/

{

    NTSTATUS Status;
    RTL_PAGED_CODE();

    Status =
        LdrpAccessResourceData(
          DllHandle,
          ResourceDataEntry,
          Address,
          Size
          );

#if DBG
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_LDR_ID, DPFLTR_LEVEL_STATUS(Status), "LDR: %s() exiting 0x%08lx\n", __FUNCTION__, Status));
    }
#endif
    return Status;
}

NTSTATUS
LdrpAccessResourceDataNoMultipleLanguage(
    IN PVOID DllHandle,
    IN const IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    )

/*++

Routine Description:

    This function returns the data necessary to actually examine the
    contents of a particular resource, without allowing for the .mui
    feature. It used to be the tail of LdrpAccessResourceData, from
    which it is now called.

Arguments:

    DllHandle - Supplies a handle to the image file that the resource is
        contained in.

    ResourceDataEntry - Supplies a pointer to the resource data entry in
        the resource data directory of the image file specified by the
        DllHandle parameter.  This pointer should have been one returned
        by the LdrFindResource function.

    Address - Optional pointer to a variable that will receive the
        address of the resource specified by the first two parameters.

    Size - Optional pointer to a variable that will receive the size of
        the resource specified by the first two parameters.

--*/

{
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory;
    ULONG ResourceSize;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG_PTR VirtualAddressOffset;
    PIMAGE_SECTION_HEADER NtSection;
    NTSTATUS Status = STATUS_SUCCESS;

    RTL_PAGED_CODE();

    try {
        ResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData(DllHandle,
                                         TRUE,
                                         IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                         &ResourceSize
                                         );
        if (!ResourceDirectory) {
            return STATUS_RESOURCE_DATA_NOT_FOUND;
        }

        if (LDR_IS_DATAFILE(DllHandle)) {
            ULONG ResourceRVA;
            DllHandle = LDR_DATAFILE_TO_VIEW(DllHandle);
            NtHeaders = RtlImageNtHeader( DllHandle );
            if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                ResourceRVA=((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_RESOURCE ].VirtualAddress;
            } else if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                ResourceRVA=((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_RESOURCE ].VirtualAddress;
            } else {
                ResourceRVA = 0;
            }

            if (!ResourceRVA) {
                return STATUS_RESOURCE_DATA_NOT_FOUND;
                }

            VirtualAddressOffset = (ULONG_PTR)DllHandle + ResourceRVA - (ULONG_PTR)ResourceDirectory;

            //
            // Now, we must check to see if the resource is not in the
            // same section as the resource table.  If it's in .rsrc1,
            // we've got to adjust the RVA in the ResourceDataEntry
            // to point to the correct place in the non-VA data file.
            //
            NtSection = RtlSectionTableFromVirtualAddress( NtHeaders, DllHandle, ResourceRVA);

            if (!NtSection) {
                return STATUS_RESOURCE_DATA_NOT_FOUND;
            }

            if ( ResourceDataEntry->OffsetToData > NtSection->Misc.VirtualSize ) {
                ULONG rva;

                rva = NtSection->VirtualAddress;
                NtSection = RtlSectionTableFromVirtualAddress(NtHeaders,
                                                             DllHandle,
                                                             ResourceDataEntry->OffsetToData
                                                             );
                if (!NtSection) {
                    return STATUS_RESOURCE_DATA_NOT_FOUND;
                }
                VirtualAddressOffset +=
                        ((ULONG_PTR)NtSection->VirtualAddress - rva) -
                        ((ULONG_PTR)RtlAddressInSectionTable ( NtHeaders, DllHandle, NtSection->VirtualAddress ) - (ULONG_PTR)ResourceDirectory);
            }
        } else {
            VirtualAddressOffset = 0;
        }

        if (ARGUMENT_PRESENT( Address )) {
            *Address = (PVOID)( (PCHAR)DllHandle +
                                (ResourceDataEntry->OffsetToData - VirtualAddressOffset)
                              );
        }

        if (ARGUMENT_PRESENT( Size )) {
            *Size = ResourceDataEntry->Size;
        }

    }    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

#if DBG
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_LDR_ID, DPFLTR_LEVEL_STATUS(Status), "LDR: %s() exiting 0x%08lx\n", __FUNCTION__, Status));
    }
#endif
    return Status;
}


NTSTATUS
LdrpAccessResourceData(
    IN PVOID DllHandle,
    IN const IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    )

/*++

Routine Description:

    This function returns the data necessary to actually examine the
    contents of a particular resource.

Arguments:

    DllHandle - Supplies a handle to the image file that the resource is
        contained in.

    ResourceDataEntry - Supplies a pointer to the resource data entry in
   the resource data directory of the image file specified by the
        DllHandle parameter.  This pointer should have been one returned
        by the LdrFindResource function.

    Address - Optional pointer to a variable that will receive the
        address of the resource specified by the first two parameters.

    Size - Optional pointer to a variable that will receive the size of
        the resource specified by the first two parameters.

--*/

{
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory;
    ULONG ResourceSize;
    PIMAGE_NT_HEADERS NtHeaders;
    NTSTATUS Status = STATUS_SUCCESS;

    RTL_PAGED_CODE();

    Status =
        LdrpAccessResourceDataNoMultipleLanguage(
            DllHandle,
            ResourceDataEntry,
            Address,
            Size
            );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_LDR_ID, DPFLTR_LEVEL_STATUS(Status), "LDR: %s() exiting 0x%08lx\n", __FUNCTION__, Status));
    }
    return Status;
}


NTSTATUS
LdrFindEntryForAddress(
    IN PVOID Address,
    OUT PLDR_DATA_TABLE_ENTRY *TableEntry
    )
/*++

Routine Description:

    This function returns the load data table entry that describes the virtual
    address range that contains the passed virtual address.

Arguments:

    Address - Supplies a 32-bit virtual address.

    TableEntry - Supplies a pointer to the variable that will receive the
        address of the loader data table entry.


Return Value:

    Status

--*/
{
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY Head, Next;
    PLDR_DATA_TABLE_ENTRY Entry;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID ImageBase;
    PVOID EndOfImage;
    NTSTATUS Status;

    Ldr = NtCurrentPeb()->Ldr;
    if (Ldr == NULL) {
        Status = STATUS_NO_MORE_ENTRIES;
        goto Exit;
        }

    Entry = (PLDR_DATA_TABLE_ENTRY) Ldr->EntryInProgress;
    if (Entry != NULL) {
        NtHeaders = RtlImageNtHeader( Entry->DllBase );
        if (NtHeaders != NULL) {
            ImageBase = (PVOID)Entry->DllBase;

            EndOfImage = (PVOID)
                ((ULONG_PTR)ImageBase + NtHeaders->OptionalHeader.SizeOfImage);

            if ((ULONG_PTR)Address >= (ULONG_PTR)ImageBase && (ULONG_PTR)Address < (ULONG_PTR)EndOfImage) {
                *TableEntry = Entry;
                Status = STATUS_SUCCESS;
                goto Exit;
                }
            }
        }

    Head = &Ldr->InMemoryOrderModuleList;
    Next = Head->Flink;
    while ( Next != Head ) {
        Entry = CONTAINING_RECORD( Next, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks );

        NtHeaders = RtlImageNtHeader( Entry->DllBase );
        if (NtHeaders != NULL) {
            ImageBase = (PVOID)Entry->DllBase;

            EndOfImage = (PVOID)
                ((ULONG_PTR)ImageBase + NtHeaders->OptionalHeader.SizeOfImage);

            if ((ULONG_PTR)Address >= (ULONG_PTR)ImageBase && (ULONG_PTR)Address < (ULONG_PTR)EndOfImage) {
                *TableEntry = Entry;
                Status = STATUS_SUCCESS;
                goto Exit;
                }
            }

        Next = Next->Flink;
        }

    Status = STATUS_NO_MORE_ENTRIES;
Exit:
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_LDR_ID, DPFLTR_LEVEL_STATUS(Status), "LDR: %s() exiting 0x%08lx\n", __FUNCTION__, Status));
    }
    return( Status );
}


NTSTATUS
LdrFindResource_U(
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    OUT PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry
    )

/*++

Routine Description:

    This function locates the address of the specified resource in the
    specified DLL and returns its address.

Arguments:

    DllHandle - Supplies a handle to the image file that the resource is
        contained in.

    ResourceIdPath - Supplies a pointer to an array of 32-bit resource
        identifiers.  Each identifier is either an integer or a pointer
        to a STRING structure that specifies a resource name.  The array
        is used to traverse the directory structure contained in the
        resource section in the image file specified by the DllHandle
        parameter.

    ResourceIdPathLength - Supplies the number of elements in the
        ResourceIdPath array.

    ResourceDataEntry - Supplies a pointer to a variable that will
        receive the address of the resource data entry in the resource
        data section of the image file specified by the DllHandle
        parameter.
--*/

{
    RTL_PAGED_CODE();

    return LdrpSearchResourceSection_U(
      DllHandle,
      ResourceIdPath,
      ResourceIdPathLength,
      0,                // Look for a leaf node, ineaxt lang match
      (PVOID *)ResourceDataEntry
      );
}

NTSTATUS
LdrFindResourceEx_U(
    IN ULONG Flags,
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    OUT PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry
    )

/*++

Routine Description:

    This function locates the address of the specified resource in the
    specified DLL and returns its address.

Arguments:
    Flags -
        LDRP_FIND_RESOURCE_DIRECTORY
        searching for a resource directory, otherwise the caller is
        searching for a resource data entry.

        LDR_FIND_RESOURCE_LANGUAGE_EXACT
        searching for a resource with, and only with, the language id
        specified in ResourceIdPath, otherwise the caller wants the routine
        to come up with default when specified langid is not found.

        LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION
        searching for a resource version in both main and alternative
        module paths

    DllHandle - Supplies a handle to the image file that the resource is
        contained in.

    ResourceIdPath - Supplies a pointer to an array of 32-bit resource
        identifiers.  Each identifier is either an integer or a pointer
        to a STRING structure that specifies a resource name.  The array
        is used to traverse the directory structure contained in the
        resource section in the image file specified by the DllHandle
        parameter.

    ResourceIdPathLength - Supplies the number of elements in the
        ResourceIdPath array.

    ResourceDataEntry - Supplies a pointer to a variable that will
        receive the address of the resource data entry in the resource
        data section of the image file specified by the DllHandle
        parameter.
--*/

{
    RTL_PAGED_CODE();

    return LdrpSearchResourceSection_U(
      DllHandle,
      ResourceIdPath,
      ResourceIdPathLength,
      Flags,
      (PVOID *)ResourceDataEntry
      );
}



NTSTATUS
LdrFindResourceDirectory_U(
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    OUT PIMAGE_RESOURCE_DIRECTORY *ResourceDirectory
    )

/*++

Routine Description:

    This function locates the address of the specified resource directory in
    specified DLL and returns its address.

Arguments:

    DllHandle - Supplies a handle to the image file that the resource
        directory is contained in.

    ResourceIdPath - Supplies a pointer to an array of 32-bit resource
        identifiers.  Each identifier is either an integer or a pointer
        to a STRING structure that specifies a resource name.  The array
        is used to traverse the directory structure contained in the
        resource section in the image file specified by the DllHandle
        parameter.

    ResourceIdPathLength - Supplies the number of elements in the
        ResourceIdPath array.

    ResourceDirectory - Supplies a pointer to a variable that will
        receive the address of the resource directory specified by
        ResourceIdPath in the resource data section of the image file
        the DllHandle parameter.
--*/

{
    RTL_PAGED_CODE();

    return LdrpSearchResourceSection_U(
      DllHandle,
      ResourceIdPath,
      ResourceIdPathLength,
      LDRP_FIND_RESOURCE_DIRECTORY,                 // Look for a directory node
      (PVOID *)ResourceDirectory
      );
}


LONG
LdrpCompareResourceNames_U(
    IN ULONG_PTR ResourceName,
    IN const IMAGE_RESOURCE_DIRECTORY* ResourceDirectory,
    IN const IMAGE_RESOURCE_DIRECTORY_ENTRY* ResourceDirectoryEntry
    )
{
    LONG li;
    PIMAGE_RESOURCE_DIR_STRING_U ResourceNameString;

    if (ResourceName & LDR_RESOURCE_ID_NAME_MASK) {
        if (!ResourceDirectoryEntry->NameIsString) {
            return( -1 );
            }

        ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
            ((PCHAR)ResourceDirectory + ResourceDirectoryEntry->NameOffset);

        li = wcsncmp( (LPWSTR)ResourceName,
            ResourceNameString->NameString,
            ResourceNameString->Length
          );

        if (!li && wcslen((PWSTR)ResourceName) != ResourceNameString->Length) {
       return( 1 );
       }

   return(li);
        }
    else {
        if (ResourceDirectoryEntry->NameIsString) {
            return( 1 );
            }

        return( (ULONG)(ResourceName - ResourceDirectoryEntry->Name) );
        }
}

// Language ids are 16bits so any value with any bits
// set above 16 should be ok, and this value only has
// to fit in a ULONG_PTR. 0x10000 should be sufficient.
// The value used is actually 0xFFFF regardless of 32bit or 64bit,
// I guess assuming this is not an actual langid, which it isn't,
// due to the relatively small number of languages, around 70.
#define  USE_FIRSTAVAILABLE_LANGID   (0xFFFFFFFF & ~LDR_RESOURCE_ID_NAME_MASK)

NTSTATUS
LdrpSearchResourceSection_U(
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN ULONG Flags,
    OUT PVOID *ResourceDirectoryOrData
    )

/*++

Routine Description:

    This function locates the address of the specified resource in the
    specified DLL and returns its address.

Arguments:

    DllHandle - Supplies a handle to the image file that the resource is
        contained in.

    ResourceIdPath - Supplies a pointer to an array of 32-bit resource
        identifiers.  Each identifier is either an integer or a pointer
        to a null terminated string (PSZ) that specifies a resource
        name.  The array is used to traverse the directory structure
        contained in the resource section in the image file specified by
        the DllHandle parameter.

    ResourceIdPathLength - Supplies the number of elements in the
        ResourceIdPath array.

    Flags -
        LDRP_FIND_RESOURCE_DIRECTORY
        searching for a resource directory, otherwise the caller is
        searching for a resource data entry.

        LDR_FIND_RESOURCE_LANGUAGE_EXACT
        searching for a resource with, and only with, the language id
        specified in ResourceIdPath, otherwise the caller wants the routine
        to come up with default when specified langid is not found.

        LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION
        searching for a resource version in main and alternative
        modules paths

    FindDirectoryEntry - Supplies a boolean that is TRUE if caller is
        searching for a resource directory, otherwise the caller is
        searching for a resource data entry.

    ExactLangMatchOnly - Supplies a boolean that is TRUE if caller is
        searching for a resource with, and only with, the language id
        specified in ResourceIdPath, otherwise the caller wants the routine
        to come up with default when specified langid is not found.

    ResourceDirectoryOrData - Supplies a pointer to a variable that will
        receive the address of the resource directory or data entry in
        the resource data section of the image file specified by the
        DllHandle parameter.
--*/

{
    NTSTATUS Status;
    PIMAGE_RESOURCE_DIRECTORY LanguageResourceDirectory, ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirEntLow;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirEntMiddle;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirEntHigh;
    PIMAGE_RESOURCE_DATA_ENTRY ResourceEntry;
    USHORT n, half;
    LONG dir;
    ULONG size;
    ULONG_PTR ResourceIdRetry;
    ULONG RetryCount;
    LANGID NewLangId;
    const ULONG_PTR* IdPath = ResourceIdPath;
    ULONG IdPathLength = ResourceIdPathLength;
    BOOLEAN fIsNeutral = FALSE;
    LANGID GivenLanguage;

    RTL_PAGED_CODE();

    try {
        TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData(DllHandle,
                                         TRUE,
                                         IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                         &size
                                         );
        if (!TopResourceDirectory) {
            return( STATUS_RESOURCE_DATA_NOT_FOUND );
        }

        ResourceDirectory = TopResourceDirectory;
        ResourceIdRetry = USE_FIRSTAVAILABLE_LANGID;
        RetryCount = 0;
        ResourceEntry = NULL;
        LanguageResourceDirectory = NULL;
        while (ResourceDirectory != NULL && ResourceIdPathLength--) {
            //
            // If search path includes a language id, then attempt to
            // match the following language ids in this order:
            //
            //   (0)  use given language id
            //   (1)  use primary language of given language id
            //   (2)  use id 0  (neutral resource)
            //   (4)  use user UI language
            //
            // If the PRIMARY language id is ZERO, then ALSO attempt to
            // match the following language ids in this order:
            //
            //   (3)  use thread language id for console app
            //   (4)  use user UI language
            //   (5)  use lang id of TEB for windows app if it is different from user locale
            //   (6)  use UI lang from exe resource
            //   (7)  use primary UI lang from exe resource
            //   (8)  use Install Language
            //   (9)  use lang id from user's locale id
            //   (10)  use primary language of user's locale id
            //   (11) use lang id from system default locale id
            //   (12) use lang id of system default locale id
            //   (13) use primary language of system default locale id
            //   (14) use US English lang id
            //   (15) use any lang id that matches requested info
            //
            if (ResourceIdPathLength == 0 && IdPathLength == 3) {
                LanguageResourceDirectory = ResourceDirectory;
                }

            if (LanguageResourceDirectory != NULL) {
                GivenLanguage = (LANGID)IdPath[ 2 ];
                fIsNeutral = (PRIMARYLANGID( GivenLanguage ) == LANG_NEUTRAL);
TryNextLangId:
                switch( RetryCount++ ) {
                    case 0:     // Use given language id
                        NewLangId = GivenLanguage;
                        break;

                    case 1:     // Use primary language of given language id
                        NewLangId = PRIMARYLANGID( GivenLanguage );
                        break;

                    case 2:     // Use id 0  (neutral resource)
                        NewLangId = 0;
                        break;

                    case 3:     // Use user's default UI language
                        NewLangId = (LANGID)ResourceIdRetry;
                        break;

                    case 4:     // Use native UI language
                        if ( !fIsNeutral ) {
                            // Stop looking - Not in the neutral case
                            goto ReturnFailure;
                            break;
                        }
                        NewLangId = PsInstallUILanguageId;
                        break;

                    case 5:     // Use default system locale
                        NewLangId = LANGIDFROMLCID(PsDefaultSystemLocaleId);
                        break;

                    case 6:
                        // Use US English language
                        NewLangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
                        break;

                    case 7:     // Take any lang id that matches
                        NewLangId = USE_FIRSTAVAILABLE_LANGID;
                        break;

                    default:    // No lang ids to match
                        goto ReturnFailure;
                        break;
                }

                //
                // If looking for a specific language id and same as the
                // one we just looked up, then skip it.
                //
                if (NewLangId != USE_FIRSTAVAILABLE_LANGID &&
                    NewLangId == ResourceIdRetry
                   ) {
                    goto TryNextLangId;
                    }

                //
                // Try this new language Id
                //
                ResourceIdRetry = (ULONG_PTR)NewLangId;
                ResourceIdPath = &ResourceIdRetry;
                ResourceDirectory = LanguageResourceDirectory;
                }

            n = ResourceDirectory->NumberOfNamedEntries;
            ResourceDirEntLow = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
            if (!(*ResourceIdPath & LDR_RESOURCE_ID_NAME_MASK)) { // No string(name),so we need ID
                ResourceDirEntLow += n;
                n = ResourceDirectory->NumberOfIdEntries;
                }

            if (!n) {
                ResourceDirectory = NULL;
                goto NotFound;  // Resource directory contains zero types or names or langID.
                }

            if (LanguageResourceDirectory != NULL &&
                *ResourceIdPath == USE_FIRSTAVAILABLE_LANGID
               ) {
                ResourceDirectory = NULL;
                ResourceIdRetry = ResourceDirEntLow->Name;
                ResourceEntry = (PIMAGE_RESOURCE_DATA_ENTRY)
                    ((PCHAR)TopResourceDirectory +
                            ResourceDirEntLow->OffsetToData
                    );

                break;
                }

            ResourceDirectory = NULL;
            ResourceDirEntHigh = ResourceDirEntLow + n - 1;
            while (ResourceDirEntLow <= ResourceDirEntHigh) {
                if ((half = (n >> 1)) != 0) {
                    ResourceDirEntMiddle = ResourceDirEntLow;
                    if (*(PUCHAR)&n & 1) {
                        ResourceDirEntMiddle += half;
                        }
                    else {
                        ResourceDirEntMiddle += half - 1;
                        }
                    dir = LdrpCompareResourceNames_U( *ResourceIdPath,
                                                      TopResourceDirectory,
                                                      ResourceDirEntMiddle
                                                    );
                    if (!dir) {
                        if (ResourceDirEntMiddle->DataIsDirectory) {
                            ResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
                    ((PCHAR)TopResourceDirectory +
                                    ResourceDirEntMiddle->OffsetToDirectory
                                );
                            }
                        else {
                            ResourceDirectory = NULL;
                            ResourceEntry = (PIMAGE_RESOURCE_DATA_ENTRY)
                                ((PCHAR)TopResourceDirectory +
                                 ResourceDirEntMiddle->OffsetToData
                                );
                            }

                        break;
                        }
                    else {
                        if (dir < 0) {  // Order in the resource: Name, ID.
                            ResourceDirEntHigh = ResourceDirEntMiddle - 1;
                            if (*(PUCHAR)&n & 1) {
                                n = half;
                                }
                            else {
                                n = half - 1;
                                }
                            }
                        else {
                            ResourceDirEntLow = ResourceDirEntMiddle + 1;
                            n = half;
                            }
                        }
                    }
                else {
                    if (n != 0) {
                        dir = LdrpCompareResourceNames_U( *ResourceIdPath,
                          TopResourceDirectory,
                                                          ResourceDirEntLow
                                                        );
                        if (!dir) {   // find, or it fail to set ResourceDirectory so go to NotFound.
                            if (ResourceDirEntLow->DataIsDirectory) {
                                ResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
                                    ((PCHAR)TopResourceDirectory +
                                        ResourceDirEntLow->OffsetToDirectory
                                    );
                                }
                            else {
                                ResourceEntry = (PIMAGE_RESOURCE_DATA_ENTRY)
                                    ((PCHAR)TopResourceDirectory +
                      ResourceDirEntLow->OffsetToData
                                    );
                                }
                            }
                        }

                    break;
                    }
                }

            ResourceIdPath++;
            }

        if (ResourceEntry != NULL && !(Flags & LDRP_FIND_RESOURCE_DIRECTORY)) {
            *ResourceDirectoryOrData = (PVOID)ResourceEntry;
            Status = STATUS_SUCCESS;
            }
        else
        if (ResourceDirectory != NULL && (Flags & LDRP_FIND_RESOURCE_DIRECTORY)) {
            *ResourceDirectoryOrData = (PVOID)ResourceDirectory;
            Status = STATUS_SUCCESS;
            }
        else {
NotFound:
            switch( IdPathLength - ResourceIdPathLength) {
                case 3:     Status = STATUS_RESOURCE_LANG_NOT_FOUND; break;
                case 2:     Status = STATUS_RESOURCE_NAME_NOT_FOUND; break;
                case 1:     Status = STATUS_RESOURCE_TYPE_NOT_FOUND; break;
                default:    Status = STATUS_INVALID_PARAMETER; break;
                }
            }

        if (Status == STATUS_RESOURCE_LANG_NOT_FOUND &&
            LanguageResourceDirectory != NULL
           ) {
            ResourceEntry = NULL;
            goto TryNextLangId;
ReturnFailure: ;
            Status = STATUS_RESOURCE_LANG_NOT_FOUND;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    return Status;
}


NTSTATUS
LdrEnumResources(
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN OUT PULONG NumberOfResources,
    OUT PLDR_ENUM_RESOURCE_ENTRY Resources OPTIONAL
    )
{
    NTSTATUS Status;
    PIMAGE_RESOURCE_DIRECTORY TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY TypeResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY NameResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY LangResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY TypeResourceDirectoryEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY NameResourceDirectoryEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY LangResourceDirectoryEntry;
    ULONG TypeDirectoryIndex, NumberOfTypeDirectoryEntries;
    ULONG NameDirectoryIndex, NumberOfNameDirectoryEntries;
    ULONG LangDirectoryIndex, NumberOfLangDirectoryEntries;
    BOOLEAN ScanTypeDirectory;
    BOOLEAN ScanNameDirectory;
    BOOLEAN ReturnThisResource;
    PIMAGE_RESOURCE_DIR_STRING_U ResourceNameString;
    ULONG_PTR TypeResourceNameOrId;
    ULONG_PTR NameResourceNameOrId;
    ULONG_PTR LangResourceNameOrId;
    PLDR_ENUM_RESOURCE_ENTRY ResourceInfo;
    PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry;
    ULONG ResourceIndex, MaxResourceIndex;
    ULONG Size;

    ResourceIndex = 0;
    if (!ARGUMENT_PRESENT( Resources )) {
        MaxResourceIndex = 0;
        }
    else {
        MaxResourceIndex = *NumberOfResources;
        }
    *NumberOfResources = 0;

    TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
        RtlImageDirectoryEntryToData( DllHandle,
                                      TRUE,
                                      IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                      &Size
                                    );
    if (!TopResourceDirectory) {
        return STATUS_RESOURCE_DATA_NOT_FOUND;
        }

    TypeResourceDirectory = TopResourceDirectory;
    TypeResourceDirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(TypeResourceDirectory+1);
    NumberOfTypeDirectoryEntries = TypeResourceDirectory->NumberOfNamedEntries +
                                   TypeResourceDirectory->NumberOfIdEntries;
    TypeDirectoryIndex = 0;
    Status = STATUS_SUCCESS;
    for (TypeDirectoryIndex=0;
         TypeDirectoryIndex<NumberOfTypeDirectoryEntries;
         TypeDirectoryIndex++, TypeResourceDirectoryEntry++
        ) {
        if (ResourceIdPathLength > 0) {
            ScanTypeDirectory = LdrpCompareResourceNames_U( ResourceIdPath[ 0 ],
                                                            TopResourceDirectory,
                                                            TypeResourceDirectoryEntry
                                                          ) == 0;
            }
        else {
            ScanTypeDirectory = TRUE;
            }
        if (ScanTypeDirectory) {
            if (!TypeResourceDirectoryEntry->DataIsDirectory) {
                return STATUS_INVALID_IMAGE_FORMAT;
                }
            if (TypeResourceDirectoryEntry->NameIsString) {
                ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                    ((PCHAR)TopResourceDirectory + TypeResourceDirectoryEntry->NameOffset);

                TypeResourceNameOrId = (ULONG_PTR)ResourceNameString;
                }
            else {
                TypeResourceNameOrId = (ULONG_PTR)TypeResourceDirectoryEntry->Id;
                }

            NameResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
                ((PCHAR)TopResourceDirectory + TypeResourceDirectoryEntry->OffsetToDirectory);
            NameResourceDirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(NameResourceDirectory+1);
            NumberOfNameDirectoryEntries = NameResourceDirectory->NumberOfNamedEntries +
                                           NameResourceDirectory->NumberOfIdEntries;
            for (NameDirectoryIndex=0;
                 NameDirectoryIndex<NumberOfNameDirectoryEntries;
                 NameDirectoryIndex++, NameResourceDirectoryEntry++
                ) {
                if (ResourceIdPathLength > 1) {
                    ScanNameDirectory = LdrpCompareResourceNames_U( ResourceIdPath[ 1 ],
                                                                    TopResourceDirectory,
                                                                    NameResourceDirectoryEntry
                                                                  ) == 0;
                    }
                else {
                    ScanNameDirectory = TRUE;
                    }
                if (ScanNameDirectory) {
                    if (!NameResourceDirectoryEntry->DataIsDirectory) {
                        return STATUS_INVALID_IMAGE_FORMAT;
                        }

                    if (NameResourceDirectoryEntry->NameIsString) {
                        ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                            ((PCHAR)TopResourceDirectory + NameResourceDirectoryEntry->NameOffset);

                        NameResourceNameOrId = (ULONG_PTR)ResourceNameString;
                        }
                    else {
                        NameResourceNameOrId = (ULONG_PTR)NameResourceDirectoryEntry->Id;
                        }

                    LangResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
                        ((PCHAR)TopResourceDirectory + NameResourceDirectoryEntry->OffsetToDirectory);

                    LangResourceDirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(LangResourceDirectory+1);
                    NumberOfLangDirectoryEntries = LangResourceDirectory->NumberOfNamedEntries +
                                                   LangResourceDirectory->NumberOfIdEntries;
                    LangDirectoryIndex = 0;
                    for (LangDirectoryIndex=0;
                         LangDirectoryIndex<NumberOfLangDirectoryEntries;
                         LangDirectoryIndex++, LangResourceDirectoryEntry++
                        ) {
                        if (ResourceIdPathLength > 2) {
                            ReturnThisResource = LdrpCompareResourceNames_U( ResourceIdPath[ 2 ],
                                                                             TopResourceDirectory,
                                                                             LangResourceDirectoryEntry
                                                                           ) == 0;
                            }
                        else {
                            ReturnThisResource = TRUE;
                            }
                        if (ReturnThisResource) {
                            if (LangResourceDirectoryEntry->DataIsDirectory) {
                                return STATUS_INVALID_IMAGE_FORMAT;
                                }

                            if (LangResourceDirectoryEntry->NameIsString) {
                                ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                                    ((PCHAR)TopResourceDirectory + LangResourceDirectoryEntry->NameOffset);

                                LangResourceNameOrId = (ULONG_PTR)ResourceNameString;
                                }
                            else {
                                LangResourceNameOrId = (ULONG_PTR)LangResourceDirectoryEntry->Id;
                                }

                            ResourceDataEntry = (PIMAGE_RESOURCE_DATA_ENTRY)
                                    ((PCHAR)TopResourceDirectory + LangResourceDirectoryEntry->OffsetToData);

                            ResourceInfo = &Resources[ ResourceIndex++ ];
                            if (ResourceIndex <= MaxResourceIndex) {
                                ResourceInfo->Path[ 0 ].NameOrId = TypeResourceNameOrId;
                                ResourceInfo->Path[ 1 ].NameOrId = NameResourceNameOrId;
                                ResourceInfo->Path[ 2 ].NameOrId = LangResourceNameOrId;
                                ResourceInfo->Data = (PVOID)((ULONG_PTR)DllHandle + ResourceDataEntry->OffsetToData);
                                ResourceInfo->Size = ResourceDataEntry->Size;
                                ResourceInfo->Reserved = 0;
                                }
                            else {
                                Status = STATUS_INFO_LENGTH_MISMATCH;
                                }
                            }
                        }
                    }
                }
            }
        }

    *NumberOfResources = ResourceIndex;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\lookup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lookup.c

Abstract:

    This module implements function table lookup for platforms with table
    base exception handling.

--*/

#include "ntrtlp.h"

//
// Define external data.
//

#if !defined(_X86_)
#pragma alloc_text(INIT, RtlInitializeHistoryTable)
#endif

//
// Define global unwind history table to hold the constant unwind entries
// for exception dispatch followed by unwind.
//

#if !defined(_X86_)

UNWIND_HISTORY_TABLE RtlpUnwindHistoryTable = {
    0, UNWIND_HISTORY_TABLE_NONE, - 1, 0};

VOID
RtlInitializeHistoryTable (
    VOID
    )

/*++

Routine Description:

    This function initializes the global unwind history table.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64 BeginAddress;
    ULONG64 ControlPc;
    ULONG64 EndAddress;
    PVOID *FunctionAddressTable;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG64 Gp;
    ULONG64 ImageBase;
    ULONG Index;

    //
    // Lookup function entries from the function address table until a NULL
    // entry is encountered or the unwind history table is full.
    //

    FunctionAddressTable = &RtlpFunctionAddressTable[0];
    Index = 0;
    while ((Index < UNWIND_HISTORY_TABLE_SIZE) &&
           (*FunctionAddressTable != NULL)) {

        ControlPc = (ULONG64)*FunctionAddressTable++;
        FunctionEntry = RtlLookupFunctionEntry(ControlPc,
                                               &ImageBase,
                                               NULL
                                               );

        ASSERT(FunctionEntry != NULL);

        BeginAddress = FunctionEntry->BeginAddress + ImageBase;
        EndAddress = FunctionEntry->EndAddress + ImageBase;
        RtlpUnwindHistoryTable.Entry[Index].ImageBase = ImageBase;

        RtlpUnwindHistoryTable.Entry[Index].FunctionEntry = FunctionEntry;
        if (BeginAddress < RtlpUnwindHistoryTable.LowAddress) {
            RtlpUnwindHistoryTable.LowAddress = BeginAddress;
        }

        if (EndAddress > RtlpUnwindHistoryTable.HighAddress) {
            RtlpUnwindHistoryTable.HighAddress = EndAddress;
        }

        Index += 1;
    }

    RtlpUnwindHistoryTable.Count = Index;
    return;
}

PRUNTIME_FUNCTION
RtlpSearchInvertedFunctionTable (
    PINVERTED_FUNCTION_TABLE InvertedTable,
    PVOID ControlPc,
    OUT PVOID *ImageBase,
    OUT PULONG SizeOfTable
    )

/*++

Routine Description:

    This function searches for a matching entry in an inverted function
    table using the specified control PC value.

    N.B. It is assumed that appropriate locks are held when this routine
         is called.

Arguments:

    InvertedTable - Supplies a pointer to an inverted function table.

    ControlPc - Supplies a PC value to to use in searching the inverted
        function table.

    ImageBase - Supplies a pointer to a variable that receives the base
         address of the corresponding module.

    SizeOfTable - Supplies a pointer to a variable that receives the size
         of the function table in bytes.

Return Value:

    If a matching entry is located in the specified function table, then
    the function table address is returned as the function value. Otherwise,
    a value of NULL is returned.

--*/

{

    PVOID Bound;
    LONG High;
    ULONG Index;
    PINVERTED_FUNCTION_TABLE_ENTRY InvertedEntry;
    LONG Low;
    LONG Middle;

    //
    // If there are any entries in the specified inverted function table,
    // then search the table for a matching entry.
    //

    if (InvertedTable->CurrentSize != 0) {
        Low = 0;
        High = InvertedTable->CurrentSize - 1;
        while (High >= Low) {

            //
            // Compute next probe index and test entry. If the specified
            // control PC is greater than of equal to the beginning address
            // and less than the ending address of the inverted function
            // table entry, then return the address of the function table.
            // Otherwise, continue the search.
            //

            Middle = (Low + High) >> 1;
            InvertedEntry = &InvertedTable->TableEntry[Middle];
            Bound = (PVOID)((ULONG_PTR)InvertedEntry->ImageBase + InvertedEntry->SizeOfImage);
            if (ControlPc < InvertedEntry->ImageBase) {
                High = Middle - 1;

            } else if (ControlPc >= Bound) {
                Low = Middle + 1;

            } else {
                *ImageBase = InvertedEntry->ImageBase;
                *SizeOfTable = InvertedEntry->SizeOfTable;
                return InvertedEntry->FunctionTable;
            }
        }
    }

    return NULL;
}

#endif

VOID
RtlCaptureImageExceptionValues (
    IN  PVOID Base,
    OUT PVOID *FunctionTable,
    OUT PULONG TableSize
    )

/*++

Routine Description:

    This function queries the image exception information.

Arguments:

    Base - Supplies the base address of the image.

    FunctionTable - Supplies a pointer to a variable that receives the address
        of the function table, if any.

    Gp - Supplies a pointer to a variable that receives the GP pointer value,
        if any.

    TableSize - Supplies a pointer to a variable that receives the size of the
        function table, if any.

Return Value:

    None.

--*/

{

#if defined(_X86_)

    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_LOAD_CONFIG_DIRECTORY32 LoadConfig;
    ULONG LoadConfigSize;

    NtHeaders = RtlImageNtHeader(Base);
    if (NtHeaders->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NO_SEH) {

        //
        // SEH is not possible.
        //

        *FunctionTable = (PCHAR)LongToPtr(-1);
        *TableSize = (ULONG)-1;

    } else {
        LoadConfig = (PIMAGE_LOAD_CONFIG_DIRECTORY32)
                         RtlImageDirectoryEntryToData(Base,
                                                      TRUE,
                                                      IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                      &LoadConfigSize);
        if (LoadConfig && 
            (LoadConfigSize == 0x40) &&     // 0x40 is what Win2k expects - anything else is an error.
            LoadConfig->Size >= RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY32, SEHandlerCount) &&
            LoadConfig->SEHandlerTable &&
            LoadConfig->SEHandlerCount) {

            *FunctionTable = (PVOID)LoadConfig->SEHandlerTable;
            *TableSize = LoadConfig->SEHandlerCount;

        } else {

            //
            // Check iof the image is an ILONLY COR image.
            //

            PIMAGE_COR20_HEADER Cor20Header;
            ULONG Cor20HeaderSize;
            Cor20Header = RtlImageDirectoryEntryToData(Base,
                                                       TRUE,
                                                       IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                                       &Cor20HeaderSize);

            if (Cor20Header && ((Cor20Header->Flags & COMIMAGE_FLAGS_ILONLY) == COMIMAGE_FLAGS_ILONLY)) {
        
                //
                // SEH is not possible.
                //
        
                *FunctionTable = (PCHAR)LongToPtr(-1);
                *TableSize = (ULONG)-1;

            } else {
                *FunctionTable = 0;
                *TableSize = 0;
            }
        }
    }

#else

    *FunctionTable = RtlImageDirectoryEntryToData(Base,
                                                 TRUE,
                                                 IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                                                 TableSize);
#endif

}

#if defined(_X86_)

PVOID

#else

PRUNTIME_FUNCTION

#endif

RtlLookupFunctionTable (
    IN PVOID ControlPc,
    OUT PVOID *ImageBase,
    OUT PULONG SizeOfTable
    )

/*++

Routine Description:

    This function looks up the control PC in the loaded module list, and
    returns the image base, the size of the function table, and the address
    of the function table.

Arguments:

    ControlPc - Supplies an address in the module to be looked up.

    ImageBase - Supplies a pointer to a variable that receives the base
         address of the corresponding module.

    SizeOfTable - Supplies a pointer to a variable that receives the size
         of the function table in bytes.

Return Value:

    If a module is found that contains the specified control PC value and
    that module contains a function table, then the address of the function
    table is returned as the function value. Otherwise, NULL is returned.

--*/

{
    PVOID Base;
    ULONG_PTR Bound;

    PKLDR_DATA_TABLE_ENTRY Entry;

    PLIST_ENTRY Next;

#if defined(_X86_)

    PVOID FunctionTable;

#else

    PRUNTIME_FUNCTION FunctionTable;

#endif

    KIRQL OldIrql;

    //
    // Acquire the loaded module list spinlock and scan the list for the
    // specified PC value if the list has been initialized.
    //

    OldIrql = KeGetCurrentIrql();
    if (OldIrql < SYNCH_LEVEL) {
        KeRaiseIrqlToSynchLevel();
    }

    ExAcquireSpinLockAtDpcLevel(&PsLoadedModuleSpinLock);

#ifndef _X86_

    FunctionTable = RtlpSearchInvertedFunctionTable(&PsInvertedFunctionTable,
                                                    ControlPc,
                                                    &Base,
                                                    SizeOfTable);

    if ((FunctionTable == NULL) &&
        (PsInvertedFunctionTable.Overflow != FALSE))

#endif

    {
        Next = PsLoadedModuleList.Flink;
        if (Next != NULL) {
            while (Next != &PsLoadedModuleList) {
                Entry = CONTAINING_RECORD(Next,
                                          KLDR_DATA_TABLE_ENTRY,
                                          InLoadOrderLinks);
    
                Base = Entry->DllBase;
                Bound = (ULONG_PTR)Base + Entry->SizeOfImage;
                if (((ULONG_PTR)ControlPc >= (ULONG_PTR)Base) &&
                    ((ULONG_PTR)ControlPc < Bound)) {
                    FunctionTable = Entry->ExceptionTable;
                    *SizeOfTable = Entry->ExceptionTableSize;
                    break;
                }

                Next = Next->Flink;
            }
        }
    }

    //
    // Release the loaded module list spin lock.
    //

    ExReleaseSpinLockFromDpcLevel(&PsLoadedModuleSpinLock);
    KeLowerIrql(OldIrql);

    //
    // Set the image base address and return the function table address.
    //

    *ImageBase = Base;
    return FunctionTable;
}

#if !defined(_X86_)

VOID
RtlInsertInvertedFunctionTable (
    PINVERTED_FUNCTION_TABLE InvertedTable,
    PVOID ImageBase,
    ULONG SizeOfImage
    )

/*++

Routine Description:

    This function inserts an entry in an inverted function table if there
    is room in the table. Otherwise, no operation is performed.

    N.B. It is assumed that appropriate locks are held when this routine
         is called.

    N.B. If the inverted function table overflows, then it is treated as
         a cache. This is unlikely to happen, however.

Arguments:

    InvertedTable - Supplies a pointer to the inverted function table in
        which the specified entry is to be inserted.

    ImageBase - Supplies the base address of the containing image.

    SizeOfImage - Supplies the size of the image.

Return Value:

    None.

--*/

{

    ULONG CurrentSize;
    PRUNTIME_FUNCTION FunctionTable;
    ULONG Index;
    ULONG SizeOfTable;

    //
    // If the inverted table is not full, then insert the entry in the
    // specified inverted table.
    //

    CurrentSize = InvertedTable->CurrentSize;
    if (CurrentSize != InvertedTable->MaximumSize) {

        //
        // If the inverted table has no entries, then insert the new entry as
        // the first entry. Otherwise, search the inverted table for the proper
        // insert position, shuffle the table, and insert the new entry.
        //
    
        Index = 0;
        if (CurrentSize != 0) {
            for (Index = 0; Index < CurrentSize; Index += 1) {
                if (ImageBase < InvertedTable->TableEntry[Index].ImageBase) {
                    break;
                }
            }

            //
            // If the new entry does not go at the end of the specified table,
            // then shuffle the table down to make room for the new entry.
            //

            if (Index != CurrentSize) {
                RtlMoveMemory(&InvertedTable->TableEntry[Index + 1],
                              &InvertedTable->TableEntry[Index],
                              (CurrentSize - Index) * sizeof(INVERTED_FUNCTION_TABLE_ENTRY));
            }
        }
    
        //
        // Insert the specified entry in the specified inverted function table.
        //
    
        FunctionTable = RtlImageDirectoryEntryToData (ImageBase,
                                                      TRUE,
                                                      IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                                                      &SizeOfTable);

        InvertedTable->TableEntry[Index].FunctionTable = FunctionTable;
        InvertedTable->TableEntry[Index].ImageBase = ImageBase;
        InvertedTable->TableEntry[Index].SizeOfImage = SizeOfImage;
        InvertedTable->TableEntry[Index].SizeOfTable = SizeOfTable;
        InvertedTable->CurrentSize += 1;

    } else {
        InvertedTable->Overflow = TRUE;
    }

    return;
}

VOID
RtlRemoveInvertedFunctionTable (
    PINVERTED_FUNCTION_TABLE InvertedTable,
    PVOID ImageBase
    )

/*++

Routine Description:

    This routine removes an entry from an inverted function table.

    N.B. It is assumed that appropriate locks are held when this routine
         is called.

Arguments:

    InvertedTable - Supplies a pointer to the inverted function table from
        which the specified entry is to be removed.

    ImageBase - Supplies the base address of the containing image. 

Return Value:

    None.

--*/

{

    ULONG CurrentSize;
    ULONG Index;

    //
    // Search for an entry in the specified inverted table that matches the
    // image base.
    //
    // N.B. It is possible a matching entry is not in the inverted table
    //      the table was full when an attempt was made to insert the
    //      corresponding entry.
    //

    CurrentSize = InvertedTable->CurrentSize;
    for (Index = 0; Index < CurrentSize; Index += 1) {
        if (ImageBase == InvertedTable->TableEntry[Index].ImageBase) {
            break;
        }
    }

    //
    // If the entry was found in the inverted table, then remove the entry
    // and reduce the size of the table.
    //

    if (Index != CurrentSize) {

        //
        // If the size of the table is not one, then shuffle the table and
        // remove the specified entry.
        //
    
        if (CurrentSize != 1) {
            RtlMoveMemory(&InvertedTable->TableEntry[Index],
                          &InvertedTable->TableEntry[Index + 1],
                          (CurrentSize - Index - 1) * sizeof(INVERTED_FUNCTION_TABLE_ENTRY));
        }
    
        //
        // Reduce the size of the inverted table.
        //
    
        InvertedTable->CurrentSize -= 1;
    }

    return;
}

#endif      // !_X86_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\message.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    message.c

Abstract:

    Message table resource accessing functions

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,RtlFindMessage)
#endif

NTSTATUS
RtlFindMessage(
    IN PVOID DllHandle,
    IN ULONG MessageTableId,
    IN ULONG MessageLanguageId,
    IN ULONG MessageId,
    OUT PMESSAGE_RESOURCE_ENTRY *MessageEntry
    )
{
    NTSTATUS Status;
    ULONG NumberOfBlocks;
    ULONG EntryIndex;
    PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry;
    PMESSAGE_RESOURCE_DATA  MessageData;
    PMESSAGE_RESOURCE_BLOCK MessageBlock;
    PCHAR s;
    ULONG_PTR ResourceIdPath[ 3 ];

    RTL_PAGED_CODE();

    ResourceIdPath[ 0 ] = MessageTableId;
    ResourceIdPath[ 1 ] = 1;
    ResourceIdPath[ 2 ] = MessageLanguageId;

    Status = LdrpSearchResourceSection_U( DllHandle,
                                          ResourceIdPath,
                                          3,
                                          0,
                                          (PVOID *)&ResourceDataEntry
                                        );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    Status = LdrpAccessResourceData( DllHandle,
                                     ResourceDataEntry,
                                     (PVOID *)&MessageData,
                                     NULL
                                   );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    NumberOfBlocks = MessageData->NumberOfBlocks;
    MessageBlock = &MessageData->Blocks[ 0 ];
    while (NumberOfBlocks--) {
        if (MessageId >= MessageBlock->LowId &&
            MessageId <= MessageBlock->HighId
           ) {
            s = (PCHAR)MessageData + MessageBlock->OffsetToEntries;
            EntryIndex = MessageId - MessageBlock->LowId;
            while (EntryIndex--) {
                s += ((PMESSAGE_RESOURCE_ENTRY)s)->Length;
                }

            *MessageEntry = (PMESSAGE_RESOURCE_ENTRY)s;
            return( STATUS_SUCCESS );
            }

        MessageBlock++;
        }

    return( STATUS_MESSAGE_NOT_FOUND );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\pctohdr.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    pctohdr.c

Abstract:

    This module implements code to locate the file header for an image or
    dll given a PC value that lies within the image.

    N.B. This routine is conditionalized for user mode and kernel mode.

--*/

#include "ntos.h"

PVOID
RtlPcToFileHeader(
    IN PVOID PcValue,
    OUT PVOID *BaseOfImage
    )

/*++

Routine Description:

    This function returns the base of an image that contains the
    specified PcValue. An image contains the PcValue if the PcValue
    is within the ImageBase, and the ImageBase plus the size of the
    virtual image.

Arguments:

    PcValue - Supplies a PcValue.  All of the modules mapped into the
        calling processes address space are scanned to compute which
        module contains the PcValue.

    BaseOfImage - Returns the base address for the image containing the
        PcValue.  This value must be added to any relative addresses in
        the headers to locate portions of the image.

Return Value:

    NULL - No image was found that contains the PcValue.

    NON-NULL - Returns the base address of the image that contain the
        PcValue.

--*/

{
    extern LIST_ENTRY PsLoadedModuleList;
    extern KSPIN_LOCK PsLoadedModuleSpinLock;

    PVOID Base;
    ULONG_PTR Bounds;
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Next;
    KIRQL OldIrql;

    //
    // Acquire the loaded module list spinlock and scan the list for the
    // specified PC value if the list has been initialized.
    //

    OldIrql = KeGetCurrentIrql();
    if (OldIrql < SYNCH_LEVEL) {
        KeRaiseIrqlToSynchLevel();
    }

    ExAcquireSpinLockAtDpcLevel(&PsLoadedModuleSpinLock);
    Next = PsLoadedModuleList.Flink;
    if (Next != NULL) {
        while (Next != &PsLoadedModuleList) {
            Entry = CONTAINING_RECORD(Next,
                                      LDR_DATA_TABLE_ENTRY,
                                      InLoadOrderLinks);

            Next = Next->Flink;
            Base = Entry->DllBase;
            Bounds = (ULONG_PTR)Base + Entry->SizeOfImage;
            if (((ULONG_PTR)PcValue >= (ULONG_PTR)Base) && ((ULONG_PTR)PcValue < Bounds)) {
                ExReleaseSpinLockFromDpcLevel(&PsLoadedModuleSpinLock);
                KeLowerIrql(OldIrql);
                *BaseOfImage = Base;
                return Base;
            }
        }
    }

    //
    // Release the loaded module list spin lock and return NULL.
    //

    ExReleaseSpinLockFromDpcLevel(&PsLoadedModuleSpinLock);
    KeLowerIrql(OldIrql);
    *BaseOfImage = NULL;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\nlsxlat.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:
    nlsxlat.c

Abstract:

    This modules contains the private routines for character translation:
    8-bit <=> Unicode.

--*/

#include "ntrtlp.h"


VOID
RtlpInitUpcaseTable(
    IN PUSHORT TableBase,
    OUT PNLSTABLEINFO CodePageTable
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,RtlConsoleMultiByteToUnicodeN)
#pragma alloc_text(PAGE,RtlMultiByteToUnicodeN)
#pragma alloc_text(PAGE,RtlOemToUnicodeN)
#pragma alloc_text(PAGE,RtlUnicodeToMultiByteN)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeToMultiByteN)
#pragma alloc_text(PAGE,RtlUnicodeToOemN)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeToOemN)
#pragma alloc_text(PAGE,RtlpDidUnicodeToOemWork)
#pragma alloc_text(PAGE,RtlCustomCPToUnicodeN)
#pragma alloc_text(PAGE,RtlUnicodeToCustomCPN)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeToCustomCPN)
#pragma alloc_text(PAGE,RtlInitCodePageTable)
#pragma alloc_text(PAGE,RtlpInitUpcaseTable)
#pragma alloc_text(PAGE,RtlInitNlsTables)
#pragma alloc_text(PAGE,RtlResetRtlTranslations)
#pragma alloc_text(PAGE,RtlMultiByteToUnicodeSize)
#pragma alloc_text(PAGE,RtlUnicodeToMultiByteSize)
#pragma alloc_text(PAGE,RtlGetDefaultCodePage)
#endif



//
// Various defines and convenient macros for data access
//

#define DBCS_TABLE_SIZE 256


/*
 * Global data used by the translation routines.
 *
 */

#if defined(ALLOC_DATA_PRAGMA)
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif

//
// Upcase and Lowercase data
//
PUSHORT Nls844UnicodeUpcaseTable = NULL;
PUSHORT Nls844UnicodeLowercaseTable = NULL;

//
// ACP related data
//
USHORT   NlsLeadByteInfoTable[DBCS_TABLE_SIZE] = {0}; // Lead byte info. for ACP
USHORT   NlsAnsiCodePage = 0;               // Default ANSI code page
USHORT   NlsOemCodePage = 0;                // Default OEM code page
const PUSHORT  NlsLeadByteInfo = NlsLeadByteInfoTable;
PUSHORT  NlsMbAnsiCodePageTables = NULL;   // Multibyte to Unicode translation tables
PUSHORT  NlsAnsiToUnicodeData = NULL;      // Ansi CP to Unicode translation table
PCH      NlsUnicodeToAnsiData = NULL;      // Unicode to Ansi CP translation table
PUSHORT  NlsUnicodeToMbAnsiData = NULL;    // Unicode to Multibyte Ansi CP translation table
BOOLEAN  NlsMbCodePageTag = FALSE;         // TRUE -> Multibyte ACP, FALSE -> Singlebyte ACP

//
// OEM related data
//
USHORT   NlsOemLeadByteInfoTable[DBCS_TABLE_SIZE] = {0}; // Lead byte info. for 0CP
const PUSHORT  NlsOemLeadByteInfo = NlsOemLeadByteInfoTable;
PUSHORT  NlsMbOemCodePageTables = NULL;       // OEM Multibyte to Unicode translation tables
PUSHORT  NlsOemToUnicodeData = NULL;          // Oem CP to Unicode translation table
PCH      NlsUnicodeToOemData = NULL;          // Unicode to Oem CP translation table
PUSHORT  NlsUnicodeToMbOemData = NULL;        // Unicode to Multibyte Oem CP translation table
BOOLEAN  NlsMbOemCodePageTag = FALSE;         // TRUE -> Multibyte OCP, FALSE -> Singlebyte OCP

//
// Default info taken from data files
//
USHORT   UnicodeDefaultChar = 0;

USHORT   OemDefaultChar = 0;
USHORT   OemTransUniDefaultChar = 0;

//
// Default info NOT taken from data files
//
#define UnicodeNull 0x0000



NTSTATUS
RtlConsoleMultiByteToUnicodeN(
    __out_bcount_part(MaxBytesInUnicodeString, *BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG MaxBytesInUnicodeString,
    __out_opt PULONG BytesInUnicodeString,
    __in_bcount(BytesInMultiByteString) PCH MultiByteString,
    __in ULONG BytesInMultiByteString,
    __out PULONG pdwSpecialChar )

/*++

Routine Description:

    This function is a superset of MultiByteToUnicode for the
    console.  It works just like the other, except it will detect
    if any characters were under 0x20.

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    ANSI Code Page (ACP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the ansi source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of MultiByteString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    MultiByteString - Supplies the ansi source string that is to be
        converted to unicode.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

    pdwSpecialChar - will be zero if non detected, else it will contain the
       approximate index (can be off by 32).

Return Value:

    SUCCESS - The conversion was successful.


--*/

{
    ULONG LoopCount;
    PUSHORT TranslateTable;
    ULONG MaxCharsInUnicodeString;

    RTL_PAGED_CODE();

    *pdwSpecialChar = 0;

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);

    if (!NlsMbCodePageTag) {

        LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
                     MaxCharsInUnicodeString : BytesInMultiByteString;

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = LoopCount * sizeof(WCHAR);

        TranslateTable = NlsAnsiToUnicodeData;  // used to help the mips compiler

        quick_copy:
            switch( LoopCount ) {
            default:
                if ((UCHAR)MultiByteString[0x1F] < 0x20)    goto  bad_case;
                UnicodeString[0x1F] = TranslateTable[(UCHAR)MultiByteString[0x1F]];
            case 0x1F:
                if ((UCHAR)MultiByteString[0x1E] < 0x20)    goto  bad_case;
                UnicodeString[0x1E] = TranslateTable[(UCHAR)MultiByteString[0x1E]];
            case 0x1E:
                if ((UCHAR)MultiByteString[0x1D] < 0x20)    goto  bad_case;
                UnicodeString[0x1D] = TranslateTable[(UCHAR)MultiByteString[0x1D]];
            case 0x1D:
                if ((UCHAR)MultiByteString[0x1C] < 0x20)    goto  bad_case;
                UnicodeString[0x1C] = TranslateTable[(UCHAR)MultiByteString[0x1C]];
            case 0x1C:
                if ((UCHAR)MultiByteString[0x1B] < 0x20)    goto  bad_case;
                UnicodeString[0x1B] = TranslateTable[(UCHAR)MultiByteString[0x1B]];
            case 0x1B:
                if ((UCHAR)MultiByteString[0x1A] < 0x20)    goto  bad_case;
                UnicodeString[0x1A] = TranslateTable[(UCHAR)MultiByteString[0x1A]];
            case 0x1A:
                if ((UCHAR)MultiByteString[0x19] < 0x20)    goto  bad_case;
                UnicodeString[0x19] = TranslateTable[(UCHAR)MultiByteString[0x19]];
            case 0x19:
                if ((UCHAR)MultiByteString[0x18] < 0x20)    goto  bad_case;
                UnicodeString[0x18] = TranslateTable[(UCHAR)MultiByteString[0x18]];
            case 0x18:
                if ((UCHAR)MultiByteString[0x17] < 0x20)    goto  bad_case;
                UnicodeString[0x17] = TranslateTable[(UCHAR)MultiByteString[0x17]];
            case 0x17:
                if ((UCHAR)MultiByteString[0x16] < 0x20)    goto  bad_case;
                UnicodeString[0x16] = TranslateTable[(UCHAR)MultiByteString[0x16]];
            case 0x16:
                if ((UCHAR)MultiByteString[0x15] < 0x20)    goto  bad_case;
                UnicodeString[0x15] = TranslateTable[(UCHAR)MultiByteString[0x15]];
            case 0x15:
                if ((UCHAR)MultiByteString[0x14] < 0x20)    goto  bad_case;
                UnicodeString[0x14] = TranslateTable[(UCHAR)MultiByteString[0x14]];
            case 0x14:
                if ((UCHAR)MultiByteString[0x13] < 0x20)    goto  bad_case;
                UnicodeString[0x13] = TranslateTable[(UCHAR)MultiByteString[0x13]];
            case 0x13:
                if ((UCHAR)MultiByteString[0x12] < 0x20)    goto  bad_case;
                UnicodeString[0x12] = TranslateTable[(UCHAR)MultiByteString[0x12]];
            case 0x12:
                if ((UCHAR)MultiByteString[0x11] < 0x20)    goto  bad_case;
                UnicodeString[0x11] = TranslateTable[(UCHAR)MultiByteString[0x11]];
            case 0x11:
                if ((UCHAR)MultiByteString[0x10] < 0x20)    goto  bad_case;
                UnicodeString[0x10] = TranslateTable[(UCHAR)MultiByteString[0x10]];
            case 0x10:
                if ((UCHAR)MultiByteString[0x0F] < 0x20)    goto  bad_case;
                UnicodeString[0x0F] = TranslateTable[(UCHAR)MultiByteString[0x0F]];
            case 0x0F:
                if ((UCHAR)MultiByteString[0x0E] < 0x20)    goto  bad_case;
                UnicodeString[0x0E] = TranslateTable[(UCHAR)MultiByteString[0x0E]];
            case 0x0E:
                if ((UCHAR)MultiByteString[0x0D] < 0x20)    goto  bad_case;
                UnicodeString[0x0D] = TranslateTable[(UCHAR)MultiByteString[0x0D]];
            case 0x0D:
                if ((UCHAR)MultiByteString[0x0C] < 0x20)    goto  bad_case;
                UnicodeString[0x0C] = TranslateTable[(UCHAR)MultiByteString[0x0C]];
            case 0x0C:
                if ((UCHAR)MultiByteString[0x0B] < 0x20)    goto  bad_case;
                UnicodeString[0x0B] = TranslateTable[(UCHAR)MultiByteString[0x0B]];
            case 0x0B:
                if ((UCHAR)MultiByteString[0x0A] < 0x20)    goto  bad_case;
                UnicodeString[0x0A] = TranslateTable[(UCHAR)MultiByteString[0x0A]];
            case 0x0A:
                if ((UCHAR)MultiByteString[0x09] < 0x20)    goto  bad_case;
                UnicodeString[0x09] = TranslateTable[(UCHAR)MultiByteString[0x09]];
            case 0x09:
                if ((UCHAR)MultiByteString[0x08] < 0x20)    goto  bad_case;
                UnicodeString[0x08] = TranslateTable[(UCHAR)MultiByteString[0x08]];
            case 0x08:
                if ((UCHAR)MultiByteString[0x07] < 0x20)    goto  bad_case;
                UnicodeString[0x07] = TranslateTable[(UCHAR)MultiByteString[0x07]];
            case 0x07:
                if ((UCHAR)MultiByteString[0x06] < 0x20)    goto  bad_case;
                UnicodeString[0x06] = TranslateTable[(UCHAR)MultiByteString[0x06]];
            case 0x06:
                if ((UCHAR)MultiByteString[0x05] < 0x20)    goto  bad_case;
                UnicodeString[0x05] = TranslateTable[(UCHAR)MultiByteString[0x05]];
            case 0x05:
                if ((UCHAR)MultiByteString[0x04] < 0x20)    goto  bad_case;
                UnicodeString[0x04] = TranslateTable[(UCHAR)MultiByteString[0x04]];
            case 0x04:
                if ((UCHAR)MultiByteString[0x03] < 0x20)    goto  bad_case;
                UnicodeString[0x03] = TranslateTable[(UCHAR)MultiByteString[0x03]];
            case 0x03:
                if ((UCHAR)MultiByteString[0x02] < 0x20)    goto  bad_case;
                UnicodeString[0x02] = TranslateTable[(UCHAR)MultiByteString[0x02]];
            case 0x02:
                if ((UCHAR)MultiByteString[0x01] < 0x20)    goto  bad_case;
                UnicodeString[0x01] = TranslateTable[(UCHAR)MultiByteString[0x01]];
            case 0x01:
                if ((UCHAR)MultiByteString[0x00] < 0x20)    goto  bad_case;
                UnicodeString[0x00] = TranslateTable[(UCHAR)MultiByteString[0x00]];
            case 0x00:
                ;
            }

            if ( LoopCount > 0x20 ) {
                LoopCount -= 0x20;
                UnicodeString += 0x20;
                MultiByteString += 0x20;

                goto  quick_copy;
            }
        /* end of copy... */
    } else {
        register USHORT Entry;

        PWCH UnicodeStringAnchor = UnicodeString;
        TranslateTable = (PUSHORT)NlsMbAnsiCodePageTables;

        //
        // The ACP is a multibyte code page.  Check each character
        // to see if it is a lead byte before doing the translation.
        //
        while (MaxCharsInUnicodeString && BytesInMultiByteString) {
            MaxCharsInUnicodeString--;
            BytesInMultiByteString--;
            if (NlsLeadByteInfo[*(PUCHAR)MultiByteString]) {
                //
                // Lead byte - Make sure there is a trail byte.  If not,
                // pass back a space rather than an error.  Some 3.x
                // applications pass incorrect strings and don't expect
                // to get an error.
                //
                if (BytesInMultiByteString == 0)
                {
                    *UnicodeString++ = UnicodeNull;
                    break;
                }

                //
                // Get the unicode character.
                //
                Entry = NlsLeadByteInfo[*(PUCHAR)MultiByteString++];
                *UnicodeString = (WCHAR)TranslateTable[ Entry + *(PUCHAR)MultiByteString++ ];
                UnicodeString++;

                //
                // Decrement count of bytes in multibyte string to account
                // for the double byte character.
                //
                BytesInMultiByteString--;
            } else {
                //
                // Single byte character.
                //
                if ((UCHAR)MultiByteString[0x00] < 0x20)
                    *pdwSpecialChar = 1;
                *UnicodeString++ = NlsAnsiToUnicodeData[*(PUCHAR)MultiByteString++];
            }
        }

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
    }

    return STATUS_SUCCESS;

    bad_case:
        //
        // this is a low probability case, so we optimized the loop.  If have a
        // special char, finish trans and notify caller.
        //
        *pdwSpecialChar = 1;
        return RtlMultiByteToUnicodeN(UnicodeString, MaxBytesInUnicodeString,
                NULL, MultiByteString, LoopCount);
}


NTSTATUS
RtlMultiByteToUnicodeN(
    __out_bcount_part(MaxBytesInUnicodeString, *BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG MaxBytesInUnicodeString,
    __out_opt PULONG BytesInUnicodeString,
    __in_bcount(BytesInMultiByteString) PCSTR MultiByteString,
    __in ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    ANSI Code Page (ACP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the ansi source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of MultiByteString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    MultiByteString - Supplies the ansi source string that is to be
        converted to unicode.  For single-byte character sets, this address
        CAN be the same as UnicodeString.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful.


--*/

{
    ULONG LoopCount;
    ULONG TmpCount;
    PUSHORT TranslateTable;
    ULONG MaxCharsInUnicodeString;

    RTL_PAGED_CODE();

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);
    if (!NlsMbCodePageTag) {

        LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
                     MaxCharsInUnicodeString : BytesInMultiByteString;

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = LoopCount * sizeof(WCHAR);

        TranslateTable = NlsAnsiToUnicodeData;  // used to help the mips compiler

        TmpCount = LoopCount & 0x1F;
        UnicodeString += (LoopCount - TmpCount);
        MultiByteString += (LoopCount - TmpCount);
        quick_copy:
            switch( TmpCount ) {
            default:
                UnicodeString[0x1F] = TranslateTable[(UCHAR)MultiByteString[0x1F]];
            case 0x1F:
                UnicodeString[0x1E] = TranslateTable[(UCHAR)MultiByteString[0x1E]];
            case 0x1E:
                UnicodeString[0x1D] = TranslateTable[(UCHAR)MultiByteString[0x1D]];
            case 0x1D:
                UnicodeString[0x1C] = TranslateTable[(UCHAR)MultiByteString[0x1C]];
            case 0x1C:
                UnicodeString[0x1B] = TranslateTable[(UCHAR)MultiByteString[0x1B]];
            case 0x1B:
                UnicodeString[0x1A] = TranslateTable[(UCHAR)MultiByteString[0x1A]];
            case 0x1A:
                UnicodeString[0x19] = TranslateTable[(UCHAR)MultiByteString[0x19]];
            case 0x19:
                UnicodeString[0x18] = TranslateTable[(UCHAR)MultiByteString[0x18]];
            case 0x18:
                UnicodeString[0x17] = TranslateTable[(UCHAR)MultiByteString[0x17]];
            case 0x17:
                UnicodeString[0x16] = TranslateTable[(UCHAR)MultiByteString[0x16]];
            case 0x16:
                UnicodeString[0x15] = TranslateTable[(UCHAR)MultiByteString[0x15]];
            case 0x15:
                UnicodeString[0x14] = TranslateTable[(UCHAR)MultiByteString[0x14]];
            case 0x14:
                UnicodeString[0x13] = TranslateTable[(UCHAR)MultiByteString[0x13]];
            case 0x13:
                UnicodeString[0x12] = TranslateTable[(UCHAR)MultiByteString[0x12]];
            case 0x12:
                UnicodeString[0x11] = TranslateTable[(UCHAR)MultiByteString[0x11]];
            case 0x11:
                UnicodeString[0x10] = TranslateTable[(UCHAR)MultiByteString[0x10]];
            case 0x10:
                UnicodeString[0x0F] = TranslateTable[(UCHAR)MultiByteString[0x0F]];
            case 0x0F:
                UnicodeString[0x0E] = TranslateTable[(UCHAR)MultiByteString[0x0E]];
            case 0x0E:
                UnicodeString[0x0D] = TranslateTable[(UCHAR)MultiByteString[0x0D]];
            case 0x0D:
                UnicodeString[0x0C] = TranslateTable[(UCHAR)MultiByteString[0x0C]];
            case 0x0C:
                UnicodeString[0x0B] = TranslateTable[(UCHAR)MultiByteString[0x0B]];
            case 0x0B:
                UnicodeString[0x0A] = TranslateTable[(UCHAR)MultiByteString[0x0A]];
            case 0x0A:
                UnicodeString[0x09] = TranslateTable[(UCHAR)MultiByteString[0x09]];
            case 0x09:
                UnicodeString[0x08] = TranslateTable[(UCHAR)MultiByteString[0x08]];
            case 0x08:
                UnicodeString[0x07] = TranslateTable[(UCHAR)MultiByteString[0x07]];
            case 0x07:
                UnicodeString[0x06] = TranslateTable[(UCHAR)MultiByteString[0x06]];
            case 0x06:
                UnicodeString[0x05] = TranslateTable[(UCHAR)MultiByteString[0x05]];
            case 0x05:
                UnicodeString[0x04] = TranslateTable[(UCHAR)MultiByteString[0x04]];
            case 0x04:
                UnicodeString[0x03] = TranslateTable[(UCHAR)MultiByteString[0x03]];
            case 0x03:
                UnicodeString[0x02] = TranslateTable[(UCHAR)MultiByteString[0x02]];
            case 0x02:
                UnicodeString[0x01] = TranslateTable[(UCHAR)MultiByteString[0x01]];
            case 0x01:
                UnicodeString[0x00] = TranslateTable[(UCHAR)MultiByteString[0x00]];
            case 0x00:
                ;
            }

            if ( LoopCount >= 0x20 ) {
                TmpCount = 0x20;
                LoopCount -= 0x20;
                UnicodeString -= 0x20;
                MultiByteString -= 0x20;

                goto  quick_copy;
            }
        /* end of copy... */
    } else {
        register USHORT Entry;
        PWCH UnicodeStringAnchor = UnicodeString;
        TranslateTable = (PUSHORT)NlsMbAnsiCodePageTables;

        //
        // The ACP is a multibyte code page.  Check each character
        // to see if it is a lead byte before doing the translation.
        //
        while (MaxCharsInUnicodeString && BytesInMultiByteString) {
            MaxCharsInUnicodeString--;
            BytesInMultiByteString--;
            if (NlsLeadByteInfo[*(PUCHAR)MultiByteString]) {
                //
                // Lead byte - Make sure there is a trail byte.  If not,
                // pass back a space rather than an error.  Some 3.x
                // applications pass incorrect strings and don't expect
                // to get an error.
                //
                if (BytesInMultiByteString == 0)
                {
                    *UnicodeString++ = UnicodeNull;
                    break;
                }

                //
                // Get the unicode character.
                //
                Entry = NlsLeadByteInfo[*(PUCHAR)MultiByteString++];
                *UnicodeString = (WCHAR)TranslateTable[ Entry + *(PUCHAR)MultiByteString++ ];
                UnicodeString++;

                //
                // Decrement count of bytes in multibyte string to account
                // for the double byte character.
                //
                BytesInMultiByteString--;
            } else {
                //
                // Single byte character.
                //
                *UnicodeString++ = NlsAnsiToUnicodeData[*(PUCHAR)MultiByteString++];
            }
        }

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlOemToUnicodeN(
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCH OemString,
    IN ULONG BytesInOemString)

/*++

Routine Description:

    This functions converts the specified oem source string into a
    Unicode string. The translation is done with respect to the
    OEM Code Page (OCP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the oem source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of OemString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    OemString - Supplies the oem source string that is to be
        converted to unicode.

    BytesInOemString - The number of bytes in the string pointed to
        by OemString.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_ILLEGAL_CHARACTER - The final Oem character was illegal

    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to hold
        the whole Oem string.  It was converted correct to the point though.

--*/

{
    ULONG LoopCount;
    PUSHORT TranslateTable;
    ULONG MaxCharsInUnicodeString;

    RTL_PAGED_CODE();

    // The OCP is a multibyte code page.  Check each character
    // to see if it is a lead byte before doing the translation.

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);

    if (!NlsMbOemCodePageTag) {

        LoopCount = (MaxCharsInUnicodeString < BytesInOemString) ?
                     MaxCharsInUnicodeString : BytesInOemString;

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = LoopCount * sizeof(WCHAR);


        TranslateTable = NlsOemToUnicodeData;  // used to help the mips compiler

        quick_copy:
            switch( LoopCount ) {
            default:
                UnicodeString[0x0F] = TranslateTable[(UCHAR)OemString[0x0F]];
            case 0x0F:
                UnicodeString[0x0E] = TranslateTable[(UCHAR)OemString[0x0E]];
            case 0x0E:
                UnicodeString[0x0D] = TranslateTable[(UCHAR)OemString[0x0D]];
            case 0x0D:
                UnicodeString[0x0C] = TranslateTable[(UCHAR)OemString[0x0C]];
            case 0x0C:
                UnicodeString[0x0B] = TranslateTable[(UCHAR)OemString[0x0B]];
            case 0x0B:
                UnicodeString[0x0A] = TranslateTable[(UCHAR)OemString[0x0A]];
            case 0x0A:
                UnicodeString[0x09] = TranslateTable[(UCHAR)OemString[0x09]];
            case 0x09:
                UnicodeString[0x08] = TranslateTable[(UCHAR)OemString[0x08]];
            case 0x08:
                UnicodeString[0x07] = TranslateTable[(UCHAR)OemString[0x07]];
            case 0x07:
                UnicodeString[0x06] = TranslateTable[(UCHAR)OemString[0x06]];
            case 0x06:
                UnicodeString[0x05] = TranslateTable[(UCHAR)OemString[0x05]];
            case 0x05:
                UnicodeString[0x04] = TranslateTable[(UCHAR)OemString[0x04]];
            case 0x04:
                UnicodeString[0x03] = TranslateTable[(UCHAR)OemString[0x03]];
            case 0x03:
                UnicodeString[0x02] = TranslateTable[(UCHAR)OemString[0x02]];
            case 0x02:
                UnicodeString[0x01] = TranslateTable[(UCHAR)OemString[0x01]];
            case 0x01:
                UnicodeString[0x00] = TranslateTable[(UCHAR)OemString[0x00]];
            case 0x00:
                ;
            }

            if ( LoopCount > 0x10 ) {
                LoopCount -= 0x10;
                OemString += 0x10;
                UnicodeString += 0x10;

                goto  quick_copy;
            }
        /* end of copy... */
    } else {
        register USHORT Entry;
        PWCH UnicodeStringAnchor = UnicodeString;

        TranslateTable = (PUSHORT)NlsMbOemCodePageTables;

        while (MaxCharsInUnicodeString && BytesInOemString) {
            MaxCharsInUnicodeString--;
            BytesInOemString--;
            if (NlsOemLeadByteInfo[*(PUCHAR)OemString]) {
                //
                // Lead byte - Make sure there is a trail byte.  If not,
                // pass back a space rather than an error.  Some 3.x
                // applications pass incorrect strings and don't expect
                // to get an error.
                //
                if (BytesInOemString == 0)
                {
                    *UnicodeString++ = UnicodeNull;
                    break;
                }

                //
                // Get the unicode character.
                //
                Entry = NlsOemLeadByteInfo[*(PUCHAR)OemString++];
                *UnicodeString = TranslateTable[ Entry + *(PUCHAR)OemString++ ];
                UnicodeString++;

                //
                // Decrement count of bytes in oem string to account
                // for the double byte character.
                //
                BytesInOemString--;
            } else {
                //
                // Single byte character.
                //
                *UnicodeString++ = NlsOemToUnicodeData[*(PUCHAR)OemString++];
            }
        }

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
    }

    //
    //  Check if we were able to use all of the source Oem String
    //
    return (BytesInOemString <= MaxCharsInUnicodeString) ?
           STATUS_SUCCESS :
           STATUS_BUFFER_OVERFLOW;
}


NTSTATUS
RtlMultiByteToUnicodeSize(
    OUT PULONG BytesInUnicodeString,
    IN PCSTR MultiByteString,
    IN ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions determines how many bytes would be needed to represent
    the specified ANSI source string in Unicode string (not counting the
    null terminator)
    The translation is done with respect to the ANSI Code Page (ACP) installed
    at boot time.  Single byte characters in the range 0x00 - 0x7f are simply
    zero extended as a performance enhancement.  In some far eastern code pages
    0x5c is defined as the Yen sign.  For system translation we always want to
    consider 0x5c to be the backslash character.  We get this for free by zero
    extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    BytesInUnicodeString - Returns the number of bytes a Unicode translation
        of the ANSI string pointed to by MultiByteString would contain.

    MultiByteString - Supplies the ansi source string whose Unicode length
        is to be calculated.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful


--*/

{
    ULONG cbUnicode = 0;

    RTL_PAGED_CODE();

    if (NlsMbCodePageTag) {
        //
        // The ACP is a multibyte code page.  Check each character
        // to see if it is a lead byte before doing the translation.
        //
        while (BytesInMultiByteString--) {
            if (NlsLeadByteInfo[*(PUCHAR)MultiByteString++]) {
                //
                // Lead byte - translate the trail byte using the table
                // that corresponds to this lead byte.  NOTE: make sure
                // we have a trail byte to convert.
                //
                if (BytesInMultiByteString == 0) {
                    //
                    // RtlMultibyteToUnicodeN() uses the unicode
                    // default character if the last multibyte
                    // character is a lead byte.
                    //
                    cbUnicode += sizeof(WCHAR);
                    break;
                } else {
                    BytesInMultiByteString--;
                    MultiByteString++;
                }
            }
            cbUnicode += sizeof(WCHAR);
        }
        *BytesInUnicodeString = cbUnicode;
    } else {
        //
        // The ACP is a single byte code page.
        //
        *BytesInUnicodeString = BytesInMultiByteString * sizeof(WCHAR);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUnicodeToMultiByteSize(
    __out PULONG BytesInMultiByteString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions determines how many bytes would be needed to represent
    the specified Unicode source string as an ANSI string (not counting the
    null terminator)

Arguments:

    BytesInMultiByteString - Returns the number of bytes an ANSI translation
        of the Unicode string pointed to by UnicodeString would contain.

    UnicodeString - Supplies the unicode source string whose ANSI length
        is to be calculated.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The conversion failed.  A unicode character was encountered
        that has no translation for the current ANSI Code Page (ACP).

--*/

{
    ULONG cbMultiByte = 0;
    ULONG CharsInUnicodeString;

    RTL_PAGED_CODE();

    /*
     * convert from bytes to chars for easier loop handling.
     */
    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    if (NlsMbCodePageTag) {
        USHORT MbChar;

        while (CharsInUnicodeString--) {
            MbChar = NlsUnicodeToMbAnsiData[ *UnicodeString++ ];
            if (HIBYTE(MbChar) == 0) {
                cbMultiByte++ ;
            } else {
                cbMultiByte += 2;
            }
        }
        *BytesInMultiByteString = cbMultiByte;
    }
    else {
        *BytesInMultiByteString = CharsInUnicodeString;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUnicodeToMultiByteN(
    __out_bcount_part(MaxBytesInMultiByteString, *BytesInMultiByteString) PCH MultiByteString,
    __in ULONG MaxBytesInMultiByteString,
    __out_opt PULONG BytesInMultiByteString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    PCH TranslateTable;
    ULONG CharsInUnicodeString;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    if (!NlsMbCodePageTag) {

        LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                     CharsInUnicodeString : MaxBytesInMultiByteString;

        if (ARGUMENT_PRESENT(BytesInMultiByteString))
            *BytesInMultiByteString = LoopCount;

        TranslateTable = NlsUnicodeToAnsiData;  // used to help the mips compiler

        TmpCount = LoopCount & 0x0F;
        UnicodeString += TmpCount;
        MultiByteString += TmpCount;

        do
        {
            switch( TmpCount ) {
            default:
                UnicodeString += 0x10;
                MultiByteString += 0x10;

                MultiByteString[-0x10] = TranslateTable[UnicodeString[-0x10]];
            case 0x0F:
                MultiByteString[-0x0F] = TranslateTable[UnicodeString[-0x0F]];
            case 0x0E:
                MultiByteString[-0x0E] = TranslateTable[UnicodeString[-0x0E]];
            case 0x0D:
                MultiByteString[-0x0D] = TranslateTable[UnicodeString[-0x0D]];
            case 0x0C:
                MultiByteString[-0x0C] = TranslateTable[UnicodeString[-0x0C]];
            case 0x0B:
                MultiByteString[-0x0B] = TranslateTable[UnicodeString[-0x0B]];
            case 0x0A:
                MultiByteString[-0x0A] = TranslateTable[UnicodeString[-0x0A]];
            case 0x09:
                MultiByteString[-0x09] = TranslateTable[UnicodeString[-0x09]];
            case 0x08:
                MultiByteString[-0x08] = TranslateTable[UnicodeString[-0x08]];
            case 0x07:
                MultiByteString[-0x07] = TranslateTable[UnicodeString[-0x07]];
            case 0x06:
                MultiByteString[-0x06] = TranslateTable[UnicodeString[-0x06]];
            case 0x05:
                MultiByteString[-0x05] = TranslateTable[UnicodeString[-0x05]];
            case 0x04:
                MultiByteString[-0x04] = TranslateTable[UnicodeString[-0x04]];
            case 0x03:
                MultiByteString[-0x03] = TranslateTable[UnicodeString[-0x03]];
            case 0x02:
                MultiByteString[-0x02] = TranslateTable[UnicodeString[-0x02]];
            case 0x01:
                MultiByteString[-0x01] = TranslateTable[UnicodeString[-0x01]];
            case 0x00:
                ;
            }

            LoopCount -= TmpCount;
            TmpCount = 0x10;
        } while ( LoopCount > 0 );

        /* end of copy... */
    } else {
        USHORT MbChar;
        PCH MultiByteStringAnchor = MultiByteString;

        while ( CharsInUnicodeString && MaxBytesInMultiByteString ) {

            MbChar = NlsUnicodeToMbAnsiData[ *UnicodeString++ ];
            if (HIBYTE(MbChar) != 0) {
                //
                // Need at least 2 bytes to copy a double byte char.
                // Don't want to truncate in the middle of a DBCS char.
                //
                if (MaxBytesInMultiByteString-- < 2) {
                    break;
                }
                *MultiByteString++ = HIBYTE(MbChar);  // lead byte
            }
            *MultiByteString++ = LOBYTE(MbChar);
            MaxBytesInMultiByteString--;

            CharsInUnicodeString--;
        }

        if (ARGUMENT_PRESENT(BytesInMultiByteString))
            *BytesInMultiByteString = (ULONG)(MultiByteString - MultiByteStringAnchor);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUpcaseUnicodeToMultiByteN(
    __out_bcount_part(MaxBytesInMultiByteString, *BytesInMultiByteString) PCH MultiByteString,
    __in ULONG MaxBytesInMultiByteString,
    __out_opt PULONG BytesInMultiByteString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    converts it into an ansi string. The translation is done with respect
    to the ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        upper case of the unicode source string.  If the translation can
        not be done, an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    PCH TranslateTable;
    ULONG CharsInUnicodeString;
    UCHAR SbChar;
    WCHAR UnicodeChar;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    if (!NlsMbCodePageTag) {

        LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                     CharsInUnicodeString : MaxBytesInMultiByteString;

        if (ARGUMENT_PRESENT(BytesInMultiByteString))
            *BytesInMultiByteString = LoopCount;

        TranslateTable = NlsUnicodeToAnsiData;  // used to help the mips compiler

        TmpCount = LoopCount & 0x0F;
        UnicodeString += TmpCount;
        MultiByteString += TmpCount;

        do
        {
            //
            // Convert to ANSI and back to Unicode before upper casing
            // to ensure the visual best fits are converted and
            // upper cased properly.
            //
            switch( TmpCount ) {
            default:
                UnicodeString += 0x10;
                MultiByteString += 0x10;

                SbChar = TranslateTable[UnicodeString[-0x10]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x10] = TranslateTable[UnicodeChar];
            case 0x0F:
                SbChar = TranslateTable[UnicodeString[-0x0F]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x0F] = TranslateTable[UnicodeChar];
            case 0x0E:
                SbChar = TranslateTable[UnicodeString[-0x0E]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x0E] = TranslateTable[UnicodeChar];
            case 0x0D:
                SbChar = TranslateTable[UnicodeString[-0x0D]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x0D] = TranslateTable[UnicodeChar];
            case 0x0C:
                SbChar = TranslateTable[UnicodeString[-0x0C]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x0C] = TranslateTable[UnicodeChar];
            case 0x0B:
                SbChar = TranslateTable[UnicodeString[-0x0B]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x0B] = TranslateTable[UnicodeChar];
            case 0x0A:
                SbChar = TranslateTable[UnicodeString[-0x0A]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x0A] = TranslateTable[UnicodeChar];
            case 0x09:
                SbChar = TranslateTable[UnicodeString[-0x09]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x09] = TranslateTable[UnicodeChar];
            case 0x08:
                SbChar = TranslateTable[UnicodeString[-0x08]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x08] = TranslateTable[UnicodeChar];
            case 0x07:
                SbChar = TranslateTable[UnicodeString[-0x07]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x07] = TranslateTable[UnicodeChar];
            case 0x06:
                SbChar = TranslateTable[UnicodeString[-0x06]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x06] = TranslateTable[UnicodeChar];
            case 0x05:
                SbChar = TranslateTable[UnicodeString[-0x05]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x05] = TranslateTable[UnicodeChar];
            case 0x04:
                SbChar = TranslateTable[UnicodeString[-0x04]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x04] = TranslateTable[UnicodeChar];
            case 0x03:
                SbChar = TranslateTable[UnicodeString[-0x03]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x03] = TranslateTable[UnicodeChar];
            case 0x02:
                SbChar = TranslateTable[UnicodeString[-0x02]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x02] = TranslateTable[UnicodeChar];
            case 0x01:
                SbChar = TranslateTable[UnicodeString[-0x01]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x01] = TranslateTable[UnicodeChar];
            case 0x00:
                ;
            }

            LoopCount -= TmpCount;
            TmpCount = 0x10;
        } while ( LoopCount > 0 );

        /* end of copy... */
    } else {
        USHORT MbChar;
        register USHORT Entry;
        PCH MultiByteStringAnchor = MultiByteString;

        while ( CharsInUnicodeString && MaxBytesInMultiByteString ) {
            //
            // Convert to ANSI and back to Unicode before upper casing
            // to ensure the visual best fits are converted and
            // upper cased properly.
            //
            MbChar = NlsUnicodeToMbAnsiData[ *UnicodeString++ ];
            if ( NlsLeadByteInfo[HIBYTE(MbChar)] ) {
                //
                // Lead byte - translate the trail byte using the table
                // that corresponds to this lead byte.
                //
                Entry = NlsLeadByteInfo[HIBYTE(MbChar)];
                UnicodeChar = (WCHAR)NlsMbAnsiCodePageTables[ Entry + LOBYTE(MbChar) ];
            } else {
                //
                // Single byte character.
                //
                UnicodeChar = NlsAnsiToUnicodeData[LOBYTE(MbChar)];
            }
            UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
            MbChar = NlsUnicodeToMbAnsiData[UnicodeChar];

            if (HIBYTE(MbChar) != 0) {
                //
                // Need at least 2 bytes to copy a double byte char.
                // Don't want to truncate in the middle of a DBCS char.
                //
                if (MaxBytesInMultiByteString-- < 2) {
                    break;
                }
                *MultiByteString++ = HIBYTE(MbChar);  // lead byte
            }
            *MultiByteString++ = LOBYTE(MbChar);
            MaxBytesInMultiByteString--;

            CharsInUnicodeString--;
        }

        if (ARGUMENT_PRESENT(BytesInMultiByteString))
            *BytesInMultiByteString = (ULONG)(MultiByteString - MultiByteStringAnchor);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUnicodeToOemN(
    __out_bcount_part(MaxBytesInOemString, *BytesInOemString) PCH OemString,
    __in ULONG MaxBytesInOemString,
    __out_opt PULONG BytesInOemString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    oem string. The translation is done with respect to the OEM Code
    Page (OCP) loaded at boot time.

Arguments:

    OemString - Returns an oem string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInOemString - Supplies the maximum number of bytes to be
        written to OemString.  If this causes OemString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInOemString - Returns the number of bytes in the returned
        oem string pointed to by OemString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to oem.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to hold
        the whole Oem string.  It was converted correct to the point though.

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    PCH TranslateTable;
    ULONG CharsInUnicodeString;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    if (!NlsMbOemCodePageTag) {

        LoopCount = (CharsInUnicodeString < MaxBytesInOemString) ?
                     CharsInUnicodeString : MaxBytesInOemString;

        if (ARGUMENT_PRESENT(BytesInOemString))
            *BytesInOemString = LoopCount;

        TranslateTable = NlsUnicodeToOemData;  // used to help the mips compiler

        TmpCount = LoopCount & 0x0F;
        UnicodeString += TmpCount;
        OemString += TmpCount;

        do
        {
            switch( TmpCount ) {
            default:
                UnicodeString += 0x10;
                OemString += 0x10;

                OemString[-0x10] = TranslateTable[UnicodeString[-0x10]];
            case 0x0F:
                OemString[-0x0F] = TranslateTable[UnicodeString[-0x0F]];
            case 0x0E:
                OemString[-0x0E] = TranslateTable[UnicodeString[-0x0E]];
            case 0x0D:
                OemString[-0x0D] = TranslateTable[UnicodeString[-0x0D]];
            case 0x0C:
                OemString[-0x0C] = TranslateTable[UnicodeString[-0x0C]];
            case 0x0B:
                OemString[-0x0B] = TranslateTable[UnicodeString[-0x0B]];
            case 0x0A:
                OemString[-0x0A] = TranslateTable[UnicodeString[-0x0A]];
            case 0x09:
                OemString[-0x09] = TranslateTable[UnicodeString[-0x09]];
            case 0x08:
                OemString[-0x08] = TranslateTable[UnicodeString[-0x08]];
            case 0x07:
                OemString[-0x07] = TranslateTable[UnicodeString[-0x07]];
            case 0x06:
                OemString[-0x06] = TranslateTable[UnicodeString[-0x06]];
            case 0x05:
                OemString[-0x05] = TranslateTable[UnicodeString[-0x05]];
            case 0x04:
                OemString[-0x04] = TranslateTable[UnicodeString[-0x04]];
            case 0x03:
                OemString[-0x03] = TranslateTable[UnicodeString[-0x03]];
            case 0x02:
                OemString[-0x02] = TranslateTable[UnicodeString[-0x02]];
            case 0x01:
                OemString[-0x01] = TranslateTable[UnicodeString[-0x01]];
            case 0x00:
                ;
            }

            LoopCount -= TmpCount;
            TmpCount = 0x10;
        } while ( LoopCount > 0 );

        /* end of copy... */
    } else {
        register USHORT MbChar;
        PCH OemStringAnchor = OemString;

        while ( CharsInUnicodeString && MaxBytesInOemString ) {

            MbChar = NlsUnicodeToMbOemData[ *UnicodeString++ ];
            if (HIBYTE(MbChar) != 0) {
                //
                // Need at least 2 bytes to copy a double byte char.
                // Don't want to truncate in the middle of a DBCS char.
                //
                if (MaxBytesInOemString-- < 2) {
                    break;
                }
                *OemString++ = HIBYTE(MbChar);  // lead byte
            }
            *OemString++ = LOBYTE(MbChar);
            MaxBytesInOemString--;

            CharsInUnicodeString--;
        }

        if (ARGUMENT_PRESENT(BytesInOemString))
            *BytesInOemString = (ULONG)(OemString - OemStringAnchor);
    }

    //
    //  Check if we were able to use all of the source Unicode String
    //
    return ( CharsInUnicodeString <= MaxBytesInOemString ) ?
           STATUS_SUCCESS :
           STATUS_BUFFER_OVERFLOW;
}


NTSTATUS
RtlUpcaseUnicodeToOemN(
    __out_bcount_part(MaxBytesInOemString, *BytesInOemString) PCH OemString,
    __in ULONG MaxBytesInOemString,
    __out_opt PULONG BytesInOemString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    converts it into an oem string. The translation is done with respect
    to the OEM Code Page (OCP) loaded at boot time.

Arguments:

    OemString - Returns an oem string that is equivalent to the upper
        case of the unicode source string.  If the translation can not
        be done, an error is returned.

    MaxBytesInOemString - Supplies the maximum number of bytes to be
        written to OemString.  If this causes OemString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInOemString - Returns the number of bytes in the returned
        oem string pointed to by OemString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to oem.

    BytesInUnicodeString - The number of bytes in the the string pointed
        to by UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to
        hold the whole Oem string.  It was converted correctly to that
        point, though.

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    PCH TranslateTable;
    ULONG CharsInUnicodeString;
    UCHAR SbChar;
    WCHAR UnicodeChar;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    if (!NlsMbOemCodePageTag) {

        LoopCount = (CharsInUnicodeString < MaxBytesInOemString) ?
                     CharsInUnicodeString : MaxBytesInOemString;

        if (ARGUMENT_PRESENT(BytesInOemString))
            *BytesInOemString = LoopCount;

        TranslateTable = NlsUnicodeToOemData;  // used to help the mips compiler

        TmpCount = LoopCount & 0x0F;
        UnicodeString += TmpCount;
        OemString += TmpCount;

        do
        {
            //
            // Convert to OEM and back to Unicode before upper casing
            // to ensure the visual best fits are converted and
            // upper cased properly.
            //
            switch( TmpCount ) {
            default:
                UnicodeString += 0x10;
                OemString += 0x10;

                SbChar = TranslateTable[UnicodeString[-0x10]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x10] = TranslateTable[UnicodeChar];
            case 0x0F:
                SbChar = TranslateTable[UnicodeString[-0x0F]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x0F] = TranslateTable[UnicodeChar];
            case 0x0E:
                SbChar = TranslateTable[UnicodeString[-0x0E]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x0E] = TranslateTable[UnicodeChar];
            case 0x0D:
                SbChar = TranslateTable[UnicodeString[-0x0D]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x0D] = TranslateTable[UnicodeChar];
            case 0x0C:
                SbChar = TranslateTable[UnicodeString[-0x0C]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x0C] = TranslateTable[UnicodeChar];
            case 0x0B:
                SbChar = TranslateTable[UnicodeString[-0x0B]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x0B] = TranslateTable[UnicodeChar];
            case 0x0A:
                SbChar = TranslateTable[UnicodeString[-0x0A]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x0A] = TranslateTable[UnicodeChar];
            case 0x09:
                SbChar = TranslateTable[UnicodeString[-0x09]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x09] = TranslateTable[UnicodeChar];
            case 0x08:
                SbChar = TranslateTable[UnicodeString[-0x08]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x08] = TranslateTable[UnicodeChar];
            case 0x07:
                SbChar = TranslateTable[UnicodeString[-0x07]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x07] = TranslateTable[UnicodeChar];
            case 0x06:
                SbChar = TranslateTable[UnicodeString[-0x06]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x06] = TranslateTable[UnicodeChar];
            case 0x05:
                SbChar = TranslateTable[UnicodeString[-0x05]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x05] = TranslateTable[UnicodeChar];
            case 0x04:
                SbChar = TranslateTable[UnicodeString[-0x04]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x04] = TranslateTable[UnicodeChar];
            case 0x03:
                SbChar = TranslateTable[UnicodeString[-0x03]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x03] = TranslateTable[UnicodeChar];
            case 0x02:
                SbChar = TranslateTable[UnicodeString[-0x02]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x02] = TranslateTable[UnicodeChar];
            case 0x01:
                SbChar = TranslateTable[UnicodeString[-0x01]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x01] = TranslateTable[UnicodeChar];
            case 0x00:
                ;
            }

            LoopCount -= TmpCount;
            TmpCount = 0x10;
        } while ( LoopCount > 0 );

        /* end of copy... */
    } else {
        USHORT MbChar;
        register USHORT Entry;
        PCH OemStringAnchor = OemString;

        while ( CharsInUnicodeString && MaxBytesInOemString ) {
            //
            // Convert to OEM and back to Unicode before upper casing
            // to ensure the visual best fits are converted and
            // upper cased properly.
            //
            MbChar = NlsUnicodeToMbOemData[ *UnicodeString++ ];
            if (NlsOemLeadByteInfo[HIBYTE(MbChar)]) {
                //
                // Lead byte - translate the trail byte using the table
                // that corresponds to this lead byte.
                //
                Entry = NlsOemLeadByteInfo[HIBYTE(MbChar)];
                UnicodeChar = (WCHAR)NlsMbOemCodePageTables[ Entry + LOBYTE(MbChar) ];
            } else {
                //
                // Single byte character.
                //
                UnicodeChar = NlsOemToUnicodeData[LOBYTE(MbChar)];
            }
            UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
            MbChar = NlsUnicodeToMbOemData[UnicodeChar];

            if (HIBYTE(MbChar) != 0) {
                //
                // Need at least 2 bytes to copy a double byte char.
                // Don't want to truncate in the middle of a DBCS char.
                //
                if (MaxBytesInOemString-- < 2) {
                    break;
                }
                *OemString++ = HIBYTE(MbChar);  // lead byte
            }
            *OemString++ = LOBYTE(MbChar);
            MaxBytesInOemString--;

            CharsInUnicodeString--;
        }

        if (ARGUMENT_PRESENT(BytesInOemString))
            *BytesInOemString = (ULONG)(OemString - OemStringAnchor);
    }

    //
    //  Check if we were able to use all of the source Unicode String
    //
    return ( CharsInUnicodeString <= MaxBytesInOemString ) ?
           STATUS_SUCCESS :
           STATUS_BUFFER_OVERFLOW;
}

BOOLEAN
RtlpDidUnicodeToOemWork(
    IN PCOEM_STRING OemString,
    IN PCUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This function looks for the default character in the Oem string, making
    sure it was not a correct translation from the Unicode source string.

    This allows us to test whether or not a translation was really successful.

Arguments:

    OemString - The result of conversion from the unicode string.

    UnicodeString - The source of the Oem string.

Return Value:

    TRUE if the Unicode to Oem translation caused no default characters to be
        inserted.  FALSE otherwise.

--*/

{
    ULONG OemOffset;
    BOOLEAN Result = TRUE;

    RTL_PAGED_CODE();

    if (!NlsMbOemCodePageTag) {

        for (OemOffset = 0;
             OemOffset < OemString->Length;
             OemOffset += 1) {

            if ((OemString->Buffer[OemOffset] == (UCHAR)OemDefaultChar) &&
                (UnicodeString->Buffer[OemOffset] != OemTransUniDefaultChar)) {

                Result = FALSE;
                break;
            }
        }

    } else {

        ULONG UnicodeOffset;

        for (OemOffset = 0, UnicodeOffset = 0;
             OemOffset < OemString->Length;
             OemOffset += 1, UnicodeOffset += 1) {

            //
            //  If we landed on a DBCS character handle it accordingly
            //

            if (NlsOemLeadByteInfo[(UCHAR)OemString->Buffer[OemOffset]]) {

                USHORT DbcsChar;

                ASSERT( OemOffset + 1 < OemString->Length );

                DbcsChar = (OemString->Buffer[OemOffset] << 8) + (UCHAR)OemString->Buffer[OemOffset+1];
                OemOffset++;

                if ((DbcsChar == OemDefaultChar) &&
                    (UnicodeString->Buffer[UnicodeOffset] != OemTransUniDefaultChar)) {

                    Result = FALSE;
                    break;
                }

                continue;
            }

            if ((OemString->Buffer[OemOffset] == (UCHAR)OemDefaultChar) &&
                (UnicodeString->Buffer[UnicodeOffset] != OemTransUniDefaultChar)) {

                Result = FALSE;
                break;
            }
        }
    }

    return Result;
}


NTSTATUS
RtlCustomCPToUnicodeN(
    __in PCPTABLEINFO CustomCP,
    __out_bcount_part(MaxBytesInUnicodeString, *BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG MaxBytesInUnicodeString,
    __out_opt PULONG BytesInUnicodeString,
    __in_bcount(BytesInCustomCPString) PCH CustomCPString,
    __in ULONG BytesInCustomCPString)

/*++

Routine Description:

    This functions converts the specified CustomCP source string into a
    Unicode string. The translation is done with respect to the
    CustomCP Code Page specified.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    CustomCP - Supplies the address of the code page that translations
        are done relative to

    UnicodeString - Returns a unicode string that is equivalent to
        the CustomCP source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of CustomCPString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    CustomCPString - Supplies the CustomCP source string that is to be
        converted to unicode.

    BytesInCustomCPString - The number of bytes in the string pointed to
        by CustomCPString.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_ILLEGAL_CHARACTER - The final CustomCP character was illegal

    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to hold
        the whole CustomCP string.  It was converted correct to the point though.

--*/

{
    ULONG LoopCount;
    PUSHORT TranslateTable;
    ULONG MaxCharsInUnicodeString;

    RTL_PAGED_CODE();

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);

    if (!(CustomCP->DBCSCodePage)) {
        //
        // The Custom CP is a single byte code page.
        //

        LoopCount = (MaxCharsInUnicodeString < BytesInCustomCPString) ?
                     MaxCharsInUnicodeString : BytesInCustomCPString;

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = LoopCount * sizeof(WCHAR);


        TranslateTable = CustomCP->MultiByteTable;

        quick_copy:
            switch( LoopCount ) {
            default:
                UnicodeString[0x0F] = TranslateTable[(UCHAR)CustomCPString[0x0F]];
            case 0x0F:
                UnicodeString[0x0E] = TranslateTable[(UCHAR)CustomCPString[0x0E]];
            case 0x0E:
                UnicodeString[0x0D] = TranslateTable[(UCHAR)CustomCPString[0x0D]];
            case 0x0D:
                UnicodeString[0x0C] = TranslateTable[(UCHAR)CustomCPString[0x0C]];
            case 0x0C:
                UnicodeString[0x0B] = TranslateTable[(UCHAR)CustomCPString[0x0B]];
            case 0x0B:
                UnicodeString[0x0A] = TranslateTable[(UCHAR)CustomCPString[0x0A]];
            case 0x0A:
                UnicodeString[0x09] = TranslateTable[(UCHAR)CustomCPString[0x09]];
            case 0x09:
                UnicodeString[0x08] = TranslateTable[(UCHAR)CustomCPString[0x08]];
            case 0x08:
                UnicodeString[0x07] = TranslateTable[(UCHAR)CustomCPString[0x07]];
            case 0x07:
                UnicodeString[0x06] = TranslateTable[(UCHAR)CustomCPString[0x06]];
            case 0x06:
                UnicodeString[0x05] = TranslateTable[(UCHAR)CustomCPString[0x05]];
            case 0x05:
                UnicodeString[0x04] = TranslateTable[(UCHAR)CustomCPString[0x04]];
            case 0x04:
                UnicodeString[0x03] = TranslateTable[(UCHAR)CustomCPString[0x03]];
            case 0x03:
                UnicodeString[0x02] = TranslateTable[(UCHAR)CustomCPString[0x02]];
            case 0x02:
                UnicodeString[0x01] = TranslateTable[(UCHAR)CustomCPString[0x01]];
            case 0x01:
                UnicodeString[0x00] = TranslateTable[(UCHAR)CustomCPString[0x00]];
            case 0x00:
                ;
            }

            if ( LoopCount > 0x10 ) {
                LoopCount -= 0x10;
                CustomCPString += 0x10;
                UnicodeString += 0x10;

                goto  quick_copy;
            }
        /* end of copy... */
    } else {
        register USHORT Entry;
        PWCH UnicodeStringAnchor = UnicodeString;
        PUSHORT NlsCustomLeadByteInfo = CustomCP->DBCSOffsets;

        //
        // The CP is a multibyte code page.  Check each character
        // to see if it is a lead byte before doing the translation.
        //
        TranslateTable = (PUSHORT)(CustomCP->DBCSOffsets);

        while (MaxCharsInUnicodeString && BytesInCustomCPString) {
            MaxCharsInUnicodeString--;
            BytesInCustomCPString--;
            if (NlsCustomLeadByteInfo[*(PUCHAR)CustomCPString]) {
                //
                // Lead byte - Make sure there is a trail byte.  If not,
                // pass back a space rather than an error.  Some 3.x
                // applications pass incorrect strings and don't expect
                // to get an error.
                //
                if (BytesInCustomCPString == 0)
                {
                    *UnicodeString++ = UnicodeNull;
                    break;
                }

                //
                // Get the unicode character.
                //
                Entry = NlsCustomLeadByteInfo[*(PUCHAR)CustomCPString++];
                *UnicodeString = TranslateTable[ Entry + *(PUCHAR)CustomCPString++ ];
                UnicodeString++;

                //
                // Decrement count of bytes in multibyte string to account
                // for the double byte character.
                //
                BytesInCustomCPString--;
            } else {
                //
                // Single byte character.
                //
                *UnicodeString++ = (CustomCP->MultiByteTable)[*(PUCHAR)CustomCPString++];
            }
        }

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
    }

    //
    //  Check if we were able to use all of the source CustomCP String
    //
    return ( BytesInCustomCPString <= MaxCharsInUnicodeString ) ?
           STATUS_SUCCESS :
           STATUS_BUFFER_OVERFLOW;
}


NTSTATUS
RtlUnicodeToCustomCPN(
    __in PCPTABLEINFO CustomCP,
    __out_bcount_part(MaxBytesInCustomCPString, *BytesInCustomCPString) PCH CustomCPString,
    __in ULONG MaxBytesInCustomCPString,
    __out_opt PULONG BytesInCustomCPString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    CustomCP string.  The translation is done with respect to the
    CustomCP Code Page specified by CustomCp.

Arguments:

    CustomCP - Supplies the address of the code page that translations
        are done relative to

    CustomCPString - Returns an CustomCP string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInCustomCPString - Supplies the maximum number of bytes to be
        written to CustomCPString.  If this causes CustomCPString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInCustomCPString - Returns the number of bytes in the returned
        CustomCP string pointed to by CustomCPString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to CustomCP.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to hold
        the whole CustomCP string.  It was converted correct to the point though.

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    PCH TranslateTable;
    PUSHORT WideTranslateTable;
    ULONG CharsInUnicodeString;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    if (!(CustomCP->DBCSCodePage)) {

        LoopCount = (CharsInUnicodeString < MaxBytesInCustomCPString) ?
                     CharsInUnicodeString : MaxBytesInCustomCPString;

        if (ARGUMENT_PRESENT(BytesInCustomCPString))
            *BytesInCustomCPString = LoopCount;

        TranslateTable = CustomCP->WideCharTable;

        TmpCount = LoopCount & 0x0F;
        UnicodeString += TmpCount;
        CustomCPString += TmpCount;

        do
        {
            switch( TmpCount ) {
            default:
                UnicodeString += 0x10;
                CustomCPString += 0x10;

                CustomCPString[-0x10] = TranslateTable[UnicodeString[-0x10]];
            case 0x0F:
                CustomCPString[-0x0F] = TranslateTable[UnicodeString[-0x0F]];
            case 0x0E:
                CustomCPString[-0x0E] = TranslateTable[UnicodeString[-0x0E]];
            case 0x0D:
                CustomCPString[-0x0D] = TranslateTable[UnicodeString[-0x0D]];
            case 0x0C:
                CustomCPString[-0x0C] = TranslateTable[UnicodeString[-0x0C]];
            case 0x0B:
                CustomCPString[-0x0B] = TranslateTable[UnicodeString[-0x0B]];
            case 0x0A:
                CustomCPString[-0x0A] = TranslateTable[UnicodeString[-0x0A]];
            case 0x09:
                CustomCPString[-0x09] = TranslateTable[UnicodeString[-0x09]];
            case 0x08:
                CustomCPString[-0x08] = TranslateTable[UnicodeString[-0x08]];
            case 0x07:
                CustomCPString[-0x07] = TranslateTable[UnicodeString[-0x07]];
            case 0x06:
                CustomCPString[-0x06] = TranslateTable[UnicodeString[-0x06]];
            case 0x05:
                CustomCPString[-0x05] = TranslateTable[UnicodeString[-0x05]];
            case 0x04:
                CustomCPString[-0x04] = TranslateTable[UnicodeString[-0x04]];
            case 0x03:
                CustomCPString[-0x03] = TranslateTable[UnicodeString[-0x03]];
            case 0x02:
                CustomCPString[-0x02] = TranslateTable[UnicodeString[-0x02]];
            case 0x01:
                CustomCPString[-0x01] = TranslateTable[UnicodeString[-0x01]];
            case 0x00:
                ;
            }

            LoopCount -= TmpCount;
            TmpCount = 0x10;
        } while ( LoopCount > 0 );

        /* end of copy... */
    } else {
        USHORT MbChar;
        PCH CustomCPStringAnchor = CustomCPString;

        WideTranslateTable = CustomCP->WideCharTable;

        while (CharsInUnicodeString && MaxBytesInCustomCPString) {

            MbChar = WideTranslateTable[ *UnicodeString++ ];
            if (HIBYTE(MbChar) != 0) {
                //
                // Need at least 2 bytes to copy a double byte char.
                // Don't want to truncate in the middle of a DBCS char.
                //
                if (MaxBytesInCustomCPString-- < 2) {
                    break;
                }
                *CustomCPString++ = HIBYTE(MbChar);  // lead byte
            }
            *CustomCPString++ = LOBYTE(MbChar);
            MaxBytesInCustomCPString--;

            CharsInUnicodeString--;
        }

        if (ARGUMENT_PRESENT(BytesInCustomCPString))
            *BytesInCustomCPString = (ULONG)(CustomCPString - CustomCPStringAnchor);
    }

    //
    //  Check if we were able to use all of the source Unicode String
    //
    return ( CharsInUnicodeString <= MaxBytesInCustomCPString ) ?
           STATUS_SUCCESS :
           STATUS_BUFFER_OVERFLOW;
}


NTSTATUS
RtlUpcaseUnicodeToCustomCPN(
    __in PCPTABLEINFO CustomCP,
    __out_bcount_part(MaxBytesInCustomCPString, *BytesInCustomCPString) PCH CustomCPString,
    __in ULONG MaxBytesInCustomCPString,
    __out_opt PULONG BytesInCustomCPString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    converts it into a CustomCP string.  The translation is done with
    respect to the CustomCP Code Page specified by CustomCp.

Arguments:

    CustomCP - Supplies the address of the code page that translations
        are done relative to

    CustomCPString - Returns an CustomCP string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInCustomCPString - Supplies the maximum number of bytes to be
        written to CustomCPString.  If this causes CustomCPString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInCustomCPString - Returns the number of bytes in the returned
        CustomCP string pointed to by CustomCPString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to CustomCP.

    BytesInUnicodeString - The number of bytes in the the string pointed
        to by UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to
        hold the whole CustomCP string.  It was converted correctly to
        that point, though.

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    PCH TranslateTable;
    PUSHORT WideTranslateTable;
    ULONG CharsInUnicodeString;
    UCHAR SbChar;
    WCHAR UnicodeChar;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    if (!(CustomCP->DBCSCodePage)) {

        LoopCount = (CharsInUnicodeString < MaxBytesInCustomCPString) ?
                     CharsInUnicodeString : MaxBytesInCustomCPString;

        if (ARGUMENT_PRESENT(BytesInCustomCPString))
            *BytesInCustomCPString = LoopCount;

        TranslateTable = CustomCP->WideCharTable;

        TmpCount = LoopCount & 0x0F;
        UnicodeString += TmpCount;
        CustomCPString += TmpCount;

        do
        {
            //
            // Convert to Single Byte and back to Unicode before upper
            // casing to ensure the visual best fits are converted and
            // upper cased properly.
            //
            switch( TmpCount ) {
            default:
                UnicodeString += 0x10;
                CustomCPString += 0x10;

                SbChar = TranslateTable[UnicodeString[-0x10]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x10] = TranslateTable[UnicodeChar];
            case 0x0F:
                SbChar = TranslateTable[UnicodeString[-0x0F]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x0F] = TranslateTable[UnicodeChar];
            case 0x0E:
                SbChar = TranslateTable[UnicodeString[-0x0E]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x0E] = TranslateTable[UnicodeChar];
            case 0x0D:
                SbChar = TranslateTable[UnicodeString[-0x0D]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x0D] = TranslateTable[UnicodeChar];
            case 0x0C:
                SbChar = TranslateTable[UnicodeString[-0x0C]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x0C] = TranslateTable[UnicodeChar];
            case 0x0B:
                SbChar = TranslateTable[UnicodeString[-0x0B]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x0B] = TranslateTable[UnicodeChar];
            case 0x0A:
                SbChar = TranslateTable[UnicodeString[-0x0A]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x0A] = TranslateTable[UnicodeChar];
            case 0x09:
                SbChar = TranslateTable[UnicodeString[-0x09]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x09] = TranslateTable[UnicodeChar];
            case 0x08:
                SbChar = TranslateTable[UnicodeString[-0x08]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x08] = TranslateTable[UnicodeChar];
            case 0x07:
                SbChar = TranslateTable[UnicodeString[-0x07]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x07] = TranslateTable[UnicodeChar];
            case 0x06:
                SbChar = TranslateTable[UnicodeString[-0x06]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x06] = TranslateTable[UnicodeChar];
            case 0x05:
                SbChar = TranslateTable[UnicodeString[-0x05]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x05] = TranslateTable[UnicodeChar];
            case 0x04:
                SbChar = TranslateTable[UnicodeString[-0x04]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x04] = TranslateTable[UnicodeChar];
            case 0x03:
                SbChar = TranslateTable[UnicodeString[-0x03]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x03] = TranslateTable[UnicodeChar];
            case 0x02:
                SbChar = TranslateTable[UnicodeString[-0x02]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x02] = TranslateTable[UnicodeChar];
            case 0x01:
                SbChar = TranslateTable[UnicodeString[-0x01]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x01] = TranslateTable[UnicodeChar];
            case 0x00:
                ;
            }

            LoopCount -= TmpCount;
            TmpCount = 0x10;
        } while ( LoopCount > 0 );

        /* end of copy... */
    } else {
        USHORT MbChar;
        register USHORT Entry;
        PCH CustomCPStringAnchor = CustomCPString;
        PUSHORT NlsCustomLeadByteInfo = CustomCP->DBCSOffsets;

        WideTranslateTable = CustomCP->WideCharTable;

        while ( CharsInUnicodeString && MaxBytesInCustomCPString ) {
            //
            // Convert to Single Byte and back to Unicode before upper
            // casing to ensure the visual best fits are converted and
            // upper cased properly.
            //
            MbChar = WideTranslateTable[ *UnicodeString++ ];
            if (NlsCustomLeadByteInfo[HIBYTE(MbChar)]) {
                //
                // Lead byte - translate the trail byte using the table
                // that corresponds to this lead byte.
                //
                Entry = NlsCustomLeadByteInfo[HIBYTE(MbChar)];
                UnicodeChar = NlsCustomLeadByteInfo[ Entry + LOBYTE(MbChar) ];
            } else {
                //
                // Single byte character.
                //
                UnicodeChar = (CustomCP->MultiByteTable)[LOBYTE(MbChar)];
            }
            UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
            MbChar = WideTranslateTable[UnicodeChar];

            if (HIBYTE(MbChar) != 0) {
                //
                // Need at least 2 bytes to copy a double byte char.
                // Don't want to truncate in the middle of a DBCS char.
                //
                if (MaxBytesInCustomCPString-- < 2) {
                    break;
                }
                *CustomCPString++ = HIBYTE(MbChar);  // lead byte
            }
            *CustomCPString++ = LOBYTE(MbChar);
            MaxBytesInCustomCPString--;

            CharsInUnicodeString--;
        }

        if (ARGUMENT_PRESENT(BytesInCustomCPString))
            *BytesInCustomCPString = (ULONG)(CustomCPString - CustomCPStringAnchor);
    }

    //
    //  Check if we were able to use all of the source Unicode String
    //
    return ( CharsInUnicodeString <= MaxBytesInCustomCPString ) ?
           STATUS_SUCCESS :
           STATUS_BUFFER_OVERFLOW;
}

#define MB_TBL_SIZE      256             /* size of MB tables */
#define GLYPH_TBL_SIZE   MB_TBL_SIZE     /* size of GLYPH tables */
#define DBCS_TBL_SIZE    256             /* size of DBCS tables */
#define GLYPH_HEADER     1               /* size of GLYPH table header */
#define DBCS_HEADER      1               /* size of DBCS table header */
#define LANG_HEADER      1               /* size of LANGUAGE file header */
#define UP_HEADER        1               /* size of UPPERCASE table header */
#define LO_HEADER        1               /* size of LOWERCASE table header */

VOID
RtlInitCodePageTable(
    IN PUSHORT TableBase,
    OUT PCPTABLEINFO CodePageTable
    )
{
    USHORT offMB;
    USHORT offWC;
    PUSHORT pGlyph;
    PUSHORT pRange;

    RTL_PAGED_CODE();

    //
    // Get the offsets.
    //

    offMB = TableBase[0];
    offWC = offMB + TableBase[offMB];


    //
    // Attach Code Page Info to CP hash node.
    //

    CodePageTable->CodePage = TableBase[1];
    CodePageTable->MaximumCharacterSize = TableBase[2];
    CodePageTable->DefaultChar = TableBase[3];           // default character (MB)
    CodePageTable->UniDefaultChar = TableBase[4];        // default character (Unicode)
    CodePageTable->TransDefaultChar = TableBase[5];      // trans of default char (Unicode)
    CodePageTable->TransUniDefaultChar = TableBase[6];   // trans of Uni default char (MB)
    RtlCopyMemory(
        &CodePageTable->LeadByte,
        &TableBase[7],
        MAXIMUM_LEADBYTES
        );
    CodePageTable->MultiByteTable = (TableBase + offMB + 1);

    pGlyph = CodePageTable->MultiByteTable + MB_TBL_SIZE;

    if (pGlyph[0] != 0) {
        pRange = CodePageTable->DBCSRanges = pGlyph + GLYPH_HEADER + GLYPH_TBL_SIZE;
        }
    else {
        pRange = CodePageTable->DBCSRanges = pGlyph + GLYPH_HEADER;
        }

    //
    //  Attach DBCS information to CP hash node.
    //

    if (pRange[0] > 0) {
        CodePageTable->DBCSOffsets = pRange + DBCS_HEADER;
        CodePageTable->DBCSCodePage = 1;
        }
    else {
        CodePageTable->DBCSCodePage = 0;
        CodePageTable->DBCSOffsets = NULL;
        }

    CodePageTable->WideCharTable = (TableBase + offWC + 1);
}


VOID
RtlpInitUpcaseTable(
    IN PUSHORT TableBase,
    OUT PNLSTABLEINFO CodePageTable
    )
{
    USHORT offUP;
    USHORT offLO;

    //
    // Get the offsets.
    //

    offUP = LANG_HEADER;
    offLO = offUP + TableBase[offUP];

    CodePageTable->UpperCaseTable = TableBase + offUP + UP_HEADER;
    CodePageTable->LowerCaseTable = TableBase + offLO + LO_HEADER;
}


VOID
RtlInitNlsTables(
    IN PUSHORT AnsiNlsBase,
    IN PUSHORT OemNlsBase,
    IN PUSHORT LanguageNlsBase,
    OUT PNLSTABLEINFO TableInfo
    )
{
    RTL_PAGED_CODE();

    RtlInitCodePageTable(AnsiNlsBase,&TableInfo->AnsiTableInfo);
    RtlInitCodePageTable(OemNlsBase,&TableInfo->OemTableInfo);
    RtlpInitUpcaseTable(LanguageNlsBase,TableInfo);
}


VOID
RtlResetRtlTranslations(
    PNLSTABLEINFO TableInfo
    )
{
    RTL_PAGED_CODE();

    if ( TableInfo->AnsiTableInfo.DBCSCodePage ) {
        RtlCopyMemory(NlsLeadByteInfo,TableInfo->AnsiTableInfo.DBCSOffsets,DBCS_TBL_SIZE*sizeof(USHORT));
    } else {
        RtlZeroMemory(NlsLeadByteInfo,DBCS_TBL_SIZE*sizeof(USHORT));
    }

    NlsMbAnsiCodePageTables = (PUSHORT)TableInfo->AnsiTableInfo.DBCSOffsets;

    NlsAnsiToUnicodeData = TableInfo->AnsiTableInfo.MultiByteTable;
    NlsUnicodeToAnsiData = (PCH)TableInfo->AnsiTableInfo.WideCharTable;
    NlsUnicodeToMbAnsiData = (PUSHORT)TableInfo->AnsiTableInfo.WideCharTable;
    NlsMbCodePageTag = TableInfo->AnsiTableInfo.DBCSCodePage ? TRUE : FALSE;
    NlsAnsiCodePage = TableInfo->AnsiTableInfo.CodePage;

    if ( TableInfo->OemTableInfo.DBCSCodePage ) {
        RtlCopyMemory(NlsOemLeadByteInfo,TableInfo->OemTableInfo.DBCSOffsets,DBCS_TBL_SIZE*sizeof(USHORT));
    } else {
        RtlZeroMemory(NlsOemLeadByteInfo,DBCS_TBL_SIZE*sizeof(USHORT));
    }

    NlsMbOemCodePageTables = (PUSHORT)TableInfo->OemTableInfo.DBCSOffsets;

    NlsOemToUnicodeData = TableInfo->OemTableInfo.MultiByteTable;
    NlsUnicodeToOemData = (PCH)TableInfo->OemTableInfo.WideCharTable;
    NlsUnicodeToMbOemData = (PUSHORT)TableInfo->OemTableInfo.WideCharTable;
    NlsMbOemCodePageTag = TableInfo->OemTableInfo.DBCSCodePage ? TRUE : FALSE;
    NlsOemCodePage = TableInfo->OemTableInfo.CodePage;
    OemDefaultChar = TableInfo->OemTableInfo.DefaultChar;
    OemTransUniDefaultChar = TableInfo->OemTableInfo.TransDefaultChar;

    Nls844UnicodeUpcaseTable = TableInfo->UpperCaseTable;
    Nls844UnicodeLowercaseTable = TableInfo->LowerCaseTable;
    UnicodeDefaultChar = TableInfo->AnsiTableInfo.UniDefaultChar;
}

void
RtlGetDefaultCodePage(
    OUT PUSHORT AnsiCodePage,
    OUT PUSHORT OemCodePage
    )
{
    RTL_PAGED_CODE();
    *AnsiCodePage = NlsAnsiCodePage;
    *OemCodePage = NlsOemCodePage;
}

#if defined(ALLOC_DATA_PRAGMA)
#pragma data_seg()
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\nls.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    nls.c

Abstract:

    This module implements NLS support functions for NT.

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,RtlAnsiStringToUnicodeString)
#pragma alloc_text(PAGE,RtlAnsiCharToUnicodeChar)
#pragma alloc_text(PAGE,RtlUnicodeStringToAnsiString)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeStringToAnsiString)
#pragma alloc_text(PAGE,RtlOemStringToUnicodeString)
#pragma alloc_text(PAGE,RtlUnicodeStringToOemString)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeStringToOemString)
#pragma alloc_text(PAGE,RtlOemStringToCountedUnicodeString)
#pragma alloc_text(PAGE,RtlUnicodeStringToCountedOemString)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeStringToCountedOemString)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeString)
#pragma alloc_text(PAGE,RtlDowncaseUnicodeString)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeChar)
#pragma alloc_text(PAGE,RtlDowncaseUnicodeChar)
#pragma alloc_text(PAGE,RtlFreeUnicodeString)
#pragma alloc_text(PAGE,RtlFreeAnsiString)
#pragma alloc_text(PAGE,RtlFreeOemString)
#pragma alloc_text(PAGE,RtlxUnicodeStringToAnsiSize)
#pragma alloc_text(PAGE,RtlxUnicodeStringToOemSize)
#pragma alloc_text(PAGE,RtlxAnsiStringToUnicodeSize)
#pragma alloc_text(PAGE,RtlxOemStringToUnicodeSize)
#pragma alloc_text(PAGE,RtlCompareUnicodeString)
#pragma alloc_text(PAGE,RtlEqualUnicodeString)
#pragma alloc_text(PAGE,RtlPrefixUnicodeString)
#pragma alloc_text(PAGE,RtlCreateUnicodeString)
#pragma alloc_text(PAGE,RtlEqualDomainName)
#pragma alloc_text(PAGE,RtlEqualComputerName)
#pragma alloc_text(PAGE,RtlIsTextUnicode)
#pragma alloc_text(PAGE,RtlDnsHostNameToComputerName)
#pragma alloc_text(PAGE,RtlHashUnicodeString)
#pragma alloc_text(PAGE,RtlDuplicateUnicodeString)
#pragma alloc_text(PAGE,RtlFindCharInUnicodeString)
#endif




//
// Global data used for translations.
//

extern const PUSHORT  NlsAnsiToUnicodeData;    // Ansi CP to Unicode translation table
extern const PUSHORT  NlsLeadByteInfo;         // Lead byte info for ACP

//
// Pulled from lmcons.h:
//

#ifndef NETBIOS_NAME_LEN
#define NETBIOS_NAME_LEN  16            // NetBIOS net name (bytes)
#endif // NETBIOS_NAME_LEN



NTSTATUS
RtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the ansi source string. The maximum length field is only
        set if AllocateDestinationString is TRUE.

    SourceString - Supplies the ansi source string that is to be
        converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    UnicodeLength = RtlAnsiStringToUnicodeSize(SourceString);
    if ( UnicodeLength > MAX_USTRING ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)UnicodeLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(UnicodeLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( (DestinationString->Length + 1) >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }
    
    ASSERT_WELL_FORMED_UNICODE_STRING_OUT(DestinationString);

    st = RtlMultiByteToUnicodeN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index / sizeof(WCHAR)] = UNICODE_NULL;

    return STATUS_SUCCESS;

}


WCHAR
RtlAnsiCharToUnicodeChar(
    IN OUT PUCHAR *SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified ansi character to unicode and
    returns the unicode value.  The purpose for this routine is to allow
    for character by character ansi to unicode translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies a pointer to an ansi character pointer.
        Through two levels of indirection, this supplies an ansi
        character that is to be translated to unicode.  After
        translation, the ansi character pointer is modified to point to
        the next character to be converted.  This is done to allow for
        dbcs ansi characters.

Return Value:

    Returns the unicode equivalent of the specified ansi character.

--*/

{
    WCHAR UnicodeCharacter;
    ULONG cbCharSize;
    NTSTATUS st;


    RTL_PAGED_CODE();


    //
    // Translate the ansi character to unicode - this handles DBCS.
    //
    UnicodeCharacter = 0x0020;
    cbCharSize = NlsLeadByteInfo[ **SourceCharacter ] ? 2 : 1;
    st = RtlMultiByteToUnicodeN ( &UnicodeCharacter,
                                  sizeof ( WCHAR ),
                                  NULL,
                                  *SourceCharacter,
                                  cbCharSize );

    //
    // Check for error - The only time this will happen is if there is
    // a leadbyte without a trail byte.
    //
    if ( ! NT_SUCCESS( st ) )
    {
        // Use space as default.
        UnicodeCharacter = 0x0020;
    }

    //
    // Advance the source pointer and return the Unicode character.
    //
    (*SourceCharacter) += cbCharSize;
    return UnicodeCharacter;
}


NTSTATUS
RtlUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to ansi.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG AnsiLength;
    ULONG Index;
    NTSTATUS st;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;

    RTL_PAGED_CODE();

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(SourceString);

    AnsiLength = RtlUnicodeStringToAnsiSize(SourceString);
    if ( AnsiLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(AnsiLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)AnsiLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(AnsiLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            /*
             * Return STATUS_BUFFER_OVERFLOW, but translate as much as
             * will fit into the buffer first.  This is the expected
             * behavior for routines such as GetProfileStringA.
             * Set the length of the buffer to one less than the maximum
             * (so that the trail byte of a double byte char is not
             * overwritten by doing DestinationString->Buffer[Index] = '\0').
             * RtlUnicodeToMultiByteN is careful not to truncate a
             * multibyte character.
             */
            if (!DestinationString->MaximumLength) {
                return STATUS_BUFFER_OVERFLOW;
            }
            ReturnStatus = STATUS_BUFFER_OVERFLOW;
            DestinationString->Length = DestinationString->MaximumLength - 1;
            }
        }

    st = RtlUnicodeToMultiByteN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index] = '\0';

    return ReturnStatus;
}


NTSTATUS
RtlUpcaseUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions upper cases the specified unicode source string and then
    converts it into an ansi string. The translation is done with respect
    to the current system locale information.

Arguments:

    DestinationString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set
        if AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to upper case ansi.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG AnsiLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(SourceString);

    AnsiLength = RtlUnicodeStringToAnsiSize(SourceString);
    if ( AnsiLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(AnsiLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)AnsiLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(AnsiLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlUpcaseUnicodeToMultiByteN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index] = '\0';

    return STATUS_SUCCESS;
}


NTSTATUS
RtlOemStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCOEM_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified oem source string into a
    Unicode string. The translation is done with respect to the
    installed OEM code page (OCP).

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the oem source string. The maximum length field is only
        set if AllocateDestinationString is TRUE.

    SourceString - Supplies the oem source string that is to be
        converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    UnicodeLength = RtlOemStringToUnicodeSize(SourceString);
    if ( UnicodeLength > MAX_USTRING ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)UnicodeLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(UnicodeLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( (DestinationString->Length + 1) >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    ASSERT_WELL_FORMED_UNICODE_STRING_OUT(DestinationString);

    st = RtlOemToUnicodeN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index / sizeof(WCHAR)] = UNICODE_NULL;

    return STATUS_SUCCESS;

}


NTSTATUS
RtlUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    oem string. The translation is done with respect to the OEM code
    page (OCP).

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG OemLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(SourceString);

    OemLength = RtlUnicodeStringToOemSize(SourceString);
    if ( OemLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(OemLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)OemLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(OemLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlUnicodeToOemN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index] = '\0';

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUpcaseUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This function upper cases the specified unicode source string and then
    converts it into an oem string. The translation is done with respect
    to the OEM code page (OCP).

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG OemLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(SourceString);

    OemLength = RtlUnicodeStringToOemSize(SourceString);
    if ( OemLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(OemLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)OemLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(OemLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlUpcaseUnicodeToOemN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    //
    //  Now do a check here to see if there was really a mapping for all
    //  characters converted.
    //

    if (NT_SUCCESS(st) &&
        !RtlpDidUnicodeToOemWork( DestinationString, SourceString )) {

        st = STATUS_UNMAPPABLE_CHARACTER;
    }

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index] = '\0';

    return STATUS_SUCCESS;
}


NTSTATUS
RtlOemStringToCountedUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCOEM_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified oem source string into a
    Unicode string. The translation is done with respect to the
    installed OEM code page (OCP).

    The destination string is NOT unnaturally null terminated.  It is a
    counted string as counted strings are meant to be.

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the oem source string. The maximum length field is only
        set if AllocateDestinationString is TRUE.

    SourceString - Supplies the oem source string that is to be
        converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    UnicodeLength = RtlOemStringToCountedUnicodeSize(SourceString);

    if ( UnicodeLength == 0 ) {

        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DestinationString->Buffer = NULL;

        return STATUS_SUCCESS;
    }

    if ( UnicodeLength > MAX_USTRING ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)UnicodeLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(UnicodeLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    ASSERT_WELL_FORMED_UNICODE_STRING_OUT(DestinationString);

    st = RtlOemToUnicodeN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlUnicodeStringToCountedOemString(
    OUT POEM_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    oem string. The translation is done with respect to the OEM code
    page (OCP).

    The destination string is NOT unnaturally null terminated.  It is a
    counted string as counted strings are meant to be.

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG OemLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(SourceString);

    OemLength = RtlUnicodeStringToCountedOemSize(SourceString);

    if ( OemLength == 0 ) {

        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DestinationString->Buffer = NULL;

        return STATUS_SUCCESS;
    }

    if ( OemLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(OemLength);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)OemLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(OemLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlUnicodeToOemN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    //
    //  Now do a check here to see if there was really a mapping for all
    //  characters converted.
    //

    if (NT_SUCCESS(st) &&
        !RtlpDidUnicodeToOemWork( DestinationString, SourceString )) {

        st = STATUS_UNMAPPABLE_CHARACTER;
    }

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUpcaseUnicodeStringToCountedOemString(
    OUT POEM_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    then converts it into an oem string. The translation is done with
    respect to the OEM code page (OCP).

    The destination string is NOT unnaturally null terminated.  It is a
    counted string as counted strings are meant to be.

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set
        if AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG OemLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(SourceString);

    OemLength = RtlUnicodeStringToCountedOemSize(SourceString);

    if ( OemLength == 0 ) {

        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DestinationString->Buffer = NULL;

        return STATUS_SUCCESS;
    }

    if ( OemLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(OemLength);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)OemLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(OemLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlUpcaseUnicodeToOemN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    //
    //  Now do a check here to see if there was really a mapping for all
    //  characters converted.
    //

    if (NT_SUCCESS(st) &&
        !RtlpDidUnicodeToOemWork( DestinationString, SourceString )) {

        st = STATUS_UNMAPPABLE_CHARACTER;
    }

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUpcaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    upcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the upcased equivalent
        to the unicode source string.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        upcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;

    RTL_PAGED_CODE();

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(SourceString);

    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = (RtlAllocateStringRoutine)((ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
        DestinationString->Buffer[Index] = (WCHAR)NLS_UPCASE(SourceString->Buffer[Index]);
    }

    DestinationString->Length = SourceString->Length;

    ASSERT_WELL_FORMED_UNICODE_STRING_OUT(DestinationString);

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDowncaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into a
    downcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the downcased
        equivalent to the unicode source string.  The maximum length field
        is only set if AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        downcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;

    RTL_PAGED_CODE();

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(SourceString);

    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = (RtlAllocateStringRoutine)((ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
        DestinationString->Buffer[Index] = (WCHAR)NLS_DOWNCASE(SourceString->Buffer[Index]);
    }

    DestinationString->Length = SourceString->Length;

    ASSERT_WELL_FORMED_UNICODE_STRING_OUT(DestinationString);

    return STATUS_SUCCESS;
}


WCHAR
RtlUpcaseUnicodeChar(
    IN WCHAR SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified unicode character to its
    equivalent upcased unicode character.  The purpose for this routine
    is to allow for character by character upcase translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies the unicode character to be upcased.

Return Value:

    Returns the upcased unicode equivalent of the specified input character.

--*/

{
    RTL_PAGED_CODE();

    //
    // Note that this needs to reference the translation table !
    //

    return (WCHAR)NLS_UPCASE(SourceCharacter);
}


WCHAR
RtlDowncaseUnicodeChar(
    IN WCHAR SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified unicode character to its
    equivalent downcased unicode character.  The purpose for this routine
    is to allow for character by character downcase translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies the unicode character to be downcased.

Return Value:

    Returns the downcased unicode equivalent of the specified input character.

--*/

{
    RTL_PAGED_CODE();

    //
    // Note that this needs to reference the translation table !
    //

    return (WCHAR)NLS_DOWNCASE(SourceCharacter);
}


VOID
RtlFreeUnicodeString(
    IN OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlAnsiStringToUnicodeString.  Note that only UnicodeString->Buffer
    is free'd by this routine.

Arguments:

    UnicodeString - Supplies the address of the unicode string whose
        buffer was previously allocated by RtlAnsiStringToUnicodeString.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    if (UnicodeString->Buffer) {
         
       (RtlFreeStringRoutine)(UnicodeString->Buffer);
        memset( UnicodeString, 0, sizeof( *UnicodeString ) );
        }
}


VOID
RtlFreeAnsiString(
    IN OUT PANSI_STRING AnsiString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToAnsiString.  Note that only AnsiString->Buffer
    is free'd by this routine.

Arguments:

    AnsiString - Supplies the address of the ansi string whose buffer
        was previously allocated by RtlUnicodeStringToAnsiString.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    if (AnsiString->Buffer) {
        (RtlFreeStringRoutine)(AnsiString->Buffer);
        memset( AnsiString, 0, sizeof( *AnsiString ) );
        }
}


VOID
RtlFreeOemString(
    IN OUT POEM_STRING OemString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToOemString.  Note that only OemString->Buffer
    is free'd by this routine.

Arguments:

    OemString - Supplies the address of the oem string whose buffer
        was previously allocated by RtlUnicodeStringToOemString.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    if (OemString->Buffer) {(RtlFreeStringRoutine)(OemString->Buffer);}
}


ULONG
RtlxUnicodeStringToAnsiSize(
    IN PCUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This function computes the number of bytes required to store
    a NULL terminated ansi string that is equivalent to the specified
    unicode string. If an ansi string can not be formed, the return value
    is 0.

Arguments:

    UnicodeString - Supplies a unicode string whose equivalent size as
        an ansi string is to be calculated.

Return Value:

    0 - The operation failed, the unicode string can not be translated
        into ansi using the current system locale therefore no storage
        is needed for the ansi string.

    !0 - The operation was successful.  The return value specifies the
        number of bytes required to hold an NULL terminated ansi string
        equivalent to the specified unicode string.

--*/

{
    ULONG  cbMultiByteString;

    RTL_PAGED_CODE();

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(UnicodeString);

    //
    // Get the size of the string - this call handles DBCS.
    //
    RtlUnicodeToMultiByteSize( &cbMultiByteString,
                               UnicodeString->Buffer,
                               UnicodeString->Length );

    //
    // Return the size in bytes.
    //
    return (cbMultiByteString + 1);
}


ULONG
RtlxUnicodeStringToOemSize(
    IN PCUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This function computes the number of bytes required to store
    a NULL terminated oem string that is equivalent to the specified
    unicode string. If an oem string can not be formed, the return value
    is 0.

Arguments:

    UnicodeString - Supplies a unicode string whose equivalent size as
        an oem string is to be calculated.

Return Value:

    0 - The operation failed, the unicode string can not be translated
        into oem using the OEM code page therefore no storage is
        needed for the oem string.

    !0 - The operation was successful.  The return value specifies the
        number of bytes required to hold an NULL terminated oem string
        equivalent to the specified unicode string.

--*/

{
    ULONG  cbMultiByteString;

    RTL_PAGED_CODE();

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(UnicodeString);

    //
    // LATER:  Define an RtlUnicodeToOemSize.
    //         In the Japanese version, it's safe to call
    //         RtlUnicodeToMultiByteSize because the Ansi code page
    //         and the OEM code page are the same.
    //

    //
    // Get the size of the string - this call handles DBCS.
    //
    RtlUnicodeToMultiByteSize( &cbMultiByteString,
                               UnicodeString->Buffer,
                               UnicodeString->Length );

    //
    // Return the size in bytes.
    //
    return (cbMultiByteString + 1);
}


ULONG
RtlxAnsiStringToUnicodeSize(
    IN PCANSI_STRING AnsiString
    )

/*++

Routine Description:

    This function computes the number of bytes required to store a NULL
    terminated unicode string that is equivalent to the specified ansi
    string.

Arguments:

    AnsiString - Supplies an ansi string whose equivalent size as a
        unicode string is to be calculated.  The ansi string is
        interpreted relative to the current system locale.

Return Value:

    The return value specifies the number of bytes required to hold a
    NULL terminated unicode string equivalent to the specified ansi
    string.

--*/

{
    ULONG cbConverted;

    RTL_PAGED_CODE();

    //
    // Get the size of the string - this call handles DBCS.
    //
    RtlMultiByteToUnicodeSize( &cbConverted ,
                               AnsiString->Buffer,
                               AnsiString->Length );

    //
    // Return the size in bytes.
    //
    return ( cbConverted + sizeof(UNICODE_NULL) );
}


ULONG
RtlxOemStringToUnicodeSize(
    IN PCOEM_STRING OemString
    )

/*++

Routine Description:

    This function computes the number of bytes required to store a NULL
    terminated unicode string that is equivalent to the specified oem
    string.

Arguments:

    OemString - Supplies an oem string whose equivalent size as a
        unicode string is to be calculated.  The oem string is
        interpreted relative to the current oem code page (OCP).

Return Value:

    The return value specifies the number of bytes required to hold a
    NULL terminated unicode string equivalent to the specified oem
    string.

--*/

{
    ULONG cbConverted;

    RTL_PAGED_CODE();

    //
    // LATER:  Define an RtlOemToUnicodeSize.
    //         In the Japanese version, it's safe to call
    //         RtlMultiByteToUnicodeSize because the Ansi code page
    //         and the OEM code page are the same.
    //

    //
    // Get the size of the string - this call handles DBCS.
    //
    RtlMultiByteToUnicodeSize( &cbConverted,
                               OemString->Buffer,
                               OemString->Length );

    //
    // Return the size in bytes.
    //
    return ( cbConverted + sizeof(UNICODE_NULL) );
}


LONG
RtlCompareUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareUnicodeString function compares two counted strings.  The
    return value indicates if the strings are equal or String1 is less than
    String2 or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    PCWSTR s1, s2, Limit;
    LONG n1, n2;
    ULONG c1, c2;

    RTL_PAGED_CODE();

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(String1);

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(String2);

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = String1->Length;
    n2 = String2->Length;

    ASSERT(!(((((ULONG_PTR)s1 & 1) != 0) || (((ULONG_PTR)s2 & 1) != 0)) && (n1 != 0) && (n2 != 0)));

    Limit = (PWCHAR)((PCHAR)s1 + (n1 <= n2 ? n1 : n2));
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1;
            c2 = *s2;
            if (c1 != c2) {

                //
                // Note that this needs to reference the translation table!
                //

                c1 = NLS_UPCASE(c1);
                c2 = NLS_UPCASE(c2);
                if (c1 != c2) {
                    return (LONG)(c1) - (LONG)(c2);
                }
            }

            s1 += 1;
            s2 += 1;
        }

    } else {
        while (s1 < Limit) {
            c1 = *s1;
            c2 = *s2;
            if (c1 != c2) {
                return (LONG)(c1) - (LONG)(c2);
            }

            s1 += 1;
            s2 += 1;
        }
    }

    return n1 - n2;
}


BOOLEAN
RtlEqualUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualUnicodeString function compares two counted unicode strings for
    equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PWCHAR s1, s2, Limit;
    LONG n1, n2;
    ULONG c1, c2;

    RTL_PAGED_CODE();

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(String1);

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(String2);

    n1 = String1->Length;
    n2 = String2->Length;
    if (n1 == n2) {
        s1 = String1->Buffer;
        s2 = String2->Buffer;
        Limit = (PWCHAR)((PCHAR)s1 + n1);

        //
        // At this point, the vast majority of strings are identical.
        //
        // Compare until all chunks have been found to match or a mismatch
        // chunk is located, at which point a character-by-character
        // comparison will be undertaken.
        //

        while (n1 >= sizeof(ULONG_PTR)) {

            if (*(PULONG_PTR)s1 != *(PULONG_PTR)s2) {
                break;
            }
            n1 -= sizeof(ULONG_PTR);
            if (n1 == 0) {
                return TRUE;
            }
            s1 += sizeof(ULONG_PTR) / sizeof(WCHAR);
            s2 += sizeof(ULONG_PTR) / sizeof(WCHAR);
        }

        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = *s1;
                c2 = *s2;
                if ((c1 != c2) && (NLS_UPCASE(c1) != NLS_UPCASE(c2))) {
                    return FALSE;
                }

                s1 += 1;
                s2 += 1;
            }

        } else {
            while (s1 < Limit) {
                c1 = *s1;
                c2 = *s2;
                if (c1 != c2) {
                    return FALSE;
                }

                s1 += 1;
                s2 += 1;
            }
        }

        return TRUE;

    } else {
        return FALSE;
    }
}


BOOLEAN
RtlPrefixUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlPrefixUnicodeString function determines if the String1
    counted string parameter is a prefix of the String2 counted string
    parameter.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first unicode string.

    String2 - Pointer to the second unicode string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals a prefix of String2 and
    FALSE otherwise.

--*/

{
    PWSTR Limit;
    PWSTR s1, s2;
    ULONG n;
    ULONG c1, c2;

    RTL_PAGED_CODE();

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(String1);

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(String2);

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n = String1->Length;
    if (String2->Length < n) {
        return FALSE;
    }

    Limit = (PWSTR)((PCHAR)s1 + n);
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1;
            c2 = *s2;
            if ((c1 != c2) && (NLS_UPCASE(c1) != NLS_UPCASE(c2))) {
                return FALSE;
            }

            s1 += 1;
            s2 += 1;
        }

    } else {
        while (s1 < Limit) {
            if (*s1 != *s2) {
                return FALSE;
            }

            s1 += 1;
            s2 += 1;
        }
    }

    return TRUE;
}


VOID
RtlCopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCUNICODE_STRING SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlCopyString function copies the SourceString to the
    DestinationString.  If SourceString is not specified, then
    the Length field of DestinationString is set to zero.  The
    MaximumLength and Buffer fields of DestinationString are not
    modified by this function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Optional pointer to the source string.

Return Value:

    None.

--*/

{
    UNALIGNED WCHAR *src, *dst;
    ULONG n;

    if (ARGUMENT_PRESENT(SourceString)) {
        ASSERT_WELL_FORMED_UNICODE_STRING_IN(SourceString);
        dst = DestinationString->Buffer;
        src = SourceString->Buffer;
        n = SourceString->Length;
        if ((USHORT)n > DestinationString->MaximumLength) {
            n = DestinationString->MaximumLength;
        }

        DestinationString->Length = (USHORT)n;
        RtlCopyMemory(dst, src, n);
        if( (DestinationString->Length + sizeof (WCHAR)) <= DestinationString->MaximumLength) {
            dst[n / sizeof(WCHAR)] = UNICODE_NULL;
        }

        ASSERT_WELL_FORMED_UNICODE_STRING_OUT(DestinationString);
    } else {
        DestinationString->Length = 0;
    }

    return;
}


NTSTATUS
RtlAppendUnicodeToString (
    IN PUNICODE_STRING Destination,
    IN PCWSTR Source OPTIONAL
    )

/*++

Routine Description:

    This routine appends the supplied UNICODE string to an existing
    PUNICODE_STRING.

    It will copy bytes from the Source PSZ to the destination PSTRING up to
    the destinations PUNICODE_STRING->MaximumLength field.

Arguments:

    IN PUNICODE_STRING Destination, - Supplies a pointer to the destination
                            string
    IN PWSTR Source - Supplies the string to append to the destination

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n;
    UNALIGNED WCHAR *dst;

    if (ARGUMENT_PRESENT( Source )) {
        UNICODE_STRING UniSource;

        ASSERT_WELL_FORMED_UNICODE_STRING_IN(Destination);
        ASSERT_WELL_FORMED_UNICODE_STRING_OUT(Destination);

        if( !NT_SUCCESS(RtlInitUnicodeStringEx(&UniSource, Source)) ) {
            return( STATUS_BUFFER_TOO_SMALL );
        }

        n = UniSource.Length;

        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source, n );

        Destination->Length += n;

        if ((Destination->Length + 1) < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlAppendUnicodeStringToString (
    IN OUT PUNICODE_STRING Destination,
    IN PCUNICODE_STRING Source
    )

/*++

Routine Description:

    This routine will concatenate two PSTRINGs together.  It will copy
    bytes from the source up to the MaximumLength of the destination.

Arguments:

    IN PSTRING Destination, - Supplies the destination string
    IN PSTRING Source - Supplies the source for the string copy

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n = Source->Length;
    UNALIGNED WCHAR *dst;

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(Source);
    if (n) {
        ASSERT_WELL_FORMED_UNICODE_STRING_IN(Destination);
        ASSERT_WELL_FORMED_UNICODE_STRING_OUT(Destination);
        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source->Buffer, n );

        Destination->Length += n;

        if( (Destination->Length + 1) < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}

BOOLEAN
RtlCreateUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
    )
{
    ULONG cb;

    RTL_PAGED_CODE();

    cb = (wcslen( SourceString ) + 1) * sizeof( WCHAR );
    if( cb > MAX_USTRING ) {
        return( FALSE );
    }
    DestinationString->Buffer = (RtlAllocateStringRoutine)( cb );
    if (DestinationString->Buffer) {
        RtlCopyMemory( DestinationString->Buffer, SourceString, cb );
        DestinationString->MaximumLength = (USHORT)cb;
        DestinationString->Length = (USHORT)(cb - sizeof( UNICODE_NULL ));
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}


BOOLEAN
RtlEqualDomainName(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2
    )

/*++

Routine Description:

    The RtlEqualDomainName function compares two domain names for equality.

    The comparison is a case insensitive comparison of the OEM equivalent
    strings.

    The domain name is not validated for length nor invalid characters.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{
    NTSTATUS Status;
    BOOLEAN ReturnValue = FALSE;
    OEM_STRING OemString1;
    OEM_STRING OemString2;

    RTL_PAGED_CODE();
    ASSERT_WELL_FORMED_UNICODE_STRING_IN(String1);
    ASSERT_WELL_FORMED_UNICODE_STRING_IN(String2);

    //
    // Upper case and convert the first string to OEM
    //

    Status = RtlUpcaseUnicodeStringToOemString( &OemString1,
                                                String1,
                                                TRUE );   // Allocate Dest

    if ( NT_SUCCESS( Status ) ) {

        //
        // Upper case and convert the second string to OEM
        //

        Status = RtlUpcaseUnicodeStringToOemString( &OemString2,
                                                    String2,
                                                    TRUE );   // Allocate Dest

        if ( NT_SUCCESS( Status ) ) {

            //
            // Do a case insensitive comparison.
            //

            ReturnValue = RtlEqualString( &OemString1,
                                          &OemString2,
                                          FALSE );

            RtlFreeOemString( &OemString2 );
        }

        RtlFreeOemString( &OemString1 );
    }

    return ReturnValue;
}



BOOLEAN
RtlEqualComputerName(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2
    )

/*++

Routine Description:

    The RtlEqualComputerName function compares two computer names for equality.

    The comparison is a case insensitive comparison of the OEM equivalent
    strings.

    The domain name is not validated for length nor invalid characters.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{
    return RtlEqualDomainName( String1, String2 );
}

/**


**/

#define UNICODE_FFFF              0xFFFF
#define REVERSE_BYTE_ORDER_MARK   0xFFFE
#define BYTE_ORDER_MARK           0xFEFF

#define PARAGRAPH_SEPARATOR       0x2029
#define LINE_SEPARATOR            0x2028

#define UNICODE_TAB               0x0009
#define UNICODE_LF                0x000A
#define UNICODE_CR                0x000D
#define UNICODE_SPACE             0x0020
#define UNICODE_CJK_SPACE         0x3000

#define UNICODE_R_TAB             0x0900
#define UNICODE_R_LF              0x0A00
#define UNICODE_R_CR              0x0D00
#define UNICODE_R_SPACE           0x2000
#define UNICODE_R_CJK_SPACE       0x0030  /* Ambiguous - same as ASCII '0' */

#define ASCII_CRLF                0x0A0D

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))


BOOLEAN
RtlIsTextUnicode(
    IN PVOID Buffer,
    IN ULONG Size,
    IN OUT PULONG Result OPTIONAL
    )

/*++

Routine Description:

    IsTextUnicode performs a series of inexpensive heuristic checks
    on a buffer in order to verify that it contains Unicode data.


    Found            Return Result

    BOM              TRUE   BOM
    RBOM             FALSE  RBOM
    FFFF             FALSE  Binary
    NULL             FALSE  Binary
    null             TRUE   null bytes
    ASCII_CRLF       FALSE  CRLF
    UNICODE_TAB etc. TRUE   Zero Ext Controls
    UNICODE_TAB_R    FALSE  Reversed Controls
    UNICODE_ZW  etc. TRUE   Unicode specials

    1/3 as little variation in hi-byte as in lo byte: TRUE   Correl
    3/1 or worse   "                                  FALSE  AntiCorrel

Arguments:

    Buffer - pointer to buffer containing text to examine.

    Size - size of buffer in bytes.  At most 256 characters in this will
           be examined.  If the size is less than the size of a unicode
           character, then this function returns FALSE.

    Result - optional pointer to a flag word that contains additional information
             about the reason for the return value.  If specified, this value on
             input is a mask that is used to limit the factors this routine uses
             to make its decision.  On output, this flag word is set to contain
             those flags that were used to make its decision.

Return Value:

    Boolean value that is TRUE if Buffer contains unicode characters.

--*/
{
    UNALIGNED WCHAR *lpBuff = Buffer;
    PUCHAR lpb = Buffer;
    ULONG iBOM = 0;
    ULONG iCR = 0;
    ULONG iLF = 0;
    ULONG iTAB = 0;
    ULONG iSPACE = 0;
    ULONG iCJK_SPACE = 0;
    ULONG iFFFF = 0;
    ULONG iPS = 0;
    ULONG iLS = 0;

    ULONG iRBOM = 0;
    ULONG iR_CR = 0;
    ULONG iR_LF = 0;
    ULONG iR_TAB = 0;
    ULONG iR_SPACE = 0;

    ULONG iNull = 0;
    ULONG iUNULL = 0;
    ULONG iCRLF = 0;
    ULONG iTmp;
    ULONG LastLo = 0;
    ULONG LastHi = 0;
    ULONG iHi, iLo;
    ULONG HiDiff = 0;
    ULONG LoDiff = 0;
    ULONG cLeadByte = 0;
    ULONG cWeird = 0;

    ULONG iResult = 0;

    ULONG iMaxTmp = __min(256, Size / sizeof(WCHAR));

    //
    //  Special case when the size is less than or equal to 2.
    //  Make sure we don't have a character followed by a null byte.
    //
    if ((Size < 2) ||
        ((Size == 2) && (lpBuff[0] != 0) && (lpb[1] == 0)))
    {
        if (ARGUMENT_PRESENT(Result))
        {
            *Result = IS_TEXT_UNICODE_ASCII16 | IS_TEXT_UNICODE_CONTROLS;
        }

        return (FALSE);
    }
    else if ((Size > 2) && ((Size / sizeof(WCHAR)) <= 256))
    {
        //
        //  If the Size passed in is an even number, we don't want to
        //  use the last WCHAR because it will contain the final null
        //  byte.
        //
        if (((Size % sizeof(WCHAR)) == 0) &&
            ((lpBuff[iMaxTmp - 1] & 0xff00) == 0))
        {
            iMaxTmp--;
        }
    }

    //
    //  Check at most 256 wide characters, collect various statistics.
    //
    for (iTmp = 0; iTmp < iMaxTmp; iTmp++)
    {
        switch (lpBuff[iTmp])
        {
            case BYTE_ORDER_MARK:
                iBOM++;
                break;
            case PARAGRAPH_SEPARATOR:
                iPS++;
                break;
            case LINE_SEPARATOR:
                iLS++;
                break;
            case UNICODE_LF:
                iLF++;
                break;
            case UNICODE_TAB:
                iTAB++;
                break;
            case UNICODE_SPACE:
                iSPACE++;
                break;
            case UNICODE_CJK_SPACE:
                iCJK_SPACE++;
                break;
            case UNICODE_CR:
                iCR++;
                break;

            //
            //  The following codes are expected to show up in
            //  byte reversed files.
            //
            case REVERSE_BYTE_ORDER_MARK:
                iRBOM++;
                break;
            case UNICODE_R_LF:
                iR_LF++;
                break;
            case UNICODE_R_TAB:
                iR_TAB++;
                break;
            case UNICODE_R_CR:
                iR_CR++;
                break;
            case UNICODE_R_SPACE:
                iR_SPACE++;
                break;

            //
            //  The following codes are illegal and should never occur.
            //
            case UNICODE_FFFF:
                iFFFF++;
                break;
            case UNICODE_NULL:
                iUNULL++;
                break;

            //
            //  The following is not currently a Unicode character
            //  but is expected to show up accidentally when reading
            //  in ASCII files which use CRLF on a little endian machine.
            //
            case ASCII_CRLF:
                iCRLF++;
                break;       /* little endian */
        }

        //
        //  Collect statistics on the fluctuations of high bytes
        //  versus low bytes.
        //
        iHi = HIBYTE(lpBuff[iTmp]);
        iLo = LOBYTE(lpBuff[iTmp]);

        //
        //  Count cr/lf and lf/cr that cross two words.
        //
        if ((iLo == '\r' && LastHi == '\n') ||
            (iLo == '\n' && LastHi == '\r'))
        {
            cWeird++;
        }

        iNull += (iHi ? 0 : 1) + (iLo ? 0 : 1);   /* count Null bytes */

        HiDiff += __max(iHi, LastHi) - __min(LastHi, iHi);
        LoDiff += __max(iLo, LastLo) - __min(LastLo, iLo);

        LastLo = iLo;
        LastHi = iHi;
    }

    //
    //  Count cr/lf and lf/cr that cross two words.
    //
    if ((iLo == '\r' && LastHi == '\n') ||
        (iLo == '\n' && LastHi == '\r'))
    {
        cWeird++;
    }

    if (iHi == '\0')     /* don't count the last null */
        iNull--;
    if (iHi == 26)       /* count ^Z at end as weird */
        cWeird++;

    iMaxTmp = __min(256 * sizeof(WCHAR), Size);
    if (NlsMbCodePageTag)
    {
        for (iTmp = 0; iTmp < iMaxTmp; iTmp++)
        {
            if (NlsLeadByteInfo[lpb[iTmp]])
            {
                cLeadByte++;
                iTmp++;         /* should check for trailing-byte range */
            }
        }
    }

    //
    //  Sift through the statistical evidence.
    //
    if (LoDiff < 127 && HiDiff == 0)
    {
        iResult |= IS_TEXT_UNICODE_ASCII16;         /* likely 16-bit ASCII */
    }

    if (HiDiff && LoDiff == 0)
    {
        iResult |= IS_TEXT_UNICODE_REVERSE_ASCII16; /* reverse 16-bit ASCII */
    }

    //
    //  Use leadbyte info to weight statistics.
    //
    if (!NlsMbCodePageTag || cLeadByte == 0 ||
        !ARGUMENT_PRESENT(Result) || !(*Result & IS_TEXT_UNICODE_DBCS_LEADBYTE))
    {
        iHi = 3;
    }
    else
    {
        //
        //  A ratio of cLeadByte:cb of 1:2 ==> dbcs
        //  Very crude - should have a nice eq.
        //
        iHi = __min(256, Size / sizeof(WCHAR)) / 2;
        if (cLeadByte < (iHi - 1) / 3)
        {
            iHi = 3;
        }
        else if (cLeadByte < (2 * (iHi - 1)) / 3)
        {
            iHi = 2;
        }
        else
        {
            iHi = 1;
        }
        iResult |= IS_TEXT_UNICODE_DBCS_LEADBYTE;
    }

    if (iHi * HiDiff < LoDiff)
    {
        iResult |= IS_TEXT_UNICODE_STATISTICS;
    }

    if (iHi * LoDiff < HiDiff)
    {
        iResult |= IS_TEXT_UNICODE_REVERSE_STATISTICS;
    }

    //
    //  Any control codes widened to 16 bits? Any Unicode character
    //  which contain one byte in the control code range?
    //
    if (iCR + iLF + iTAB + iSPACE + iCJK_SPACE /*+iPS+iLS*/)
    {
        iResult |= IS_TEXT_UNICODE_CONTROLS;
    }

    if (iR_LF + iR_CR + iR_TAB + iR_SPACE)
    {
        iResult |= IS_TEXT_UNICODE_REVERSE_CONTROLS;
    }

    //
    //  Any characters that are illegal for Unicode?
    //
    if ((iRBOM + iFFFF + iUNULL + iCRLF) != 0 ||
         (cWeird != 0 && cWeird >= iMaxTmp/40))
    {
        iResult |= IS_TEXT_UNICODE_ILLEGAL_CHARS;
    }

    //
    //  Odd buffer length cannot be Unicode.
    //
    if (Size & 1)
    {
        iResult |= IS_TEXT_UNICODE_ODD_LENGTH;
    }

    //
    //  Any NULL bytes? (Illegal in ANSI)
    //
    if (iNull)
    {
        iResult |= IS_TEXT_UNICODE_NULL_BYTES;
    }

    //
    //  POSITIVE evidence, BOM or RBOM used as signature.
    //
    if (*lpBuff == BYTE_ORDER_MARK)
    {
        iResult |= IS_TEXT_UNICODE_SIGNATURE;
    }
    else if (*lpBuff == REVERSE_BYTE_ORDER_MARK)
    {
        iResult |= IS_TEXT_UNICODE_REVERSE_SIGNATURE;
    }

    //
    //  Limit to desired categories if requested.
    //
    if (ARGUMENT_PRESENT(Result))
    {
        iResult &= *Result;
        *Result = iResult;
    }

    //
    //  There are four separate conclusions:
    //
    //  1: The file APPEARS to be Unicode     AU
    //  2: The file CANNOT be Unicode         CU
    //  3: The file CANNOT be ANSI            CA
    //
    //
    //  This gives the following possible results
    //
    //      CU
    //      +        -
    //
    //      AU       AU
    //      +   -    +   -
    //      --------  --------
    //      CA +| 0   0    2   3
    //      |
    //      -| 1   1    4   5
    //
    //
    //  Note that there are only 6 really different cases, not 8.
    //
    //  0 - This must be a binary file
    //  1 - ANSI file
    //  2 - Unicode file (High probability)
    //  3 - Unicode file (more than 50% chance)
    //  5 - No evidence for Unicode (ANSI is default)
    //
    //  The whole thing is more complicated if we allow the assumption
    //  of reverse polarity input. At this point we have a simplistic
    //  model: some of the reverse Unicode evidence is very strong,
    //  we ignore most weak evidence except statistics. If this kind of
    //  strong evidence is found together with Unicode evidence, it means
    //  its likely NOT Text at all. Furthermore if a REVERSE_BYTE_ORDER_MARK
    //  is found, it precludes normal Unicode. If both byte order marks are
    //  found it's not Unicode.
    //

    //
    //  Unicode signature : uncontested signature outweighs reverse evidence.
    //
    if ((iResult & IS_TEXT_UNICODE_SIGNATURE) &&
        !(iResult & (IS_TEXT_UNICODE_NOT_UNICODE_MASK&(~IS_TEXT_UNICODE_DBCS_LEADBYTE))))
    {
        return (TRUE);
    }

    //
    //  If we have conflicting evidence, it's not Unicode.
    //
    if (iResult & IS_TEXT_UNICODE_REVERSE_MASK)
    {
        return (FALSE);
    }

    //
    //  Statistical and other results (cases 2 and 3).
    //
    if (!(iResult & IS_TEXT_UNICODE_NOT_UNICODE_MASK) &&
         ((iResult & IS_TEXT_UNICODE_NOT_ASCII_MASK) ||
          (iResult & IS_TEXT_UNICODE_UNICODE_MASK)))
    {
        return (TRUE);
    }

    return (FALSE);
}


NTSTATUS
RtlDnsHostNameToComputerName(
    OUT PUNICODE_STRING ComputerNameString,
    IN PCUNICODE_STRING DnsHostNameString,
    IN BOOLEAN AllocateComputerNameString
    )

/*++

Routine Description:

    The RtlDnsHostNameToComputerName API converts a DNS-style host name to a
    Netbios-style computer name.

    This API does a syntactical mapping of the name.  As such, it should not
    be used to convert a DNS domain name to a Netbios domain name.
    There is no syntactical mapping for domain names.

    DNS-style names consist of one or more "labels" separated by a period
    (e.g., xxx.nt.microsoft.com).  Each label can be up to 63 bytes of
    UTF-8 characters and must consist only of characters specified
    by the DnsValidateDnsName API.  Upper and lower case characters are treated
    as the same character.  DNS names are represented in the UTF-8 character set
    or UNICODE.

    Netbios computer names consist of up to 15 bytes of OEM characters
    including letters, digits, hyphens, periods and various other characters.
    Some of these characters are specific to the character set. Netbios names
    are typically represented in the OEM character set.  The OEM character
    set is different depending on the locale of the particular version of the OS
    (e.g., the German version has a different character set than the US version).
    Some OEM character sets represent certain characters as 2 bytes
    (e.g., Japanese).  Netbios names, by convention, are represented in
    uppercase where the translation algorithm from lowercase to uppercase
    is OEM character set dependent.

    These characteristics make translating between DNS name and Netbios name
    difficult.

    RtlDnsHostNameToComputerName enforces a textual convention for
    mapping between the two names.  This convention limits the names of
    computers to be the common subset of the names.  Specifically, the leftmost
    label of the DNS name is truncated to 15-bytes of OEM characters.
    As such, RtlDnsHostNameToComputerName simply interprets the leftmost label
    of the DNS name as the Netbios name.  If the DNS name doesn't meet the
    criteria of a valid translatable name, a distinct error code is returned.

Arguments:

    ComputerNameString - Returns a unicode string that is equivalent to
        the DNS source string. The maximum length field is only
        set if AllocateComputerNameString is TRUE.

    DnsHostNameString - Supplies the DNS host name source string that is to be
        converted to a netbios computer name.

        This routine does NOT attempt to validate that the passed in DnsHostNameString
        is a valid DNS host a DNS host name.  Rather it assumes that the passed in
        name is valid and converts it on a best effort basis.

    AllocateComputerNameString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    STATUS_NO_MEMORY - There is not enough memory to allocate the return buffer.

    STATUS_INVALID_COMPUTER_NAME - The DnsHostName has no first label or
        one or more characters of the DnsHostName could not be converted to
        the OEM character set.

--*/

{
    NTSTATUS Status;


    UNICODE_STRING LocalDnsHostNameString;

    OEM_STRING OemString;
    ULONG ActualOemLength;
    CHAR OemStringBuffer[16];

    ULONG i;

    RTL_PAGED_CODE();

    //
    // Truncate the dns name to the first label
    //

    LocalDnsHostNameString = *DnsHostNameString;
    ASSERT_WELL_FORMED_UNICODE_STRING_IN(&LocalDnsHostNameString);

    for ( i=0; i<LocalDnsHostNameString.Length/sizeof(WCHAR); i++ ) {

        if ( LocalDnsHostNameString.Buffer[i] == L'.' ) {
            LocalDnsHostNameString.Length = (USHORT)(i * sizeof(WCHAR));
            break;
        }
    }

    if ( LocalDnsHostNameString.Length < sizeof(WCHAR) ) {
        return STATUS_INVALID_COMPUTER_NAME;
    }

    //
    // Convert the DNS name to OEM truncating at 15 OEM bytes.
    //

    Status = RtlUpcaseUnicodeToOemN(
                OemStringBuffer,
                NETBIOS_NAME_LEN-1,         // truncate to 15 bytes
                &ActualOemLength,
                LocalDnsHostNameString.Buffer,
                LocalDnsHostNameString.Length );

    if ( !NT_SUCCESS(Status) && Status != STATUS_BUFFER_OVERFLOW ) {
        return Status;
    }


    //
    // Check to see if any characters are not valid OEM characters.
    //

    OemString.Buffer = OemStringBuffer;
    OemString.MaximumLength = OemString.Length = (USHORT) ActualOemLength;

    if ( !RtlpDidUnicodeToOemWork( &OemString, &LocalDnsHostNameString )) {
        return STATUS_INVALID_COMPUTER_NAME;
    }


    //
    // Convert the OEM string back to UNICODE
    //

    Status = RtlOemStringToUnicodeString(
                ComputerNameString,
                &OemString,
                AllocateComputerNameString );

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    ASSERT_WELL_FORMED_UNICODE_STRING_OUT(ComputerNameString);
    return STATUS_SUCCESS;
}

NTSTATUS
RtlHashUnicodeString(
    const UNICODE_STRING *String,
    BOOLEAN CaseInSensitive,
    ULONG HashAlgorithm,
    PULONG HashValue
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG TmpHashValue = 0;
    ULONG Chars;
    PCWSTR Buffer;

    if ((String == NULL) ||
        (HashValue == NULL))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    ASSERT_WELL_FORMED_UNICODE_STRING_IN(String);

    Buffer = String->Buffer;

    *HashValue = 0;
    Chars = String->Length / sizeof(WCHAR);

    switch (HashAlgorithm)
    {
    default:
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
        break;

    case HASH_STRING_ALGORITHM_DEFAULT:
    case HASH_STRING_ALGORITHM_X65599:
        if (CaseInSensitive)
        {
            while (Chars-- != 0)
            {
                WCHAR Char = *Buffer++;
                TmpHashValue = (TmpHashValue * 65599) + NLS_UPCASE(Char);
            }
        }
        else
        {
            while (Chars-- != 0)
                TmpHashValue = (TmpHashValue * 65599) + *Buffer++;
        }

        break;
    }

    *HashValue = TmpHashValue;
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


NTSTATUS
RtlValidateUnicodeString(
    ULONG Flags,
    const UNICODE_STRING *String
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(Flags == 0);

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (String != NULL) {
        if (((String->Length % 2) != 0) ||
            ((String->MaximumLength % 2) != 0) ||
            (String->Length > String->MaximumLength)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        if (((String->Length != 0) ||
             (String->MaximumLength != 0)) &&
            (String->Buffer == NULL)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


NTSTATUS
RtlDuplicateUnicodeString(
    ULONG Flags,
    PCUNICODE_STRING StringIn,
    PUNICODE_STRING StringOut
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT Length = 0;
    USHORT NewMaximumLength = 0;
    PWSTR Buffer = NULL;

    if (((Flags & ~(
            RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
            RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING)) != 0) ||
        (StringOut == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // It doesn't make sense to force allocation of a null string unless you
    // want null termination.
    if ((Flags & RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING) &&
        !(Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = RtlValidateUnicodeString(0, StringIn);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (StringIn != NULL)
        Length = StringIn->Length;

    if ((Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE) &&
        (Length == UNICODE_STRING_MAX_BYTES)) {
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    if (Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE)
        NewMaximumLength = (USHORT) (Length + sizeof(WCHAR));
    else
        NewMaximumLength = Length;

    // If it's a zero length string in, force the allocation length to zero
    // unless the caller said that they want zero length strings allocated.
    if (((Flags & RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING) == 0) &&
        (Length == 0)) {
        NewMaximumLength = 0;
    }

    if (NewMaximumLength != 0) {
        Buffer = (RtlAllocateStringRoutine)(NewMaximumLength);
        if (Buffer == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        // If there's anything to copy, copy it.  We explicitly test Length because
        // StringIn could be a NULL pointer, so dereferencing it to get the Buffer
        // pointer would access violate.
        if (Length != 0) {
            RtlCopyMemory(
                Buffer,
                StringIn->Buffer,
                Length);
        }

        if (Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE) {
            Buffer[Length / sizeof(WCHAR)] = L'\0';
        }
    }

    StringOut->Buffer = Buffer;
    StringOut->MaximumLength = NewMaximumLength;
    StringOut->Length = Length;

    ASSERT_WELL_FORMED_UNICODE_STRING_OUT(StringOut);

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
RtlFindCharInUnicodeString(
    ULONG Flags,
    PCUNICODE_STRING StringToSearch,
    PCUNICODE_STRING CharSet,
    USHORT *NonInclusivePrefixLength
    )
{
    NTSTATUS Status;
    USHORT PrefixLengthFound = 0;
    USHORT CharsToSearch = 0;
    int MovementDirection = 0;
    PCWSTR Cursor = NULL;
    BOOLEAN Found = FALSE;
    USHORT CharSetChars = 0;
    PCWSTR CharSetBuffer = NULL;
    USHORT i;

    if (NonInclusivePrefixLength != 0)
        *NonInclusivePrefixLength = 0;

    if (((Flags & ~(RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END |
                    RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET |
                    RTL_FIND_CHAR_IN_UNICODE_STRING_CASE_INSENSITIVE)) != 0) ||
        (NonInclusivePrefixLength == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = RtlValidateUnicodeString(0, StringToSearch);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = RtlValidateUnicodeString(0, CharSet);
    if (!NT_SUCCESS(Status))
        goto Exit;

    CharsToSearch = StringToSearch->Length / sizeof(WCHAR);
    CharSetChars = CharSet->Length / sizeof(WCHAR);
    CharSetBuffer = CharSet->Buffer;

    if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END) {
        MovementDirection = -1;
        Cursor = StringToSearch->Buffer + CharsToSearch - 1;
    } else {
        MovementDirection = 1;
        Cursor = StringToSearch->Buffer;
    }

    if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_CASE_INSENSITIVE) {
        // Unicode standard says to always do case insensitive comparisons in lower case since the case mappings are
        // asymmetric.
        WCHAR CharSetStackBuffer[32]; // optimized pre-downcased for case insensitive

        // Optimization for the case of a relatively small char set to match
        if (CharSetChars <= RTL_NUMBER_OF(CharSetStackBuffer)) {

            for (i=0; i<CharSetChars; i++)
                CharSetStackBuffer[i] = RtlDowncaseUnicodeChar(CharSetBuffer[i]);

            while (CharsToSearch != 0) {
                const WCHAR wch = RtlDowncaseUnicodeChar(*Cursor);

                if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET) {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == CharSetStackBuffer[i])
                            break;
                    }

                    if (i == CharSetChars)
                        break;
                } else {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == CharSetStackBuffer[i])
                            break;
                    }

                    if (i != CharSetChars)
                        break;
                }

                CharsToSearch--;
                Cursor += MovementDirection;
            }
        } else {
            while (CharsToSearch != 0) {
                const WCHAR wch = RtlDowncaseUnicodeChar(*Cursor);

                if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET) {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == RtlDowncaseUnicodeChar(CharSetBuffer[i])) {
                            break;
                        }
                    }

                    if (i == CharSetChars)
                        break;
                } else {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == RtlDowncaseUnicodeChar(CharSetBuffer[i])) {
                            break;
                        }
                    }

                    if (i != CharSetChars)
                        break;
                }

                CharsToSearch--;
                Cursor += MovementDirection;
            }
        }
    } else {
        if (CharSetChars == 1) {
            // Significant optimization for looking for one character.
            const WCHAR wchSearchChar = CharSetBuffer[0];

            if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET) {
                while (CharsToSearch != 0) {
                    if (*Cursor != wchSearchChar)
                        break;
                    CharsToSearch--;
                    Cursor += MovementDirection;
                }
            } else {
                while (CharsToSearch != 0) {
                    if (*Cursor == wchSearchChar)
                        break;
                    CharsToSearch--;
                    Cursor += MovementDirection;
                }
            }
        } else {
            while (CharsToSearch != 0) {
                const WCHAR wch = *Cursor;

                if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET) {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == CharSetBuffer[i])
                            break;
                    }

                    if (i == CharSetChars)
                        break;

                } else {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == CharSetBuffer[i])
                            break;
                    }

                    if (i != CharSetChars)
                        break;
                }

                CharsToSearch--;
                Cursor += MovementDirection;
            }
        }
    }

    if (CharsToSearch == 0) {
        Status = STATUS_NOT_FOUND;
        goto Exit;
    }

    CharsToSearch--;

    if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END)
        PrefixLengthFound = (USHORT) (CharsToSearch * sizeof(WCHAR));
    else
        PrefixLengthFound = (USHORT) (StringToSearch->Length - (CharsToSearch * sizeof(WCHAR)));

    *NonInclusivePrefixLength = PrefixLengthFound;

    Status = STATUS_SUCCESS;

Exit:
    return Status;
}


NTSTATUS
NTAPI
RtlFindAndReplaceCharacterInString(
    ULONG           Flags,
    PVOID           Reserved,
    PUNICODE_STRING String,
    WCHAR           Find,
    WCHAR           Replace
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index = 0;
    ULONG Length = 0;
    typedef WCHAR TChar;

    if (Flags & ~RTL_FIND_AND_REPLACE_CHARACTER_IN_STRING_CASE_SENSITIVE) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (Reserved != NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (String == NULL
        || Find == Replace
        ) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    Length = RTL_STRING_GET_LENGTH_CHARS(String);
    if (Length == 0) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    if ((Flags & RTL_FIND_AND_REPLACE_CHARACTER_IN_STRING_CASE_SENSITIVE) != 0) {
        for (Index = 0 ; Index != Length ; ++Index) {
            if (   String->Buffer[Index] == Find
                ) {
                String->Buffer[Index] = Replace;
            }
        }
    }
    else {
        TChar DownFind = RtlDowncaseUnicodeChar(Find);
        TChar UpFind   = RtlUpcaseUnicodeChar(Find);
        for (Index = 0 ; Index != Length ; ++Index) {
            const TChar Char = String->Buffer[Index];
            if (   Char == Find
                || Char == UpFind
                || Char == DownFind
                ) {
                String->Buffer[Index] = Replace;
            }
            else {
                TChar DownChar = RtlDowncaseUnicodeChar(Char);
                if (   DownChar == Find
                    //|| DownChar == UpFind // presumably not possible
                    || DownChar == DownFind
                    ) {
                    String->Buffer[Index] = Replace;
                }
                else if (DownChar != Char) {
                    TChar UpChar = RtlUpcaseUnicodeChar(Char);
                    if (   UpChar == Find
                        || UpChar == UpFind
                        //||UpChar == DownFind // presumably not possible
                        ) {
                        String->Buffer[Index] = Replace;
                    }
                }
            }
        }
    }
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\ntrtlp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    ntrtlp.h

Abstract:

    Include file for NT runtime routines that are callable by both
    kernel mode code in the executive and user mode code in various
    NT subsystems, but which are private interfaces.

--*/

#ifndef _NTRTLP_
#define _NTRTLP_
#include <ntos.h>
#include <nturtl.h>
#include <zwapi.h>

#if defined(_AMD64_)
#include "amd64\ntrtlamd64.h"

#elif defined(_X86_)
#include "i386\ntrtl386.h"

#else
#error "no target architecture"
#endif

#include "string.h"
#include "wchar.h"

//
// This is the maximum MaximumLength for a UNICODE_STRING.
//
#define MAX_USTRING ( sizeof(WCHAR) * (MAXUSHORT/sizeof(WCHAR)) )

#define ASSERT_WELL_FORMED_UNICODE_STRING(Str) \
    ASSERT( (!(((Str)->Length&1) || ((Str)->MaximumLength&1) )) && ((Str)->Length <= (Str)->MaximumLength) )

#define ASSERT_WELL_FORMED_UNICODE_STRING_IN(Str) \
    ASSERT( !((Str)->Length&1) )

#define ASSERT_WELL_FORMED_UNICODE_STRING_OUT(Str) \
    ASSERT( (!((Str)->MaximumLength&1)) && ((Str)->Length <= (Str)->MaximumLength) )

//
//  Machine state reporting.  See machine specific includes for more.
//

#if defined(_WIN64)

extern PVOID RtlpFunctionAddressTable[];
extern UNWIND_HISTORY_TABLE RtlpUnwindHistoryTable;

#endif

VOID
RtlCaptureImageExceptionValues(
    IN  PVOID Base,
    OUT PVOID *FunctionTable,
    OUT PULONG TableSize
    );

LONG
LdrpCompareResourceNames(
    IN ULONG ResourceName,
    IN const IMAGE_RESOURCE_DIRECTORY* ResourceDirectory,
    IN const IMAGE_RESOURCE_DIRECTORY_ENTRY* ResourceDirectoryEntry
    );

NTSTATUS
LdrpSearchResourceSection(
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN BOOLEAN FindDirectoryEntry,
    OUT PVOID *ResourceDirectoryOrData
    );
PVOID
LdrpGetAlternateResourceModuleHandle(
    IN PVOID Module,
    IN LANGID LangId
    );
LONG
LdrpCompareResourceNames_U(
    IN ULONG_PTR ResourceName,
    IN const IMAGE_RESOURCE_DIRECTORY* ResourceDirectory,
    IN const IMAGE_RESOURCE_DIRECTORY_ENTRY* ResourceDirectoryEntry
    );

NTSTATUS
LdrpSearchResourceSection_U(
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN ULONG Flags,
    OUT PVOID *ResourceDirectoryOrData
    );

NTSTATUS
LdrpAccessResourceData(
    IN PVOID DllHandle,
    IN const IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    );

NTSTATUS
LdrpAccessResourceDataNoMultipleLanguage(
    IN PVOID DllHandle,
    IN const IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    );

VOID
RtlpAnsiPszToUnicodePsz(
    IN PCHAR AnsiString,
    IN WCHAR *UnicodeString,
    IN USHORT AnsiStringLength
    );

BOOLEAN
RtlpDidUnicodeToOemWork(
    IN PCOEM_STRING OemString,
    IN PCUNICODE_STRING UnicodeString
    );

extern CONST CCHAR RtlpBitsClearAnywhere[256];
extern CONST CCHAR RtlpBitsClearLow[256];
extern CONST CCHAR RtlpBitsClearHigh[256];
extern CONST CCHAR RtlpBitsClearTotal[256];

//
//  Macro that tells how many contiguous bits are set (i.e., 1) in
//  a byte
//

#define RtlpBitSetAnywhere( Byte ) RtlpBitsClearAnywhere[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many contiguous LOW order bits are set
//  (i.e., 1) in a byte
//

#define RtlpBitsSetLow( Byte ) RtlpBitsClearLow[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many contiguous HIGH order bits are set
//  (i.e., 1) in a byte
//

#define RtlpBitsSetHigh( Byte ) RtlpBitsClearHigh[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many set bits (i.e., 1) there are in a byte
//

#define RtlpBitsSetTotal( Byte ) RtlpBitsClearTotal[ (~(Byte) & 0xFF) ]



//
// Upcase data table
//

extern PUSHORT Nls844UnicodeUpcaseTable;
extern PUSHORT Nls844UnicodeLowercaseTable;


//
// Macros for Upper Casing a Unicode Code Point.
//

#define LOBYTE(w)           ((UCHAR)((w)))
#define HIBYTE(w)           ((UCHAR)(((USHORT)((w)) >> 8) & 0xFF))
#define GET8(w)             ((ULONG)(((w) >> 8) & 0xff))
#define GETHI4(w)           ((ULONG)(((w) >> 4) & 0xf))
#define GETLO4(w)           ((ULONG)((w) & 0xf))

/***************************************************************************\
* TRAVERSE844W
*
* Traverses the 8:4:4 translation table for the given wide character.  It
* returns the final value of the 8:4:4 table, which is a WORD in length.
*
*   Broken Down Version:
*   --------------------
*       Incr = pTable[GET8(wch)];
*       Incr = pTable[Incr + GETHI4(wch)];
*       Value = pTable[Incr + GETLO4(wch)];
*
* DEFINED AS A MACRO.
*
\***************************************************************************/

#define TRAVERSE844W(pTable, wch)                                               \
    ( (pTable)[(pTable)[(pTable)[GET8((wch))] + GETHI4((wch))] + GETLO4((wch))] )

//
// NLS_UPCASE - Based on macros in nls.h
//
// We will have this upcase macro quickly shortcircuit out if the value
// is within the normal ANSI range (i.e., < 127).  We actually won't bother
// with the 5 values above 'z' because they won't happen very often and
// coding it this way lets us get out after 1 compare for value less than
// 'a' and 2 compares for lowercase a-z.
//

#define NLS_UPCASE(wch) (                                                   \
    ((wch) < 'a' ?                                                          \
        (wch)                                                               \
    :                                                                       \
        ((wch) <= 'z' ?                                                     \
            (wch) - ('a'-'A')                                               \
        :                                                                   \
            ((WCHAR)((wch) + TRAVERSE844W(Nls844UnicodeUpcaseTable,(wch)))) \
        )                                                                   \
    )                                                                       \
)

#define NLS_DOWNCASE(wch) (                                                 \
    ((wch) < 'A' ?                                                          \
        (wch)                                                               \
    :                                                                       \
        ((wch) <= 'Z' ?                                                     \
            (wch) + ('a'-'A')                                               \
        :                                                                   \
            ((WCHAR)((wch) + TRAVERSE844W(Nls844UnicodeLowercaseTable,(wch)))) \
        )                                                                   \
    )                                                                       \
)

#if DBG
#define RTL_PAGED_CODE() PAGED_CODE()
#else
#define RTL_PAGED_CODE()
#endif


//
// The follow definition is used to support the Rtl compression engine
// Every compression format that NT supports will need to supply
// these set of routines in order to be called by NtRtl.
//

typedef NTSTATUS (*PRTL_COMPRESS_WORKSPACE_SIZE) (
    IN USHORT CompressionEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );

typedef NTSTATUS (*PRTL_COMPRESS_BUFFER) (
    IN USHORT CompressionEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );

typedef NTSTATUS (*PRTL_DECOMPRESS_BUFFER) (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

typedef NTSTATUS (*PRTL_DECOMPRESS_FRAGMENT) (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

typedef NTSTATUS (*PRTL_DESCRIBE_CHUNK) (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

typedef NTSTATUS (*PRTL_RESERVE_CHUNK) (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

//
// Here is the declarations of the LZNT1 routines
//

NTSTATUS
RtlCompressWorkSpaceSizeLZNT1 (
    IN USHORT CompressionEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );

NTSTATUS
RtlCompressBufferLZNT1 (
    IN USHORT CompressionEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlDecompressBufferLZNT1 (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

NTSTATUS
RtlDecompressFragmentLZNT1 (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlDescribeChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

NTSTATUS
RtlReserveChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );


NTSTATUS
RtlpSecMemFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
     );

//
// Define procedure prototypes for architecture specific debug support routines.
//

NTSTATUS
DebugPrint(
    IN PSTRING Output,
    IN ULONG ComponentId,
    IN ULONG Level
    );

ULONG
DebugPrompt(
    IN PSTRING Output,
    IN PSTRING Input
    );

#endif  // _NTRTLP_

//
// Procedure prototype for exception logging routines.

ULONG
RtlpLogExceptionHandler(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN ULONG_PTR ControlPc,
    IN PVOID HandlerData,
    IN ULONG Size
    );

VOID
RtlpLogLastExceptionDisposition(
    IN ULONG LogIndex,
    IN EXCEPTION_DISPOSITION Disposition
    );

#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\peb.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Peb.c

Abstract:

    Get the PEB for the current process safely

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,RtlGetCurrentPeb)
#pragma alloc_text(PAGE,RtlSetProcessIsCritical)
#pragma alloc_text(PAGE,RtlSetThreadIsCritical)
#endif

PPEB
RtlGetCurrentPeb (
    VOID)
{
    PAGED_CODE ();

    return PsGetCurrentProcess ()->Peb;
}

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetProcessIsCritical(
    IN  BOOLEAN  NewValue,
    OUT PBOOLEAN OldValue OPTIONAL,
    IN  BOOLEAN  CheckFlag
    )
{
    PPEB     Peb;
    ULONG    Enable;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(OldValue) ) {
        *OldValue = FALSE;
    }

    Peb = RtlGetCurrentPeb();
    if ( CheckFlag
         && ! (Peb->NtGlobalFlag & FLG_ENABLE_SYSTEM_CRIT_BREAKS) ) {
        return STATUS_UNSUCCESSFUL;
    }
    if ( ARGUMENT_PRESENT(OldValue) ) {
        NtQueryInformationProcess(NtCurrentProcess(),
                                  ProcessBreakOnTermination,
                                  &Enable,
                                  sizeof(Enable),
                                  NULL);

        *OldValue = (BOOLEAN) Enable;
    }

    Enable = NewValue;

    Status = NtSetInformationProcess(NtCurrentProcess(),
                                     ProcessBreakOnTermination,
                                     &Enable,
                                     sizeof(Enable));

    return Status;
}

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetThreadIsCritical(
    IN  BOOLEAN  NewValue,
    OUT PBOOLEAN OldValue OPTIONAL,
    IN  BOOLEAN  CheckFlag
    )
{
    PPEB     Peb;
    ULONG    Enable;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(OldValue) ) {
        *OldValue = FALSE;
    }

    Peb = RtlGetCurrentPeb();
    if ( CheckFlag
         && ! (Peb->NtGlobalFlag & FLG_ENABLE_SYSTEM_CRIT_BREAKS) ) {
        return STATUS_UNSUCCESSFUL;
    }
    if ( ARGUMENT_PRESENT(OldValue) ) {
        NtQueryInformationThread(NtCurrentThread(),
                                 ThreadBreakOnTermination,
                                 &Enable,
                                 sizeof(Enable),
                                 NULL);

        *OldValue = (BOOLEAN) Enable;
    }

    Enable = NewValue;

    Status = NtSetInformationThread(NtCurrentThread(),
                                    ThreadBreakOnTermination,
                                    &Enable,
                                    sizeof(Enable));

    return Status;
}

NTSYSAPI
NTSTATUS
NTAPI
RtlCheckProcessParameters(PVOID p1,
                          PWSTR p2,
                          PULONG p3,
                          ULONG v1)
{
    while (*p2) {
        p3[2] = p3[1];
        p3[1] = p3[0];
        p3[0] = *p2;
        p2++;
    }

    v1 = * (volatile WCHAR *) p2;
    v1 *= ((PULONG) p1)[0];
    p3[v1] += ((PULONG) p1)[2];
    v1 += 2;
    p3[v1] = v1 * 3;
    return (NTSTATUS) 0xc0000578;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\regutil.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    regutil.c

Abstract:

    This file contains support routines for accessing the registry.

--*/

#include "ntrtlp.h"
#include <ctype.h>

NTSTATUS
RtlpGetRegistryHandle(
    IN ULONG RelativeTo,
    IN PCWSTR KeyName,
    IN BOOLEAN WriteAccess,
    OUT PHANDLE Key
    );

NTSTATUS
RtlpQueryRegistryDirect(
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN OUT PVOID Destination
    );

NTSTATUS
RtlpCallQueryRegistryRoutine(
    IN PRTL_QUERY_REGISTRY_TABLE QueryTable,
    IN PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    IN OUT PULONG PKeyValueInfoLength,
    IN PVOID Context,
    IN PVOID Environment OPTIONAL
    );

PVOID
RtlpAllocDeallocQueryBuffer(
   IN OUT SIZE_T    *PAllocLength            OPTIONAL,
   IN     PVOID      OldKeyValueInformation  OPTIONAL,
   IN     SIZE_T     OldAllocLength          OPTIONAL,
      OUT NTSTATUS  *pStatus                 OPTIONAL
    );

NTSTATUS
RtlpInitCurrentUserString(
    OUT PUNICODE_STRING UserString
    );


NTSTATUS
RtlpGetTimeZoneInfoHandle(
    IN BOOLEAN WriteAccess,
    OUT PHANDLE Key
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,RtlpGetRegistryHandle)
#pragma alloc_text(PAGE,RtlpQueryRegistryDirect)
#pragma alloc_text(PAGE,RtlpCallQueryRegistryRoutine)
#pragma alloc_text(PAGE,RtlpAllocDeallocQueryBuffer)
#pragma alloc_text(PAGE,RtlQueryRegistryValues)
#pragma alloc_text(PAGE,RtlWriteRegistryValue)
#pragma alloc_text(PAGE,RtlCheckRegistryKey)
#pragma alloc_text(PAGE,RtlCreateRegistryKey)
#pragma alloc_text(PAGE,RtlDeleteRegistryValue)
#pragma alloc_text(PAGE,RtlExpandEnvironmentStrings_U)
#pragma alloc_text(PAGE,RtlFormatCurrentUserKeyPath)
#pragma alloc_text(PAGE,RtlGetNtGlobalFlags)
#pragma alloc_text(PAGE,RtlpInitCurrentUserString)
#pragma alloc_text(PAGE,RtlOpenCurrentUser)
#pragma alloc_text(PAGE,RtlpGetTimeZoneInfoHandle)
#pragma alloc_text(PAGE,RtlQueryTimeZoneInformation)
#pragma alloc_text(PAGE,RtlSetTimeZoneInformation)
#pragma alloc_text(PAGE,RtlSetActiveTimeBias)
#endif

extern  const PWSTR RtlpRegistryPaths[ RTL_REGISTRY_MAXIMUM ];

NTSTATUS
RtlpGetRegistryHandle(
    IN ULONG RelativeTo,
    IN PCWSTR KeyName,
    IN BOOLEAN WriteAccess,
    OUT PHANDLE Key
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR KeyPathBuffer[ MAXIMUM_FILENAME_LENGTH+6 ];
    UNICODE_STRING KeyPath;
    UNICODE_STRING CurrentUserKeyPath;
    BOOLEAN OptionalPath;

    if (RelativeTo & RTL_REGISTRY_HANDLE) {
        *Key = (HANDLE)KeyName;
        return STATUS_SUCCESS;
    }

    if (RelativeTo & RTL_REGISTRY_OPTIONAL) {
        RelativeTo &= ~RTL_REGISTRY_OPTIONAL;
        OptionalPath = TRUE;
    } else {
        OptionalPath = FALSE;
    }

    if (RelativeTo >= RTL_REGISTRY_MAXIMUM) {
        return STATUS_INVALID_PARAMETER;
    }

    KeyPath.Buffer = KeyPathBuffer;
    KeyPath.Length = 0;
    KeyPath.MaximumLength = sizeof( KeyPathBuffer );
    if (RelativeTo != RTL_REGISTRY_ABSOLUTE) {
        if (RelativeTo == RTL_REGISTRY_USER &&
            NT_SUCCESS( RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath ) )
           ) {
            Status = RtlAppendUnicodeStringToString( &KeyPath, &CurrentUserKeyPath );
            RtlFreeUnicodeString( &CurrentUserKeyPath );
        } else {
            Status = RtlAppendUnicodeToString( &KeyPath, RtlpRegistryPaths[ RelativeTo ] );
        }

        if (!NT_SUCCESS( Status )) {
            return Status;
        }

        Status = RtlAppendUnicodeToString( &KeyPath, L"\\" );
        if (!NT_SUCCESS( Status )) {
            return Status;
        }
    }

    Status = RtlAppendUnicodeToString( &KeyPath, KeyName );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }


    //
    // Use a kernel-mode handle for the registry key to prevent
    // malicious apps from hijacking it.
    //
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL
                              );
    if (WriteAccess) {
        Status = ZwCreateKey( Key,
                              GENERIC_WRITE,
                              &ObjectAttributes,
                              0,
                              (PUNICODE_STRING) NULL,
                              0,
                              NULL
                            );
    } else {
        Status = ZwOpenKey( Key,
                            MAXIMUM_ALLOWED | GENERIC_READ,
                            &ObjectAttributes
                          );
    }

    return Status;
}

//
// This is the maximum MaximumLength for a UNICODE_STRING that still leaves
// room for a UNICODE_NULL.
//
#define MAX_NONNULL_USTRING ( MAX_USTRING - sizeof(UNICODE_NULL) )

//
// Return a registry value for RTL_QUERY_REGISTRY_DIRECT.
// For string values, ValueLength includes the UNICODE_NULL.
// Truncate string values if they don't fit within a UNICODE_STRING.
//
NTSTATUS
RtlpQueryRegistryDirect(
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN OUT PVOID Destination
    )
{

    if (ValueType == REG_SZ ||
        ValueType == REG_EXPAND_SZ ||
        ValueType == REG_MULTI_SZ
       ) {
        PUNICODE_STRING DestinationString;
        USHORT TruncValueLength;

        //
        // Truncate ValueLength to be represented in a UNICODE_STRING
        //
        if ( ValueLength <= MAX_USTRING ) {
            TruncValueLength = (USHORT)ValueLength;
        } else {
            TruncValueLength = MAX_USTRING;

#if DBG
            DbgPrint("RtlpQueryRegistryDirect: truncating SZ Value length: %x -> %x\n",
                     ValueLength, TruncValueLength);
#endif //DBG
        }

        DestinationString = (PUNICODE_STRING)Destination;
        if (DestinationString->Buffer == NULL) {

            DestinationString->Buffer = RtlAllocateStringRoutine( TruncValueLength );
            if (!DestinationString->Buffer) {
                return STATUS_NO_MEMORY;
            }
            DestinationString->MaximumLength = TruncValueLength;
        } else if (TruncValueLength > DestinationString->MaximumLength) {
                return STATUS_BUFFER_TOO_SMALL;
        }

        RtlCopyMemory( DestinationString->Buffer, ValueData, TruncValueLength );
        DestinationString->Length = (TruncValueLength - sizeof(UNICODE_NULL));

    } else if (ValueLength <= sizeof( ULONG )) {
        if (Destination != ValueData && ValueLength)
            RtlCopyMemory( Destination, ValueData, ValueLength );

    } else {
        PULONG DestinationLength;

        DestinationLength = (PULONG)Destination;
        if ((LONG)*DestinationLength < 0) {
            ULONG n = -(LONG)*DestinationLength;

            if (n < ValueLength) {
                return STATUS_BUFFER_TOO_SMALL;
            }
            RtlCopyMemory( DestinationLength, ValueData, ValueLength );

        } else {
            if (*DestinationLength < (2 * sizeof(*DestinationLength) + ValueLength)) {
                return STATUS_BUFFER_TOO_SMALL;
            }

            *DestinationLength++ = ValueLength;
            *DestinationLength++ = ValueType;
            RtlCopyMemory( DestinationLength, ValueData, ValueLength );
        }
    }

    return STATUS_SUCCESS;
}

#define QuadAlignPtr(P) (             \
    (PVOID)((((ULONG_PTR)(P)) + 7) & (-8)) \
)

NTSTATUS
RtlpCallQueryRegistryRoutine(
    IN PRTL_QUERY_REGISTRY_TABLE QueryTable,
    IN PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    IN OUT PULONG PKeyValueInfoLength,
    IN PVOID Context,
    IN PVOID Environment OPTIONAL
    )

/*++

Routine Description:

    This function implements the caller out the a caller specified
    routine.  It is reponsible for capturing the arguments for the
    routine and then calling it.  If not specifically disabled, this
    routine will converted REG_EXPAND_SZ Registry values to REG_SZ by
    calling RtlExpandEnvironmentStrings_U prior to calling the routine.
    It will also converted REG_MULTI_SZ registry values into multiple
    REG_SZ calls to the specified routine.

    N.B. UNICODE_STRINGs cannot handle strings exceeding MAX_USTRING bytes. This creates
    issues both for expansion and for returning queries.  Whenever this limitation
    is a encountered, we punt as best we can -- often returning an unexpanded, or perhaps
    truncated stream -- since this seems to create fewer problems for our callers than
    if we unexpectedly fail.

Arguments:

    QueryTable - specifies the current query table entry.

    KeyValueInformation - points to a buffer that contains the information
        about the current registry value.

    PKeyValueInfoLength - pointer to the maximum length of the KeyValueInformation
        buffer.  This function will use the
        unused portion at the end of this buffer for storing null terminated
        value name strings and the expanded version of REG_EXPAND_SZ values.
        PKeyValueInfoLength returns an estimate of the space required if
        STATUS_BUFFER_TOO_SMALL is returned.  This estimate can be used to retry
        with a larger buffer. Two retries may be required if REG_EXPAND_SZ is specified.

    Context - specifies a 32-bit quantity that is passed uninterpreted to
        each QueryRoutine called.

    Environment - optional parameter, that if specified is the environment
        used when expanding variable values in REG_EXPAND_SZ registry
        values.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    ULONG ValueType;
    PWSTR ValueName;
    PVOID ValueData;
    ULONG ValueLength;
    PWSTR s;
    PCHAR FreeMem;
    PCHAR EndFreeMem;
    LONG  FreeMemSize;
    ULONG KeyValueInfoLength;
    int   retries;


    //
    // Return 0 length unless we return STATUS_BUFFER_TOO_SMALL.
    //
    KeyValueInfoLength = *PKeyValueInfoLength;
    *PKeyValueInfoLength = 0;

    //
    // the registry has signaled no data for this value
    //
    if( KeyValueInformation->DataOffset == (ULONG)-1 ) {
        //
        // Return success unless this is a required value.
        //
        if ( QueryTable->Flags & RTL_QUERY_REGISTRY_REQUIRED ) {
           return STATUS_OBJECT_NAME_NOT_FOUND;
        } else {
           return STATUS_SUCCESS;
        }
    }

    //
    // Initially assume the entire KeyValueInformation buffer is unused.
    //

    FreeMem = (PCHAR)KeyValueInformation;
    FreeMemSize = KeyValueInfoLength;
    EndFreeMem = FreeMem + FreeMemSize;

    if (KeyValueInformation->Type == REG_NONE ||
        (KeyValueInformation->DataLength == 0 &&
         KeyValueInformation->Type == QueryTable->DefaultType)
       ) {

        //
        // If there is no registry value then see if they want to default
        // this value.
        //
        if (QueryTable->DefaultType == REG_NONE) {
            //
            // No default value specified.  Return success unless this is
            // a required value.
            //
            if ( QueryTable->Flags & RTL_QUERY_REGISTRY_REQUIRED ) {
               return STATUS_OBJECT_NAME_NOT_FOUND;
            } else {
               return STATUS_SUCCESS;
            }
        }

        //
        // Default requested.  Setup the value data pointers from the
        // information in the table entry.
        //

        ValueName = QueryTable->Name,
        ValueType = QueryTable->DefaultType;
        ValueData = QueryTable->DefaultData;
        ValueLength = QueryTable->DefaultLength;
        if (ValueLength == 0) {
            //
            // If the length of the value is zero, then calculate the
            // actual length for REG_SZ, REG_EXPAND_SZ and REG_MULTI_SZ
            // value types.
            //

            s = (PWSTR)ValueData;
            if (ValueType == REG_SZ || ValueType == REG_EXPAND_SZ) {
                while (*s++ != UNICODE_NULL) {
                }
                ValueLength = (ULONG)((PCHAR)s - (PCHAR)ValueData);

            } else if (ValueType == REG_MULTI_SZ) {
                while (*s != UNICODE_NULL) {
                    while (*s++ != UNICODE_NULL) {
                        }
                    }
                ValueLength = (ULONG)((PCHAR)s - (PCHAR)ValueData) + sizeof( UNICODE_NULL );
            }
        }

    } else {
        if (!(QueryTable->Flags & RTL_QUERY_REGISTRY_DIRECT)) {
            LONG ValueSpaceNeeded;

            //
            // There is a registry value.  Calculate a pointer to the
            // free memory at the end of the value information buffer,
            // and its size.
            //
            if (KeyValueInformation->DataLength) {
                FreeMem += KeyValueInformation->DataOffset +
                           KeyValueInformation->DataLength;
            } else {
                FreeMem += FIELD_OFFSET(KEY_VALUE_FULL_INFORMATION, Name) +
                           KeyValueInformation->NameLength;
            }
            FreeMem = (PCHAR)QuadAlignPtr(FreeMem);
            FreeMemSize = (ULONG) (EndFreeMem - FreeMem);

            //
            // See if there is room in the free memory area for a null
            // terminated copy of the value name string.  If not return
            // the length we require (so far) and an error.
            //
            ValueSpaceNeeded = KeyValueInformation->NameLength + sizeof(UNICODE_NULL);
            if ( FreeMemSize < ValueSpaceNeeded ) {

               *PKeyValueInfoLength = (ULONG)(((PCHAR)FreeMem - (PCHAR)KeyValueInformation) + ValueSpaceNeeded);
                return STATUS_BUFFER_TOO_SMALL;
            }

            //
            // There is room, so copy the string, and null terminate it.
            //

            ValueName = (PWSTR)FreeMem;
            RtlCopyMemory( ValueName,
                           KeyValueInformation->Name,
                           KeyValueInformation->NameLength
                         );
            *(PWSTR)((PCHAR)ValueName + KeyValueInformation->NameLength) = UNICODE_NULL;

            //
            // Update the free memory pointer and size to reflect the space we
            // just used for the null terminated value name.
            //
            FreeMem += ValueSpaceNeeded;
            FreeMem = (PCHAR)QuadAlignPtr(FreeMem);
            FreeMemSize = (LONG) (EndFreeMem - FreeMem);

        } else {
            ValueName = QueryTable->Name;
        }

        //
        // Get the remaining data for the registry value.
        //

        ValueType = KeyValueInformation->Type;
        ValueData = (PCHAR)KeyValueInformation + KeyValueInformation->DataOffset;
        ValueLength = KeyValueInformation->DataLength;
    }

    //
    // Unless specifically disabled for this table entry, preprocess
    // registry values of type REG_EXPAND_SZ and REG_MULTI_SZ
    //

    if (!(QueryTable->Flags & RTL_QUERY_REGISTRY_NOEXPAND)) {
        if (ValueType == REG_MULTI_SZ) {
            PWSTR ValueEnd;

            //
            // For REG_MULTI_SZ value type, call the query routine once
            // for each null terminated string in the registry value.  Fake
            // like this is multiple REG_SZ values with the same value name.
            //

            Status = STATUS_SUCCESS;
            ValueEnd = (PWSTR)((PCHAR)ValueData + ValueLength) - sizeof(UNICODE_NULL);
            s = (PWSTR)ValueData;
            while (s < ValueEnd) {
                while (*s++ != UNICODE_NULL) {
                }

                ValueLength = (ULONG)((PCHAR)s - (PCHAR)ValueData);
                if (QueryTable->Flags & RTL_QUERY_REGISTRY_DIRECT) {
                    Status = RtlpQueryRegistryDirect( REG_SZ,
                                                      ValueData,
                                                      ValueLength,
                                                      QueryTable->EntryContext
                                                    );
                    (PUNICODE_STRING)(QueryTable->EntryContext) += 1;

                } else {
                    Status = (QueryTable->QueryRoutine)( ValueName,
                                                         REG_SZ,
                                                         ValueData,
                                                         ValueLength,
                                                         Context,
                                                         QueryTable->EntryContext
                                                       );
                }

                //
                // We ignore failures where the buffer is too small.
                //
                if (Status == STATUS_BUFFER_TOO_SMALL) {
                   Status = STATUS_SUCCESS;
                }

                if (!NT_SUCCESS( Status )) {
                    break;
                }

                ValueData = (PVOID)s;
            }

            return Status;
        }

        //
        // If requested, expand the Value -- but only if the unexpanded value
        // can be represented with a UNICODE_STRING.
        //
        if ((ValueType == REG_EXPAND_SZ) &&
            (ValueLength >= sizeof(WCHAR)) &&
            (ValueLength <= MAX_NONNULL_USTRING)) {
            //
            // For REG_EXPAND_SZ value type, expand any environment variable
            // references in the registry value string using the Rtl function.
            //

            UNICODE_STRING Source;
            UNICODE_STRING Destination;
            PWCHAR  Src;
            ULONG   SrcLength;
            ULONG   RequiredLength;
            BOOLEAN PercentFound;

            //
            // Don't expand unless we have to since expansion doubles buffer usage.
            //

            PercentFound = FALSE;
            SrcLength = ValueLength - sizeof(WCHAR);
            Src = (PWSTR)ValueData;
            while (SrcLength) {
                if (*Src == L'%') {
                    PercentFound = TRUE;
                    break;
                }
                Src++;
                SrcLength -= sizeof(WCHAR);
            }

            if ( PercentFound ) {
                Source.Buffer = (PWSTR)ValueData;
                Source.MaximumLength = (USHORT)ValueLength;
                Source.Length = (USHORT)(Source.MaximumLength - sizeof(UNICODE_NULL));
                Destination.Buffer = (PWSTR)FreeMem;
                Destination.Length = 0;

                if (FreeMemSize <= 0) {
                    Destination.MaximumLength = 0;
                } else if (FreeMemSize <= MAX_USTRING) {
                    Destination.MaximumLength = (USHORT)FreeMemSize;
                    Destination.Buffer[FreeMemSize/sizeof(WCHAR) - 1] = UNICODE_NULL;
                } else {
                    Destination.MaximumLength = MAX_USTRING;
                    Destination.Buffer[MAX_USTRING/sizeof(WCHAR) - 1] = UNICODE_NULL;
                }

                Status = RtlExpandEnvironmentStrings_U( Environment,
                                                        &Source,
                                                        &Destination,
                                                        &RequiredLength
                                                      );
                ValueType = REG_SZ;

                if ( NT_SUCCESS(Status) ) {
                    ValueData = Destination.Buffer;
                    ValueLength = Destination.Length + sizeof( UNICODE_NULL );
                } else {
                    if (Status == STATUS_BUFFER_TOO_SMALL) {
                       *PKeyValueInfoLength = (ULONG)((PCHAR)FreeMem - (PCHAR)KeyValueInformation) + RequiredLength;
                    }
//#if DBG
                    if (Status == STATUS_BUFFER_TOO_SMALL) {
                       DbgPrint( "RTL: Expand variables for %wZ failed - Status == %lx Size %x > %x <%x>\n",
                                     &Source, Status, *PKeyValueInfoLength, KeyValueInfoLength,
                                     Destination.MaximumLength );
                    } else {
                       DbgPrint( "RTL: Expand variables for %wZ failed - Status == %lx\n", &Source, Status );
                    }
//#endif  // DBG
                    if ( Status == STATUS_BUFFER_OVERFLOW ||
                         Status == STATUS_BUFFER_TOO_SMALL &&
                        ( Destination.MaximumLength == MAX_USTRING
                         || RequiredLength > MAX_NONNULL_USTRING ) ) {

                       // We can't do variable expansion because the required buffer can't be described
                       // by a UNICODE_STRING, so we silently ignore expansion.
                   } else {
                        return Status;
                   }
                }
            }
        }
    }

    //
    // No special process of the registry value required so just call
    // the query routine.
    //
    if (QueryTable->Flags & RTL_QUERY_REGISTRY_DIRECT) {
        Status = RtlpQueryRegistryDirect( ValueType,
                                          ValueData,
                                          ValueLength,
                                          QueryTable->EntryContext
                                        );
    } else {
        Status = (QueryTable->QueryRoutine)( ValueName,
                                             ValueType,
                                             ValueData,
                                             ValueLength,
                                             Context,
                                             QueryTable->EntryContext
                                           );

    }

    //
    // At this point we fail silently if the buffer is too small.
    //
    if (Status == STATUS_BUFFER_TOO_SMALL) {
        Status = STATUS_SUCCESS;
    }
    return Status;
}

//
// Most of the registry queries in the kernel are small (40-50 bytes).
// User queries use ZwAllocateVirtualMemory, so nothing less than a page will do.
//
#if defined(ALLOC_DATA_PRAGMA)
#pragma const_seg("PAGECONST")
#endif
const SIZE_T RtlpRegistryQueryInitialBuffersize = 0x80 + sizeof(PVOID);

//
// Allocate, Free, or Free/Allocate space for registry queries.
//
PVOID
RtlpAllocDeallocQueryBuffer(
   IN OUT SIZE_T    *PAllocLength            OPTIONAL,
   IN     PVOID      OldKeyValueInformation  OPTIONAL,
   IN     SIZE_T     OldAllocLength          OPTIONAL,
      OUT NTSTATUS  *pStatus                 OPTIONAL
   )
{
   PVOID    Ptr     = NULL;
   NTSTATUS Status  = STATUS_SUCCESS;

   //
   // Kernel version
   //

   UNREFERENCED_PARAMETER( OldAllocLength );

   if ( ARGUMENT_PRESENT(OldKeyValueInformation) ) {
      ExFreePool( OldKeyValueInformation );
   }

   if ( ARGUMENT_PRESENT(PAllocLength) ) {
      Ptr = ExAllocatePoolWithTag( PagedPool, *PAllocLength, 'vrqR' );
      if (Ptr == NULL) {
         Status = STATUS_NO_MEMORY;
      }
   }

   if ( ARGUMENT_PRESENT(pStatus) ) {
      *pStatus = Status;
   }

   return Ptr;
}

NTSTATUS
RtlQueryRegistryValues(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PRTL_QUERY_REGISTRY_TABLE QueryTable,
    IN PVOID Context,
    IN PVOID Environment OPTIONAL
    )

/*++

Routine Description:

    This function allows the caller to query multiple values from the registry
    sub-tree with a single call.  The caller specifies an initial key path,
    and a table.  The table contains one or more entries that describe the
    key values and subkey names the caller is interested in.  This function
    starts at the initial key and enumerates the entries in the table.  For
    each entry that specifies a value name or subkey name that exists in
    the registry, this function calls the caller's query routine associated
    with each table entry.  The caller's query routine is passed the value
    name, type, data and data length, to do with what they wish.

Arguments:

    RelativeTo - specifies that the Path parameter is either an absolute
        registry path, or a path relative to a predefined key path.  The
        following values are defined:

        RTL_REGISTRY_ABSOLUTE   - Path is an absolute registry path
        RTL_REGISTRY_SERVICES   - Path is relative to \Registry\Machine\System\CurrentControlSet\Services
        RTL_REGISTRY_CONTROL    - Path is relative to \Registry\Machine\System\CurrentControlSet\Control
        RTL_REGISTRY_WINDOWS_NT - Path is relative to \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
        RTL_REGISTRY_DEVICEMAP  - Path is relative to \Registry\Machine\Hardware\DeviceMap
        RTL_REGISTRY_USER       - Path is relative to \Registry\User\CurrentUser

        RTL_REGISTRY_OPTIONAL   - Bit that specifies the key referenced by
                                  this parameter and the Path parameter is
                                  optional.

        RTL_REGISTRY_HANDLE     - Bit that specifies that the Path parameter
                                  is actually a registry handle to use.
                                  optional.

    Path - specifies either an absolute registry path, or a path relative to the
        known location specified by the RelativeTo parameter.  If the the
        RTL_REGISTRY_HANDLE flag is specified, then this parameter is a
        registry handle to use directly.

    QueryTable - specifies a table of one or more value names and subkey names
        that the caller is interested.  Each table entry contains a query routine
        that will be called for each value name that exists in the registry.
        The table is terminated when a NULL table entry is reached.  A NULL
        table entry is defined as a table entry with a NULL QueryRoutine
        and a NULL Name field.

        QueryTable entry fields:

        PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine - This routine is
            called with the name, type, data and data length of a
            registry value.  If this field is NULL, then it marks the
            end of the table.

        ULONG Flags - These flags control how the following fields are
            interpreted.  The following flags are defined:

            RTL_QUERY_REGISTRY_SUBKEY - says the Name field of this
                table entry is another path to a registry key and all
                following table entries are for that key rather than the
                key specified by the Path parameter.  This change in
                focus lasts until the end of the table or another
                RTL_QUERY_REGISTRY_SUBKEY entry is seen or
                RTL_QUERY_REGISTRY_TOPKEY entry is seen.  Each such
                entry must specify a path that is relative to the Path
                specified on the call to this function.

            RTL_QUERY_REGISTRY_TOPKEY - resets the current registry key
                handle to the original one specified by the RelativeTo
                and Path parameters.  Useful for getting back to the
                original node after descending into subkeys with the
                RTL_QUERY_REGISTRY_SUBKEY flag.

            RTL_QUERY_REGISTRY_REQUIRED - specifies that this value is
                required and if not found then STATUS_OBJECT_NAME_NOT_FOUND
                is returned.  For a table entry that specifies a NULL
                name so that this function will enumerate all of the
                value names under a key, STATUS_OBJECT_NAME_NOT_FOUND
                will be returned only if there are no value keys under
                the current key.

            RTL_QUERY_REGISTRY_NOVALUE - specifies that even though
                there is no Name field for this table entry, all the
                caller wants is a call back, it does NOT want to
                enumerate all the values under the current key.  The
                query routine is called with NULL for ValueData,
                REG_NONE for ValueType and zero for ValueLength.

            RTL_QUERY_REGISTRY_NOEXPAND - specifies that if the value
                type of this registry value is REG_EXPAND_SZ or
                REG_MULTI_SZ, then this function is NOT to do any
                preprocessing of the registry values prior to calling
                the query routine.  Default behavior is to expand
                environment variable references in REG_EXPAND_SZ
                values and to enumerate the NULL terminated strings
                in a REG_MULTI_SZ value and call the query routine
                once for each, making it look like multiple REG_SZ
                values with the same ValueName.

            RTL_QUERY_REGISTRY_DIRECT QueryRoutine field ignored.
                EntryContext field points to location to store value.
                For null terminated strings, EntryContext points to
                UNICODE_STRING structure that that describes maximum
                size of buffer.  If .Buffer field is NULL then a buffer
                is allocated.

            RTL_QUERY_REGISTRY_DELETE Used to delete value keys after
                they are queried.

        PWSTR Name - This field gives the name of a Value the caller
            wants to query the value of.  If this field is NULL, then
            the QueryRoutine specified for this table entry is called
            for all values associated with the current registry key.

        PVOID EntryContext - This field is an arbitrary 32-bit field
            that is passed uninterpreted to each QueryRoutine called.

        ULONG DefaultType
        PVOID DefaultData
        ULONG DefaultLength If there is no value name that matches the
            name given by the Name field, and the DefaultType field is
            not REG_NONE, then the QueryRoutine for this table entry is
            called with the contents of the following fields as if the
            value had been found in the registry.  If the DefaultType is
            REG_SZ, REG_EXPANDSZ or REG_MULTI_SZ and the DefaultLength
            is 0 then the value of DefaultLength will be computed based
            on the length of unicode string pointed to by DefaultData

    Context - specifies a 32-bit quantity that is passed uninterpreted to
        each QueryRoutine called.

    Environment - optional parameter, that if specified is the environment
        used when expanding variable values in REG_EXPAND_SZ registry
        values.

Return Value:

    Status of the operation.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    KeyPath, KeyValueName;
    HANDLE  Key, Key1;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    SIZE_T  KeyValueInfoLength;
    ULONG   ValueIndex;
    SIZE_T  AllocLength;
    ULONG   KeyResultLength;
    int     retries;

    RTL_PAGED_CODE();

    KeyValueInformation = NULL;

    Status = RtlpGetRegistryHandle( RelativeTo, Path, FALSE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    if ((RelativeTo & RTL_REGISTRY_HANDLE) == 0) {
        RtlInitUnicodeString(&KeyPath, Path);
    } else {
        RtlInitUnicodeString(&KeyPath, NULL);
    }

    AllocLength = RtlpRegistryQueryInitialBuffersize;

    KeyValueInformation = RtlpAllocDeallocQueryBuffer( &AllocLength, NULL, 0, &Status );
    if ( KeyValueInformation == NULL ) {
        if (!(RelativeTo & RTL_REGISTRY_HANDLE)) {
            ZwClose( Key );
        }
        return Status;
    }

    KeyValueInformation->DataOffset = 0;
    KeyValueInfoLength = AllocLength - sizeof(UNICODE_NULL);
    Key1 = Key;
    while (QueryTable->QueryRoutine != NULL ||
           (QueryTable->Flags & (RTL_QUERY_REGISTRY_SUBKEY | RTL_QUERY_REGISTRY_DIRECT))
          ) {

        if ((QueryTable->Flags & RTL_QUERY_REGISTRY_DIRECT) &&
            (QueryTable->Name == NULL ||
             (QueryTable->Flags & RTL_QUERY_REGISTRY_SUBKEY) ||
             QueryTable->QueryRoutine != NULL)
           ) {

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (QueryTable->Flags & (RTL_QUERY_REGISTRY_TOPKEY | RTL_QUERY_REGISTRY_SUBKEY)) {
            if (Key1 != Key) {
                NtClose( Key1 );
                Key1 = Key;
            }
        }

        if (QueryTable->Flags & RTL_QUERY_REGISTRY_SUBKEY) {
            if (QueryTable->Name == NULL) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                RtlInitUnicodeString( &KeyPath, QueryTable->Name );
                //
                // Use a kernel-mode handle for the registry key to prevent
                // malicious apps from hijacking it.
                //
                InitializeObjectAttributes( &ObjectAttributes,
                                            &KeyPath,
                                            OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                            Key,
                                            NULL
                                            );

                Status = ZwOpenKey( &Key1,
                                    MAXIMUM_ALLOWED,
                                    &ObjectAttributes
                                  );
                if (NT_SUCCESS( Status )) {
                    if (QueryTable->QueryRoutine != NULL) {
                        goto enumvalues;
                    }
                }
            }

        } else if (QueryTable->Name != NULL) {
                RtlInitUnicodeString( &KeyValueName, QueryTable->Name );
                retries = 0;
    retryqueryvalue:
                //
                // A maximum of two retries is expected. If we see more we must
                // have miscomputed how much is required for the query buffer.
                //
                if (retries++ > 4) {
//#if DBG
                   DbgPrint("RtlQueryRegistryValues: Miscomputed buffer size at line %d\n", __LINE__);
//#endif
                   break;
                }

                Status = ZwQueryValueKey( Key1,
                                          &KeyValueName,
                                          KeyValueFullInformation,
                                          KeyValueInformation,
                                          (ULONG) KeyValueInfoLength,
                                          &KeyResultLength
                                        );
                //
                // ZwQueryValueKey returns overflow even though the problem is that
                // the specified buffer was too small, so we fix that up here so we
                // can decide correctly whether to retry or not below.
                //
                if (Status == STATUS_BUFFER_OVERFLOW) {
                   Status = STATUS_BUFFER_TOO_SMALL;
                }

                if (!NT_SUCCESS( Status )) {
                    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

                        KeyValueInformation->Type = REG_NONE;
                        KeyValueInformation->DataLength = 0;
                        KeyResultLength = (ULONG)KeyValueInfoLength;
                        Status = RtlpCallQueryRegistryRoutine( QueryTable,
                                                               KeyValueInformation,
                                                               &KeyResultLength,
                                                               Context,
                                                               Environment
                                                             );
                    }

                   if (Status == STATUS_BUFFER_TOO_SMALL) {
                        //
                        // Try to allocate a larger buffer as this is one humongous
                        // value.
                        //
                        AllocLength = KeyResultLength + sizeof(PVOID) + sizeof(UNICODE_NULL);
                        KeyValueInformation = RtlpAllocDeallocQueryBuffer( &AllocLength,
                                                                           KeyValueInformation,
                                                                           AllocLength,
                                                                           &Status
                                                                         );
                        if ( KeyValueInformation == NULL) {
                           break;
                        }
                        KeyValueInformation->DataOffset = 0;
                        KeyValueInfoLength = AllocLength - sizeof(UNICODE_NULL);
                        goto retryqueryvalue;
                    }

                } else {
                    //
                    // KeyResultLength holds the length of the data returned by ZwQueryKeyValue.
                    // If this is a MULTI_SZ value, catenate a NUL.
                    //
                    if ( KeyValueInformation->Type == REG_MULTI_SZ ) {
                            *(PWCHAR) ((PUCHAR)KeyValueInformation + KeyResultLength) = UNICODE_NULL;
                            KeyValueInformation->DataLength += sizeof(UNICODE_NULL);
                    }

                    KeyResultLength = (ULONG)KeyValueInfoLength;
                    Status = RtlpCallQueryRegistryRoutine( QueryTable,
                                                           KeyValueInformation,
                                                           &KeyResultLength,
                                                           Context,
                                                           Environment
                                                         );

                    if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                         //
                         // Try to allocate a larger buffer as this is one humongous
                         // value.
                         //
                         AllocLength = KeyResultLength + sizeof(PVOID) + sizeof(UNICODE_NULL);
                         KeyValueInformation = RtlpAllocDeallocQueryBuffer( &AllocLength,
                                                                            KeyValueInformation,
                                                                            AllocLength,
                                                                            &Status
                                                                          );
                         if ( KeyValueInformation == NULL) {
                            break;
                         }
                         KeyValueInformation->DataOffset = 0;
                         KeyValueInfoLength = AllocLength - sizeof(UNICODE_NULL);
                         goto retryqueryvalue;
                     }

                    //
                    // If requested, delete the value key after it has been successfully queried.
                    //

                    if (NT_SUCCESS( Status ) && QueryTable->Flags & RTL_QUERY_REGISTRY_DELETE) {
                        ZwDeleteValueKey (Key1, &KeyValueName);
                    }
                }

        } else if (QueryTable->Flags & RTL_QUERY_REGISTRY_NOVALUE) {
            Status = (QueryTable->QueryRoutine)( NULL,
                                                 REG_NONE,
                                                 NULL,
                                                 0,
                                                 Context,
                                                 QueryTable->EntryContext
                                               );
        } else {

        enumvalues:
            retries = 0;
            for (ValueIndex = 0; TRUE; ValueIndex++) {
                Status = ZwEnumerateValueKey( Key1,
                                              ValueIndex,
                                              KeyValueFullInformation,
                                              KeyValueInformation,
                                              (ULONG) KeyValueInfoLength,
                                              &KeyResultLength
                                            );
                //
                // ZwEnumerateValueKey returns overflow even though the problem is that
                // the specified buffer was too small, so we fix that up here so we
                // can decide correctly whether to retry or not below.
                //
                if (Status == STATUS_BUFFER_OVERFLOW) {
                   Status = STATUS_BUFFER_TOO_SMALL;
                }

                if (Status == STATUS_NO_MORE_ENTRIES) {
                    if (ValueIndex == 0 && (QueryTable->Flags & RTL_QUERY_REGISTRY_REQUIRED)) {
                       Status = STATUS_OBJECT_NAME_NOT_FOUND;
                    } else {
                        Status = STATUS_SUCCESS;
                    }
                    break;
                }

                if ( NT_SUCCESS( Status ) ) {

                    KeyResultLength = (ULONG)KeyValueInfoLength;
                    Status = RtlpCallQueryRegistryRoutine( QueryTable,
                                                           KeyValueInformation,
                                                           &KeyResultLength,
                                                           Context,
                                                           Environment
                                                         );
                }

                if (Status == STATUS_BUFFER_TOO_SMALL) {
                    //
                    // Allocate a larger buffer and try again.
                    //
                    AllocLength = KeyResultLength + sizeof(PVOID) + sizeof(UNICODE_NULL);
                    KeyValueInformation = RtlpAllocDeallocQueryBuffer( &AllocLength,
                                                                       KeyValueInformation,
                                                                       AllocLength,
                                                                       &Status
                                                                     );
                    if (KeyValueInformation == NULL) {
                       break;
                    }
                    KeyValueInformation->DataOffset = 0;
                    KeyValueInfoLength = AllocLength - sizeof(UNICODE_NULL);
                    ValueIndex -= 1;

                    //
                    // A maximum of two retries is expected per loop iteration.
                    // If we see more we must have miscomputed
                    // how much is required for the query buffer.
                    //
                    if (retries++ <= 4) {
                        continue;
                    }
                    break;
                }

                if (!NT_SUCCESS( Status )) {
                    break;
                }

                retries = 0;

                //
                // If requested, delete the value key after it has been successfully queried.
                // After deletion the current ValueIndex is for the next sub-key, so adjust it.
                // KeyValueInformation->NameLength should fit in a USHORT, but we don't check since
                // it only harms our caller.
                //

                if (QueryTable->Flags & RTL_QUERY_REGISTRY_DELETE) {
                    KeyValueName.Buffer = KeyValueInformation->Name;
                    KeyValueName.Length = (USHORT)KeyValueInformation->NameLength;
                    KeyValueName.MaximumLength = (USHORT)KeyValueInformation->NameLength;
                    Status = ZwDeleteValueKey( Key1,
                                               &KeyValueName
                                             );
                    if (NT_SUCCESS( Status )) {
                        ValueIndex -= 1;
                    }
                }
            }
        }

        if (!NT_SUCCESS( Status )) {
            break;
        }

        QueryTable++;
    }

    if (Key != NULL && !(RelativeTo & RTL_REGISTRY_HANDLE)) {
        ZwClose( Key );
    }

    if (Key1 != NULL && Key1 != Key) {
        ZwClose( Key1 );
    }

    //
    // Free any query buffer we allocated.
    //
    (void) RtlpAllocDeallocQueryBuffer( NULL, KeyValueInformation, AllocLength, NULL );
    return Status;
}


NTSTATUS
RtlWriteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength
    )
{
    NTSTATUS Status;
    UNICODE_STRING KeyValueName;
    HANDLE Key;

    RTL_PAGED_CODE();

    Status = RtlpGetRegistryHandle( RelativeTo, Path, TRUE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    RtlInitUnicodeString( &KeyValueName, ValueName );
    Status = ZwSetValueKey( Key,
                            &KeyValueName,
                            0,
                            ValueType,
                            ValueData,
                            ValueLength
                          );
    if (!(RelativeTo & RTL_REGISTRY_HANDLE)) {
        ZwClose( Key );
    }

    return Status;
}


NTSTATUS
RtlCheckRegistryKey(
    __in ULONG RelativeTo,
    __in PWSTR Path
    )
{
    NTSTATUS Status;
    HANDLE Key;

    RTL_PAGED_CODE();

    Status = RtlpGetRegistryHandle( RelativeTo, Path, FALSE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
        }

    ZwClose( Key );
    return STATUS_SUCCESS;
}


NTSTATUS
RtlCreateRegistryKey(
    __in ULONG RelativeTo,
    __in PWSTR Path
    )
{
    NTSTATUS Status;
    HANDLE Key;

    RTL_PAGED_CODE();

    Status = RtlpGetRegistryHandle( RelativeTo, Path, TRUE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    if (!(RelativeTo & RTL_REGISTRY_HANDLE)) {
        ZwClose( Key );
    }
    return STATUS_SUCCESS;
}


NTSTATUS
RtlDeleteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName
    )
{
    NTSTATUS Status;
    UNICODE_STRING KeyValueName;
    HANDLE Key;

    RTL_PAGED_CODE();

    Status = RtlpGetRegistryHandle( RelativeTo, Path, TRUE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
        }

    RtlInitUnicodeString( &KeyValueName, ValueName );
    Status = ZwDeleteValueKey( Key, &KeyValueName );

    if (!(RelativeTo & RTL_REGISTRY_HANDLE)) {
        ZwClose( Key );
    }
    return Status;
}


NTSTATUS
RtlExpandEnvironmentStrings_U(
    IN PVOID Environment OPTIONAL,
    IN PCUNICODE_STRING Source,
    OUT PUNICODE_STRING Destination,
    OUT PULONG ReturnedLength OPTIONAL
    )
{
    NTSTATUS Status, Status1;
    PWCHAR Src, Src1, Dst;
    UNICODE_STRING VariableName, VariableValue;
    ULONG SrcLength, DstLength, VarLength, RequiredLength;

    RTL_PAGED_CODE();

    Src = Source->Buffer;
    SrcLength = Source->Length;
    Dst = Destination->Buffer;
    DstLength = Destination->MaximumLength;
    Status = STATUS_SUCCESS;
    RequiredLength = 0;
    while (SrcLength >= sizeof(WCHAR)) {
        if (*Src == L'%') {
            Src1 = Src + 1;
            VarLength = 0;
            VariableName.Length = 0;
            VariableName.Buffer = Src1;

            while (VarLength < (SrcLength - sizeof(WCHAR))) {
                if (*Src1 == L'%') {
                    if (VarLength) {
                        VariableName.Length = (USHORT)VarLength;
                        VariableName.MaximumLength = (USHORT)VarLength;
                    }
                    break;

                }

                Src1++;
                VarLength += sizeof(WCHAR);
            }

            if (VariableName.Length) {
                VariableValue.Buffer = Dst;
                VariableValue.Length = 0;
                VariableValue.MaximumLength = (USHORT)DstLength;
                Status1 = RtlQueryEnvironmentVariable_U( Environment,
                                                         &VariableName,
                                                         &VariableValue
                                                       );
                if (NT_SUCCESS( Status1 ) || Status1 == STATUS_BUFFER_TOO_SMALL) {
                    RequiredLength += VariableValue.Length;
                    Src = Src1 + 1;
                    SrcLength -= (VarLength + 2*sizeof(WCHAR));

                    if (NT_SUCCESS( Status1 )) {
                        DstLength -= VariableValue.Length;
                        Dst += VariableValue.Length / sizeof(WCHAR);

                    } else {
                        Status = Status1;
                    }

                    continue;
                }
            }
        }

        if (NT_SUCCESS( Status )) {
            if (DstLength > sizeof(WCHAR)) {
                DstLength -= sizeof(WCHAR);
                *Dst++ = *Src;

            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }

        RequiredLength += sizeof(WCHAR);
        SrcLength -= sizeof(WCHAR);
        Src++;
    }

    if (NT_SUCCESS( Status )) {
        if (DstLength) {
            DstLength -= sizeof(WCHAR);
            *Dst = UNICODE_NULL;

        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
    }

    RequiredLength += sizeof(WCHAR);

    if (ARGUMENT_PRESENT( ReturnedLength )) {
        *ReturnedLength = RequiredLength;
    }

    if (NT_SUCCESS( Status )) {
        Destination->Length = (USHORT)(RequiredLength - sizeof(WCHAR));
    }

    return Status;
}


ULONG
RtlGetNtGlobalFlags( VOID )
{
    return NtGlobalFlag;
}


//
// Maximum size of TOKEN_USER information.
//

#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES


NTSTATUS
RtlFormatCurrentUserKeyPath(
    OUT PUNICODE_STRING CurrentUserKeyPath
    )

/*++

Routine Description:

    Initialize the supplied buffer with a string representation
    of the current user's SID.

Arguments:

    CurrentUserKeyPath - Returns a string that represents the current
        user's root key in the Registry.  Caller must call
        RtlFreeUnicodeString to free the buffer when done with it.

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS if the user string was
        succesfully initialized.

--*/

{
    HANDLE TokenHandle;
    UCHAR TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG ReturnLength;
    ULONG SidStringLength ;
    UNICODE_STRING SidString ;
    NTSTATUS Status;

    //
    // Inside the kernel we can tell rapidly if we are impersonating.
    //
    Status = STATUS_NO_TOKEN;
    if (PS_IS_THREAD_IMPERSONATING (PsGetCurrentThread ())) {

        Status = ZwOpenThreadTokenEx (NtCurrentThread(),
                                      TOKEN_READ,
                                      TRUE,
                                      OBJ_KERNEL_HANDLE,
                                      &TokenHandle);

        if ( !NT_SUCCESS( Status ) && ( Status != STATUS_NO_TOKEN ) ) {
            return Status;
        }
    }

    if ( !NT_SUCCESS( Status ) ) {

        Status = ZwOpenProcessTokenEx (NtCurrentProcess(),
                                       TOKEN_READ,
                                       OBJ_KERNEL_HANDLE,
                                       &TokenHandle);
        if ( !NT_SUCCESS( Status )) {
            return Status;
        }
    }

    Status = ZwQueryInformationToken( TokenHandle,
                                      TokenUser,
                                      TokenInformation,
                                      sizeof( TokenInformation ),
                                      &ReturnLength
                                    );

    ZwClose( TokenHandle );

    if ( !NT_SUCCESS( Status )) {
        return Status;
    }

    Status = RtlLengthSidAsUnicodeString(
                        ((PTOKEN_USER)TokenInformation)->User.Sid,
                        &SidStringLength
                        );

    if ( !NT_SUCCESS( Status ) ) {
        return Status ;
    }

    CurrentUserKeyPath->Length = 0;
    CurrentUserKeyPath->MaximumLength = (USHORT)(SidStringLength +
                                        sizeof( L"\\REGISTRY\\USER\\" ) +
                                        sizeof( UNICODE_NULL ));
    CurrentUserKeyPath->Buffer = (RtlAllocateStringRoutine)( CurrentUserKeyPath->MaximumLength );
    if (CurrentUserKeyPath->Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Copy "\REGISTRY\USER" to the current user string.
    //

    RtlAppendUnicodeToString( CurrentUserKeyPath, L"\\REGISTRY\\USER\\" );

    SidString.MaximumLength = (USHORT)SidStringLength ;
    SidString.Length = 0 ;
    SidString.Buffer = CurrentUserKeyPath->Buffer +
            (CurrentUserKeyPath->Length / sizeof(WCHAR) );

    Status = RtlConvertSidToUnicodeString( &SidString,
                                           ((PTOKEN_USER)TokenInformation)->User.Sid,
                                           FALSE
                                         );
    if ( !NT_SUCCESS( Status )) {
        RtlFreeUnicodeString( CurrentUserKeyPath );

    } else {
        CurrentUserKeyPath->Length += SidString.Length ;
    }

    return Status;
}


NTSTATUS
RtlOpenCurrentUser(
    IN ULONG DesiredAccess,
    OUT PHANDLE CurrentUserKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_CURRENT_USER predefined handle.

Arguments:

    DesiredAccess - Specifies the access to open the key for.

    CurrentUserKey - Returns a handle to the key \REGISTRY\USER\*.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNICODE_STRING      CurrentUserKeyPath;
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status;

    RTL_PAGED_CODE();

    //
    // Format the registry path for the current user.
    //

    Status = RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath );
    if ( NT_SUCCESS(Status) ) {

        InitializeObjectAttributes( &Obja,
                                    &CurrentUserKeyPath,
                                    OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE|OBJ_FORCE_ACCESS_CHECK,
                                    NULL,
                                    NULL
                                  );
        Status = ZwOpenKey( CurrentUserKey,
                            DesiredAccess,
                            &Obja
                          );
        RtlFreeUnicodeString( &CurrentUserKeyPath );
    }

    if ( !NT_SUCCESS(Status) ) {
        //
        // Opening \REGISTRY\USER\<SID> failed, try \REGISTRY\USER\.DEFAULT
        //
        RtlInitUnicodeString( &CurrentUserKeyPath, RtlpRegistryPaths[ RTL_REGISTRY_USER ] );
        InitializeObjectAttributes( &Obja,
                                    &CurrentUserKeyPath,
                                    OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE|OBJ_FORCE_ACCESS_CHECK,
                                    NULL,
                                    NULL
                                  );

        Status = ZwOpenKey( CurrentUserKey,
                            DesiredAccess,
                            &Obja
                          );

    }

    return Status;
}


NTSTATUS
RtlpGetTimeZoneInfoHandle(
    IN BOOLEAN WriteAccess,
    OUT PHANDLE Key
    )
{
    return RtlpGetRegistryHandle( RTL_REGISTRY_CONTROL, L"TimeZoneInformation", WriteAccess, Key );
}



extern  const WCHAR szBias[];
extern  const WCHAR szStandardName[];
extern  const WCHAR szStandardBias[];
extern  const WCHAR szStandardStart[];
extern  const WCHAR szDaylightName[];
extern  const WCHAR szDaylightBias[];
extern  const WCHAR szDaylightStart[];

NTSTATUS
RtlQueryTimeZoneInformation(
    OUT PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    )
{
    NTSTATUS Status;
    HANDLE Key;
    UNICODE_STRING StandardName, DaylightName;
    RTL_QUERY_REGISTRY_TABLE RegistryConfigurationTable[ 8 ];

    RTL_PAGED_CODE();

    Status = RtlpGetTimeZoneInfoHandle( FALSE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    RtlZeroMemory( TimeZoneInformation, sizeof( *TimeZoneInformation ) );
    RtlZeroMemory( RegistryConfigurationTable, sizeof( RegistryConfigurationTable ) );

    RegistryConfigurationTable[ 0 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 0 ].Name = (PWSTR)szBias;
    RegistryConfigurationTable[ 0 ].EntryContext = &TimeZoneInformation->Bias;


    StandardName.Buffer = TimeZoneInformation->StandardName;
    StandardName.Length = 0;
    StandardName.MaximumLength = sizeof( TimeZoneInformation->StandardName );
    RegistryConfigurationTable[ 1 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 1 ].Name = (PWSTR)szStandardName;
    RegistryConfigurationTable[ 1 ].EntryContext = &StandardName;

    RegistryConfigurationTable[ 2 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 2 ].Name = (PWSTR)szStandardBias;
    RegistryConfigurationTable[ 2 ].EntryContext = &TimeZoneInformation->StandardBias;

    RegistryConfigurationTable[ 3 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 3 ].Name = (PWSTR)szStandardStart;
    RegistryConfigurationTable[ 3 ].EntryContext = &TimeZoneInformation->StandardStart;
    *(PLONG)(RegistryConfigurationTable[ 3 ].EntryContext) = -(LONG)sizeof( TIME_FIELDS );

    DaylightName.Buffer = TimeZoneInformation->DaylightName;
    DaylightName.Length = 0;
    DaylightName.MaximumLength = sizeof( TimeZoneInformation->DaylightName );
    RegistryConfigurationTable[ 4 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 4 ].Name = (PWSTR)szDaylightName;
    RegistryConfigurationTable[ 4 ].EntryContext = &DaylightName;

    RegistryConfigurationTable[ 5 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 5 ].Name = (PWSTR)szDaylightBias;
    RegistryConfigurationTable[ 5 ].EntryContext = &TimeZoneInformation->DaylightBias;

    RegistryConfigurationTable[ 6 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 6 ].Name = (PWSTR)szDaylightStart;
    RegistryConfigurationTable[ 6 ].EntryContext = &TimeZoneInformation->DaylightStart;
    *(PLONG)(RegistryConfigurationTable[ 6 ].EntryContext) = -(LONG)sizeof( TIME_FIELDS );

    Status = RtlQueryRegistryValues( RTL_REGISTRY_HANDLE,
                                     (PWSTR)Key,
                                     RegistryConfigurationTable,
                                     NULL,
                                     NULL
                                   );
    ZwClose( Key );
    return Status;
}


NTSTATUS
RtlSetTimeZoneInformation(
    IN PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    )
{
    NTSTATUS Status;
    HANDLE Key;

    RTL_PAGED_CODE();

    Status = RtlpGetTimeZoneInfoHandle( TRUE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                    (PWSTR)Key,
                                    szBias,
                                    REG_DWORD,
                                    &TimeZoneInformation->Bias,
                                    sizeof( TimeZoneInformation->Bias )
                                  );
    if (NT_SUCCESS( Status )) {
        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        szStandardName,
                                        REG_SZ,
                                        TimeZoneInformation->StandardName,
                                        (wcslen( TimeZoneInformation->StandardName ) + 1) * sizeof( WCHAR )
                                      );
    }

    if (NT_SUCCESS( Status )) {
        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        szStandardBias,
                                        REG_DWORD,
                                        &TimeZoneInformation->StandardBias,
                                        sizeof( TimeZoneInformation->StandardBias )
                                      );
    }

    if (NT_SUCCESS( Status )) {
        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        szStandardStart,
                                        REG_BINARY,
                                        &TimeZoneInformation->StandardStart,
                                        sizeof( TimeZoneInformation->StandardStart )
                                      );
    }

    if (NT_SUCCESS( Status )) {
        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        szDaylightName,
                                        REG_SZ,
                                        TimeZoneInformation->DaylightName,
                                        (wcslen( TimeZoneInformation->DaylightName ) + 1) * sizeof( WCHAR )
                                      );
    }

    if (NT_SUCCESS( Status )) {
        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        szDaylightBias,
                                        REG_DWORD,
                                        &TimeZoneInformation->DaylightBias,
                                        sizeof( TimeZoneInformation->DaylightBias )
                                      );
    }

    if (NT_SUCCESS( Status )) {
        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        szDaylightStart,
                                        REG_BINARY,
                                        &TimeZoneInformation->DaylightStart,
                                        sizeof( TimeZoneInformation->DaylightStart )
                                      );
    }

    ZwClose( Key );
    return Status;
}


NTSTATUS
RtlSetActiveTimeBias(
    IN LONG ActiveBias
    )
{
    NTSTATUS Status;
    HANDLE Key;
    RTL_QUERY_REGISTRY_TABLE RegistryConfigurationTable[ 2 ];
    LONG CurrentActiveBias;

    RTL_PAGED_CODE();

    Status = RtlpGetTimeZoneInfoHandle( TRUE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    RtlZeroMemory( RegistryConfigurationTable, sizeof( RegistryConfigurationTable ) );
    RegistryConfigurationTable[ 0 ].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    RegistryConfigurationTable[ 0 ].Name = L"ActiveTimeBias";
    RegistryConfigurationTable[ 0 ].EntryContext = &CurrentActiveBias;

    Status = RtlQueryRegistryValues( RTL_REGISTRY_HANDLE,
                                     (PWSTR)Key,
                                     RegistryConfigurationTable,
                                     NULL,
                                     NULL
                                   );

    if ( !NT_SUCCESS(Status) || CurrentActiveBias != ActiveBias ) {

        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        L"ActiveTimeBias",
                                        REG_DWORD,
                                        &ActiveBias,
                                        sizeof( ActiveBias )
                                      );
    }

    ZwClose( Key );
    return Status;
}

#if defined(ALLOC_DATA_PRAGMA)
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\prefix.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Prefix.c

Abstract:

    This module implements the prefix table utility.  The two structures
    used in a prefix table are the PREFIX_TABLE and PREFIX_TABLE_ENTRY.
    Each table has one prefix table and multiple prefix table entries
    corresponding to each prefix stored in the table.

    A prefix table is a list of prefix trees, where each tree contains
    the prefixes corresponding to a particular name length (i.e., all
    prefixes of length 1 are stored in one tree, prefixes of length 2
    are stored in another tree, and so forth).  A prefixes name length
    is the number of separate names that appear in the string, and not
    the number of characters in the string (e.g., Length("\alpha\beta") = 2).

    The elements of each tree are ordered lexicalgraphically (case blind)
    using a splay tree data structure.  If two or more prefixes are identical
    except for case then one of the corresponding table entries is actually
    in the tree, while the other entries are in a circular linked list joined
    with the tree member.

--*/

#include "ntrtlp.h"

//
//  Local procedures and types used only in this package
//

typedef enum _COMPARISON {
    IsLessThan,
    IsPrefix,
    IsEqual,
    IsGreaterThan
} COMPARISON;

CLONG
ComputeNameLength(
    IN PSTRING Name
    );

COMPARISON
CompareNamesCaseSensitive (
    IN PSTRING Prefix,
    IN PSTRING Name
    );

CLONG
ComputeUnicodeNameLength(
    IN PUNICODE_STRING Name
    );

COMPARISON
CompareUnicodeStrings (
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_STRING Name,
    IN ULONG CaseInsensitiveIndex
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,ComputeNameLength)
#pragma alloc_text(PAGE,CompareNamesCaseSensitive)
#pragma alloc_text(PAGE,PfxInitialize)
#pragma alloc_text(PAGE,PfxInsertPrefix)
#pragma alloc_text(PAGE,PfxRemovePrefix)
#pragma alloc_text(PAGE,PfxFindPrefix)
#pragma alloc_text(PAGE,ComputeUnicodeNameLength)
#pragma alloc_text(PAGE,CompareUnicodeStrings)
#pragma alloc_text(PAGE,RtlInitializeUnicodePrefix)
#pragma alloc_text(PAGE,RtlInsertUnicodePrefix)
#pragma alloc_text(PAGE,RtlRemoveUnicodePrefix)
#pragma alloc_text(PAGE,RtlFindUnicodePrefix)
#pragma alloc_text(PAGE,RtlNextUnicodePrefix)
#endif


//
//  The node type codes for the prefix data structures
//

#define RTL_NTC_PREFIX_TABLE             ((CSHORT)0x0200)
#define RTL_NTC_ROOT                     ((CSHORT)0x0201)
#define RTL_NTC_INTERNAL                 ((CSHORT)0x0202)


VOID
PfxInitialize (
    IN PPREFIX_TABLE PrefixTable
    )

/*++

Routine Description:

    This routine initializes a prefix table record to the empty state.

Arguments:

    PrefixTable - Supplies the prefix table being initialized

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    PrefixTable->NodeTypeCode = RTL_NTC_PREFIX_TABLE;

    PrefixTable->NameLength = 0;

    PrefixTable->NextPrefixTree = (PPREFIX_TABLE_ENTRY)PrefixTable;

    //
    //  return to our caller
    //

    return;
}


BOOLEAN
PfxInsertPrefix (
    IN PPREFIX_TABLE PrefixTable,
    IN PSTRING Prefix,
    IN PPREFIX_TABLE_ENTRY PrefixTableEntry
    )

/*++

Routine Description:

    This routine inserts a new prefix into the specified prefix table

Arguments:

    PrefixTable - Supplies the target prefix table

    Prefix - Supplies the string to be inserted in the prefix table

    PrefixTableEntry - Supplies the entry to use to insert the prefix

Return Value:

    BOOLEAN - TRUE if the Prefix is not already in the table, and FALSE
        otherwise

--*/

{
    ULONG PrefixNameLength;

    PPREFIX_TABLE_ENTRY PreviousTree;
    PPREFIX_TABLE_ENTRY CurrentTree;
    PPREFIX_TABLE_ENTRY NextTree;

    PPREFIX_TABLE_ENTRY Node;

    COMPARISON Comparison;

    RTL_PAGED_CODE();

    //
    //  Determine the name length of the input string
    //

    PrefixNameLength = ComputeNameLength(Prefix);

    //
    //  Setup parts of the prefix table entry that we will always need
    //

    PrefixTableEntry->NameLength = (CSHORT)PrefixNameLength;
    PrefixTableEntry->Prefix = Prefix;

    RtlInitializeSplayLinks(&PrefixTableEntry->Links);

    //
    //  find the corresponding tree, or find where the tree should go
    //

    PreviousTree = (PPREFIX_TABLE_ENTRY)PrefixTable;
    CurrentTree = PreviousTree->NextPrefixTree;

    while (CurrentTree->NameLength > (CSHORT)PrefixNameLength) {

        PreviousTree = CurrentTree;
        CurrentTree = CurrentTree->NextPrefixTree;

    }

    //
    //  If the name length of the current tree is not equal to the
    //  prefix name length then the tree does not exist and we need
    //  to make a new tree node.
    //

    if (CurrentTree->NameLength != (CSHORT)PrefixNameLength) {

        //
        //  Insert the new prefix entry to the list between
        //  previous and current tree
        //

        PreviousTree->NextPrefixTree = PrefixTableEntry;
        PrefixTableEntry->NextPrefixTree = CurrentTree;

        //
        //  And set the node type code
        //

        PrefixTableEntry->NodeTypeCode = RTL_NTC_ROOT;

        //
        //  And tell our caller everything worked fine
        //

        return TRUE;

    }

    //
    //  The tree does exist so now search the tree for our
    //  position in it.  We only exit the loop if we've inserted
    //  a new node, and node is left is left pointing to the
    //  tree position
    //

    Node = CurrentTree;

    while (TRUE) {

        //
        //  Compare the prefix in the tree with the prefix we want
        //  to insert
        //

        Comparison = CompareNamesCaseSensitive(Node->Prefix, Prefix);

        //
        //  If we do match case sensitive then we cannot add
        //  this prefix so we return false.  Note this is the
        //  only condition where we return false
        //

        if (Comparison == IsEqual) {

            return FALSE;
        }

        //
        //  If the tree prefix is greater than the new prefix then
        //  we go down the left subtree
        //

        if (Comparison == IsGreaterThan) {

            //
            //  We want to go down the left subtree, first check to see
            //  if we have a left subtree
            //

            if (RtlLeftChild(&Node->Links) == NULL) {

                //
                //  there isn't a left child so we insert ourselves as the
                //  new left child
                //

                PrefixTableEntry->NodeTypeCode = RTL_NTC_INTERNAL;
                PrefixTableEntry->NextPrefixTree = NULL;

                RtlInsertAsLeftChild(&Node->Links, &PrefixTableEntry->Links);

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a left child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlLeftChild(&Node->Links),
                                          PREFIX_TABLE_ENTRY,
                                          Links );

            }

        } else {

            //
            //  The tree prefix is either less than or a proper prefix
            //  of the new string.  We treat both cases a less than when
            //  we do insert.  So we want to go down the right subtree,
            //  first check to see if we have a right subtree
            //

            if (RtlRightChild(&Node->Links) == NULL) {

                //
                //  These isn't a right child so we insert ourselves as the
                //  new right child
                //

                PrefixTableEntry->NodeTypeCode = RTL_NTC_INTERNAL;
                PrefixTableEntry->NextPrefixTree = NULL;

                RtlInsertAsRightChild(&Node->Links, &PrefixTableEntry->Links);

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a right child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlRightChild(&Node->Links),
                                          PREFIX_TABLE_ENTRY,
                                          Links );
            }

        }

    }

    //
    //  Now that we've inserted the new node we can splay the tree.
    //  To do this we need to remember how we find this tree in the root
    //  tree list, set the root to be an internal, splay, the tree, and
    //  then setup the new root node.  Note: we cannot splay the prefix table
    //  entry because it might be a case match node so we only splay
    //  the Node variable, which for case match insertions is the
    //  internal node for the case match and for non-case match insertions
    //  the Node variable is the parent node.
    //

    //
    //  Save a pointer to the next tree, we already have the previous tree
    //

    NextTree = CurrentTree->NextPrefixTree;

    //
    //  Reset the current root to be an internal node
    //

    CurrentTree->NodeTypeCode = RTL_NTC_INTERNAL;
    CurrentTree->NextPrefixTree = NULL;

    //
    //  Splay the tree and get the root
    //

    Node = CONTAINING_RECORD(RtlSplay(&Node->Links), PREFIX_TABLE_ENTRY, Links);

    //
    //  Set the new root's node type code and make it part of the
    //  root tree list
    //

    Node->NodeTypeCode = RTL_NTC_ROOT;
    PreviousTree->NextPrefixTree = Node;
    Node->NextPrefixTree = NextTree;

    //
    //  tell our caller everything worked fine
    //

    return TRUE;
}


VOID
PfxRemovePrefix (
    IN PPREFIX_TABLE PrefixTable,
    IN PPREFIX_TABLE_ENTRY PrefixTableEntry
    )

/*++

Routine Description:

    This routine removes the indicated prefix table entry from
    the prefix table

Arguments:

    PrefixTable - Supplies the prefix table affected

    PrefixTableEntry - Supplies the prefix entry to remove

Return Value:

    None.

--*/

{
    PRTL_SPLAY_LINKS Links;

    PPREFIX_TABLE_ENTRY Root;
    PPREFIX_TABLE_ENTRY NewRoot;

    PPREFIX_TABLE_ENTRY PreviousTree;

    RTL_PAGED_CODE();

    //
    //  case on the type of node that we are trying to delete
    //

    switch (PrefixTableEntry->NodeTypeCode) {

    case RTL_NTC_INTERNAL:
    case RTL_NTC_ROOT:

        //
        //  The node is internal or root node so we need to delete it from
        //  the tree, but first find the root of the tree
        //

        Links = &PrefixTableEntry->Links;

        while (!RtlIsRoot(Links)) {

            Links = RtlParent(Links);
        }

        Root = CONTAINING_RECORD( Links, PREFIX_TABLE_ENTRY, Links );

        //
        //  Now delete the node
        //

        Links = RtlDelete(&PrefixTableEntry->Links);

        //
        //  Now see if the tree is deleted
        //

        if (Links == NULL) {

            //
            //  The tree is now empty so remove this tree from
            //  the tree list, by first finding the previous tree that
            //  references us
            //

            PreviousTree = Root->NextPrefixTree;

            while ( PreviousTree->NextPrefixTree != Root ) {

                PreviousTree = PreviousTree->NextPrefixTree;
            }

            //
            //  We've located the previous tree so now just have it
            //  point around the deleted node
            //

            PreviousTree->NextPrefixTree = Root->NextPrefixTree;

            //
            //  and return the our caller
            //

            return;
        }

        //
        //  The tree is not deleted but see if we changed roots
        //

        if (&Root->Links != Links) {

            //
            //  Get a pointer to the new root
            //

            NewRoot = CONTAINING_RECORD(Links, PREFIX_TABLE_ENTRY, Links);

            //
            //  We changed root so we better need to make the new
            //  root part of the prefix data structure, by
            //  first finding the previous tree that
            //  references us
            //

            PreviousTree = Root->NextPrefixTree;

            while ( PreviousTree->NextPrefixTree != Root ) {

                PreviousTree = PreviousTree->NextPrefixTree;
            }

            //
            //  Set the new root
            //

            NewRoot->NodeTypeCode = RTL_NTC_ROOT;

            PreviousTree->NextPrefixTree = NewRoot;
            NewRoot->NextPrefixTree = Root->NextPrefixTree;

            //
            //  Set the old root to be an internal node
            //

            Root->NodeTypeCode = RTL_NTC_INTERNAL;

            Root->NextPrefixTree = NULL;

            //
            //  And return to our caller
            //

            return;
        }

        //
        //  We didn't change roots so everything is fine and we can
        //  simply return to our caller
        //

        return;

    default:

        //
        //  If we get here then there was an error and the node type
        //  code is unknown
        //

        return;
    }
}


PPREFIX_TABLE_ENTRY
PfxFindPrefix (
    IN PPREFIX_TABLE PrefixTable,
    IN PSTRING FullName
    )

/*++

Routine Description:

    This routine finds if a full name has a prefix in a prefix table.
    It returns a pointer to the largest proper prefix found if one exists.

Arguments:

    PrefixTable - Supplies the prefix table to search

    FullString - Supplies the name to search for

Return Value:

    PPREFIX_TABLE_ENTRY - a pointer to the longest prefix found if one
        exists, and NULL otherwise

--*/

{
    CLONG NameLength;

    PPREFIX_TABLE_ENTRY PreviousTree;
    PPREFIX_TABLE_ENTRY CurrentTree;
    PPREFIX_TABLE_ENTRY NextTree;

    PRTL_SPLAY_LINKS Links;

    PPREFIX_TABLE_ENTRY Node;

    COMPARISON Comparison;

    RTL_PAGED_CODE();

    //
    //  Determine the name length of the input string
    //

    NameLength = ComputeNameLength(FullName);

    //
    //  Locate the first tree that can contain a prefix
    //

    PreviousTree = (PPREFIX_TABLE_ENTRY)PrefixTable;
    CurrentTree = PreviousTree->NextPrefixTree;

    while (CurrentTree->NameLength > (CSHORT)NameLength) {

        PreviousTree = CurrentTree;
        CurrentTree = CurrentTree->NextPrefixTree;
    }

    //
    //  Now search for a prefix until we find one or until we exhaust
    //  the prefix trees
    //

    while (CurrentTree->NameLength > 0) {

        Links = &CurrentTree->Links;

        while (Links != NULL) {

            Node = CONTAINING_RECORD(Links, PREFIX_TABLE_ENTRY, Links);

            //
            //  Compare the prefix in the tree with the full name
            //

            Comparison = CompareNamesCaseSensitive(Node->Prefix, FullName);

            //
            //  See if they don't match
            //

            if (Comparison == IsGreaterThan) {

                //
                //  The prefix is greater than the full name
                //  so we go down the left child
                //

                Links = RtlLeftChild(Links);

                //
                //  And continue searching down this tree
                //

            } else if (Comparison == IsLessThan) {

                //
                //  The prefix is less than the full name
                //  so we go down the right child
                //

                Links = RtlRightChild(Links);

                //
                //  And continue searching down this tree
                //

            } else {

                //
                //  We found it.
                //
                //  Now that we've located the node we can splay the tree.
                //  To do this we need to remember how we find this tree in the root
                //  tree list, set the root to be an internal, splay, the tree, and
                //  then setup the new root node.
                //

                if (Node->NodeTypeCode == RTL_NTC_INTERNAL) {

                    //
                    //  Save a pointer to the next tree, we already have the previous tree
                    //

                    NextTree = CurrentTree->NextPrefixTree;

                    //
                    //  Reset the current root to be an internal node
                    //

                    CurrentTree->NodeTypeCode = RTL_NTC_INTERNAL;
                    CurrentTree->NextPrefixTree = NULL;

                    //
                    //  Splay the tree and get the root
                    //

                    Node = CONTAINING_RECORD(RtlSplay(&Node->Links), PREFIX_TABLE_ENTRY, Links);

                    //
                    //  Set the new root's node type code and make it part of the
                    //  root tree list
                    //

                    Node->NodeTypeCode = RTL_NTC_ROOT;
                    PreviousTree->NextPrefixTree = Node;
                    Node->NextPrefixTree = NextTree;
                }

                return Node;
            }
        }

        //
        //  This tree is done so now find the next tree
        //

        PreviousTree = CurrentTree;
        CurrentTree = CurrentTree->NextPrefixTree;
    }

    //
    //  We sesarched everywhere and didn't find a prefix so tell the
    //  caller none was found
    //

    return NULL;
}


CLONG
ComputeNameLength(
    IN PSTRING Name
    )

/*++

Routine Description:

    This routine counts the number of names appearing in the input string.
    It does this by simply counting the number of backslashes in the string.
    To handle ill-formed names (i.e., names that do not contain a backslash)
    this routine really returns the number of backslashes plus 1.

Arguments:

    Name - Supplies the input name to examine

Returns Value:

    CLONG - the number of names in the input string

--*/

{
    ULONG NameLength;
    ULONG i;
    ULONG Count;

    extern const PUSHORT NlsLeadByteInfo;  // Lead byte info. for ACP ( nlsxlat.c )
    extern BOOLEAN NlsMbCodePageTag;

    RTL_PAGED_CODE();

    //
    //  Save the name length, this should make the compiler be able to
    //  optimize not having to reload the length each time
    //

    NameLength = Name->Length - 1;

    //
    //  Now loop through the input string counting back slashes
    //

    if (NlsMbCodePageTag) {

        //
        // ComputeNameLength() skip DBCS character when counting '\'
        //

        for (i = 0, Count = 1; i < NameLength; ) {

            if (NlsLeadByteInfo[(UCHAR)Name->Buffer[i]]) {

                i += 2;

            } else {

                if (Name->Buffer[i] == '\\') {

                    Count += 1;
                }

                i += 1;
            }
        }

    } else {

        for (i = 0, Count = 1; i < NameLength; i += 1) {

            //
            //  check for a back slash
            //

            if (Name->Buffer[i] == '\\') {

                Count += 1;
            }
        }
    }

    //
    //  return the number of back slashes we found
    //
    return Count;
}


COMPARISON
CompareNamesCaseSensitive (
    IN PSTRING Prefix,
    IN PSTRING Name
    )

/*++

Routine Description:

    This routine takes a prefix string and a full name string and determines
    if the prefix string is a proper prefix of the name string (case sensitive)

Arguments:

    Prefix - Supplies the input prefix string

    Name - Supplies the full name input string

Return Value:

    COMPARISON - returns

        IsLessThan    if Prefix < Name lexicalgraphically,
        IsPrefix      if Prefix is a proper prefix of Name
        IsEqual       if Prefix is equal to Name, and
        IsGreaterThan if Prefix > Name lexicalgraphically

--*/

{
    ULONG PrefixLength;
    ULONG NameLength;
    ULONG MinLength;
    ULONG i;

    UCHAR PrefixChar;
    UCHAR NameChar;

    extern const PUSHORT NlsLeadByteInfo;  // Lead byte info. for ACP ( nlsxlat.c )
    extern BOOLEAN NlsMbCodePageTag;

    RTL_PAGED_CODE();

    //
    //  Save the length of the prefix and name string, this should allow
    //  the compiler to not need to reload the length through a pointer every
    //  time we need their values
    //

    PrefixLength = Prefix->Length;
    NameLength = Name->Length;

    //
    //  Special case the situation where the prefix string is simply "\" and
    //  the name starts with an "\"
    //

    if ((Prefix->Length == 1) && (Prefix->Buffer[0] == '\\') &&
        (Name->Length > 1) && (Name->Buffer[0] == '\\')) {
        return IsPrefix;
    }

    //
    //  Figure out the minimum of the two lengths
    //

    MinLength = (PrefixLength < NameLength ? PrefixLength : NameLength);

    //
    //  Loop through looking at all of the characters in both strings
    //  testing for equality, less than, and greater than
    //

    i = (ULONG) RtlCompareMemory( &Prefix->Buffer[0], &Name->Buffer[0], MinLength );

    if (i < MinLength) {

        UCHAR c;

        //
        //  Get both characters to examine and keep their case
        //

        PrefixChar = ((c = Prefix->Buffer[i]) == '\\' ? (CHAR)0 : c);
        NameChar   = ((c = Name->Buffer[i])   == '\\' ? (CHAR)0 : c);

        //
        //  Unfortunately life is not so easy in DBCS land.
        //

        if (NlsMbCodePageTag) {

            //
            // CompareNamesCaseSensitive(): check backslash in trailing bytes
            //

            if (Prefix->Buffer[i] == '\\') {

                ULONG j;
                extern const PUSHORT   NlsLeadByteInfo;  // Lead byte info. for ACP ( nlsxlat.c )

                for (j = 0; j < i;) {

                    j += NlsLeadByteInfo[(UCHAR)Prefix->Buffer[j]] ? 2 : 1;
                }

                if (j != i) {

                    PrefixChar = '\\';
                }
            }

            if (Name->Buffer[i] == '\\') {

                ULONG j;
                extern const PUSHORT   NlsLeadByteInfo;  // Lead byte info. for ACP ( nlsxlat.c )

                for (j = 0; j < i;) {

                    j += NlsLeadByteInfo[(UCHAR)Name->Buffer[j]] ? 2 : 1;
                }

                if (j != i) {

                    NameChar = '\\';
                }
            }
        }

        //
        //  Now compare the characters
        //

        if (PrefixChar < NameChar) {

            return IsLessThan;

        } else if (PrefixChar > NameChar) {

            return IsGreaterThan;
        }
    }

    //
    //  They match up to the minimum length so now figure out the largest string
    //  and see if one is a proper prefix of the other
    //

    if (PrefixLength < NameLength) {

        //
        //  The prefix string is shorter so if it is a proper prefix we
        //  return prefix otherwise we return less than (e.g., "\a" < "\ab")
        //

        if (Name->Buffer[PrefixLength] == '\\') {

            return IsPrefix;

        } else {

            return IsLessThan;
        }

    } else if (PrefixLength > NameLength) {

        //
        //  The Prefix string is longer so we say that the prefix is
        //  greater than the name (e.g., "\ab" > "\a")
        //

        return IsGreaterThan;

    } else {

        //
        //  They lengths are equal so the strings are equal
        //

        return IsEqual;
    }
}


//
//  The node type codes for the prefix data structures
//

#define RTL_NTC_UNICODE_PREFIX_TABLE     ((CSHORT)0x0800)
#define RTL_NTC_UNICODE_ROOT             ((CSHORT)0x0801)
#define RTL_NTC_UNICODE_INTERNAL         ((CSHORT)0x0802)
#define RTL_NTC_UNICODE_CASE_MATCH       ((CSHORT)0x0803)


VOID
RtlInitializeUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable
    )

/*++

Routine Description:

    This routine initializes a unicode prefix table record to the empty state.

Arguments:

    PrefixTable - Supplies the prefix table being initialized

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    PrefixTable->NodeTypeCode = RTL_NTC_UNICODE_PREFIX_TABLE;
    PrefixTable->NameLength = 0;
    PrefixTable->NextPrefixTree = (PUNICODE_PREFIX_TABLE_ENTRY)PrefixTable;
    PrefixTable->LastNextEntry = NULL;

    //
    //  return to our caller
    //

    return;
}


BOOLEAN
RtlInsertUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable,
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    )

/*++

Routine Description:

    This routine inserts a new unicode prefix into the specified prefix table

Arguments:

    PrefixTable - Supplies the target prefix table

    Prefix - Supplies the string to be inserted in the prefix table

    PrefixTableEntry - Supplies the entry to use to insert the prefix

Return Value:

    BOOLEAN - TRUE if the Prefix is not already in the table, and FALSE
        otherwise

--*/

{
    ULONG PrefixNameLength;

    PUNICODE_PREFIX_TABLE_ENTRY PreviousTree;
    PUNICODE_PREFIX_TABLE_ENTRY CurrentTree;
    PUNICODE_PREFIX_TABLE_ENTRY NextTree;

    PUNICODE_PREFIX_TABLE_ENTRY Node;

    COMPARISON Comparison;

    RTL_PAGED_CODE();

    //
    //  Determine the name length of the input string
    //

    PrefixNameLength = ComputeUnicodeNameLength(Prefix);

    //
    //  Setup parts of the prefix table entry that we will always need
    //

    PrefixTableEntry->NameLength = (CSHORT)PrefixNameLength;
    PrefixTableEntry->Prefix = Prefix;

    RtlInitializeSplayLinks(&PrefixTableEntry->Links);

    //
    //  find the corresponding tree, or find where the tree should go
    //

    PreviousTree = (PUNICODE_PREFIX_TABLE_ENTRY)PrefixTable;
    CurrentTree = PreviousTree->NextPrefixTree;

    while (CurrentTree->NameLength > (CSHORT)PrefixNameLength) {

        PreviousTree = CurrentTree;
        CurrentTree = CurrentTree->NextPrefixTree;
    }

    //
    //  If the name length of the current tree is not equal to the
    //  prefix name length then the tree does not exist and we need
    //  to make a new tree node.
    //

    if (CurrentTree->NameLength != (CSHORT)PrefixNameLength) {

        //
        //  Insert the new prefix entry to the list between
        //  previous and current tree
        //

        PreviousTree->NextPrefixTree = PrefixTableEntry;
        PrefixTableEntry->NextPrefixTree = CurrentTree;

        //
        //  And set the node type code, case match for the root tree node
        //

        PrefixTableEntry->NodeTypeCode = RTL_NTC_UNICODE_ROOT;
        PrefixTableEntry->CaseMatch = PrefixTableEntry;

        //
        //  And tell our caller everything worked fine
        //

        return TRUE;
    }

    //
    //  The tree does exist so now search the tree for our
    //  position in it.  We only exit the loop if we've inserted
    //  a new node, and node is left is left pointing to the
    //  tree position
    //

    Node = CurrentTree;

    while (TRUE) {

        //
        //  Compare the prefix in the tree with the prefix we want
        //  to insert.  Do the compare case blind
        //

        Comparison = CompareUnicodeStrings(Node->Prefix, Prefix, 0);

        //
        //  If they are equal then this node gets added as a case
        //  match, provided it doesn't case sensitive match anyone
        //

        if (Comparison == IsEqual) {

            PUNICODE_PREFIX_TABLE_ENTRY Next;

            //
            //  Loop through the case match list checking to see if we
            //  match case sensitive with anyone.  Get the first node
            //

            Next = Node;

            //
            //  And loop checking each node until we're back to where
            //  we started
            //

            do {

                //
                //  If we do match case sensitive then we cannot add
                //  this prefix so we return false.  Note this is the
                //  only condition where we return false
                //

                if (CompareUnicodeStrings(Next->Prefix, Prefix, MAXULONG) == IsEqual) {

                    return FALSE;
                }

                //
                //  Get the next node in the case match list
                //

                Next = Next->CaseMatch;

                //
                //  And continue looping until we're back where we started
                //

            } while ( Next != Node );

            //
            //  We've searched the case match and didn't find an exact match
            //  so we can insert this node in the case match list
            //

            PrefixTableEntry->NodeTypeCode = RTL_NTC_UNICODE_CASE_MATCH;
            PrefixTableEntry->NextPrefixTree = NULL;

            PrefixTableEntry->CaseMatch = Node->CaseMatch;
            Node->CaseMatch = PrefixTableEntry;

            //
            //  And exit out of the while loop
            //

            break;
        }

        //
        //  If the tree prefix is greater than the new prefix then
        //  we go down the left subtree
        //

        if (Comparison == IsGreaterThan) {

            //
            //  We want to go down the left subtree, first check to see
            //  if we have a left subtree
            //

            if (RtlLeftChild(&Node->Links) == NULL) {

                //
                //  there isn't a left child so we insert ourselves as the
                //  new left child
                //

                PrefixTableEntry->NodeTypeCode = RTL_NTC_UNICODE_INTERNAL;
                PrefixTableEntry->NextPrefixTree = NULL;
                PrefixTableEntry->CaseMatch = PrefixTableEntry;

                RtlInsertAsLeftChild(&Node->Links, &PrefixTableEntry->Links);

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a left child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlLeftChild(&Node->Links),
                                          UNICODE_PREFIX_TABLE_ENTRY,
                                          Links );
            }

        } else {

            //
            //  The tree prefix is either less than or a proper prefix
            //  of the new string.  We treat both cases a less than when
            //  we do insert.  So we want to go down the right subtree,
            //  first check to see if we have a right subtree
            //

            if (RtlRightChild(&Node->Links) == NULL) {

                //
                //  These isn't a right child so we insert ourselves as the
                //  new right child
                //

                PrefixTableEntry->NodeTypeCode = RTL_NTC_UNICODE_INTERNAL;
                PrefixTableEntry->NextPrefixTree = NULL;
                PrefixTableEntry->CaseMatch = PrefixTableEntry;

                RtlInsertAsRightChild(&Node->Links, &PrefixTableEntry->Links);

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a right child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlRightChild(&Node->Links),
                                          UNICODE_PREFIX_TABLE_ENTRY,
                                          Links );
            }
        }
    }

    //
    //  Now that we've inserted the new node we can splay the tree.
    //  To do this we need to remember how we find this tree in the root
    //  tree list, set the root to be an internal, splay, the tree, and
    //  then setup the new root node.  Note: we cannot splay the prefix table
    //  entry because it might be a case match node so we only splay
    //  the Node variable, which for case match insertions is the
    //  internal node for the case match and for non-case match insertions
    //  the Node variable is the parent node.
    //

    //
    //  Save a pointer to the next tree, we already have the previous tree
    //

    NextTree = CurrentTree->NextPrefixTree;

    //
    //  Reset the current root to be an internal node
    //

    CurrentTree->NodeTypeCode = RTL_NTC_UNICODE_INTERNAL;
    CurrentTree->NextPrefixTree = NULL;

    //
    //  Splay the tree and get the root
    //

    Node = CONTAINING_RECORD(RtlSplay(&Node->Links), UNICODE_PREFIX_TABLE_ENTRY, Links);

    //
    //  Set the new root's node type code and make it part of the
    //  root tree list
    //

    Node->NodeTypeCode = RTL_NTC_UNICODE_ROOT;
    PreviousTree->NextPrefixTree = Node;
    Node->NextPrefixTree = NextTree;

    //
    //  tell our caller everything worked fine
    //

    return TRUE;
}


VOID
RtlRemoveUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable,
    IN PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    )

/*++

Routine Description:

    This routine removes the indicated prefix table entry from
    the prefix table

Arguments:

    PrefixTable - Supplies the prefix table affected

    PrefixTableEntry - Supplies the prefix entry to remove

Return Value:

    None.

--*/

{
    PUNICODE_PREFIX_TABLE_ENTRY PreviousCaseMatch;

    PRTL_SPLAY_LINKS Links;

    PUNICODE_PREFIX_TABLE_ENTRY Root;
    PUNICODE_PREFIX_TABLE_ENTRY NewRoot;

    PUNICODE_PREFIX_TABLE_ENTRY PreviousTree;

    RTL_PAGED_CODE();

    //
    //  Wipe out the next last entry field of the prefix table
    //

    PrefixTable->LastNextEntry = NULL;

    //
    //  case on the type of node that we are trying to delete
    //

    switch (PrefixTableEntry->NodeTypeCode) {

    case RTL_NTC_UNICODE_CASE_MATCH:

        //
        //  The prefix entry is a case match record so
        //  we only need to remove it from the case match list.
        //  Locate the previous PrefixTableEntry that reference this
        //  case match record
        //

        PreviousCaseMatch = PrefixTableEntry->CaseMatch;

        while ( PreviousCaseMatch->CaseMatch != PrefixTableEntry ) {

             PreviousCaseMatch = PreviousCaseMatch->CaseMatch;
        }

        //
        //  Now that we have the previous record just have it point
        //  around the case match that is being deleted
        //

        PreviousCaseMatch->CaseMatch = PrefixTableEntry->CaseMatch;

        //
        //  And return to our caller
        //

        return;

    case RTL_NTC_UNICODE_INTERNAL:
    case RTL_NTC_UNICODE_ROOT:

        //
        //  The prefix entry is an internal/root node so check to see if it
        //  has any case match nodes with it
        //

        if (PrefixTableEntry->CaseMatch != PrefixTableEntry) {

            //
            //  There is at least one case match that goes with this
            //  node, so we need to make the next case match the
            //  new node and remove this node.
            //  Locate the previous prefix table entry that references this
            //  case match record
            //

            PreviousCaseMatch = PrefixTableEntry->CaseMatch;

            while ( PreviousCaseMatch->CaseMatch != PrefixTableEntry ) {

                PreviousCaseMatch = PreviousCaseMatch->CaseMatch;
            }

            //
            //  Now that we have the previous record just have it point
            //  around the node being deleted
            //

            PreviousCaseMatch->CaseMatch = PrefixTableEntry->CaseMatch;

            //
            //  Now make the previous case match in the new node
            //

            PreviousCaseMatch->NodeTypeCode = PrefixTableEntry->NodeTypeCode;
            PreviousCaseMatch->NextPrefixTree = PrefixTableEntry->NextPrefixTree;
            PreviousCaseMatch->Links = PrefixTableEntry->Links;

            //
            //  Now take care of the back pointers to this new internal
            //  node in the splay tree, first do the parent's pointer to us.
            //

            if (RtlIsRoot(&PrefixTableEntry->Links)) {

                //
                //  This is the root so make this new node the root
                //

                PreviousCaseMatch->Links.Parent = &PreviousCaseMatch->Links;

                //
                //  Fix up the root tree list, by first finding the previous
                //  pointer to us

                PreviousTree = PrefixTableEntry->NextPrefixTree;

                while ( PreviousTree->NextPrefixTree != PrefixTableEntry ) {

                    PreviousTree = PreviousTree->NextPrefixTree;
                }

                //
                //  We've located the previous tree so now have the previous
                //  tree point to our new root
                //

                PreviousTree->NextPrefixTree = PreviousCaseMatch;

            } else if (RtlIsLeftChild(&PrefixTableEntry->Links)) {

                //
                //  The node was the left child so make the new node the
                //  left child
                //

                RtlParent(&PrefixTableEntry->Links)->LeftChild = &PreviousCaseMatch->Links;

            } else {

                //
                //  The node was the right child so make the new node the
                //  right child
                //

                RtlParent(&PrefixTableEntry->Links)->RightChild = &PreviousCaseMatch->Links;
            }

            //
            //  Now update the parent pointer for our new children
            //

            if (RtlLeftChild(&PreviousCaseMatch->Links) != NULL) {

                RtlLeftChild(&PreviousCaseMatch->Links)->Parent = &PreviousCaseMatch->Links;
            }

            if (RtlRightChild(&PreviousCaseMatch->Links) != NULL) {

                RtlRightChild(&PreviousCaseMatch->Links)->Parent = &PreviousCaseMatch->Links;
            }

            //
            //  And return to our caller
            //

            return;
        }

        //
        //  The node is internal or root node and does not have any case match
        //  nodes so we need to delete it from the tree, but first find
        //  the root of the tree
        //

        Links = &PrefixTableEntry->Links;

        while (!RtlIsRoot(Links)) {

            Links = RtlParent(Links);
        }

        Root = CONTAINING_RECORD( Links, UNICODE_PREFIX_TABLE_ENTRY, Links );

        //
        //  Now delete the node
        //

        Links = RtlDelete(&PrefixTableEntry->Links);

        //
        //  Now see if the tree is deleted
        //

        if (Links == NULL) {

            //
            //  The tree is now empty so remove this tree from
            //  the tree list, by first finding the previous tree that
            //  references us
            //

            PreviousTree = Root->NextPrefixTree;

            while ( PreviousTree->NextPrefixTree != Root ) {

                PreviousTree = PreviousTree->NextPrefixTree;
            }

            //
            //  We've located the previous tree so now just have it
            //  point around the deleted node
            //

            PreviousTree->NextPrefixTree = Root->NextPrefixTree;

            //
            //  and return the our caller
            //

            return;
        }

        //
        //  The tree is not deleted but see if we changed roots
        //

        if (&Root->Links != Links) {

            //
            //  Get a pointer to the new root
            //

            NewRoot = CONTAINING_RECORD(Links, UNICODE_PREFIX_TABLE_ENTRY, Links);

            //
            //  We changed root so we better need to make the new
            //  root part of the prefix data structure, by
            //  first finding the previous tree that
            //  references us
            //

            PreviousTree = Root->NextPrefixTree;

            while ( PreviousTree->NextPrefixTree != Root ) {

                PreviousTree = PreviousTree->NextPrefixTree;
            }

            //
            //  Set the new root
            //

            NewRoot->NodeTypeCode = RTL_NTC_UNICODE_ROOT;

            PreviousTree->NextPrefixTree = NewRoot;
            NewRoot->NextPrefixTree = Root->NextPrefixTree;

            //
            //  Set the old root to be an internal node
            //

            Root->NodeTypeCode = RTL_NTC_UNICODE_INTERNAL;

            Root->NextPrefixTree = NULL;

            //
            //  And return to our caller
            //

            return;
        }

        //
        //  We didn't change roots so everything is fine and we can
        //  simply return to our caller
        //

        return;

    default:

        //
        //  If we get here then there was an error and the node type
        //  code is unknown
        //

        return;
    }
}


PUNICODE_PREFIX_TABLE_ENTRY
RtlFindUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable,
    IN PUNICODE_STRING FullName,
    IN ULONG CaseInsensitiveIndex
    )

/*++

Routine Description:

    This routine finds if a full name has a prefix in a prefix table.
    It returns a pointer to the largest proper prefix found if one exists.

Arguments:

    PrefixTable - Supplies the prefix table to search

    FullString - Supplies the name to search for

    CaseInsensitiveIndex - Indicates the wchar index at which to do a case
        insensitive search.  All characters before the index are searched
        case sensitive and all characters at and after the index are searched
        insensitive.

Return Value:

    PPREFIX_TABLE_ENTRY - a pointer to the longest prefix found if one
        exists, and NULL otherwise

--*/

{
    CLONG NameLength;

    PUNICODE_PREFIX_TABLE_ENTRY PreviousTree;
    PUNICODE_PREFIX_TABLE_ENTRY CurrentTree;
    PUNICODE_PREFIX_TABLE_ENTRY NextTree;

    PRTL_SPLAY_LINKS Links;

    PUNICODE_PREFIX_TABLE_ENTRY Node;
    PUNICODE_PREFIX_TABLE_ENTRY Next;

    COMPARISON Comparison;

    RTL_PAGED_CODE();

    //
    //  Determine the name length of the input string
    //

    NameLength = ComputeUnicodeNameLength(FullName);

    //
    //  Locate the first tree that can contain a prefix
    //

    PreviousTree = (PUNICODE_PREFIX_TABLE_ENTRY)PrefixTable;
    CurrentTree = PreviousTree->NextPrefixTree;

    while (CurrentTree->NameLength > (CSHORT)NameLength) {

        PreviousTree = CurrentTree;
        CurrentTree = CurrentTree->NextPrefixTree;
    }

    //
    //  Now search for a prefix until we find one or until we exhaust
    //  the prefix trees
    //

    while (CurrentTree->NameLength > 0) {

        Links = &CurrentTree->Links;

        while (Links != NULL) {

            Node = CONTAINING_RECORD(Links, UNICODE_PREFIX_TABLE_ENTRY, Links);

            //
            //  Compare the prefix in the tree with the full name, do the
            //  compare case blind
            //

            Comparison = CompareUnicodeStrings(Node->Prefix, FullName, 0);

            //
            //  See if they don't match
            //

            if (Comparison == IsGreaterThan) {

                //
                //  The prefix is greater than the full name
                //  so we go down the left child
                //

                Links = RtlLeftChild(Links);

                //
                //  And continue searching down this tree
                //

            } else if (Comparison == IsLessThan) {

                //
                //  The prefix is less than the full name
                //  so we go down the right child
                //

                Links = RtlRightChild(Links);

                //
                //  And continue searching down this tree
                //

            } else {

                //
                //  We have either a prefix or a match either way
                //  we need to check if we should do case sensitive
                //  searches
                //

                if (CaseInsensitiveIndex == 0) {

                    //
                    //  The caller wants case insensitive so we'll
                    //  return the first one we found
                    //
                    //  Now that we've located the node we can splay the tree.
                    //  To do this we need to remember how we find this tree in the root
                    //  tree list, set the root to be an internal, splay, the tree, and
                    //  then setup the new root node.
                    //

                    if (Node->NodeTypeCode == RTL_NTC_UNICODE_INTERNAL) {

                        //
                        //  Save a pointer to the next tree, we already have the previous tree
                        //

                        NextTree = CurrentTree->NextPrefixTree;

                        //
                        //  Reset the current root to be an internal node
                        //

                        CurrentTree->NodeTypeCode = RTL_NTC_UNICODE_INTERNAL;
                        CurrentTree->NextPrefixTree = NULL;

                        //
                        //  Splay the tree and get the root
                        //

                        Node = CONTAINING_RECORD(RtlSplay(&Node->Links), UNICODE_PREFIX_TABLE_ENTRY, Links);

                        //
                        //  Set the new root's node type code and make it part of the
                        //  root tree list
                        //

                        Node->NodeTypeCode = RTL_NTC_UNICODE_ROOT;
                        PreviousTree->NextPrefixTree = Node;
                        Node->NextPrefixTree = NextTree;
                    }

                    //
                    //  Now return the root to our caller
                    //

                    return Node;
                }

                //
                //  The caller wants an exact match so search the case match
                //  until we find a complete match.  Get the first node
                //

                Next = Node;

                //
                //  Loop through the case match list checking to see if we
                //  match case sensitive with anyone.
                //

                do {

                    //
                    //  If we do match case sensitive then we found one
                    //  and we return it to our caller
                    //

                    Comparison = CompareUnicodeStrings( Next->Prefix,
                                                        FullName,
                                                        CaseInsensitiveIndex );

                    if ((Comparison == IsEqual) || (Comparison == IsPrefix)) {

                        //
                        //  We found a good one, so return it to our caller
                        //

                        return Next;
                    }

                    //
                    //  Get the next case match record
                    //

                    Next = Next->CaseMatch;

                    //
                    //  And continue the loop until we reach the original
                    //  node again
                    //

                } while ( Next != Node );

                //
                //  We found a case blind prefix but the caller wants
                //  case sensitive and we weren't able to find one of those
                //  so we need to go on to the next tree, by breaking out
                //  of the inner while-loop
                //

                break;
            }
        }

        //
        //  This tree is done so now find the next tree
        //

        PreviousTree = CurrentTree;
        CurrentTree = CurrentTree->NextPrefixTree;
    }

    //
    //  We sesarched everywhere and didn't find a prefix so tell the
    //  caller none was found
    //

    return NULL;
}


PUNICODE_PREFIX_TABLE_ENTRY
RtlNextUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable,
    IN BOOLEAN Restart
    )

/*++

Routine Description:

    This routine returns the next prefix entry stored in the prefix table

Arguments:

    PrefixTable - Supplies the prefix table to enumerate

    Restart - Indicates if the enumeration should start over

Return Value:

    PPREFIX_TABLE_ENTRY - A pointer to the next prefix table entry if
        one exists otherwise NULL

--*/

{
    PUNICODE_PREFIX_TABLE_ENTRY Node;

    PRTL_SPLAY_LINKS Links;

    RTL_PAGED_CODE();

    //
    //  See if we are restarting the sequence
    //

    if (Restart || (PrefixTable->LastNextEntry == NULL)) {

        //
        //  we are restarting the sequence so locate the first entry
        //  in the first tree
        //

        Node = PrefixTable->NextPrefixTree;

        //
        //  Make sure we've pointing at a prefix tree
        //

        if (Node->NodeTypeCode == RTL_NTC_UNICODE_PREFIX_TABLE) {

            //
            //  No we aren't so the table must be empty
            //

            return NULL;
        }

        //
        //  Find the first node in the tree
        //

        Links = &Node->Links;

        while (RtlLeftChild(Links) != NULL) {

            Links = RtlLeftChild(Links);
        }

        //
        //  Set it as our the node we're returning
        //

        Node = CONTAINING_RECORD( Links, UNICODE_PREFIX_TABLE_ENTRY, Links);

    } else if (PrefixTable->LastNextEntry->CaseMatch->NodeTypeCode == RTL_NTC_UNICODE_CASE_MATCH) {

        //
        //  The last node has a case match that we should be returning
        //  this time around
        //

        Node = PrefixTable->LastNextEntry->CaseMatch;

    } else {

        //
        //  Move over the last node returned by the case match link, this
        //  will enable us to finish off the last case match node if there
        //  was one, and go to the next internal/root node. If this node
        //  does not have a case match then we simply circle back to ourselves
        //

        Node = PrefixTable->LastNextEntry->CaseMatch;

        //
        //  Find the successor for the last node we returned
        //

        Links = RtlRealSuccessor(&Node->Links);

        //
        //  If links is null then we've exhausted this tree and need to
        //  the the next tree to use
        //

        if (Links == NULL) {

            Links = &PrefixTable->LastNextEntry->Links;

            while (!RtlIsRoot(Links)) {

                Links = RtlParent(Links);
            }

            Node = CONTAINING_RECORD(Links, UNICODE_PREFIX_TABLE_ENTRY, Links);

            //
            //  Now we've found the root see if there is another
            //  tree to enumerate
            //

            Node = Node->NextPrefixTree;

            if (Node->NameLength <= 0) {

                //
                //  We've run out of tree so tell our caller there
                //  are no more
                //

                return NULL;
            }

            //
            //  We have another tree to go down
            //

            Links = &Node->Links;

            while (RtlLeftChild(Links) != NULL) {

                Links = RtlLeftChild(Links);
            }
        }

        //
        //  Set it as our the node we're returning
        //

        Node = CONTAINING_RECORD( Links, UNICODE_PREFIX_TABLE_ENTRY, Links);
    }

    //
    //  Save node as the last next entry
    //

    PrefixTable->LastNextEntry = Node;

    //
    //  And return this entry to our caller
    //

    return Node;
}


CLONG
ComputeUnicodeNameLength(
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine counts the number of names appearing in the input string.
    It does this by simply counting the number of backslashes in the string.
    To handle ill-formed names (i.e., names that do not contain a backslash)
    this routine really returns the number of backslashes plus 1.

Arguments:

    Name - Supplies the input name to examine

Returns Value:

    CLONG - the number of names in the input string

--*/

{
    WCHAR UnicodeBackSlash = '\\';
    ULONG NameLength;
    ULONG i;
    ULONG Count;

    RTL_PAGED_CODE();

    //
    //  Save the name length, this should make the compiler be able to
    //  optimize not having to reload the length each time
    //

    NameLength = (ULONG)Name->Length/sizeof (WCHAR);

    if (NameLength == 0) {
        return 1;
    }

    //
    //  Now loop through the input string counting back slashes
    //

    for (i = 0, Count = 1; i < NameLength - 1; i += 1) {

        //
        //  check for a back slash
        //

        if (Name->Buffer[i] == UnicodeBackSlash) {

            Count += 1;
        }
    }

    //
    //  return the number of back slashes we found
    //
    return Count;
}


COMPARISON
CompareUnicodeStrings (
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_STRING Name,
    IN ULONG CaseInsensitiveIndex
    )

/*++

Routine Description:

    This routine takes a prefix string and a full name string and determines
    if the prefix string is a proper prefix of the name string (case sensitive)

Arguments:

    Prefix - Supplies the input prefix string

    Name - Supplies the full name input string

    CaseInsensitiveIndex - Indicates the wchar index at which to do a case
        insensitive search.  All characters before the index are searched
        case sensitive and all characters at and after the index are searched

Return Value:

    COMPARISON - returns

        IsLessThan    if Prefix < Name lexicalgraphically,
        IsPrefix      if Prefix is a proper prefix of Name
        IsEqual       if Prefix is equal to Name, and
        IsGreaterThan if Prefix > Name lexicalgraphically

--*/

{
    WCHAR UnicodeBackSlash = '\\';
    ULONG PrefixLength;
    ULONG NameLength;
    ULONG MinLength;
    ULONG i;

    WCHAR PrefixChar;
    WCHAR NameChar;

    RTL_PAGED_CODE();

    //
    //  Save the length of the prefix and name string, this should allow
    //  the compiler to not need to reload the length through a pointer every
    //  time we need their values
    //

    PrefixLength = (ULONG)Prefix->Length/2;
    NameLength = (ULONG)Name->Length/2;

    //
    //  Special case the situation where the prefix string is simply "\" and
    //  the name starts with an "\"
    //

    if ((PrefixLength == 1) && (Prefix->Buffer[0] == UnicodeBackSlash) &&
        (NameLength > 1) && (Name->Buffer[0] == UnicodeBackSlash)) {
        return IsPrefix;
    }

    //
    //  Figure out the minimum of the two lengths
    //

    MinLength = (PrefixLength < NameLength ? PrefixLength : NameLength);

    //
    //  Loop through looking at all of the characters in both strings
    //  testing for equality.  First to the CaseSensitive part, then the
    //  CaseInsensitive part.
    //

    if (CaseInsensitiveIndex > MinLength) {

        CaseInsensitiveIndex = MinLength;
    }

    //
    //  CaseSensitive compare
    //

    for (i = 0; i < CaseInsensitiveIndex; i += 1) {

        PrefixChar = Prefix->Buffer[i];
        NameChar   = Name->Buffer[i];

        if (PrefixChar != NameChar) {

            break;
        }
    }

    //
    //  If we didn't break out of the above loop, do the
    //  CaseInsensitive compare.
    //

    if (i == CaseInsensitiveIndex) {

        WCHAR *s1 = &Prefix->Buffer[i];
        WCHAR *s2 = &Name->Buffer[i];

        for (; i < MinLength; i += 1) {

            PrefixChar = *s1++;
            NameChar = *s2++;

            if (PrefixChar != NameChar) {

                PrefixChar = NLS_UPCASE(PrefixChar);
                NameChar   = NLS_UPCASE(NameChar);

                if (PrefixChar != NameChar) {
                    break;
                }
            }
        }
    }

    //
    //  If we broke out of the above loop because of a mismatch, determine
    //  the result of the comparison.
    //

    if (i < MinLength) {

        //
        //  We also need to treat "\" as less than all other characters, so
        //  if the char is a "\" we'll drop it down to a value of zero.
        //

        if (PrefixChar == UnicodeBackSlash) {

            return IsLessThan;
        }

        if (NameChar == UnicodeBackSlash) {

            return IsGreaterThan;
        }

        //
        //  Now compare the characters
        //

        if (PrefixChar < NameChar) {

            return IsLessThan;

        } else if (PrefixChar > NameChar) {

            return IsGreaterThan;
        }
    }

    //
    //  They match up to the minimum length so now figure out the largest string
    //  and see if one is a proper prefix of the other
    //

    if (PrefixLength < NameLength) {

        //
        //  The prefix string is shorter so if it is a proper prefix we
        //  return prefix otherwise we return less than (e.g., "\a" < "\ab")
        //

        if (Name->Buffer[PrefixLength] == UnicodeBackSlash) {

            return IsPrefix;

        } else {

            return IsLessThan;
        }

    } else if (PrefixLength > NameLength) {

        //
        //  The Prefix string is longer so we say that the prefix is
        //  greater than the name (e.g., "\ab" > "\a")
        //
        return IsGreaterThan;

    } else {

        //
        //  They lengths are equal so the strings are equal
        //
        return IsEqual;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\rtldata.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Rtldata.c

Abstract:

    This module contains static data used by RLT routines.

--*/

#include <ntrtlp.h>

#if defined(ALLOC_DATA_PRAGMA)
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif

ULONG RtlpRandomConstantVector[128] = {
    0x4c8bc0aa, 0x4c022957, 0x2232827a, 0x2f1e7626, 0x7f8bdafb, 0x5c37d02a, 0x0ab48f72, 0x2f0c4ffa,
    0x290e1954, 0x6b635f23, 0x5d3885c0, 0x74b49ff8, 0x5155fa54, 0x6214ad3f, 0x111e9c29, 0x242a3a09,
    0x75932ae1, 0x40ac432e, 0x54f7ba7a, 0x585ccbd5, 0x6df5c727, 0x0374dad1, 0x7112b3f1, 0x735fc311,
    0x404331a9, 0x74d97781, 0x64495118, 0x323e04be, 0x5974b425, 0x4862e393, 0x62389c1d, 0x28a68b82,
    0x0f95da37, 0x7a50bbc6, 0x09b0091c, 0x22cdb7b4, 0x4faaed26, 0x66417ccd, 0x189e4bfa, 0x1ce4e8dd,
    0x5274c742, 0x3bdcf4dc, 0x2d94e907, 0x32eac016, 0x26d33ca3, 0x60415a8a, 0x31f57880, 0x68c8aa52,
    0x23eb16da, 0x6204f4a1, 0x373927c1, 0x0d24eb7c, 0x06dd7379, 0x2b3be507, 0x0f9c55b1, 0x2c7925eb,
    0x36d67c9a, 0x42f831d9, 0x5e3961cb, 0x65d637a8, 0x24bb3820, 0x4d08e33d, 0x2188754f, 0x147e409e,
    0x6a9620a0, 0x62e26657, 0x7bd8ce81, 0x11da0abb, 0x5f9e7b50, 0x23e444b6, 0x25920c78, 0x5fc894f0,
    0x5e338cbb, 0x404237fd, 0x1d60f80f, 0x320a1743, 0x76013d2b, 0x070294ee, 0x695e243b, 0x56b177fd,
    0x752492e1, 0x6decd52f, 0x125f5219, 0x139d2e78, 0x1898d11e, 0x2f7ee785, 0x4db405d8, 0x1a028a35,
    0x63f6f323, 0x1f6d0078, 0x307cfd67, 0x3f32a78a, 0x6980796c, 0x462b3d83, 0x34b639f2, 0x53fce379,
    0x74ba50f4, 0x1abc2c4b, 0x5eeaeb8d, 0x335a7a0d, 0x3973dd20, 0x0462d66b, 0x159813ff, 0x1e4643fd,
    0x06bc5c62, 0x3115e3fc, 0x09101613, 0x47af2515, 0x4f11ec54, 0x78b99911, 0x3db8dd44, 0x1ec10b9b,
    0x5b5506ca, 0x773ce092, 0x567be81a, 0x5475b975, 0x7a2cde1a, 0x494536f5, 0x34737bb4, 0x76d9750b,
    0x2a1f6232, 0x2e49644d, 0x7dddcbe7, 0x500cebdb, 0x619dab9e, 0x48c626fe, 0x1cda3193, 0x52dabe9d
    };

/*++

Table and auxiliary variable used by RtlRandomEx()
per Knuth (see comments for RtlRandomEx())

    Table is initialzed by generating the first 128 elements
    of the sequence UniformMacro() defined in random.c with
    seed and first element 0x4c8bc0aa.

    Auxiliary variable is initialized by the 129th. element
    of the same sequence.

--*/

ULONG RtlpRandomExAuxVarY = (ULONG)  0x7775fb16;

ULONG RtlpRandomExConstantVector[128] = {
    0x4c8bc0aa,  0x51a0b326,  0x7112b3f1,  0x1b9ca4e1,  0x735fc311,  0x6fe48580,  0x320a1743,  0x494045ca,
    0x103ad1c5,  0x4ba26e25,  0x62f1d304,  0x280d5677,  0x70294ee,   0x7acef21a,  0x62a407d5,  0x2dd36af5,
    0x194f0f95,  0x1f21d7b4,  0x307cfd67,  0x66b9311e,  0x60415a8a,  0x5b264785,  0x3c28b0e4,  0x8faded7,
    0x556175ce,  0x29c44179,  0x666f23c9,  0x65c057d8,  0x72b97abc,  0x7c3be3d0,  0x478e1753,  0x3074449b,
    0x675ee842,  0x53f4c2de,  0x44d58949,  0x6426cf59,  0x111e9c29,  0x3aba68b9,  0x242a3a09,  0x50ddb118,
    0x7f8bdafb,  0x89ebf23,   0x5c37d02a,  0x27db8ca6,  0xab48f72,   0x34995a4e,  0x189e4bfa,  0x2c405c36,
    0x373927c1,  0x66c20c71,  0x5f991360,  0x67a38fa3,  0x4edc56aa,  0x25a59126,  0x34b639f2,  0x1679b2ce,
    0x54f7ba7a,  0x319d28b5,  0x5155fa54,  0x769e6b87,  0x323e04be,  0x4565a5aa,  0x5974b425,  0x5c56a104,
    0x25920c78,  0x362912dc,  0x7af3996f,  0x5feb9c87,  0x618361bf,  0x433fbe97,  0x244da8e,   0x54e3c739,
    0x33183689,  0x3533f398,  0xd24eb7c,   0x6428590,   0x9101613,   0x53ce5c5a,  0x47af2515,  0x2e003f35,
    0x15fb4ed5,  0x5e5925f4,  0x7f622ea7,  0xbb6895f,   0x2173cdb6,  0x467bb41,   0x2c4d19f1,  0x364712e1,
    0x78b99911,  0xa39a380,   0x3db8dd44,  0x6b4793b8,  0x9b0091c,   0x47ef52b0,  0x293cdcb3,  0x707b9e7b,
    0x26d33ca3,  0x1e527faa,  0x3fe08625,  0x42560b04,  0x139d2e78,  0xb558cdb,   0x28a68b82,  0x7ba3a51d,
    0x52dabe9d,  0x59c3da1d,  0x5676cf9c,  0x152e972f,  0x6d8ac746,  0x5eb33591,  0x78b30601,  0xab68db0,
    0x34737bb4,  0x1b6dd168,  0x76d9750b,  0x2ddc4ff2,  0x18a610cd,  0x2bacc08c,  0x422db55f,  0x169b89b6,
    0x5274c742,  0x615535dd,  0x46ad005d,  0x4128f8dd,  0x29f5875c,  0x62c6f3ef,  0x2b3be507,  0x4a8e003f
};


const
PWSTR RtlpRegistryPaths[ RTL_REGISTRY_MAXIMUM ] = {
    NULL,
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services",
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control",
    L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion",
    L"\\Registry\\Machine\\Hardware\\DeviceMap",
    L"\\Registry\\User\\.Default"
};

const WCHAR szBias[] =          L"Bias";
const WCHAR szStandardName[] =  L"StandardName";
const WCHAR szStandardBias[] =  L"StandardBias";
const WCHAR szStandardStart[] = L"StandardStart";
const WCHAR szDaylightName[] =  L"DaylightName";
const WCHAR szDaylightBias[] =  L"DaylightBias";
const WCHAR szDaylightStart[] = L"DaylightStart";

const WCHAR GuidFormat[] = L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}";

#if defined(ALLOC_DATA_PRAGMA)
#pragma data_seg()
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\rtlassig.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    rtlassig.c

Abstract:

    This Module implements many security rtl routines defined in ntseapi.h

--*/

#include "ntrtlp.h"
#include "seopaque.h"
#include "sertlp.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, RtlSelfRelativeToAbsoluteSD)
#pragma alloc_text(PAGE, RtlMakeSelfRelativeSD)
#pragma alloc_text(PAGE, RtlpQuerySecurityDescriptor)
#pragma alloc_text(PAGE, RtlAbsoluteToSelfRelativeSD)
#pragma alloc_text(PAGE, RtlSelfRelativeToAbsoluteSD2)
#endif

NTSTATUS
RtlSelfRelativeToAbsoluteSD (
    __in PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    __out_bcount_part_opt(*AbsoluteSecurityDescriptorSize, *AbsoluteSecurityDescriptorSize) PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    __inout PULONG AbsoluteSecurityDescriptorSize,
    __out_bcount_part_opt(*DaclSize, *DaclSize) PACL Dacl,
    __inout PULONG DaclSize,
    __out_bcount_part_opt(*SaclSize, *SaclSize) PACL Sacl,
    __inout PULONG SaclSize,
    __out_bcount_part_opt(*OwnerSize, *OwnerSize) PSID Owner,
    __inout PULONG OwnerSize,
    __out_bcount_part_opt(*PrimaryGroupSize, *PrimaryGroupSize) PSID PrimaryGroup,
    __inout PULONG PrimaryGroupSize
    )

/*++

Routine Description:

    Converts a security descriptor from self-relative format to absolute
    format

Arguments:

    SecurityDescriptor - Supplies a pointer to a security descriptor in
        Self-Relative format

    AbsoluteSecurityDescriptor - A pointer to a buffer in which will be
        placed the main body of the Absolute format security descriptor.

    Dacl - Supplies a pointer to a buffer that will contain the Dacl of the
        output descriptor.  This pointer will be referenced by, not copied
        into, the output descriptor.

    DaclSize - Supplies the size of the buffer pointed to by Dacl.  In case
        of error, it will return the minimum size necessary to contain the
        Dacl.

    Sacl - Supplies a pointer to a buffer that will contain the Sacl of the
        output descriptor.  This pointer will be referenced by, not copied
        into, the output descriptor.

    SaclSize - Supplies the size of the buffer pointed to by Sacl.  In case
        of error, it will return the minimum size necessary to contain the
        Sacl.

    Owner - Supplies a pointer to a buffer that will contain the Owner of
        the output descriptor.  This pointer will be referenced by, not
        copied into, the output descriptor.

    OwnerSize - Supplies the size of the buffer pointed to by Owner.  In
        case of error, it will return the minimum size necessary to contain
        the Owner.

    PrimaryGroup - Supplies a pointer to a buffer that will contain the
        PrimaryGroup of the output descriptor.  This pointer will be
        referenced by, not copied into, the output descriptor.

    PrimaryGroupSize - Supplies the size of the buffer pointed to by
        PrimaryGroup.  In case of error, it will return the minimum size
        necessary to contain the PrimaryGroup.


Return Value:

    STATUS_SUCCESS - Success

    STATUS_BUFFER_TOO_SMALL - One of the buffers passed was too small.

    STATUS_INVALID_OWNER - There was not a valid owner in the passed
        security descriptor.

--*/

{

    ULONG NewDaclSize;
    ULONG NewSaclSize;
    ULONG NewBodySize;
    ULONG NewOwnerSize;
    ULONG NewGroupSize;
    PSID NewOwner;
    PSID NewGroup;
    PACL NewDacl;
    PACL NewSacl;

    //
    // typecast security descriptors so we don't have to cast all over the place.
    //

    PISECURITY_DESCRIPTOR OutSD = AbsoluteSecurityDescriptor;

    PISECURITY_DESCRIPTOR InSD =
            (PISECURITY_DESCRIPTOR)SelfRelativeSecurityDescriptor;

    RTL_PAGED_CODE();

    if ( !RtlpAreControlBitsSet( InSD, SE_SELF_RELATIVE) ) {
        return( STATUS_BAD_DESCRIPTOR_FORMAT );
    }

    NewBodySize = sizeof(SECURITY_DESCRIPTOR);
    RtlpQuerySecurityDescriptor(
        InSD,
        &NewOwner,
        &NewOwnerSize,
        &NewGroup,
        &NewGroupSize,
        &NewDacl,
        &NewDaclSize,
        &NewSacl,
        &NewSaclSize
        );

    if ( (OutSD == NULL) ||
         (NewBodySize  > *AbsoluteSecurityDescriptorSize) ||
         (NewOwnerSize > *OwnerSize )                     ||
         (NewDaclSize  > *DaclSize )                      ||
         (NewSaclSize  > *SaclSize )                      ||
         (NewGroupSize > *PrimaryGroupSize ) ) {

         *AbsoluteSecurityDescriptorSize = sizeof(SECURITY_DESCRIPTOR);
         *PrimaryGroupSize               = NewGroupSize;
         *OwnerSize                      = NewOwnerSize;
         *SaclSize                       = NewSaclSize;
         *DaclSize                       = NewDaclSize;
         return( STATUS_BUFFER_TOO_SMALL );
    }

    RtlMoveMemory( OutSD,
                   InSD,
                   sizeof(SECURITY_DESCRIPTOR_RELATIVE) );

    OutSD->Owner = NULL;
    OutSD->Group = NULL;
    OutSD->Sacl  = NULL;
    OutSD->Dacl  = NULL;
    RtlpClearControlBits( OutSD, SE_SELF_RELATIVE );
    if (NewOwner != NULL) {
        RtlMoveMemory( Owner, NewOwner, SeLengthSid( NewOwner ));
        OutSD->Owner = Owner;
    }

    if (NewGroup != NULL) {
        RtlMoveMemory( PrimaryGroup, NewGroup, SeLengthSid( NewGroup ));
        OutSD->Group = PrimaryGroup;
    }

    if (NewSacl != NULL) {
        RtlMoveMemory( Sacl, NewSacl, NewSacl->AclSize );
        OutSD->Sacl  = Sacl;
    }

    if (NewDacl != NULL) {
        RtlMoveMemory( Dacl, NewDacl, NewDacl->AclSize );
        OutSD->Dacl  = Dacl;
    }

    return( STATUS_SUCCESS );
}

NTSTATUS
RtlMakeSelfRelativeSD (
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __out_bcount(*BufferLength) PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    __inout PULONG BufferLength
    )

/*++

Routine Description:

    Makes a copy of a security descriptor.  The produced copy will be in self-relative
    form.

    The security descriptor to be copied may be in either absolute or self-relative
    form.

Arguments:

    SecurityDescriptor - Pointer to a security descriptor.  This descriptor will not
        be modified.

    SelfRelativeSecurityDescriptor - Pointer to a buffer that will contain
        the returned self-relative security descriptor.

    BufferLength - Supplies the length of the buffer.  If the supplied
        buffer is not large enough to hold the self-relative security
        descriptor, an error will be returned, and this field will return
        the minimum size required.

Return Value:

    STATUS_BUFFER_TOO_SMALL - The supplied buffer was too small to contain
        the resultant security descriptor.

--*/

{

    ULONG NewDaclSize;
    ULONG NewSaclSize;
    ULONG NewOwnerSize;
    ULONG NewGroupSize;
    ULONG AllocationSize;
    PSID NewOwner;
    PSID NewGroup;
    PACL NewDacl;
    PACL NewSacl;
    PCHAR Field;
    PCHAR Base;

    //
    // Convert security descriptors to new data type so we don't
    // have to cast all over the place.
    //

    PISECURITY_DESCRIPTOR_RELATIVE IResultantDescriptor =
            (PISECURITY_DESCRIPTOR_RELATIVE)SelfRelativeSecurityDescriptor;

    PISECURITY_DESCRIPTOR IPassedSecurityDescriptor =
            (PISECURITY_DESCRIPTOR)SecurityDescriptor;

    RtlpQuerySecurityDescriptor(
        IPassedSecurityDescriptor,
        &NewOwner,
        &NewOwnerSize,
        &NewGroup,
        &NewGroupSize,
        &NewDacl,
        &NewDaclSize,
        &NewSacl,
        &NewSaclSize
        );

    RTL_PAGED_CODE();

    AllocationSize = sizeof(SECURITY_DESCRIPTOR_RELATIVE) +
                     NewOwnerSize +
                     NewGroupSize +
                     NewDaclSize  +
                     NewSaclSize  ;

    if (AllocationSize > *BufferLength) {
        *BufferLength = AllocationSize;
        return( STATUS_BUFFER_TOO_SMALL );
    }

    RtlZeroMemory( IResultantDescriptor, AllocationSize );
    RtlCopyMemory( IResultantDescriptor,
                   IPassedSecurityDescriptor,
                   FIELD_OFFSET( SECURITY_DESCRIPTOR_RELATIVE, Owner ));

    Base = (PCHAR)(IResultantDescriptor);
    Field =  Base + (ULONG)sizeof(SECURITY_DESCRIPTOR_RELATIVE);
    if (NewSaclSize > 0) {
        RtlCopyMemory( Field, NewSacl, NewSaclSize );
        IResultantDescriptor->Sacl = RtlPointerToOffset(Base, Field);
        Field += NewSaclSize;

    } else {
        IResultantDescriptor->Sacl = 0;
    }

    if (NewDaclSize > 0) {
        RtlCopyMemory( Field, NewDacl, NewDaclSize );
        IResultantDescriptor->Dacl = RtlPointerToOffset(Base, Field);
        Field += NewDaclSize;

    } else {
        IResultantDescriptor->Dacl = 0;
    }

    if (NewOwnerSize > 0) {
        RtlCopyMemory( Field, NewOwner, NewOwnerSize );
        IResultantDescriptor->Owner = RtlPointerToOffset(Base, Field);
        Field += NewOwnerSize;
    }

    if (NewGroupSize > 0) {
        RtlCopyMemory( Field, NewGroup, NewGroupSize );
        IResultantDescriptor->Group = RtlPointerToOffset(Base, Field);
    }

    RtlpSetControlBits(IResultantDescriptor, SE_SELF_RELATIVE);
    return( STATUS_SUCCESS );
}

NTSTATUS
RtlAbsoluteToSelfRelativeSD(
    __in PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    __out_bcount(*BufferLength) PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    __inout PULONG BufferLength
    )

/*++

Routine Description:

    Converts a security descriptor in absolute form to one in self-relative
    form.

Arguments:

    AbsoluteSecurityDescriptor - Pointer to an absolute format security
        descriptor.  This descriptor will not be modified.

    SelfRelativeSecurityDescriptor - Pointer to a buffer that will contain
        the returned self-relative security descriptor.

    BufferLength - Supplies the length of the buffer.  If the supplied
        buffer is not large enough to hold the self-relative security
        descriptor, an error will be returned, and this field will return
        the minimum size required.


Return Value:

    STATUS_BUFFER_TOO_SMALL - The supplied buffer was too small to contain
        the resultant security descriptor.

    STATUS_BAD_DESCRIPTOR_FORMAT - The supplied security descriptor was not
        in absolute form.

--*/

{

    NTSTATUS NtStatus;

    PISECURITY_DESCRIPTOR IAbsoluteSecurityDescriptor =
            (PISECURITY_DESCRIPTOR)AbsoluteSecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Make sure the passed SD is absolute format, and then call
    // RtlMakeSelfRelativeSD() to do all the work.
    //

    if (RtlpAreControlBitsSet(IAbsoluteSecurityDescriptor, SE_SELF_RELATIVE)) {
        return( STATUS_BAD_DESCRIPTOR_FORMAT );
    }

    NtStatus = RtlMakeSelfRelativeSD(
                   AbsoluteSecurityDescriptor,
                   SelfRelativeSecurityDescriptor,
                   BufferLength
                   );

    return( NtStatus );
}

VOID
RtlpQuerySecurityDescriptor (
    __in PISECURITY_DESCRIPTOR SecurityDescriptor,
    __deref_out PSID *Owner,
    __out PULONG OwnerSize,
    __deref_out PSID *PrimaryGroup,
    __out PULONG PrimaryGroupSize,
    __deref_out PACL *Dacl,
    __out PULONG DaclSize,
    __deref_out PACL *Sacl,
    __out PULONG SaclSize
    )

/*++

Routine Description:

    Returns the pieces of a security descriptor structure.

Arguments:


    SecurityDescriptor - Provides the security descriptor of interest.

    Owner - Returns a pointer to the owner information contained in the
        security descriptor.

    OwnerSize - Returns the size of the owner information.

    PrimaryGroup -  Returns a pointer to the primary group information.

    PrimaryGroupSize - Returns the size of the primary group information.

    Dacl - Returns a pointer to the Dacl.

    DaclSize - Returns the size of the Dacl.

    Sacl - Returns a pointer to the Sacl.

    SaclSize - Returns the size of the Sacl.

Return Value:

    None.

--*/

{

    RTL_PAGED_CODE();

    *Owner = RtlpOwnerAddrSecurityDescriptor( SecurityDescriptor );
    if (*Owner != NULL) {
        *OwnerSize = LongAlignSize(SeLengthSid(*Owner));

    } else {
        *OwnerSize = 0;
    }

    *Dacl = RtlpDaclAddrSecurityDescriptor ( SecurityDescriptor );
    if (*Dacl !=NULL) {
        *DaclSize = LongAlignSize((*Dacl)->AclSize);

    } else {
        *DaclSize = 0;
    }

    *PrimaryGroup = RtlpGroupAddrSecurityDescriptor( SecurityDescriptor );
    if (*PrimaryGroup != NULL) {
        *PrimaryGroupSize = LongAlignSize(SeLengthSid(*PrimaryGroup));

    } else {
         *PrimaryGroupSize = 0;
    }

    *Sacl = RtlpSaclAddrSecurityDescriptor( SecurityDescriptor );
    if (*Sacl != NULL) {
        *SaclSize = LongAlignSize((*Sacl)->AclSize);

    } else {
        *SaclSize = 0;
    }
}

NTSTATUS
RtlSelfRelativeToAbsoluteSD2 (
    __inout_bcount(*pBufferSize) PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    __inout PULONG pBufferSize
    )

/*++

Routine Description:

    Converts a security descriptor from self-relative format to absolute
    format using the memory allocated for the SelfRelativeSecurityDescriptor

Arguments:

    pSecurityDescriptor - Supplies a pointer to a security descriptor in
        Self-Relative format. If success, we return a absolute security
        descriptor where this pointer pointings.

    pBufferSize - Supplies a pointer to the size of the
        buffer.

Return Value:

    STATUS_SUCCESS - Success

    STATUS_BAD_DESCRIPTOR_FORMAT - The passed descriptor is not a self-relative
       security descriptor.

    STATUS_BUFFER_TOO_SMALL - The passed buffer is too small.

    STATUS_INVALID_OWNER - There was not a valid owner in the passed
        security descriptor.

Notes: Despite some attempts to make this code as portable as possible and the 
       utilization of C_ASSERT or ASSERT to detect the respect of these assumptions, 
       this code is still making several assumptions about the format of the absolute 
       and self-relative descriptors and their relationships: in terms of packing, 
       fields definitions and locations in their respective structures. 
       In particular, this code assumes that the only differences are due to differences 
       in the types of the structure members and in the behavior of the security descriptor
       query API.
       At this time, the only structure members that get read/updated are Owner, Group,
       Dacl and Sacl. If more members are added or displaced in the definitions of these
       structures, this code may have to be modified.

--*/

{

    ULONG_PTR ptr;
    PSID owner;
    PSID group;
    PACL dacl;
    PACL sacl;
    ULONG daclSize;
    ULONG saclSize;
    ULONG newBodySize;
    ULONG ownerSize;
    ULONG groupSize;
    ULONG newBufferSize;
    LONG deltaSize;

    //
    // Typecast security descriptors so we don't have to cast all over the place.
    //

    PISECURITY_DESCRIPTOR          psd  = (PISECURITY_DESCRIPTOR)         pSelfRelativeSecurityDescriptor;
    PISECURITY_DESCRIPTOR_RELATIVE psdr = (PISECURITY_DESCRIPTOR_RELATIVE)pSelfRelativeSecurityDescriptor;

    //
    // This code uses several assumptions about the absolute and self-relative formats of 
    // security descriptors and the way they are packing in memory. 
    // See Routine Description Notes.
    //

    C_ASSERT( sizeof( SECURITY_DESCRIPTOR ) >= sizeof( SECURITY_DESCRIPTOR_RELATIVE ) ); 
    C_ASSERT( sizeof( psd->Control ) == sizeof( psdr->Control ) );
    C_ASSERT( FIELD_OFFSET( SECURITY_DESCRIPTOR, Control ) == FIELD_OFFSET( SECURITY_DESCRIPTOR_RELATIVE, Control ) );
    
    RTL_PAGED_CODE();

    //
    // Parameters check point
    //

    if ( psd == (PISECURITY_DESCRIPTOR)0 ) {
        return( STATUS_INVALID_PARAMETER_1 );        
    }

    if ( pBufferSize == (PULONG)0 )   {
        return( STATUS_INVALID_PARAMETER_2 );       
    }

    //
    // If the passed security descriptor is not self-relative, we return
    // an format error.
    //

    if ( !RtlpAreControlBitsSet( psd, SE_SELF_RELATIVE) ) {
        return( STATUS_BAD_DESCRIPTOR_FORMAT );
    }

    //
    // Update local variables by querying the self-relative descriptor.
    //
    // Note that the returned size values are long-aligned.
    //

    RtlpQuerySecurityDescriptor(
        psd,
        &owner,
        &ownerSize,
        &group,
        &groupSize,
        &dacl,
        &daclSize,
        &sacl,
        &saclSize
        );

    //
    // Identical formats check:
    //
    // Determine the delta in size between the two formats of security descriptors
    //

    deltaSize = sizeof( SECURITY_DESCRIPTOR ) - sizeof( SECURITY_DESCRIPTOR_RELATIVE ); 

    //
    // If identical format: 
    //      - clear the SELF_RELATIVE flag
    //      - update absolute descriptor members
    //      - return SUCCESS.
    //

    if ( deltaSize == 0 )   {
       
        RtlpClearControlBits( psd, SE_SELF_RELATIVE );

        //
        // Only the following fields are updated.
        //

        ASSERT( sizeof( psd->Owner ) == sizeof( psdr->Owner ) );
        ASSERT( sizeof( psd->Group ) == sizeof( psdr->Group ) );
        ASSERT( sizeof( psd->Sacl  ) == sizeof( psdr->Sacl  ) );
        ASSERT( sizeof( psd->Dacl  ) == sizeof( psdr->Dacl  ) );

        psd->Owner = owner;
        psd->Group = group;
        psd->Sacl  = sacl;
        psd->Dacl  = dacl;
    
        return( STATUS_SUCCESS );
    }

    //
    // Determine the required size for the absolute format:
    //

#define ULONG_PTR_SDEND( _Adr ) ( (ULONG_PTR)(_Adr) + (ULONG_PTR)(_Adr##Size) )

    ptr = owner > group ? ULONG_PTR_SDEND( owner ) : ULONG_PTR_SDEND( group );
    ptr = ptr > (ULONG_PTR)dacl ? ptr : ULONG_PTR_SDEND( dacl );
    ptr = ptr > (ULONG_PTR)sacl ? ptr : ULONG_PTR_SDEND( sacl );
   
    newBufferSize = sizeof( SECURITY_DESCRIPTOR );
    if ( ptr )   {

#define ULONG_ROUND_UP( x, y )   ((ULONG)(x) + ((y)-1) & ~((y)-1))

        newBufferSize += ULONG_ROUND_UP( (ULONG_PTR)ptr - (ULONG_PTR)(psdr + 1), sizeof(PVOID) );
    }

    //
    // If the specified buffer size is not big enough, let the caller know about 
    // the minimum size and return STATUS_BUFFER_TOO_SMALL.
    //

    if ( newBufferSize > *pBufferSize )  {
        *pBufferSize = newBufferSize;
        return( STATUS_BUFFER_TOO_SMALL );
    }

    //
    // Update absolute security descriptor:
    //

    //
    // Move the members of self-relative security descriptor in their 
    // absolute format locations.
    //

    if ( ptr )   {
       RtlMoveMemory( (PVOID)(psd + 1), (PVOID)(psdr + 1), newBufferSize - sizeof( SECURITY_DESCRIPTOR) );      
    }

    //
    // Clear the self-relative flag
    //

    RtlpClearControlBits( psd, SE_SELF_RELATIVE );

    //
    // Only the following fields are updated.
    //

    psd->Owner = (PSID)( owner ? (ULONG_PTR)owner + deltaSize : 0 );
    psd->Group = (PSID)( group ? (ULONG_PTR)group + deltaSize : 0 );
    psd->Sacl  = (PACL)( sacl  ? (ULONG_PTR)sacl  + deltaSize : 0 );
    psd->Dacl  = (PACL)( dacl  ? (ULONG_PTR)dacl  + deltaSize : 0 );
    return( STATUS_SUCCESS );

} // RtlSelfRelativeToAbsoluteSD2()
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\rtlexec.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    rtlexec.c

Abstract:

    User Mode routines for creating user mode processes and threads.

--*/

#include "ntrtlp.h"
#include <nturtl.h>
#include <string.h>
#include "init.h"
#include "ntos.h"
#define ROUND_UP( x, y )  ((ULONG)(x) + ((y)-1) & ~((y)-1))
#ifdef KERNEL
#define ISTERMINALSERVER() (SharedUserData->SuiteMask & (1 << TerminalServer))
#else
#define ISTERMINALSERVER() (USER_SHARED_DATA->SuiteMask & (1 << TerminalServer))
#endif

VOID
RtlpCopyProcString(
    IN OUT PWSTR *pDst,
    OUT PUNICODE_STRING DestString,
    IN PUNICODE_STRING SourceString,
    IN ULONG DstAlloc OPTIONAL
    );

NTSTATUS
RtlpOpenImageFile(
    IN PUNICODE_STRING ImagePathName,
    IN ULONG Attributes,
    OUT PHANDLE FileHandle,
    IN BOOLEAN ReportErrors
    );

NTSTATUS
RtlpFreeStack(
    IN HANDLE Process,
    IN PINITIAL_TEB InitialTeb
    );

NTSTATUS
RtlpCreateStack(
    IN HANDLE Process,
    IN SIZE_T MaximumStackSize OPTIONAL,
    IN SIZE_T CommittedStackSize OPTIONAL,
    IN ULONG ZeroBits OPTIONAL,
    OUT PINITIAL_TEB InitialTeb
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,RtlpCopyProcString          )
#pragma alloc_text(INIT,RtlCreateProcessParameters  )
#pragma alloc_text(INIT,RtlDestroyProcessParameters )
#pragma alloc_text(INIT,RtlNormalizeProcessParams   )
#pragma alloc_text(INIT,RtlDeNormalizeProcessParams )
#pragma alloc_text(INIT,RtlpOpenImageFile           )
#pragma alloc_text(PAGE,RtlpCreateStack             )
#pragma alloc_text(PAGE,RtlpFreeStack               )
#pragma alloc_text(INIT,RtlCreateUserProcess        )
#pragma alloc_text(PAGE,RtlCreateUserThread         )
#endif

#if defined(ALLOC_DATA_PRAGMA)
#pragma const_seg("INITCONST")
#endif
const UNICODE_STRING NullString = RTL_CONSTANT_STRING(L"");

VOID
RtlpCopyProcString(
    IN OUT PWSTR *pDst,
    OUT PUNICODE_STRING DestString,
    IN PUNICODE_STRING SourceString,
    IN ULONG DstAlloc OPTIONAL
    )
{
    if (!ARGUMENT_PRESENT( DstAlloc )) {
        DstAlloc = SourceString->MaximumLength;
    }

    ASSERT((SourceString->Length == 0) || (SourceString->Buffer != NULL));

    if (SourceString->Buffer != NULL && SourceString->Length != 0) {
        RtlCopyMemory (*pDst,
                       SourceString->Buffer,
                       SourceString->Length);
    }

    DestString->Buffer = *pDst;
    DestString->Length = SourceString->Length;
    DestString->MaximumLength = (USHORT)DstAlloc;

    if (DestString->Length < DestString->MaximumLength) {
        RtlZeroMemory (((PUCHAR)DestString->Buffer) + DestString->Length, DestString->MaximumLength - DestString->Length);
    }
    

    *pDst = (PWSTR)((PCHAR)(*pDst) + ROUND_UP( DstAlloc, sizeof( ULONG ) ) );
    return;
}

NTSTATUS
RtlCreateProcessParameters(
    OUT PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    IN PUNICODE_STRING ImagePathName,
    IN PUNICODE_STRING DllPath OPTIONAL,
    IN PUNICODE_STRING CurrentDirectory OPTIONAL,
    IN PUNICODE_STRING CommandLine OPTIONAL,
    IN PVOID Environment OPTIONAL,
    IN PUNICODE_STRING WindowTitle OPTIONAL,
    IN PUNICODE_STRING DesktopInfo OPTIONAL,
    IN PUNICODE_STRING ShellInfo OPTIONAL,
    IN PUNICODE_STRING RuntimeData OPTIONAL
    )

/*++

Routine Description:

    This function formats NT style RTL_USER_PROCESS_PARAMETERS
    record.  The record is self-contained in a single block of memory
    allocated by this function.  The allocation method is opaque and
    thus the record must be freed by calling the
    RtlDestroyProcessParameters function.

    The process parameters record is created in a de-normalized form,
    thus making it suitable for passing to the RtlCreateUserProcess
    function.  It is expected that the caller will fill in additional
    fields in the process parameters record after this function returns,
    but prior to calling RtlCreateUserProcess.

Arguments:

    pProcessParameters - Pointer to a variable that will receive the address
        of the process parameter structure created by this routine.  The
        memory for the structure is allocated in an opaque manner and must
        be freed by calling RtlDestroyProcessParameters.

    ImagePathName - Required parameter that is the fully qualified NT
        path name of the image file that will be used to create the process
        that will received these parameters.

    DllPath - An optional parameter that is an NT String variable pointing
        to the search path the NT Loader is to use in the target process
        when searching for Dll modules.  If not specified, then the Dll
        search path is filled in from the current process's Dll search
        path.

    CurrentDirectory - An optional parameter that is an NT String variable
        pointing to the default directory string for the target process.
        If not specified, then the current directory string is filled in
        from the current process's current directory string.

    CommandLine - An optional parameter that is an NT String variable that
        will be passed to the target process as its command line.  If not
        specified, then the command line passed to the target process will
        be a null string.

    Environment - An optional parameter that is an opaque pointer to an
        environment variable block of the type created by
        RtlCreateEnvironment routine.  If not specified, then the target
        process will receive a copy of the calling process's environment
        variable block.

    WindowTitle - An optional parameter that is an NT String variable that
        points to the title string the target process is to use for its
        main window.  If not specified, then a null string will be passed
        to the target process as its default window title.

    DesktopInfo - An optional parameter that is an NT String variable that
        contains uninterpreted data that is passed as is to the target
        process.  If not specified, the target process will receive a
        pointer to an empty string.

    ShellInfo - An optional parameter that is an NT String variable that
        contains uninterpreted data that is passed as is to the target
        process.  If not specified, the target process will receive a
        pointer to an empty string.

    RuntimeData - An optional parameter that is an NT String variable that
        contains uninterpreted data that is passed as is to the target
        process.  If not specified, the target process will receive a
        pointer to an empty string.

Return Value:

    STATUS_SUCCESS - The process parameters is De-Normalized and
        contains entries for each of the specified argument and variable
        strings.

    STATUS_BUFFER_TOO_SMALL - The specified process parameters buffer is
        too small to contain the argument and environment strings. The value
        of ProcessParameters->Length is modified to contain the buffer
        size needed to contain the argument and variable strings.

--*/

{
    PRTL_USER_PROCESS_PARAMETERS p;
    NTSTATUS Status;
    ULONG ByteCount;
    PWSTR pDst;
    PPEB Peb;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    HANDLE CurDirHandle;
    BOOLEAN PebLockAcquired = FALSE;

    //
    // Acquire the Peb Lock for the duration while we copy information out
    // of it.
    //

    Peb = NtCurrentPeb();
    ProcessParameters = Peb->ProcessParameters;

    Status = STATUS_SUCCESS;
    p = NULL;
    CurDirHandle = NULL;
    try {
        //
        //  Validate input parameters
        //

#define VALIDATE_STRING_PARAMETER(_x) \
    do { \
        ASSERT(ARGUMENT_PRESENT((_x))); \
        if (!ARGUMENT_PRESENT((_x))) { \
            Status = STATUS_INVALID_PARAMETER; \
            leave; \
        } \
        if (ARGUMENT_PRESENT((_x))) { \
            ASSERT((_x)->MaximumLength >= (_x)->Length); \
            ASSERT(((_x)->Length == 0) || ((_x)->Buffer != NULL)); \
            if (((_x)->MaximumLength < (_x)->Length) || \
                (((_x)->Length != 0) && ((_x)->Buffer == NULL))) { \
                Status = STATUS_INVALID_PARAMETER; \
                leave; \
            } \
        } \
    } while (0)

#define VALIDATE_OPTIONAL_STRING_PARAMETER(_x) \
    do { \
        if (ARGUMENT_PRESENT((_x))) { \
            ASSERT((_x)->MaximumLength >= (_x)->Length); \
            ASSERT(((_x)->Length == 0) || ((_x)->Buffer != NULL)); \
            if (((_x)->MaximumLength < (_x)->Length) || \
                (((_x)->Length != 0) && ((_x)->Buffer == NULL))) { \
                Status = STATUS_INVALID_PARAMETER; \
                leave; \
            } \
        } \
    } while (0)

        VALIDATE_STRING_PARAMETER (ImagePathName);
        VALIDATE_OPTIONAL_STRING_PARAMETER (DllPath);
        VALIDATE_OPTIONAL_STRING_PARAMETER (CurrentDirectory);
        VALIDATE_OPTIONAL_STRING_PARAMETER (CommandLine);
        VALIDATE_OPTIONAL_STRING_PARAMETER (WindowTitle);
        VALIDATE_OPTIONAL_STRING_PARAMETER (DesktopInfo);
        VALIDATE_OPTIONAL_STRING_PARAMETER (ShellInfo);
        VALIDATE_OPTIONAL_STRING_PARAMETER (RuntimeData);

#undef VALIDATE_STRING_PARAMETER
#undef VALIDATE_OPTIONAL_STRING_PARAMETER

        if (!ARGUMENT_PRESENT (CommandLine)) {
            CommandLine = ImagePathName;
        }

        if (!ARGUMENT_PRESENT (WindowTitle)) {
            WindowTitle = (PUNICODE_STRING)&NullString;
        }

        if (!ARGUMENT_PRESENT (DesktopInfo)) {
            DesktopInfo = (PUNICODE_STRING)&NullString;
        }

        if (!ARGUMENT_PRESENT (ShellInfo)) {
            ShellInfo = (PUNICODE_STRING)&NullString;
        }

        if (!ARGUMENT_PRESENT (RuntimeData)) {
            RuntimeData = (PUNICODE_STRING)&NullString;
        }

        //
        // Determine size need to contain the process parameter record
        // structure and all of the strings it will point to.  Each string
        // will be aligned on a ULONG byte boundary.
        // We do the ones we can outside of the peb lock.
        //

        ByteCount = sizeof (*ProcessParameters);
        ByteCount += ROUND_UP (DOS_MAX_PATH_LENGTH*2,        sizeof( ULONG ) );
        ByteCount += ROUND_UP (ImagePathName->Length + sizeof(UNICODE_NULL),    sizeof( ULONG ) );
        ByteCount += ROUND_UP (CommandLine->Length + sizeof(UNICODE_NULL),      sizeof( ULONG ) );
        ByteCount += ROUND_UP (WindowTitle->MaximumLength,   sizeof( ULONG ) );
        ByteCount += ROUND_UP (DesktopInfo->MaximumLength,   sizeof( ULONG ) );
        ByteCount += ROUND_UP (ShellInfo->MaximumLength,     sizeof( ULONG ) );
        ByteCount += ROUND_UP (RuntimeData->MaximumLength,   sizeof( ULONG ) );

        PebLockAcquired = TRUE;
        RtlAcquirePebLock ();

        //
        // For optional pointer parameters, default them to point to their
        // corresponding field in the current process's process parameter
        // structure or to a null string.
        //

        if (!ARGUMENT_PRESENT (DllPath)) {
            DllPath = &ProcessParameters->DllPath;
        }

        if (!ARGUMENT_PRESENT (CurrentDirectory)) {

            if (ProcessParameters->CurrentDirectory.Handle) {
                CurDirHandle = (HANDLE)((ULONG_PTR)ProcessParameters->CurrentDirectory.Handle & ~OBJ_HANDLE_TAGBITS);
                CurDirHandle = (HANDLE)((ULONG_PTR)CurDirHandle | RTL_USER_PROC_CURDIR_INHERIT);
            }
            CurrentDirectory = &ProcessParameters->CurrentDirectory.DosPath;
        } else {
            ASSERT(CurrentDirectory->MaximumLength >= CurrentDirectory->Length);
            ASSERT((CurrentDirectory->Length == 0) || (CurrentDirectory->Buffer != NULL));

            if (ProcessParameters->CurrentDirectory.Handle) {
                CurDirHandle = (HANDLE)((ULONG_PTR)ProcessParameters->CurrentDirectory.Handle & ~OBJ_HANDLE_TAGBITS);
                CurDirHandle = (HANDLE)((ULONG_PTR)CurDirHandle | RTL_USER_PROC_CURDIR_CLOSE);
            }
        }


        if (!ARGUMENT_PRESENT (Environment)) {
            Environment = ProcessParameters->Environment;
        }

        ByteCount += ROUND_UP (DllPath->MaximumLength,       sizeof( ULONG ) );

        //
        // Allocate memory for the process parameter record.
        //
        p = RtlAllocateHeap (RtlProcessHeap (), 0, ByteCount);

        if (p == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        RtlZeroMemory (p, sizeof (*p));

        p->MaximumLength = ByteCount;
        p->Length = ByteCount;
        p->Flags = RTL_USER_PROC_PARAMS_NORMALIZED;
        p->DebugFlags = 0;
        p->Environment = Environment;
        p->CurrentDirectory.Handle = CurDirHandle;

        //
        // Inherits ^C inhibit information
        //

        p->ConsoleFlags = ProcessParameters->ConsoleFlags;

        pDst = (PWSTR)(p + 1);
        RtlpCopyProcString (&pDst,
                            &p->CurrentDirectory.DosPath,
                            CurrentDirectory,
                            DOS_MAX_PATH_LENGTH*2);

        RtlpCopyProcString (&pDst, &p->DllPath, DllPath, 0);
        RtlpCopyProcString (&pDst, &p->ImagePathName, ImagePathName, ImagePathName->Length + sizeof (UNICODE_NULL));
        if (CommandLine->Length == CommandLine->MaximumLength) {
            RtlpCopyProcString (&pDst, &p->CommandLine, CommandLine, 0);
        } else {
            RtlpCopyProcString (&pDst, &p->CommandLine, CommandLine, CommandLine->Length + sizeof (UNICODE_NULL));
        }

        RtlpCopyProcString (&pDst, &p->WindowTitle, WindowTitle, 0);
        RtlpCopyProcString (&pDst, &p->DesktopInfo, DesktopInfo, 0);
        RtlpCopyProcString (&pDst, &p->ShellInfo,   ShellInfo, 0);
        if (RuntimeData->Length != 0) {
            RtlpCopyProcString (&pDst, &p->RuntimeData, RuntimeData, 0);
        }
        *pProcessParameters = RtlDeNormalizeProcessParams (p);
        p = NULL;
    } finally {
        if (PebLockAcquired) {
            RtlReleasePebLock();
        }

        if (AbnormalTermination ()) {
            Status = STATUS_ACCESS_VIOLATION;
        }

        if (p != NULL) {
            RtlDestroyProcessParameters (p);
        }

    }

    return Status;
}

NTSTATUS
RtlDestroyProcessParameters(
    IN PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    )
{
    RtlFreeHeap (RtlProcessHeap (), 0, ProcessParameters);
    return STATUS_SUCCESS;
}


#define RtlpNormalizeProcessParam( Base, p )        \
    if ((p) != NULL) {                              \
        (p) = (PWSTR)((PCHAR)(p) + (ULONG_PTR)(Base));  \
        }                                           \

#define RtlpDeNormalizeProcessParam( Base, p )      \
    if ((p) != NULL) {                              \
        (p) = (PWSTR)((PCHAR)(p) - (ULONG_PTR)(Base));  \
        }                                           \


PRTL_USER_PROCESS_PARAMETERS
RtlNormalizeProcessParams(
    IN OUT PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    )
{
    if (!ARGUMENT_PRESENT( ProcessParameters )) {
        return( NULL );
        }

    if (ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED) {
        return( ProcessParameters );
        }

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->CurrentDirectory.DosPath.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->DllPath.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->ImagePathName.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->CommandLine.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->WindowTitle.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->DesktopInfo.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->ShellInfo.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->RuntimeData.Buffer
                             );
    ProcessParameters->Flags |= RTL_USER_PROC_PARAMS_NORMALIZED;

    return( ProcessParameters );
}

PRTL_USER_PROCESS_PARAMETERS
RtlDeNormalizeProcessParams(
    IN OUT PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    )
{
    if (!ARGUMENT_PRESENT( ProcessParameters )) {
        return( NULL );
    }

    if (!(ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) {
        return( ProcessParameters );
    }

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->CurrentDirectory.DosPath.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->DllPath.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->ImagePathName.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->CommandLine.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->WindowTitle.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->DesktopInfo.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->ShellInfo.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->RuntimeData.Buffer
                               );

    ProcessParameters->Flags &= ~RTL_USER_PROC_PARAMS_NORMALIZED;
    return( ProcessParameters );
}

NTSTATUS
RtlpOpenImageFile(
    IN PUNICODE_STRING ImagePathName,
    IN ULONG Attributes,
    OUT PHANDLE FileHandle,
    IN BOOLEAN ReportErrors
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE File;
    IO_STATUS_BLOCK IoStatus;

    *FileHandle = NULL;

    InitializeObjectAttributes( &ObjectAttributes,
                                ImagePathName,
                                Attributes,
                                NULL,
                                NULL
                              );
    Status = ZwOpenFile( &File,
                         SYNCHRONIZE | FILE_EXECUTE,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_READ | FILE_SHARE_DELETE,
                         FILE_NON_DIRECTORY_FILE
                         );

    if (!NT_SUCCESS( Status )) {
#if DBG
        if (ReportErrors) {
            DbgPrint( "NTRTL: RtlpOpenImageFile - NtCreateFile( %wZ ) failed.  Status == %X\n",
                      ImagePathName,
                      Status
                    );
            }
#endif // DBG
        return( Status );
        }

    *FileHandle = File;
    return( STATUS_SUCCESS );
}


NTSTATUS
RtlpCreateStack(
    IN HANDLE Process,
    IN SIZE_T MaximumStackSize OPTIONAL,
    IN SIZE_T CommittedStackSize OPTIONAL,
    IN ULONG ZeroBits OPTIONAL,
    OUT PINITIAL_TEB InitialTeb
    )
{
    NTSTATUS Status;
    PCH Stack;
    SYSTEM_BASIC_INFORMATION SysInfo;
    BOOLEAN GuardPage;
    SIZE_T RegionSize;
    ULONG OldProtect;

    Status = ZwQuerySystemInformation( SystemBasicInformation,
                                       (PVOID)&SysInfo,
                                       sizeof( SysInfo ),
                                       NULL
                                     );
    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
        }

    //
    // if stack is in the current process, then default to
    // the parameters from the image
    //

    if ( Process == NtCurrentProcess() ) {
        PPEB Peb;
        PIMAGE_NT_HEADERS NtHeaders;


        Peb = NtCurrentPeb();
        NtHeaders = RtlImageNtHeader(Peb->ImageBaseAddress);

        if (!NtHeaders) {
            return STATUS_INVALID_IMAGE_FORMAT;
        }


        if (!MaximumStackSize) {
            MaximumStackSize = NtHeaders->OptionalHeader.SizeOfStackReserve;
            }

        if (!CommittedStackSize) {
            CommittedStackSize = NtHeaders->OptionalHeader.SizeOfStackCommit;
            }

        }
    else {

        if (!CommittedStackSize) {
            CommittedStackSize = SysInfo.PageSize;
            }

        if (!MaximumStackSize) {
            MaximumStackSize = SysInfo.AllocationGranularity;
            }

        }

    //
    // Enforce a minimal stack commit if there is a PEB setting
    // for this.
    //

    if ( CommittedStackSize >= MaximumStackSize ) {
        MaximumStackSize = ROUND_UP(CommittedStackSize, (1024*1024));
        }


    CommittedStackSize = ROUND_UP( CommittedStackSize, SysInfo.PageSize );
    MaximumStackSize = ROUND_UP( MaximumStackSize,
                                 SysInfo.AllocationGranularity
                               );

    Stack = NULL;


    Status = ZwAllocateVirtualMemory( Process,
                                      (PVOID *)&Stack,
                                      ZeroBits,
                                      &MaximumStackSize,
                                      MEM_RESERVE,
                                      PAGE_READWRITE
                                    );

    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "NTRTL: RtlpCreateStack( %lx ) failed.  Stack Reservation Status == %X\n",
                  Process,
                  Status
                );
#endif // DBG
        return( Status );
        }

    InitialTeb->OldInitialTeb.OldStackBase = NULL;
    InitialTeb->OldInitialTeb.OldStackLimit = NULL;
    InitialTeb->StackAllocationBase = Stack;
    InitialTeb->StackBase = Stack + MaximumStackSize;

    Stack += MaximumStackSize - CommittedStackSize;
    if (MaximumStackSize > CommittedStackSize) {
        Stack -= SysInfo.PageSize;
        CommittedStackSize += SysInfo.PageSize;
        GuardPage = TRUE;
        }
    else {
        GuardPage = FALSE;
        }
    Status = ZwAllocateVirtualMemory( Process,
                                      (PVOID *)&Stack,
                                      0,
                                      &CommittedStackSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    InitialTeb->StackLimit = Stack;

    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "NTRTL: RtlpCreateStack( %lx ) failed.  Stack Commit Status == %X\n",
                  Process,
                  Status
                );
#endif // DBG
        return( Status );
        }

    //
    // if we have space, create a guard page.
    //

    if (GuardPage) {
        RegionSize =  SysInfo.PageSize;
        Status = ZwProtectVirtualMemory( Process,
                                         (PVOID *)&Stack,
                                         &RegionSize,
                                         PAGE_GUARD | PAGE_READWRITE,
                                         &OldProtect);


        if ( !NT_SUCCESS( Status ) ) {
#if DBG
            DbgPrint( "NTRTL: RtlpCreateStack( %lx ) failed.  Guard Page Creation Status == %X\n",
                      Process,
                      Status
                    );
#endif // DBG
            return( Status );
            }
        InitialTeb->StackLimit = (PVOID)((PUCHAR)InitialTeb->StackLimit + RegionSize);
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlpFreeStack(
    IN HANDLE Process,
    IN PINITIAL_TEB InitialTeb
    )
{
    NTSTATUS Status;
    SIZE_T Zero;

    Zero = 0;
    Status = ZwFreeVirtualMemory( Process,
                                  &InitialTeb->StackAllocationBase,
                                  &Zero,
                                  MEM_RELEASE
                                );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "NTRTL: RtlpFreeStack( %lx ) failed.  Stack DeCommit Status == %X\n",
                  Process,
                  Status
                );
#endif // DBG
        return( Status );
        }

    RtlZeroMemory( InitialTeb, sizeof( *InitialTeb ) );
    return( STATUS_SUCCESS );
}


NTSTATUS
RtlCreateUserProcess(
    IN PUNICODE_STRING NtImagePathName,
    IN ULONG Attributes,
    IN PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    IN PSECURITY_DESCRIPTOR ProcessSecurityDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR ThreadSecurityDescriptor OPTIONAL,
    IN HANDLE ParentProcess OPTIONAL,
    IN BOOLEAN InheritHandles,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL,
    OUT PRTL_USER_PROCESS_INFORMATION ProcessInformation
    )

/*++

Routine Description:

    This function creates a user mode process with a single thread with
    a suspend count of one.  The address space of the new process is
    initialized with the contents of specified image file.  The caller
    can specify the Access Control List for the new process and thread.
    The caller can also specify the parent process to inherit process
    priority and processor affinity from.  The default is to inherit
    these from the current process.  Finally the caller can specify
    whether the new process is to inherit any of the object handles
    from the specified parent process or not.

    Information about the new process and thread is returned via
    the ProcessInformation parameter.

Arguments:

    NtImagePathName - A required pointer that points to the NT Path string
        that identifies the image file that is to be loaded into the
        child process.

    ProcessParameters - A required pointer that points to parameters that
        are to passed to the child process.

    ProcessSecurityDescriptor - An optional pointer to the Security Descriptor
        give to the new process.

    ThreadSecurityDescriptor - An optional pointer to the Security Descriptor
        give to the new thread.

    ParentProcess - An optional process handle that will used to inherit
        certain properties from.

    InheritHandles - A boolean value.  TRUE specifies that object handles
        associated with the specified parent process are to be inherited
        by the new process, provided they have the OBJ_INHERIT attribute.
        FALSE specifies that the new process is to inherit no handles.

    DebugPort - An optional handle to the debug port associated with this
        process.

    ExceptionPort - An optional handle to the exception port associated with this
        process.

    ProcessInformation - A pointer to a variable that receives information
        about the new process and thread.

--*/

{
    NTSTATUS Status;
    HANDLE Section, File;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PRTL_USER_PROCESS_PARAMETERS Parameters;
    SIZE_T ParameterLength;
    PVOID Environment;
    PWCHAR s;
    SIZE_T EnvironmentLength;
    SIZE_T RegionSize;
    PROCESS_BASIC_INFORMATION ProcessInfo;
    PPEB Peb;
    UNICODE_STRING Unicode;

    //
    // Zero output parameter and probe the addresses at the same time
    //

    RtlZeroMemory( ProcessInformation, sizeof( *ProcessInformation ) );
    ProcessInformation->Length = sizeof( *ProcessInformation );

    //
    // Open the specified image file.
    //

    Status = RtlpOpenImageFile( NtImagePathName,
                                Attributes & (OBJ_INHERIT | OBJ_CASE_INSENSITIVE),
                                &File,
                                TRUE
                              );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }


    //
    // Create a memory section backed by the opened image file
    //

    Status = ZwCreateSection( &Section,
                              SECTION_ALL_ACCESS,
                              NULL,
                              NULL,
                              PAGE_EXECUTE,
                              SEC_IMAGE,
                              File
                            );
    ZwClose( File );
    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
        }


    //
    // Create the user mode process, defaulting the parent process to the
    // current process if one is not specified.  The new process will not
    // have a name nor will the handle be inherited by other processes.
    //

    if (!ARGUMENT_PRESENT( ParentProcess )) {
        ParentProcess = NtCurrentProcess();
        }

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL,
                                ProcessSecurityDescriptor );
    if ( RtlGetNtGlobalFlags() & FLG_ENABLE_CSRDEBUG ) {
        if ( wcsstr(NtImagePathName->Buffer,L"csrss") ||
             wcsstr(NtImagePathName->Buffer,L"CSRSS")
           ) {

            //
            // For Hydra we don't name the CSRSS process to avoid name
            // collissions when multiple CSRSS's are started
            //
            if (ISTERMINALSERVER()) {

                InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL,
                                            ProcessSecurityDescriptor );
            } else {

                RtlInitUnicodeString(&Unicode,L"\\WindowsSS");
                InitializeObjectAttributes( &ObjectAttributes, &Unicode, 0, NULL,
                                            ProcessSecurityDescriptor );
            }

            }
        }

    if ( !InheritHandles ) {
        ProcessParameters->CurrentDirectory.Handle = NULL;
        }
    Status = ZwCreateProcess( &ProcessInformation->Process,
                              PROCESS_ALL_ACCESS,
                              &ObjectAttributes,
                              ParentProcess,
                              InheritHandles,
                              Section,
                              DebugPort,
                              ExceptionPort
                            );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( Section );
        return( Status );
        }


    //
    // Retrieve the interesting information from the image header
    //

    Status = ZwQuerySection( Section,
                             SectionImageInformation,
                             &ProcessInformation->ImageInformation,
                             sizeof( ProcessInformation->ImageInformation ),
                             NULL
                           );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( ProcessInformation->Process );
        ZwClose( Section );
        return( Status );
        }

    Status = ZwQueryInformationProcess( ProcessInformation->Process,
                                        ProcessBasicInformation,
                                        &ProcessInfo,
                                        sizeof( ProcessInfo ),
                                        NULL
                                      );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( ProcessInformation->Process );
        ZwClose( Section );
        return( Status );
        }

    Peb = ProcessInfo.PebBaseAddress;

    //
    // Duplicate Native handles into new process if any specified.
    // Note that the duplicated handles will overlay the input values.
    //

    try {
        Status = STATUS_SUCCESS;

        if ( ProcessParameters->StandardInput ) {

            Status = ZwDuplicateObject(
                        ParentProcess,
                        ProcessParameters->StandardInput,
                        ProcessInformation->Process,
                        &ProcessParameters->StandardInput,
                        0L,
                        0L,
                        DUPLICATE_SAME_ACCESS | DUPLICATE_SAME_ATTRIBUTES
                        );
            if ( !NT_SUCCESS(Status) ) {
                __leave;
            }
        }

        if ( ProcessParameters->StandardOutput ) {

            Status = ZwDuplicateObject(
                        ParentProcess,
                        ProcessParameters->StandardOutput,
                        ProcessInformation->Process,
                        &ProcessParameters->StandardOutput,
                        0L,
                        0L,
                        DUPLICATE_SAME_ACCESS | DUPLICATE_SAME_ATTRIBUTES
                        );
            if ( !NT_SUCCESS(Status) ) {
                __leave;
            }
        }

        if ( ProcessParameters->StandardError ) {

            Status = ZwDuplicateObject(
                        ParentProcess,
                        ProcessParameters->StandardError,
                        ProcessInformation->Process,
                        &ProcessParameters->StandardError,
                        0L,
                        0L,
                        DUPLICATE_SAME_ACCESS | DUPLICATE_SAME_ATTRIBUTES
                        );
            if ( !NT_SUCCESS(Status) ) {
                __leave;
            }
        }

    } finally {
        if ( !NT_SUCCESS(Status) ) {
            ZwClose( ProcessInformation->Process );
            ZwClose( Section );
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    //
    // Possibly reserve some address space in the new process
    //

    if (ProcessInformation->ImageInformation.SubSystemType == IMAGE_SUBSYSTEM_NATIVE ) {
        if ( ProcessParameters->Flags & RTL_USER_PROC_RESERVE_1MB ) {

            Environment = (PVOID)(4);
            RegionSize = (1024*1024)-(256);

            Status = ZwAllocateVirtualMemory( ProcessInformation->Process,
                                              (PVOID *)&Environment,
                                              0,
                                              &RegionSize,
                                              MEM_RESERVE,
                                              PAGE_READWRITE
                                            );
            if ( !NT_SUCCESS( Status ) ) {
                ZwClose( ProcessInformation->Process );
                ZwClose( Section );
                return( Status );
                }
            }
        }

    //
    // Allocate virtual memory in the new process and use NtWriteVirtualMemory
    // to write a copy of the process environment block into the address
    // space of the new process.  Save the address of the allocated block in
    // the process parameter block so the new process can access it.
    //

    if (s = (PWCHAR)ProcessParameters->Environment) {
        while (*s++) {
            while (*s++) {
                }
            }
        EnvironmentLength = (SIZE_T)(s - (PWCHAR)ProcessParameters->Environment) * sizeof(WCHAR);

        Environment = NULL;
        RegionSize = EnvironmentLength;
        Status = ZwAllocateVirtualMemory( ProcessInformation->Process,
                                          (PVOID *)&Environment,
                                          0,
                                          &RegionSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if ( !NT_SUCCESS( Status ) ) {
            ZwClose( ProcessInformation->Process );
            ZwClose( Section );
            return( Status );
            }

        Status = ZwWriteVirtualMemory( ProcessInformation->Process,
                                       Environment,
                                       ProcessParameters->Environment,
                                       EnvironmentLength,
                                       NULL
                                     );
        if ( !NT_SUCCESS( Status ) ) {
            ZwClose( ProcessInformation->Process );
            ZwClose( Section );
            return( Status );
            }

        ProcessParameters->Environment = Environment;
        }

    //
    // Allocate virtual memory in the new process and use NtWriteVirtualMemory
    // to write a copy of the process parameters block into the address
    // space of the new process.  Set the initial parameter to the new thread
    // to be the address of the block in the new process's address space.
    //

    Parameters = NULL;
    ParameterLength = ProcessParameters->MaximumLength;
    Status = ZwAllocateVirtualMemory( ProcessInformation->Process,
                                      (PVOID *)&Parameters,
                                      0,
                                      &ParameterLength,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( ProcessInformation->Process );
        ZwClose( Section );
        return( Status );
        }

    Status = ZwWriteVirtualMemory( ProcessInformation->Process,
                                   Parameters,
                                   ProcessParameters,
                                   ProcessParameters->Length,
                                   NULL
                                 );
    if ( !NT_SUCCESS( Status ) ) {
            ZwClose( ProcessInformation->Process );
            ZwClose( Section );
            return( Status );
            }

    Status = ZwWriteVirtualMemory( ProcessInformation->Process,
                                   &Peb->ProcessParameters,
                                   &Parameters,
                                   sizeof( Parameters ),
                                   NULL
                                 );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( ProcessInformation->Process );
        ZwClose( Section );
        return( Status );
        }

    //
    // Create a suspended thread in the new process.  Specify the size and
    // position of the stack, along with the start address, initial parameter
    // and an SECURITY_DESCRIPTOR.  The new thread will not have a name and its handle will
    // not be inherited by other processes.
    //

    Status = RtlCreateUserThread(
                 ProcessInformation->Process,
                 ThreadSecurityDescriptor,
                 TRUE,
                 ProcessInformation->ImageInformation.ZeroBits,
                 ProcessInformation->ImageInformation.MaximumStackSize,
                 ProcessInformation->ImageInformation.CommittedStackSize,
                 (PUSER_THREAD_START_ROUTINE)
                     ProcessInformation->ImageInformation.TransferAddress,
                 (PVOID)Peb,
                 &ProcessInformation->Thread,
                 &ProcessInformation->ClientId
                 );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( ProcessInformation->Process );
        ZwClose( Section );
        return( Status );
        }

    //
    // Now close the section and file handles.  The objects they represent
    // will not actually go away until the process is destroyed.
    //

    ZwClose( Section );

    //
    // Return success status
    //

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlCreateUserThread(
    IN HANDLE Process,
    IN PSECURITY_DESCRIPTOR ThreadSecurityDescriptor OPTIONAL,
    IN BOOLEAN CreateSuspended,
    IN ULONG ZeroBits OPTIONAL,
    IN SIZE_T MaximumStackSize OPTIONAL,
    IN SIZE_T CommittedStackSize OPTIONAL,
    IN PUSER_THREAD_START_ROUTINE StartAddress,
    IN PVOID Parameter OPTIONAL,
    OUT PHANDLE Thread OPTIONAL,
    OUT PCLIENT_ID ClientId OPTIONAL
    )

/*++

Routine Description:

    This function creates a user mode thread in a user process.  The caller
    specifies the attributes of the new thread.  A handle to the thread, along
    with its Client Id are returned to the caller.

Arguments:

    Process - Handle to the target process in which to create the new thread.

    ThreadSecurityDescriptor - An optional pointer to the Security Descriptor
        give to the new thread.

    CreateSuspended - A boolean parameter that specifies whether or not the new
        thread is to be created suspended or not.  If TRUE, the new thread
        will be created with an initial suspend count of 1.  If FALSE then
        the new thread will be ready to run when this call returns.

    ZeroBits - This parameter is passed to the virtual memory manager
        when the stack is allocated.  Stacks are always allocated with the
        MEM_TOP_DOWN allocation attribute.

    MaximumStackSize - This is the maximum size of the stack.  This size
        will be rounded up to the next highest page boundary.  If zero is
        specified, then the default size will be 64K bytes.

    CommittedStackSize - This is the initial committed size of the stack.  This
        size is rounded up to the next highest page boundary and then an
        additional page is added for the guard page.  The resulting size
        will then be commited and the guard page protection initialized
        for the last committed page in the stack.

    StartAddress - The initial starting address of the thread.

    Parameter - An optional pointer to a 32-bit pointer parameter that is
        passed as a single argument to the procedure at the start address
        location.

    Thread - An optional pointer that, if specified, points to a variable that
        will receive the handle of the new thread.

    ClientId - An optional pointer that, if specified, points to a variable
        that will receive the Client Id of the new thread.

--*/

{
    NTSTATUS Status;
    CONTEXT ThreadContext={0};
    OBJECT_ATTRIBUTES ObjectAttributes;
    INITIAL_TEB InitialTeb;
    HANDLE ThreadHandle;
    CLIENT_ID ThreadClientId;

    //
    // Allocate a stack for this thread in the address space of the target
    // process.
    //

    Status = RtlpCreateStack( Process,
                              MaximumStackSize,
                              CommittedStackSize,
                              ZeroBits,
                              &InitialTeb
                            );
    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
    }

    //
    // Create an initial context for the new thread.
    //


    try {
        RtlInitializeContext( Process,
                              &ThreadContext,
                              Parameter,
                              (PVOID)StartAddress,
                              InitialTeb.StackBase
                            );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        RtlpFreeStack( Process, &InitialTeb );
        return GetExceptionCode ();
    }

    //
    // Now create a thread in the target process.  The new thread will
    // not have a name and its handle will not be inherited by other
    // processes.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, OBJ_KERNEL_HANDLE, NULL,
                                ThreadSecurityDescriptor );
    Status = ZwCreateThread( &ThreadHandle,
                             THREAD_ALL_ACCESS,
                             &ObjectAttributes,
                             Process,
                             &ThreadClientId,
                             &ThreadContext,
                             &InitialTeb,
                             CreateSuspended
                           );
    if (!NT_SUCCESS( Status )) {
#if DBG
        DbgPrint( "NTRTL: RtlCreateUserThread Failed. NtCreateThread Status == %X\n",
                  Status );
#endif // DBG
        RtlpFreeStack( Process, &InitialTeb );
    } else {
        if (ARGUMENT_PRESENT( Thread )) {
            *Thread = ThreadHandle;
        } else {
            ZwClose (ThreadHandle);
        }

        if (ARGUMENT_PRESENT( ClientId )) {
            *ClientId = ThreadClientId;
        }

    }

    //
    // Return status
    //

    return( Status );
}

VOID
RtlFreeUserThreadStack(
    HANDLE hProcess,
    HANDLE hThread
    )
{
    NTSTATUS Status;
    PTEB Teb;
    THREAD_BASIC_INFORMATION ThreadInfo;
    PVOID StackDeallocationBase;
    SIZE_T Size;

    Status = NtQueryInformationThread (hThread,
                                       ThreadBasicInformation,
                                       &ThreadInfo,
                                       sizeof (ThreadInfo),
                                       NULL);
    Teb = ThreadInfo.TebBaseAddress;
    if (!NT_SUCCESS (Status) || !Teb) {
        return;
    }

    Status = NtReadVirtualMemory (hProcess,
                                  &Teb->DeallocationStack,
                                  &StackDeallocationBase,
                                  sizeof (StackDeallocationBase),
                                  NULL);
    if (!NT_SUCCESS (Status) || !StackDeallocationBase) {
        return;
    }

    Size = 0;
    NtFreeVirtualMemory (hProcess, &StackDeallocationBase, &Size, MEM_RELEASE);
    return;
}

#if defined(ALLOC_DATA_PRAGMA)
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\rtlnthdr.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    rtlimagentheader.c

Abstract:

    The module contains RtlImageNtHeader and RtlImageNtHeaderEx.

--*/

#include "ntrtlp.h"

#if DBG
int
RtlImageNtHeaderEx_ExceptionFilter(
    BOOLEAN RangeCheck,
    ULONG ExceptionCode
    )
{
    ASSERT(!RangeCheck || ExceptionCode == STATUS_IN_PAGE_ERROR);
    return EXCEPTION_EXECUTE_HANDLER;
}
#else
#define RtlImageNtHeaderEx_ExceptionFilter(RangeCheck, ExceptionCode) EXCEPTION_EXECUTE_HANDLER
#endif

NTSTATUS
NTAPI
RtlImageNtHeaderEx(
    ULONG Flags,
    PVOID Base,
    ULONG64 Size,
    OUT PIMAGE_NT_HEADERS * OutHeaders
    )

/*++

Routine Description:

    This function returns the address of the NT Header.

    This function is a bit complicated.
    It is this way because RtlImageNtHeader that it replaces was hard to understand,
      and this function retains compatibility with RtlImageNtHeader.

    RtlImageNtHeader was #ifed such as to act different in each of the three
        boot loader, kernel, usermode flavors.

    boot loader -- no exception handling
    usermode -- limit msdos header to 256meg, catch any exception accessing the msdos-header
                or the pe header
    kernel -- don't cross user/kernel boundary, don't catch the exceptions,
                no 256meg limit

Arguments:

    Flags - RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK -- don't be so picky
                about the image, for compatibility with RtlImageNtHeader
    Base - Supplies the base of the image.
    Size - The size of the view, usually larger than the size of the file on disk.
            This is available from NtMapViewOfSection but not from MapViewOfFile.
    OutHeaders -

Return Value:

    STATUS_SUCCESS -- everything ok
    STATUS_INVALID_IMAGE_FORMAT -- bad filesize or signature value
    STATUS_INVALID_PARAMETER -- bad parameters

--*/

{
    PIMAGE_NT_HEADERS NtHeaders = 0;
    ULONG e_lfanew = 0;
    BOOLEAN RangeCheck = 0;
    NTSTATUS Status = 0;
    const ULONG ValidFlags = 
        RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK;

    if (OutHeaders != NULL) {
        *OutHeaders = NULL;
    }
    if (OutHeaders == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if ((Flags & ~ValidFlags) != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (Base == NULL || Base == (PVOID)(LONG_PTR)-1) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    RangeCheck = ((Flags & RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK) == 0);
    if (RangeCheck) {
        if (Size < sizeof(IMAGE_DOS_HEADER)) {
            Status = STATUS_INVALID_IMAGE_FORMAT;
            goto Exit;
        }
    }

    //
    // Exception handling is not available in the boot loader, and exceptions
    // were not historically caught here in kernel mode. Drivers are considered
    // trusted, so we can't get an exception here due to a bad file, but we
    // could take an inpage error.
    //
#define EXIT goto Exit
    if (((PIMAGE_DOS_HEADER)Base)->e_magic != IMAGE_DOS_SIGNATURE) {
        Status = STATUS_INVALID_IMAGE_FORMAT;
        EXIT;
    }
    e_lfanew = ((PIMAGE_DOS_HEADER)Base)->e_lfanew;
    if (RangeCheck) {
        if (e_lfanew >= Size
#define SIZEOF_PE_SIGNATURE 4
            || e_lfanew >= (MAXULONG - SIZEOF_PE_SIGNATURE - sizeof(IMAGE_FILE_HEADER))
            || (e_lfanew + SIZEOF_PE_SIGNATURE + sizeof(IMAGE_FILE_HEADER)) >= Size
            ) {
            Status = STATUS_INVALID_IMAGE_FORMAT;
            EXIT;
        }
    }

    NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + e_lfanew);

    //
    // In kernelmode, do not cross from usermode address to kernelmode address.
    //
    if (Base < MM_HIGHEST_USER_ADDRESS) {
        if ((PVOID)NtHeaders >= MM_HIGHEST_USER_ADDRESS) {
            Status = STATUS_INVALID_IMAGE_FORMAT;
            EXIT;
        }
        //
        // Note that this check is slightly overeager since IMAGE_NT_HEADERS has
        // a builtin array of data_directories that may be larger than the image
        // actually has. A better check would be to add FileHeader.SizeOfOptionalHeader,
        // after ensuring that the FileHeader does not cross the u/k boundary.
        //
        if ((PVOID)((PCHAR)NtHeaders + sizeof (IMAGE_NT_HEADERS)) >= MM_HIGHEST_USER_ADDRESS) {
            Status = STATUS_INVALID_IMAGE_FORMAT;
            EXIT;
        }
    }

    if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {
        Status = STATUS_INVALID_IMAGE_FORMAT;
        EXIT;
    }
    Status = STATUS_SUCCESS;

Exit:
    if (NT_SUCCESS(Status)) {
        *OutHeaders = NtHeaders;
    }
    return Status;
}
#undef EXIT

PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
    PVOID Base
    )
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    (VOID)RtlImageNtHeaderEx(RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK, Base, 0, &NtHeaders);
    return NtHeaders;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\str2adda.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
//
// You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

//
// Without this define, link errors can occur due to missing _pctype and 
// __mb_cur_max
//
#define _CTYPE_DISABLE_MACROS

#undef UNICODE
#undef _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <stdlib.h>
#include <tchar.h>

#define RtlIpv4StringToAddressT RtlIpv4StringToAddressA
#define RtlIpv6StringToAddressT RtlIpv6StringToAddressA
#define RtlIpv4StringToAddressExT RtlIpv4StringToAddressExA
#define RtlIpv6StringToAddressExT RtlIpv6StringToAddressExA
#include "str2addt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\splay.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Splay.c

Abstract:

    This module implements the general splay utilities

--*/

#include <nt.h>

#include <ntrtl.h>

#define SwapPointers(Ptr1, Ptr2) {      \
    PVOID _SWAP_POINTER_TEMP;           \
    _SWAP_POINTER_TEMP = (PVOID)(Ptr1); \
    (Ptr1) = (Ptr2);                    \
    (Ptr2) = _SWAP_POINTER_TEMP; \
    }

#define ParentsChildPointerAddress(Links) ( \
    RtlIsLeftChild(Links) ?                 \
        &(((Links)->Parent)->LeftChild)     \
    :                                       \
        &(((Links)->Parent)->RightChild)    \
    )

VOID
SwapSplayLinks (
    IN PRTL_SPLAY_LINKS Link1,
    IN PRTL_SPLAY_LINKS Link2
    );


PRTL_SPLAY_LINKS
RtlSplay (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The Splay function takes as input a pointer to a splay link in a tree
    and splays the tree.  Its function return value is a pointer to the
    root of the splayed tree.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the root of the splayed tree.

--*/

{
    PRTL_SPLAY_LINKS L;
    PRTL_SPLAY_LINKS P;
    PRTL_SPLAY_LINKS G;

    //
    //  while links is not the root we need to keep rotating it toward
    //  the root
    //

    L = Links;

    while (!RtlIsRoot(L)) {

        P = RtlParent(L);
        G = RtlParent(P);

        if (RtlIsLeftChild(L)) {

            if (RtlIsRoot(P)) {

                /*
                  we have the following case

                          P           L
                         / \         / \
                        L   c  ==>  a   P
                       / \             / \
                      a   b           b   c
                */

                //
                //  Connect P & b
                //

                P->LeftChild = L->RightChild;
                if (P->LeftChild != NULL) {P->LeftChild->Parent = P;}

                //
                //  Connect L & P
                //

                L->RightChild = P;
                P->Parent = L;

                //
                //  Make L the root
                //

                L->Parent = L;

            } else if (RtlIsLeftChild(P)) {

                /*
                  we have the following case

                          |           |
                          G           L
                         / \         / \
                        P   d  ==>  a   P
                       / \             / \
                      L   c           b   G
                     / \                 / \
                    a   b               c   d
                */

                //
                //  Connect P & b
                //

                P->LeftChild = L->RightChild;
                if (P->LeftChild != NULL) {P->LeftChild->Parent = P;}

                //
                //  Connect G & c
                //

                G->LeftChild = P->RightChild;
                if (G->LeftChild != NULL) {G->LeftChild->Parent = G;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & P
                //

                L->RightChild = P;
                P->Parent = L;

                //
                //  Connect P & G
                //

                P->RightChild = G;
                G->Parent = P;

            } else { // RtlIsRightChild(Parent)

                /*
                  we have the following case

                        |                |
                        G                L
                       / \             /   \
                      a   P           G     P
                         / \         / \   / \
                        L   d  ==>  a   b c   d
                       / \
                      b   c
                */

                //
                //  Connect G & b
                //

                G->RightChild = L->LeftChild;
                if (G->RightChild != NULL) {G->RightChild->Parent = G;}

                //
                //  Connect P & c
                //

                P->LeftChild = L->RightChild;
                if (P->LeftChild != NULL) {P->LeftChild->Parent = P;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & G
                //

                L->LeftChild = G;
                G->Parent = L;

                //
                //  Connect L & P
                //

                L->RightChild = P;
                P->Parent = L;

            }

        } else { // RtlIsRightChild(L)

            if (RtlIsRoot(P)) {

                /*
                  we have the following case

                        P               L
                       / \             / \
                      a   L           P   c
                         / \         / \
                        b   c  ==>  a   b
                */

                //
                //  Connect P & b
                //

                P->RightChild = L->LeftChild;
                if (P->RightChild != NULL) {P->RightChild->Parent = P;}

                //
                //  Connect P & L
                //

                L->LeftChild = P;
                P->Parent = L;

                //
                //  Make L the root
                //

                L->Parent = L;

            } else if (RtlIsRightChild(P)) {

                /*
                  we have the following case

                      |                   |
                      G                   L
                     / \                 / \
                    a   P               P   d
                       / \             / \
                      b   L           G   c
                         / \         / \
                        c   d  ==>  a   b
                */

                //
                //  Connect G & b
                //

                G->RightChild = P->LeftChild;
                if (G->RightChild != NULL) {G->RightChild->Parent = G;}

                //
                //  Connect P & c
                //

                P->RightChild = L->LeftChild;
                if (P->RightChild != NULL) {P->RightChild->Parent = P;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & P
                //

                L->LeftChild = P;
                P->Parent = L;

                //
                //  Connect P & G
                //

                P->LeftChild = G;
                G->Parent = P;

            } else { // RtlIsLeftChild(P)

                /*
                  we have the following case

                          |              |
                          G              L
                         / \           /   \
                        P   d         P     G
                       / \           / \   / \
                      a   L    ==>  a   b c   d
                         / \
                        b   c
                */

                //
                //  Connect P & b
                //

                P->RightChild = L->LeftChild;
                if (P->RightChild != NULL) {P->RightChild->Parent = P;}

                //
                //  Connect G & c
                //

                G->LeftChild = L->RightChild;
                if (G->LeftChild != NULL) {G->LeftChild->Parent = G;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & P
                //

                L->LeftChild = P;
                P->Parent = L;

                //
                //  Connect L & G
                //

                L->RightChild = G;
                G->Parent = L;

            }
        }
    }

    return L;
}


PRTL_SPLAY_LINKS
RtlDelete (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The Delete function takes as input a pointer to a splay link in a tree
    and deletes that node from the tree.  Its function return value is a
    pointer to the root of the tree.  If the tree is now empty, the return
    value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the root of the tree.

--*/

{
    PRTL_SPLAY_LINKS Predecessor;
    PRTL_SPLAY_LINKS Parent;
    PRTL_SPLAY_LINKS Child;

    PRTL_SPLAY_LINKS *ParentChildPtr;

    //
    //  First check to see if Links as two children.  If it does then swap
    //  Links with its subtree predecessor.  Now we are guaranteed that Links
    //  has at most one child.
    //

    if ((RtlLeftChild(Links) != NULL) && (RtlRightChild(Links) != NULL)) {

        //
        //  get the predecessor, and swap their position in the tree
        //

        Predecessor = RtlSubtreePredecessor(Links);
        SwapSplayLinks(Predecessor, Links);

    }

    //
    //  If Links has no children then delete links by checking if it is
    //  already the root or has a parent.  If it is the root then the
    //  tree is now empty, otherwise it set the appropriate parent's child
    //  pointer (i.e., the one to links) to NULL, and splay the parent.
    //

    if ((RtlLeftChild(Links) == NULL) && (RtlRightChild(Links) == NULL)) {

        //
        //  Links has no children, if it is the root then return NULL
        //

        if (RtlIsRoot(Links)) {

            return NULL;
        }

        //
        //  Links as not children and is not the root, so to the parent's
        //  child pointer to NULL and splay the parent.
        //

        Parent = RtlParent(Links);

        ParentChildPtr = ParentsChildPointerAddress(Links);
        *ParentChildPtr = NULL;

        return RtlSplay(Parent);

    }

    //
    //  otherwise Links has one child.  If it is the root then make the child
    //  the new root, otherwise link together the child and parent, and splay
    //  the parent.  But first remember who our child is.
    //

    if (RtlLeftChild(Links) != NULL) {
        Child = RtlLeftChild(Links);
    } else {
        Child = RtlRightChild(Links);
    }

    //
    //  If links is the root then we make the child the root and return the
    //  child.
    //

    if (RtlIsRoot(Links)) {
        Child->Parent = Child;
        return Child;
    }

    //
    //  Links is not the root, so set link's parent child pointer to be
    //  the child and the set child's parent to be link's parent, and splay
    //  the parent.
    //

    ParentChildPtr = ParentsChildPointerAddress(Links);
    *ParentChildPtr = Child;
    Child->Parent = Links->Parent;

    return RtlSplay(RtlParent(Child));

}


VOID
RtlDeleteNoSplay (
    IN PRTL_SPLAY_LINKS Links,
    IN OUT PRTL_SPLAY_LINKS *Root
    )

/*++

Routine Description:

    The Delete function takes as input a pointer to a splay link in a tree,
    a pointer to the callers pointer to the tree and deletes that node from
    the tree.  The caller's pointer is updated upon return.  If the tree is
    now empty, the value is NULL.

    Unfortunately, the original RtlDelete() always splays and this is not
    always a desireable side-effect.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

    Root - Pointer to the callers pointer to the root 

Return Value:

    None

--*/

{
    PRTL_SPLAY_LINKS Predecessor;
    PRTL_SPLAY_LINKS Parent;
    PRTL_SPLAY_LINKS Child;

    PRTL_SPLAY_LINKS *ParentChildPtr;

    //
    //  First check to see if Links as two children.  If it does then swap
    //  Links with its subtree predecessor.  Now we are guaranteed that Links
    //  has at most one child.
    //

    if ((RtlLeftChild(Links) != NULL) && (RtlRightChild(Links) != NULL)) {

        //
        //  get the predecessor, and swap their position in the tree
        //

        Predecessor = RtlSubtreePredecessor(Links);

        if (RtlIsRoot(Links)) {

            //
            //  If we're switching with the root of the tree, fix the
            //  caller's root pointer
            //

            *Root = Predecessor;
        }

        SwapSplayLinks(Predecessor, Links);

    }

    //
    //  If Links has no children then delete links by checking if it is
    //  already the root or has a parent.  If it is the root then the
    //  tree is now empty, otherwise it set the appropriate parent's child
    //  pointer (i.e., the one to links) to NULL.
    //

    if ((RtlLeftChild(Links) == NULL) && (RtlRightChild(Links) == NULL)) {

        //
        //  Links has no children, if it is the root then set root to NULL
        //

        if (RtlIsRoot(Links)) {

            *Root = NULL;

            return;
        }

        //
        //  Links as not children and is not the root, so to the parent's
        //  child pointer to NULL.
        //

        ParentChildPtr = ParentsChildPointerAddress(Links);
        *ParentChildPtr = NULL;

        return;
    }

    //
    //  otherwise Links has one child.  If it is the root then make the child
    //  the new root, otherwise link together the child and parent. But first
    //  remember who our child is.
    //

    if (RtlLeftChild(Links) != NULL) {
        Child = RtlLeftChild(Links);
    } else {
        Child = RtlRightChild(Links);
    }

    //
    //  If links is the root then we make the child the root and return the
    //  child.
    //

    if (RtlIsRoot(Links)) {
        Child->Parent = Child;

        *Root = Child;

        return;
    }

    //
    //  Links is not the root, so set link's parent child pointer to be
    //  the child and the set child's parent to be link's parent.
    //

    ParentChildPtr = ParentsChildPointerAddress(Links);
    *ParentChildPtr = Child;
    Child->Parent = Links->Parent;

    return;
}


PRTL_SPLAY_LINKS
RtlSubtreeSuccessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The SubtreeSuccessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the successor of the input node of
    the subtree rooted at the input node.  If there is not a successor, the
    return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the successor in the subtree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    /*
      check to see if there is a right subtree to the input link
      if there is then the subtree successor is the left most node in
      the right subtree.  That is find and return P in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  P
                   \
    */

    if ((Ptr = RtlRightChild(Links)) != NULL) {

        while (RtlLeftChild(Ptr) != NULL) {
            Ptr = RtlLeftChild(Ptr);
        }

        return Ptr;

    }

    //
    //  otherwise we are do not have a subtree successor so we simply return
    //  NULL
    //

    return NULL;

}


PRTL_SPLAY_LINKS
RtlSubtreePredecessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The SubtreePredecessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the predecessor of the input node of
    the subtree rooted at the input node.  If there is not a predecessor,
    the return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the predecessor in the subtree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    //
    //  check to see if there is a left subtree to the input link
    //  if there is then the subtree predecessor is the right most node in
    //  the left subtree.  That is find and return P in the following diagram
    //
    //              Links
    //               /
    //              .
    //               .
    //                .
    //                 P
    //                /
    //

    if ((Ptr = RtlLeftChild(Links)) != NULL) {

        while (RtlRightChild(Ptr) != NULL) {
            Ptr = RtlRightChild(Ptr);
        }

        return Ptr;

    }

    //
    //  otherwise we are do not have a subtree predecessor so we simply return
    //  NULL
    //

    return NULL;

}


PRTL_SPLAY_LINKS
RtlRealSuccessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The RealSuccessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the successor of the input node within
    the entire tree.  If there is not a successor, the return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the successor in the entire tree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    /*
      first check to see if there is a right subtree to the input link
      if there is then the real successor is the left most node in
      the right subtree.  That is find and return P in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  P
                   \
    */

    if ((Ptr = RtlRightChild(Links)) != NULL) {

        while (RtlLeftChild(Ptr) != NULL) {
            Ptr = RtlLeftChild(Ptr);
        }

        return Ptr;

    }

    /*
      we do not have a right child so check to see if have a parent and if
      so find the first ancestor that we are a left descendent of. That
      is find and return P in the following diagram

                       P
                      /
                     .
                      .
                       .
                      Links
    */

    Ptr = Links;
    while (RtlIsRightChild(Ptr)) {
        Ptr = RtlParent(Ptr);
    }

    if (RtlIsLeftChild(Ptr)) {
        return RtlParent(Ptr);
    }

    //
    //  otherwise we are do not have a real successor so we simply return
    //  NULL
    //

    return NULL;

}


PRTL_SPLAY_LINKS
RtlRealPredecessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The RealPredecessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the predecessor of the input node
    within the entire tree.  If there is not a predecessor, the return value
    is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the predecessor in the entire tree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    /*
      first check to see if there is a left subtree to the input link
      if there is then the real predecessor is the right most node in
      the left subtree.  That is find and return P in the following diagram

                  Links
                   /
                  .
                   .
                    .
                     P
                    /
    */

    if ((Ptr = RtlLeftChild(Links)) != NULL) {

        while (RtlRightChild(Ptr) != NULL) {
            Ptr = RtlRightChild(Ptr);
        }

        return Ptr;

    }

    /*
      we do not have a left child so check to see if have a parent and if
      so find the first ancestor that we are a right descendent of. That
      is find and return P in the following diagram

                       P
                        \
                         .
                        .
                       .
                    Links
    */

    Ptr = Links;
    while (RtlIsLeftChild(Ptr)) {
        Ptr = RtlParent(Ptr);
    }

    if (RtlIsRightChild(Ptr)) {
        return RtlParent(Ptr);
    }

    //
    //  otherwise we are do not have a real predecessor so we simply return
    //  NULL
    //

    return NULL;

}


VOID
SwapSplayLinks (
    IN PRTL_SPLAY_LINKS Link1,
    IN PRTL_SPLAY_LINKS Link2
    )

{
    PRTL_SPLAY_LINKS *Parent1ChildPtr;
    PRTL_SPLAY_LINKS *Parent2ChildPtr;

    /*
      We have the following situation


             Parent1            Parent2
                |                  |
                |                  |
              Link1              Link2
               / \                / \
              /   \              /   \
            LC1   RC1          LC2   RC2

      where one of the links can possibly be the root and one of the links
      can possibly be a direct child of the other.  Without loss of
      generality we'll make link2 be the possible and root and link1 be
      the possible child.
    */

    if ((RtlIsRoot(Link1)) || (RtlParent(Link2) == Link1)) {
        SwapPointers(Link1, Link2);
    }

    //
    //  The four cases we need to handle are
    //
    //  1. Link1 is not a child of link2 and link2 is not the root
    //  2. Link1 is not a child of link2 and link2 is     the root
    //  3. Link1 is     a child of link2 and link2 is not the root
    //  4. Link1 is     a child of link2 and link2 is     the root
    //
    //
    //  Each case will be handled separately
    //

    if (RtlParent(Link1) != Link2) {

        if (!RtlIsRoot(Link2)) {

            //
            //  Case 1 the initial steps are:
            //
            //  1. get both parent child pointers
            //  2. swap the parent child pointers
            //  3. swap the parent pointers
            //

            Parent1ChildPtr = ParentsChildPointerAddress(Link1);
            Parent2ChildPtr = ParentsChildPointerAddress(Link2);

            SwapPointers(*Parent1ChildPtr, *Parent2ChildPtr);

            SwapPointers(Link1->Parent, Link2->Parent);

        } else {

            //
            //  Case 2 the initial steps are:
            //
            //  1. Set link1's parent child pointer to link2
            //  2. Set parent pointer of link2 to link1's parent
            //  3. Set parent pointer of link1 to be itself
            //

            Parent1ChildPtr = ParentsChildPointerAddress(Link1);
            *Parent1ChildPtr = Link2;

            Link2->Parent = Link1->Parent;

            Link1->Parent = Link1;

        }

        //
        //  Case 1 and 2 common steps are:
        //
        //  1. swap the child pointers
        //

        SwapPointers(Link1->LeftChild, Link2->LeftChild);
        SwapPointers(Link1->RightChild, Link2->RightChild);

    } else { // RtlParent(Link1) == Link2

        if (!RtlIsRoot(Link2)) {

            //
            //  Case 3 the initial steps are:
            //
            //  1. Set Link2's parent child pointer to link1
            //  2. Set Link1's parent pointer to parent of link2
            //

            Parent2ChildPtr = ParentsChildPointerAddress(Link2);
            *Parent2ChildPtr = Link1;

            Link1->Parent = Link2->Parent;

        } else {

            //
            //  Case 4 the initial steps are:
            //
            //  1. Set Link1's parent pointer to be link1
            //

            Link1->Parent = Link1;

        }

        //
        //  Case 3 and 4 common steps are:
        //
        //  1. Swap the child pointers
        //  2. if link1 was a left child (i.e., RtlLeftChild(Link1) == Link1)
        //     then set left child of link1 to link2
        //     else set right child of link1 to link2
        //

        SwapPointers(Link1->LeftChild, Link2->LeftChild);
        SwapPointers(Link1->RightChild, Link2->RightChild);

        if (Link1->LeftChild == Link1) {
            Link1->LeftChild = Link2;
        } else {
            Link1->RightChild = Link2;
        }

    }

    //
    //  Case 1, 2, 3, 4 common (and final) steps are:
    //
    //  1. Fix the parent pointers of the left and right children
    //

    if (Link1->LeftChild  != NULL) {Link1->LeftChild->Parent  = Link1;}
    if (Link1->RightChild != NULL) {Link1->RightChild->Parent = Link1;}
    if (Link2->LeftChild  != NULL) {Link2->LeftChild->Parent  = Link2;}
    if (Link2->RightChild != NULL) {Link2->RightChild->Parent = Link2;}
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\str2addw.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
//
// You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

// Without this define, link errors can occur due to missing _pctype and
// __mb_cur_max
//
#define _CTYPE_DISABLE_MACROS

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <stdlib.h>
#include <tchar.h>

#define RtlIpv4StringToAddressT RtlIpv4StringToAddressW
#define RtlIpv6StringToAddressT RtlIpv6StringToAddressW
#define RtlIpv4StringToAddressExT RtlIpv4StringToAddressExW
#define RtlIpv6StringToAddressExT RtlIpv6StringToAddressExW

#include "str2addt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\str2addt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    str2addt.h

Abstract:

    Code file for IP string-to-address translation routines.

--*/

struct in6_addr {
    union {
        UCHAR Byte[16];
        USHORT Word[8];
    } u;
};
#define s6_bytes   u.Byte
#define s6_words   u.Word

struct in_addr {
        union {
                struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { USHORT s_w1,s_w2; } S_un_w;
                ULONG S_addr;
        } S_un;
};
#define s_addr  S_un.S_addr

//
// Define some versions of crt functions which are not affected by locale.
//
#define ISDIGIT(c)  (_istascii(c) && _istdigit(c))
#define ISLOWER(c)  (_istascii(c) && _istlower(c))
#define ISXDIGIT(c) (_istascii(c) && _istxdigit(c))

#define INADDR_NONE 0xffffffff

NTSTATUS
RtlIpv6StringToAddressT(
    IN LPCTSTR S,
    OUT LPCTSTR *Terminator,
    OUT struct in6_addr *Addr
    )

/*++

Routine Description:

    Parses the string S as an IPv6 address. See RFC 1884.
    The basic string representation consists of 8 hex numbers
    separated by colons, with a couple embellishments:
    - a string of zero numbers (at most one) may be replaced
    with a double-colon. Double-colons are allowed at beginning/end
    of the string.
    - the last 32 bits may be represented in IPv4-style dotted-octet notation.

    For example,
        ::
        ::1
        ::157.56.138.30
        ::ffff:156.56.136.75
        ff01::
        ff02::2
        0:1:2:3:4:5:6:7

Arguments:

    S - RFC 1884 string representation of an IPv6 address.

    Terminator - Receives a pointer to the character that terminated
        the conversion.

    Addr - Receives the IPv6 address.

Return Value:

    TRUE if parsing was successful. FALSE otherwise.

--*/

{
    enum { Start, InNumber, AfterDoubleColon } state = Start;
    const TCHAR *number = NULL;
    BOOLEAN sawHex;
    ULONG numColons = 0, numDots = 0, numDigits = 0;
    ULONG sawDoubleColon = 0;
    ULONG i = 0;
    TCHAR c;

    // There are a several difficulties here. For one, we don't know
    // when we see a double-colon how many zeroes it represents.
    // So we just remember where we saw it and insert the zeroes
    // at the end. For another, when we see the first digits
    // of a number we don't know if it is hex or decimal. So we
    // remember a pointer to the first character of the number
    // and convert it after we see the following character.

    while (c = *S) {

        switch (state) {
        case Start:
            if (c == _T(':')) {

                // this case only handles double-colon at the beginning

                if (numDots > 0)
                    goto Finish;
                if (numColons > 0)
                    goto Finish;
                if (S[1] != _T(':'))
                    goto Finish;

                sawDoubleColon = 1;
                numColons = 2;
                Addr->s6_words[i++] = 0; // pretend it was 0::
                S++;
                state = AfterDoubleColon;

            } else
        case AfterDoubleColon:
            if (ISDIGIT(c)) {

                sawHex = FALSE;
                number = S;
                state = InNumber;
                numDigits = 1;

            } else if (ISXDIGIT(c)) {

                if (numDots > 0)
                    goto Finish;

                sawHex = TRUE;
                number = S;
                state = InNumber;
                numDigits = 1;

            } else
                goto Finish;
            break;

        case InNumber:
            if (ISDIGIT(c)) {

                numDigits++;

                // remain in InNumber state

            } else if (ISXDIGIT(c)) {

                numDigits++;

                if (numDots > 0)
                    goto Finish;

                sawHex = TRUE;
                // remain in InNumber state;

            } else if (c == _T(':')) {

                if (numDots > 0)
                    goto Finish;
                if (numColons > 6)
                    goto Finish;

                if (S[1] == _T(':')) {

                    if (sawDoubleColon)
                        goto Finish;
                    if (numColons > 5)
                        goto Finish;

                    sawDoubleColon = numColons+1;
                    numColons += 2;
                    S++;
                    state = AfterDoubleColon;

                } else {
                    numColons++;
                    state = Start;
                }

            } else if (c == _T('.')) {

                if (sawHex)
                    goto Finish;
                if (numDots > 2)
                    goto Finish;
                if (numColons > 6)
                    goto Finish;
                numDots++;
                state = Start;

            } else
                goto Finish;
            break;
        }

        // If we finished a number, parse it.

        if ((state != InNumber) && (number != NULL)) {

            // Note either numDots > 0 or numColons > 0,
            // because something terminated the number.

            if (numDots == 0) {
                if (numDigits > 4)
                    return STATUS_INVALID_PARAMETER;
                Addr->s6_words[i++] =
                    RtlUshortByteSwap((USHORT) _tcstol(number, NULL, 16));
            } else {
                ULONG Temp;
                if (numDigits > 3)
                    return STATUS_INVALID_PARAMETER;
                Temp = _tcstol(number, NULL, 10);
                if (Temp > 255) 
                    return STATUS_INVALID_PARAMETER;
                Addr->s6_bytes[2*i + numDots-1] = (UCHAR) Temp;
            }
        }

        S++;
    }

Finish:
    *Terminator = S;

    // Check that we have a complete address.

    if (numDots == 0)
        ;
    else if (numDots == 3)
        numColons++;
    else
        return STATUS_INVALID_PARAMETER;

    if (sawDoubleColon)
        ;
    else if (numColons == 7)
        ;
    else
        return STATUS_INVALID_PARAMETER;

    // Parse the last number, if necessary.

    if (state == InNumber) {

        if (numDots == 0) {
            if (numDigits > 4)
                return STATUS_INVALID_PARAMETER;
            Addr->s6_words[i] =
                RtlUshortByteSwap((USHORT) _tcstol(number, NULL, 16));
        } else {
            ULONG Temp;
            if (numDigits > 3)
                return STATUS_INVALID_PARAMETER;
            Temp = _tcstol(number, NULL, 10);
            if (Temp > 255) 
                return STATUS_INVALID_PARAMETER;
            Addr->s6_bytes[2*i + numDots] = (UCHAR) Temp;
        }

    } else if (state == AfterDoubleColon) {

        Addr->s6_words[i] = 0; // pretend it was ::0

    } else
        return STATUS_INVALID_PARAMETER;

    // Insert zeroes for the double-colon, if necessary.

    if (sawDoubleColon) {

        RtlMoveMemory(&Addr->s6_words[sawDoubleColon + 8 - numColons],
                      &Addr->s6_words[sawDoubleColon],
                      (numColons - sawDoubleColon) * sizeof(USHORT));
        RtlZeroMemory(&Addr->s6_words[sawDoubleColon],
                      (8 - numColons) * sizeof(USHORT));
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlIpv6StringToAddressExT (
    IN LPCTSTR AddressString,
    OUT struct in6_addr *Address,
    OUT PULONG ScopeId,
    OUT PUSHORT Port
    )

/*++

Routine Description:

    Parsing a human-readable string to Address, port number and scope id. 

    The syntax is address%scope-id or [address%scope-id]:port, where 
    the scope-id and port are optional.
    Note that since the IPv6 address format uses a varying number
    of ':' characters, the IPv4 convention of address:port cannot
    be supported without the braces.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    Address - Receive address part (in6_addr) of this address.

    ScopeId - Receive scopeid of this address. If there is no scope id in
             the address string, 0 is returned. 

    Port - Receive port number of this address. If there is no port number 
          in the string, 0 is returned. Port is returned in network byte order.

Return Value:

    NT_STATUS - STATUS_SUCCESS if successful, NT error code if not.

--*/

{
    LPTSTR Terminator;
    ULONG TempScopeId;
    USHORT TempPort;
    TCHAR Ch;
    BOOLEAN ExpectBrace;

    //
    // Quick sanity checks.
    //
    if ((AddressString == NULL) ||
        (Address == NULL) ||
        (ScopeId == NULL) ||
        (Port == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    TempPort = 0;
    TempScopeId = 0;
    ExpectBrace = FALSE;
    if (*AddressString == _T('[')) {
        ExpectBrace = TRUE;
        AddressString++;
    }

    if (!NT_SUCCESS(RtlIpv6StringToAddressT(AddressString, 
                                            &Terminator, 
                                            Address))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // We have parsed the address, check for a scope-id.
    //
    if (*Terminator == _T('%')) {
        Terminator++;
        Ch = *Terminator;
        if (!ISDIGIT(Ch)) {
            return STATUS_INVALID_PARAMETER;
        }
        while ((Ch != 0) && (Ch != _T(']'))) {
            if (!ISDIGIT(Ch)) {
                return STATUS_INVALID_PARAMETER;
            }
            //
            // first check the possibility of overflow
            //
            if (((ULONGLONG)TempScopeId * 10 + Ch - _T('0')) >  
                0xFFFFFFFF) {
                return STATUS_INVALID_PARAMETER;
            }
            TempScopeId = 10 * TempScopeId + (Ch - _T('0'));
            Terminator++;
            Ch = *Terminator;
        }
        
    }

    //
    // When we come here, the current char should either be the
    // end of the string or ']' if expectbrace is true. 
    //
    if (*Terminator == _T(']')) {
        if (!ExpectBrace) {
            return STATUS_INVALID_PARAMETER;
        }
        ExpectBrace = FALSE;
        Terminator++;
        //
        // See if we have a port to parse.
        //
        if (*Terminator == _T(':')) {
            USHORT Base;
            Terminator++;
            Base = 10;
            if (*Terminator == _T('0')) {
                Base = 8;
                Terminator++;         
                if ((*Terminator == _T('x')) || 
                    (*Terminator == _T('X'))) {
                    Base = 16;
                    Terminator++;
                }
            }
            Ch = *Terminator;
            while (Ch != 0) {
                if (ISDIGIT(Ch) && (Ch - _T('0')) < Base) {
                    //
                    // check the possibility for overflow first
                    //
                    if (((ULONG)TempPort * Base + Ch - _T('0')) >  
                         0xFFFF) {
                        return STATUS_INVALID_PARAMETER; 
                    }
                    TempPort = (TempPort * Base) + (Ch - _T('0'));
                } else if (Base == 16 && ISXDIGIT(Ch)) {
                    //
                    // check the possibility for overflow
                    //
                    if ((((ULONG)TempPort << 4) + Ch + 10 - 
                        (ISLOWER(Ch)? _T('a') : _T('A'))) > 0xFFFF) {
                        return STATUS_INVALID_PARAMETER;
                    }
                    TempPort = (TempPort << 4);
                    TempPort += Ch + 10 - (ISLOWER(Ch)? _T('a') : _T('A')); 
                } else {
                    return STATUS_INVALID_PARAMETER;
                }
                Terminator++;
                Ch = *Terminator;
            }
        }       
    }

    //
    // We finished parsing address, scope id and port number. We are expecting the
    // end of the string. 
    //
    if ((*Terminator != 0) || ExpectBrace) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Now construct the address.
    //
    *Port = RtlUshortByteSwap(TempPort);
    *ScopeId = TempScopeId;
    return STATUS_SUCCESS;
} 

NTSTATUS
RtlIpv4StringToAddressT(
    IN LPCTSTR String,
    IN BOOLEAN Strict,
    OUT LPCTSTR *Terminator,
    OUT struct in_addr *Addr
    )

/*++

Routine Description:

    This function interprets the character string specified by the cp
    parameter.  This string represents a numeric Internet address
    expressed in the Internet standard ".'' notation.  The value
    returned is a number suitable for use as an Internet address.  All
    Internet addresses are returned in network order (bytes ordered from
    left to right).

    Internet Addresses

    Values specified using the "." notation take one of the following
    forms:

    a.b.c.d   a.b.c     a.b  a

    When four parts are specified, each is interpreted as a byte of data
    and assigned, from left to right, to the four bytes of an Internet
    address.  Note that when an Internet address is viewed as a 32-bit
    integer quantity on the Intel architecture, the bytes referred to
    above appear as "d.c.b.a''.  That is, the bytes on an Intel
    processor are ordered from right to left.

    Note: The following notations are only used by Berkeley, and nowhere
    else on the Internet.  In the interests of compatibility with their
    software, they are supported as specified.

    When a three part address is specified, the last part is interpreted
    as a 16-bit quantity and placed in the right most two bytes of the
    network address.  This makes the three part address format
    convenient for specifying Class B network addresses as
    "128.net.host''.

    When a two part address is specified, the last part is interpreted
    as a 24-bit quantity and placed in the right most three bytes of the
    network address.  This makes the two part address format convenient
    for specifying Class A network addresses as "net.host''.

    When only one part is given, the value is stored directly in the
    network address without any byte rearrangement.

Arguments:

    String - A character string representing a number expressed in the
        Internet standard "." notation.

    Strict - If TRUE, the string must be dotted-decimal with 4 parts.
             Otherwise, any of the four forms are allowed, with decimal,
             octal, or hex.

    Terminator - Receives a pointer to the character that terminated
        the conversion.

    Addr - Receives a pointer to the structure to fill in with
        a suitable binary representation of the Internet address given. 

Return Value:

    TRUE if parsing was successful. FALSE otherwise.

--*/

{
    ULONG val, n;
    LONG base;
    TCHAR c;
    ULONG parts[4], *pp = parts;
    BOOLEAN sawDigit;

again:
    //
    // We must see at least one digit for address to be valid.
    //
    sawDigit=FALSE; 

    //
    // Collect number up to ``.''.
    // Values are specified as for C:
    // 0x=hex, 0=octal, other=decimal.
    //
    val = 0; 
    base = 10;
    if (*String == _T('0')) {
        String++;
        if (ISDIGIT(*String)) {
            base = 8;
        } else if (*String == _T('x') || *String == _T('X')) {
            base = 16;
            String++;
        } else {
            //
            // It is still decimal but we saw the digit
            // and it was 0.
            //
            sawDigit = TRUE;
        }
    }
    if (Strict && (base != 10)) {
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }

    while ((c = *String)!= 0) {
        ULONG newVal;
        if (ISDIGIT(c) && ((c - _T('0')) < base)) {
            newVal = (val * base) + (c - _T('0'));
        } else if ((base == 16) && ISXDIGIT(c)) {
            newVal = (val << 4) + (c + 10 - (ISLOWER(c) ? _T('a') : _T('A')));
        } else {
            break;
        }

        //
        // Protect from overflow
        //
        if (newVal < val) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        String++;
        sawDigit = TRUE;
        val = newVal;
    }
    if (*String == _T('.')) {
        //
        // Internet format:
        //      a.b.c.d
        //      a.b.c   (with c treated as 16-bits)
        //      a.b     (with b treated as 24 bits)
        //
        if (pp >= parts + 3) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        *pp++ = val, String++;

        //
        // Check if we saw at least one digit.
        //
        if (!sawDigit) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }

        goto again;
    }

    //
    // Check if we saw at least one digit.
    //
    if (!sawDigit) {
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }
    *pp++ = val;

    //
    // Concoct the address according to
    // the number of parts specified.
    //
    n = (ULONG)(pp - parts);
    if (Strict && (n != 4)) {
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }
    switch ((int) n) {

    case 1:                         /* a -- 32 bits */
        val = parts[0];
        break;

    case 2:                         /* a.b -- 8.24 bits */
        if ((parts[0] > 0xff) || (parts[1] > 0xffffff)) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        val = (parts[0] << 24) | (parts[1] & 0xffffff);
        break;

    case 3:                         /* a.b.c -- 8.8.16 bits */
        if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
            (parts[2] > 0xffff)) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                (parts[2] & 0xffff);
        break;

    case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
        if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
            (parts[2] > 0xff) || (parts[3] > 0xff)) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
              ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
        break;

    default:
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }

    val = RtlUlongByteSwap(val);
    *Terminator = String;
    Addr->s_addr = val;

    return STATUS_SUCCESS;
}


NTSTATUS
RtlIpv4StringToAddressExT (
    IN LPCTSTR AddressString,
    IN BOOLEAN Strict,
    OUT struct in_addr *Address,
    OUT PUSHORT Port
    )

/*++

Routine Description:

    Parsing a human-readable string to in_addr and port number.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    Strict - If TRUE, the address portion must be dotted-decimal with 4 parts.
             Otherwise, any of the four forms are allowed, with decimal,
             octal, or hex.

    Address - Receives the address (in_addr) itself.

    Port - Receives port number. 0 is returned if there is no port number.
           Port is returned in network byte order.  

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful, error code if not.

--*/

{
    LPTSTR Terminator;
    USHORT TempPort;
    
    if ((AddressString == NULL) ||
        (Address == NULL) ||
        (Port == NULL)) { 
        return STATUS_INVALID_PARAMETER;
    }

    if (!NT_SUCCESS(RtlIpv4StringToAddressT(AddressString, 
                                            Strict, 
                                            &Terminator, 
                                            Address))) {
        return STATUS_INVALID_PARAMETER;
    }
    
    if (*Terminator == _T(':')) {
        TCHAR Ch;
        USHORT Base;
        BOOLEAN ExpectPort = TRUE;
        Terminator++;
        TempPort = 0;
        Base = 10;
        if (*Terminator == _T('0')) {
            Base = 8;
            Terminator++;
            if ((*Terminator == _T('x')) || (*Terminator == _T('X'))) {
                Base = 16;
                Terminator++;
            }
        }
        if (Ch = *Terminator) {
            ExpectPort = FALSE;
        }
        while (Ch = *Terminator++) {
            if (ISDIGIT(Ch) && (USHORT)(Ch-_T('0')) < Base) {
                //
                // Check the possibility for overflow
                //
                if (((ULONG)TempPort * Base + Ch - _T('0')) > 0xFFFF) {
                    return STATUS_INVALID_PARAMETER;
                }
                TempPort = (TempPort * Base) + (Ch - _T('0'));
            } else if (Base == 16 && ISXDIGIT(Ch)) {
                //
                // Check the possibility for overflow first
                //
                if ((((ULONG)TempPort << 4) + Ch + 10 -  
                    (ISLOWER(Ch) ? _T('a') : _T('A')))
                    > 0xFFFF) {
                    return STATUS_INVALID_PARAMETER;
                }
                TempPort = TempPort << 4;
                TempPort += Ch + 10 - (ISLOWER(Ch) ? _T('a') : _T('A'));
            } else {
                return STATUS_INVALID_PARAMETER;
            }
        }
        if (ExpectPort) {
            return STATUS_INVALID_PARAMETER;
        }
    } else if (*Terminator == 0) {
        TempPort = 0;
    } else {
        return STATUS_INVALID_PARAMETER;
    }
    *Port = RtlUshortByteSwap(TempPort);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\sertl.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    sertl.c

Abstract:

    This Module implements many security rtl routines defined in ntseapi.h

--*/


#include "ntrtlp.h"
#include <winerror.h>
#include <stdio.h>
#include "seopaque.h"
#include "sertlp.h"
#include <..\se\sep.h>

#undef RtlEqualLuid

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualLuid (
    PLUID Luid1,
    PLUID Luid2
    );

NTSTATUS
RtlpConvertAclToAutoInherit (
    IN PACL ParentAcl OPTIONAL,
    IN PACL ChildAcl,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PACL *NewAcl,
    OUT PULONG NewGenericControl
    );

BOOLEAN
RtlpCopyEffectiveAce (
    IN PACE_HEADER OldAce,
    IN BOOLEAN AutoInherit,
    IN BOOLEAN WillGenerateInheritAce,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN OUT PVOID *AcePosition,
    OUT PULONG NewAceLength,
    OUT PACL NewAcl,
    OUT PBOOLEAN ObjectAceInherited OPTIONAL,
    OUT PBOOLEAN EffectiveAceMapped,
    OUT PBOOLEAN AclOverflowed
    );

typedef enum {
     CopyInheritedAces,
     CopyNonInheritedAces,
     CopyAllAces } ACE_TYPE_TO_COPY;

NTSTATUS
RtlpCopyAces(
    IN PACL Acl,
    IN PGENERIC_MAPPING GenericMapping,
    IN ACE_TYPE_TO_COPY AceTypeToCopy,
    IN UCHAR AceFlagsToReset,
    IN BOOLEAN MapSids,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN RetainInheritedAceBit,
    OUT PULONG NewAclSizeParam,
    OUT PACL NewAcl
    );

NTSTATUS
RtlpGenerateInheritedAce (
    IN PACE_HEADER OldAce,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    OUT PULONG NewAceLength,
    OUT PACL NewAcl,
    OUT PULONG NewAceExtraLength,
    OUT PBOOLEAN ObjectAceInherited
    );

NTSTATUS
RtlpGenerateInheritAcl(
    IN PACL Acl,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    OUT PULONG NewAclSizeParam,
    OUT PACL NewAcl,
    OUT PBOOLEAN ObjectAceInherited
    );

NTSTATUS
RtlpInheritAcl2 (
    IN PACL DirectoryAcl,
    IN PACL ChildAcl,
    IN ULONG ChildGenericControl,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN BOOLEAN DefaultDescriptorForObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN PULONG AclBufferSize,
    IN OUT PUCHAR AclBuffer,
    OUT PBOOLEAN NewAclExplicitlyAssigned,
    OUT PULONG NewGenericControl
    );

NTSTATUS
RtlpComputeMergedAcl (
    IN PACL CurrentAcl,
    IN ULONG CurrentGenericControl,
    IN PACL ModificationAcl,
    IN ULONG ModificationGenericControl,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    OUT PACL *NewAcl,
    OUT PULONG NewGenericControl
    );

NTSTATUS
RtlpComputeMergedAcl2 (
    IN PACL CurrentAcl,
    IN ULONG CurrentGenericControl,
    IN PACL ModificationAcl,
    IN ULONG ModificationGenericControl,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    IN PULONG AclBufferSize,
    IN OUT PUCHAR AclBuffer,
    OUT PULONG NewGenericControl
    );

BOOLEAN
RtlpCompareAces(
    IN PKNOWN_ACE InheritedAce,
    IN PKNOWN_ACE ChildAce,
    IN PSID OwnerSid,
    IN PSID GroupSid
    );

BOOLEAN
RtlpCompareKnownObjectAces(
    IN PKNOWN_OBJECT_ACE InheritedAce,
    IN PKNOWN_OBJECT_ACE ChildAce,
    IN PSID OwnerSid OPTIONAL,
    IN PSID GroupSid OPTIONAL
    );

BOOLEAN
RtlpCompareKnownAces(
    IN PKNOWN_ACE InheritedAce,
    IN PKNOWN_ACE ChildAce,
    IN PSID OwnerSid OPTIONAL,
    IN PSID GroupSid OPTIONAL
    );

BOOLEAN
RtlpIsDuplicateAce(
    IN PACL Acl,
    IN PKNOWN_ACE NewAce
    );

BOOLEAN
RtlpGuidPresentInGuidList(
    IN GUID *InheritedObjectType,
    IN GUID **pNewObjectType,
    IN ULONG GuidCount
    );

NTSTATUS
RtlpCreateServerAcl(
    IN PACL Acl,
    IN BOOLEAN AclUntrusted,
    IN PSID ServerSid,
    OUT PACL *ServerAcl,
    OUT BOOLEAN *ServerAclAllocated
    );

NTSTATUS
RtlpGetDefaultsSubjectContext(
    HANDLE ClientToken,
    OUT PTOKEN_OWNER *OwnerInfo,
    OUT PTOKEN_PRIMARY_GROUP *GroupInfo,
    OUT PTOKEN_DEFAULT_DACL *DefaultDaclInfo,
    OUT PTOKEN_OWNER *ServerOwner,
    OUT PTOKEN_PRIMARY_GROUP *ServerGroup
    );

BOOLEAN RtlpValidateSDOffsetAndSize (
    IN ULONG   Offset,
    IN ULONG   Length,
    IN ULONG   MinLength,
    OUT PULONG MaxLength
    );

BOOLEAN
RtlValidRelativeSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    );

NTSTATUS
RtlpImpersonateSelfEx (
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN ACCESS_MASK AdditionalAccess,
    OUT PHANDLE ThreadToken OPTIONAL
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,RtlRunEncodeUnicodeString)
#pragma alloc_text(PAGE,RtlRunDecodeUnicodeString)
#pragma alloc_text(PAGE,RtlEraseUnicodeString)
#pragma alloc_text(PAGE,RtlAdjustPrivilege)
#pragma alloc_text(PAGE,RtlValidSid)
#pragma alloc_text(PAGE,RtlEqualSid)
#pragma alloc_text(PAGE,RtlEqualPrefixSid)
#pragma alloc_text(PAGE,RtlLengthRequiredSid)
#pragma alloc_text(PAGE,RtlInitializeSid)
#pragma alloc_text(PAGE,RtlIdentifierAuthoritySid)
#pragma alloc_text(PAGE,RtlSubAuthoritySid)
#pragma alloc_text(PAGE,RtlSubAuthorityCountSid)
#pragma alloc_text(PAGE,RtlLengthSid)
#pragma alloc_text(PAGE,RtlCopySid)
#pragma alloc_text(PAGE,RtlCopySidAndAttributesArray)
#pragma alloc_text(PAGE,RtlLengthSidAsUnicodeString)
#pragma alloc_text(PAGE,RtlConvertSidToUnicodeString)
#pragma alloc_text(PAGE,RtlEqualLuid)
#pragma alloc_text(PAGE,RtlCopyLuid)
#pragma alloc_text(PAGE,RtlCopyLuidAndAttributesArray)
#pragma alloc_text(PAGE,RtlCreateSecurityDescriptor)
#pragma alloc_text(PAGE,RtlCreateSecurityDescriptorRelative)
#pragma alloc_text(PAGE,RtlValidSecurityDescriptor)
#pragma alloc_text(PAGE,RtlLengthSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetAttributesSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetControlSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetControlSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetDaclSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetDaclSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetSaclSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetSaclSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetOwnerSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetOwnerSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetGroupSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetGroupSecurityDescriptor)
#pragma alloc_text(PAGE,RtlAreAllAccessesGranted)
#pragma alloc_text(PAGE,RtlAreAnyAccessesGranted)
#pragma alloc_text(PAGE,RtlMapGenericMask)
#pragma alloc_text(PAGE,RtlpImpersonateSelfEx)
#pragma alloc_text(PAGE,RtlImpersonateSelf)
#pragma alloc_text(PAGE,RtlpApplyAclToObject)
#pragma alloc_text(PAGE,RtlpCopyEffectiveAce)
#pragma alloc_text(PAGE,RtlpCopyAces)
#pragma alloc_text(PAGE,RtlpGuidPresentInGuidList)
#pragma alloc_text(PAGE,RtlpInheritAcl2)
#pragma alloc_text(PAGE,RtlpInheritAcl)
#pragma alloc_text(PAGE,RtlpGenerateInheritedAce)
#pragma alloc_text(PAGE,RtlpGenerateInheritAcl)
#pragma alloc_text(PAGE,RtlpComputeMergedAcl2)
#pragma alloc_text(PAGE,RtlpComputeMergedAcl)
#pragma alloc_text(PAGE,RtlpConvertToAutoInheritSecurityObject)
#pragma alloc_text(PAGE,RtlpCompareAces)
#pragma alloc_text(PAGE,RtlpCompareKnownAces)
#pragma alloc_text(PAGE,RtlpCompareKnownObjectAces)
#pragma alloc_text(PAGE,RtlpConvertAclToAutoInherit)
#pragma alloc_text(PAGE,RtlpIsDuplicateAce)
#pragma alloc_text(PAGE,RtlpCreateServerAcl)
#pragma alloc_text(PAGE,RtlpNewSecurityObject)
#pragma alloc_text(PAGE,RtlpSetSecurityObject)
#pragma alloc_text(PAGE,RtlpValidateSDOffsetAndSize)
#pragma alloc_text(PAGE,RtlValidRelativeSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetSecurityDescriptorRMControl)
#pragma alloc_text(PAGE,RtlSetSecurityDescriptorRMControl)
#endif


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Local Macros and Symbols                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#define CREATOR_SID_SIZE 12

#define max(a,b)            (((a) > (b)) ? (a) : (b))

//
// Define an array mapping all ACE types to their base type.
//
// For instance, all allowed ACE types are similar.  As are all denied ACE types.
//

#if defined(ALLOC_DATA_PRAGMA)
#pragma const_seg("PAGECONST")
#endif

const UCHAR RtlBaseAceType[] = {
    ACCESS_ALLOWED_ACE_TYPE,    // ACCESS_ALLOWED_ACE_TYPE (0x0)
    ACCESS_DENIED_ACE_TYPE,     // ACCESS_DENIED_ACE_TYPE (0x1)
    SYSTEM_AUDIT_ACE_TYPE,      // SYSTEM_AUDIT_ACE_TYPE (0x2)
    SYSTEM_ALARM_ACE_TYPE,      // SYSTEM_ALARM_ACE_TYPE (0x3)
    ACCESS_ALLOWED_ACE_TYPE,    // ACCESS_ALLOWED_COMPOUND_ACE_TYPE (0x4)
    ACCESS_ALLOWED_ACE_TYPE,    // ACCESS_ALLOWED_OBJECT_ACE_TYPE (0x5)
    ACCESS_DENIED_ACE_TYPE,     // ACCESS_DENIED_OBJECT_ACE_TYPE (0x6)
    SYSTEM_AUDIT_ACE_TYPE,      // SYSTEM_AUDIT_OBJECT_ACE_TYPE (0x7)
    SYSTEM_ALARM_ACE_TYPE       // SYSTEM_ALARM_OBJECT_ACE_TYPE (0x8)
};

//
// Define an array defining whether an ACE is a system ACE
//

const UCHAR RtlIsSystemAceType[] = {
    FALSE,    // ACCESS_ALLOWED_ACE_TYPE (0x0)
    FALSE,    // ACCESS_DENIED_ACE_TYPE (0x1)
    TRUE,     // SYSTEM_AUDIT_ACE_TYPE (0x2)
    TRUE,     // SYSTEM_ALARM_ACE_TYPE (0x3)
    FALSE,    // ACCESS_ALLOWED_COMPOUND_ACE_TYPE (0x4)
    FALSE,    // ACCESS_ALLOWED_OBJECT_ACE_TYPE (0x5)
    FALSE,    // ACCESS_DENIED_OBJECT_ACE_TYPE (0x6)
    TRUE,     // SYSTEM_AUDIT_OBJECT_ACE_TYPE (0x7)
    TRUE      // SYSTEM_ALARM_OBJECT_ACE_TYPE (0x8)
};

#if DBG
BOOLEAN RtlpVerboseConvert = FALSE;
#endif // DBG

#define SE_VALID_CONTROL_BITS ( SE_DACL_UNTRUSTED | \
                                SE_SERVER_SECURITY | \
                                SE_DACL_AUTO_INHERIT_REQ | \
                                SE_SACL_AUTO_INHERIT_REQ | \
                                SE_DACL_AUTO_INHERITED | \
                                SE_SACL_AUTO_INHERITED | \
                                SE_DACL_PROTECTED | \
                                SE_SACL_PROTECTED )


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Null DACL assertions                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#if DBG
#define ASSERT_ON_NULL_DACL 1
#endif

#ifdef ASSERT_ON_NULL_DACL
ULONG RtlpAssertOnNullDacls;
#endif // ASSERT_ON_NULL_DACL



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Exported Procedures                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


VOID
RtlRunEncodeUnicodeString(
    PUCHAR          Seed        OPTIONAL,
    PUNICODE_STRING String
    )

/*++

Routine Description:

    This function performs a trivial XOR run-encoding of a string.
    The purpose of this run-encoding is to change the character values
    to appear somewhat random and typically not printable.  This is
    useful for transforming passwords that you don't want to be easily
    distinguishable by visually scanning a paging file or memory dump.


Arguments:

    Seed - Points to a seed value to use in the encoding.  If the
        pointed to value is zero, then this routine will assign
        a value.

    String - The string to encode.  This string may be decode
        by passing it and the seed value to RtlRunDecodeUnicodeString().


Return Value:

    None - Nothing can really go wrong unless the caller passes bogus
        parameters.  In this case, the caller can catch the access
        violation.


--*/
{

    LARGE_INTEGER Time;
    PUCHAR        LocalSeed;
    NTSTATUS      Status;
    ULONG         i;
    PSTRING       S;


    RTL_PAGED_CODE();

    //
    // Typecast so we can work on bytes rather than WCHARs
    //

    S = (PSTRING)((PVOID)String);

    //
    // If a seed wasn't passed, use the 2nd byte of current time.
    // This byte seems to be sufficiently random (by observation).
    //

    if ((*Seed) == 0) {
        Status = NtQuerySystemTime ( &Time );
        ASSERT(NT_SUCCESS(Status));

        LocalSeed = (PUCHAR)((PVOID)&Time);

        i = 1;

        (*Seed) = LocalSeed[ i ];

        //
        // Occasionally, this byte could be zero.  That would cause the
        // string to become un-decodable, since 0 is the magic value that
        // causes us to re-gen the seed.  This loop makes sure that we
        // never end up with a zero byte (unless time is zero, as well).
        //

        while ( ((*Seed) == 0) && ( i < sizeof( Time ) ) )
        {
            (*Seed) |= LocalSeed[ i++ ] ;
        }

        if ( (*Seed) == 0 )
        {
            (*Seed) = 1;
        }
    }

    //
    // Transform the initial byte.
    // The funny constant just keeps the first byte from propagating
    // into the second byte in the next step.  Without a funny constant
    // this would happen for many languages (which typically have every
    // other byte zero.
    //
    //

    if (S->Length >= 1) {
        S->Buffer[0] ^= ((*Seed) | 0X43);
    }


    //
    // Now transform the rest of the string
    //

    for (i=1; i<S->Length; i++) {

        //
        //  There are export issues that cause us to want to
        //  keep this algorithm simple.
        //

        //
        // In order to be compatible with zero terminated unicode strings,
        //  this algorithm is designed to not produce a wide character of
        //  zero as long a the seed is not zero.
        //

        //
        // Simple running XOR with the previous byte and the
        // seed value.
        //

        S->Buffer[i] ^= (S->Buffer[i-1]^(*Seed));

    }


    return;

}


VOID
RtlRunDecodeUnicodeString(
    UCHAR           Seed,
    PUNICODE_STRING String
    )
/*++

Routine Description:

    This function performs the inverse of the function performed
    by RtlRunEncodeUnicodeString().  Please see RtlRunEncodeUnicodeString()
    for details.


Arguments:

    Seed - The seed value to use in RtlRunEncodeUnicodeString().

    String - The string to reveal.


Return Value:

    None - Nothing can really go wrong unless the caller passes bogus
        parameters.  In this case, the caller can catch the access
        violation.


--*/

{

    ULONG
        i;

    PSTRING
        S;

    RTL_PAGED_CODE();

    //
    // Typecast so we can work on bytes rather than WCHARs
    //

    S = (PSTRING)((PVOID)String);


    //
    // Transform the end of the string
    //

    for (i=S->Length; i>1; i--) {

        //
        // a simple running XOR with the previous byte and the
        // seed value.
        //

        S->Buffer[i-1] ^= (S->Buffer[i-2]^Seed);

    }

    //
    // Finally, transform the initial byte
    //

    if (S->Length >= 1) {
        S->Buffer[0] ^= (Seed | 0X43);
    }


    return;
}



VOID
RtlEraseUnicodeString(
    PUNICODE_STRING String
    )
/*++

Routine Description:

    This function scrubs the passed string by over-writing all
    characters in the string.  The entire string (i.e., MaximumLength)
    is erased, not just the current length.


Arguments:

    String - The string to be erased.


Return Value:

    None - Nothing can really go wrong unless the caller passes bogus
        parameters.  In this case, the caller can catch the access
        violation.


--*/

{
    RTL_PAGED_CODE();

    if ((String->Buffer == NULL) || (String->MaximumLength == 0)) {
        return;
    }

    RtlZeroMemory( (PVOID)String->Buffer, (ULONG)String->MaximumLength );

    String->Length = 0;

    return;
}



NTSTATUS
RtlAdjustPrivilege(
    ULONG Privilege,
    BOOLEAN Enable,
    BOOLEAN Client,
    PBOOLEAN WasEnabled
    )

/*++

Routine Description:

    This procedure enables or disables a privilege process-wide.

Arguments:

    Privilege - The lower 32-bits of the privilege ID to be enabled or
        disabled.  The upper 32-bits is assumed to be zero.

    Enable - A boolean indicating whether the privilege is to be enabled
        or disabled.  TRUE indicates the privilege is to be enabled.
        FALSE indicates the privilege is to be disabled.

    Client - A boolean indicating whether the privilege should be adjusted
        in a client token or the process's own token.   TRUE indicates
        the client's token should be used (and an error returned if there
        is no client token).  FALSE indicates the process's token should
        be used.

    WasEnabled - points to a boolean to receive an indication of whether
        the privilege was previously enabled or disabled.  TRUE indicates
        the privilege was previously enabled.  FALSE indicates the privilege
        was previously disabled.  This value is useful for returning the
        privilege to its original state after using it.


Return Value:

    STATUS_SUCCESS - The privilege has been successfully enabled or disabled.

    STATUS_PRIVILEGE_NOT_HELD - The privilege is not held by the specified context.

    Other status values as may be returned by:

            NtOpenProcessToken()
            NtAdjustPrivilegesToken()


--*/

{
    NTSTATUS
        Status,
        TmpStatus;

    HANDLE
        Token;

    LUID
        LuidPrivilege;

    PTOKEN_PRIVILEGES
        NewPrivileges,
        OldPrivileges;

    ULONG
        Length;

    UCHAR
        Buffer1[sizeof(TOKEN_PRIVILEGES)+
                ((1-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES))],
        Buffer2[sizeof(TOKEN_PRIVILEGES)+
                ((1-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES))];


    RTL_PAGED_CODE();

    NewPrivileges = (PTOKEN_PRIVILEGES)Buffer1;
    OldPrivileges = (PTOKEN_PRIVILEGES)Buffer2;

    //
    // Open the appropriate token...
    //

    if (Client == TRUE) {
        Status = NtOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                     FALSE,
                     &Token
                     );
    } else {

        Status = NtOpenProcessToken(
                     NtCurrentProcess(),
                     TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                     &Token
                    );
    }

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Initialize the privilege adjustment structure
    //

    LuidPrivilege = RtlConvertUlongToLuid(Privilege);


    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;



    //
    // Adjust the privilege
    //

    Status = NtAdjustPrivilegesToken(
                 Token,                     // TokenHandle
                 FALSE,                     // DisableAllPrivileges
                 NewPrivileges,             // NewPrivileges
                 sizeof(Buffer1),           // BufferLength
                 OldPrivileges,             // PreviousState (OPTIONAL)
                 &Length                    // ReturnLength
                 );


    TmpStatus = NtClose(Token);
    ASSERT(NT_SUCCESS(TmpStatus));


    //
    // Map the success code NOT_ALL_ASSIGNED to an appropriate error
    // since we're only trying to adjust the one privilege.
    //

    if (Status == STATUS_NOT_ALL_ASSIGNED) {
        Status = STATUS_PRIVILEGE_NOT_HELD;
    }


    if (NT_SUCCESS(Status)) {

        //
        // If there are no privileges in the previous state, there were
        // no changes made. The previous state of the privilege
        // is whatever we tried to change it to.
        //

        if (OldPrivileges->PrivilegeCount == 0) {

            (*WasEnabled) = Enable;

        } else {

            (*WasEnabled) =
                (OldPrivileges->Privileges[0].Attributes & SE_PRIVILEGE_ENABLED)
                ? TRUE : FALSE;
        }
    }

    return(Status);
}


BOOLEAN
RtlValidSid (
    IN PSID Sid
    )

/*++

Routine Description:

    This procedure validates an SID's structure.

Arguments:

    Sid - Pointer to the SID structure to validate.

Return Value:

    BOOLEAN - TRUE if the structure of Sid is valid.

--*/

{
    PISID Isid = (PISID) Sid;
    RTL_PAGED_CODE();
    //
    // Make sure revision is SID_REVISION and sub authority count is not
    // greater than maximum number of allowed sub-authorities.
    //

    try {

        if ( Isid != NULL && (Isid->Revision & 0x0f) == SID_REVISION) {
            if (Isid->SubAuthorityCount <= SID_MAX_SUB_AUTHORITIES) {

                return TRUE;
          }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }

    return FALSE;

}



BOOLEAN
RtlEqualSid (
    IN PSID Sid1,
    IN PSID Sid2
    )

/*++

Routine Description:

    This procedure tests two SID values for equality.

Arguments:

    Sid1, Sid2 - Supply pointers to the two SID values to compare.
        The SID structures are assumed to be valid.

Return Value:

    BOOLEAN - TRUE if the value of Sid1 is equal to Sid2, and FALSE
        otherwise.

--*/

{
   ULONG SidLength;

   C_ASSERT (FIELD_OFFSET (SID, Revision) + sizeof (((SID *)Sid1)->Revision) == FIELD_OFFSET (SID, SubAuthorityCount));
   C_ASSERT (sizeof (((SID *)Sid1)->Revision) + sizeof (((SID *)Sid1)->SubAuthorityCount) == sizeof (USHORT));

   RTL_PAGED_CODE();

   //
   // Make sure they are the same revision. To make this routine faster we make the assumption that
   // the revision and subauthority fields are adjacent.
   //

   if (*(USHORT *)&((SID *)Sid1)->Revision == *(USHORT *)&((SID *)Sid2)->Revision) {
       SidLength = SeLengthSid (Sid1);
       return( (BOOLEAN)RtlEqualMemory( Sid1, Sid2, SidLength) );
   }

   return( FALSE );

}



BOOLEAN
RtlEqualPrefixSid (
    IN PSID Sid1,
    IN PSID Sid2
    )

/*++

Routine Description:

    This procedure tests two SID prefix values for equality.

    An SID prefix is the entire SID except for the last sub-authority
    value.

Arguments:

    Sid1, Sid2 - Supply pointers to the two SID values to compare.
        The SID structures are assumed to be valid.

Return Value:

    BOOLEAN - TRUE if the prefix value of Sid1 is equal to Sid2, and FALSE
        otherwise.

--*/


{
    LONG Index;

    //
    // Typecast to the opaque SID structures.
    //

    SID *ISid1 = Sid1;
    SID *ISid2 = Sid2;

    RTL_PAGED_CODE();

    //
    // Make sure they are the same revision
    //

    if (ISid1->Revision == ISid2->Revision ) {

        //
        // Compare IdentifierAuthority values
        //

        if ( (ISid1->IdentifierAuthority.Value[0] ==
              ISid2->IdentifierAuthority.Value[0])  &&
             (ISid1->IdentifierAuthority.Value[1]==
              ISid2->IdentifierAuthority.Value[1])  &&
             (ISid1->IdentifierAuthority.Value[2] ==
              ISid2->IdentifierAuthority.Value[2])  &&
             (ISid1->IdentifierAuthority.Value[3] ==
              ISid2->IdentifierAuthority.Value[3])  &&
             (ISid1->IdentifierAuthority.Value[4] ==
              ISid2->IdentifierAuthority.Value[4])  &&
             (ISid1->IdentifierAuthority.Value[5] ==
              ISid2->IdentifierAuthority.Value[5])
            ) {

            //
            // Compare SubAuthorityCount values
            //

            if (ISid1->SubAuthorityCount == ISid2->SubAuthorityCount) {

                if (ISid1->SubAuthorityCount == 0) {
                    return TRUE;
                }

                Index = 0;
                while (Index < (ISid1->SubAuthorityCount - 1)) {
                    if ((ISid1->SubAuthority[Index]) != (ISid2->SubAuthority[Index])) {

                        //
                        // Found some SubAuthority values that weren't equal.
                        //

                        return FALSE;
                    }
                    Index += 1;
                }

                //
                // All SubAuthority values are equal.
                //

                return TRUE;
            }
        }
    }

    //
    // Either the Revision, SubAuthorityCount, or IdentifierAuthority values
    // weren't equal.
    //

    return FALSE;
}



ULONG
RtlLengthRequiredSid (
    IN ULONG SubAuthorityCount
    )

/*++

Routine Description:

    This routine returns the length, in bytes, required to store an SID
    with the specified number of Sub-Authorities.

Arguments:

    SubAuthorityCount - The number of sub-authorities to be stored in the SID.

Return Value:

    ULONG - The length, in bytes, required to store the SID.


--*/

{
    RTL_PAGED_CODE();

    return (8L + (4 * SubAuthorityCount));

}


NTSTATUS
RtlInitializeSid(
    IN PSID Sid,
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount
    )
/*++

Routine Description:

    This function initializes an SID data structure.  It does not, however,
    set the sub-authority values.  This must be done separately.

Arguments:

    Sid - Pointer to the SID data structure to initialize.

    IdentifierAuthority - Pointer to the Identifier Authority value to
        set in the SID.

    SubAuthorityCount - The number of sub-authorities that will be placed in
        the SID (a separate action).

Return Value:


--*/
{
    PISID ISid;

    RTL_PAGED_CODE();

    //
    //  Typecast to the opaque SID
    //

    ISid = (PISID)Sid;

    if ( SubAuthorityCount > SID_MAX_SUB_AUTHORITIES ) {
        return( STATUS_INVALID_PARAMETER );
    }

    ISid->SubAuthorityCount = (UCHAR)SubAuthorityCount;
    ISid->Revision = 1;
    ISid->IdentifierAuthority = *IdentifierAuthority;

    return( STATUS_SUCCESS );

}


PSID_IDENTIFIER_AUTHORITY
RtlIdentifierAuthoritySid(
    IN PSID Sid
    )
/*++

Routine Description:

    This function returns the address of an SID's IdentifierAuthority field.

Arguments:

    Sid - Pointer to the SID data structure.

Return Value:


--*/
{
    PISID ISid;

    RTL_PAGED_CODE();

    //
    //  Typecast to the opaque SID
    //

    ISid = (PISID)Sid;

    return &(ISid->IdentifierAuthority);

}

PULONG
RtlSubAuthoritySid(
    IN PSID Sid,
    IN ULONG SubAuthority
    )
/*++

Routine Description:

    This function returns the address of a sub-authority array element of
    an SID.

Arguments:

    Sid - Pointer to the SID data structure.

    SubAuthority - An index indicating which sub-authority is being specified.
        This value is not compared against the number of sub-authorities in the
        SID for validity.

Return Value:


--*/
{
    RTL_PAGED_CODE();

    return RtlpSubAuthoritySid( Sid, SubAuthority );
}

PUCHAR
RtlSubAuthorityCountSid(
    IN PSID Sid
    )
/*++

Routine Description:

    This function returns the address of the sub-authority count field of
    an SID.

Arguments:

    Sid - Pointer to the SID data structure.

Return Value:


--*/
{
    PISID ISid;

    RTL_PAGED_CODE();

    //
    //  Typecast to the opaque SID
    //

    ISid = (PISID)Sid;

    return &(ISid->SubAuthorityCount);

}

ULONG
RtlLengthSid (
    IN PSID Sid
    )

/*++

Routine Description:

    This routine returns the length, in bytes, of a structurally valid SID.

Arguments:

    Sid - Points to the SID whose length is to be returned.  The
        SID's structure is assumed to be valid.

Return Value:

    ULONG - The length, in bytes, of the SID.


--*/

{
    RTL_PAGED_CODE();

    return SeLengthSid(Sid);
}


NTSTATUS
RtlCopySid (
    IN ULONG DestinationSidLength,
    OUT PSID DestinationSid,
    IN PSID SourceSid
    )

/*++

Routine Description:

    This routine copies the value of the source SID to the destination
    SID.

Arguments:

    DestinationSidLength - Indicates the length, in bytes, of the
        destination SID buffer.

    DestinationSid - Pointer to a buffer to receive a copy of the
        source Sid value.

    SourceSid - Supplies the Sid value to be copied.

Return Value:

    STATUS_SUCCESS - Indicates the SID was successfully copied.

    STATUS_BUFFER_TOO_SMALL - Indicates the target buffer wasn't
        large enough to receive a copy of the SID.


--*/

{
    ULONG SidLength = SeLengthSid(SourceSid);

    RTL_PAGED_CODE();

    if (SidLength > DestinationSidLength) {

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    // Buffer is large enough
    //

    RtlMoveMemory( DestinationSid, SourceSid, SidLength );

    return STATUS_SUCCESS;

}


NTSTATUS
RtlCopySidAndAttributesArray (
    IN ULONG ArrayLength,
    IN PSID_AND_ATTRIBUTES Source,
    IN ULONG TargetSidBufferSize,
    OUT PSID_AND_ATTRIBUTES TargetArrayElement,
    OUT PSID TargetSid,
    OUT PSID *NextTargetSid,
    OUT PULONG RemainingTargetSidBufferSize
    )

/*++

Routine Description:

    This routine copies the value of the source SID_AND_ATTRIBUTES array
    to the target.  The actual SID values are placed according to a separate
    parameter.  This allows multiple arrays to be merged using this service
    to copy each.

Arguments:

    ArrayLength - Number of elements in the source array to copy.

    Source - Pointer to the source array.

    TargetSidBufferSize - Indicates the length, in bytes, of the buffer
        to receive the actual SID values.  If this value is less than
        the actual amount needed, then STATUS_BUFFER_TOO_SMALL is returned.

    TargetArrayElement - Indicates where the array elements are to be
        copied to (but not the SID values themselves).

    TargetSid - Indicates where the target SID values s are to be copied.  This
        is assumed to be ULONG aligned.  Each SID value will be copied
        into this buffer.  Each SID will be ULONG aligned.

    NextTargetSid - On completion, will be set to point to the ULONG
        aligned address following the last SID copied.

    RemainingTargetSidBufferSize - On completion, receives an indicatation
        of how much of the SID buffer is still unused.


Return Value:

    STATUS_SUCCESS - The call completed successfully.

    STATUS_BUFFER_TOO_SMALL - Indicates the buffer to receive the SID
        values wasn't large enough.



--*/

{

    ULONG Index = 0;
    PSID NextSid = TargetSid;
    ULONG NextSidLength;
    ULONG AlignedSidLength;
    ULONG RemainingLength = TargetSidBufferSize;

    RTL_PAGED_CODE();

    while (Index < ArrayLength) {

        NextSidLength = SeLengthSid( Source[Index].Sid );
        AlignedSidLength = PtrToUlong(LongAlign(NextSidLength));

        if (NextSidLength > RemainingLength) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        RemainingLength -= AlignedSidLength;

        TargetArrayElement[Index].Sid = NextSid;
        TargetArrayElement[Index].Attributes = Source[Index].Attributes;

        RtlCopySid( NextSidLength, NextSid, Source[Index].Sid );

        NextSid = (PSID)((PCHAR)NextSid + AlignedSidLength);

        Index += 1;

    } //end_while

    (*NextTargetSid) = NextSid;
    (*RemainingTargetSidBufferSize) = RemainingLength;

    return STATUS_SUCCESS;

}



NTSTATUS
RtlLengthSidAsUnicodeString(
    PSID Sid,
    PULONG StringLength
    )

/*++

Routine Description:


    This function returns the maximum length of the string needed
    to represent the SID supplied.  The actual string may be shorter,
    but this is intended to be a quick calculation.

Arguments:


    Sid - Supplies the SID that is to be converted to unicode.

    StringLength - Receives the max length required in bytes.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_INVALID_SID - The sid provided does not have a valid structure,
        or has too many sub-authorities (more than SID_MAX_SUB_AUTHORITIES).

--*/

{
    ULONG   i ;

    PISID   iSid = (PISID)Sid;  // pointer to opaque structure


    RTL_PAGED_CODE();

    if ( RtlValidSid( Sid ) != TRUE)
    {
        return(STATUS_INVALID_SID);
    }

    //
    // if the SID's IA value has 5 or 6 significant bytes, the
    // representation will be in hex, with a 0x preceding.  Otherwise
    // it will be in decimal, with at most 10 characters.
    //

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)  )
    {
        i = 14 ;    // 0x665544332211

    }
    else
    {
        i = 10 ;    // 4294967295 is the max ulong, at 10 chars
    }

    i += 4 ;        // room for the S-1-

    //
    // for each sub authority, it is a max of 10 chars (for a ulong),
    // plus the - separator
    //

    i += 11 * iSid->SubAuthorityCount ;

    *StringLength = i * sizeof( WCHAR );

    return STATUS_SUCCESS ;

}




NTSTATUS
RtlConvertSidToUnicodeString(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexadecimal    |  | |  |
                            +--+-+--+---- Decimal






Arguments:



    UnicodeString - Returns a unicode string that is equivalent to
        the SID. The maximum length field is only set if
        AllocateDestinationString is TRUE.

    Sid - Supplies the SID that is to be converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    STATUS_INVALID_SID - The sid provided does not have a valid structure,
        or has too many sub-authorities (more than SID_MAX_SUB_AUTHORITIES).

    STATUS_NO_MEMORY - There was not sufficient memory to allocate the
        target string.  This is returned only if AllocateDestinationString
        is specified as TRUE.

    STATUS_BUFFER_OVERFLOW - This is returned only if
        AllocateDestinationString is specified as FALSE.


--*/

{
    NTSTATUS Status;
    WCHAR UniBuffer[ 256 ];
    PWSTR Offset ;
    UNICODE_STRING LocalString ;

    UCHAR   i;
    ULONG   Tmp;
    LARGE_INTEGER Auth ;

    PISID   iSid = (PISID)Sid;  // pointer to opaque structure


    RTL_PAGED_CODE();

    if (RtlValidSid( Sid ) != TRUE) {
        return(STATUS_INVALID_SID);
    }

    if ( iSid->Revision != SID_REVISION )
    {
        return STATUS_INVALID_SID ;
    }

    wcscpy( UniBuffer, L"S-1-" );

    Offset = &UniBuffer[ 4 ];

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     ){

        //
        // Ugly hex dump.
        //
	
        wcscat( UniBuffer, L"0x" );
	
        Offset = &UniBuffer[ 6 ];

        Auth.HighPart = (LONG) (iSid->IdentifierAuthority.Value[ 0 ] << 8) +
                        (LONG) iSid->IdentifierAuthority.Value[ 1 ] ;

        Auth.LowPart = (ULONG)iSid->IdentifierAuthority.Value[5]          +
                       (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
                       (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
                       (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);

        Status = RtlLargeIntegerToUnicode(
                        &Auth,
                        16,
                        256 - (LONG) (Offset - UniBuffer),
                        Offset );


    } else {

        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);

        Status = RtlIntegerToUnicode(
                        Tmp,
                        10,
                        256 - (LONG) (Offset - UniBuffer),
                        Offset );

    }

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }


    for (i=0;i<iSid->SubAuthorityCount ;i++ ) {

        while ( *Offset && ( Offset < &UniBuffer[ 255 ] ) )
        {
            Offset++ ;
        }

        *Offset++ = L'-' ;

        Status = RtlIntegerToUnicode(
                        iSid->SubAuthority[ i ],
                        10,
                        256 - (LONG) (Offset - UniBuffer),
                        Offset );

        if ( !NT_SUCCESS( Status ) )
        {
            return Status ;
        }
    }

    if ( AllocateDestinationString )
    {
        if ( RtlCreateUnicodeString( UnicodeString,
                                         UniBuffer ) )
        {
            Status = STATUS_SUCCESS ;
        }
        else
        {
            Status = STATUS_NO_MEMORY ;
        }

    }
    else
    {

        while ( *Offset && ( Offset < &UniBuffer[ 255 ] ) )
        {
            Offset++ ;
        }

        Tmp = (ULONG) (Offset - UniBuffer) * sizeof( WCHAR );

        if ( Tmp < UnicodeString->MaximumLength )
        {
            LocalString.Length = (USHORT) Tmp ;
            LocalString.MaximumLength = LocalString.Length + sizeof( WCHAR );
            LocalString.Buffer = UniBuffer ;

            RtlCopyUnicodeString(
                        UnicodeString,
                        &LocalString );

            Status = STATUS_SUCCESS ;
        }
        else
        {
            Status = STATUS_BUFFER_OVERFLOW ;
        }

    }

    return(Status);
}




BOOLEAN
RtlEqualLuid (
    IN PLUID Luid1,
    IN PLUID Luid2
    )

/*++

Routine Description:

    This procedure test two LUID values for equality.

    This routine is here for backwards compatibility only. New code
    should use the macro.

Arguments:

    Luid1, Luid2 - Supply pointers to the two LUID values to compare.

Return Value:

    BOOLEAN - TRUE if the value of Luid1 is equal to Luid2, and FALSE
        otherwise.


--*/

{
    LUID UNALIGNED * TempLuid1;
    LUID UNALIGNED * TempLuid2;

    RTL_PAGED_CODE();

    return((Luid1->HighPart == Luid2->HighPart) &&
           (Luid1->LowPart  == Luid2->LowPart));

}


VOID
RtlCopyLuid (
    OUT PLUID DestinationLuid,
    IN PLUID SourceLuid
    )

/*++

Routine Description:

    This routine copies the value of the source LUID to the
    destination LUID.

Arguments:

    DestinationLuid - Receives a copy of the source Luid value.

    SourceLuid - Supplies the Luid value to be copied.  This LUID is
                 assumed to be structurally valid.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    (*DestinationLuid) = (*SourceLuid);
    return;
}

VOID
RtlCopyLuidAndAttributesArray (
    IN ULONG ArrayLength,
    IN PLUID_AND_ATTRIBUTES Source,
    OUT PLUID_AND_ATTRIBUTES Target
    )

/*++

Routine Description:

    This routine copies the value of the source LUID_AND_ATTRIBUTES array
    to the target.

Arguments:

    ArrayLength - Number of elements in the source array to copy.

    Source - The source array.

    Target - Indicates where the array elements are to be copied to.


Return Value:

    None.


--*/

{

    ULONG Index = 0;

    RTL_PAGED_CODE();

    while (Index < ArrayLength) {

        Target[Index] = Source[Index];

        Index += 1;

    } //end_while


    return;

}

NTSTATUS
RtlCreateSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Revision
    )

/*++

Routine Description:

    This procedure initializes a new "absolute format" security descriptor.
    After the procedure call the security descriptor is initialized with no
    system ACL, no discretionary ACL, no owner, no primary group and
    all control flags set to false (null).

Arguments:


    SecurityDescriptor - Supplies the security descriptor to
        initialize.

    Revision - Provides the revision level to assign to the security
        descriptor.  This should be one (1) for this release.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision level provided
        is not supported by this routine.

--*/

{
    RTL_PAGED_CODE();

    //
    // Check the requested revision
    //

    if (Revision == SECURITY_DESCRIPTOR_REVISION) {

        //
        // Typecast to the opaque SECURITY_DESCRIPTOR structure.
        //

        SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

        RtlZeroMemory( ISecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));

        ISecurityDescriptor->Revision = SECURITY_DESCRIPTOR_REVISION;

        return STATUS_SUCCESS;
    }

    return STATUS_UNKNOWN_REVISION;
}


NTSTATUS
RtlCreateSecurityDescriptorRelative (
    IN PISECURITY_DESCRIPTOR_RELATIVE SecurityDescriptor,
    IN ULONG Revision
    )

/*++

Routine Description:

    This procedure initializes a new "relative format" security descriptor.
    After the procedure call the security descriptor is initialized with no
    system ACL, no discretionary ACL, no owner, no primary group and
    all control flags set to false (null).

Arguments:


    SecurityDescriptor - Supplies the security descriptor to
        initialize.

    Revision - Provides the revision level to assign to the security
        descriptor.  This should be one (1) for this release.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision level provided
        is not supported by this routine.

Note:
    Warning, this code assume the caller allocated a relative security
    descriptor rather than a relative one.  Absolute is larger on systems
    with 64-bit pointers.

--*/

{
    RTL_PAGED_CODE();

    //
    // Check the requested revision
    //

    if (Revision == SECURITY_DESCRIPTOR_REVISION) {

        //
        // Typecast to the opaque SECURITY_DESCRIPTOR structure.
        //

        RtlZeroMemory( SecurityDescriptor, sizeof(SECURITY_DESCRIPTOR_RELATIVE));

        SecurityDescriptor->Revision = SECURITY_DESCRIPTOR_REVISION;

        return STATUS_SUCCESS;
    }

    return STATUS_UNKNOWN_REVISION;
}


BOOLEAN
RtlValidSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This procedure validates a SecurityDescriptor's structure.  This
    involves validating the revision levels of each component of the
    security descriptor.

Arguments:

    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure
        to validate.

Return Value:

    BOOLEAN - TRUE if the structure of SecurityDescriptor is valid.


--*/

{
    PSID Owner;
    PSID Group;
    PACL Dacl;
    PACL Sacl;

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    try {

        //
        // known revision ?
        //

        if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
            return FALSE;
        }


        //
        // Validate each element contained in the security descriptor
        //

        Owner = RtlpOwnerAddrSecurityDescriptor( ISecurityDescriptor );

        if (Owner != NULL) {
            if (!RtlValidSid( Owner )) {
                return FALSE;
            }
        }

        Group = RtlpGroupAddrSecurityDescriptor( ISecurityDescriptor );

        if (Group != NULL) {
            if (!RtlValidSid( Group )) {
                return FALSE;
            }
        }

        Dacl = RtlpDaclAddrSecurityDescriptor( ISecurityDescriptor );
        if (Dacl != NULL ) {

            if (!RtlValidAcl( Dacl )) {
                return FALSE;
            }
        }

        Sacl = RtlpSaclAddrSecurityDescriptor( ISecurityDescriptor );
        if ( Sacl != NULL ) {
            if (!RtlValidAcl( Sacl )) {
                return FALSE;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }

    //
    // All components are valid
    //

    return TRUE;


}


ULONG
RtlLengthSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine returns the length, in bytes, necessary to capture a
    structurally valid SECURITY_DESCRIPTOR.  The length includes the length
    of all associated data structures (like SIDs and ACLs).  The length also
    takes into account the alignment requirements of each component.

    The minimum length of a security descriptor (one which has no associated
    SIDs or ACLs) is SECURITY_DESCRIPTOR_MIN_LENGTH.


Arguments:

    SecurityDescriptor - Points to the SECURITY_DESCRIPTOR whose
        length is to be returned.  The SECURITY_DESCRIPTOR's
        structure is assumed to be valid.

Return Value:

    ULONG - The length, in bytes, of the SECURITY_DESCRIPTOR.


--*/

{
    ULONG sum;
    PVOID Temp;


    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = (SECURITY_DESCRIPTOR *)SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // The length is the sum of the following:
    //
    //       SECURITY_DESCRIPTOR_MIN_LENGTH (or sizeof(SECURITY_DESCRIPTOR))
    //       length of Owner SID (if present)
    //       length of Group SID (if present)
    //       length of Discretionary ACL (if present and non-null)
    //       length of System ACL (if present and non-null)
    //

    sum = ISecurityDescriptor->Control & SE_SELF_RELATIVE ?
                            sizeof(SECURITY_DESCRIPTOR_RELATIVE) :
                            sizeof(SECURITY_DESCRIPTOR);

    //
    // Add in length of Owner SID
    //

    Temp = RtlpOwnerAddrSecurityDescriptor(ISecurityDescriptor);
    if (Temp != NULL) {
        sum += LongAlignSize(SeLengthSid(Temp));
    }

    //
    // Add in length of Group SID
    //

    Temp = RtlpGroupAddrSecurityDescriptor(ISecurityDescriptor);
    if (Temp != NULL) {
        sum += LongAlignSize(SeLengthSid(Temp));
    }

    //
    // Add in used length of Discretionary ACL
    //

    Temp = RtlpDaclAddrSecurityDescriptor(ISecurityDescriptor);
    if ( Temp != NULL ) {

        sum += LongAlignSize(((PACL) Temp)->AclSize );
    }

    //
    // Add in used length of System Acl
    //

    Temp = RtlpSaclAddrSecurityDescriptor(ISecurityDescriptor);
    if ( Temp != NULL ) {

        sum += LongAlignSize(((PACL) Temp)->AclSize );
    }

    return sum;
}


NTSTATUS
RtlSetAttributesSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL Control,
    OUT PULONG Revision
    )
{
    RTL_PAGED_CODE();

    //
    // Always return the revision value - even if this isn't a valid
    // security descriptor
    //

    *Revision = ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Revision;

    if ( ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Revision
         != SECURITY_DESCRIPTOR_REVISION ) {
        return STATUS_UNKNOWN_REVISION;
    }

    // This is a worthless API.  There is no way to turn any of the bits off.
    // Use the newer RtlSetControlSecurityDescriptor.
    Control &= SE_VALID_CONTROL_BITS;
    return RtlSetControlSecurityDescriptor ( SecurityDescriptor, Control, Control );
}



NTSTATUS
RtlGetControlSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR_CONTROL Control,
    OUT PULONG Revision
    )

/*++

Routine Description:

    This procedure retrieves the control information from a security descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    Control - Receives the control information.

    Revision - Receives the revision of the security descriptor.
               This value will always be returned, even if an error
               is returned by this routine.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{
    RTL_PAGED_CODE();

    //
    // Always return the revision value - even if this isn't a valid
    // security descriptor
    //

    *Revision = ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Revision;


    if ( ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Revision
         != SECURITY_DESCRIPTOR_REVISION ) {
        return STATUS_UNKNOWN_REVISION;
    }


    *Control = ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Control;

    return STATUS_SUCCESS;

}

NTSTATUS
RtlSetControlSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    )
/*++

Routine Description:

    This procedure sets the control information in a security descriptor.


    For instance,

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      SE_DACL_PROTECTED );

    marks the DACL on the security descriptor as protected. And

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      0 );


    marks the DACL as not protected.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    ControlBitsOfInterest - A mask of the control bits being changed, set,
        or reset by this call.  The mask is the logical OR of one or more of
        the following flags:

            SE_DACL_UNTRUSTED
            SE_SERVER_SECURITY
            SE_DACL_AUTO_INHERIT_REQ
            SE_SACL_AUTO_INHERIT_REQ
            SE_DACL_AUTO_INHERITED
            SE_SACL_AUTO_INHERITED
            SE_DACL_PROTECTED
            SE_SACL_PROTECTED

    ControlBitsToSet - A mask indicating what the bits specified by ControlBitsOfInterest
        should be set to.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    //
    // Ensure the caller passed valid bits.
    //

    if ( (ControlBitsOfInterest & ~SE_VALID_CONTROL_BITS) != 0 ||
         (ControlBitsToSet & ~ControlBitsOfInterest) != 0 ) {
        return STATUS_INVALID_PARAMETER;
    }

    ((SECURITY_DESCRIPTOR *)pSecurityDescriptor)->Control &= ~ControlBitsOfInterest;
    ((SECURITY_DESCRIPTOR *)pSecurityDescriptor)->Control |= ControlBitsToSet;

    return STATUS_SUCCESS;
}


NTSTATUS
RtlSetDaclSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN DaclPresent,
    IN PACL Dacl OPTIONAL,
    IN BOOLEAN DaclDefaulted OPTIONAL
    )

/*++

Routine Description:

    This procedure sets the discretionary ACL information of an absolute
    format security descriptor.  If there is already a discretionary ACL
    present in the security descriptor, it is superseded.

Arguments:

    SecurityDescriptor - Supplies the security descriptor to be which
        the discretionary ACL is to be added.

    DaclPresent - If FALSE, indicates the DaclPresent flag in the
        security descriptor should be set to FALSE.  In this case,
        the remaining optional parameters are ignored.  Otherwise,
        the DaclPresent control flag in the security descriptor is
        set to TRUE and the remaining optional parameters are not
        ignored.

    Dacl - Supplies the discretionary ACL for the security
        descriptor.  If this optional parameter is not passed, then a
        null ACL is assigned to the security descriptor.  A null
        discretionary ACL unconditionally grants access.  The ACL is
        referenced by, not copied into, by the security descriptor.

    DaclDefaulted - When set, indicates the discretionary ACL was
        picked up from some default mechanism (rather than explicitly
        specified by a user).  This value is set in the DaclDefaulted
        control flag in the security descriptor.  If this optional
        parameter is not passed, then the DaclDefaulted flag will be
        cleared.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.

    STATUS_INVALID_SECURITY_DESCR - Indicates the security descriptor
        is not an absolute format security descriptor.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
       return STATUS_UNKNOWN_REVISION;
    }

    //
    // Make sure the descriptor is absolute format
    //

    if (ISecurityDescriptor->Control & SE_SELF_RELATIVE) {
        return STATUS_INVALID_SECURITY_DESCR;
    }

    //
    // Assign the DaclPresent flag value passed
    //


    if (DaclPresent) {

        ISecurityDescriptor->Control |= SE_DACL_PRESENT;

        //
        // Assign the ACL address if passed, otherwise set to null.
        //

        ISecurityDescriptor->Dacl = NULL;
        if (ARGUMENT_PRESENT(Dacl)) {
            ISecurityDescriptor->Dacl = Dacl;
        }




        //
        // Assign DaclDefaulted flag if passed, otherwise clear it.
        //

        ISecurityDescriptor->Control &= ~SE_DACL_DEFAULTED;
        if (DaclDefaulted == TRUE) {
            ISecurityDescriptor->Control |= SE_DACL_DEFAULTED;
        }
    } else {

        ISecurityDescriptor->Control &= ~SE_DACL_PRESENT;

    }


    return STATUS_SUCCESS;

}


NTSTATUS
RtlGetDaclSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN DaclPresent,
    OUT PACL *Dacl,
    OUT PBOOLEAN DaclDefaulted
    )

/*++

Routine Description:

    This procedure retrieves the discretionary ACL information of a
    security descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    DaclPresent - If TRUE, indicates that the security descriptor
        does contain a discretionary ACL.  In this case, the
        remaining OUT parameters will receive valid values.
        Otherwise, the security descriptor does not contain a
        discretionary ACL and the remaining OUT parameters will not
        receive valid values.

    Dacl - This value is returned only if the value returned for the
        DaclPresent flag is TRUE.  In this case, the Dacl parameter
        receives the address of the security descriptor's
        discretionary ACL.  If this value is returned as null, then
        the security descriptor has a null discretionary ACL.

    DaclDefaulted - This value is returned only if the value returned
        for the DaclPresent flag is TRUE.  In this case, the
        DaclDefaulted parameter receives the value of the security
        descriptor's DaclDefaulted control flag.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{
    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Assign the DaclPresent flag value
    //

    *DaclPresent = RtlpAreControlBitsSet( ISecurityDescriptor, SE_DACL_PRESENT );

    if (*DaclPresent) {

        //
        // Assign the ACL address.
        //

        *Dacl = RtlpDaclAddrSecurityDescriptor(ISecurityDescriptor);

        //
        // Assign DaclDefaulted flag.
        //

        *DaclDefaulted = RtlpAreControlBitsSet( ISecurityDescriptor, SE_DACL_DEFAULTED );
    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlSetSaclSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN SaclPresent,
    IN PACL Sacl OPTIONAL,
    IN BOOLEAN SaclDefaulted OPTIONAL
    )

/*++

Routine Description:

    This procedure sets the system ACL information of an absolute security
    descriptor.  If there is already a system ACL present in the
    security descriptor, it is superseded.

Arguments:

    SecurityDescriptor - Supplies the security descriptor to be which
        the system ACL is to be added.

    SaclPresent - If FALSE, indicates the SaclPresent flag in the
        security descriptor should be set to FALSE.  In this case,
        the remaining optional parameters are ignored.  Otherwise,
        the SaclPresent control flag in the security descriptor is
        set to TRUE and the remaining optional parameters are not
        ignored.

    Sacl - Supplies the system ACL for the security descriptor.  If
        this optional parameter is not passed, then a null ACL is
        assigned to the security descriptor.  The ACL is referenced
        by, not copied into, by the security descriptor.

    SaclDefaulted - When set, indicates the system ACL was picked up
        from some default mechanism (rather than explicitly specified
        by a user).  This value is set in the SaclDefaulted control
        flag in the security descriptor.  If this optional parameter
        is not passed, then the SaclDefaulted flag will be cleared.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.

    STATUS_INVALID_SECURITY_DESCR - Indicates the security descriptor
        is not an absolute format security descriptor.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Make sure the descriptor is absolute format
    //

    if (ISecurityDescriptor->Control & SE_SELF_RELATIVE) {
        return STATUS_INVALID_SECURITY_DESCR;
    }

    //
    // Assign the SaclPresent flag value passed
    //


    if (SaclPresent) {

        ISecurityDescriptor->Control |= SE_SACL_PRESENT;

        //
        // Assign the ACL address if passed, otherwise set to null.
        //

        ISecurityDescriptor->Sacl = NULL;
        if (ARGUMENT_PRESENT(Sacl)) {
           ISecurityDescriptor->Sacl = Sacl;
        }

        //
        // Assign SaclDefaulted flag if passed, otherwise clear it.
        //

        ISecurityDescriptor->Control &= ~ SE_SACL_DEFAULTED;
        if (ARGUMENT_PRESENT(SaclDefaulted)) {
            ISecurityDescriptor->Control |= SE_SACL_DEFAULTED;
        }
    } else {

        ISecurityDescriptor->Control &= ~SE_SACL_PRESENT;
    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlGetSaclSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN SaclPresent,
    OUT PACL *Sacl,
    OUT PBOOLEAN SaclDefaulted
    )

/*++

Routine Description:

    This procedure retrieves the system ACL information of a security
    descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    SaclPresent - If TRUE, indicates that the security descriptor
        does contain a system ACL.  In this case, the remaining OUT
        parameters will receive valid values.  Otherwise, the
        security descriptor does not contain a system ACL and the
        remaining OUT parameters will not receive valid values.

    Sacl - This value is returned only if the value returned for the
        SaclPresent flag is TRUE.  In this case, the Sacl parameter
        receives the address of the security descriptor's system ACL.
        If this value is returned as null, then the security
        descriptor has a null system ACL.

    SaclDefaulted - This value is returned only if the value returned
        for the SaclPresent flag is TRUE.  In this case, the
        SaclDefaulted parameter receives the value of the security
        descriptor's SaclDefaulted control flag.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Assign the SaclPresent flag value
    //

    *SaclPresent = RtlpAreControlBitsSet( ISecurityDescriptor, SE_SACL_PRESENT );

    if (*SaclPresent) {

        //
        // Assign the ACL address.
        //

        *Sacl = RtlpSaclAddrSecurityDescriptor(ISecurityDescriptor);

        //
        // Assign SaclDefaulted flag.
        //

        *SaclDefaulted = RtlpAreControlBitsSet( ISecurityDescriptor, SE_SACL_DEFAULTED );

    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlSetOwnerSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID Owner OPTIONAL,
    IN BOOLEAN OwnerDefaulted OPTIONAL
    )

/*++

Routine Description:

    This procedure sets the owner information of an absolute security
    descriptor.  If there is already an owner present in the security
    descriptor, it is superseded.

Arguments:

    SecurityDescriptor - Supplies the security descriptor in which
        the owner is to be set.  If the security descriptor already
        includes an owner, it will be superseded by the new owner.

    Owner - Supplies the owner SID for the security descriptor.  If
        this optional parameter is not passed, then the owner is
        cleared (indicating the security descriptor has no owner).
        The SID is referenced by, not copied into, the security
        descriptor.

    OwnerDefaulted - When set, indicates the owner was picked up from
        some default mechanism (rather than explicitly specified by a
        user).  This value is set in the OwnerDefaulted control flag
        in the security descriptor.  If this optional parameter is
        not passed, then the SaclDefaulted flag will be cleared.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.

    STATUS_INVALID_SECURITY_DESCR - Indicates the security descriptor
        is not an absolute format security descriptor.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Make sure the descriptor is absolute format
    //

    if (ISecurityDescriptor->Control & SE_SELF_RELATIVE) {
        return STATUS_INVALID_SECURITY_DESCR;
    }

    //
    // Assign the Owner field if passed, otherwise clear it.
    //

    ISecurityDescriptor->Owner = NULL;
    if (ARGUMENT_PRESENT(Owner)) {
        ISecurityDescriptor->Owner = Owner;
    }

    //
    // Assign the OwnerDefaulted flag if passed, otherwise clear it.
    //

    ISecurityDescriptor->Control &= ~SE_OWNER_DEFAULTED;
    if (OwnerDefaulted == TRUE) {
        ISecurityDescriptor->Control |= SE_OWNER_DEFAULTED;
    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlGetOwnerSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Owner,
    OUT PBOOLEAN OwnerDefaulted
    )

/*++

Routine Description:

    This procedure retrieves the owner information of a security
    descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    Owner - Receives a pointer to the owner SID.  If the security
        descriptor does not currently contain an owner, then this
        value will be returned as null.  In this case, the remaining
        OUT parameters are not given valid return values.  Otherwise,
        this parameter points to an SID and the remaining OUT
        parameters are provided valid return values.

    OwnerDefaulted - This value is returned only if the value
        returned for the Owner parameter is not null.  In this case,
        the OwnerDefaulted parameter receives the value of the
        security descriptor's OwnerDefaulted control flag.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Return the Owner field value.
    //

    *Owner = RtlpOwnerAddrSecurityDescriptor(ISecurityDescriptor);

    //
    // Return the OwnerDefaulted flag value.
    //

    *OwnerDefaulted = RtlpAreControlBitsSet( ISecurityDescriptor, SE_OWNER_DEFAULTED );

    return STATUS_SUCCESS;

}


NTSTATUS
RtlSetGroupSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID Group OPTIONAL,
    IN BOOLEAN GroupDefaulted OPTIONAL
    )

/*++

Routine Description:

    This procedure sets the primary group information of an absolute security
    descriptor.  If there is already an primary group present in the
    security descriptor, it is superseded.

Arguments:

    SecurityDescriptor - Supplies the security descriptor in which
        the primary group is to be set.  If the security descriptor
        already includes a primary group, it will be superseded by
        the new group.

    Group - Supplies the primary group SID for the security
        descriptor.  If this optional parameter is not passed, then
        the primary group is cleared (indicating the security
        descriptor has no primary group).  The SID is referenced by,
        not copied into, the security descriptor.

    GroupDefaulted - When set, indicates the owner was picked up from
        some default mechanism (rather than explicitly specified by a
        user).  This value is set in the OwnerDefaulted control flag
        in the security descriptor.  If this optional parameter is
        not passed, then the SaclDefaulted flag will be cleared.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.

    STATUS_INVALID_SECURITY_DESCR - Indicates the security descriptor
        is not an absolute format security descriptor.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Make sure the descriptor is absolute format
    //

    if (ISecurityDescriptor->Control & SE_SELF_RELATIVE) {
        return STATUS_INVALID_SECURITY_DESCR;
    }

    //
    // Assign the Group field if passed, otherwise clear it.
    //

    ISecurityDescriptor->Group = NULL;
    if (ARGUMENT_PRESENT(Group)) {
        ISecurityDescriptor->Group = Group;
    }

    //
    // Assign the GroupDefaulted flag if passed, otherwise clear it.
    //

    ISecurityDescriptor->Control &= ~SE_GROUP_DEFAULTED;
    if (ARGUMENT_PRESENT(GroupDefaulted)) {
        ISecurityDescriptor->Control |= SE_GROUP_DEFAULTED;
    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlGetGroupSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Group,
    OUT PBOOLEAN GroupDefaulted
    )

/*++

Routine Description:

    This procedure retrieves the primary group information of a
    security descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    Group - Receives a pointer to the primary group SID.  If the
        security descriptor does not currently contain a primary
        group, then this value will be returned as null.  In this
        case, the remaining OUT parameters are not given valid return
        values.  Otherwise, this parameter points to an SID and the
        remaining OUT parameters are provided valid return values.

    GroupDefaulted - This value is returned only if the value
        returned for the Group parameter is not null.  In this case,
        the GroupDefaulted parameter receives the value of the
        security descriptor's GroupDefaulted control flag.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{

    //
    // Typecast to the opaque SECURITY_DESCRIPTOR structure.
    //

    SECURITY_DESCRIPTOR *ISecurityDescriptor =
        (SECURITY_DESCRIPTOR *)SecurityDescriptor;

    RTL_PAGED_CODE();

    //
    // Check the revision
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Return the Group field value.
    //

    *Group = RtlpGroupAddrSecurityDescriptor(ISecurityDescriptor);

    //
    // Return the GroupDefaulted flag value.
    //

    *GroupDefaulted = RtlpAreControlBitsSet( ISecurityDescriptor, SE_GROUP_DEFAULTED );

    return STATUS_SUCCESS;

}


BOOLEAN
RtlAreAllAccessesGranted(
    IN ACCESS_MASK GrantedAccess,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine is used to check a desired access mask against a
    granted access mask.  It is used by the Object Management
    component when dereferencing a handle.

Arguments:

        GrantedAccess - Specifies the granted access mask.

        DesiredAccess - Specifies the desired access mask.

Return Value:

    BOOLEAN - TRUE if the GrantedAccess mask has all the bits set
        that the DesiredAccess mask has set.  That is, TRUE is
        returned if all of the desired accesses have been granted.

--*/

{
    RTL_PAGED_CODE();

    return ((BOOLEAN)((~(GrantedAccess) & (DesiredAccess)) == 0));
}


BOOLEAN
RtlAreAnyAccessesGranted(
    IN ACCESS_MASK GrantedAccess,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine is used to test whether any of a set of desired
    accesses are granted by a granted access mask.  It is used by
    components other than the the Object Management component for
    checking access mask subsets.

Arguments:

        GrantedAccess - Specifies the granted access mask.

        DesiredAccess - Specifies the desired access mask.

Return Value:

    BOOLEAN - TRUE if the GrantedAccess mask contains any of the bits
        specified in the DesiredAccess mask.  That is, if any of the
        desired accesses have been granted, TRUE is returned.


--*/

{
    RTL_PAGED_CODE();

    return ((BOOLEAN)(((GrantedAccess) & (DesiredAccess)) != 0));
}


VOID
RtlMapGenericMask(
    IN OUT PACCESS_MASK AccessMask,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This routine maps all generic accesses in the provided access mask
    to specific and standard accesses according to the provided
    GenericMapping.

Arguments:

        AccessMask - Points to the access mask to be mapped.

        GenericMapping - The mapping of generic to specific and standard
                         access types.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

//    //
//    // Make sure the pointer is properly aligned
//    //
//

    if (*AccessMask & GENERIC_READ) {

        *AccessMask |= GenericMapping->GenericRead;
    }

    if (*AccessMask & GENERIC_WRITE) {

        *AccessMask |= GenericMapping->GenericWrite;
    }

    if (*AccessMask & GENERIC_EXECUTE) {

        *AccessMask |= GenericMapping->GenericExecute;
    }

    if (*AccessMask & GENERIC_ALL) {

        *AccessMask |= GenericMapping->GenericAll;
    }

    //
    // Now clear the generic flags
    //

    *AccessMask &= ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);

    return;
}

NTSTATUS
RtlpImpersonateSelfEx (
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN ACCESS_MASK AdditionalAccess,
    OUT PHANDLE ThreadToken OPTIONAL
    )

/*++

Routine Description:

    This routine may be used to obtain an Impersonation token representing
    your own process's context.  This may be useful for enabling a privilege
    for a single thread rather than for the entire process; or changing
    the default DACL for a single thread.

    The token is assigned to the callers thread.

    The caller may optionally request to receive a handle to the token assigned
    to the thread, obviating the need for a subsequent call solely to open the
    thread token.

Arguments:

    ImpersonationLevel - The level to make the impersonation token.

    AdditionalAccess - Additional requested access rights to the thread token 
        handle beyond TOKEN_IMPERSONATE. If an output handle is not specified, 
        this value must be zero.

    ThreadToken - Optional output pointer which receives a handle to the current 
        thread token upon successful completion of this routine.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status, Status1;
    HANDLE Token1, Token2;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE Qos;

    RTL_PAGED_CODE ();

    if (!ARGUMENT_PRESENT (ThreadToken) && (AdditionalAccess != 0)) {
        return STATUS_INVALID_PARAMETER_2;
    }
    
    InitializeObjectAttributes (&ObjectAttributes, NULL, 0, 0, NULL);

    Qos.Length = sizeof (SECURITY_QUALITY_OF_SERVICE);
    Qos.ImpersonationLevel = ImpersonationLevel;
    Qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    Qos.EffectiveOnly = FALSE;
    ObjectAttributes.SecurityQualityOfService = &Qos;

    Status = NtOpenProcessToken (NtCurrentProcess(), TOKEN_DUPLICATE, &Token1);

    if (NT_SUCCESS(Status)) {
        Status = NtDuplicateToken (
                     Token1,
                     TOKEN_IMPERSONATE | AdditionalAccess,
                     &ObjectAttributes,
                     FALSE,                 //EffectiveOnly
                     TokenImpersonation,
                     &Token2
                     );
        
        if (NT_SUCCESS(Status)) {
            
            Status = NtSetInformationThread (
                         NtCurrentThread (),
                         ThreadImpersonationToken,
                         &Token2,
                         sizeof(HANDLE)
                         );

            if (NT_SUCCESS (Status) && ARGUMENT_PRESENT (ThreadToken)) {
                *ThreadToken = Token2;
            } else {
                Status1 = NtClose (Token2);
                NT_ASSERT (NT_SUCCESS (Status1));
            }
        }

        Status1 = NtClose (Token1);
        NT_ASSERT (NT_SUCCESS (Status1));
    }

    return Status;
}

NTSTATUS
RtlImpersonateSelf (
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This routine may be used to obtain an Impersonation token representing
    your own process's context.  This may be useful for enabling a privilege
    for a single thread rather than for the entire process; or changing
    the default DACL for a single thread.

    N.B. This routine now simply invokes RtlpImpersonateSelfEx.
    
Arguments:

    ImpersonationLevel - The level to make the impersonation token.

Return Value:

    NSTATUS.

--*/

{
    RTL_PAGED_CODE ();

    return RtlpImpersonateSelfEx (ImpersonationLevel, 0, NULL);
}


VOID
RtlpApplyAclToObject (
    IN PACL Acl,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This is a private routine that maps Access Masks of an ACL so that
    they are applicable to the object type the ACL is being applied to.

    Only known DSA ACEs are mapped.  Unknown ACE types are ignored.

    Only access types in the GenericAll mapping for the target object
    type will be non-zero upon return.

Arguments:

    Acl - Supplies the acl being applied.

    GenericMapping - Specifies the generic mapping to use.


Return Value:

    None.

--*/

{
    ULONG i;

    PACE_HEADER Ace;

    RTL_PAGED_CODE();

    //
    //  First check if the acl is null
    //

    if (Acl == NULL) {

        return;

    }


    //
    // Now walk the ACL, mapping each ACE as we go.
    //

    for (i = 0, Ace = FirstAce(Acl);
         i < Acl->AceCount;
         i += 1, Ace = NextAce(Ace)) {

        if (IsMSAceType( Ace )) {

            RtlApplyAceToObject( Ace, GenericMapping );
        }

    }

    return;
}


BOOLEAN
RtlpCopyEffectiveAce (
    IN PACE_HEADER OldAce,
    IN BOOLEAN AutoInherit,
    IN BOOLEAN WillGenerateInheritAce,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN OUT PVOID *AcePosition,
    OUT PULONG NewAceLength,
    OUT PACL NewAcl,
    OUT PBOOLEAN ObjectAceInherited OPTIONAL,
    OUT PBOOLEAN EffectiveAceMapped,
    OUT PBOOLEAN AclOverflowed
    )

/*++

Routine Description:

    This routine copy a specified ACE into an ACL as an effective ACE.
    The resultant ACE has all the inheritance bits turned of.
    The resultant ACE has the SID mapped from a generic SID to a specific SID
    (e.g., From "creator owner" to the passed in owner sid).

Arguments:

    OldAce - Supplies the ace being inherited

    AutoInherit - Specifies if the inheritance is an "automatic inheritance".
        As such, the inherited ACEs will be marked as such.

    WillGenerateInheritAce - Specifies if the caller intends to generate an
        inheritable ACE the corresponds to OldAce.  If TRUE, this routine will
        try to not map the effective ACE (increasing the likelyhood that
        EffectiveAceMapped will return FALSE),

    ClientOwnerSid - Specifies the owner Sid to use

    ClientGroupSid - Specifies the new Group Sid to use

    ServerSid - Optionally specifies the Server Sid to use in compound ACEs.

    ClientSid - Optionally specifies the Client Sid to use in compound ACEs.

    GenericMapping - Specifies the generic mapping to use

    pNewObjectType - List of types of object being inherited to.  If not 
        specified, the object has no object type.

    GuidCount - Number of object types in the list.

    AcePosition - On entry and exit, specifies location of the next available ACE
        position in NewAcl.
        A NULL ACE position means there is no room at all in NewAcl.

    NewAceLength - Returns the length (in bytes) needed in NewAcl to
        copy the specified ACE. This might be zero to indicate that the ACE
        need not be copied at all.

    NewAcl - Provides a pointer to the ACL into which the ACE is to be
        inherited.

    ObjectAceInherited - Returns true if one or more object ACEs were inherited
        based on NewObjectType
        If NULL, NewObjectType is ignored and the object ACE is always inherited

    EffectiveAceMapped - Return TRUE if the SID, guid, or access mask of Old Ace
        was modifed when copying the ACE.

    AclOverflowed - Returns TRUE if NewAcl wasn't long enough to contain NewAceLength.

Return Value:

    TRUE - No problem was detected.
    FALSE - Indicates something went wrong preventing
        the ACE from being copied.  This generally represents a bugcheck
        situation when returned from this call.

--*/
{
    ULONG LengthRequired;
    ACCESS_MASK LocalMask;
    BOOLEAN GuidOptimizationPossible = FALSE;

    PSID LocalServerOwner;
    PSID LocalServerGroup;
    NTSTATUS Status;

    ULONG CreatorSid[CREATOR_SID_SIZE];

    SID_IDENTIFIER_AUTHORITY  CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;


    RTL_PAGED_CODE();

    //
    // Allocate and initialize the universal SIDs we're going to need
    // to look for inheritable ACEs.
    //

    ASSERT(RtlLengthRequiredSid( 1 ) == CREATOR_SID_SIZE);
    Status = RtlInitializeSid( (PSID)CreatorSid, &CreatorSidAuthority, 1 );

    if ( !NT_SUCCESS(Status) ) {
        return FALSE;
    }

    *(RtlpSubAuthoritySid( (PSID)CreatorSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

    LocalServerOwner = ARGUMENT_PRESENT(ServerOwnerSid) ? ServerOwnerSid : ClientOwnerSid;
    LocalServerGroup = ARGUMENT_PRESENT(ServerGroupSid) ? ServerGroupSid : ClientGroupSid;


    //
    // Initialization
    //
    *EffectiveAceMapped = FALSE;
    if ( ARGUMENT_PRESENT(ObjectAceInherited)) {
        *ObjectAceInherited = FALSE;
    }
    *AclOverflowed = FALSE;
    LengthRequired = (ULONG)OldAce->AceSize;

    //
    // Process all MS ACE types specially
    //

    if ( IsMSAceType(OldAce) ) {
        ULONG Rid;
        PSID SidToCopy = NULL;
        ULONG AceHeaderToCopyLength;
        PACE_HEADER AceHeaderToCopy = OldAce;
        PSID ServerSidToCopy = NULL;

        UCHAR DummyAce[sizeof(KNOWN_OBJECT_ACE)+sizeof(GUID)];

        //
        // Grab the Sid pointer and access mask as a function of the ACE type
        //
        if (IsKnownAceType( OldAce ) ) {
            SidToCopy = &((PKNOWN_ACE)OldAce)->SidStart;
            AceHeaderToCopyLength = FIELD_OFFSET(KNOWN_ACE, SidStart);

        } else if (IsCompoundAceType(OldAce)) {

            SidToCopy = RtlCompoundAceClientSid( OldAce );
            AceHeaderToCopyLength = FIELD_OFFSET(KNOWN_COMPOUND_ACE, SidStart);
            ASSERT( FIELD_OFFSET(KNOWN_COMPOUND_ACE, Mask) ==
                    FIELD_OFFSET(KNOWN_ACE, Mask) );

            //
            // Compound ACEs have two SIDs (Map one now).
            //
            ServerSidToCopy = RtlCompoundAceServerSid( OldAce );

            if (RtlEqualPrefixSid ( ServerSidToCopy, CreatorSid )) {

                Rid = *RtlpSubAuthoritySid( ServerSidToCopy, 0 );
                switch (Rid) {
                case SECURITY_CREATOR_OWNER_RID:
                    ServerSidToCopy = ClientOwnerSid;
                    LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(ClientOwnerSid);
                    *EffectiveAceMapped = TRUE;
                    break;
                case SECURITY_CREATOR_GROUP_RID:
                    if ( ClientGroupSid != NULL ) {
                        ServerSidToCopy = ClientGroupSid;
                        LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(ClientGroupSid);
                        *EffectiveAceMapped = TRUE;
                    }
                    break;
                case SECURITY_CREATOR_OWNER_SERVER_RID:
                    ServerSidToCopy = LocalServerOwner;
                    LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(LocalServerOwner);
                    *EffectiveAceMapped = TRUE;
                    break;
                case SECURITY_CREATOR_GROUP_SERVER_RID:
                    ServerSidToCopy = LocalServerGroup;
                    LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(LocalServerGroup);
                    *EffectiveAceMapped = TRUE;
                    break;
                }

                //
                // If we don't know what this SID is, just copy the original.
                //
                if ( !*EffectiveAceMapped ) {
                    AceHeaderToCopyLength += SeLengthSid( ServerSidToCopy );
                    ServerSidToCopy = NULL;
                }

            } else {
                //
                // We don't know what this SID is, just copy the original.
                //
                AceHeaderToCopyLength += SeLengthSid( ServerSidToCopy );
                ServerSidToCopy = NULL;
            }

        //
        // Handle Object ACEs
        //
        } else {
            GUID *InheritedObjectType;

            SidToCopy = RtlObjectAceSid( OldAce );
            AceHeaderToCopyLength = (ULONG) ((PUCHAR)SidToCopy - (PUCHAR)OldAce);
            ASSERT( FIELD_OFFSET(KNOWN_OBJECT_ACE, Mask) ==
                    FIELD_OFFSET(KNOWN_ACE, Mask) );

            //
            // Handle ACEs that are only inherited for a specific object type,
            //
            InheritedObjectType = RtlObjectAceInheritedObjectType( OldAce );
            if ( ARGUMENT_PRESENT(ObjectAceInherited) && InheritedObjectType != NULL ) {

                //
                // If the object type doesn't match the inherited object type,
                //  don't inherit the ACE.
                //

                if ( pNewObjectType == NULL ||
                     !RtlpGuidPresentInGuidList( InheritedObjectType,
                                      pNewObjectType,
                                      GuidCount ) ) {

                    LengthRequired = 0;

                //
                // If the object type matches the inherited object type,
                //  Inherit an ACE with no inherited object type.
                //

                } else {

                    //
                    // Tell the caller we inherited an object type specific ACE.
                    //

                    *ObjectAceInherited = TRUE;

                    //
                    // If the caller is not going to generate an inheritable ACE,
                    //  deleting the inherited object type GUID for the effective ACE.
                    //
                    // Otherwise, leave it so the caller can merge the two ACEs.
                    //

                    if ( !WillGenerateInheritAce ) {
                        *EffectiveAceMapped = TRUE;

                        //
                        // If an object type GUID is present,
                        //  simply delete the inherited object type GUID.
                        //
                        if ( RtlObjectAceObjectTypePresent( OldAce )) {
                            LengthRequired -= sizeof(GUID);
                            AceHeaderToCopyLength -= sizeof(GUID);
                            RtlCopyMemory( DummyAce, OldAce, AceHeaderToCopyLength );

                            AceHeaderToCopy = (PACE_HEADER)DummyAce;
                            ((PKNOWN_OBJECT_ACE)AceHeaderToCopy)->Flags &= ~ACE_INHERITED_OBJECT_TYPE_PRESENT;


                        //
                        // If an object type GUID is not present,
                        //  convert the ACE to non-object type specific.
                        //
                        } else {
                            AceHeaderToCopyLength = AceHeaderToCopyLength -
                                             sizeof(GUID) +
                                             sizeof(KNOWN_ACE) -
                                             sizeof(KNOWN_OBJECT_ACE);
                            LengthRequired = LengthRequired -
                                             sizeof(GUID) +
                                             sizeof(KNOWN_ACE) -
                                             sizeof(KNOWN_OBJECT_ACE);

                            RtlCopyMemory( DummyAce, OldAce, AceHeaderToCopyLength );
                            AceHeaderToCopy = (PACE_HEADER)DummyAce;

                            AceHeaderToCopy->AceType = RtlBaseAceType[ OldAce->AceType ];

                        }
                    } else {
                        GuidOptimizationPossible = TRUE;
                    }
                }

            }
        }

        //
        // Only proceed if we've not already determined to drop the ACE.
        //

        if ( LengthRequired != 0 ) {

            //
            // If after mapping the access mask, the access mask
            // is empty, then drop the ACE.
            //
            // This is incompatible with NT 4.0 which simply mapped and left
            //  undefined access bits set.

            LocalMask = ((PKNOWN_ACE)(OldAce))->Mask;
            RtlApplyGenericMask( OldAce, &LocalMask, GenericMapping);

            if ( LocalMask != ((PKNOWN_ACE)(OldAce))->Mask ) {
                *EffectiveAceMapped = TRUE;
            }

            //
            // Mask off any bits that aren't meaningful
            //

            LocalMask &= ( STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL | ACCESS_SYSTEM_SECURITY );

            if (LocalMask == 0) {

                LengthRequired = 0;

            } else {

                //
                // See if the SID in the ACE is one of the various CREATOR_* SIDs by
                // comparing identifier authorities.
                //

                if (RtlEqualPrefixSid ( SidToCopy, CreatorSid )) {

                    Rid = *RtlpSubAuthoritySid( SidToCopy, 0 );

                    switch (Rid) {
                    case SECURITY_CREATOR_OWNER_RID:
                        SidToCopy = ClientOwnerSid;
                        LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(ClientOwnerSid);
                        *EffectiveAceMapped = TRUE;
                        break;
                    case SECURITY_CREATOR_GROUP_RID:
                        if ( ClientGroupSid != NULL ) {
                            SidToCopy = ClientGroupSid;
                            LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(ClientGroupSid);
                            *EffectiveAceMapped = TRUE;
                        }
                        break;
                    case SECURITY_CREATOR_OWNER_SERVER_RID:
                        SidToCopy = LocalServerOwner;
                        LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(LocalServerOwner);
                        *EffectiveAceMapped = TRUE;
                        break;
                    case SECURITY_CREATOR_GROUP_SERVER_RID:
                        SidToCopy = LocalServerGroup;
                        LengthRequired = LengthRequired - CREATOR_SID_SIZE + SeLengthSid(LocalServerGroup);
                        *EffectiveAceMapped = TRUE;
                        break;
                    default :
                        //
                        // We don't know what this SID is, just copy the original.
                        //
                        break;
                    }
                }

                //
                // In cases where effective ace has been mapped because of
                //     a. CreatorOwner/Group OR
                //     b. Generic flags
                // AND
                //     this is an object type ace which will generate an IO ace
                // we can save space for a guid.
                //

                if (GuidOptimizationPossible && *EffectiveAceMapped) {

                    //
                    // If an object type GUID is present,
                    //  simply delete the inherited object type GUID.
                    //

                    if ( RtlObjectAceObjectTypePresent( OldAce )) {
                        LengthRequired -= sizeof(GUID);
                        AceHeaderToCopyLength -= sizeof(GUID);
                        RtlCopyMemory( DummyAce, OldAce, AceHeaderToCopyLength );

                        AceHeaderToCopy = (PACE_HEADER)DummyAce;
                        ((PKNOWN_OBJECT_ACE)AceHeaderToCopy)->Flags &= ~ACE_INHERITED_OBJECT_TYPE_PRESENT;


                    //
                    // If an object type GUID is not present,
                    //  convert the ACE to non-object type specific.
                    //
                    } else {
                        AceHeaderToCopyLength = AceHeaderToCopyLength -
                                         sizeof(GUID) +
                                         sizeof(KNOWN_ACE) -
                                         sizeof(KNOWN_OBJECT_ACE);
                        LengthRequired = LengthRequired -
                                         sizeof(GUID) +
                                         sizeof(KNOWN_ACE) -
                                         sizeof(KNOWN_OBJECT_ACE);

                        RtlCopyMemory( DummyAce, OldAce, AceHeaderToCopyLength );
                        AceHeaderToCopy = (PACE_HEADER)DummyAce;

                        AceHeaderToCopy->AceType = RtlBaseAceType[ OldAce->AceType ];

                    }
                }

                //
                // If the ACE doesn't fit,
                //  just note the fact and don't copy the ACE.
                //

                if ( *AcePosition == NULL ||
                     LengthRequired > (ULONG)NewAcl->AclSize - ((PUCHAR)(*AcePosition) - (PUCHAR)NewAcl) ) {
                    *AclOverflowed = TRUE;
                } else {

                    PUCHAR Target;

                    //
                    // Copy individual parts of the ACE separately.
                    //

                    Target = (PUCHAR)*AcePosition;

                    RtlCopyMemory(
                        Target,
                        AceHeaderToCopy,
                        AceHeaderToCopyLength );

                    Target += AceHeaderToCopyLength;

                    //
                    // Now copy the correct server SID
                    //

                    if ( ServerSidToCopy != NULL ) {
                        RtlCopyMemory(
                            Target,
                            ServerSidToCopy,
                            SeLengthSid(ServerSidToCopy)
                            );
                        Target += SeLengthSid(ServerSidToCopy);
                    }

                    //
                    // Now copy the correct SID
                    //

                    RtlCopyMemory(
                        Target,
                        SidToCopy,
                        SeLengthSid(SidToCopy)
                        );
                    Target += SeLengthSid(SidToCopy);

                    //
                    // Set the size of the ACE accordingly
                    //

                    if ( LengthRequired < (ULONG)(Target - (PUCHAR)*AcePosition) ) {
                        return FALSE;
                    }
                    LengthRequired = (ULONG)(Target - (PUCHAR)*AcePosition);
                    ((PKNOWN_ACE)*AcePosition)->Header.AceSize =
                        (USHORT)LengthRequired;


                    //
                    // Put the mapped access mask in the new ACE
                    //

                    ((PKNOWN_ACE)*AcePosition)->Mask = LocalMask;

                }
            }
        }

    } else {

        //
        // If the ACE doesn't fit,
        //  just note the fact and don't copy the ACE.
        //

        if ( LengthRequired > (ULONG)NewAcl->AclSize - ((PUCHAR)*AcePosition - (PUCHAR)NewAcl) ) {
            *AclOverflowed = TRUE;
        } else {

            //
            // Not a known ACE type, copy ACE as is
            //

            RtlCopyMemory(
                *AcePosition,
                OldAce,
                LengthRequired );
         }
    }

    //
    // If the ACE was actually kept, clear all the inherit flags
    // and update the ACE count of the ACL.
    //

    if ( !*AclOverflowed && LengthRequired != 0 ) {
        ((PACE_HEADER)*AcePosition)->AceFlags &= ~VALID_INHERIT_FLAGS;
        if ( AutoInherit ) {
            ((PACE_HEADER)*AcePosition)->AceFlags |= INHERITED_ACE;
        }
        NewAcl->AceCount += 1;
    }

    //
    // We have the length of the new ACE, but we've calculated
    // it with a ULONG.  It must fit into a USHORT.  See if it
    // does.
    //

    if (LengthRequired > 0xFFFF) {
        return FALSE;
    }

    //
    // Move the Ace Position to where the next ACE goes.
    //
    if ( !*AclOverflowed ) {
        *AcePosition = ((PUCHAR)*AcePosition) + LengthRequired;
    }

    //
    //  Now return to our caller
    //

    (*NewAceLength) = LengthRequired;

    return TRUE;
}

#ifndef WIN16

NTSTATUS
RtlpCopyAces(
    IN PACL Acl,
    IN PGENERIC_MAPPING GenericMapping,
    IN ACE_TYPE_TO_COPY AceTypeToCopy,
    IN UCHAR AceFlagsToReset,
    IN BOOLEAN MapSids,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN RetainInheritedAceBit,
    OUT PULONG NewAclSizeParam,
    OUT PACL NewAcl
    )

/*++

Routine Description:

    Copy ACEs from of an ACL and perform generic mapping.  Only ACEs specified
    by 'AceFilter' are copied.

Arguments:

    Acl - Supplies the ACL to copy from.

    GenericMapping - Specifies the generic mapping to use.

    AceTypeToCopy - Describes which aces to copy.

    AceFlagsToReset - Bit mask of ACE flags to reset (if set) on each ACE.

    MapSids - TRUE if the SID in the ACE is to be mapped to the corresponding
        actual SID.

    ClientOwnerSid - Specifies the owner Sid to use

    ClientGroupSid - Specifies the new Group Sid to use

    ServerOwnerSid - Optionally specifies the Server Sid to use in compound ACEs.

    ServerGroupSid - Optionally specifies the Server group Sid to use in compound ACEs.

    IsDirectoryObject - Whether the object is a container or a non-container
    
    RetainInheritedAceBit - Whether to retain INHERITED_ACE bit for effective aces.

    NewAclSizeParam - Receives the cumulative length of the copies ACEs

    NewAcl - Provides a pointer to the ACL to copy to.
        This ACL must already be initialized.


Return Value:

    STATUS_SUCCESS - An inheritable ACL has been generated.

    STATUS_BUFFER_TOO_SMALL - The ACL specified by NewAcl is too small for the
        copied ACEs.  The required size is returned in NewAceLength.


--*/

{

    NTSTATUS Status;
    ULONG i;

    PACE_HEADER OldAce;
    ULONG NewAclSize, NewAceSize;
    BOOLEAN AclOverflowed = FALSE;
    BOOLEAN CopyAce;
    PVOID AcePosition;
    BOOLEAN LocalAutoInherit = FALSE;


    RTL_PAGED_CODE();

    //
    // Validate the ACL.
    //

    if ( !ValidAclRevision(NewAcl) ) {
        return STATUS_UNKNOWN_REVISION;
    }

    //
    // Find where the first ACE goes.
    //

    if (!RtlFirstFreeAce( NewAcl, &AcePosition )) {
        return STATUS_BAD_INHERITANCE_ACL;
    }

    //
    // Walk through the original ACL copying ACEs.
    //

    NewAclSize = 0;
    for (i = 0, OldAce = FirstAce(Acl);
         i < Acl->AceCount;
         i += 1, OldAce = NextAce(OldAce)) {

        //
        // If the ACE wasn't inherited,
        //  copy it.
        //

        switch (AceTypeToCopy) {
        case CopyInheritedAces:
            CopyAce = AceInherited(OldAce);
            break;
        case CopyNonInheritedAces:
            CopyAce = !AceInherited(OldAce);
            break;
        case CopyAllAces:
            CopyAce = TRUE;
            break;
        default:
            CopyAce = FALSE;
            break;
        }

        if ( CopyAce ) {


            //
            // If SIDs are to be mapped,
            //  do so (and potentially create up to two ACEs).
            //

            if ( MapSids ) {
                PVOID TempAcePosition;
                ULONG EffectiveAceSize = 0;

                BOOLEAN EffectiveAceMapped;
                BOOLEAN GenerateInheritAce;

                //
                // Remember where the next ACE will be copied.
                //

                TempAcePosition = AcePosition;
                NewAceSize = 0;
                GenerateInheritAce = IsDirectoryObject &&
                    ((((PACE_HEADER)OldAce)->AceFlags & (OBJECT_INHERIT_ACE|CONTAINER_INHERIT_ACE)) != 0);


                //
                // If the original ACE is an effective ACE,
                //  create an effective ACE.
                //

                if ( !(((PACE_HEADER)OldAce)->AceFlags & INHERIT_ONLY_ACE)) {
                    BOOLEAN LocalAclOverflowed;

                    //
                    // If the ace has INHERITED_ACE bit and the caller has requested
                    // preservation of the bit, copy the effective ace as an
                    // INHERITED_ACE.
                    //

                    LocalAutoInherit = FALSE;

                    if ( RetainInheritedAceBit ) {
                        if ( OldAce->AceFlags & INHERITED_ACE) {
                            LocalAutoInherit = TRUE;
                        }
                    }

                    //
                    // Copy the effective ACE into the ACL.
                    //
                    if ( !RtlpCopyEffectiveAce (
                                    OldAce,
                                    LocalAutoInherit,  
                                    GenerateInheritAce,
                                    ClientOwnerSid,
                                    ClientGroupSid,
                                    ServerOwnerSid,
                                    ServerGroupSid,
                                    GenericMapping,
                                    NULL,   // Always copy object ACES
                                    0,
                                    &TempAcePosition,
                                    &EffectiveAceSize,
                                    NewAcl,
                                    NULL,   // Always copy object ACES
                                    &EffectiveAceMapped,
                                    &LocalAclOverflowed ) ) {

                        return STATUS_BAD_INHERITANCE_ACL;
                    }

                    if (LocalAclOverflowed) {
                        AclOverflowed = TRUE;
                    }
                    NewAceSize += EffectiveAceSize;

                    //
                    // Reset any undesirable AceFlags.
                    //
                    
                    if ( !AclOverflowed && EffectiveAceSize != 0 ) {
                        ((PACE_HEADER)AcePosition)->AceFlags &= ~AceFlagsToReset;
                    }

                }

                //
                // If the original ACE is inheritable,
                //  create an inheritable ACE.
                //
                // ASSERT: AcePosition points to where the effective ACE was copied
                // ASSERT: TempAcePosition points to where the inheritable ACE should be copied
                //

                if ( GenerateInheritAce ) {

                    //
                    // If a effective ACE was created,
                    //  and it wasn't mapped,
                    //  avoid generating another ACE and simply merge the inheritance bits into
                    //      the effective ACE.
                    //

                    if ( EffectiveAceSize != 0 && !EffectiveAceMapped ) {

                       //
                       // Copy the inherit bits from the original ACE.
                       //
                       if ( !AclOverflowed ) {
                            ((PACE_HEADER)AcePosition)->AceFlags |=
                                ((PACE_HEADER)OldAce)->AceFlags & (VALID_INHERIT_FLAGS);
                            ((PACE_HEADER)AcePosition)->AceFlags &= ~AceFlagsToReset;
                       }


                    //
                    // Otherwise, generate an explicit inheritance ACE.
                    //
                    // But only if the access mask isn't zero.
                    //

                    } else if ( !IsMSAceType(OldAce) || ((PKNOWN_ACE)(OldAce))->Mask != 0 ) {

                        //
                        // Account for the new ACE being added to the ACL.
                        //
                        NewAceSize += (ULONG)(((PACE_HEADER)OldAce)->AceSize);

                        if (NewAceSize > 0xFFFF) {
                            return STATUS_BAD_INHERITANCE_ACL;
                        }

                        //
                        // If the ACE doesn't fit,
                        //  just note the fact and don't copy the ACE.
                        //

                        if ( ((PACE_HEADER)OldAce)->AceSize > NewAcl->AclSize - ((PUCHAR)TempAcePosition - (PUCHAR)NewAcl) ) {
                            AclOverflowed = TRUE;
                        } else {

                            //
                            // copy it as is, but make sure the InheritOnly bit is set.
                            //

                            if ( !AclOverflowed ) {
                                RtlCopyMemory(
                                    TempAcePosition,
                                    OldAce,
                                    ((PACE_HEADER)OldAce)->AceSize
                                    );

                                ((PACE_HEADER)TempAcePosition)->AceFlags |= INHERIT_ONLY_ACE;
                                ((PACE_HEADER)TempAcePosition)->AceFlags &= ~AceFlagsToReset;
                                NewAcl->AceCount += 1;
                            }
                        }
                    }

                }

            } else {
                NewAceSize = (ULONG)OldAce->AceSize;

                //
                // If the ACE doesn't fit,
                //  just note the fact and don't copy the ACE.
                //

                if ( AcePosition == NULL ||
                     NewAceSize > (ULONG)NewAcl->AclSize - ((PUCHAR)AcePosition - (PUCHAR)NewAcl) ) {
                    AclOverflowed = TRUE;
                } else if ( !AclOverflowed ) {


                    //
                    // Copy the ACE.
                    //

                    RtlCopyMemory(
                        AcePosition,
                        OldAce,
                        NewAceSize );

                    //
                    // Map the generic bits.
                    //
                    // Is it really right to map the generic bits on an ACE
                    // that's both effective and inheritable.  Shouldn't this
                    // be split into two ACEs in that case?  Or just skip the mapping?
                    //
                    if (IsMSAceType( AcePosition )) {
                        RtlApplyAceToObject( (PACE_HEADER)AcePosition, GenericMapping );
                    }

                    //
                    // Reset any undesirable AceFlags.
                    //

                    ((PACE_HEADER)AcePosition)->AceFlags &= ~AceFlagsToReset;

                    //
                    // Account for the new ACE.
                    //

                    NewAcl->AceCount += 1;
                }
            }


            //
            // Move the Ace Position to where the next ACE goes.
            //
            if ( !AclOverflowed ) {
                AcePosition = ((PUCHAR)AcePosition) + NewAceSize;
            } else {
                // On overflow, ensure no other ACEs are actually output to the buffer
                AcePosition = ((PUCHAR)NewAcl) + NewAcl->AclSize;
            }
            NewAclSize += NewAceSize;

        }
    }


    //
    // We have the length of the new ACE, but we've calculated
    // it with a ULONG.  It must fit into a USHORT.  See if it
    // does.
    //

    if (NewAclSize > 0xFFFF) {
        return STATUS_BAD_INHERITANCE_ACL;
    }

    (*NewAclSizeParam) = NewAclSize;

    return AclOverflowed ? STATUS_BUFFER_TOO_SMALL : STATUS_SUCCESS;

}


NTSTATUS
RtlpInheritAcl2 (
    IN PACL DirectoryAcl,
    IN PACL ChildAcl,
    IN ULONG ChildGenericControl,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN BOOLEAN DefaultDescriptorForObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN PULONG AclBufferSize,
    IN OUT PUCHAR AclBuffer,
    OUT PBOOLEAN NewAclExplicitlyAssigned,
    OUT PULONG NewGenericControl
    )

/*++

Routine Description:

    This is a private routine that produces an inherited acl from
    a parent acl according to the rules of inheritance

Arguments:

    DirectoryAcl - Supplies the acl being inherited.

    ChildAcl - Supplies the acl associated with the object.  This
        is either the current acl on the object or the acl being assigned
        to the object.

    ChildGenericControl - Specifies the control flags from the SecurityDescriptor
        describing the ChildAcl:

        SEP_ACL_PRESENT: Specifies that the child ACL is explictly supplied by
            the caller.

        SEP_ACL_DEFAULTED: Specifies that the child ACL was supplied by some
            defaulting mechanism.

        SEP_ACL_PROTECTED: Specifies that the child ACL is protected and
            should not inherit any ACE from the DirectoryACL

    IsDirectoryObject - Specifies if the new acl is for a directory.

    AutoInherit - Specifies if the inheritance is an "automatic inheritance".
        As such, the non-inherited ACEs from the ChildAcl will be preserved and
        the inherited ACEs from the DirectoryAcl will be marked as such.

    DefaultDescriptorForObject - If set, the CreatorDescriptor
        is the default descriptor for ObjectType.  As such, the
        CreatorDescriptor will be ignored if any ObjectType specific
        ACEs are inherited from the parent.  If not such ACEs are inherited,
        the CreatorDescriptor is handled as though this flag were not
        specified.

    OwnerSid - Specifies the owner Sid to use.

    GroupSid - Specifies the group SID to use.

    GenericMapping - Specifies the generic mapping to use.

    IsSacl - True if this is the SACL.  False if this is the DACL.

    pNewObjectType - List of types of object being inherited to.  If not 
        specified, the object has no object type.

    GuidCount - Number of object types in the list.

    AclBufferSize - On input, specifies the size of AclBuffer.
        On output, on success, returns the used size of AclBuffer.
        On output, if the buffer is too small, returns the required size of AclBuffer.

    AclBuffer - Receives a pointer to the new (inherited) acl.

    NewAclExplicitlyAssigned - Returns true to indicate that some portion of
        "NewAcl" was derived from an the explicit ChildAcl

    NewGenericControl - Specifies the control flags for the newly
        generated ACL.

        SEP_ACL_AUTO_INHERITED: Set if the ACL was generated using the
            Automatic Inheritance algorithm.

        SEP_ACL_PROTECTED: Specifies that the ACL is protected and
            was not inherited from the parent ACL.

Return Value:

    STATUS_SUCCESS - An inheritable ACL was successfully generated.

    STATUS_NO_INHERITANCE - An inheritable ACL was not successfully generated.
        This is a warning completion status.  The caller should use the default
        ACL.

    STATUS_BAD_INHERITANCE_ACL - Indicates the acl built was not a valid ACL.
        This can be caused by a number of things.  One of the more probable
        causes is the replacement of a CreatorId with an SID that didn't fit
        into the ACE or ACL.

    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that
        is unknown to this routine.

    STATUS_BUFFER_TOO_SMALL - The ACL specified by NewAcl is too small for the
        inheritance ACEs.  The required size is returned in AclBufferSize.

--*/

{
    NTSTATUS Status;
    ULONG ChildNewAclSize = 0;
    ULONG UsedChildNewAclSize = 0;
    ULONG DirectoryNewAclSize = 0;
    ULONG AclRevision;
    USHORT ChildAceCount;
    PVOID ChildAcePosition;
    PVOID DirectoryAcePosition;
    BOOLEAN AclOverflowed = FALSE;
    BOOLEAN AclProtected = FALSE;
    BOOLEAN NullAclOk = TRUE;
    BOOLEAN ObjectAceInherited;

    RTL_PAGED_CODE();


    //
    // Assume the ACL revision.
    //

    AclRevision = ACL_REVISION;
    RtlCreateAcl( (PACL)AclBuffer, *AclBufferSize, AclRevision );
    *NewAclExplicitlyAssigned = FALSE;
    *NewGenericControl = AutoInherit ? SEP_ACL_AUTO_INHERITED : 0;

    //
    // If the a current child ACL is not defaulted,
    //  the non-inherited ACEs from the current child ACL are to be preserved.
    //

    if ( (ChildGenericControl & SEP_ACL_DEFAULTED) == 0 ) {

        //
        // The resultant ACL should be protected if the input ACL is
        //  protected.
        //

        if ( ChildGenericControl & SEP_ACL_PROTECTED ) {
            AclProtected = TRUE;
            *NewGenericControl |= SEP_ACL_PROTECTED;
        }

        //
        // Only copy ACEs if the child ACL is actually present.
        //
        if ( (ChildGenericControl & (SEP_ACL_PRESENT|SEP_ACL_PROTECTED)) != 0 ) {


            if ( ChildAcl != NULL ) {
                ACE_TYPE_TO_COPY AceTypeToCopy;
                UCHAR AceFlagsToReset;
                BOOLEAN MapSids;


                AclRevision = max( AclRevision, ChildAcl->AclRevision );

                //
                // Since we're explicitly using the ACL specified by the caller,
                //  we never want to return a NULL ACL.
                //  Rather, if we have an ACL with no ACEs,
                //  we'll return exactly that.  For a DACL, that results
                //  in a DACL that grants no access rather than a DACL
                //  that grants all access.
                //

                NullAclOk = FALSE;

                //
                // If the caller doesn't understand auto inheritance,
                //  simply preserve the specified ACL 100% intact.
                //
                if ( !AutoInherit ) {

                    AceTypeToCopy = CopyAllAces;
                    AceFlagsToReset = 0;      // Don't turn off any ACE Flags
                    MapSids = FALSE;          // For backward compatibility

                //
                // If the child is protected,
                //  keep all of the ACEs turning off the INHERITED ACE flags.
                //
                } else if ( ChildGenericControl & SEP_ACL_PROTECTED ) {

                    AceTypeToCopy = CopyAllAces;
                    AceFlagsToReset = INHERITED_ACE; // Turn off all INHERITED_ACE flags
                    MapSids = TRUE;

                //
                // If the child is not protected,
                //  just copy the non-inherited ACEs.
                //
                // (The inherited ACEs will be recomputed from the parent.)
                //
                } else {

                    AceTypeToCopy = CopyNonInheritedAces;
                    AceFlagsToReset = 0;      // Don't turn off any ACE Flags
                    MapSids = TRUE;

                }

                //
                // Copy the requested ACEs.
                //

                Status = RtlpCopyAces(
                            ChildAcl,
                            GenericMapping,
                            AceTypeToCopy,
                            AceFlagsToReset,
                            MapSids,
                            OwnerSid,
                            GroupSid,
                            ServerOwnerSid,
                            ServerGroupSid,
                            IsDirectoryObject,
                            FALSE, // Do not retain INHERITED_ACE bit for effective aces
                            &ChildNewAclSize,
                            (PACL)AclBuffer );

                UsedChildNewAclSize = ChildNewAclSize;
                if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                    AclOverflowed = TRUE;
                    Status = STATUS_SUCCESS;
                }

                if ( !NT_SUCCESS(Status) ) {
                    return Status;
                }

                //
                // If this ACL might be ignored later,
                //  remember the current state of the ACL.
                //

                if ( DefaultDescriptorForObject && ChildNewAclSize != 0 ) {
                    ChildAceCount = ((PACL)AclBuffer)->AceCount;

                    if (!RtlFirstFreeAce( (PACL)AclBuffer, &ChildAcePosition ) ) {
                        return STATUS_BAD_INHERITANCE_ACL;
                    }
                }

            //
            // If the ACL isn't protected,
            //  don't allow NULL ACL semantics.
            //  (those semantics are ambiguous for auto inheritance)
            //
            } else if ( AutoInherit &&
                        !IsSacl &&
                        (ChildGenericControl & (SEP_ACL_PRESENT|SEP_ACL_PROTECTED)) == SEP_ACL_PRESENT ) {
                return STATUS_INVALID_ACL;

            }

            *NewAclExplicitlyAssigned = TRUE;

        }

    }

    //
    // Inherit ACEs from the Directory ACL in any of the following cases:
    //  If !AutoInheriting,
    //      Inherit if there is no explicit child ACL (ignoring a defaulted child).
    //  If AutoInheriting,
    //      observe the protected flag.
    //

    if ( (!AutoInherit &&
            (ChildGenericControl & SEP_ACL_PRESENT) == 0 ||
                (ChildGenericControl & SEP_ACL_DEFAULTED) != 0) ||
         (AutoInherit && !AclProtected) ) {

        //
        //  If there is no directory ACL,
        //      don't inherit from it.
        //

        if ( DirectoryAcl != NULL ) {

            //
            // If the DirectoryAcl is used,
            //  the revision of the Directory ACL is picked up.
            //

            if ( !ValidAclRevision(DirectoryAcl) ) {
                return STATUS_UNKNOWN_REVISION;
            }

            AclRevision = max( AclRevision, DirectoryAcl->AclRevision );

            //
            // Inherit the Parent's ACL.
            //

            Status = RtlpGenerateInheritAcl(
                         DirectoryAcl,
                         IsDirectoryObject,
                         AutoInherit,
                         OwnerSid,
                         GroupSid,
                         ServerOwnerSid,
                         ServerGroupSid,
                         GenericMapping,
                         pNewObjectType,
                         GuidCount,
                         &DirectoryNewAclSize,
                         (PACL)AclBuffer,
                         &ObjectAceInherited );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                AclOverflowed = TRUE;
                Status = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

            //
            // If the default descriptor for the object should be ditched,
            //  because object specific ACEs were inherited from the directory,
            //  ditch them now.
            //

            if ( DefaultDescriptorForObject &&
                 ChildNewAclSize != 0 &&
                 ObjectAceInherited &&
                 !AclOverflowed ) {

                //
                // Compute the last used byte of the combined ACL
                //
                if (!RtlFirstFreeAce( (PACL)AclBuffer, &DirectoryAcePosition ) ) {
                    return STATUS_BAD_INHERITANCE_ACL;
                }
                if ( DirectoryAcePosition == NULL ) {
                    DirectoryAcePosition = AclBuffer + ((PACL)AclBuffer)->AclSize;
                }



                //
                // Move all the inherited ACEs to the front of the ACL.
                //

                RtlMoveMemory( FirstAce( AclBuffer ),
                               ChildAcePosition,
                               (ULONG)(((PUCHAR)DirectoryAcePosition) -
                                (PUCHAR)ChildAcePosition) );

                //
                // Adjust the ACE count to remove the deleted ACEs
                //

                ((PACL)AclBuffer)->AceCount -= ChildAceCount;

                //
                // Save the number of bytes of the Child ACL that were
                //  actually used.
                //

                UsedChildNewAclSize = 0;

            }
        }

    }

    //
    // If this routine didn't build the ACL,
    //  tell the caller.
    //

    if ( DirectoryNewAclSize + UsedChildNewAclSize == 0) {

        //
        // If the ACL was not explicitly assigned,
        //  tell the caller to default the ACL.
        //
        if ( !(*NewAclExplicitlyAssigned) ) {
            *AclBufferSize = 0;
            return STATUS_NO_INHERITANCE;

        //
        // If the Acl was explictly assigned,
        //  generate a NULL ACL based on the path taken above.
        //

        } else if ( NullAclOk ) {
            *AclBufferSize = 0;
            return STATUS_SUCCESS;
        }

        // DbgBreakPoint();
    }


    //
    // And make sure we don't exceed the length limitations of an ACL (WORD)
    //

    if ( DirectoryNewAclSize + UsedChildNewAclSize + sizeof(ACL) > 0xFFFF) {
        return(STATUS_BAD_INHERITANCE_ACL);
    }

    // The caller has to allocate a buffer large enough for
    // ChildNewAclSize rather than UsedChildNewAclSize.  Due to the nature of
    // my algorithm above.
    (*AclBufferSize) = DirectoryNewAclSize + ChildNewAclSize + sizeof(ACL);

    if ( AclOverflowed ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Patch the real ACL size and revision into the ACL
    //

    ((PACL)AclBuffer)->AclSize = (USHORT)
        (DirectoryNewAclSize + UsedChildNewAclSize + sizeof(ACL));
    ((PACL)AclBuffer)->AclRevision = (UCHAR) AclRevision;

    return STATUS_SUCCESS;
}



NTSTATUS
RtlpInheritAcl (
    IN PACL DirectoryAcl,
    IN PACL ChildAcl,
    IN ULONG ChildGenericControl,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN BOOLEAN DefaultDescriptorForObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    OUT PACL *NewAcl,
    OUT PBOOLEAN NewAclExplicitlyAssigned,
    OUT PULONG NewGenericControl
    )

/*++

Routine Description:

    This is a private routine that produces an inherited acl from
    a parent acl according to the rules of inheritance

Arguments:

    DirectoryAcl - Supplies the acl being inherited.

    ChildAcl - Supplies the acl associated with the object.  This
        is either the current acl on the object or the acl being assigned
        to the object.

    ChildGenericControl - Specifies the control flags from the SecurityDescriptor
        describing the ChildAcl:

        SEP_ACL_PRESENT: Specifies that the child ACL is explictly supplied by
            the caller.

        SEP_ACL_DEFAULTED: Specifies that the child ACL was supplied by some
            defaulting mechanism.

        SEP_ACL_PROTECTED: Specifies that the child ACL is protected and
            should not inherit any ACE from the DirectoryACL

    IsDirectoryObject - Specifies if the new acl is for a directory.

    AutoInherit - Specifies if the inheritance is an "automatic inheritance".
        As such, the non-inherited ACEs from the ChildAcl will be preserved and
        the inherited ACEs from the DirectoryAcl will be marked as such.

    DefaultDescriptorForObject - If set, the CreatorDescriptor
        is the default descriptor for ObjectType.  As such, the
        CreatorDescriptor will be ignored if any ObjectType specific
        ACEs are inherited from the parent.  If not such ACEs are inherited,
        the CreatorDescriptor is handled as though this flag were not
        specified.

    OwnerSid - Specifies the owner Sid to use.

    GroupSid - Specifies the group SID to use.

    GenericMapping - Specifies the generic mapping to use.

    IsSacl - True if this is the SACL.  False if this is the DACL.

    pNewObjectType - List of types of object being inherited to.  If not 
        specified, the object has no object type.

    GuidCount - Number of object types in the list.

    NewAcl - Receives a pointer to the new (inherited) acl.

    NewAclExplicitlyAssigned - Returns true to indicate that some portion of
        "NewAcl" was derived from an the explicit ChildAcl

    NewGenericControl - Specifies the control flags for the newly
        generated ACL.

        SEP_ACL_AUTO_INHERITED: Set if the ACL was generated using the
            Automatic Inheritance algorithm.

        SEP_ACL_PROTECTED: Specifies that the ACL is protected and
            was not inherited from the parent ACL.

Return Value:

    STATUS_SUCCESS - An inheritable ACL was successfully generated.

    STATUS_NO_INHERITANCE - An inheritable ACL was not successfully generated.
        This is a warning completion status.

    STATUS_BAD_INHERITANCE_ACL - Indicates the acl built was not a valid ACL.
        This can be caused by a number of things.  One of the more probable
        causes is the replacement of a CreatorId with an SID that didn't fit
        into the ACE or ACL.

    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that
        is unknown to this routine.

--*/

{
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//   The logic in the ACL inheritance code must mirror the code for         //
//   inheritance in the executive (in seassign.c).  Do not make changes     //
//   here without also making changes in that module.                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////



    NTSTATUS Status;
    ULONG AclBufferSize;
    ULONG i;

    RTL_PAGED_CODE();

    //
    // Implement a two pass strategy.
    //
    // First try to create the ACL in a fixed length buffer.
    // If that is too small,
    //  then use the buffer size determined on the first pass
    //

    AclBufferSize = 200;
    for ( i=0; i<2 ; i++ ) {

        //
        // Allocate heap for the new ACL.
        //

        (*NewAcl) = ExAllocatePoolWithTag(
                        PagedPool,
                        AclBufferSize,
                        'cAeS' );

        if ((*NewAcl) == NULL ) {
            return( STATUS_NO_MEMORY );
        }

        //
        // Actually build the inherited ACL.
        //

        Status = RtlpInheritAcl2 (
                    DirectoryAcl,
                    ChildAcl,
                    ChildGenericControl,
                    IsDirectoryObject,
                    AutoInherit,
                    DefaultDescriptorForObject,
                    OwnerSid,
                    GroupSid,
                    ServerOwnerSid,
                    ServerGroupSid,
                    GenericMapping,
                    IsSacl,
                    pNewObjectType,
                    GuidCount,
                    &AclBufferSize,
                    (PUCHAR) *NewAcl,
                    NewAclExplicitlyAssigned,
                    NewGenericControl );


        if ( NT_SUCCESS(Status) ) {

            //
            // If a NULL ACL should be used,
            //  tell the caller.
            //

            if ( AclBufferSize == 0 ) {

                ExFreePool( *NewAcl );

                *NewAcl = NULL;
            }

            break;

        } else {
            ExFreePool( *NewAcl );

            *NewAcl = NULL;

            if ( Status != STATUS_BUFFER_TOO_SMALL ) {
                break;
            }
        }
    }


    return Status;
}


NTSTATUS
RtlpGenerateInheritedAce (
    IN PACE_HEADER OldAce,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    OUT PULONG NewAceLength,
    OUT PACL NewAcl,
    OUT PULONG NewAceExtraLength,
    OUT PBOOLEAN ObjectAceInherited
    )

/*++

Routine Description:

    This is a private routine that checks if the input ace is inheritable
    and produces 0, 1, or 2 inherited aces in the given buffer.

Arguments:

    OldAce - Supplies the ace being inherited

    IsDirectoryObject - Specifies if the new ACE is for a directory

    AutoInherit - Specifies if the inheritance is an "automatic inheritance".
        As such, the inherited ACEs will be marked as such.

    ClientOwnerSid - Specifies the owner Sid to use

    ClientGroupSid - Specifies the new Group Sid to use

    ServerSid - Optionally specifies the Server Sid to use in compound ACEs.

    ClientSid - Optionally specifies the Client Sid to use in compound ACEs.

    GenericMapping - Specifies the generic mapping to use

    pNewObjectType - List of types of object being inherited to.  If not 
        specified, the object has no object type.

    GuidCount - Number of object types in the list.

    NewAceLength - Receives the length (number of bytes) needed to allow for
        the inheritance of the specified ACE.  This might be zero.

    NewAcl - Provides a pointer to the ACL into which the ACE is to be
        inherited.

    NewAceExtraLength - Receives a length (number of bytes) temporarily used
        in the ACL for the inheritance ACE.  This might be zero

    ObjectAceInherited - Returns true if one or more object ACEs were inherited
        based on NewObjectType

Return Value:

    STATUS_SUCCESS - The ACE was inherited successfully.

    STATUS_BAD_INHERITANCE_ACL - Indicates something went wrong preventing
        the ACE from being inherited.  This generally represents a bugcheck
        situation when returned from this call.

    STATUS_BUFFER_TOO_SMALL - The ACL specified by NewAcl is too small for the
        inheritance ACEs.  The required size is returned in NewAceLength.


--*/

{
    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // The inheritance flags AND the sid of the ACE determine whether        //
    // we need 0, 1, or 2 ACEs.                                              //
    //                                                                       //
    // BE CAREFUL WHEN CHANGING THIS CODE.  READ THE DSA ACL ARCHITECTURE    //
    // SECTION COVERING INHERITANCE BEFORE ASSUMING YOU KNOW WHAT YOU ARE    //
    // DOING!!!!                                                             //
    //                                                                       //
    // The general gist of the algorithm is:                                 //
    //                                                                       //
    //       if ( (container  && ContainerInherit) ||                        //
    //            (!container && ObjectInherit)      ) {                     //
    //               GenerateEffectiveAce;                                   //
    //       }                                                               //
    //                                                                       //
    //                                                                       //
    //       if (Container && Propagate) {                                   //
    //           Propagate copy of ACE and set InheritOnly;                  //
    //       }                                                               //
    //                                                                       //
    //                                                                       //
    // A slightly more accurate description of this algorithm is:            //
    //                                                                       //
    //   IO  === InheritOnly flag                                            //
    //   CI  === ContainerInherit flag                                       //
    //   OI  === ObjectInherit flag                                          //
    //   NPI === NoPropagateInherit flag                                     //
    //                                                                       //
    //   if ( (container  && CI) ||                                          //
    //        (!container && OI)   ) {                                       //
    //       Copy Header of ACE;                                             //
    //       Clear IO, NPI, CI, OI;                                          //
    //                                                                       //
    //       if (KnownAceType) {                                             //
    //           if (SID is a creator ID) {                                  //
    //               Copy appropriate creator SID;                           //
    //           } else {                                                    //
    //               Copy SID of original;                                   //
    //           }                                                           //
    //                                                                       //
    //           Copy AccessMask of original;                                //
    //           MapGenericAccesses;                                         //
    //           if (AccessMask == 0) {                                      //
    //               discard new ACE;                                        //
    //           }                                                           //
    //                                                                       //
    //       } else {                                                        //
    //           Copy body of ACE;                                           //
    //       }                                                               //
    //                                                                       //
    //   }                                                                   //
    //                                                                       //
    //   if (!NPI) {                                                         //
    //       Copy ACE as is;                                                 //
    //       Set IO;                                                         //
    //   }                                                                   //
    //                                                                       //
    //                                                                       //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////



    ULONG LengthRequired = 0;
    ULONG ExtraLengthRequired = 0;
    PVOID AcePosition;
    PVOID EffectiveAcePosition;
    ULONG EffectiveAceSize = 0;

    BOOLEAN EffectiveAceMapped;
    BOOLEAN AclOverflowed = FALSE;
    BOOLEAN GenerateInheritAce;

    RTL_PAGED_CODE();

    //
    //  This is gross and ugly, but it's better than allocating
    //  virtual memory to hold the ClientSid, because that can
    //  fail, and propagating the error back is a tremendous pain
    //

    ASSERT(RtlLengthRequiredSid( 1 ) == CREATOR_SID_SIZE);
    *ObjectAceInherited = FALSE;
    GenerateInheritAce = IsDirectoryObject && Propagate(OldAce);

    //
    // Allocate and initialize the universal SIDs we're going to need
    // to look for inheritable ACEs.
    //

    if (!RtlFirstFreeAce(NewAcl, &AcePosition) || (AcePosition == NULL)) {
        return STATUS_BAD_INHERITANCE_ACL;
    }

    //
    //  check to see if we will have a effective ACE (one mapped to
    //  the target object type).
    //

    if ( (IsDirectoryObject  && ContainerInherit(OldAce)) ||
         (!IsDirectoryObject && ObjectInherit(OldAce))      ) {


        //
        // Remember where the effective ACE will be copied to.
        //
        EffectiveAcePosition = AcePosition;

        //
        // Copy the effective ACE into the ACL.
        //
        if ( !RtlpCopyEffectiveAce (
                        OldAce,
                        AutoInherit,
                        GenerateInheritAce,
                        ClientOwnerSid,
                        ClientGroupSid,
                        ServerOwnerSid,
                        ServerGroupSid,
                        GenericMapping,
                        pNewObjectType,
                        GuidCount,
                        &AcePosition,
                        &EffectiveAceSize,
                        NewAcl,
                        ObjectAceInherited,
                        &EffectiveAceMapped,
                        &AclOverflowed ) ) {

            return STATUS_BAD_INHERITANCE_ACL;
        }

        //
        // If the effective ACE is a duplicate of existing inherited ACEs,
        //  Don't really generate it.
        //

        if ( !AclOverflowed &&
             EffectiveAceSize > 0 &&
             EffectiveAcePosition != NULL &&
                RtlpIsDuplicateAce(
                    NewAcl,
                    EffectiveAcePosition ) ) {


            //
            // Truncate the ACE we just added.
            //

            NewAcl->AceCount--;
            AcePosition = EffectiveAcePosition;
            ExtraLengthRequired = max( ExtraLengthRequired, EffectiveAceSize );
            EffectiveAceSize = 0;
        }

        LengthRequired += EffectiveAceSize;

    }

    //
    // If we are inheriting onto a container, then we may need to
    // propagate the inheritance as well.
    //

    if ( GenerateInheritAce ) {

        //
        // If a effective ACE was created,
        //  and it wasn't mapped,
        //  avoid generating another ACE and simply merge the inheritance bits into
        //      the effective ACE.
        //

        if ( EffectiveAceSize != 0 && !EffectiveAceMapped ) {

           //
           // Copy the inherit bits from the original ACE.
           //
           if ( !AclOverflowed ) {
               ((PACE_HEADER)EffectiveAcePosition)->AceFlags |=
                    ((PACE_HEADER)OldAce)->AceFlags & (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE);
               if ( AutoInherit ) {
                   ((PACE_HEADER)EffectiveAcePosition)->AceFlags |= INHERITED_ACE;
               }
           }


        //
        // Otherwise, generate an explicit inheritance ACE.
        //
        // But only if the access mask isn't zero.
        //

        } else if ( !IsMSAceType(OldAce) || ((PKNOWN_ACE)(OldAce))->Mask != 0 ) {

            //
            // Account for the new ACE being added to the ACL.
            //
            LengthRequired += (ULONG)(((PACE_HEADER)OldAce)->AceSize);

            if (LengthRequired > 0xFFFF) {
                return STATUS_BAD_INHERITANCE_ACL;
            }

            //
            // If the ACE doesn't fit,
            //  just note the fact and don't copy the ACE.
            //

            if ( ((PACE_HEADER)OldAce)->AceSize > NewAcl->AclSize - ((PUCHAR)AcePosition - (PUCHAR)NewAcl) ) {
                AclOverflowed = TRUE;
            } else if (!AclOverflowed){

                //
                // copy it as is, but make sure the InheritOnly bit is set.
                //

                RtlCopyMemory(
                    AcePosition,
                    OldAce,
                    ((PACE_HEADER)OldAce)->AceSize
                    );

                ((PACE_HEADER)AcePosition)->AceFlags |= INHERIT_ONLY_ACE;
                NewAcl->AceCount += 1;
                if ( AutoInherit ) {
                    ((PACE_HEADER)AcePosition)->AceFlags |= INHERITED_ACE;

                    //
                    // If the inheritance ACE is a duplicate of existing inherited ACEs,
                    //  Don't really generate it.
                    //

                    if ( RtlpIsDuplicateAce(
                                NewAcl,
                                AcePosition ) ) {


                        //
                        // Truncate the ACE we just added.
                        //

                        NewAcl->AceCount--;
                        ExtraLengthRequired = max( ExtraLengthRequired,
                                                   ((PACE_HEADER)OldAce)->AceSize );
                        LengthRequired -= (ULONG)(((PACE_HEADER)OldAce)->AceSize);
                    }
                }

            }
        }
    }

    //
    //  Now return to our caller
    //

    (*NewAceLength) = LengthRequired;
    (*NewAceExtraLength) = ExtraLengthRequired;

    return AclOverflowed ? STATUS_BUFFER_TOO_SMALL : STATUS_SUCCESS;
}


NTSTATUS
RtlpGenerateInheritAcl(
    IN PACL Acl,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    OUT PULONG NewAclSizeParam,
    OUT PACL NewAcl,
    OUT PBOOLEAN ObjectAceInherited
    )

/*++

Routine Description:

    This is a private routine that produces an inheritable ACL.

    The buffer to contain the inherted ACL is passed in.  If the buffer is
    too small, the corect size is computed and STATUS_BUFFER_TOO_SMALL is
    returned.

Arguments:

    Acl - Supplies the acl being inherited.

    IsDirectoryObject - Specifies if the new acl is for a directory.

    AutoInherit - Specifies if the inheritance is an "automatic inheritance".
        As such, the inherited ACEs will be marked as such.

    OwnerSid - Specifies the owner Sid to use.

    GroupSid - Specifies the group SID to use.

    GenericMapping - Specifies the generic mapping to use.

    pNewObjectType - List of types of object being inherited to.  If not 
        specified, the object has no object type.

    GuidCount - Number of object types in the list.

    NewAclSizeParam - Receives the length of the inherited ACL.

    NewAcl - Provides a pointer to the buffer to receive the new
        (inherited) acl.  This ACL must already be initialized.

    ObjectAceInherited - Returns true if one or more object ACEs were inherited
        based on NewObjectType


Return Value:

    STATUS_SUCCESS - An inheritable ACL has been generated.

    STATUS_BAD_INHERITANCE_ACL - Indicates the acl built was not a valid ACL.
        This can be caused by a number of things.  One of the more probable
        causes is the replacement of a CreatorId with an SID that didn't fit
        into the ACE or ACL.

    STATUS_BUFFER_TOO_SMALL - The ACL specified by NewAcl is too small for the
        inheritance ACEs.  The required size is returned in NewAceLength.


--*/

{

    NTSTATUS Status;
    ULONG i;

    PACE_HEADER OldAce;
    ULONG NewAclSize, NewAceSize;
    ULONG NewAclExtraSize, NewAceExtraSize;
    BOOLEAN AclOverflowed = FALSE;
    BOOLEAN LocalObjectAceInherited;


    RTL_PAGED_CODE();

    //
    // Walk through the original ACL generating any necessary
    // inheritable ACEs.
    //

    NewAclSize = 0;
    NewAclExtraSize = 0;
    *ObjectAceInherited = FALSE;
    for (i = 0, OldAce = FirstAce(Acl);
         i < Acl->AceCount;
         i += 1, OldAce = NextAce(OldAce)) {

        //
        //  RtlpGenerateInheritedAce() will generate the ACE(s) necessary
        //  to inherit a single ACE.  This may be 0, 1, or more ACEs.
        //

        Status = RtlpGenerateInheritedAce(
                     OldAce,
                     IsDirectoryObject,
                     AutoInherit,
                     ClientOwnerSid,
                     ClientGroupSid,
                     ServerOwnerSid,
                     ServerGroupSid,
                     GenericMapping,
                     pNewObjectType,
                     GuidCount,
                     &NewAceSize,
                     NewAcl,
                     &NewAceExtraSize,
                     &LocalObjectAceInherited
                     );

        if ( Status == STATUS_BUFFER_TOO_SMALL ) {
            AclOverflowed = TRUE;
            Status = STATUS_SUCCESS;
        }

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        if ( LocalObjectAceInherited ) {
            *ObjectAceInherited = TRUE;
        }

        //
        // Make room in the ACL for the new ACE
        //
        NewAclSize += NewAceSize;

        //
        // If a previous ACE needed 'extra' space,
        //  reduce that requirement by the size of this ACE.
        //
        // The previous ACE can use this ACE's space temporarily
        //
        if ( NewAceSize > NewAclExtraSize ) {
            NewAclExtraSize = 0 ;
        } else {
            NewAclExtraSize -= NewAceSize;
        }

        //
        // The 'extra' space needed is the larger of that needed by any
        //  previous ACE and that need by this ACE
        //
        NewAclExtraSize = max( NewAclExtraSize, NewAceExtraSize );

    }

    //
    // We only need to include the "ExtraSize" if we've overflowed.
    //  In those cases, the caller will allocate the size we requested and
    //  try again.  Otherwise, the caller won't call back so we don't care
    //  if it knows about the extra size.
    //

    if ( AclOverflowed ) {
        (*NewAclSizeParam) = NewAclSize + NewAclExtraSize;
        return STATUS_BUFFER_TOO_SMALL;
    } else {
        (*NewAclSizeParam) = NewAclSize;
        return STATUS_SUCCESS;
    }

}


NTSTATUS
RtlpComputeMergedAcl2 (
    IN PACL CurrentAcl,
    IN ULONG CurrentGenericControl,
    IN PACL ModificationAcl,
    IN ULONG ModificationGenericControl,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    IN PULONG AclBufferSize,
    IN OUT PUCHAR AclBuffer,
    OUT PULONG NewGenericControl
    )

/*++

Routine Description:

    This routine implements the 'set' semantics for auto inheritance.

    This routine builds the actual ACL that should be set on an object.
    The built ACL is a composite of the previous ACL on an object and
    the newly set ACL on the object.  The New ACL is built as follows:

    If SEP_ACL_PROTECTED is set in neither CurrentAcl nor ModificationAcl,
    the NewAcl is constructed from the inherited ACEs from the
    CurrentAcl and the non-inherited ACEs from the ModificationAcl.
    (That is, it is impossible to edit an inherited ACE by changing the
    ACL on an object.)

    If SEP_ACL_PROTECTED is set on ModificationAcl, CurrentAcl is ignored.
    NewAcl is built as a copy of ModificationAcl with any INHERITED_ACE
    bits turned off.

    If SEP_ACL_PROTECTED is set on CurrentAcl and not ModificationAcl, the
    CurrentAcl is ignored.  NewAcl is built as a copy of
    ModificationDescriptor.  It is the callers responsibility to ensure
    that the correct ACEs have the INHERITED_ACE bit turned on.

Arguments:

    CurrentAcl - The current ACL on the object.

    CurrentGenericControl - Specifies the control flags from the SecurityDescriptor
        describing the CurrentAcl.

    ModificationAcl - The ACL being applied to the object.

    ModificationGenericControl - Specifies the control flags from the SecurityDescriptor
        describing the CurrentAcl.

    ClientOwnerSid - Specifies the owner Sid to use

    ClientGroupSid - Specifies the new Group Sid to use

    GenericMapping - The mapping of generic to specific and standard
                     access types.

    IsSacl - True if this is the SACL.  False if this is the DACL.

    AclBufferSize - On input, specifies the size of AclBuffer.
        On output, on success, returns the used size of AclBuffer.
        On output, if the buffer is too small, returns the required size of AclBuffer.

    AclBuffer - Receives a pointer to the new (inherited) acl.

    NewGenericControl - Specifies the control flags for the newly
        generated ACL.

        Only the Protected and AutoInherited bits are returned.

Return Value:

    STATUS_SUCCESS - An ACL was successfully generated.

    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that
        is unknown to this routine.

--*/

{
    NTSTATUS Status;
    ULONG ModificationNewAclSize = 0;
    ULONG CurrentNewAclSize = 0;
    ULONG AclRevision;
    BOOLEAN AclOverflowed = FALSE;
    BOOLEAN NullAclOk = TRUE;

    RTL_PAGED_CODE();


    //
    // Assume the ACL revision.
    //

    AclRevision = ACL_REVISION;
    RtlCreateAcl( (PACL)AclBuffer, *AclBufferSize, AclRevision );

    //
    // This routine is only called for the AutoInheritance case.
    //

    *NewGenericControl = SEP_ACL_AUTO_INHERITED;

    //
    // If the new ACL is protected,
    //  simply use the new ACL with the INHERITED_ACE bits turned off.
    //

    if ( (ModificationGenericControl & SEP_ACL_PROTECTED) != 0 ) {

        //
        // Set the Control bits for the resultant descriptor.
        //

        *NewGenericControl |= SEP_ACL_PROTECTED;

        //
        // Only copy the ACL if it is actually present
        //

        if ( ModificationAcl != NULL ) {

            AclRevision = max( AclRevision, ModificationAcl->AclRevision );

            //
            // Copy all ACES, turn off the inherited bit, and generic map them.
            //

            Status = RtlpCopyAces(
                        ModificationAcl,
                        GenericMapping,
                        CopyAllAces,
                        INHERITED_ACE,  // Turn off all INHERITED_ACE flags
                        TRUE,           // Map sids as needed
                        ClientOwnerSid,
                        ClientGroupSid,
                        ClientOwnerSid, // Not technically correct. s.b. server sid
                        ClientGroupSid, // Not technically correct. s.b. server sid
                        TRUE,           // Assume container and skip optimization
                        FALSE,          // Do not retain INHERITED_ACE bit for effective aces
                        &ModificationNewAclSize,
                        (PACL)AclBuffer );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                AclOverflowed = TRUE;
                Status = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

            //
            // If the caller specified an ACL with no ACES,
            //  make sure we generate an ACL with no ACES.
            //

            NullAclOk = FALSE;
        }

    //
    // If the old ACL is protected but the new one isn't,
    //  simply use the new ACL as is.
    //
    // Rely on the caller to get the INHERITED_ACE bits right.
    //

    } else if ( (CurrentGenericControl & SEP_ACL_PROTECTED) != 0 ) {

        //
        // Only do the copy if the new ACL is specified.
        //

        if ( ModificationAcl != NULL ) {
            AclRevision = max( AclRevision, ModificationAcl->AclRevision );

            //
            // Copy all ACES, and generic map them.
            //

            Status = RtlpCopyAces(
                        ModificationAcl,
                        GenericMapping,
                        CopyAllAces,
                        0,
                        TRUE,           // Map sids as needed
                        ClientOwnerSid,
                        ClientGroupSid,
                        ClientOwnerSid, // Not technically correct. s.b. server sid
                        ClientGroupSid, // Not technically correct. s.b. server sid
                        TRUE,           // Assume container and skip optimization
                        TRUE,           // Retain INHERITED_ACE bit for effective aces
                        &ModificationNewAclSize,
                        (PACL)AclBuffer );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                AclOverflowed = TRUE;
                Status = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

            //
            // If the caller specified an ACL with no ACES,
            //  make sure we generate an ACL with no ACES.
            //

            NullAclOk = FALSE;

        //
        // Since the ACL isn't protected,
        //  don't allow NULL ACL semantics.
        //  (those semantics are ambiguous for auto inheritance)
        //
        } else if ( !IsSacl ) {
            return STATUS_INVALID_ACL;
        }


    //
    // If neither are protected,
    //  use the non-inherited ACEs from the new ACL, and
    //  preserve the inherited ACEs from the old ACL.
    //

    } else {

        //
        // NULL ACLs are always OK for a SACL.
        // NULL ACLs are never OK for a non-protected DACL.
        //

        NullAclOk = IsSacl;


        //
        // Only do the copy if the new ACL is specified.
        //

        if ( ModificationAcl != NULL ) {
            AclRevision = max( AclRevision, ModificationAcl->AclRevision );

            //
            // Copy the non-inherited ACES, and generic map them.
            //

            Status = RtlpCopyAces(
                        ModificationAcl,
                        GenericMapping,
                        CopyNonInheritedAces,
                        0,
                        TRUE,           // Map sids as needed
                        ClientOwnerSid,
                        ClientGroupSid,
                        ClientOwnerSid, // Not technically correct. s.b. server sid
                        ClientGroupSid, // Not technically correct. s.b. server sid
                        TRUE,           // Assume container and skip optimization
                        FALSE,          // Do not retain INHERITED_ACE bit for effective aces
                        &ModificationNewAclSize,
                        (PACL)AclBuffer );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                AclOverflowed = TRUE;
                Status = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

            //
            // If the caller specified an ACL with no ACES,
            //  make sure we generate an ACL with no ACES.
            //
            // If inherited aces were deleted, leave the flag alone allowing
            //  a NULL SACL to be generated.
            //

            if ( ModificationAcl->AceCount == 0 ) {
                NullAclOk = FALSE;
            }

        //
        // Since the ACL isn't protected,
        //  don't allow NULL ACL semantics.
        //  (those semantics are ambiguous for auto inheritance)
        //
        } else if ( !IsSacl ) {
            return STATUS_INVALID_ACL;
        }


        //
        // Only do the copy if the old ACL is specified.
        //

        if ( CurrentAcl != NULL ) {

            AclRevision = max( AclRevision, CurrentAcl->AclRevision );


            //
            // Copy the inherited ACES, and generic map them.
            //
            // Don't bother mapping the sids in these ACEs.  They got mapped
            // during inheritance.
            //

            Status = RtlpCopyAces(
                        CurrentAcl,
                        GenericMapping,
                        CopyInheritedAces,
                        0,
                        FALSE,          // Don't map the sids,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        TRUE,           // Assume container and skip optimization
                        FALSE,          // Do not retain INHERITED_ACE bit for effective aces
                        &CurrentNewAclSize,
                        (PACL)AclBuffer );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                AclOverflowed = TRUE;
                Status = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }
        }
    }

    //
    // If this routine didn't build the ACL,
    //  tell the caller to use an explict NULL ACL
    //

    if ( ModificationNewAclSize + CurrentNewAclSize == 0) {
        //
        // If the Acl was explictly assigned,
        //  generate a NULL ACL based on the path taken above.
        //

        if ( NullAclOk ) {
            *AclBufferSize = 0;
            return STATUS_SUCCESS;
        }
    }


    //
    // And make sure we don't exceed the length limitations of an ACL (WORD)
    //

    if ( ModificationNewAclSize + CurrentNewAclSize + sizeof(ACL) > 0xFFFF) {
        return(STATUS_BAD_INHERITANCE_ACL);
    }

    (*AclBufferSize) = ModificationNewAclSize + CurrentNewAclSize + sizeof(ACL);

    if ( AclOverflowed ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Patch the real ACL size and revision into the ACL
    //

    ((PACL)AclBuffer)->AclSize = (USHORT) *AclBufferSize;
    ((PACL)AclBuffer)->AclRevision = (UCHAR) AclRevision;

    return STATUS_SUCCESS;
}


NTSTATUS
RtlpComputeMergedAcl (
    IN PACL CurrentAcl,
    IN ULONG CurrentGenericControl,
    IN PACL ModificationAcl,
    IN ULONG ModificationGenericControl,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    OUT PACL *NewAcl,
    OUT PULONG NewGenericControl
    )

/*++

Routine Description:

    This routine builds the actual ACL that should be set on an object.
    The built ACL is a composite of the previous ACL on an object and
    the newly set ACL on the object.  The New ACL is built as follows:

    If SEP_ACL_PROTECTED is set in neither CurrentAcl nor ModificationAcl,
    the NewAcl is constructed from the inherited ACEs from the
    CurrentAcl and the non-inherited ACEs from the ModificationAcl.
    (That is, it is impossible to edit an inherited ACE by changing the
    ACL on an object.)

    If SEP_ACL_PROTECTED is set on ModificationAcl, CurrentAcl is ignored.
    NewAcl is built as a copy of ModificationAcl with any INHERITED_ACE
    bits turned off.

    If SEP_ACL_PROTECTED is set on CurrentAcl and not ModificationAcl, the
    CurrentAcl is ignored.  NewAcl is built as a copy of
    ModificationDescriptor.  It is the callers responsibility to ensure
    that the correct ACEs have the INHERITED_ACE bit turned on.

Arguments:

    CurrentAcl - The current ACL on the object.

    CurrentGenericControl - Specifies the control flags from the SecurityDescriptor
        describing the CurrentAcl.

    ModificationAcl - The ACL being applied to the object.

    ModificationGenericControl - Specifies the control flags from the SecurityDescriptor
        describing the CurrentAcl.

    ClientOwnerSid - Specifies the owner Sid to use

    ClientGroupSid - Specifies the new Group Sid to use

    GenericMapping - The mapping of generic to specific and standard
                     access types.

    IsSacl - True if this is the SACL.  False if this is the DACL.

    NewAcl - Receives a pointer to the new resultant acl.

    NewGenericControl - Specifies the control flags for the newly
        generated ACL.

        Only the Protected and AutoInherited bits are returned.

Return Value:

    STATUS_SUCCESS - An ACL was successfully generated.

    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that
        is unknown to this routine.

--*/

{
    NTSTATUS Status;
    ULONG AclBufferSize;
    ULONG i;

    RTL_PAGED_CODE();

    //
    // Implement a two pass strategy.
    //
    // First try to create the ACL in a fixed length buffer.
    // If that is too small,
    //  then use the buffer size determined on the first pass
    //

    AclBufferSize = 1024;
    for ( i=0; i<2 ; i++ ) {

        //
        // Allocate heap for the new ACL.
        //

        (*NewAcl) = ExAllocatePoolWithTag(
                        PagedPool,
                        AclBufferSize,
                        'cAeS' );

        if ((*NewAcl) == NULL ) {
            return( STATUS_NO_MEMORY );
        }

        //
        // Merge the ACLs
        //

        Status = RtlpComputeMergedAcl2 (
                    CurrentAcl,
                    CurrentGenericControl,
                    ModificationAcl,
                    ModificationGenericControl,
                    ClientOwnerSid,
                    ClientGroupSid,
                    GenericMapping,
                    IsSacl,
                    &AclBufferSize,
                    (PUCHAR) *NewAcl,
                    NewGenericControl );


        if ( NT_SUCCESS(Status) ) {

            //
            // If a NULL ACL should be used,
            //  tell the caller.
            //

            if ( AclBufferSize == 0 ) {
                ExFreePool( *NewAcl );
                *NewAcl = NULL;
            }

            break;

        } else {
            ExFreePool( *NewAcl );
            *NewAcl = NULL;

            if ( Status != STATUS_BUFFER_TOO_SMALL ) {
                break;
            }
        }
    }


    return Status;
}

#endif // WIN16

#if DBG
NTSTATUS
RtlDumpUserSid(
    VOID
    )
{
    NTSTATUS Status;
    HANDLE   TokenHandle;
    CHAR     Buffer[200];
    ULONG    ReturnLength;
    PSID     pSid;
    UNICODE_STRING SidString;
    PTOKEN_USER  User;

    //
    // Attempt to open the impersonation token first
    //

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 GENERIC_READ,
                 FALSE,
                 &TokenHandle
                 );

    if (!NT_SUCCESS( Status )) {

        DbgPrint("Not impersonating, status = %X, trying process token\n",Status);

        Status = NtOpenProcessToken(
                     NtCurrentProcess(),
                     GENERIC_READ,
                     &TokenHandle
                     );

        if (!NT_SUCCESS( Status )) {
            DbgPrint("Unable to open process token, status = %X\n",Status);
            return( Status );
        }
    }

    Status = NtQueryInformationToken (
                 TokenHandle,
                 TokenUser,
                 Buffer,
                 200,
                 &ReturnLength
                 );

    if (!NT_SUCCESS( Status )) {

        DbgPrint("Unable to query user sid, status = %X \n",Status);
        NtClose(TokenHandle);
        return( Status );
    }

    User = (PTOKEN_USER)Buffer;

    pSid = User->User.Sid;

    Status = RtlConvertSidToUnicodeString( &SidString, pSid, TRUE );

    if (!NT_SUCCESS( Status )) {
        DbgPrint("Unable to format sid string, status = %X \n",Status);
        NtClose(TokenHandle);
        return( Status );
    }

    DbgPrint("Current Sid = %wZ \n",&SidString);

    RtlFreeUnicodeString( &SidString );

    return( STATUS_SUCCESS );
}

#endif


NTSTATUS
RtlpConvertToAutoInheritSecurityObject(
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This routine a converts a security descriptor whose ACLs are not marked
    as AutoInherit to a security descriptor whose ACLs are marked as
    AutoInherit.

    See comments for RtlConvertToAutoInheritSecurityObject.

Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a object exists.  If there is
        no parent directory, then this argument is specified as NULL.

    CurrentSecurityDescriptor - Supplies a pointer to the objects security descriptor
        that is going to be altered by this procedure.

    NewSecurityDescriptor Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor. When no
        longer needed, this descriptor must be freed using
        DestroyPrivateObjectSecurity().

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    IsDirectoryObject - Specifies if the object is a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    STATUS_SUCCESS - The operation was successful.

    See comments for RtlConvertToAutoInheritSecurityObject.


--*/
{
    NTSTATUS Status;
    PISECURITY_DESCRIPTOR CurrentDescriptor;
    PACL CurrentSacl;
    PACL CurrentDacl;

    PSID NewOwner;
    PSID NewGroup;

    PACL NewSacl = NULL;
    ULONG NewSaclControl = 0;
    BOOLEAN NewSaclAllocated = FALSE;

    PACL NewDacl = NULL;
    ULONG NewDaclControl = 0;
    BOOLEAN NewDaclAllocated = FALSE;
    PACL TemplateInheritedDacl = NULL;
    ULONG GenericControl;

    ULONG AllocationSize;
    ULONG NewOwnerSize;
    ULONG NewGroupSize;
    ULONG NewSaclSize;
    ULONG NewDaclSize;

    PCHAR Field;
    PCHAR Base;

    PISECURITY_DESCRIPTOR_RELATIVE INewDescriptor = NULL;
    ULONG ReturnLength;
    NTSTATUS PassedStatus;
    HANDLE PrimaryToken;

    RTL_PAGED_CODE();

    CurrentDescriptor = CurrentSecurityDescriptor;

    //
    // Validate the incoming security descriptor.
    //

    if (!RtlValidSecurityDescriptor ( CurrentDescriptor )) {
        Status = STATUS_INVALID_SECURITY_DESCR;
        goto Cleanup;
    }


    NewOwner = RtlpOwnerAddrSecurityDescriptor( CurrentDescriptor );
    if ( NewOwner == NULL ) {
        Status = STATUS_INVALID_SECURITY_DESCR;
        goto Cleanup;
    }

    NewGroup = RtlpGroupAddrSecurityDescriptor( CurrentDescriptor );




    //
    // Handle the SACL.
    //
    //
    // If the SACL isn't present,
    //  special case it.
    //

    CurrentSacl = RtlpSaclAddrSecurityDescriptor( CurrentDescriptor );

    if ( CurrentSacl == NULL ) {
        PACL ParentSacl;

        // Preserve the Acl Present bit and protected bit from the existing descriptor.
        NewSaclControl |= CurrentDescriptor->Control & (SE_SACL_PROTECTED|SE_SACL_PRESENT);

        // Always set the autoinherited bit.
        NewSaclControl |= SE_SACL_AUTO_INHERITED;


        //
        // If the Parent also has a NULL SACL,
        //  just consider this SACL as inherited.
        //  otherwise, this SACL is protected.
        //

        ParentSacl = ARGUMENT_PRESENT(ParentDescriptor) ?
                        RtlpSaclAddrSecurityDescriptor( ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
                        NULL;
        if ( ParentSacl != NULL) {
            NewSaclControl |= SE_SACL_PROTECTED;
        }


    //
    // If the SACL is already converted,
    //  or if this object is at the root of the tree,
    //  simply leave it alone.
    //
    // Don't force the Protect bit on at the root of the tree since it is semantically
    //  a no-op and gets in the way if the object is ever moved.
    //

    } else if ( RtlpAreControlBitsSet( CurrentDescriptor, SE_SACL_AUTO_INHERITED) ||
                RtlpAreControlBitsSet( CurrentDescriptor, SE_SACL_PROTECTED ) ||
                !ARGUMENT_PRESENT(ParentDescriptor) ) {

        // Preserve the Acl Present bit and protected bit from the existing descriptor.
        NewSaclControl |= CurrentDescriptor->Control & (SE_SACL_PROTECTED|SE_SACL_PRESENT);

        // Always set the autoinherited bit.
        NewSaclControl |= SE_SACL_AUTO_INHERITED;

        NewSacl = CurrentSacl;


    //
    // If the SACL is present,
    //  compute a new SACL with appropriate ACEs marked as inherited.
    //

    } else {


        Status = RtlpConvertAclToAutoInherit (
                    ARGUMENT_PRESENT(ParentDescriptor) ?
                        RtlpSaclAddrSecurityDescriptor(
                            ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
                        NULL,
                    RtlpSaclAddrSecurityDescriptor(CurrentDescriptor),
                    ObjectType,
                    IsDirectoryObject,
                    RtlpOwnerAddrSecurityDescriptor(CurrentDescriptor),
                    RtlpGroupAddrSecurityDescriptor(CurrentDescriptor),
                    GenericMapping,
                    &NewSacl,
                    &GenericControl );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        NewSaclAllocated = TRUE;
        NewSaclControl |= SE_SACL_PRESENT | SeControlGenericToSacl( GenericControl );
    }


    //
    // Handle the DACL.
    //
    //
    // If the DACL isn't present,
    //  special case it.
    //

    CurrentDacl = RtlpDaclAddrSecurityDescriptor( CurrentDescriptor );

    if ( CurrentDacl == NULL ) {
        // Preserve the Dacl Present bit from the existing descriptor.
        NewDaclControl |= CurrentDescriptor->Control & SE_DACL_PRESENT;

        // Always set the autoinherited bit.
        // Force it protected.
        NewDaclControl |= SE_DACL_AUTO_INHERITED | SE_DACL_PROTECTED;



    //
    // If the DACL is already converted,
    //  or if this object is at the root of the tree,
    //  simply leave it alone.
    //
    // Don't force the Protect bit on at the root of the tree since it is semantically
    //  a no-op and gets in the way if the object is ever moved.
    //

    } else if ( RtlpAreControlBitsSet( CurrentDescriptor, SE_DACL_AUTO_INHERITED) ||
                RtlpAreControlBitsSet( CurrentDescriptor, SE_DACL_PROTECTED ) ||
                !ARGUMENT_PRESENT(ParentDescriptor) ) {

        // Preserve the Acl Present bit and protected bit from the existing descriptor.
        NewDaclControl |= CurrentDescriptor->Control & (SE_DACL_PROTECTED|SE_DACL_PRESENT);

        // Always set the autoinherited bit.
        NewDaclControl |= SE_DACL_AUTO_INHERITED;

        NewDacl = CurrentDacl;



    //
    // If the DACL is present,
    //  compute a new DACL with appropriate ACEs marked as inherited.
    //

    } else {


        Status = RtlpConvertAclToAutoInherit (
                    ARGUMENT_PRESENT(ParentDescriptor) ?
                        RtlpDaclAddrSecurityDescriptor(
                            ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
                        NULL,
                    RtlpDaclAddrSecurityDescriptor(CurrentDescriptor),
                    ObjectType,
                    IsDirectoryObject,
                    RtlpOwnerAddrSecurityDescriptor(CurrentDescriptor),
                    RtlpGroupAddrSecurityDescriptor(CurrentDescriptor),
                    GenericMapping,
                    &NewDacl,
                    &GenericControl );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        NewDaclAllocated = TRUE;
        NewDaclControl |= SE_DACL_PRESENT | SeControlGenericToDacl( GenericControl );
    }



    //
    // Build the resultant security descriptor
    //
    // Also map the ACEs for application to the target object
    // type, if they haven't already been mapped.
    //
    NewOwnerSize = LongAlignSize(SeLengthSid(NewOwner));

    if ( NewGroup != NULL ) {
        NewGroupSize = LongAlignSize(SeLengthSid(NewGroup));
    } else {
        NewGroupSize = 0;
    }

    if (NewSacl != NULL) {
        NewSaclSize = LongAlignSize(NewSacl->AclSize);
    } else {
        NewSaclSize = 0;
    }

    if (NewDacl != NULL) {
        NewDaclSize = LongAlignSize(NewDacl->AclSize);
    } else {
        NewDaclSize = 0;
    }

    AllocationSize = LongAlignSize(sizeof(SECURITY_DESCRIPTOR_RELATIVE)) +
                     NewOwnerSize +
                     NewGroupSize +
                     NewSaclSize  +
                     NewDaclSize;

    //
    // Allocate and initialize the security descriptor as
    // self-relative form.
    //


    INewDescriptor = ExAllocatePoolWithTag(
                        PagedPool,
                        AllocationSize,
                        'dSeS' );

    if ( INewDescriptor == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    //
    // Initialize the security descriptor as self-relative form.
    //

    RtlCreateSecurityDescriptorRelative(
        INewDescriptor,
        SECURITY_DESCRIPTOR_REVISION
        );

    RtlpSetControlBits( INewDescriptor, SE_SELF_RELATIVE );

    Base = (PCHAR)(INewDescriptor);
    Field =  Base + sizeof(SECURITY_DESCRIPTOR_RELATIVE);

    //
    // Copy the Sacl
    //

    RtlpSetControlBits( INewDescriptor, NewSaclControl );
    if (NewSacl != NULL ) {

        RtlCopyMemory( Field, NewSacl, NewSacl->AclSize );
        INewDescriptor->Sacl = RtlPointerToOffset(Base,Field);
        Field += NewSaclSize;

    } else {

        INewDescriptor->Sacl = 0;
    }

    //
    // Copy the Dacl
    //

    RtlpSetControlBits( INewDescriptor, NewDaclControl );
    if (NewDacl != NULL ) {

        RtlCopyMemory( Field, NewDacl, NewDacl->AclSize );
        INewDescriptor->Dacl = RtlPointerToOffset(Base,Field);
        Field += NewDaclSize;

    } else {

        INewDescriptor->Dacl = 0;
    }

    //
    // Assign the owner
    //

    RtlCopyMemory( Field, NewOwner, SeLengthSid(NewOwner) );
    INewDescriptor->Owner = RtlPointerToOffset(Base,Field);
    Field += NewOwnerSize;

    if ( NewGroup != NULL ) {
        RtlCopyMemory( Field, NewGroup, SeLengthSid(NewGroup) );
        INewDescriptor->Group = RtlPointerToOffset(Base,Field);
    }

    Status = STATUS_SUCCESS;



    //
    // Cleanup any locally used resources.
    //
Cleanup:
    if (NewDaclAllocated) {
            ExFreePool( NewDacl );
    }
    if (NewSaclAllocated) {
            ExFreePool( NewSacl );
    }

    *NewSecurityDescriptor = (PSECURITY_DESCRIPTOR) INewDescriptor;

    return Status;


}

//
// Local macro to classify the ACE flags in an ACE.
//
// Returns one or more of the following ACE flags:
//
//  CONTAINER_INHERIT_ACE - ACE is inherited to child containers
//  OBJECT_INHERIT_ACE - ACE is inherited to child leaf objects
//  EFFECTIVE_ACE - ACE is used during access validation
//

#define MAX_CHILD_SID_GROUP_SIZE 3 // Number of bits in above list
#define EFFECTIVE_ACE INHERIT_ONLY_ACE
#define AceFlagsInAce( _Ace) \
            (((PACE_HEADER)(_Ace))->AceFlags & (OBJECT_INHERIT_ACE|CONTAINER_INHERIT_ACE) | \
             (((PACE_HEADER)(_Ace))->AceFlags & INHERIT_ONLY_ACE) ^ INHERIT_ONLY_ACE )


BOOLEAN
RtlpCompareAces(
    IN PKNOWN_ACE InheritedAce,
    IN PKNOWN_ACE ChildAce,
    IN PSID OwnerSid,
    IN PSID GroupSid
    )
/*++

Routine Description:

    Compare two aces to see if they are "substantially" the same.

Arguments:

    InheritedAce - Computed ACE as inherited from DirectoryAcl.

    ChildAce - The current acl on the object.  This ACL must be a revision 2 ACL.

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    OwnerSid - Specifies the owner Sid to use.
        If not specified, the owner sid is not treated as special.

    GroupSid - Specifies the group SID to use.
        If not specified, the group sid is not treated as special.

Return Value:

    TRUE - The ACEs are substantially the same.
    FALSE - The ACEs are not substantially the same.

--*/
{
    BOOLEAN AcesCompare = FALSE;

    if (IsObjectAceType(InheritedAce) && IsObjectAceType(ChildAce)) {

        AcesCompare = RtlpCompareKnownObjectAces( (PKNOWN_OBJECT_ACE)InheritedAce,
                                                  (PKNOWN_OBJECT_ACE)ChildAce,
                                                  OwnerSid,
                                                  GroupSid
                                                  );
    } else {

        if (!IsObjectAceType(InheritedAce) && !IsObjectAceType(ChildAce)) {

            AcesCompare = RtlpCompareKnownAces( InheritedAce,
                                                ChildAce,
                                                OwnerSid,
                                                GroupSid
                                                );
        }
    }

    return( AcesCompare );
}


BOOLEAN
RtlpCompareKnownAces(
    IN PKNOWN_ACE InheritedAce,
    IN PKNOWN_ACE ChildAce,
    IN PSID OwnerSid OPTIONAL,
    IN PSID GroupSid OPTIONAL
    )

/*++

Routine Description:

    Compare two aces to see if they are "substantially" the same.

Arguments:

    InheritedAce - Computed ACE as inherited from DirectoryAcl.

    ChildAce - The current acl on the object.  This ACL must be a revision 2 ACL.

    OwnerSid - Specifies the owner Sid to use.
        If not specified, the owner sid is not treated as special.

    GroupSid - Specifies the group SID to use.
        If not specified, the group sid is not treated as special.

Return Value:

    TRUE - The ACEs are substantially the same.
    FALSE - The ACEs are not substantially the same.

--*/

{
    NTSTATUS Status;
    ACE_HEADER volatile *InheritedAceHdr = &InheritedAce->Header;

    RTL_PAGED_CODE();

    ASSERT(!IsObjectAceType(InheritedAce));
    ASSERT(!IsObjectAceType(ChildAce));

    //
    // If the Ace types are different,
    //  we don't match.
    //
    if ( RtlBaseAceType[ChildAce->Header.AceType] != RtlBaseAceType[InheritedAceHdr->AceType] ) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("AceType mismatch"));
        }
#endif // DBG
        return FALSE;
    }

    //
    // If this is a system ACE,
    //  ensure the SUCCESS/FAILURE flags match.
    //

    if ( RtlIsSystemAceType[ChildAce->Header.AceType] ) {
        if ( (ChildAce->Header.AceFlags & (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG)) !=
             (InheritedAceHdr->AceFlags & (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG)) ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("System ace success/fail mismatch"));
            }
#endif // DBG
            return FALSE;
        }
    }

    //
    // If the SID of the inherited ACE doesn't match,
    //  we don't match.
    //

    if ( !RtlEqualSid( (PSID)&ChildAce->SidStart, (PSID)&InheritedAce->SidStart )) {

        //
        // The inheritance algorithm only does SID mapping when building the effective
        //  ace.  So, we only check for a mapped SID if the child ACE is an effective ACE.
        //

        if ( AceFlagsInAce(ChildAce) != EFFECTIVE_ACE ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("SID mismatch"));
            }
#endif // DBG
            return FALSE;
        }

        //
        // In the case of CreatorOwner and CreatorGroup, the SIDs don't have to
        //  exactly match.  When the InheritedAce was generated, care was taken
        //  to NOT map these sids.  The SID may (or may not) have been mapped in
        //  the ChildAce.  We want to compare equal in both cases.
        //
        // If the InheritedAce contains a CreatorOwner/Group SID,
        //  do the another comparison of the SID in the child ACE with the
        //  real owner/group from the child security descriptor.
        //

        if ( OwnerSid != NULL || GroupSid != NULL ) {
            SID_IDENTIFIER_AUTHORITY  CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
            ULONG CreatorSid[CREATOR_SID_SIZE];

            //
            // Allocate and initialize the universal SIDs we're going to need
            // to look for inheritable ACEs.
            //

            ASSERT(RtlLengthRequiredSid( 1 ) == CREATOR_SID_SIZE);
            Status = RtlInitializeSid( (PSID)CreatorSid, &CreatorSidAuthority, 1 );
            if ( !NT_SUCCESS(Status) ) {
                return FALSE;
            }

            *(RtlpSubAuthoritySid( (PSID)CreatorSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

            if (RtlEqualPrefixSid ( (PSID)&InheritedAce->SidStart, CreatorSid )) {
                ULONG Rid;

                Rid = *RtlpSubAuthoritySid( (PSID)&InheritedAce->SidStart, 0 );
                switch (Rid) {
                case SECURITY_CREATOR_OWNER_RID:
                    if ( OwnerSid == NULL ||
                         !RtlEqualSid( (PSID)&ChildAce->SidStart, OwnerSid )) {
#if DBG
                        if ( RtlpVerboseConvert ) {
                            KdPrint(("SID mismatch (Creator Owner)"));
                        }
#endif // DBG
                        return FALSE;
                    }
                    break;
                case SECURITY_CREATOR_GROUP_RID:
                    if ( GroupSid == NULL ||
                         !RtlEqualSid( (PSID)&ChildAce->SidStart, GroupSid )) {
#if DBG
                        if ( RtlpVerboseConvert ) {
                            KdPrint(("SID mismatch (Creator Group)"));
                        }
#endif // DBG
                        return FALSE;
                    }
                    break;
                default:
#if DBG
                    if ( RtlpVerboseConvert ) {
                        KdPrint(("SID mismatch (Creator)"));
                    }
#endif // DBG
                    return FALSE;
                }

            } else {
#if DBG
                if ( RtlpVerboseConvert ) {
                    KdPrint(("SID mismatch"));
                }
#endif // DBG
                return FALSE;
            }
        } else {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("SID mismatch"));
            }
#endif // DBG
            return FALSE;
        }
    }

    return TRUE;

}


BOOLEAN
RtlpCompareKnownObjectAces(
    IN PKNOWN_OBJECT_ACE InheritedAce,
    IN PKNOWN_OBJECT_ACE ChildAce,
    IN PSID OwnerSid OPTIONAL,
    IN PSID GroupSid OPTIONAL
    )

/*++

Routine Description:

    Compare two aces to see if they are "substantially" the same.

Arguments:

    InheritedAce - Computed ACE as inherited from DirectoryAcl.

    ChildAce - The current acl on the object.  This ACL must be a revision 2 ACL.

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    OwnerSid - Specifies the owner Sid to use.
        If not specified, the owner sid is not treated as special.

    GroupSid - Specifies the group SID to use.
        If not specified, the group sid is not treated as special.

Return Value:

    TRUE - The ACEs are substantially the same.
    FALSE - The ACEs are not substantially the same.

--*/

{
    NTSTATUS Status;
    BOOLEAN DoingObjectAces;
    GUID *ChildObjectGuid;
    GUID *InhObjectGuid;
    GUID *ChildInheritedObjectGuid;
    GUID *InhInheritedObjectGuid;
    ACE_HEADER volatile *InheritedAceHdr = &InheritedAce->Header;

    RTL_PAGED_CODE();

    ASSERT(IsObjectAceType(InheritedAce));
    ASSERT(IsObjectAceType(ChildAce));
    //
    // If the Ace types are different,
    //  we don't match.
    //
    if ( RtlBaseAceType[ChildAce->Header.AceType] != RtlBaseAceType[InheritedAceHdr->AceType] ) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("AceType mismatch"));
        }
#endif // DBG
        return FALSE;
    }

    //
    // If this is a system ACE,
    //  ensure the SUCCESS/FAILURE flags match.
    //

    if ( RtlIsSystemAceType[ChildAce->Header.AceType] ) {
        if ( (ChildAce->Header.AceFlags & (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG)) !=
             (InheritedAceHdr->AceFlags & (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG)) ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("System ace success/fail mismatch"));
            }
#endif // DBG
            return FALSE;
        }
    }

    //
    // Get the GUIDs from the Object Aces
    //

    ChildObjectGuid = RtlObjectAceObjectType(ChildAce);
    ChildInheritedObjectGuid = RtlObjectAceInheritedObjectType(ChildAce);

    InhObjectGuid = RtlObjectAceObjectType(InheritedAce);
    InhInheritedObjectGuid = RtlObjectAceInheritedObjectType(InheritedAce);

    //
    // If the InheritedObjectGuid is present in either ACE,
    //  they must be equal.
    //

    if ( ChildInheritedObjectGuid != NULL || InhInheritedObjectGuid != NULL ) {

        if ( ChildInheritedObjectGuid == NULL ||
             InhInheritedObjectGuid == NULL ||
             !RtlpIsEqualGuid( ChildInheritedObjectGuid, InhInheritedObjectGuid )) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("InheritedObject GUID mismatch"));
            }
#endif // DBG
            return FALSE;
        }
    }

    //
    // If the ObjectGUID is present in either ACE,
    //  they must be equal.
    //
    // Any missing object GUID defaults to the passed in object GUID.
    //

    if ( (ChildObjectGuid != NULL) && (InhObjectGuid != NULL) ) {

        if (!RtlpIsEqualGuid( ChildObjectGuid, InhObjectGuid )) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Object GUID mismatch"));
            }
#endif // DBG

            return( FALSE );
        }
    } else {

        //
        // One or both is NULL, if it's only one, they don't match.
        //

        if ( !((ChildObjectGuid == NULL) && (InhObjectGuid == NULL)) ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Object GUID mismatch"));
            }
#endif // DBG

            return( FALSE );
        }
    }

    //
    // If the SID of the inherited ACE doesn't match,
    //  we don't match.
    //

    if ( !RtlEqualSid( RtlObjectAceSid(ChildAce), RtlObjectAceSid(InheritedAce))) {

        //
        // The inheritance algorithm only does SID mapping when building the effective
        //  ace.  So, we only check for a mapped SID if the child ACE is an effective ACE.
        //

        if ( AceFlagsInAce(ChildAce) != EFFECTIVE_ACE ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("SID mismatch"));
            }
#endif // DBG
            return FALSE;
        }



        //
        // In the case of CreatorOwner and CreatorGroup, the SIDs don't have to
        //  exactly match.  When the InheritedAce was generated, care was taken
        //  to NOT map these sids.  The SID may (or may not) have been mapped in
        //  the ChildAce.  We want to compare equal in both cases.
        //
        // If the InheritedAce contains a CreatorOwner/Group SID,
        //  do the another comparison of the SID in the child ACE with the
        //  real owner/group from the child security descriptor.
        //

        if ( OwnerSid != NULL || GroupSid != NULL ) {
            SID_IDENTIFIER_AUTHORITY  CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
            ULONG CreatorSid[CREATOR_SID_SIZE];

            //
            // Allocate and initialize the universal SIDs we're going to need
            // to look for inheritable ACEs.
            //

            ASSERT(RtlLengthRequiredSid( 1 ) == CREATOR_SID_SIZE);
            Status = RtlInitializeSid( (PSID)CreatorSid, &CreatorSidAuthority, 1 );
            if ( !NT_SUCCESS(Status) ) {
                return FALSE;
            }

            *(RtlpSubAuthoritySid( (PSID)CreatorSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

            if (RtlEqualPrefixSid ( RtlObjectAceSid(InheritedAce), CreatorSid )) {
                ULONG Rid;

                Rid = *RtlpSubAuthoritySid( RtlObjectAceSid(InheritedAce), 0 );
                switch (Rid) {
                case SECURITY_CREATOR_OWNER_RID:
                    if ( OwnerSid == NULL ||
                         !RtlEqualSid( RtlObjectAceSid(ChildAce), OwnerSid )) {
#if DBG
                        if ( RtlpVerboseConvert ) {
                            KdPrint(("SID mismatch (Creator Owner)"));
                        }
#endif // DBG
                        return FALSE;
                    }
                    break;
                case SECURITY_CREATOR_GROUP_RID:
                    if ( GroupSid == NULL ||
                         !RtlEqualSid( RtlObjectAceSid(ChildAce), GroupSid )) {
#if DBG
                        if ( RtlpVerboseConvert ) {
                            KdPrint(("SID mismatch (Creator Group)"));
                        }
#endif // DBG
                        return FALSE;
                    }
                    break;
                default:
#if DBG
                    if ( RtlpVerboseConvert ) {
                        KdPrint(("SID mismatch (Creator)"));
                    }
#endif // DBG
                    return FALSE;
                }

            } else {
#if DBG
                if ( RtlpVerboseConvert ) {
                    KdPrint(("SID mismatch"));
                }
#endif // DBG
                return FALSE;
            }
        } else {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("SID mismatch"));
            }
#endif // DBG
            return FALSE;
        }
    }

    return TRUE;

}




NTSTATUS
RtlpConvertAclToAutoInherit (
    IN PACL ParentAcl OPTIONAL,
    IN PACL ChildAcl,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PACL *NewAcl,
    OUT PULONG NewGenericControl
    )

/*++

Routine Description:

    This is a private routine that produces an auto inherited acl from
    a ChildAcl that is not marked as auto inherited.  The passed in InheritedAcl
    is computed as the pure inherited ACL of Parent ACL of the object.

    See comments for RtlConvertToAutoInheritSecurityObject.

Arguments:

    ParentAcl - Supplies the ACL of the parent object.

    ChildAcl - Supplies the acl associated with the object.  This
        is the current acl on the object.

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    IsDirectoryObject - Specifies if the object is a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    OwnerSid - Specifies the owner Sid to use.

    GroupSid - Specifies the group SID to use.

    GenericMapping - Specifies the generic mapping to use.

    NewAcl - Receives a pointer to the new (auto inherited) acl.
        The ACL must be deallocated using the pool (kernel mode) or
            heap (user mode) deallocator.

    NewGenericControl - Specifies the control flags for the newly
        generated ACL.

        SEP_ACL_PRESENT: Specifies that the ACL is explictly supplied by
            the caller. ?? Ever set?

        SEP_ACL_DEFAULTED: Specifies that the ACL was supplied by some
            defaulting mechanism. ?? Ever set

        SEP_ACL_AUTO_INHERITED: Set if the ACL was generated using the
            Automatic Inheritance algorithm.

        SEP_ACL_PROTECTED: Specifies that the ACL is protected and
            was not inherited from the parent ACL.

Return Value:

    STATUS_SUCCESS - An inheritable ACL was successfully generated.

    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that
        is unknown to this routine.

    STATUS_INVALID_ACL - The structure of one of the ACLs in invalid.

--*/

{
    NTSTATUS Status;

    PACL InheritedAcl = NULL;
    PACL RealInheritedAcl = NULL;
    BOOLEAN AclExplicitlyAssigned;
    ULONG GenericControl;

    PKNOWN_ACE ChildAce = NULL;
    PKNOWN_ACE InheritedAce;

    LONG ChildAceIndex;
    LONG InheritedAceIndex;

    BOOLEAN InheritedAllowFound;
    BOOLEAN InheritedDenyFound;

    BOOLEAN AcesCompare;

    ACCESS_MASK InheritedContainerInheritMask;
    ACCESS_MASK InheritedObjectInheritMask;
    ACCESS_MASK InheritedEffectiveMask;
    ACCESS_MASK OriginalInheritedContainerInheritMask;
    ACCESS_MASK OriginalInheritedObjectInheritMask;
    ACCESS_MASK OriginalInheritedEffectiveMask;

    ULONG InheritedAceFlags;
    ULONG MatchedFlags;
    ULONG NonInheritedAclSize;


    PACE_HEADER AceHeader;
    PUCHAR Where;

    // ULONG i;

    //
    // This routine maintains an array of the structure below (one element per ACE in
    // the ChildAcl).
    //
    // The ACE is broken down into its component parts.  The access mask is 'triplicated'.
    // That is, if the ACE is a ContainerInherit ACE, the access mask is remembered as
    // being a "ContainerInheritMask".  The same is true if the ACE is an ObjectInherit ACE
    // on an effective ACE.  This is done since each of the resultant 96 bits are
    // individually matched against corresponding bits in the computed inherited ACE.
    //
    // Each of the above mentioned masks are maintained in two forms.  The first is never
    // changed and represents the bits as the originally appeared in the child ACL.
    // This second is modified as the corresponding bits are matched in the inherited ACL.
    // When the algorithm is completed, bits that haven't been matched represent ACEs
    // that weren't inherited from the parent.
    //

    typedef struct {
        ACCESS_MASK OriginalContainerInheritMask;
        ACCESS_MASK OriginalObjectInheritMask;
        ACCESS_MASK OriginalEffectiveMask;

        ACCESS_MASK ContainerInheritMask;
        ACCESS_MASK ObjectInheritMask;
        ACCESS_MASK EffectiveMask;
    } ACE_INFO, *PACE_INFO;

    PACE_INFO ChildAceInfo = NULL;

    ULONG CreatorOwnerSid[CREATOR_SID_SIZE];
    ULONG CreatorGroupSid[CREATOR_SID_SIZE];

    SID_IDENTIFIER_AUTHORITY  CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;

    RTL_PAGED_CODE();

    //
    // Allocate and initialize the universal SIDs we're going to need
    // to look for inheritable ACEs.
    //

    ASSERT(RtlLengthRequiredSid( 1 ) == CREATOR_SID_SIZE);
    Status = RtlInitializeSid( (PSID)CreatorOwnerSid, &CreatorSidAuthority, 1 );
    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    *(RtlpSubAuthoritySid( (PSID)CreatorOwnerSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

    Status = RtlInitializeSid( (PSID)CreatorGroupSid, &CreatorSidAuthority, 1 );
    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    *(RtlpSubAuthoritySid( (PSID)CreatorGroupSid, 0 )) = SECURITY_CREATOR_GROUP_RID;

    //
    // Ensure the passed in ACLs are valid.
    //

    *NewGenericControl = SEP_ACL_AUTO_INHERITED;
    *NewAcl = NULL;

    if ( ParentAcl != NULL && !RtlValidAcl( ParentAcl ) ) {
        Status = STATUS_INVALID_ACL;
        goto Cleanup;
    }

    if (!RtlValidAcl( ChildAcl ) ) {
        Status = STATUS_INVALID_ACL;
        goto Cleanup;
    }


    //
    // Compute what the inherited ACL "should" look like.
    //
    // The inherited ACL is computed to NOT SID-map Creator Owner and Creator Group.
    // This allows use to later recognize the constant SIDs and special case them
    // rather than mistakenly confuse them with the mapped SID.
    //

    Status = RtlpInheritAcl (
                ParentAcl,
                NULL,   // No explicit child ACL
                0,      // No Child Generic Control
                IsDirectoryObject,
                TRUE,   // AutoInherit the DACL
                FALSE,  // Not default descriptor for object
                CreatorOwnerSid,   // Subsitute a constant SID
                CreatorGroupSid,   // Subsitute a constant SID
                CreatorOwnerSid,   // Server Owner (Technically incorrect, but OK since we don't support compound ACEs)
                CreatorGroupSid,   // Server Group
                GenericMapping,
                TRUE,   // Is a SACL
                ObjectType ? &ObjectType : NULL, 
                ObjectType ? 1 : 0,
                &InheritedAcl,
                &AclExplicitlyAssigned,
                &GenericControl );

    if ( Status == STATUS_NO_INHERITANCE ) {
        *NewGenericControl |= SEP_ACL_PROTECTED;
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("NO_INHERITANCE of the parent ACL\n" ));
        }
#endif // DBG
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    if ( !NT_SUCCESS(Status) ) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("Can't build inherited ACL %lX\n", Status ));
        }
#endif // DBG
        goto Cleanup;
    }

    //
    // Allocate a work buffer describing the ChildAcl
    //

    ChildAceInfo = ExAllocatePoolWithTag(
                        PagedPool,
                        ChildAcl->AceCount * sizeof(ACE_INFO),
                        'cAeS' );

    if (ChildAceInfo == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    for (ChildAceIndex = 0, ChildAce = FirstAce(ChildAcl);
         ChildAceIndex < ChildAcl->AceCount;
         ChildAceIndex += 1, ChildAce = NextAce(ChildAce)) {
        ACCESS_MASK LocalMask;
        ULONG ChildAceFlags;

        if ( !IsV4AceType(ChildAce) || IsCompoundAceType(ChildAce)) {
             *NewGenericControl |= SEP_ACL_PROTECTED;
#if DBG
             if ( RtlpVerboseConvert ) {
                 KdPrint(("Inherited Ace type (%ld) not known\n", ChildAce->Header.AceType ));
             }
#endif // DBG
             Status = STATUS_SUCCESS;
             goto Cleanup;
        }

        //
        // Compute the generic mapped mask for use in all comparisons.  The
        //  generic mapping will be undone if needed later.
        //
        // All V4 aces have an access mask in the same location.
        //
        LocalMask = ((PKNOWN_ACE)(ChildAce))->Mask;
        RtlApplyGenericMask( ChildAce, &LocalMask, GenericMapping);


        //
        // Break the ACE into its component parts.
        //
        ChildAceFlags = AceFlagsInAce( ChildAce );
        if ( ChildAceFlags & CONTAINER_INHERIT_ACE ) {
            ChildAceInfo[ChildAceIndex].OriginalContainerInheritMask = LocalMask;
            ChildAceInfo[ChildAceIndex].ContainerInheritMask = LocalMask;
        } else {
            ChildAceInfo[ChildAceIndex].OriginalContainerInheritMask = 0;
            ChildAceInfo[ChildAceIndex].ContainerInheritMask = 0;
        }

        if ( ChildAceFlags & OBJECT_INHERIT_ACE ) {
            ChildAceInfo[ChildAceIndex].OriginalObjectInheritMask = LocalMask;
            ChildAceInfo[ChildAceIndex].ObjectInheritMask = LocalMask;
        } else {
            ChildAceInfo[ChildAceIndex].OriginalObjectInheritMask = 0;
            ChildAceInfo[ChildAceIndex].ObjectInheritMask = 0;
        }

        if ( ChildAceFlags & EFFECTIVE_ACE ) {
            ChildAceInfo[ChildAceIndex].OriginalEffectiveMask = LocalMask;
            ChildAceInfo[ChildAceIndex].EffectiveMask = LocalMask;
        } else {
            ChildAceInfo[ChildAceIndex].OriginalEffectiveMask = 0;
            ChildAceInfo[ChildAceIndex].EffectiveMask = 0;
        }

    }


    //
    // Walk through the computed inherited ACL one ACE at a time.
    //

    for (InheritedAceIndex = 0, InheritedAce = FirstAce(InheritedAcl);
         InheritedAceIndex < InheritedAcl->AceCount;
         InheritedAceIndex += 1, InheritedAce = NextAce(InheritedAce)) {

        ACCESS_MASK LocalMask;

        //
        // If the ACE isn't a valid version 4 ACE,
        //  this isn't an ACL we're interested in handling.
        //

        if ( !IsV4AceType(InheritedAce) || IsCompoundAceType(InheritedAce)) {
             *NewGenericControl |= SEP_ACL_PROTECTED;
#if DBG
             if ( RtlpVerboseConvert ) {
                 KdPrint(("Inherited Ace type (%ld) not known\n", InheritedAce->Header.AceType ));
             }
#endif // DBG
             Status = STATUS_SUCCESS;
             goto Cleanup;
        }

        //
        // Compute the generic mapped mask for use in all comparisons.  The
        //  generic mapping will be undone if needed later.
        //
        // All V4 aces have an access mask in the same location.
        //
        LocalMask = ((PKNOWN_ACE)(InheritedAce))->Mask;
        RtlApplyGenericMask( InheritedAce, &LocalMask, GenericMapping);

        if ( LocalMask == 0 ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Worthless INH ACE: %ld 0x%8.8lx\n", InheritedAceIndex, LocalMask ));
            }
#endif // DBG
            continue;
        }

        //
        // This ACE is some combination of an effective ACE, a container
        //  inherit ACE and an object inherit ACE.  Process each of those
        //  attributes separately since they might be represented separately
        //  in the ChildAcl.
        //

        InheritedAceFlags = AceFlagsInAce( InheritedAce );

        if  ( InheritedAceFlags == 0 ) {
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Worthless INH ACE: %ld 0x%lx\n", InheritedAceIndex, InheritedAceFlags ));
            }
#endif // DBG
            continue;
        }

        if ( InheritedAceFlags & CONTAINER_INHERIT_ACE ) {
            OriginalInheritedContainerInheritMask = InheritedContainerInheritMask = LocalMask;
        } else {
            OriginalInheritedContainerInheritMask = InheritedContainerInheritMask = 0;
        }

        if ( InheritedAceFlags & OBJECT_INHERIT_ACE ) {
            OriginalInheritedObjectInheritMask = InheritedObjectInheritMask = LocalMask;
        } else {
            OriginalInheritedObjectInheritMask = InheritedObjectInheritMask = 0;
        }

        if ( InheritedAceFlags & EFFECTIVE_ACE ) {
            OriginalInheritedEffectiveMask = InheritedEffectiveMask = LocalMask;
        } else {
            OriginalInheritedEffectiveMask = InheritedEffectiveMask = 0;
        }

#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("Doing INH ACE:  %ld %8.8lX %8.8lX %8.8lX\n", InheritedAceIndex, InheritedEffectiveMask, InheritedContainerInheritMask, InheritedObjectInheritMask ));
        }
#endif // DBG


        //
        // Loop through the entire child ACL comparing each inherited ACE with
        //  each child ACE.  Don't stop simply because we've matched once.
        //  Multiple ACEs in the one ACL may have been condensed into a single ACE
        //  in the other ACL in any combination (by any of our friendly ACL editors).
        //  In all cases, it is better to compute a resultant auto inherited ACL
        //  than it is to compute a protected ACL.
        //

        for (ChildAceIndex = 0, ChildAce = FirstAce(ChildAcl);
             ChildAceIndex < ChildAcl->AceCount;
             ChildAceIndex += 1, ChildAce = NextAce(ChildAce)) {


            //
            // Ensure the ACE represents the same principal and object,
            //

#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Compare Child Ace: %ld ", ChildAceIndex ));
            }
#endif // DBG

            if ( !RtlpCompareAces( InheritedAce,
                                   ChildAce,
                                   OwnerSid,
                                   GroupSid ) ) {
#if DBG
                if ( RtlpVerboseConvert ) {
                    KdPrint(("\n" ));
                }
#endif // DBG
                continue;
            }
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("\n" ));
            }
#endif // DBG


            //
            // Match as many access bits in the INH ACE as possible.
            //
            // Don't pay any attention to whether the bits have been previously matched
            // in the CHILD ACE.  To do so, would imply that there is a one-to-one
            // correspondance between bits in the INH ACL and Child ACL.  Unfortunately,
            // ACL editors feel free to compress out duplicate bits in both
            // the CHILD ACL and PARENT ACL as they see fit.
            //

            InheritedEffectiveMask &= ~ChildAceInfo[ChildAceIndex].OriginalEffectiveMask;
            InheritedContainerInheritMask &= ~ChildAceInfo[ChildAceIndex].OriginalContainerInheritMask;
            InheritedObjectInheritMask &= ~ChildAceInfo[ChildAceIndex].OriginalObjectInheritMask;

#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("New   INH MASKs %ld %8.8lX %8.8lX %8.8lX\n", InheritedAceIndex, InheritedEffectiveMask, InheritedContainerInheritMask, InheritedObjectInheritMask ));
            }
#endif // DBG


            //
            // Match as many access bits in the child ACE as possible.
            //
            // Same reasoning as above.
            //

            ChildAceInfo[ChildAceIndex].EffectiveMask &= ~OriginalInheritedEffectiveMask;
            ChildAceInfo[ChildAceIndex].ContainerInheritMask &= ~OriginalInheritedContainerInheritMask;
            ChildAceInfo[ChildAceIndex].ObjectInheritMask &= ~OriginalInheritedObjectInheritMask;

#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("New Child MASKs %ld %8.8lX %8.8lX %8.8lX\n", ChildAceIndex, ChildAceInfo[ChildAceIndex].EffectiveMask, ChildAceInfo[ChildAceIndex].ContainerInheritMask, ChildAceInfo[ChildAceIndex].ObjectInheritMask ));
            }
#endif // DBG

        }


        //
        // If we couldn't process this inherited ACE,
        //  then the child ACL wasn't inherited.
        //

        if ( (InheritedEffectiveMask | InheritedContainerInheritMask | InheritedObjectInheritMask) != 0 ) {
            *NewGenericControl |= SEP_ACL_PROTECTED;
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("INH ACE not completely matched: %ld %8.8lX %8.8lX %8.8lX\n", InheritedAceIndex, InheritedEffectiveMask, InheritedContainerInheritMask, InheritedObjectInheritMask ));
            }
#endif // DBG
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }


    }

    //
    // ASSERT: All of the inherited ACEs have been processed.
    //

    //
    // Loop through the Child ACL ensuring we can build a valid auto inherited ACL
    //

    InheritedAllowFound = FALSE;
    InheritedDenyFound = FALSE;
    NonInheritedAclSize = 0;
    for (ChildAceIndex = 0, ChildAce = FirstAce(ChildAcl);
         ChildAceIndex < ChildAcl->AceCount;
         ChildAceIndex += 1, ChildAce = NextAce(ChildAce)) {

        ACCESS_MASK ResultantMask;

        //
        // Any Child ACE access bits not eliminated above required than an
        //  explicit non-inherited ACE by built.  That ACE will have an
        //  access mask that is the combined access mask of the unmatched bit
        //  in the effective, container inherit, and object inherit categories.
        //  Even though, the combined mask may include access bits not absolutely
        //  required (since they were already inherited), this strategy prevents
        //  us from having to build multiple ACEs (one for each category) for this
        //  single ACE.
        //

        ResultantMask =
            ChildAceInfo[ChildAceIndex].EffectiveMask |
            ChildAceInfo[ChildAceIndex].ContainerInheritMask |
            ChildAceInfo[ChildAceIndex].ObjectInheritMask;


        //
        // Handle an inherited ACE
        //

        if ( ResultantMask == 0 ) {

            //
            // Keep track of whether inherited "allow" and "deny" ACEs are found.
            //

            if ( RtlBaseAceType[ChildAce->Header.AceType] == ACCESS_ALLOWED_ACE_TYPE ) {
                InheritedAllowFound = TRUE;
            }

            if ( RtlBaseAceType[ChildAce->Header.AceType] == ACCESS_DENIED_ACE_TYPE ) {
                InheritedDenyFound = TRUE;
            }

        //
        // Handle a non-inherited ACE
        //

        } else {

            //
            // Keep a running tab of the size of the non-inherited ACEs.
            //

            NonInheritedAclSize += ChildAce->Header.AceSize;

            //
            // Since non-inherited ACEs will be moved to the front of the ACL,
            //  we have to be careful that we don't move a deny ACE in front of a
            //  previously found inherited allow ACE (and vice-versa).  To do so would
            //  change the semantics of the ACL.
            //

            if ( RtlBaseAceType[ChildAce->Header.AceType] == ACCESS_ALLOWED_ACE_TYPE && InheritedDenyFound ) {
                *NewGenericControl |= SEP_ACL_PROTECTED;
#if DBG
                if ( RtlpVerboseConvert ) {
                    KdPrint(("Previous deny found Child ACE: %ld\n", ChildAceIndex ));
                }
#endif // DBG
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }

            if ( RtlBaseAceType[ChildAce->Header.AceType] == ACCESS_DENIED_ACE_TYPE && InheritedAllowFound ) {
                *NewGenericControl |= SEP_ACL_PROTECTED;
#if DBG
                if ( RtlpVerboseConvert ) {
                    KdPrint(("Previous allow found Child ACE: %ld\n", ChildAceIndex ));
                }
#endif // DBG
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }

        }

    }

    //
    // The resultant ACL is composed of the non-inherited ACEs followed by
    // the inherited ACE. The inherited ACEs are built by running the
    // inheritance algorithm over the Parent ACL.
    //
    // The Inherited ACL computed below is almost identical to InheritedAcl.
    // However, InheritedAcl didn't properly substitute the correct owner and
    // group SID.
    //

    Status = RtlpInheritAcl (
                ParentAcl,
                NULL,   // No explicit child ACL
                0,      // No Child Generic Control
                IsDirectoryObject,
                TRUE,   // AutoInherit the DACL
                FALSE,  // Not default descriptor for object
                OwnerSid,   // Subsitute a constant SID
                GroupSid,   // Subsitute a constant SID
                OwnerSid,   // Server Owner (Technically incorrect, but OK since we don't support compound ACEs)
                GroupSid,   // Server Group
                GenericMapping,
                TRUE,   // Is a SACL
                ObjectType ? &ObjectType : NULL, 
                ObjectType ? 1 : 0,
                &RealInheritedAcl,
                &AclExplicitlyAssigned,
                &GenericControl );

    if ( !NT_SUCCESS(Status) ) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("Can't build real inherited ACL %lX\n", Status ));
        }
#endif // DBG
        goto Cleanup;
    }



    //
    // Allocate a buffer for the inherited ACL
    //

    *NewAcl = ExAllocatePoolWithTag(
                        PagedPool,
                        RealInheritedAcl->AclSize + NonInheritedAclSize,
                        'cAeS' );

    if ( *NewAcl == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // All non-inherited ACEs are copied first.
    // The inherited ACES are grabbed from real inherited ACL.
    //
    // Build an ACL Header.
    //

    Status = RtlCreateAcl( *NewAcl,
                           RealInheritedAcl->AclSize + NonInheritedAclSize,
                           max( RealInheritedAcl->AclRevision, ChildAcl->AclRevision ) );

    if ( !NT_SUCCESS(Status) ) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("Can't create final ACL %lX\n", Status ));
        }
#endif // DBG
        //
        // The only reason for failure would be if the combined ACL is too large.
        // So just create a protected ACL (better than a failure).
        //
        *NewGenericControl |= SEP_ACL_PROTECTED;
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Copy the non-inherited ACES.
    //

    Where = ((PUCHAR)(*NewAcl)) + sizeof(ACL);
    for (ChildAceIndex = 0, ChildAce = FirstAce(ChildAcl);
         ChildAceIndex < ChildAcl->AceCount;
         ChildAceIndex += 1, ChildAce = NextAce(ChildAce)) {

        ACCESS_MASK ResultantMask;

        //
        // Copy the non-inherited ACE from the Child only if there's a non-zero access mask.
        //

        ResultantMask =
            ChildAceInfo[ChildAceIndex].EffectiveMask |
            ChildAceInfo[ChildAceIndex].ContainerInheritMask |
            ChildAceInfo[ChildAceIndex].ObjectInheritMask;

        if ( ResultantMask != 0 ) {
            PKNOWN_ACE NewAce;
            ULONG GenericBitToTry;

            //
            // Use the original ChildAce as the template.
            //

            RtlCopyMemory( Where, ChildAce, ChildAce->Header.AceSize );
            NewAce = (PKNOWN_ACE)Where;
            NewAce->Header.AceFlags &= ~INHERITED_ACE;  // Clear stray bits
            Where += ChildAce->Header.AceSize;

            (*NewAcl)->AceCount ++;

            //
            // The AccessMask on the ACE are those access bits that didn't get matched
            //  by inherited ACEs.
            //

            NewAce->Mask = ChildAce->Mask & ResultantMask;
            ResultantMask &= ~ChildAce->Mask;
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Original non-inherited: %ld %8.8lX %8.8lX\n", ChildAceIndex, NewAce->Mask, ResultantMask ));
            }
#endif // DBG

            //
            // Map any remaining bits back to generic access bits.
            // Doing so might expand the ResultantMask to beyond what was computed above.
            // Doing so will never expand the computed ACE to beyond what the original
            //  ChildAce granted.
            //

            ASSERT( GENERIC_WRITE == (GENERIC_READ >> 1));
            ASSERT( GENERIC_EXECUTE == (GENERIC_WRITE >> 1));
            ASSERT( GENERIC_ALL == (GENERIC_EXECUTE >> 1));

            GenericBitToTry = GENERIC_READ;

            while ( ResultantMask && GenericBitToTry >= GENERIC_ALL ) {

                //
                // Only map generic bits that are in the ChildAce.
                //

                if ( GenericBitToTry & ChildAce->Mask ) {
                    ACCESS_MASK GenericMask;

                    //
                    // Compute the real access mask corresponding to the Generic bit.
                    //

                    GenericMask = GenericBitToTry;
                    RtlMapGenericMask( &GenericMask, GenericMapping );

                    //
                    // If the current generic bit matches any of the bits remaining,
                    //  set the generic bit in the current ACE.
                    //

                    if ( (ResultantMask & GenericMask) != 0 ) {
                        NewAce->Mask |= GenericBitToTry;
                        ResultantMask &= ~GenericMask;
                    }
#if DBG
                    if ( RtlpVerboseConvert ) {
                        KdPrint(("Generic  non-inherited: %ld %8.8lX %8.8lX\n", ChildAceIndex, NewAce->Mask, ResultantMask ));
                    }
#endif // DBG
                }

                //
                // Try the next Generic bit.
                //

                GenericBitToTry >>= 1;
            }


            //
            // This is really an internal error, but press on regardless.
            //

            ASSERT(ResultantMask == 0 );
            NewAce->Mask |= ResultantMask;
#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Final    non-inherited: %ld %8.8lX %8.8lX\n", ChildAceIndex, NewAce->Mask, ResultantMask ));
            }
#endif // DBG

        }
    }

    //
    // Copy the inherited ACES.
    //  Simply copy computed Inherited ACL.
    //

    RtlCopyMemory( Where,
                   FirstAce(RealInheritedAcl),
                   RealInheritedAcl->AclSize - (ULONG)(((PUCHAR)FirstAce(RealInheritedAcl)) - (PUCHAR)RealInheritedAcl));
    Where += RealInheritedAcl->AclSize - (ULONG)(((PUCHAR)FirstAce(RealInheritedAcl)) - (PUCHAR)RealInheritedAcl);

    (*NewAcl)->AceCount += RealInheritedAcl->AceCount;
    ASSERT( (*NewAcl)->AclSize == Where - (PUCHAR)(*NewAcl) );


    Status = STATUS_SUCCESS;
Cleanup:

    //
    // If successful,
    //  build the resultant autoinherited ACL.
    //

    if ( NT_SUCCESS(Status) ) {

        //
        // If the Child ACL is protected,
        //  just build it as a copy of the original ACL
        //

        if ( *NewGenericControl & SEP_ACL_PROTECTED ) {

            //
            // If we've already allocated a new ACL (and couldn't finish it for some reason),
            //  free it.

            if ( *NewAcl != NULL) {
                ExFreePool( *NewAcl );
                *NewAcl = NULL;
            }

            //
            // Allocate a buffer for the protected ACL.
            //

            *NewAcl = ExAllocatePoolWithTag(
                                PagedPool,
                                ChildAcl->AclSize,
                                'cAeS' );

            if ( *NewAcl == NULL ) {
                Status = STATUS_NO_MEMORY;
            } else {
                RtlCopyMemory( *NewAcl, ChildAcl, ChildAcl->AclSize );
            }
        }

    }

    if ( ChildAceInfo != NULL) {
        ExFreePool( ChildAceInfo );
    }

    if ( InheritedAcl != NULL) {
        ExFreePool( InheritedAcl );
    }

    if ( RealInheritedAcl != NULL) {
        ExFreePool( RealInheritedAcl );
    }

    return Status;
}


BOOLEAN
RtlpIsDuplicateAce(
    IN PACL Acl,
    IN PKNOWN_ACE NewAce
    )

/*++

Routine Description:

    This routine determine if an ACE is a duplicate of an ACE already in an
    ACL.  If so, the NewAce can be removed from the end of the ACL.

    This routine currently only detects duplicate version 4 ACEs.  If the
    ACE isn't version 4, the ACE will be declared to be a non-duplicate.

    This routine only detects duplicate INHERTED ACEs.

Arguments:

    Acl - Existing ACL

    NewAce - Ace to determine if it is already in Acl.
        NewAce is expected to be the last ACE in "Acl".

Return Value:

    TRUE - NewAce is a duplicate of another ACE on the Acl
    FALSE - NewAce is NOT a duplicate of another ACE on the Acl

--*/

{
    NTSTATUS Status;
    BOOLEAN RetVal = FALSE;

    LONG AceIndex;

    ACCESS_MASK NewAceContainerInheritMask;
    ACCESS_MASK NewAceObjectInheritMask;
    ACCESS_MASK NewAceEffectiveMask;

    ACCESS_MASK LocalMask;

    PKNOWN_ACE AceFromAcl;

    RTL_PAGED_CODE();


    //
    // Ensure the passed in ACE is one this routine understands
    //

    if ( !IsV4AceType(NewAce) || IsCompoundAceType(NewAce)) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("New Ace type (%ld) not known\n", NewAce->Header.AceType ));
        }
#endif // DBG
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // This routine only works for ACEs marked as INHERITED.
    //

    if ( (NewAce->Header.AceFlags & INHERITED_ACE ) == 0 ) {
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("New Ace type isn't inherited\n" ));
        }
#endif // DBG
        RetVal = FALSE;
        goto Cleanup;
    }


    //
    // Break the new ACE into its component parts.
    //
    // All V4 aces have an access mask in the same location.
    //
    LocalMask = ((PKNOWN_ACE)(NewAce))->Mask;

    if ( NewAce->Header.AceFlags & CONTAINER_INHERIT_ACE ) {
        NewAceContainerInheritMask = LocalMask;
    } else {
        NewAceContainerInheritMask = 0;
    }

    if ( NewAce->Header.AceFlags & OBJECT_INHERIT_ACE ) {
        NewAceObjectInheritMask = LocalMask;
    } else {
        NewAceObjectInheritMask = 0;
    }

    if ( (NewAce->Header.AceFlags & INHERIT_ONLY_ACE) == 0 ) {
        NewAceEffectiveMask = LocalMask;
    } else {
        NewAceEffectiveMask = 0;
    }
#if DBG
    if ( RtlpVerboseConvert ) {
        KdPrint(("Starting MASKs:  %8.8lX %8.8lX %8.8lX", NewAceEffectiveMask, NewAceContainerInheritMask, NewAceObjectInheritMask ));
    }
#endif // DBG




    //
    // Walk through the ACL one ACE at a time.
    //

    for (AceIndex = 0, AceFromAcl = FirstAce(Acl);
         AceIndex < Acl->AceCount-1;    // NewAce is the last ACE
         AceIndex += 1, AceFromAcl = NextAce(AceFromAcl)) {


        //
        // If the ACE isn't a valid version 4 ACE,
        //  this isn't an ACE we're interested in handling.
        //

        if ( !IsV4AceType(AceFromAcl) || IsCompoundAceType(AceFromAcl)) {
            continue;
        }

        //
        // This routine only works for ACEs marked as INHERITED.
        //

        if ( (AceFromAcl->Header.AceFlags & INHERITED_ACE ) == 0 ) {
            continue;
        }


        //
        // Compare the Ace from the ACL with the New ACE
        //
        //  Don't stop simply because we've matched once.
        //  Multiple ACEs in the one ACL may have been condensed into a single ACE
        //  in the other ACL in any combination (by any of our friendly ACL editors).
        //
#if DBG
        if ( RtlpVerboseConvert ) {
            KdPrint(("Compare Ace: %ld ", AceIndex ));
        }
#endif // DBG

        if ( RtlpCompareAces( AceFromAcl,
                              NewAce,
                              NULL,
                              NULL ) ) {


            //
            // Match the bits from the current ACE with bits from the New ACE.
            //
            // All V4 aces have an access mask in the same location.
            //

            LocalMask = ((PKNOWN_ACE)(AceFromAcl))->Mask;

            if ( AceFromAcl->Header.AceFlags & CONTAINER_INHERIT_ACE ) {
                NewAceContainerInheritMask &= ~LocalMask;
            }

            if ( AceFromAcl->Header.AceFlags & OBJECT_INHERIT_ACE ) {
                NewAceObjectInheritMask &= ~LocalMask;
            }

            if ( (AceFromAcl->Header.AceFlags & INHERIT_ONLY_ACE) == 0 ) {
                NewAceEffectiveMask &= ~LocalMask;
            }

#if DBG
            if ( RtlpVerboseConvert ) {
                KdPrint(("Remaining MASKs:  %8.8lX %8.8lX %8.8lX", NewAceEffectiveMask, NewAceContainerInheritMask, NewAceObjectInheritMask ));
            }
#endif // DBG

            //
            // If all bits have been matched in the New Ace,
            //  then this is a duplicate ACE.
            //

            if ( (NewAceEffectiveMask | NewAceContainerInheritMask | NewAceObjectInheritMask) == 0 ) {
#if DBG
                if ( RtlpVerboseConvert ) {
                    KdPrint(("\n"));
                }
#endif // DBG
                RetVal = TRUE;
                goto Cleanup;
            }
        }
#if DBG
        if ( RtlpVerboseConvert ) {
              KdPrint(("\n"));
        }
#endif // DBG


    }

    //
    // All of the ACEs of the ACL have been processed.
    //
    // We haven't matched all of the bits in the New Ace so this is not a duplicate ACE.
    //

    RetVal = FALSE;
Cleanup:

    return RetVal;

}


NTSTATUS
RtlpCreateServerAcl(
    IN PACL Acl,
    IN BOOLEAN AclUntrusted,
    IN PSID ServerSid,
    OUT PACL *ServerAcl,
    OUT BOOLEAN *ServerAclAllocated
    )

/*++

Routine Description:

    This routine takes an ACL and converts it into a server ACL.
    Currently, that means converting all of the GRANT ACEs into
    Compount Grants, and if necessary sanitizing any Compound
    Grants that are encountered.

Arguments:



Return Value:


--*/

{
    USHORT RequiredSize = sizeof(ACL);
    USHORT AceSizeAdjustment;
    USHORT ServerSidSize;
    PACE_HEADER Ace;
    ULONG i;
    PVOID Target;
    PVOID AcePosition;
    PSID UntrustedSid;
    PSID ClientSid;
    NTSTATUS Status;

    RTL_PAGED_CODE();

    if (Acl == NULL) {
        *ServerAclAllocated = FALSE;
        *ServerAcl = NULL;
        return( STATUS_SUCCESS );
    }

    AceSizeAdjustment = sizeof( KNOWN_COMPOUND_ACE ) - sizeof( KNOWN_ACE );
    ASSERT( sizeof( KNOWN_COMPOUND_ACE ) >= sizeof( KNOWN_ACE ) );

    ServerSidSize = (USHORT)SeLengthSid( ServerSid );

    //
    // Do this in two passes.  First, determine how big the final
    // result is going to be, and then allocate the space and make
    // the changes.
    //

    for (i = 0, Ace = FirstAce(Acl);
         i < Acl->AceCount;
         i += 1, Ace = NextAce(Ace)) {

        //
        // If it's an ACCESS_ALLOWED_ACE_TYPE, we'll need to add in the
        // size of the Server SID.
        //

        if (Ace->AceType == ACCESS_ALLOWED_ACE_TYPE) {

            //
            // Simply add the size of the new Server SID plus whatever
            // adjustment needs to be made to increase the size of the ACE.
            //

            RequiredSize += ( ServerSidSize + AceSizeAdjustment );

        } else {

            if (AclUntrusted && Ace->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE ) {

                //
                // Since the Acl is untrusted, we don't care what is in the
                // server SID, we're going to replace it.
                //

                UntrustedSid = RtlCompoundAceServerSid( Ace );
                if ((USHORT)SeLengthSid(UntrustedSid) > ServerSidSize) {
                    RequiredSize += ((USHORT)SeLengthSid(UntrustedSid) - ServerSidSize);
                } else {
                    RequiredSize += (ServerSidSize - (USHORT)SeLengthSid(UntrustedSid));

                }
            }
        }

        RequiredSize += Ace->AceSize;
    }

    (*ServerAcl) = (PACL)ExAllocatePoolWithTag( PagedPool, RequiredSize, 'cAeS' );

    if ((*ServerAcl) == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Mark as allocated so caller knows to free it.
    //

    *ServerAclAllocated = TRUE;

    Status = RtlCreateAcl( (*ServerAcl), RequiredSize, ACL_REVISION3 );
    ASSERT( NT_SUCCESS( Status ));

    for (i = 0, Ace = FirstAce(Acl), Target=FirstAce( *ServerAcl );
         i < Acl->AceCount;
         i += 1, Ace = NextAce(Ace)) {

        //
        // If it's an ACCESS_ALLOWED_ACE_TYPE, convert to a Server ACE.
        //

        if (Ace->AceType == ACCESS_ALLOWED_ACE_TYPE ||
           (AclUntrusted && Ace->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE )) {

            AcePosition = Target;

            if (Ace->AceType == ACCESS_ALLOWED_ACE_TYPE) {
                ClientSid =  &((PKNOWN_ACE)Ace)->SidStart;
            } else {
                ClientSid = RtlCompoundAceClientSid( Ace );
            }

            //
            // Copy up to the access mask.
            //

            RtlCopyMemory(
                Target,
                Ace,
                FIELD_OFFSET(KNOWN_ACE, SidStart)
                );

            //
            // Now copy the correct Server SID
            //

            Target = ((PCHAR)Target + (UCHAR)(FIELD_OFFSET(KNOWN_COMPOUND_ACE, SidStart)));

            RtlCopyMemory(
                Target,
                ServerSid,
                SeLengthSid(ServerSid)
                );

            Target = ((PCHAR)Target + (UCHAR)SeLengthSid(ServerSid));

            //
            // Now copy in the correct client SID.  We can copy this right out of
            // the original ACE.
            //

            RtlCopyMemory(
                Target,
                ClientSid,
                SeLengthSid(ClientSid)
                );

            Target = ((PCHAR)Target + SeLengthSid(ClientSid));

            //
            // Set the size of the ACE accordingly
            //

            ((PKNOWN_COMPOUND_ACE)AcePosition)->Header.AceSize =
                (USHORT)FIELD_OFFSET(KNOWN_COMPOUND_ACE, SidStart) +
                (USHORT)SeLengthSid(ServerSid) +
                (USHORT)SeLengthSid(ClientSid);

            //
            // Set the type
            //

            ((PKNOWN_COMPOUND_ACE)AcePosition)->Header.AceType = ACCESS_ALLOWED_COMPOUND_ACE_TYPE;
            ((PKNOWN_COMPOUND_ACE)AcePosition)->CompoundAceType = COMPOUND_ACE_IMPERSONATION;

        } else {

            //
            // Just copy the ACE as is.
            //

            RtlCopyMemory( Target, Ace, Ace->AceSize );

            Target = ((PCHAR)Target + Ace->AceSize);
        }
    }

    (*ServerAcl)->AceCount = Acl->AceCount;

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlpNewSecurityObject (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN GUID **pObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN BOOLEAN IsDirectoryObject,
    IN ULONG AutoInheritFlags,
    IN HANDLE Token OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    The procedure is used to allocate and initialize a self-relative
    Security Descriptor for a new protected server's object.  It is called
    when a new protected server object is being created.  The generated
    security descriptor will be in self-relative form.

    This procedure, called only from user mode, is used to establish a
    security descriptor for a new protected server's object.  Memory is
    allocated to hold each of the security descriptor's components (using
    NtAllocateVirtualMemory()).  The final security descriptor generated by
    this procedure is produced according to the rules stated in ???

    System and Discretionary ACL Assignment
    ---------------------------------------

    The assignment of system and discretionary ACLs is governed by the
    logic illustrated in the following table:

                 |  Explicit      |  Explicit     |
                 | (non-default)  |  Default      |   No
                 |  Acl           |  Acl          |   Acl
                 |  Specified     |  Specified    |   Specified
    -------------+----------------+---------------+--------------
                 |                |               |
    Inheritable  | Assign         |  Assign       | Assign
    Acl From     | Specified      |  Inherited    | Inherited
    Parent       | Acl(1)(2)      |  Acl          | Acl
                 |                |               |
    -------------+----------------+---------------+--------------
    No           |                |               |
    Inheritable  | Assign         |  Assign       | Assign
    Acl From     | Specified      |  Default      | No Acl
    Parent       | Acl(1)         |  Acl          |
                 |                |               |
    -------------+----------------+---------------+--------------

    (1) Any ACEs with the INHERITED_ACE bit set are NOT copied to the assigned
    security descriptor.

    (2) If the AutoInheritFlags is flagged to automatically inherit ACEs from
    parent (SEF_DACL_AUTO_INHERIT or SEF_SACL_AUTO_INHERIT), inherited
    ACEs from the parent will be appended after explicit ACEs from the
    CreatorDescriptor.


    Note that an explicitly specified ACL, whether a default ACL or
    not, may be empty or null.

    If the caller is explicitly assigning a system acl, default or
    non-default, the caller must either be a kernel mode client or
    must be appropriately privileged.


    Owner and Group Assignment
    --------------------------

    The assignment of the new object's owner and group is governed
    by the following logic:

       1)   If the passed security descriptor includes an owner, it
            is assigned as the new object's owner.  Otherwise, the
            caller's token is looked in for the owner.  Within the
            token, if there is a default owner, it is assigned.
            Otherwise, the caller's user ID is assigned.

       2)   If the passed security descriptor includes a group, it
            is assigned as the new object's group.  Otherwise, the
            caller's token is looked in for the group.  Within the
            token, if there is a default group, it is assigned.
            Otherwise, the caller's primary group ID is assigned.


Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a new object is being created.  If there is
        no parent directory, then this argument is specified as NULL.

    CreatorDescriptor - (Optionally) Points to a security descriptor
        presented by the creator of the object.  If the creator of the
        object did not explicitly pass security information for the new
        object, then a null pointer should be passed.

    NewDescriptor - Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor.

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    IsDirectoryObject - Specifies if the new object is going to be a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    AutoInheritFlags - Controls automatic inheritance of ACES from the Parent
        Descriptor.  Valid values are a bits mask of the logical OR of
        one or more of the following bits:

        SEF_DACL_AUTO_INHERIT - If set, inherit ACEs from the
            DACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_SACL_AUTO_INHERIT - If set, inherit ACEs from the
            SACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT - If set, the CreatorDescriptor
            is the default descriptor for ObjectType.  As such, the
            CreatorDescriptor will be ignored if any ObjectType specific
            ACEs are inherited from the parent.  If no such ACEs are inherited,
            the CreatorDescriptor is handled as though this flag were not
            specified.

        SEF_AVOID_PRIVILEGE_CHECK - If set, no privilege checking is done by this
            routine.  This flag is useful while implementing automatic inheritance
            to avoid checking privileges on each child updated.

        SEF_AVOID_OWNER_CHECK - If set, no owner checking is done by this routine.

        SEF_DEFAULT_OWNER_FROM_PARENT - If set, the owner of NewDescriptor will
            default to the owner from ParentDescriptor.  If not set, the owner
            of NewDescriptor will default to the user specified in Token.

            In either case, the owner of NewDescriptor is set to the owner from
            the CreatorDescriptor if that field is specified.

        SEF_DEFAULT_GROUP_FROM_PARENT - If set, the group of NewDescriptor will
            default to the group from ParentDescriptor.  If not set, the group
            of NewDescriptor will default to the group specified in Token.

            In either case, the group of NewDescriptor is set to the group from
            the CreatorDescriptor if that field is specified.

    Token - Supplies the token for the client on whose behalf the
        object is being created.  If it is an impersonation token,
        then it must be at SecurityIdentification level or higher.  If
        it is not an impersonation token, the operation proceeds
        normally.

        A client token is used to retrieve default security
        information for the new object, such as default owner, primary
        group, and discretionary access control.  The token must be
        open for TOKEN_QUERY access.

        For calls from the kernel, Supplies the security context of the subject creating the
        object. This is used to retrieve default security information for the
        new object, such as default owner, primary group, and discretionary
        access control.

        If not specified, the Owner and Primary group must be specified in the
        CreatorDescriptor.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    STATUS_SUCCESS - The operation was successful.

    STATUS_INVALID_OWNER - The owner SID provided as the owner of the
        target security descriptor is not one the subject is authorized to
        assign as the owner of an object.

    STATUS_NO_CLIENT_TOKEN - Indicates a client token was not explicitly
        provided and the caller is not currently impersonating a client.

    STATUS_PRIVILEGE_NOT_HELD - The caller does not have the privilege
        necessary to explicitly assign the specified system ACL.
        SeSecurityPrivilege privilege is needed to explicitly assign
        system ACLs to objects.


--*/
{


    SECURITY_DESCRIPTOR *CapturedDescriptor;
    SECURITY_DESCRIPTOR InCaseOneNotPassed;
    BOOLEAN SecurityDescriptorPassed;

    NTSTATUS Status;

    PACL NewSacl = NULL;
    BOOLEAN NewSaclInherited = FALSE;

    PACL NewDacl = NULL;
    PACL ServerDacl = NULL;
    BOOLEAN NewDaclInherited = FALSE;

    PSID NewOwner = NULL;
    PSID NewGroup = NULL;

    BOOLEAN SaclExplicitlyAssigned = FALSE;
    BOOLEAN OwnerExplicitlyAssigned = FALSE;
    BOOLEAN DaclExplicitlyAssigned = FALSE;

    BOOLEAN ServerDaclAllocated = FALSE;

    BOOLEAN ServerObject;
    BOOLEAN DaclUntrusted;

    BOOLEAN HasPrivilege;
    PRIVILEGE_SET PrivilegeSet;

    PSID SubjectContextOwner = NULL;
    PSID SubjectContextGroup = NULL;
    PSID ServerOwner = NULL;
    PSID ServerGroup = NULL;

    PACL SubjectContextDacl = NULL;

    ULONG AllocationSize;
    ULONG NewOwnerSize, OwnerSize;
    ULONG NewGroupSize, GroupSize;
    ULONG NewSaclSize;
    ULONG NewDaclSize;

    PCHAR Field;
    PCHAR Base;



    PISECURITY_DESCRIPTOR_RELATIVE INewDescriptor = NULL;
    NTSTATUS PassedStatus;
    KPROCESSOR_MODE RequestorMode;

    ULONG GenericControl;
    ULONG NewControlBits = SE_SELF_RELATIVE;

    //
    // For kernel mode callers, the Token parameter is really
    // a pointer to a subject context structure.
    //

    PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    PVOID SubjectContextInfo = NULL;

    SubjectSecurityContext = (PSECURITY_SUBJECT_CONTEXT)Token;

    RTL_PAGED_CODE();

    //
    //  Get the previous mode of the caller
    //

    RequestorMode = KeGetPreviousMode();

    //
    //  The desired end result is to build a self-relative security descriptor.
    //  This means that a single block of memory will be allocated and all
    //  security information copied into it.  To minimize work along the way,
    //  it is desirable to reference (rather than copy) each field as we
    //  determine its source.  This can not be done with inherited ACLs, however,
    //  since they must be built from another ACL.  So, explicitly assigned
    //  and defaulted SIDs and ACLs are just referenced until they are copied
    //  into the self-relative descriptor.  Inherited ACLs are built in a
    //  temporary buffer which must be deallocated after being copied to the
    //  self-relative descriptor.
    //



    //
    //  If a security descriptor has been passed, capture it, otherwise
    //  cobble up a fake one to simplify the code that follows.
    //

    if (ARGUMENT_PRESENT(CreatorDescriptor)) {

        CapturedDescriptor = CreatorDescriptor;
        SecurityDescriptorPassed = TRUE;

    } else {

        //
        //  No descriptor passed, make a fake one
        //

        SecurityDescriptorPassed = FALSE;

        RtlCreateSecurityDescriptor(&InCaseOneNotPassed,
                                    SECURITY_DESCRIPTOR_REVISION);
        CapturedDescriptor = &InCaseOneNotPassed;

    }


    if ( CapturedDescriptor->Control & SE_SERVER_SECURITY ) {
        ServerObject = TRUE;
    } else {
        ServerObject = FALSE;
    }

    if ( CapturedDescriptor->Control & SE_DACL_UNTRUSTED ) {
        DaclUntrusted = TRUE;
    } else {
        DaclUntrusted = FALSE;
    }



    //
    // Get the required information from the token.
    //
    //
    // Grab pointers to the default owner, primary group, and
    // discretionary ACL.
    //
    if ( Token != NULL || ServerObject ) {

        PSID TmpSubjectContextOwner = NULL;
        PSID TmpSubjectContextGroup = NULL;
        PSID TmpServerOwner = NULL;
        PSID TmpServerGroup = NULL;

        PACL TmpSubjectContextDacl = NULL;

        SIZE_T SubjectContextInfoSize = 0;

        //
        // Lock the subject context for read access so that the pointers
        // we copy out of it don't disappear on us at random
        //

        SeLockSubjectContext( SubjectSecurityContext );

        SepGetDefaultsSubjectContext(
            SubjectSecurityContext,
            &TmpSubjectContextOwner,
            &TmpSubjectContextGroup,
            &TmpServerOwner,
            &TmpServerGroup,
            &TmpSubjectContextDacl
            );

        //
        // We can't keep the subject context locked, because
        // we may have to do a privilege check later, which calls
        // PsLockProcessSecurityFields, which can cause a deadlock
        // with PsImpersonateClient, which takes them in the reverse
        // order.
        //
        // Since we're giving up our read lock on the token, we
        // need to copy all the stuff that we just got back.  Since
        // it's not going to change, we can save some cycles and copy
        // it all into a single chunck of memory.
        //

        SubjectContextInfoSize = SeLengthSid( TmpSubjectContextOwner ) +
                                 SeLengthSid( TmpServerOwner )         +
                                 (TmpSubjectContextGroup != NULL ? SeLengthSid( TmpSubjectContextGroup ) : 0) +
                                 (TmpServerGroup         != NULL ? SeLengthSid( TmpServerGroup )         : 0) +
                                 (TmpSubjectContextDacl  != NULL ? TmpSubjectContextDacl->AclSize        : 0);

        SubjectContextInfo = ExAllocatePoolWithTag( PagedPool, SubjectContextInfoSize, 'dSeS');

        if (SubjectContextInfo) {

            //
            // Copy in the data
            //

            Base = SubjectContextInfo;

            //
            // There will always be an owner.
            //

            SubjectContextOwner = (PSID)Base;
            RtlCopySid( SeLengthSid( TmpSubjectContextOwner), Base, TmpSubjectContextOwner );
            Base += SeLengthSid( TmpSubjectContextOwner);

            //
            // Groups may be NULL
            //

            if (TmpSubjectContextGroup != NULL) {
                SubjectContextGroup = (PSID)Base;
                RtlCopySid( SeLengthSid( TmpSubjectContextGroup), Base, TmpSubjectContextGroup );
                Base += SeLengthSid( TmpSubjectContextGroup );
            } else {
                SubjectContextGroup = NULL;
            }

            ServerOwner = (PSID)Base;
            RtlCopySid( SeLengthSid( TmpServerOwner ), Base, TmpServerOwner );
            Base += SeLengthSid( TmpServerOwner );

            //
            // Groups may be NULL
            //

            if (TmpServerGroup != NULL) {
                ServerGroup = (PSID)Base;
                RtlCopySid( SeLengthSid( TmpServerGroup ), Base, TmpServerGroup );
                Base += SeLengthSid( TmpServerGroup );
            } else {
                ServerGroup = NULL;
            }

            if (TmpSubjectContextDacl != NULL) {
                SubjectContextDacl = (PACL)Base;
                RtlCopyMemory( Base, TmpSubjectContextDacl, TmpSubjectContextDacl->AclSize );
                // Base += TmpSubjectContextDacl->AclSize;
            } else {
                SubjectContextDacl = NULL;
            }

        } else {

            SeUnlockSubjectContext( SubjectSecurityContext );

            return( STATUS_INSUFFICIENT_RESOURCES );
        }

        SeUnlockSubjectContext( SubjectSecurityContext );
    }



    //
    // Establish an owner SID
    //

    NewOwner = RtlpOwnerAddrSecurityDescriptor(CapturedDescriptor);

    if ((NewOwner) != NULL) {

        //
        // Use the specified owner
        //

        OwnerExplicitlyAssigned = TRUE;

    } else {

        //
        // If the caller said to default the owner from the parent descriptor,
        //  grab it now.
        //

        if ( AutoInheritFlags & SEF_DEFAULT_OWNER_FROM_PARENT) {
            if ( !ARGUMENT_PRESENT(ParentDescriptor) ) {
                Status = STATUS_INVALID_OWNER;
                goto Cleanup;
            }
            NewOwner = RtlpOwnerAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)ParentDescriptor);
            OwnerExplicitlyAssigned = TRUE;

            if ( NewOwner == NULL ) {
                Status = STATUS_INVALID_OWNER;
                goto Cleanup;
            }
        } else {

            //
            // Pick up the default from the subject's security context.
            //
            // This does NOT constitute explicit assignment of owner
            // and does not have to be checked as an ID that can be
            // assigned as owner.  This is because a default can not
            // be established in a token unless the user of the token
            // can assign it as an owner.
            //

            //
            // If we've been asked to create a ServerObject, we need to
            // make sure to pick up the new owner from the Primary token,
            // not the client token.  If we're not impersonating, they will
            // end up being the same.
            //

            NewOwner = ServerObject ? ServerOwner : SubjectContextOwner;

            //
            // Ensure an owner is now defined.
            //

            if ( NewOwner == NULL ) {
                Status = STATUS_NO_TOKEN;
                goto Cleanup;
            }
        }
    }


    //
    // Establish a Group SID
    //

    NewGroup = RtlpGroupAddrSecurityDescriptor(CapturedDescriptor);

    if (NewGroup == NULL) {

        //
        // If the caller said to default the group from the parent descriptor,
        //  grab it now.
        //

        if ( AutoInheritFlags & SEF_DEFAULT_GROUP_FROM_PARENT) {
            if ( !ARGUMENT_PRESENT(ParentDescriptor) ) {
                Status = STATUS_INVALID_PRIMARY_GROUP;
                goto Cleanup;
            }
            NewGroup = RtlpGroupAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)ParentDescriptor);
        } else {
            //
            // Pick up the primary group from the subject's security context
            //
            // If we're creating a Server object, use the group from the server
            // context.
            //

            NewGroup = ServerObject ? ServerGroup : SubjectContextGroup;

        }

    }

    if (NewGroup == NULL) {
        Status = STATUS_INVALID_PRIMARY_GROUP;
        goto Cleanup;
    }



    //
    // Establish System Acl
    //

    Status = RtlpInheritAcl (
                ARGUMENT_PRESENT(ParentDescriptor) ?
                    RtlpSaclAddrSecurityDescriptor(
                        ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
                    NULL,
                RtlpSaclAddrSecurityDescriptor(CapturedDescriptor),
                SeControlSaclToGeneric( CapturedDescriptor->Control ),
                IsDirectoryObject,
                (BOOLEAN)((AutoInheritFlags & SEF_SACL_AUTO_INHERIT) != 0),
                (BOOLEAN)((AutoInheritFlags & SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT) != 0),
                NewOwner,
                NewGroup,
                ServerOwner,
                ServerGroup,
                GenericMapping,
                TRUE,   // Is a SACL
                pObjectType,
                GuidCount,
                &NewSacl,
                &SaclExplicitlyAssigned,
                &GenericControl );

    if ( NT_SUCCESS(Status) ) {
        NewSaclInherited = TRUE;
        NewControlBits |= SE_SACL_PRESENT | SeControlGenericToSacl( GenericControl );

    } else if ( Status == STATUS_NO_INHERITANCE ) {

        //
        // Always set the auto inherit bit if the caller requested it.
        //

        if ( AutoInheritFlags & SEF_SACL_AUTO_INHERIT) {
            NewControlBits |= SE_SACL_AUTO_INHERITED;
        }

        //
        // No inheritable ACL - check for a defaulted one.
        //
        if ( RtlpAreControlBitsSet( CapturedDescriptor,
                                SE_SACL_PRESENT | SE_SACL_DEFAULTED ) ) {

            //
            // Reference the default ACL
            //

            NewSacl = RtlpSaclAddrSecurityDescriptor(CapturedDescriptor);
            NewControlBits |= SE_SACL_PRESENT;
            NewControlBits |= (CapturedDescriptor->Control & SE_SACL_PROTECTED);

            //
            // This counts as an explicit assignment.
            //
            SaclExplicitlyAssigned = TRUE;
        }

    } else {

        //
        // Some unusual error occured
        //

        goto Cleanup;
    }




    //
    // Establish Discretionary Acl
    //

    Status = RtlpInheritAcl (
                ARGUMENT_PRESENT(ParentDescriptor) ?
                    RtlpDaclAddrSecurityDescriptor(
                        ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
                    NULL,
                RtlpDaclAddrSecurityDescriptor(CapturedDescriptor),
                SeControlDaclToGeneric( CapturedDescriptor->Control ),
                IsDirectoryObject,
                (BOOLEAN)((AutoInheritFlags & SEF_DACL_AUTO_INHERIT) != 0),
                (BOOLEAN)((AutoInheritFlags & SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT) != 0),
                NewOwner,
                NewGroup,
                ServerOwner,
                ServerGroup,
                GenericMapping,
                FALSE,   // Is a DACL
                pObjectType,
                GuidCount,
                &NewDacl,
                &DaclExplicitlyAssigned,
                &GenericControl );

    if ( NT_SUCCESS(Status) ) {
        NewDaclInherited = TRUE;
        NewControlBits |= SE_DACL_PRESENT | SeControlGenericToDacl( GenericControl );

    } else if ( Status == STATUS_NO_INHERITANCE ) {

        //
        // Always set the auto inherit bit if the caller requested it.
        //

        if ( AutoInheritFlags & SEF_DACL_AUTO_INHERIT) {
            NewControlBits |= SE_DACL_AUTO_INHERITED;
        }

        //
        // No inheritable ACL - check for a defaulted one.
        //
        if ( RtlpAreControlBitsSet( CapturedDescriptor,
                                SE_DACL_PRESENT | SE_DACL_DEFAULTED ) ) {

            //
            // Reference the default ACL
            //

            NewDacl = RtlpDaclAddrSecurityDescriptor(CapturedDescriptor);
            NewControlBits |= SE_DACL_PRESENT;
            NewControlBits |= (CapturedDescriptor->Control & SE_DACL_PROTECTED);

            //
            // This counts as an explicit assignment.
            //
            DaclExplicitlyAssigned = TRUE;

        //
        // Default to the DACL on the token.
        //
        } else if (ARGUMENT_PRESENT(SubjectContextDacl)) {

            NewDacl = SubjectContextDacl;
            NewControlBits |= SE_DACL_PRESENT;

        }


    } else {

        //
        // Some unusual error occured
        //

        goto Cleanup;
    }

#ifdef  ASSERT_ON_NULL_DACL

    //
    // Culprit will probably be the caller NtCreate*, or
    // RtlNewSecurityObject.  Note that although this will not always occur
    // because of explicit user action it still must be corrected.
    //
    
    if (RtlpAssertOnNullDacls) {

        ASSERT(("NULL DACLs are NOT allowed!", NewDacl != NULL));
    }

#endif // ASSERT_ON_NULL_DACL

    //
    // If auto inheriting and the computed child DACL is NULL,
    //  mark it as protected.
    //
    // NULL DACLs are problematic when ACEs are actually inherited from the
    // parent DACL.  It is better to mark them as protected NOW (even if we don't
    // end up inheriting any ACEs) to avoid confusion later.
    //

    if ( (AutoInheritFlags & SEF_DACL_AUTO_INHERIT) != 0 &&
         NewDacl == NULL ) {
        NewControlBits |= SE_DACL_PROTECTED;
    }



    //
    // Now make sure that the caller has the right to assign
    // everything in the descriptor.  The requestor is subjected
    // to privilege and restriction tests for some assignments.
    //
    if (RequestorMode == UserMode) {


        //
        // Anybody can assign any Discretionary ACL or group that they want to.
        //

        //
        //  See if the system ACL was explicitly specified
        //

        if ( SaclExplicitlyAssigned &&
             (AutoInheritFlags & SEF_AVOID_PRIVILEGE_CHECK) == 0 ) {

            //
            // Require a Token if we're to do the privilege check.
            //

            if ( Token == NULL ) {
                Status = STATUS_NO_TOKEN;
                goto Cleanup;
            }

            //
            // Check for appropriate Privileges
            // Audit/Alarm messages need to be generated due to the attempt
            // to perform a privileged operation.
            //

            //
            // Note: be sure to do the privilege check against
            // the passed subject context!
            //

            PrivilegeSet.PrivilegeCount = 1;
            PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
            PrivilegeSet.Privilege[0].Luid = SeSecurityPrivilege;
            PrivilegeSet.Privilege[0].Attributes = 0;

            HasPrivilege = SePrivilegeCheck(
                               &PrivilegeSet,
                               SubjectSecurityContext,
                               RequestorMode
                               );

            if ( RequestorMode != KernelMode ) {

                SePrivilegedServiceAuditAlarm (
                    NULL,
                    SubjectSecurityContext,
                    &PrivilegeSet,
                    HasPrivilege
                    );
            }

            if ( !HasPrivilege ) {
                Status = STATUS_PRIVILEGE_NOT_HELD;
                goto Cleanup;
            }

        }

        //
        // See if the owner field is one the requestor can assign
        //

        if (OwnerExplicitlyAssigned &&
            (AutoInheritFlags & SEF_AVOID_OWNER_CHECK) == 0 ) {



            if (!SepValidOwnerSubjectContext(
                    SubjectSecurityContext,
                    NewOwner,
                    ServerObject)
                    ) {

                Status = STATUS_INVALID_OWNER;
                goto Cleanup;
            }
        }


        //
        // If the DACL was explictly assigned and this is a server object,
        //  convert the DACL to be a server DACL
        //

        if (DaclExplicitlyAssigned && ServerObject) {

            Status = RtlpCreateServerAcl(
                         NewDacl,
                         DaclUntrusted,
                         ServerOwner,
                         &ServerDacl,
                         &ServerDaclAllocated
                         );

            if (!NT_SUCCESS( Status )) {
                goto Cleanup;
            }
            
            if (NewDaclInherited && NewDacl) {
                ExFreePool( NewDacl );
            }

            NewDacl = ServerDacl;
            ServerDacl = NULL;
        }
    }


    //
    // Everything is assignable by the requestor.
    // Calculate the memory needed to house all the information in
    // a self-relative security descriptor.
    //
    // Also map the ACEs for application to the target object
    // type, if they haven't already been mapped.
    //
    OwnerSize = SeLengthSid(NewOwner);
    NewOwnerSize = LongAlignSize(OwnerSize);
    if (NewGroup != NULL) {
        GroupSize = SeLengthSid(NewGroup);
        NewGroupSize = LongAlignSize(GroupSize);
    }

    if ((NewControlBits & SE_SACL_PRESENT) && (NewSacl != NULL)) {
        NewSaclSize = LongAlignSize(NewSacl->AclSize);
    } else {
        NewSaclSize = 0;
    }

    if ( (NewControlBits & SE_DACL_PRESENT) && (NewDacl != NULL)) {
        NewDaclSize = LongAlignSize(NewDacl->AclSize);
    } else {
        NewDaclSize = 0;
    }

    AllocationSize = LongAlignSize(sizeof(SECURITY_DESCRIPTOR_RELATIVE)) +
                     NewOwnerSize +
                     NewGroupSize +
                     NewSaclSize  +
                     NewDaclSize;

    //
    // Allocate and initialize the security descriptor as
    // self-relative form.
    //

    INewDescriptor = (PSECURITY_DESCRIPTOR)ExAllocatePoolWithTag( PagedPool, AllocationSize, 'dSeS');

    if ( INewDescriptor == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCreateSecurityDescriptorRelative(
        INewDescriptor,
        SECURITY_DESCRIPTOR_REVISION
        );

    RtlpSetControlBits( INewDescriptor, NewControlBits );

    Base = (PCHAR)(INewDescriptor);
    Field =  Base + sizeof(SECURITY_DESCRIPTOR_RELATIVE);

    //
    // Map and Copy in the Sacl
    //

    if (NewControlBits & SE_SACL_PRESENT) {

        if (NewSacl != NULL) {

            RtlCopyMemory( Field, NewSacl, NewSacl->AclSize );

            if (!NewSaclInherited) {
                RtlpApplyAclToObject( (PACL)Field, GenericMapping );
            }

            INewDescriptor->Sacl = RtlPointerToOffset(Base,Field);
            if (NewSaclSize > NewSacl->AclSize) {
                RtlZeroMemory (Field + NewSacl->AclSize, NewSaclSize - NewSacl->AclSize);
            }
            Field += NewSaclSize;

        } else {

            INewDescriptor->Sacl = 0;
        }

    }

    //
    // Map and Copy in the Dacl
    //

    if (NewControlBits & SE_DACL_PRESENT) {

        if (NewDacl != NULL) {

            RtlCopyMemory( Field, NewDacl, NewDacl->AclSize );

            if (!NewDaclInherited) {
                RtlpApplyAclToObject( (PACL)Field, GenericMapping );
            }

            INewDescriptor->Dacl = RtlPointerToOffset(Base,Field);
            if (NewDaclSize > NewDacl->AclSize) {
                RtlZeroMemory (Field + NewDacl->AclSize, NewDaclSize - NewDacl->AclSize);
            }
            Field += NewDaclSize;

        } else {

            INewDescriptor->Dacl = 0;
        }

    }

    //
    // Assign the owner
    //

    RtlCopyMemory( Field, NewOwner, OwnerSize );
    if (NewOwnerSize > OwnerSize) {
        RtlZeroMemory (Field + OwnerSize, NewOwnerSize - OwnerSize);
    }
    INewDescriptor->Owner = RtlPointerToOffset(Base,Field);
    Field += NewOwnerSize;

    if (NewGroup != NULL) {
        RtlCopyMemory( Field, NewGroup, GroupSize );
        if (NewGroupSize > GroupSize) {
            RtlZeroMemory (Field + GroupSize, NewGroupSize - GroupSize);
        }
        INewDescriptor->Group = RtlPointerToOffset(Base,Field);
    }

    Status = STATUS_SUCCESS;



Cleanup:
    //
    // If we allocated memory for a Server DACL, free it now.
    //

    if (ServerDaclAllocated && ServerDacl != NULL) {
        ExFreePool( ServerDacl );
    }

    //
    // Either an error was encountered or the assignment has completed
    // successfully.  In either case, we have to clean up any memory.
    //

    if (SubjectContextInfo != NULL) {
        ExFreePool( SubjectContextInfo );
    }

    if (NewSaclInherited && NewSacl != NULL ) {
        ExFreePool( NewSacl );
    }

    if (NewDaclInherited && NewDacl != NULL ) {
        ExFreePool( NewDacl );
    }

    *NewDescriptor = (PSECURITY_DESCRIPTOR) INewDescriptor;


    return Status;
}


NTSTATUS
RtlpSetSecurityObject (
    IN PVOID Object OPTIONAL,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN ULONG AutoInheritFlags,
    IN ULONG PoolType,
    IN PGENERIC_MAPPING GenericMapping,
    IN HANDLE Token OPTIONAL
    )


/*++

Routine Description:

    Modify an object's existing self-relative form security descriptor.

    This procedure, called only from user mode, is used to update a
    security descriptor on an existing protected server's object.  It
    applies changes requested by a new security descriptor to the existing
    security descriptor.  If necessary, this routine will allocate
    additional memory to produce a larger security descriptor.  All access
    checking is expected to be done before calling this routine.  This
    includes checking for WRITE_OWNER, WRITE_DAC, and privilege to assign a
    system ACL as appropriate.

    The caller of this routine must not be impersonating a client.

                                  - - WARNING - -

    This service is for use by protected subsystems that project their own
    type of object.  This service is explicitly not for use by the
    executive for executive objects and must not be called from kernel
    mode.

Arguments:

    Object - Optionally supplies the object whose security is
        being adjusted.  This is used to update security quota
        information.

    SecurityInformation - Indicates which security information is
        to be applied to the object.  The value(s) to be assigned are
        passed in the ModificationDescriptor parameter.

    ModificationDescriptor - Supplies the input security descriptor to be
        applied to the object.  The caller of this routine is expected
        to probe and capture the passed security descriptor before calling
        and release it after calling.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor that is going to be altered by
        this procedure.  This security descriptor must be in self-
        relative form or an error will be returned.

    AutoInheritFlags - Controls automatic inheritance of ACES.
        Valid values are a bits mask of the logical OR of
        one or more of the following bits:

        SEF_DACL_AUTO_INHERIT - If set, inherited ACEs from the
            DACL in the ObjectsSecurityDescriptor are preserved and inherited ACEs from
            the ModificationDescriptor are ignored. Inherited ACEs are not supposed
            to be modified; so preserving them across this call is appropriate.
            If a protected server does not itself implement auto inheritance, it should
            not set this bit.  The caller of the protected server may implement
            auto inheritance and my indeed be modifying inherited ACEs.

        SEF_SACL_AUTO_INHERIT - If set, inherited ACEs from the
            SACL in the ObjectsSecurityDescriptor are preserved and inherited ACEs from
            the ModificationDescriptor are ignored. Inherited ACEs are not supposed
            to be modified; so preserving them across this call is appropriate.
            If a protected server does not itself implement auto inheritance, it should
            not set this bit.  The caller of the protected server may implement
            auto inheritance and my indeed be modifying inherited ACEs.

         SEF_AVOID_PRIVILEGE_CHECK - If set, the Token in not used to ensure the
            Owner passed in ModificationDescriptor is valid.

    PoolType - Specifies the type of pool to allocate for the objects
        security descriptor.

    GenericMapping - This argument provides the mapping of generic to
        specific/standard access types for the object being accessed.
        This mapping structure is expected to be safe to access
        (i.e., captured if necessary) prior to be passed to this routine.

    Token - (optionally) Supplies the token for the client on whose
        behalf the security is being modified.  This parameter is only
        required to ensure that the client has provided a legitimate
        value for a new owner SID.  The token must be open for
        TOKEN_QUERY access.

Return Value:

    STATUS_SUCCESS - The operation was successful.

    STATUS_INVALID_OWNER - The owner SID provided as the new owner of the
        target security descriptor is not one the caller is authorized to
        assign as the owner of an object, or the client did not pass
        a token at all.

    STATUS_NO_CLIENT_TOKEN - Indicates a client token was not explicitly
        provided and the caller is not currently impersonating a client.

    STATUS_BAD_DESCRIPTOR_FORMAT - Indicates the provided object's security
        descriptor was not in self-relative format.

--*/

{
    BOOLEAN NewGroupPresent = FALSE;
    BOOLEAN NewOwnerPresent = FALSE;

    BOOLEAN ServerAclAllocated = FALSE;
    BOOLEAN LocalDaclAllocated = FALSE;
    BOOLEAN LocalSaclAllocated = FALSE;
    BOOLEAN ServerObject;
    BOOLEAN DaclUntrusted;

    PCHAR Field;
    PCHAR Base;

    PISECURITY_DESCRIPTOR_RELATIVE NewDescriptor = NULL;

    NTSTATUS Status;

    TOKEN_STATISTICS ThreadTokenStatistics;

    ULONG ReturnLength;

    PSID NewGroup;
    PSID NewOwner;

    PACL NewDacl;
    PACL LocalDacl;
    PACL NewSacl;
    PACL LocalSacl;

    ULONG NewDaclSize;
    ULONG NewSaclSize;
    ULONG NewOwnerSize, OwnerSize;
    ULONG NewGroupSize, GroupSize;
    ULONG AllocationSize;
    ULONG ServerOwnerInfoSize;

    HANDLE PrimaryToken;
    ULONG GenericControl;
    ULONG NewControlBits = SE_SELF_RELATIVE;

    PACL ServerDacl;

    SECURITY_SUBJECT_CONTEXT SubjectContext;


    //
    // Typecast to internal representation of security descriptor.
    // Note that the internal one is not a pointer to a pointer.
    // It is just a pointer to a security descriptor.
    //
    PISECURITY_DESCRIPTOR IModificationDescriptor =
       (PISECURITY_DESCRIPTOR)ModificationDescriptor;

    PISECURITY_DESCRIPTOR *IObjectsSecurityDescriptor =
       (PISECURITY_DESCRIPTOR *)(ObjectsSecurityDescriptor);

    RTL_PAGED_CODE();

    //
    //  Validate that the provided SD is in self-relative form
    //

    if ( !RtlpAreControlBitsSet(*IObjectsSecurityDescriptor, SE_SELF_RELATIVE) ) {
        Status = STATUS_BAD_DESCRIPTOR_FORMAT;
        goto Cleanup;
    }

    //
    // Check to see if we need to edit the passed acl
    // either because we're creating a server object, or because
    // we were passed an untrusted ACL.
    //

    if (ARGUMENT_PRESENT(ModificationDescriptor)) {

        if ( RtlpAreControlBitsSet(IModificationDescriptor, SE_SERVER_SECURITY)) {
            ServerObject = TRUE;
        } else {
            ServerObject = FALSE;
        }

        if ( RtlpAreControlBitsSet(IModificationDescriptor, SE_DACL_UNTRUSTED)) {
            DaclUntrusted = TRUE;
        } else {
            DaclUntrusted = FALSE;
        }

    } else {

        ServerObject = FALSE;
        DaclUntrusted = FALSE;

    }


    //
    // For each item specified in the SecurityInformation, extract it
    // and get it to the point where it can be copied into a new
    // descriptor.
    //

    //
    // if he's setting the owner field, make sure he's
    // allowed to set that value as an owner.
    //

    if (SecurityInformation & OWNER_SECURITY_INFORMATION) {

        NewOwner = RtlpOwnerAddrSecurityDescriptor( IModificationDescriptor );
        NewOwnerPresent = TRUE;

        if ((AutoInheritFlags & SEF_AVOID_PRIVILEGE_CHECK) == 0 ) {


            SeCaptureSubjectContext( &SubjectContext );

            if (!SepValidOwnerSubjectContext( &SubjectContext, NewOwner, ServerObject ) ) {

                SeReleaseSubjectContext( &SubjectContext );
                return( STATUS_INVALID_OWNER );

            } else {

                SeReleaseSubjectContext( &SubjectContext );
            }
        }

    } else {

        NewOwner = RtlpOwnerAddrSecurityDescriptor ( *IObjectsSecurityDescriptor );
        if (NewOwner == NULL) {
            Status = STATUS_INVALID_OWNER;
            goto Cleanup;
        }

    }
    ASSERT( NewOwner != NULL );
    if (!RtlValidSid( NewOwner )) {
        Status = STATUS_INVALID_OWNER;
        goto Cleanup;
    }


    if (SecurityInformation & GROUP_SECURITY_INFORMATION) {

        NewGroup = RtlpGroupAddrSecurityDescriptor(IModificationDescriptor);
        NewGroupPresent = TRUE;

    } else {

        NewGroup = RtlpGroupAddrSecurityDescriptor( *IObjectsSecurityDescriptor );
    }

    if (NewGroup != NULL) {
        if (!RtlValidSid( NewGroup )) {
            Status = STATUS_INVALID_PRIMARY_GROUP;
            goto Cleanup;
        }
    } else {
        Status = STATUS_INVALID_PRIMARY_GROUP;
        goto Cleanup;
    }


    if (SecurityInformation & DACL_SECURITY_INFORMATION) {

#ifdef  ASSERT_ON_NULL_DACL

        //
        // Culprit will probably be the caller NtSetSecurityObject, or
        // RtlSetSecurityObject. 
        // 

        if (RtlpAssertOnNullDacls) {

            ASSERT(("NULL DACLs are NOT allowed!",
                    RtlpDaclAddrSecurityDescriptor(IModificationDescriptor) != NULL));
        }
#endif // ASSERT_ON_NULL_DACL

        //
        // If AutoInherit is requested,
        //  build a merged ACL.
        //

        if ( AutoInheritFlags & SEF_DACL_AUTO_INHERIT ) {
            Status = RtlpComputeMergedAcl(
                        RtlpDaclAddrSecurityDescriptor( *IObjectsSecurityDescriptor ),
                        SeControlDaclToGeneric( (*IObjectsSecurityDescriptor)->Control ),
                        RtlpDaclAddrSecurityDescriptor( IModificationDescriptor ),
                        SeControlDaclToGeneric( IModificationDescriptor->Control ),
                        NewOwner,
                        NewGroup,
                        GenericMapping,
                        FALSE,      // Not a SACL
                        &LocalDacl,
                        &GenericControl );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            LocalDaclAllocated = TRUE;
            NewDacl = LocalDacl;
            NewControlBits |= SE_DACL_PRESENT;
            NewControlBits |= SeControlGenericToDacl( GenericControl );

        //
        // If AutoInherit isn't requested,
        //  just grab a copy of the input DACL.
        //

        } else {
            NewDacl = RtlpDaclAddrSecurityDescriptor( IModificationDescriptor );
            NewControlBits |= SE_DACL_PRESENT;
            NewControlBits |= IModificationDescriptor->Control & SE_DACL_PROTECTED;

            //
            // If the original caller claims he understands auto inheritance,
            //  preserve the AutoInherited flag.
            //

            if ( RtlpAreControlBitsSet(IModificationDescriptor, SE_DACL_AUTO_INHERIT_REQ|SE_DACL_AUTO_INHERITED) ) {
                NewControlBits |= SE_DACL_AUTO_INHERITED;
            }
        }

        if (ServerObject) {

            PSID SubjectContextOwner;
            PSID SubjectContextGroup;
            PSID SubjectContextServerOwner;
            PSID SubjectContextServerGroup;
            PACL SubjectContextDacl;

            SeCaptureSubjectContext( &SubjectContext );

            SepGetDefaultsSubjectContext(
                &SubjectContext,
                &SubjectContextOwner,
                &SubjectContextGroup,
                &SubjectContextServerOwner,
                &SubjectContextServerGroup,
                &SubjectContextDacl
                );

            Status = RtlpCreateServerAcl(
                         NewDacl,
                         DaclUntrusted,
                         SubjectContextServerOwner,
                         &ServerDacl,
                         &ServerAclAllocated
                         );

            SeReleaseSubjectContext( &SubjectContext );

            if (!NT_SUCCESS( Status )) {
                goto Cleanup;
            }

            NewDacl = ServerDacl;

        }

    } else {

        NewDacl = RtlpDaclAddrSecurityDescriptor( *IObjectsSecurityDescriptor );
    }



    if (SecurityInformation & SACL_SECURITY_INFORMATION) {


        //
        // If AutoInherit is requested,
        //  build a merged ACL.
        //

        if ( AutoInheritFlags & SEF_SACL_AUTO_INHERIT ) {
            Status = RtlpComputeMergedAcl(
                        RtlpSaclAddrSecurityDescriptor( *IObjectsSecurityDescriptor ),
                        SeControlSaclToGeneric( (*IObjectsSecurityDescriptor)->Control ),
                        RtlpSaclAddrSecurityDescriptor( IModificationDescriptor ),
                        SeControlSaclToGeneric( IModificationDescriptor->Control ),
                        NewOwner,
                        NewGroup,
                        GenericMapping,
                        TRUE,      // Is a SACL
                        &LocalSacl,
                        &GenericControl );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }
            LocalSaclAllocated = TRUE;
            NewSacl = LocalSacl;
            NewControlBits |= SE_SACL_PRESENT;
            NewControlBits |= SeControlGenericToSacl( GenericControl );
        } else {
            NewSacl = RtlpSaclAddrSecurityDescriptor( IModificationDescriptor );
            NewControlBits |= SE_SACL_PRESENT;
            NewControlBits |= IModificationDescriptor->Control & SE_SACL_PROTECTED;

            //
            // If the original caller claims he understands auto inheritance,
            //  preserve the AutoInherited flag.
            //

            if ( RtlpAreControlBitsSet(IModificationDescriptor, SE_SACL_AUTO_INHERIT_REQ|SE_SACL_AUTO_INHERITED) ) {
                NewControlBits |= SE_SACL_AUTO_INHERITED;
            }
        }

    } else {

        NewSacl = RtlpSaclAddrSecurityDescriptor( *IObjectsSecurityDescriptor );
    }


    //
    // Everything is assignable by the requestor.
    // Calculate the memory needed to house all the information in
    // a self-relative security descriptor.
    //
    // Also map the ACEs for application to the target object
    // type, if they haven't already been mapped.
    //
    OwnerSize = SeLengthSid(NewOwner);
    NewOwnerSize = LongAlignSize(OwnerSize);

    if (NewGroup != NULL) {
        GroupSize = SeLengthSid(NewGroup);
    } else {
        GroupSize = 0;
    }
    NewGroupSize = LongAlignSize(GroupSize);

    if (NewSacl != NULL) {
        NewSaclSize = LongAlignSize(NewSacl->AclSize);
    } else {
        NewSaclSize = 0;
    }

    if (NewDacl !=NULL) {
        NewDaclSize = LongAlignSize(NewDacl->AclSize);
    } else {
        NewDaclSize = 0;
    }

    AllocationSize = LongAlignSize(sizeof(SECURITY_DESCRIPTOR_RELATIVE)) +
                     NewOwnerSize +
                     NewGroupSize +
                     NewSaclSize  +
                     NewDaclSize;

    //
    // Allocate and initialize the security descriptor as
    // self-relative form.
    //

    NewDescriptor = ExAllocatePoolWithTag(PoolType, AllocationSize, 'dSeS');

    if ( NewDescriptor == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = RtlCreateSecurityDescriptorRelative(
                 NewDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );

    ASSERT( NT_SUCCESS( Status ) );

    //
    // We must check to make sure that the Group and Dacl size
    // do not exceed the quota preallocated for this object's
    // security when it was created.
    //
    // Update SeComputeSecurityQuota if this changes.
    //


    if (ARGUMENT_PRESENT( Object )) {

        Status = ObValidateSecurityQuota(
                     Object,
                     NewGroupSize + NewDaclSize
                     );

        if (!NT_SUCCESS( Status )) {

            //
            // The new information is too big.
            //

            ExFreePool( NewDescriptor );
            goto Cleanup;
        }

    }

    Base = (PCHAR)NewDescriptor;
    Field =  Base + sizeof(SECURITY_DESCRIPTOR_RELATIVE);

    //
    // Map and Copy in the Sacl
    //


    //         if new item {
    //             PRESENT=TRUE
    //             DEFAULTED=FALSE
    //             if (NULL) {
    //                 set new pointer to NULL
    //             } else {
    //                 copy into new SD
    //             }
    //         } else {
    //             copy PRESENT bit
    //             copy DEFAULTED bit
    //             if (NULL) {
    //                 set new pointer to NULL
    //             } else {
    //                 copy old one into new SD
    //             }
    //         }

    RtlpSetControlBits( NewDescriptor, NewControlBits );


    if (IModificationDescriptor->Control & SE_RM_CONTROL_VALID) {
        NewDescriptor->Sbz1 = IModificationDescriptor->Sbz1;
        NewDescriptor->Control |= SE_RM_CONTROL_VALID;
    }

    if (NewSacl == NULL) {
        NewDescriptor->Sacl = 0;

    } else {
        RtlCopyMemory( Field, NewSacl, NewSacl->AclSize );
        RtlpApplyAclToObject( (PACL)Field, GenericMapping );
        NewDescriptor->Sacl = RtlPointerToOffset(Base,Field);
        if (NewSaclSize > NewSacl->AclSize) {
            RtlZeroMemory( Field + NewSacl->AclSize, NewSaclSize - NewSacl->AclSize);
        }
        Field += NewSaclSize;
    }




    if ( (NewControlBits & SE_SACL_PRESENT) == 0 ) {

        //
        // Propagate the SE_SACL_DEFAULTED and SE_SACL_PRESENT
        // bits from the old security descriptor into the new
        // one.
        //

        RtlpPropagateControlBits(
            NewDescriptor,
            *IObjectsSecurityDescriptor,
            SE_SACL_DEFAULTED | SE_SACL_PRESENT | SE_SACL_PROTECTED | SE_SACL_AUTO_INHERITED
            );

    }



    //
    // Fill in Dacl field in new SD
    //

    if (NewDacl == NULL) {
        NewDescriptor->Dacl = 0;

    } else {
        RtlCopyMemory( Field, NewDacl, NewDacl->AclSize );
        RtlpApplyAclToObject( (PACL)Field, GenericMapping );
        NewDescriptor->Dacl = RtlPointerToOffset(Base,Field);
        if (NewDaclSize > NewDacl->AclSize) {
            RtlZeroMemory( Field + NewDacl->AclSize, NewDaclSize - NewDacl->AclSize);
        }
        Field += NewDaclSize;
    }


    if ( (NewControlBits & SE_DACL_PRESENT) == 0 ) {

        //
        // Propagate the SE_DACL_DEFAULTED and SE_DACL_PRESENT
        // bits from the old security descriptor into the new
        // one.
        //

        RtlpPropagateControlBits(
            NewDescriptor,
            *IObjectsSecurityDescriptor,
            SE_DACL_DEFAULTED | SE_DACL_PRESENT | SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED
            );

    }

//         if new item {
//             PRESENT=TRUE
//             DEFAULTED=FALSE
//             if (NULL) {
//                 set new pointer to NULL
//             } else {
//                 copy into new SD
//             }
//         } else {
//             copy PRESENT bit
//             copy DEFAULTED bit
//             if (NULL) {
//                 set new pointer to NULL
//             } else {
//                 copy old one into new SD
//             }
//         }


    //
    // Fill in Owner field in new SD
    //

    RtlCopyMemory( Field, NewOwner, OwnerSize );
    if (OwnerSize < NewOwnerSize) {
        RtlZeroMemory( Field + OwnerSize, NewOwnerSize - OwnerSize );
    }
    NewDescriptor->Owner = RtlPointerToOffset(Base,Field);
    Field += NewOwnerSize;

    if (!NewOwnerPresent) {

        //
        // Propagate the SE_OWNER_DEFAULTED bit from the old SD.
        // If a new owner is being assigned, we want to leave
        // SE_OWNER_DEFAULTED off, which means leave it alone.
        //

        RtlpPropagateControlBits(
            NewDescriptor,
            *IObjectsSecurityDescriptor,
            SE_OWNER_DEFAULTED
            );

    } else {
        ASSERT( !RtlpAreControlBitsSet( NewDescriptor, SE_OWNER_DEFAULTED ) );
    }


    //
    // Fill in Group field in new SD
    //

    if ( NewGroup != NULL) {
        RtlCopyMemory( Field, NewGroup, GroupSize );
        if (GroupSize < NewGroupSize) {
            RtlZeroMemory( Field + GroupSize, NewGroupSize - GroupSize);
        }
        NewDescriptor->Group = RtlPointerToOffset(Base,Field);
    }

    if (!NewGroupPresent) {

        //
        // Propagate the SE_GROUP_DEFAULTED bit from the old SD
        // If a new owner is being assigned, we want to leave
        // SE_GROUP_DEFAULTED off, which means leave it alone.
        //

        RtlpPropagateControlBits(
            NewDescriptor,
            *IObjectsSecurityDescriptor,
            SE_GROUP_DEFAULTED
            );
    } else {
        ASSERT( !RtlpAreControlBitsSet( NewDescriptor, SE_GROUP_DEFAULTED ) );

    }

    //
    // Free old descriptor
    //

    // Kernel version doesn't free the old descriptor

    *ObjectsSecurityDescriptor = (PSECURITY_DESCRIPTOR)NewDescriptor;
    Status = STATUS_SUCCESS;

Cleanup:
    if ( LocalDaclAllocated ) {
        ExFreePool( LocalDacl );
    }
    if ( LocalSaclAllocated ) {
        ExFreePool( LocalSacl );
    }
    if (ServerAclAllocated) {
        ExFreePool( ServerDacl );
    }

    return( Status );
}

BOOLEAN RtlpValidateSDOffsetAndSize (
    IN ULONG   Offset,
    IN ULONG   Length,
    IN ULONG   MinLength,
    OUT PULONG MaxLength
    )
/*++

Routine Description:

    This procedure validates offsets within a SecurityDescriptor.
    It checks that the structure can have the minimum length,
    not overlap with the fixed header and returns the maximum size
    of the item and longword alignment.

Arguments:

    Offset - Offset from start of SD of structure to validate
    Length - Total size of SD
    MinLength - Minimum size this structure can be
    MaxLength - Returns the maximum length this item can be given by
                the enclosing structure.

Return Value:

    BOOLEAN - TRUE if the item is valid


--*/

{
    ULONG Left;

    *MaxLength = 0;
    //
    // Don't allow overlap with header just in case caller modifies control bits etc
    //
    if (Offset < sizeof (SECURITY_DESCRIPTOR_RELATIVE)) {
       return FALSE;
    }

    //
    // Don't allow offsets beyond the end of the buffer
    //
    if (Offset >= Length) {
       return FALSE;
    }

    //
    // Calculate maximum size of segment and check its limits
    //
    Left = Length - Offset;

    if (Left < MinLength) {
       return FALSE;
    }

    //
    // Reject unaligned offsets
    //
    if (Offset & (sizeof (ULONG) - 1)) {
       return FALSE;
    }
    *MaxLength = Left;
    return TRUE;
}


BOOLEAN
RtlValidRelativeSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    )

/*++

Routine Description:

    This procedure validates a SecurityDescriptor's structure
    contained within a flat buffer.  This involves validating
    the revision levels of each component of the security
    descriptor.

Arguments:

    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure
        to validate.
    SecurityDescriptorLength - Size of flat buffer containing the security
        descriptor.
    RequiredInformation - Which SD components must be present to be valid.
        OWNER_SECURITY_INFORMATION etc as a bit mask.
        OWNER_SECURITY_INFORMATION - There must be a valid owner SID
        GROUP_SECURITY_INFORMATION - There must be a valid group SID
        DACL_SECURITY_INFORMATION - Ignored
        SACL_SECURITY_INFORMATION - Ignored

Return Value:

    BOOLEAN - TRUE if the structure of SecurityDescriptor is valid.


--*/

{
    PISECURITY_DESCRIPTOR_RELATIVE SecurityDescriptor;
    PISID OwnerSid;
    PISID GroupSid;
    PACE_HEADER Ace;
    PACL Dacl;
    PACL Sacl;
    ULONG MaxOwnerSidLength;
    ULONG MaxGroupSidLength;
    ULONG MaxDaclLength;
    ULONG MaxSaclLength;

    if (SecurityDescriptorLength < sizeof(SECURITY_DESCRIPTOR_RELATIVE)) {
        return FALSE;
    }

    //
    // Check the revision information.
    //

    if (((PISECURITY_DESCRIPTOR) SecurityDescriptorInput)->Revision !=
             SECURITY_DESCRIPTOR_REVISION) {
        return FALSE;
    }

    //
    // Make sure the passed SecurityDescriptor is in self-relative form
    //

    if (!(((PISECURITY_DESCRIPTOR) SecurityDescriptorInput)->Control & SE_SELF_RELATIVE)) {
        return FALSE;
    }

    SecurityDescriptor = (PISECURITY_DESCRIPTOR_RELATIVE) SecurityDescriptorInput;

    //
    // Validate the owner if it's there and see if its allowed to be missing
    //
    if (SecurityDescriptor->Owner == 0) {
        if (RequiredInformation & OWNER_SECURITY_INFORMATION) {
            return FALSE;
        }
    } else {
        if (!RtlpValidateSDOffsetAndSize (SecurityDescriptor->Owner,
                                          SecurityDescriptorLength,
                                          sizeof (SID),
                                          &MaxOwnerSidLength)) {
            return FALSE;
        }
        //
        // It is safe to reference the owner's SubAuthorityCount, compute the
        // expected length of the SID
        //

        OwnerSid = (PSID)RtlOffsetToPointer (SecurityDescriptor,
                                             SecurityDescriptor->Owner);

        if (OwnerSid->Revision != SID_REVISION) {
            return FALSE;
        }

        if (OwnerSid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
            return FALSE;
        }

        if (MaxOwnerSidLength < (ULONG) SeLengthSid (OwnerSid)) {
            return FALSE;
        }

    }

    //
    // The owner appears to be a structurally valid SID that lies within
    // the bounds of the security descriptor.  Do the same for the Group
    // if there is one.
    //
    //
    // Validate the group if it's there and see if its allowed to be missing
    //
    if (SecurityDescriptor->Group == 0) {
        if (RequiredInformation & GROUP_SECURITY_INFORMATION) {
            return FALSE;
        }
    } else {
        if (!RtlpValidateSDOffsetAndSize (SecurityDescriptor->Group,
                                          SecurityDescriptorLength,
                                          sizeof (SID),
                                          &MaxGroupSidLength)) {
            return FALSE;
        }
        //
        // It is safe to reference the group's SubAuthorityCount, compute the
        // expected length of the SID
        //

        GroupSid = (PSID)RtlOffsetToPointer (SecurityDescriptor,
                                             SecurityDescriptor->Group);

        if (GroupSid->Revision != SID_REVISION) {
            return FALSE;
        }

        if (GroupSid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
            return FALSE;
        }

        if (MaxGroupSidLength < (ULONG) SeLengthSid (GroupSid)) {
             return FALSE;
        }

    }

    //
    // Validate the DACL if it's there and check if its allowed to be missing.
    //

    if (!RtlpAreControlBitsSet (SecurityDescriptor, SE_DACL_PRESENT)) {
//
// Some code does this kind of thing:
//
// InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);
// RegSetKeySecurity(hKey, DACL_SECURITY_INFORMATION, &sd) )
//
// With the current system this works the same as passing in a NULL DACL but it looks
// almost by accident
//
//        if (RequiredInformation & DACL_SECURITY_INFORMATION) {
//            return FALSE;
//        }
    } else if (SecurityDescriptor->Dacl) {
        if (!RtlpValidateSDOffsetAndSize (SecurityDescriptor->Dacl,
                                          SecurityDescriptorLength,
                                          sizeof (ACL),
                                          &MaxDaclLength)) {
            return FALSE;
        }

        Dacl = (PACL) RtlOffsetToPointer (SecurityDescriptor,
                                          SecurityDescriptor->Dacl);

        //
        // Make sure the DACL length fits within the bounds of the security descriptor.
        //
        if (MaxDaclLength < Dacl->AclSize) {
            return FALSE;
        }

        //
        // Make sure the ACL is structurally valid.
        //
        if (!RtlValidAcl (Dacl)) {
            return FALSE;
        }
    }

    //
    // Validate the SACL if it's there and check if its allowed to be missing.
    //

    if (!RtlpAreControlBitsSet (SecurityDescriptor, SE_SACL_PRESENT)) {
//        if (RequiredInformation & SACL_SECURITY_INFORMATION) {
//            return FALSE;
//        }
    } else if (SecurityDescriptor->Sacl) {
        if (!RtlpValidateSDOffsetAndSize (SecurityDescriptor->Sacl,
                                          SecurityDescriptorLength,
                                          sizeof (ACL),
                                          &MaxSaclLength)) {
            return FALSE;
        }

        Sacl = (PACL) RtlOffsetToPointer (SecurityDescriptor,
                                          SecurityDescriptor->Sacl);

        //
        // Make sure the SACL length fits within the bounds of the security descriptor.
        //

        if (MaxSaclLength < Sacl->AclSize) {
            return FALSE;
        }

        //
        // Make sure the ACL is structurally valid.
        //

        if (!RtlValidAcl (Sacl)) {
            return FALSE;
        }
    }

    return TRUE;
}





BOOLEAN
RtlGetSecurityDescriptorRMControl(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PUCHAR RMControl
    )

/*++

Routine Description:

    This procedure returns the RM Control flags from a SecurityDescriptor if
    SE_RM_CONTROL_VALID flags is present in the control field.

Arguments:

    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure
    RMControl          - Returns the flags in the SecurityDescriptor if
                         SE_RM_CONTROL_VALID is set in the control bits of the
                         SecurityDescriptor.


Return Value:

    BOOLEAN - TRUE if SE_RM_CONTROL_VALID is set in the Control bits of the
              SecurityDescriptor.

Note:
    Parameter validation has already been done in Advapi.


--*/

{
    PISECURITY_DESCRIPTOR ISecurityDescriptor = (PISECURITY_DESCRIPTOR) SecurityDescriptor;

    if (!(ISecurityDescriptor->Control & SE_RM_CONTROL_VALID))
    {
        *RMControl = 0;
        return FALSE;
    }

    *RMControl = ISecurityDescriptor->Sbz1;

    return TRUE;
}


BOOLEAN
RtlpGuidPresentInGuidList(
    IN GUID *InheritedObjectType,
    IN GUID **pNewObjectType,
    IN ULONG GuidCount
    )

/*++

Routine Description:

    This routine returns whether a given guid is present in a list of guids.

Arguments:

    InheritedObjectType - Guid from the ace that will be compared against 
        the object types for the object.
        
    pNewObjectType - List of types of object being inherited to.

    GuidCount - Number of object types in the list.


Return Value:

    Returns TRUE if the given guid is present in the list of guids.
    FALSE otherwise.

--*/

{
    ULONG i;

    for (i = 0; i < GuidCount; i++) {

        if (RtlEqualMemory(
                InheritedObjectType,
                pNewObjectType[i],
                sizeof(GUID) ) ) {

            return TRUE;
        }

    }

    return FALSE;
}


VOID
RtlSetSecurityDescriptorRMControl(
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PUCHAR RMControl OPTIONAL
    )

/*++

Routine Description:

    This procedure sets the RM Control flag in the control field of
    SecurityDescriptor and sets Sbz1 to the the byte to which RMContol points.
    If RMControl is NULL then the bits are cleared.

Arguments:

    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure
    RMControl          - Pointer to the flags to set. If NULL then the bits
                         are cleared.

Note:
    Parameter validation has already been done in Advapi.


--*/

{
    PISECURITY_DESCRIPTOR ISecurityDescriptor = (PISECURITY_DESCRIPTOR) SecurityDescriptor;

    if (ARGUMENT_PRESENT(RMControl)) {
        ISecurityDescriptor->Control |= SE_RM_CONTROL_VALID;
        ISecurityDescriptor->Sbz1 = *RMControl;
    } else {
        ISecurityDescriptor->Control &= ~SE_RM_CONTROL_VALID;
        ISecurityDescriptor->Sbz1 = 0;
    }
}

NTSTATUS
RtlMapSecurityErrorToNtStatus(
    IN SECURITY_STATUS Error
    )
/*++

Routine Description:

    This procedure maps a security HRESULT to the proper NTSTATUS code.
    
Arguments:

    Error - a security HRESULT
    
Return Value:  The NTSTATUS code corresponding to the HRESULT. If no
               status code can be mapped, the original error is returned.

Note:
    


--*/
{
    NTSTATUS Status;

    switch(Error) {
    case SEC_E_INSUFFICIENT_MEMORY : Status = STATUS_INSUFFICIENT_RESOURCES; break;
    case SEC_E_INVALID_HANDLE : Status = STATUS_INVALID_HANDLE; break;
    case SEC_E_UNSUPPORTED_FUNCTION : Status = STATUS_NOT_SUPPORTED; break;
    case SEC_E_TARGET_UNKNOWN : Status = STATUS_BAD_NETWORK_PATH; break;
    case SEC_E_INTERNAL_ERROR : Status = STATUS_INTERNAL_ERROR; break;
    case SEC_E_SECPKG_NOT_FOUND : Status = STATUS_NO_SUCH_PACKAGE; break;
    case SEC_E_NOT_OWNER : Status = STATUS_PRIVILEGE_NOT_HELD; break;
    case SEC_E_CANNOT_INSTALL : Status = STATUS_NO_SUCH_PACKAGE; break;
    case SEC_E_INVALID_TOKEN : Status = STATUS_INVALID_PARAMETER; break;
    case SEC_E_CANNOT_PACK : Status = STATUS_INVALID_PARAMETER; break;
    case SEC_E_QOP_NOT_SUPPORTED : Status = STATUS_NOT_SUPPORTED; break;
    case SEC_E_NO_IMPERSONATION : Status = STATUS_CANNOT_IMPERSONATE; break;
    case SEC_E_LOGON_DENIED : Status = STATUS_LOGON_FAILURE; break;
    case SEC_E_UNKNOWN_CREDENTIALS : Status = STATUS_NO_SUCH_LOGON_SESSION; break;
    case SEC_E_NO_CREDENTIALS : Status = STATUS_NO_SUCH_LOGON_SESSION; break;
    case SEC_E_MESSAGE_ALTERED : Status = STATUS_ACCESS_DENIED; break;
    case SEC_E_OUT_OF_SEQUENCE : Status = STATUS_ACCESS_DENIED; break;
    case SEC_E_NO_AUTHENTICATING_AUTHORITY : Status = STATUS_NO_LOGON_SERVERS; break;
    case SEC_E_BAD_PKGID : Status = STATUS_NO_SUCH_PACKAGE; break;
    case SEC_E_TIME_SKEW : Status = STATUS_TIME_DIFFERENCE_AT_DC; break;

    default: Status = (NTSTATUS) Error;
    }

    return(Status);
}

#if defined(ALLOC_DATA_PRAGMA)
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\stktrace.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    stktrace.c

Abstract:

    This module implements routines to snapshot a set of stack back traces
    in a data base.  Useful for heap allocators to track allocation requests
    cheaply.

--*/

#include <ntos.h>
#include <ntrtl.h>
#include "ntrtlp.h"
#include <nturtl.h>
#include <zwapi.h>
#include <stktrace.h>

//
// Number of buckets used for the simple chaining hash table.
//

#define NUMBER_OF_BUCKETS 1567

//
// Macros to hide the different synchronization routines for
// user mode and kernel mode runtimes. For kernel runtime
// the OKAY_TO_LOCK macro points to a real function that makes
// sure current thread is not executing a DPC routine.
//

typedef struct _KSPIN_LOCK_EX {

    KSPIN_LOCK Lock;
    KIRQL OldIrql;
    PKTHREAD Owner;

} KSPIN_LOCK_EX, *PKSPIN_LOCK_EX;

NTSTATUS
KeInitializeSpinLockEx (
    PKSPIN_LOCK_EX Lock
    )
{
    KeInitializeSpinLock (&(Lock->Lock));
    Lock->OldIrql = 0;
    Lock->Owner = NULL;
    return STATUS_SUCCESS;
}

VOID
KeAcquireSpinLockEx (
    PKSPIN_LOCK_EX Lock
    )
{
    KeAcquireSpinLock (&(Lock->Lock), &(Lock->OldIrql));
    Lock->Owner = KeGetCurrentThread();
}

VOID
KeReleaseSpinLockEx (
    PKSPIN_LOCK_EX Lock
    )
{
    Lock->Owner = NULL;
    KeReleaseSpinLock (&(Lock->Lock), (Lock->OldIrql));
}

#define INITIALIZE_DATABASE_LOCK(R) KeInitializeSpinLockEx((PKSPIN_LOCK_EX)R)
#define ACQUIRE_DATABASE_LOCK(R) KeAcquireSpinLockEx((PKSPIN_LOCK_EX)R)
#define RELEASE_DATABASE_LOCK(R) KeReleaseSpinLockEx((PKSPIN_LOCK_EX)R)
#define OKAY_TO_LOCK_DATABASE(R) ExOkayToLockRoutine(&(((PKSPIN_LOCK_EX)R)->Lock))

BOOLEAN
ExOkayToLockRoutine (
    IN PVOID Lock
    );

//
// Globals from elsewhere referred here.
//

extern BOOLEAN RtlpFuzzyStackTracesEnabled;

//
// Forward declarations of private functions.
//

USHORT
RtlpLogStackBackTraceEx(
    ULONG FramesToSkip
    );

LOGICAL
RtlpCaptureStackTraceForLogging (
    PRTL_STACK_TRACE_ENTRY Trace,
    PULONG Hash,
    ULONG FramesToSkip,
    LOGICAL UserModeStackFromKernelMode
    );

USHORT
RtlpLogCapturedStackTrace(
    PRTL_STACK_TRACE_ENTRY Trace,
    ULONG Hash
    );

PRTL_STACK_TRACE_ENTRY
RtlpExtendStackTraceDataBase(
    IN PRTL_STACK_TRACE_ENTRY InitialValue,
    IN SIZE_T Size
    );

//
// Global per process (user mode) or system wide (kernel mode) 
// stack trace database.
//

PSTACK_TRACE_DATABASE RtlpStackTraceDataBase;

//
// Resource used to control access to stack trace database. We opted for 
// this solution so that we kept change in the database structure to an 
// absolute minimal. This way the tools that depend on this structure
// (at least umhd and oh) will not need a new version and will not
// introduce backcompatibility issues.
//

KSPIN_LOCK_EX RtlpStackTraceDataBaseLock;

/////////////////////////////////////////////////////////////////////
//////////////////////////////////////// Runtime stack trace database
/////////////////////////////////////////////////////////////////////

//
// The following section implements a trace database used to store
// stack traces captured with RtlCaptureStackBackTrace(). The database
// is implemented as a hash table and does not allow deletions. It is
// sensitive to "garbage" in the sense that spurious garbage (partially
// correct stacks) will hash in different buckets and will tend to fill
// the whole table. This is a problem only on x86 if "fuzzy" stack traces
// are used. The typical function used to log the trace is
// RtlLogStackBackTrace. One of the worst limitations of this package
// is that traces are referred using a ushort index which means we cannot
// ever store more than 65535 traces (remember we never delete traces).
//

PSTACK_TRACE_DATABASE
RtlpAcquireStackTraceDataBase(
    )
{
    PSTACK_TRACE_DATABASE DataBase;

    DataBase = RtlpStackTraceDataBase;

    //
    // Sanity checks.
    //

    if (DataBase == NULL) {
        return NULL;
    }

    if (! OKAY_TO_LOCK_DATABASE (DataBase->Lock)) {
        return NULL;
    }

    ACQUIRE_DATABASE_LOCK (DataBase->Lock);

    if (DataBase->DumpInProgress) {
        
        RELEASE_DATABASE_LOCK (DataBase->Lock);
        return NULL;
    }
    else {

        return DataBase;
    }
}


VOID
RtlpReleaseStackTraceDataBase(
    )
{
    PSTACK_TRACE_DATABASE DataBase;

    DataBase = RtlpStackTraceDataBase;
    
    //
    // Sanity checks.
    //

    if (DataBase == NULL) {
        return;
    }
    
    RELEASE_DATABASE_LOCK (DataBase->Lock);
}


NTSTATUS
RtlInitializeStackTraceDataBase(
    IN PVOID CommitBase,
    IN SIZE_T CommitSize,
    IN SIZE_T ReserveSize
    )
{
    NTSTATUS Status;
    PSTACK_TRACE_DATABASE DataBase;

    DataBase = (PSTACK_TRACE_DATABASE)CommitBase;
    
    if (CommitSize == 0) {

        //
        // Initially commit enough pages to accommodate the increased
        // number of hash chains (for improved performance we switched from ~100
        // to ~1000 in the hope that the hash chains will decrease ten-fold in 
        // length).
        //

        CommitSize = ROUND_TO_PAGES (NUMBER_OF_BUCKETS * sizeof (DataBase->Buckets[ 0 ]));
            
        Status = ZwAllocateVirtualMemory (NtCurrentProcess(),
                                          (PVOID *)&CommitBase,
                                          0,
                                          &CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE);

        if (! NT_SUCCESS(Status)) {

            KdPrint (("RTL: Unable to commit space to extend stack "
                      "trace data base - Status = %lx\n",
                      Status));
            return Status;
        }

        DataBase->PreCommitted = FALSE;
    }
    else if (CommitSize == ReserveSize) {

        RtlZeroMemory (DataBase, sizeof( *DataBase ));

        DataBase->PreCommitted = TRUE;
    }
    else {
        
        return STATUS_INVALID_PARAMETER;
    }

    DataBase->CommitBase = CommitBase;
    DataBase->NumberOfBuckets = NUMBER_OF_BUCKETS; 
    DataBase->NextFreeLowerMemory = (PCHAR)(&DataBase->Buckets[ DataBase->NumberOfBuckets ]);
    DataBase->NextFreeUpperMemory = (PCHAR)CommitBase + ReserveSize;

    if (! DataBase->PreCommitted) {

        DataBase->CurrentLowerCommitLimit = (PCHAR)CommitBase + CommitSize;
        DataBase->CurrentUpperCommitLimit = (PCHAR)CommitBase + ReserveSize;
    }
    else {
        
        RtlZeroMemory (&DataBase->Buckets[ 0 ],
                       DataBase->NumberOfBuckets * sizeof (DataBase->Buckets[ 0 ]));
    }

    DataBase->EntryIndexArray = (PRTL_STACK_TRACE_ENTRY *)DataBase->NextFreeUpperMemory;

    //
    // Initialize the database lock.
    //

    DataBase->Lock = &RtlpStackTraceDataBaseLock;

    Status = INITIALIZE_DATABASE_LOCK (DataBase->Lock);

    if (! NT_SUCCESS(Status)) {
        
        KdPrint(("RTL: Unable to initialize stack trace database lock (status %X)\n", Status));
        return Status;
    }

    RtlpStackTraceDataBase = DataBase;

    return STATUS_SUCCESS;
}


PRTL_STACK_TRACE_ENTRY
RtlpExtendStackTraceDataBase(
    IN PRTL_STACK_TRACE_ENTRY InitialValue,
    IN SIZE_T Size
    )
/*++

Routine Description:

    This routine extends the stack trace database in order to accommodate
    the new stack trace that has to be saved.

Arguments:

    InitialValue - stack trace to be saved.

    Size - size of the stack trace in bytes. Note that this is not the
        depth of the trace but rather `Depth * sizeof(PVOID)'.

Return Value:

    The address of the just saved stack trace or null in case we have hit
    the maximum size of the database or we get commit errors.

Environment:

    User mode.

    Note. In order to make all this code work in kernel mode we have to
    rewrite this function that relies on VirtualAlloc.

--*/

{
    NTSTATUS Status;
    PRTL_STACK_TRACE_ENTRY p, *pp;
    SIZE_T CommitSize;
    PSTACK_TRACE_DATABASE DataBase;

    DataBase = RtlpStackTraceDataBase;

    //
    // We will try to find space for one stack trace entry in the
    // upper part of the database.
    //

    pp = (PRTL_STACK_TRACE_ENTRY *)DataBase->NextFreeUpperMemory;

    if ((! DataBase->PreCommitted) &&
        ((PCHAR)(pp - 1) < (PCHAR)DataBase->CurrentUpperCommitLimit)) {

        //
        // No more committed space in the upper part of the database.
        // We need to extend it downwards.
        //

        DataBase->CurrentUpperCommitLimit =
            (PVOID)((PCHAR)DataBase->CurrentUpperCommitLimit - PAGE_SIZE);

        if (DataBase->CurrentUpperCommitLimit < DataBase->CurrentLowerCommitLimit) {

            //
            // No more space at all. We have got over the lower part of the db.
            // We failed therefore increase back the UpperCommitLimit pointer.
            //

            DataBase->CurrentUpperCommitLimit =
                (PVOID)((PCHAR)DataBase->CurrentUpperCommitLimit + PAGE_SIZE);

            return( NULL );
        }

        CommitSize = PAGE_SIZE;
        Status = ZwAllocateVirtualMemory(
            NtCurrentProcess(),
            (PVOID *)&DataBase->CurrentUpperCommitLimit,
            0,
            &CommitSize,
            MEM_COMMIT,
            PAGE_READWRITE
            );

        if (!NT_SUCCESS( Status )) {

            //
            // We tried to increase the upper part of the db by one page.
            // We failed therefore increase back the UpperCommitLimit pointer
            //

            DataBase->CurrentUpperCommitLimit =
                (PVOID)((PCHAR)DataBase->CurrentUpperCommitLimit + PAGE_SIZE);

            return NULL;
        }
    }

    //
    // We managed to make sure we have usable space in the upper part
    // therefore we take out one stack trace entry address.
    //

    DataBase->NextFreeUpperMemory -= sizeof( *pp );

    //
    // Now we will try to find space in the lower part of the database for
    // for the actual stack trace.
    //

    p = (PRTL_STACK_TRACE_ENTRY)DataBase->NextFreeLowerMemory;

    if ((! DataBase->PreCommitted) &&
        (((PCHAR)p + Size) > (PCHAR)DataBase->CurrentLowerCommitLimit)) {

        //
        // We need to extend the lower part.
        //

        if (DataBase->CurrentLowerCommitLimit >= DataBase->CurrentUpperCommitLimit) {

            //
            // We have hit the maximum size of the database.
            //

            DataBase->NextFreeUpperMemory += sizeof( *pp );
            return( NULL );
        }

        //
        // Extend the lower part of the database by one page.
        //

        CommitSize = Size;
        Status = ZwAllocateVirtualMemory(
            NtCurrentProcess(),
            (PVOID *)&DataBase->CurrentLowerCommitLimit,
            0,
            &CommitSize,
            MEM_COMMIT,
            PAGE_READWRITE
            );

        if (! NT_SUCCESS( Status )) {
            
            DataBase->NextFreeUpperMemory += sizeof( *pp );
            return NULL;
        }

        DataBase->CurrentLowerCommitLimit =
            (PCHAR)DataBase->CurrentLowerCommitLimit + CommitSize;
    }

    //
    // Take out the space for the stack trace.
    //

    DataBase->NextFreeLowerMemory += Size;

    //
    // Deal with a precommitted database case. If the lower and upper
    // pointers have crossed each other then rollback and return failure.
    //

    if (DataBase->PreCommitted &&
        DataBase->NextFreeLowerMemory >= DataBase->NextFreeUpperMemory) {

        DataBase->NextFreeUpperMemory += sizeof( *pp );
        DataBase->NextFreeLowerMemory -= Size;
        return( NULL );
    }

    //
    // Save the stack trace in the database
    //

    RtlMoveMemory( p, InitialValue, Size );
    p->HashChain = NULL;
    p->TraceCount = 0;
    p->Index = (USHORT)(++DataBase->NumberOfEntriesAdded);

    //
    // Save the address of the new stack trace entry in the
    // upper part of the databse.
    //

    *--pp = p;

    //
    // Return address of the saved stack trace entry.
    //

    return( p );
}


#pragma optimize("y", off) // disable FPO
USHORT
RtlLogStackBackTrace(
    VOID
    )
/*++

Routine Description:

    This routine will capture the current stacktrace (skipping the
    present function) and will save it in the global (per process)
    stack trace database. It should be noted that we do not save
    duplicate traces.

Arguments:

    None.

Return Value:

    Index of the stack trace saved. The index can be used by tools
    to access quickly the trace data. This is the reason at the end of
    the database we save downwards a list of pointers to trace entries.
    This index can be used to find this pointer in constant time.

    A zero index will be returned for error conditions (e.g. stack
    trace database not initialized).

Environment:

    User mode.

--*/

{
    return RtlpLogStackBackTraceEx (1);
}


#pragma optimize("y", off) // disable FPO
USHORT
RtlpLogStackBackTraceEx(
    ULONG FramesToSkip
    )
/*++

Routine Description:

    This routine will capture the current stacktrace (skipping the
    present function) and will save it in the global (per process)
    stack trace database. It should be noted that we do not save
    duplicate traces.

Arguments:

    FramesToSkip - no of frames that are not interesting and 
        should be skipped.

Return Value:

    Index of the stack trace saved. The index can be used by tools
    to access quickly the trace data. This is the reason at the end of
    the database we save downwards a list of pointers to trace entries.
    This index can be used to find this pointer in constant time.

    A zero index will be returned for error conditions (e.g. stack
    trace database not initialized).

Environment:

    User mode.

--*/

{
    RTL_STACK_TRACE_ENTRY Trace;
    USHORT TraceIndex;
    NTSTATUS Status;
    ULONG Hash;
    PSTACK_TRACE_DATABASE DataBase;

    //
    // Check the context in which we are running.
    //

    DataBase = RtlpStackTraceDataBase;

    if (DataBase == NULL) {
        return 0;
    }

    if (! OKAY_TO_LOCK_DATABASE (DataBase->Lock)) {
        return 0;
    }

    //
    // Capture stack trace. 
    //

    if (RtlpCaptureStackTraceForLogging (&Trace, &Hash, FramesToSkip + 1, FALSE) == FALSE) {
        return 0;
    }
    
    //
    // Add the trace if it is not already there.
    // Return trace index.
    //

    TraceIndex = RtlpLogCapturedStackTrace (&Trace, Hash);

    return TraceIndex;
}


#pragma optimize("y", off) // disable FPO
USHORT
RtlLogUmodeStackBackTrace(
    VOID
    )
/*++

Routine Description:

    This routine will capture the user mode stacktrace and will save 
    it in the global (per system) stack trace database. 
    It should be noted that we do not save duplicate traces.

Arguments:

    None.

Return Value:

    Index of the stack trace saved. The index can be used by tools
    to access quickly the trace data. This is the reason at the end of
    the database we save downwards a list of pointers to trace entries.
    This index can be used to find this pointer in constant time.

    A zero index will be returned for error conditions (e.g. stack
    trace database not initialized).

Environment:

    User mode.

--*/

{
    RTL_STACK_TRACE_ENTRY Trace;
    ULONG Hash;

    //
    // No database => nothing to do.
    //

    if (RtlpStackTraceDataBase == NULL) {
        return 0;
    }

    //
    // Capture user mode stack trace. 
    //

    if (RtlpCaptureStackTraceForLogging (&Trace, &Hash, 1, TRUE) == FALSE) {
        return 0;
    }
    
    //
    // Add the trace if it is not already there.
    // Return trace index.
    //

    return RtlpLogCapturedStackTrace (&Trace, Hash);
}


#pragma optimize("y", off) // disable FPO
LOGICAL
RtlpCaptureStackTraceForLogging (
    PRTL_STACK_TRACE_ENTRY Trace,
    PULONG Hash,
    ULONG FramesToSkip,
    LOGICAL UserModeStackFromKernelMode
    )
{
    if (UserModeStackFromKernelMode == FALSE) {
        
        //
        // Capture stack trace. The try/except was useful
        // in the old days when the function did not validate
        // the stack frame chain. We keep it just to be defensive.
        //

        try {

            Trace->Depth = RtlCaptureStackBackTrace (FramesToSkip + 1,
                                                    MAX_STACK_DEPTH,
                                                    Trace->BackTrace,
                                                    Hash);
        }
        except(EXCEPTION_EXECUTE_HANDLER) {

            Trace->Depth = 0;
        }

        if (Trace->Depth == 0) {

            return FALSE;
        }
        else {

            return TRUE;
        }
    }
    else {

        ULONG Index;

        //
        // Avoid weird situations.
        //

        if (KeAreAllApcsDisabled () == TRUE) {
            return FALSE;
        }

        //
        // Capture user mode stack trace and hash value.
        //

        Trace->Depth = (USHORT) RtlWalkFrameChain(Trace->BackTrace,
                                                  MAX_STACK_DEPTH,
                                                  1);
        if (Trace->Depth == 0) {
            
            return FALSE;
        }
        else {

            *Hash = 0;

            for (Index = 0; Index < Trace->Depth; Index += 1) {
                 *Hash += PtrToUlong (Trace->BackTrace[Index]);
            }

            return TRUE;
        }
    }
}


USHORT
RtlpLogCapturedStackTrace(
    PRTL_STACK_TRACE_ENTRY Trace,
    ULONG Hash
    )
{
    PSTACK_TRACE_DATABASE DataBase;
    PRTL_STACK_TRACE_ENTRY p, *pp;
    ULONG RequestedSize, DepthSize;
    USHORT ReturnValue;

    DataBase = RtlpStackTraceDataBase;

    //
    // Update statistics counters. Since they are used only for reference and do not
    // control decisions we increment them without protection even if this means we may
    // have numbers slightly out of sync.
    //

    DataBase->NumberOfEntriesLookedUp += 1;

    //
    // Lock the global per-process stack trace database.
    //

    if (RtlpAcquireStackTraceDataBase() == NULL) {

        //
        // Fail the log operation if we cannot acquire the lock.
        // This can happen only if there is a dump in progress or we are in
        // an invalid context (process shutdown (Umode) or DPC routine (Kmode).
        //

        return 0;
    }

    try {

        //
        // We will try to find out if the trace has been saved in the past.
        // We find the right hash chain and then traverse it.
        //

        DepthSize = Trace->Depth * sizeof (Trace->BackTrace[0]);

        pp = &DataBase->Buckets[ Hash % DataBase->NumberOfBuckets ];

        while (p = *pp) {

            if (p->Depth == Trace->Depth) {

                if (RtlCompareMemory( &p->BackTrace[ 0 ], &Trace->BackTrace[ 0 ], DepthSize) == DepthSize) {
                    
                    break;
                }
            }

            pp = &p->HashChain;
        }

        if (p == NULL) {

            //
            // If we get here we did not find a similar trace in the database. We need
            // to add it.
            //
            // We got the `*pp' value (address of last chain element) while the 
            // database lock was acquired shared so we need to take into consideration 
            // the case where another thread managed to acquire database exclusively 
            // and add a new trace at the end of the chain. Therefore if `*pp' is no longer
            // null we continue to traverse the chain until we get to the end.
            //

            p = NULL;

            if (*pp != NULL) {

                //
                // Somebody added some traces at the end of the chain while we
                // were trying to convert the lock from shared to exclusive.
                //

                while (p = *pp) {

                    if (p->Depth == Trace->Depth) {

                        if (RtlCompareMemory( &p->BackTrace[ 0 ], &Trace->BackTrace[ 0 ], DepthSize) == DepthSize) {

                            break;
                        }
                    }

                    pp = &p->HashChain;
                }
            }

            if (p == NULL) {
                
                //
                // Nobody added the trace and now `*pp' really points to the end
                // of the chain either because we traversed the rest of the chain
                // or it was at the end anyway.
                //

                RequestedSize = FIELD_OFFSET (RTL_STACK_TRACE_ENTRY, BackTrace) + DepthSize;

                p = RtlpExtendStackTraceDataBase (Trace, RequestedSize);

                if (p != NULL) {

                    //
                    // We added the trace no chain it as the last element.
                    //

                    *pp = p;
                }
            }
            else {

                //
                // Some other thread managed to add the same trace to the database
                // while we were trying to acquire the lock exclusive. `p' has the
                // address to the stack trace entry.
                //
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // We should never get here if the algorithm is correct.
        //

        p = NULL;
    }

    //
    // Release locks and return. At this stage we may return zero (failure)
    // if we did not manage to extend the database with a new trace (e.g. due to
    // out of memory conditions).
    //

    if (p != NULL) {

        p->TraceCount += 1;

        ReturnValue = p->Index;
    }
    else {
        
        ReturnValue = 0;
    }

    RtlpReleaseStackTraceDataBase();

    return ReturnValue;
}


PVOID
RtlpGetStackTraceAddress (
    USHORT Index
    )
{
    if (RtlpStackTraceDataBase == NULL) {
        return NULL;
    }

    if (! (Index > 0 && Index <= RtlpStackTraceDataBase->NumberOfEntriesAdded)) {
        return NULL;
    }

    return (PVOID)(RtlpStackTraceDataBase->EntryIndexArray[-Index]);
}


ULONG
RtlpWalkFrameChainExceptionFilter (
    ULONG ExceptionCode,
    PVOID ExceptionRecord
    )
/*++

Routine Description:

    This routine is the exception filter used by RtlWalkFrameChain function. 
    This function is platform specific (different code for x86, amd64, ia64) but
    the exception filter is common.

Arguments:

    ExceptionCode - exception code
    ExceptionRecord - structure with pointers to .exr and .cxr

Return Value:

    Always EXCEPTION_EXECUTE_HANDLER.

--*/
{

#if DBG

    //
    // We skip STATUS_IN_PAGE because this exception can be raised by MM
    // while resolving a page fault. This can happen in an obscure corner 
    // case even if RtlWalkFrameChain called MmCanThreadFault.
    //

    if (ExceptionCode != STATUS_IN_PAGE_ERROR) {
        
        DbgPrint ("Unexpected exception while walking runtime stack (exception info @ %p). \n",
                  ExceptionRecord);

        DbgBreakPoint ();
    }

#endif

    return EXCEPTION_EXECUTE_HANDLER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\time.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Time.c

Abstract:

    This module implements the absolute time conversion routines for NT.

    Absolute LARGE_INTEGER in NT is represented by a 64-bit large integer accurate
    to 100ns resolution.  The smallest time resolution used by this package
    is One millisecond.  The basis for NT time is the start of 1601 which
    was chosen because it is the start of a new quadricentury.  Some facts
    to note are:

    o At 100ns resolution 32 bits is good for about 429 seconds (or 7 minutes)

    o At 100ns resolution a large integer (i.e., 63 bits) is good for
      about 29,227 years, or around 10,675,199 days

    o At 1 second resolution 31 bits is good for about 68 years

    o At 1 second resolution 32 bits is good for about 136 years

    o 100ns Time (ignoring time less than a millisecond) can be expressed
      as two values, Days and Milliseconds.  Where Days is the number of
      whole days and Milliseconds is the number of milliseconds for the
      partial day.  Both of these values are ULONG.

    Given these facts most of the conversions are done by first splitting
    LARGE_INTEGER into Days and Milliseconds.

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA)
ULONG
ElapsedDaysToYears (
    IN ULONG ElapsedDays
    );
static
VOID
TimeToDaysAndFraction (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedDays,
    OUT PULONG Milliseconds
    );
VOID
DaysAndFractionToTime (
    IN ULONG ElapsedDays,
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Time
    );

ULONG
RtlGetTickCount (
    VOID
    );

#pragma alloc_text(PAGE, RtlCutoverTimeToSystemTime)
#pragma alloc_text(PAGE, RtlTimeToElapsedTimeFields)
#pragma alloc_text(PAGE, RtlSystemTimeToLocalTime)
#pragma alloc_text(PAGE, RtlLocalTimeToSystemTime)
#pragma alloc_text(INIT, RtlGetTickCount)

#endif


//
//  The following two tables map a day offset within a year to the month
//  containing the day.  Both tables are zero based.  For example, day
//  offset of 0 to 30 map to 0 (which is Jan).
//

CONST UCHAR LeapYearDayToMonth[366] = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // January
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        // February
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // March
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // April
     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // May
     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     // June
     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // July
     7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // August
     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // September
     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  // October
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,     // November
    11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11}; // December

CONST UCHAR NormalYearDayToMonth[365] = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // January
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,           // February
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // March
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // April
     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // May
     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     // June
     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // July
     7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // August
     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // September
     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  // October
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,     // November
    11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11}; // December

//
//  The following two tables map a month index to the number of days preceding
//  the month in the year.  Both tables are zero based.  For example, 1 (Feb)
//  has 31 days preceding it.  To help calculate the maximum number of days
//  in a month each table has 13 entries, so the number of days in a month
//  of index i is the table entry of i+1 minus the table entry of i.
//

CONST CSHORT LeapYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+29,                             // March
    31+29+31,                          // April
    31+29+31+30,                       // May
    31+29+31+30+31,                    // June
    31+29+31+30+31+30,                 // July
    31+29+31+30+31+30+31,              // August
    31+29+31+30+31+30+31+31,           // September
    31+29+31+30+31+30+31+31+30,        // October
    31+29+31+30+31+30+31+31+30+31,     // November
    31+29+31+30+31+30+31+31+30+31+30,  // December
    31+29+31+30+31+30+31+31+30+31+30+31};

CONST CSHORT NormalYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+28,                             // March
    31+28+31,                          // April
    31+28+31+30,                       // May
    31+28+31+30+31,                    // June
    31+28+31+30+31+30,                 // July
    31+28+31+30+31+30+31,              // August
    31+28+31+30+31+30+31+31,           // September
    31+28+31+30+31+30+31+31+30,        // October
    31+28+31+30+31+30+31+31+30+31,     // November
    31+28+31+30+31+30+31+31+30+31+30,  // December
    31+28+31+30+31+30+31+31+30+31+30+31};


//
//  The following definitions and declarations are some important constants
//  used in the time conversion routines
//

//
//  This is the week day that January 1st, 1601 fell on (a Monday)
//

#define WEEKDAY_OF_1601                  1

//
//  These are known constants used to convert 1970 and 1980 times to 1601
//  times.  They are the number of seconds from the 1601 base to the start
//  of 1970 and the start of 1980.  The number of seconds from 1601 to
//  1970 is 369 years worth, or (369 * 365) + 89 leap days = 134774 days, or
//  134774 * 86400 seconds, which is equal to the large integer defined
//  below.  The number of seconds from 1601 to 1980 is 379 years worth, or etc.
//

const LARGE_INTEGER SecondsToStartOf1970 = {0xb6109100, 0x00000002};

const LARGE_INTEGER SecondsToStartOf1980 = {0xc8df3700, 0x00000002};

//
//  These are the magic numbers needed to do our extended division.  The
//  only numbers we ever need to divide by are
//
//      10,000 = convert 100ns tics to millisecond tics
//
//      10,000,000 = convert 100ns tics to one second tics
//
//      86,400,000 = convert Millisecond tics to one day tics
//

const LARGE_INTEGER Magic10000    = {0xe219652c, 0xd1b71758};
#define SHIFT10000                       13

const LARGE_INTEGER Magic10000000 = {0xe57a42bd, 0xd6bf94d5};
#define SHIFT10000000                    23

const LARGE_INTEGER Magic86400000 = {0xfa67b90e, 0xc6d750eb};
#define SHIFT86400000                    26

//
//  To make the code more readable we'll also define some macros to
//  do the actual division for use
//

#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

#define ConvertMillisecondsTo100ns(MILLISECONDS) (                 \
    RtlExtendedIntegerMultiply( (MILLISECONDS), 10000 )            \
    )

#define Convert100nsToSeconds(LARGE_INTEGER) (                              \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000000, SHIFT10000000 ) \
    )

#define ConvertSecondsTo100ns(SECONDS) (                           \
    RtlExtendedIntegerMultiply( (SECONDS), 10000000 )              \
    )

#define ConvertMillisecondsToDays(LARGE_INTEGER) (                          \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic86400000, SHIFT86400000 ) \
    )

#define ConvertDaysToMilliseconds(DAYS) (                          \
    Int32x32To64( (DAYS), 86400000 )                               \
    )


//
//  Local support routine
//

ULONG
ElapsedDaysToYears (
    IN ULONG ElapsedDays
    )

/*++

Routine Description:

    This routine computes the number of total years contained in the indicated
    number of elapsed days.  The computation is to first compute the number of
    400 years and subtract that it, then do the 100 years and subtract that out,
    then do the number of 4 years and subtract that out.  Then what we have left
    is the number of days with in a normalized 4 year block.  Normalized being that
    the first three years are not leap years.

Arguments:

    ElapsedDays - Supplies the number of days to use

Return Value:

    ULONG - Returns the number of whole years contained within the input number
        of days.

--*/

{
    ULONG NumberOf400s;
    ULONG NumberOf100s;
    ULONG NumberOf4s;
    ULONG Years;

    //
    //  A 400 year time block is 365*400 + 400/4 - 400/100 + 400/400 = 146097 days
    //  long.  So we simply compute the number of whole 400 year block and the
    //  the number days contained in those whole blocks, and subtract if from the
    //  elapsed day total
    //

    NumberOf400s = ElapsedDays / 146097;
    ElapsedDays -= NumberOf400s * 146097;

    //
    //  A 100 year time block is 365*100 + 100/4 - 100/100 = 36524 days long.
    //  The computation for the number of 100 year blocks is biased by 3/4 days per
    //  100 years to account for the extra leap day thrown in on the last year
    //  of each 400 year block.
    //

    NumberOf100s = (ElapsedDays * 100 + 75) / 3652425;
    ElapsedDays -= NumberOf100s * 36524;

    //
    //  A 4 year time block is 365*4 + 4/4 = 1461 days long.
    //

    NumberOf4s = ElapsedDays / 1461;
    ElapsedDays -= NumberOf4s * 1461;

    //
    //  Now the number of whole years is the number of 400 year blocks times 400,
    //  100 year blocks time 100, 4 year blocks times 4, and the number of elapsed
    //  whole years, taking into account the 3/4 day per year needed to handle the
    //  leap year.
    //

    Years = (NumberOf400s * 400) +
            (NumberOf100s * 100) +
            (NumberOf4s * 4) +
            (ElapsedDays * 100 + 75) / 36525;

    return Years;
}


//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )

//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                                              \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )



//
//  Internal Support routine
//

static
VOID
TimeToDaysAndFraction (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedDays,
    OUT PULONG Milliseconds
    )

/*++

Routine Description:

    This routine converts an input 64-bit time value to the number
    of total elapsed days and the number of milliseconds in the
    partial day.

Arguments:

    Time - Supplies the input time to convert from

    ElapsedDays - Receives the number of elapsed days

    Milliseconds - Receives the number of milliseconds in the partial day

Return Value:

    None

--*/

{
    LARGE_INTEGER TotalMilliseconds;
    LARGE_INTEGER Temp;

    //
    //  Convert the input time to total milliseconds
    //

    TotalMilliseconds = Convert100nsToMilliseconds( *(PLARGE_INTEGER)Time );

    //
    //  Convert milliseconds to total days
    //

    Temp = ConvertMillisecondsToDays( TotalMilliseconds );

    //
    //  Set the elapsed days from temp, we've divided it enough so that
    //  the high part must be zero.
    //

    *ElapsedDays = Temp.LowPart;

    //
    //  Calculate the exact number of milliseconds in the elapsed days
    //  and subtract that from the total milliseconds to figure out
    //  the number of milliseconds left in the partial day
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( *ElapsedDays );

    Temp.QuadPart = TotalMilliseconds.QuadPart - Temp.QuadPart;

    //
    //  Set the fraction part from temp, the total number of milliseconds in
    //  a day guarantees that the high part must be zero.
    //

    *Milliseconds = Temp.LowPart;

    //
    //  And return to our caller
    //

    return;
}


//
//  Internal Support routine
//

//static
VOID
DaysAndFractionToTime (
    IN ULONG ElapsedDays,
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input elapsed day count and partial time
    in milliseconds to a 64-bit time value.

Arguments:

    ElapsedDays - Supplies the number of elapsed days

    Milliseconds - Supplies the number of milliseconds in the partial day

    Time - Receives the output time to value

Return Value:

    None

--*/

{
    LARGE_INTEGER Temp;
    LARGE_INTEGER Temp2;

    //
    //  Calculate the exact number of milliseconds in the elapsed days.
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( ElapsedDays );

    //
    //  Convert milliseconds to a large integer
    //

    Temp2.LowPart = Milliseconds;
    Temp2.HighPart = 0;

    //
    //  add milliseconds to the whole day milliseconds
    //

    Temp.QuadPart = Temp.QuadPart + Temp2.QuadPart;

    //
    //  Finally convert the milliseconds to 100ns resolution
    //

    *(PLARGE_INTEGER)Time = ConvertMillisecondsTo100ns( Temp );

    //
    //  and return to our caller
    //

    return;
}


VOID
RtlTimeToTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine converts an input 64-bit LARGE_INTEGER variable to its corresponding
    time field record.  It will tell the caller the year, month, day, hour,
    minute, second, millisecond, and weekday corresponding to the input time
    variable.

Arguments:

    Time - Supplies the time value to interpret

    TimeFields - Receives a value corresponding to Time

Return Value:

    None

--*/

{
    ULONG Years;
    ULONG Month;
    ULONG Days;

    ULONG Hours;
    ULONG Minutes;
    ULONG Seconds;
    ULONG Milliseconds;

    //
    //  First divide the input time 64 bit time variable into
    //  the number of whole days and part days (in milliseconds)
    //

    TimeToDaysAndFraction( Time, &Days, &Milliseconds );

    //
    //  Compute which weekday it is and save it away now in the output
    //  variable.  We add the weekday of the base day to bias our computation
    //  which means that if one day has elapsed then we the weekday we want
    //  is the Jan 2nd, 1601.
    //

    TimeFields->Weekday = (CSHORT)((Days + WEEKDAY_OF_1601) % 7);

    //
    //  Calculate the number of whole years contained in the elapsed days
    //  For example if Days = 500 then Years = 1
    //

    Years = ElapsedDaysToYears( Days );

    //
    //  And subtract the number of whole years from our elapsed days
    //  For example if Days = 500, Years = 1, and the new days is equal
    //  to 500 - 365 (normal year).
    //

    Days = Days - ElapsedYearsToDays( Years );

    //
    //  Now test whether the year we are working on (i.e., The year
    //  after the total number of elapsed years) is a leap year
    //  or not.
    //

    if (IsLeapYear( Years + 1 )) {

        //
        //  The current year is a leap year, so figure out what month
        //  it is, and then subtract the number of days preceding the
        //  month from the days to figure out what day of the month it is
        //

        Month = LeapYearDayToMonth[Days];
        Days = Days - LeapYearDaysPrecedingMonth[Month];

    } else {

        //
        //  The current year is a normal year, so figure out the month
        //  and days as described above for the leap year case
        //

        Month = NormalYearDayToMonth[Days];
        Days = Days - NormalYearDaysPrecedingMonth[Month];

    }

    //
    //  Now we need to compute the elapsed hour, minute, second, milliseconds
    //  from the millisecond variable.  This variable currently contains
    //  the number of milliseconds in our input time variable that did not
    //  fit into a whole day.  To compute the hour, minute, second part
    //  we will actually do the arithmetic backwards computing milliseconds
    //  seconds, minutes, and then hours.  We start by computing the
    //  number of whole seconds left in the day, and then computing
    //  the millisecond remainder.
    //

    Seconds = Milliseconds / 1000;
    Milliseconds = Milliseconds % 1000;

    //
    //  Now we compute the number of whole minutes left in the day
    //  and the number of remainder seconds
    //

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    //
    //  Now compute the number of whole hours left in the day
    //  and the number of remainder minutes
    //

    Hours = Minutes / 60;
    Minutes = Minutes % 60;

    //
    //  As our final step we put everything into the time fields
    //  output variable
    //

    TimeFields->Year         = (CSHORT)(Years + 1601);
    TimeFields->Month        = (CSHORT)(Month + 1);
    TimeFields->Day          = (CSHORT)(Days + 1);
    TimeFields->Hour         = (CSHORT)Hours;
    TimeFields->Minute       = (CSHORT)Minutes;
    TimeFields->Second       = (CSHORT)Seconds;
    TimeFields->Milliseconds = (CSHORT)Milliseconds;

    //
    //  and return to our caller
    //

    return;
}

BOOLEAN
RtlCutoverTimeToSystemTime(
    PTIME_FIELDS CutoverTime,
    PLARGE_INTEGER SystemTime,
    PLARGE_INTEGER CurrentSystemTime,
    BOOLEAN ThisYear
    )
{
    TIME_FIELDS CurrentTimeFields;

    //
    // Get the current system time
    //

    RtlTimeToTimeFields(CurrentSystemTime,&CurrentTimeFields);

    //
    // check for absolute time field. If the year is specified,
    // the the time is an absolute time
    //

    if ( CutoverTime->Year ) {

        //
        // Convert this to a time value and make sure it
        // is greater than the current system time
        //

        if ( !RtlTimeFieldsToTime(CutoverTime,SystemTime) ) {
            return FALSE;
            }

        if (SystemTime->QuadPart < CurrentSystemTime->QuadPart) {
            return FALSE;
            }
        return TRUE;
        }
    else {

        TIME_FIELDS WorkingTimeField;
        TIME_FIELDS ScratchTimeField;
        LARGE_INTEGER ScratchTime;
        CSHORT BestWeekdayDate;
        CSHORT WorkingWeekdayNumber;
        CSHORT TargetWeekdayNumber;
        CSHORT TargetYear;
        CSHORT TargetMonth;
        CSHORT TargetWeekday;     // range [0..6] == [Sunday..Saturday]
        BOOLEAN MonthMatches;
        //
        // The time is an day in the month style time
        //
        // the convention is the Day is 1-5 specifying 1st, 2nd... Last
        // day within the month. The day is WeekDay.
        //

        //
        // Compute the target month and year
        //

        TargetWeekdayNumber = CutoverTime->Day;
        if ( TargetWeekdayNumber > 5 || TargetWeekdayNumber == 0 ) {
            return FALSE;
            }
        TargetWeekday = CutoverTime->Weekday;
        TargetMonth = CutoverTime->Month;
        MonthMatches = FALSE;
        if ( !ThisYear ) {
            if ( TargetMonth < CurrentTimeFields.Month ) {
                TargetYear = CurrentTimeFields.Year + 1;
                }
            else if ( TargetMonth > CurrentTimeFields.Month ) {
                TargetYear = CurrentTimeFields.Year;
                }
            else {
                TargetYear = CurrentTimeFields.Year;
                MonthMatches = TRUE;
                }
            }
        else {
            TargetYear = CurrentTimeFields.Year;
            }
try_next_year:
        BestWeekdayDate = 0;

        WorkingTimeField.Year = TargetYear;
        WorkingTimeField.Month = TargetMonth;
        WorkingTimeField.Day = 1;
        WorkingTimeField.Hour = CutoverTime->Hour;
        WorkingTimeField.Minute = CutoverTime->Minute;
        WorkingTimeField.Second = CutoverTime->Second;
        WorkingTimeField.Milliseconds = CutoverTime->Milliseconds;
        WorkingTimeField.Weekday = 0;

        //
        // Convert to time and then back to time fields so we can determine
        // the weekday of day 1 on the month
        //

        if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
            return FALSE;
            }
        RtlTimeToTimeFields(&ScratchTime,&ScratchTimeField);

        //
        // Compute bias to target weekday
        //
        if ( ScratchTimeField.Weekday > TargetWeekday ) {
            WorkingTimeField.Day += (7-(ScratchTimeField.Weekday - TargetWeekday));
            }
        else if ( ScratchTimeField.Weekday < TargetWeekday ) {
            WorkingTimeField.Day += (TargetWeekday - ScratchTimeField.Weekday);
            }

        //
        // We are now at the first weekday that matches our target weekday
        //

        BestWeekdayDate = WorkingTimeField.Day;
        WorkingWeekdayNumber = 1;

        //
        // Keep going one week at a time until we either pass the
        // target weekday, or we match exactly
        //

        while ( WorkingWeekdayNumber < TargetWeekdayNumber ) {
            WorkingTimeField.Day += 7;
            if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
                break;
                }
            RtlTimeToTimeFields(&ScratchTime,&ScratchTimeField);
            WorkingWeekdayNumber++;
            BestWeekdayDate = ScratchTimeField.Day;
            }
        WorkingTimeField.Day = BestWeekdayDate;

        //
        // If the months match, and the date is less than the current
        // date, then be have to go to next year.
        //

        if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
            return FALSE;
            }
        if ( MonthMatches ) {
            if ( WorkingTimeField.Day < CurrentTimeFields.Day ) {
                MonthMatches = FALSE;
                TargetYear++;
                goto try_next_year;
                }
            if ( WorkingTimeField.Day == CurrentTimeFields.Day ) {

                if (ScratchTime.QuadPart < CurrentSystemTime->QuadPart) {
                    MonthMatches = FALSE;
                    TargetYear++;
                    goto try_next_year;
                    }
                }
            }
        *SystemTime = ScratchTime;

        return TRUE;
        }
}


BOOLEAN
RtlTimeFieldsToTime (
    IN PTIME_FIELDS TimeFields,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input Time Field variable to a 64-bit NT time
    value.  It ignores the WeekDay of the time field.

Arguments:

    TimeFields - Supplies the time field record to use

    Time - Receives the NT Time corresponding to TimeFields

Return Value:

    BOOLEAN - TRUE if the Time Fields is well formed and within the
        range of time expressible by LARGE_INTEGER and FALSE otherwise.

--*/

{
    ULONG Year;
    ULONG Month;
    ULONG Day;
    ULONG Hour;
    ULONG Minute;
    ULONG Second;
    ULONG Milliseconds;

    ULONG ElapsedDays;
    ULONG ElapsedMilliseconds;

    //
    //  Load the time field elements into local variables.  This should
    //  ensure that the compiler will only load the input elements
    //  once, even if there are alias problems.  It will also make
    //  everything (except the year) zero based.  We cannot zero base the
    //  year because then we can't recognize cases where we're given a year
    //  before 1601.
    //

    Year         = TimeFields->Year;
    Month        = TimeFields->Month - 1;
    Day          = TimeFields->Day - 1;
    Hour         = TimeFields->Hour;
    Minute       = TimeFields->Minute;
    Second       = TimeFields->Second;
    Milliseconds = TimeFields->Milliseconds;

    //
    //  Check that the time field input variable contains
    //  proper values.
    //

    //
    //  Year 30827 check: Time (in 100ns units) is stored in a
    //  64-bit integer, rooted at 1/1/1601.
    //
    //  2^63 / (10^7 * 86400) = 10675199 days
    //  10675199 / 146097 = 73 400-year chunks, 10118 days
    //  10118 / 1461 = 6 4-year chunks, 1352 days
    //  1352 / 365 = 3 years, some residual days
    //  1600 + 73*400 + 6*4 + 3 = 30827 is last year fully
    //  supported.
    //
    //  I'm guessing it's undesirable to support part of the
    //  year 30828.
    //

    if ((TimeFields->Month < 1)                      ||
        (TimeFields->Day < 1)                        ||
        (Year < 1601)                                ||
        (Year > 30827)                               ||
        (Month > 11)                                 ||
        ((CSHORT)Day >= MaxDaysInMonth(Year, Month)) ||
        (Hour > 23)                                  ||
        (Minute > 59)                                ||
        (Second > 59)                                ||
        (Milliseconds > 999)) {

        return FALSE;

    }

    //
    //  Compute the total number of elapsed days represented by the
    //  input time field variable
    //

    ElapsedDays = ElapsedYearsToDays( Year - 1601 );

    if (IsLeapYear( Year - 1600 )) {

        ElapsedDays += LeapYearDaysPrecedingMonth[ Month ];

    } else {

        ElapsedDays += NormalYearDaysPrecedingMonth[ Month ];

    }

    ElapsedDays += Day;

    //
    //  Now compute the total number of milliseconds in the fractional
    //  part of the day
    //

    ElapsedMilliseconds = (((Hour*60) + Minute)*60 + Second)*1000 + Milliseconds;

    //
    //  Given the elapsed days and milliseconds we can now build
    //  the output time variable
    //

    DaysAndFractionToTime( ElapsedDays, ElapsedMilliseconds, Time );

    //
    //  And return to our caller
    //

    return TRUE;
}


VOID
RtlTimeToElapsedTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine converts an input 64-bit LARGE_INTEGER variable to its corresponding
    time field record.  The input time is the elapsed time (difference
    between to times).  It will tell the caller the number of days, hour,
    minute, second, and milliseconds that the elapsed time represents.

Arguments:

    Time - Supplies the time value to interpret

    TimeFields - Receives a value corresponding to Time

Return Value:

    None

--*/

{
    ULONG Days;
    ULONG Hours;
    ULONG Minutes;
    ULONG Seconds;
    ULONG Milliseconds;

    //
    //  First divide the input time 64 bit time variable into
    //  the number of whole days and part days (in milliseconds)
    //

    TimeToDaysAndFraction( Time, &Days, &Milliseconds );

    //
    //  Now we need to compute the elapsed hour, minute, second, milliseconds
    //  from the millisecond variable.  This variable currently contains
    //  the number of milliseconds in our input time variable that did not
    //  fit into a whole day.  To compute the hour, minute, second part
    //  we will actually do the arithmetic backwards computing milliseconds
    //  seconds, minutes, and then hours.  We start by computing the
    //  number of whole seconds left in the day, and then computing
    //  the millisecond remainder.
    //

    Seconds = Milliseconds / 1000;
    Milliseconds = Milliseconds % 1000;

    //
    //  Now we compute the number of whole minutes left in the day
    //  and the number of remainder seconds
    //

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    //
    //  Now compute the number of whole hours left in the day
    //  and the number of remainder minutes
    //

    Hours = Minutes / 60;
    Minutes = Minutes % 60;

    //
    //  As our final step we put everything into the time fields
    //  output variable
    //

    TimeFields->Year         = 0;
    TimeFields->Month        = 0;
    TimeFields->Day          = (CSHORT)Days;
    TimeFields->Hour         = (CSHORT)Hours;
    TimeFields->Minute       = (CSHORT)Minutes;
    TimeFields->Second       = (CSHORT)Seconds;
    TimeFields->Milliseconds = (CSHORT)Milliseconds;

    //
    //  and return to our caller
    //

    return;
}


BOOLEAN
RtlTimeToSecondsSince1980 (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedSeconds
    )

/*++

Routine Description:

    This routine converts an input 64-bit NT Time variable to the
    number of seconds since the start of 1980.  The NT time must be
    within the range 1980 to around 2115.

Arguments:

    Time - Supplies the Time to convert from

    ElapsedSeconds - Receives the number of seconds since the start of 1980
        denoted by Time

Return Value:

    BOOLEAN - TRUE if the input Time is within a range expressible by
        ElapsedSeconds and FALSE otherwise

--*/

{
    LARGE_INTEGER Seconds;

    //
    //  First convert time to seconds since 1601
    //

    Seconds = Convert100nsToSeconds( *(PLARGE_INTEGER)Time );

    //
    //  Then subtract the number of seconds from 1601 to 1980.
    //

    Seconds.QuadPart = Seconds.QuadPart - SecondsToStartOf1980.QuadPart;

    //
    //  If the results is negative then the date was before 1980 or if
    //  the results is greater than a ulong then its too far in the
    //  future so we return FALSE
    //

    if (Seconds.HighPart != 0) {

        return FALSE;

    }

    //
    //  Otherwise we have the answer
    //

    *ElapsedSeconds = Seconds.LowPart;

    //
    //  And return to our caller
    //

    return TRUE;
}


VOID
RtlSecondsSince1980ToTime (
    IN ULONG ElapsedSeconds,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts the seconds since the start of 1980 to an
    NT Time value.

Arguments:

    ElapsedSeconds - Supplies the number of seconds from the start of 1980
        to convert from

    Time - Receives the converted Time value

Return Value:

    None

--*/

{
    LARGE_INTEGER Seconds;

    //
    //  Move elapsed seconds to a large integer
    //

    Seconds.LowPart = ElapsedSeconds;
    Seconds.HighPart = 0;

    //
    //  convert number of seconds from 1980 to number of seconds from 1601
    //

    Seconds.QuadPart = Seconds.QuadPart + SecondsToStartOf1980.QuadPart;

    //
    //  Convert seconds to 100ns resolution
    //

    *(PLARGE_INTEGER)Time = ConvertSecondsTo100ns( Seconds );

    //
    //  and return to our caller
    //

    return;
}


BOOLEAN
RtlTimeToSecondsSince1970 (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedSeconds
    )

/*++

Routine Description:

    This routine converts an input 64-bit NT Time variable to the
    number of seconds since the start of 1970.  The NT time must be
    within the range 1970 to around 2105.

Arguments:

    Time - Supplies the Time to convert from

    ElapsedSeconds - Receives the number of seconds since the start of 1970
        denoted by Time

Return Value:

    BOOLEAN - TRUE if the input time is within the range expressible by
        ElapsedSeconds and FALSE otherwise

--*/

{
    LARGE_INTEGER Seconds;

    //
    //  First convert time to seconds since 1601
    //

    Seconds = Convert100nsToSeconds( *(PLARGE_INTEGER)Time );

    //
    //  Then subtract the number of seconds from 1601 to 1970.
    //

    Seconds.QuadPart = Seconds.QuadPart - SecondsToStartOf1970.QuadPart;

    //
    //  If the results is negative then the date was before 1970 or if
    //  the results is greater than a ulong then its too far in the
    //  future so we return FALSE
    //

    if (Seconds.HighPart != 0) {

        return FALSE;

    }

    //
    //  Otherwise we have the answer
    //

    *ElapsedSeconds = Seconds.LowPart;

    //
    //  And return to our caller
    //

    return TRUE;
}


VOID
RtlSecondsSince1970ToTime (
    IN ULONG ElapsedSeconds,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts the seconds since the start of 1970 to an
    NT Time value

Arguments:

    ElapsedSeconds - Supplies the number of seconds from the start of 1970
        to convert from

    Time - Receives the converted Time value

Return Value:

    None

--*/

{
    LARGE_INTEGER Seconds;

    //
    //  Move elapsed seconds to a large integer
    //

    Seconds.LowPart = ElapsedSeconds;
    Seconds.HighPart = 0;

    //
    //  Convert number of seconds from 1970 to number of seconds from 1601
    //

    Seconds.QuadPart = Seconds.QuadPart + SecondsToStartOf1970.QuadPart;

    //
    //  Convert seconds to 100ns resolution
    //

    *(PLARGE_INTEGER)Time = ConvertSecondsTo100ns( Seconds );

    //
    //  return to our caller
    //

    return;
}

NTSTATUS
RtlSystemTimeToLocalTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER LocalTime
    )
{
    NTSTATUS Status;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    Status = ZwQuerySystemInformation(
                SystemTimeOfDayInformation,
                &TimeOfDay,
                sizeof(TimeOfDay),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return Status;
        }

    //
    // LocalTime = SystemTime - TimeZoneBias
    //

    LocalTime->QuadPart = SystemTime->QuadPart - TimeOfDay.TimeZoneBias.QuadPart;

    return STATUS_SUCCESS;
}

NTSTATUS
RtlLocalTimeToSystemTime (
    IN PLARGE_INTEGER LocalTime,
    OUT PLARGE_INTEGER SystemTime
    )
{

    NTSTATUS Status;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    Status = ZwQuerySystemInformation(
                SystemTimeOfDayInformation,
                &TimeOfDay,
                sizeof(TimeOfDay),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return Status;
        }

    //
    // SystemTime = LocalTime + TimeZoneBias
    //

    SystemTime->QuadPart = LocalTime->QuadPart + TimeOfDay.TimeZoneBias.QuadPart;

    return STATUS_SUCCESS;
}


ULONG
RtlGetTickCount (
    VOID
    )
/*++

Routine Description:

    This routine returns the current tick count for the system.
    This routine is provided for compatibility only

Arguments:

    None.

Return Value:

    System tick count.

--*/

{
    return NtGetTickCount ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\sysvol.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    SysVol.c

Abstract:

    Creation and Maintenance of the NTFS "System Volume Information"
    directory.

--*/

#include "ntrtlp.h"

PVOID
RtlpSysVolAllocate(
    IN  ULONG   Size
    );

VOID
RtlpSysVolFree(
    IN  PVOID   Buffer
    );

NTSTATUS
RtlpSysVolCreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR*   SecurityDescriptor,
    OUT PACL*                   Acl
    );

NTSTATUS
RtlpSysVolCheckOwnerAndSecurity(
    IN  HANDLE  Handle,
    IN  PACL    StandardAcl
    );

VOID
RtlpSysVolAdminSid(
    IN OUT  SID*    Sid
    );

static const SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,RtlCreateSystemVolumeInformationFolder)
#pragma alloc_text(PAGE,RtlpSysVolAllocate)
#pragma alloc_text(PAGE,RtlpSysVolFree)
#pragma alloc_text(PAGE,RtlpSysVolCreateSecurityDescriptor)
#pragma alloc_text(PAGE,RtlpSysVolCheckOwnerAndSecurity)
#pragma alloc_text(PAGE,RtlpSysVolAdminSid)
#endif

PVOID
RtlpSysVolAllocate(
    IN  ULONG   Size
    )

{
    PVOID   p;

    p = ExAllocatePoolWithTag(PagedPool, Size, 'SloV');

    return p;
}

VOID
RtlpSysVolFree(
    IN  PVOID   Buffer
    )

{
    ExFreePool(Buffer);
}

VOID
RtlpSysVolAdminSid(
    IN OUT  SID*    Sid
    )

{
    Sid->Revision = SID_REVISION;
    Sid->SubAuthorityCount = 2;
    Sid->IdentifierAuthority = ntAuthority;
    Sid->SubAuthority[0] = SECURITY_BUILTIN_DOMAIN_RID;
    Sid->SubAuthority[1] = DOMAIN_ALIAS_RID_ADMINS;
}

VOID
RtlpSysVolSystemSid(
    IN OUT  SID*    Sid
    )

{
    Sid->Revision = SID_REVISION;
    Sid->SubAuthorityCount = 1;
    Sid->IdentifierAuthority = ntAuthority;
    Sid->SubAuthority[0] = SECURITY_LOCAL_SYSTEM_RID;
}

NTSTATUS
RtlpSysVolCreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR*   SecurityDescriptor,
    OUT PACL*                   Acl
    )

{
    PSECURITY_DESCRIPTOR    sd;
    NTSTATUS                status;
    PSID                    systemSid;
    UCHAR                   sidBuffer[2*sizeof(SID)];
    ULONG                   aclLength;
    PACL                    acl;

    sd = RtlpSysVolAllocate(sizeof(SECURITY_DESCRIPTOR));
    if (!sd) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateSecurityDescriptor(sd, SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd);
        return status;
    }

    systemSid = (PSID) sidBuffer;
    RtlpSysVolSystemSid(systemSid);

    aclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
                RtlLengthSid(systemSid) - sizeof(ULONG);

    acl = RtlpSysVolAllocate(aclLength);
    if (!acl) {
        RtlpSysVolFree(sd);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateAcl(acl, aclLength, ACL_REVISION);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(acl);
        RtlpSysVolFree(sd);
        return status;
    }

    status = RtlAddAccessAllowedAceEx(acl, ACL_REVISION, OBJECT_INHERIT_ACE |
                                      CONTAINER_INHERIT_ACE,
                                      STANDARD_RIGHTS_ALL |
                                      SPECIFIC_RIGHTS_ALL, systemSid);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(acl);
        RtlpSysVolFree(sd);
        return status;
    }

    status = RtlSetDaclSecurityDescriptor(sd, TRUE, acl, FALSE);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(acl);
        RtlpSysVolFree(sd);
        return status;
    }

    *SecurityDescriptor = sd;
    *Acl = acl;

    return STATUS_SUCCESS;
}

NTSTATUS
RtlpSysVolCheckOwnerAndSecurity(
    IN  HANDLE  Handle,
    IN  PACL    StandardAcl
    )

{
    NTSTATUS                status;
    ULONG                   sdLength, sdLength2;
    PSECURITY_DESCRIPTOR    sd, sd2;
    PSID                    sid;
    BOOLEAN                 ownerDefaulted, daclPresent, daclDefaulted;
    PACL                    acl;
    ULONG                   i;
    PACCESS_ALLOWED_ACE     ace;
    PSID                    systemSid;
    UCHAR                   sidBuffer[2*sizeof(SID)];
    PSID                    adminSid;
    UCHAR                   sidBuffer2[2*sizeof(SID)];

    status = NtQuerySecurityObject(Handle, OWNER_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION, NULL, 0,
                                   &sdLength);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        // The file system does not support security.
        return STATUS_SUCCESS;
    }

    sd = RtlpSysVolAllocate(sdLength);
    if (!sd) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = NtQuerySecurityObject(Handle, OWNER_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION, sd, sdLength,
                                   &sdLength);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd);
        return status;
    }

    status = RtlGetDaclSecurityDescriptor(sd, &daclPresent, &acl,
                                          &daclDefaulted);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd);
        return status;
    }

    status = RtlGetOwnerSecurityDescriptor(sd, &sid, &ownerDefaulted);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd);
        return status;
    }

    //
    //  Setup well know SIDs
    //  

    systemSid = (PSID) sidBuffer;
    adminSid = (PSID) sidBuffer2;

    RtlpSysVolSystemSid(systemSid);
    RtlpSysVolAdminSid(adminSid);


    if (!sid) {
        goto ResetSecurity;
    }

    if (!RtlEqualSid(sid, adminSid)) {
        goto ResetSecurity;
    }

    if (!daclPresent || (daclPresent && !acl)) {
        goto ResetSecurity;
    }

    for (i = 0; ; i++) {
        status = RtlGetAce(acl, i, &ace);
        if (!NT_SUCCESS(status)) {
            ace = NULL;
        }
        if (!ace) {
            break;
        }

        if (ace->Header.AceType != ACCESS_ALLOWED_ACE_TYPE) {
            continue;
        }

        sid = (PSID) &ace->SidStart;
        if (!RtlEqualSid(sid, systemSid)) {
            continue;
        }

        break;
    }

    if (!ace) {
        goto ResetSecurity;
    }

    if (!(ace->Header.AceFlags&OBJECT_INHERIT_ACE) ||
        !(ace->Header.AceFlags&CONTAINER_INHERIT_ACE)) {

        ace->Header.AceFlags |= OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;

        status = NtSetSecurityObject(Handle, DACL_SECURITY_INFORMATION, sd);

    } else {
        status = STATUS_SUCCESS;
    }

    RtlpSysVolFree(sd);

    return status;

ResetSecurity:

    sdLength2 = sdLength;
    status = RtlSelfRelativeToAbsoluteSD2(sd, &sdLength2);
    if (status == STATUS_BUFFER_TOO_SMALL) {
        sd2 = RtlpSysVolAllocate(sdLength2);
        if (!sd2) {
            RtlpSysVolFree(sd);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(sd2, sd, sdLength);
        RtlpSysVolFree(sd);
        sd = sd2;
        sdLength = sdLength2;

        status = RtlSelfRelativeToAbsoluteSD2(sd, &sdLength);
        if (!NT_SUCCESS(status)) {
            RtlpSysVolFree(sd);
            return status;
        }
    }

    status = RtlSetOwnerSecurityDescriptor(sd, adminSid, FALSE);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd);
        return status;
    }

    status = RtlSetDaclSecurityDescriptor(sd, TRUE, StandardAcl, FALSE);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd);
        return status;
    }

    sdLength2 = 0;
    status = RtlMakeSelfRelativeSD(sd, NULL, &sdLength2);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        RtlpSysVolFree(sd);
        return status;
    }

    sd2 = RtlpSysVolAllocate(sdLength2);
    if (!sd2) {
        RtlpSysVolFree(sd);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlMakeSelfRelativeSD(sd, sd2, &sdLength2);
    RtlpSysVolFree(sd);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(sd2);
        return status;
    }

    sd = sd2;
    sdLength = sdLength2;

    status = NtSetSecurityObject(Handle, OWNER_SECURITY_INFORMATION |
                                 DACL_SECURITY_INFORMATION, sd);

    RtlpSysVolFree(sd);

    return status;
}

VOID
RtlpSysVolTakeOwnership(
    IN  PUNICODE_STRING         DirectoryName
    )

/*++

Routine Description:

    This routine is called when the open for the directory failed.  This
    routine will attempt to set the owner of the file to the caller's
    ownership so that another attempt to open the file can be attempted.

Arguments:

    DirectoryName       - Supplies the directory name.

Return Value:

    None.

--*/

{
    NTSTATUS            status;
    HANDLE              tokenHandle, fileHandle;
    TOKEN_PRIVILEGES    tokenPrivileges;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     ioStatus;
    SECURITY_DESCRIPTOR sd;
    PSID                adminSid;
    UCHAR               sidBuffer[2*sizeof(SID)];

    status = NtOpenProcessToken(NtCurrentProcess(), TOKEN_ADJUST_PRIVILEGES |
                                TOKEN_QUERY, &tokenHandle);
    if (!NT_SUCCESS(status)) {
        return;
    }

    tokenPrivileges.PrivilegeCount = 1;
    tokenPrivileges.Privileges[0].Luid =
            RtlConvertLongToLuid(SE_TAKE_OWNERSHIP_PRIVILEGE);
    tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    status = NtAdjustPrivilegesToken(tokenHandle, FALSE, &tokenPrivileges,
                                     sizeof(tokenPrivileges), NULL, NULL);
    if (!NT_SUCCESS(status)) {
        NtClose(tokenHandle);
        return;
    }

    InitializeObjectAttributes(&oa, DirectoryName, OBJ_CASE_INSENSITIVE, NULL,
                               NULL);
    status = NtOpenFile(&fileHandle, WRITE_OWNER | SYNCHRONIZE, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE);
    if (!NT_SUCCESS(status)) {
        NtClose(tokenHandle);
        return;
    }

    RtlCreateSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    adminSid = (PSID) sidBuffer;
    RtlpSysVolAdminSid(adminSid);

    status = RtlSetOwnerSecurityDescriptor(&sd, adminSid, FALSE);
    if (!NT_SUCCESS(status)) {
        NtClose(fileHandle);
        NtClose(tokenHandle);
        return;
    }

    status = NtSetSecurityObject(fileHandle, OWNER_SECURITY_INFORMATION, &sd);
    if (!NT_SUCCESS(status)) {
        NtClose(fileHandle);
        NtClose(tokenHandle);
        return;
    }

    NtClose(fileHandle);
    NtClose(tokenHandle);
}

NTSTATUS
RtlCreateSystemVolumeInformationFolder(
    IN  PUNICODE_STRING VolumeRootPath
    )

/*++

Routine Description:

    This routine verifies the existence of the "System Volume Information"
    folder on the given volume.  If the folder is not present, then the
    folder is created with one ACE indicating full access for SYSTEM.  The ACE
    will have the inheritance bits set.  The folder will be created with
    the HIDDEN and SYSTEM attributes set.

    If the folder is already present, the ACE that indicates full control
    for SYSTEM will be checked and if necessary modified to have the
    inheritance bits set.

Arguments:

    VolumeRootPath  - Supplies a path to the root of an NTFS volume.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING          sysVolName;
    UNICODE_STRING          dirName;
    BOOLEAN                 needBackslash;
    NTSTATUS                status;
    PSECURITY_DESCRIPTOR    securityDescriptor;
    PACL                    acl;
    OBJECT_ATTRIBUTES       oa;
    HANDLE                  h;
    IO_STATUS_BLOCK         ioStatus;

    RtlInitUnicodeString(&sysVolName, RTL_SYSTEM_VOLUME_INFORMATION_FOLDER);

    dirName.Length = VolumeRootPath->Length + sysVolName.Length;

    //
    // Check for wrapping.
    //
    
    if ( dirName.Length < VolumeRootPath->Length
        || dirName.Length < sysVolName.Length ) {
        return STATUS_INVALID_PARAMETER;
    }

    if (VolumeRootPath->Buffer[VolumeRootPath->Length/sizeof(WCHAR) - 1] !=
        '\\') {

        dirName.Length += sizeof(WCHAR);
        needBackslash = TRUE;
    } else {
        needBackslash = FALSE;
    }
    dirName.MaximumLength = dirName.Length + sizeof(WCHAR);
    dirName.Buffer = RtlpSysVolAllocate(dirName.MaximumLength);
    if (!dirName.Buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(dirName.Buffer, VolumeRootPath->Buffer,
                  VolumeRootPath->Length);
    dirName.Length = VolumeRootPath->Length;
    if (needBackslash) {
        dirName.Buffer[VolumeRootPath->Length/sizeof(WCHAR)] = '\\';
        dirName.Length += sizeof(WCHAR);
    }
    RtlCopyMemory((PCHAR) dirName.Buffer + dirName.Length,
                  sysVolName.Buffer, sysVolName.Length);
    dirName.Length += sysVolName.Length;
    dirName.Buffer[dirName.Length/sizeof(WCHAR)] = 0;

    status = RtlpSysVolCreateSecurityDescriptor(&securityDescriptor, &acl);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(dirName.Buffer);
        return status;
    }

    InitializeObjectAttributes(&oa, &dirName, OBJ_CASE_INSENSITIVE, NULL,
                               securityDescriptor);

    status = NtCreateFile(&h, READ_CONTROL | WRITE_DAC | WRITE_OWNER |
                          SYNCHRONIZE, &oa, &ioStatus, NULL,
                          FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                          FILE_SHARE_READ | FILE_SHARE_WRITE |
                          FILE_SHARE_DELETE, FILE_OPEN_IF,
                          FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE,
                          NULL, 0);
    if (!NT_SUCCESS(status)) {
        RtlpSysVolTakeOwnership(&dirName);
        status = NtCreateFile(&h, READ_CONTROL | WRITE_DAC | WRITE_OWNER |
                              SYNCHRONIZE, &oa, &ioStatus, NULL,
                              FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                              FILE_SHARE_READ | FILE_SHARE_WRITE |
                              FILE_SHARE_DELETE, FILE_OPEN_IF,
                              FILE_SYNCHRONOUS_IO_NONALERT |
                              FILE_DIRECTORY_FILE, NULL, 0);
    }

    RtlpSysVolFree(dirName.Buffer);

    if (!NT_SUCCESS(status)) {
        RtlpSysVolFree(acl);
        RtlpSysVolFree(securityDescriptor);
        return status;
    }

    RtlpSysVolFree(securityDescriptor);

    status = RtlpSysVolCheckOwnerAndSecurity(h, acl);

    NtClose(h);
    RtlpSysVolFree(acl);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\string.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    strings.c

Abstract:

    This module defines functions for manipulating counted strings (STRING).
    A counted string is a data structure containing three fields.  The Buffer
    field is a pointer to the string itself.  The MaximumLength field contains
    the maximum number of bytes that can be stored in the memory pointed to
    by the Buffer field.  The Length field contains the current length, in
    bytes, of the string pointed to by the Buffer field.  Users of counted
    strings should not make any assumptions about the existence of a null
    byte at the end of the string, unless the null byte is explicitly
    included in the Length of the string.

--*/

#include "string.h"
#include "nt.h"
#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,RtlUpperChar)
#pragma alloc_text(PAGE,RtlCompareString)
#pragma alloc_text(PAGE,RtlPrefixString)
#pragma alloc_text(PAGE,RtlCreateUnicodeStringFromAsciiz)
#pragma alloc_text(PAGE,RtlUpperString)
#pragma alloc_text(PAGE,RtlAppendAsciizToString)
#pragma alloc_text(PAGE,RtlAppendStringToString)
#endif

//
// Global data used for translations.
//
extern PUSHORT  NlsAnsiToUnicodeData;    // Ansi CP to Unicode translation table
extern PCH      NlsUnicodeToAnsiData;    // Unicode to Ansi CP translation table
extern const PUSHORT  NlsLeadByteInfo;         // Lead byte info for ACP
extern PUSHORT  NlsUnicodeToMbAnsiData;  // Unicode to Multibyte Ansi CP translation table
extern BOOLEAN  NlsMbCodePageTag;        // TRUE -> Multibyte ACP, FALSE -> Singlebyte ACP

#if !defined(_M_IX86)

VOID
RtlInitString (
    OUT PSTRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{

    SIZE_T Length;

    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;
    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT(SourceString)) {
        Length = strlen(SourceString);

        ASSERT(Length < MAXUSHORT);

        if(Length >= MAXUSHORT) {
            Length = MAXUSHORT - 1;
        }

        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + 1);
    }

    return;
}

VOID
RtlInitAnsiString (
    OUT PANSI_STRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitAnsiString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{

    SIZE_T Length;

    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;
    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT(SourceString)) {
        Length = strlen(SourceString);

        ASSERT(Length < MAXUSHORT);

        if(Length >= MAXUSHORT) {
            Length = MAXUSHORT - 1;
        }

        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + 1);
    }

    return;
}

VOID
RtlInitUnicodeString (
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{

    SIZE_T Length;

    DestinationString->MaximumLength = 0;
    DestinationString->Length = 0;
    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT(SourceString)) {
        Length = wcslen(SourceString) * sizeof(WCHAR);

        ASSERT(Length < MAX_USTRING);

        if(Length >= MAX_USTRING) {
            Length = MAX_USTRING - sizeof(UNICODE_NULL);
        }

        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
    }

    return;
}

#endif // !defined(_M_IX86)

NTSTATUS
RtlInitUnicodeStringEx (
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

{

    SIZE_T Length;

    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;
    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT(SourceString)) {
        Length = wcslen(SourceString);

        // We are actually limited to 32765 characters since we want to store a meaningful
        // MaximumLength also.

        if (Length > (UNICODE_STRING_MAX_CHARS - 1)) {
            return STATUS_NAME_TOO_LONG;
        }

        Length *= sizeof(WCHAR);

        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(WCHAR));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RtlInitAnsiStringEx (
    OUT PANSI_STRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

{

    SIZE_T Length;

    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;
    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT(SourceString)) {
        Length = strlen(SourceString);

        // We are actually limited to 64K - 1 characters since we want to store a meaningful
        // MaximumLength also.

        if (Length > (MAXUSHORT - 1)) {
            return STATUS_NAME_TOO_LONG;
        }

        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + 1);
    }

    return STATUS_SUCCESS;
}

VOID
RtlCopyString(
    OUT PSTRING DestinationString,
    IN const STRING *SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlCopyString function copies the SourceString to the
    DestinationString.  If SourceString is not specified, then
    the Length field of DestinationString is set to zero.  The
    MaximumLength and Buffer fields of DestinationString are not
    modified by this function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Optional pointer to the source string.

Return Value:

    None.

--*/

{
    SIZE_T n;

    DestinationString->Length = 0;
    if (ARGUMENT_PRESENT(SourceString)) {
        n = SourceString->Length;
        if (n > DestinationString->MaximumLength) {
            n = DestinationString->MaximumLength;
        }

        DestinationString->Length = (USHORT)n;
        memcpy(DestinationString->Buffer, SourceString->Buffer, n);
    }

    return;
}

CHAR
RtlUpperChar (
    register IN CHAR Character
    )

/*++

Routine Description:

    This routine returns a character uppercased
.
Arguments:

    IN CHAR Character - Supplies the character to upper case

Return Value:

    CHAR - Uppercased version of the character
ter
--*/

{

    RTL_PAGED_CODE();

    //
    // NOTE:  This assumes an ANSI string and it does NOT upper case
    //        DOUBLE BYTE characters properly.
    //

    //
    //  Handle a - z separately.
    //
    if (Character <= 'z') {
        if (Character >= 'a') {
            return Character ^ 0x20;
            }
        else {
            return Character;
            }
        }
    else {
        WCHAR wCh;

        /*
         *  Handle extended characters.
         */
        if (!NlsMbCodePageTag) {
            //
            //  Single byte code page.
            //
            wCh = NlsAnsiToUnicodeData[(UCHAR)Character];
            wCh = NLS_UPCASE(wCh);
            return NlsUnicodeToAnsiData[(USHORT)wCh];
            }
        else {
            //
            //  Multi byte code page.  Do nothing to the character
            //  if it's a lead byte or if the translation of the
            //  upper case Unicode character is a DBCS character.
            //
            if (!NlsLeadByteInfo[Character]) {
                wCh = NlsAnsiToUnicodeData[(UCHAR)Character];
                wCh = NLS_UPCASE(wCh);
                wCh = NlsUnicodeToMbAnsiData[(USHORT)wCh];
                if (!HIBYTE(wCh)) {
                    return LOBYTE(wCh);
                    }
                }
            }
        }

    return Character;
}

LONG
RtlCompareString(
    IN const STRING *String1,
    IN const STRING *String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareString function compares two counted strings.  The return
    value indicates if the strings are equal or String1 is less than String2
    or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    PUCHAR s1, s2, Limit;
    LONG n1, n2;
    UCHAR c1, c2;

    RTL_PAGED_CODE();

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = String1->Length;
    n2 = String2->Length;
    Limit = s1 + (n1 <= n2 ? n1 : n2);
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1;
            c2 = *s2;
            if (c1 !=c2) {
                c1 = RtlUpperChar(c1);
                c2 = RtlUpperChar(c2);
                if (c1 != c2) {
                    return (LONG)c1 - (LONG)c2;
                }
            }

            s1 += 1;
            s2 += 1;
        }

    } else {
        while (s1 < Limit) {
            c1 = *s1;
            c2 = *s2;
            if (c1 != c2) {
                return (LONG)c1 - (LONG)c2;
            }

            s1 += 1;
            s2 += 1;
        }
    }

    return n1 - n2;
}

BOOLEAN
RtlEqualString(
    IN const STRING *String1,
    IN const STRING *String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualString function compares two counted strings for equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PUCHAR s1, s2, Limit;
    LONG n1, n2;
    UCHAR c1, c2;

    n1 = String1->Length;
    n2 = String2->Length;
    if (n1 == n2) {
        s1 = String1->Buffer;
        s2 = String2->Buffer;
        Limit = s1 + n1;
        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = *s1;
                c2 = *s2;
                if (c1 != c2) {
                    c1 = RtlUpperChar(c1);
                    c2 = RtlUpperChar(c2);
                    if (c1 != c2) {
                        return FALSE;
                    }
                }

                s1 += 1;
                s2 += 1;
            }

            return TRUE;

        } else {
            while (s1 < Limit) {
                c1 = *s1;
                c2 = *s2;
                if (c1 != c2) {
                    return FALSE;
                }

                s1 += 1;
                s2 += 1;
            }

            return TRUE;
        }

    } else {
        return FALSE;
    }
}

BOOLEAN
RtlPrefixString(
    const STRING * String1,
    const STRING * String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlPrefixString function determines if the String1 counted string
    parameter is a prefix of the String2 counted string parameter.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals a prefix of String2 and
    FALSE otherwise.

--*/

{
    PCSZ s1, s2, Limit;
    ULONG n;
    UCHAR c1, c2;

    RTL_PAGED_CODE();

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n = String1->Length;
    if (String2->Length < n) {
        return FALSE;
    }

    Limit = s1 + n;
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1;
            c2 = *s2;

            if (c1 != c2 && RtlUpperChar(c1) != RtlUpperChar(c2)) {
                return FALSE;
            }

            s1 += 1;
            s2 += 1;
        }

    } else {
        while (s1 < Limit) {
            if (*s1 != *s2) {
                return FALSE;
            }

            s1 += 1;
            s2 += 1;
        }
    }

    return TRUE;
}

BOOLEAN
RtlCreateUnicodeStringFromAsciiz(
    OUT PUNICODE_STRING DestinationString,
    IN PCSZ SourceString
    )
{
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    RTL_PAGED_CODE();

    Status = RtlInitAnsiStringEx( &AnsiString, SourceString );
    if(!NT_SUCCESS( Status )) {
        return FALSE;
    }

    Status = RtlAnsiStringToUnicodeString( DestinationString, &AnsiString, TRUE );
    if (NT_SUCCESS( Status )) {
        ASSERT_WELL_FORMED_UNICODE_STRING_OUT(DestinationString);
        return( TRUE );
    }
    else {
        return( FALSE );
    }
}


VOID
RtlUpperString(
    IN PSTRING DestinationString,
    IN const STRING *SourceString
    )

/*++

Routine Description:

    The RtlUpperString function copies the SourceString to the
    DestinationString, converting it to upper case.  The MaximumLength
    and Buffer fields of DestinationString are not modified by this
    function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Pointer to the source string.

Return Value:

    None.

--*/

{
    PSZ src, dst;
    ULONG n;

    RTL_PAGED_CODE();

    dst = DestinationString->Buffer;
    src = SourceString->Buffer;
    n = SourceString->Length;
    if ((USHORT)n > DestinationString->MaximumLength) {
        n = DestinationString->MaximumLength;
        }
    DestinationString->Length = (USHORT)n;
    while (n) {
        *dst++ = RtlUpperChar(*src++);
        n--;
        }
}


NTSTATUS
RtlAppendAsciizToString (
    IN PSTRING Destination,
    IN PCSZ Source OPTIONAL
    )

/*++

Routine Description:

    This routine appends the supplied ASCIIZ string to an existing PSTRING.

    It will copy bytes from the Source PSZ to the destination PSTRING up to
    the destinations PSTRING->MaximumLength field.

Arguments:

    IN PSTRING Destination, - Supplies a pointer to the destination string
    IN PSZ Source - Supplies the string to append to the destination

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    SIZE_T   n;

    RTL_PAGED_CODE();

    if (ARGUMENT_PRESENT( Source )) {
        n = strlen( Source );

        if( (n > MAXUSHORT ) ||
            ((n + Destination->Length) > Destination->MaximumLength) ) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        RtlMoveMemory( &Destination->Buffer[ Destination->Length ], Source, n );
        Destination->Length += (USHORT)n;
        }

    return( STATUS_SUCCESS );
}



NTSTATUS
RtlAppendStringToString (
    IN PSTRING Destination,
    IN const STRING *Source
    )

/*++

Routine Description:

    This routine will concatenate two PSTRINGs together.  It will copy
    bytes from the source up to the MaximumLength of the destination.

Arguments:

    IN PSTRING Destination, - Supplies the destination string
    IN PSTRING Source - Supplies the source for the string copy

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n = Source->Length;

    RTL_PAGED_CODE();

    if (n) {
        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        RtlMoveMemory( &Destination->Buffer[ Destination->Length ],
                       Source->Buffer,
                       n
                     );
        Destination->Length += n;
        }

    return( STATUS_SUCCESS );
}

#if !defined(_X86_) && !defined(_AMD64_)

SIZE_T
NTAPI
RtlCompareMemoryUlong(
    PVOID Source,
    SIZE_T Length,
    ULONG Pattern
    )

/*++

Routine Description:

    This function compares two blocks of memory and returns the number
    of bytes that compared equal.

    N.B. This routine requires that the source address is aligned on a
         longword boundary and that the length is an even multiple of
         longwords.

Arguments:

    Source - Supplies a pointer to the block of memory to compare against.

    Length - Supplies the Length, in bytes, of the memory to be
        compared.

    Pattern - Supplies a 32-bit pattern to compare against the block of
        memory.

Return Value:

   The number of bytes that compared equal is returned as the function
   value.  If all bytes compared equal, then the length of the original
   block of memory is returned.  Returns zero if either the Source
   address is not longword aligned or the length is not a multiple of
   longwords.

--*/
{
    SIZE_T CountLongs;
    PULONG p = (PULONG)Source;
    PCHAR p1, p2;

    if (((ULONG_PTR)p & (sizeof( ULONG )-1)) ||
        (Length & (sizeof( ULONG )-1))
       ) {
        return( 0 );
    }

    CountLongs = Length / sizeof( ULONG );
    while (CountLongs--) {
        if (*p++ != Pattern) {
            p1 = (PCHAR)(p - 1);
            p2 = (PCHAR)&Pattern;
            Length = p1 - (PCHAR)Source;
            while (*p1++ == *p2++) {
                Length++;
            }
            break;
        }
    }

    return( Length );
}

#endif // !defined(_X86_) && !defined(_AMD64_)
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\tracedb.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    tracedb.c

Abstract:

    This module contains the implementation for the trace database 
    module (hash table to store stack trace in USer/Kernel mode).

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>

#include "tracedbp.h"

//
// TRACE_ASSERT
//

#if DBG
#define TRACE_ASSERT(Expr) {                                              \
    if (!(Expr)) {                                                        \
        DbgPrint ("Page heap: (%s, %d): \" %s \" -- assertion failed \n", \
          __FILE__, __LINE__, #Expr);                                     \
        DbgBreakPoint ();                                                 \
    }}
#else
#define TRACE_ASSERT(Expr)
#endif // #if DBG

//
// Magic values that prefix tracedb structures and allow
// early detection of corruptions.
//

#define RTL_TRACE_BLOCK_MAGIC       0xABCDAAAA
#define RTL_TRACE_SEGMENT_MAGIC     0xABCDBBBB
#define RTL_TRACE_DATABASE_MAGIC    0xABCDCCCC

//
// Amount of memory with each a trace database will be
// increased if a new trace cannot be stored.
//

#define RTL_TRACE_SIZE_INCREMENT PAGE_SIZE

//
// Internal function declarations
//

BOOLEAN
RtlpTraceDatabaseInternalAdd (
    IN PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    );

BOOLEAN
RtlpTraceDatabaseInternalFind (
    PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    );

ULONG 
RtlpTraceStandardHashFunction (
    IN ULONG Count,
    IN PVOID * Trace
    );

PVOID 
RtlpTraceDatabaseAllocate (
    IN SIZE_T Size,
    IN ULONG Flags, // OPTIONAL in User mode
    IN ULONG Tag    // OPTIONAL in User mode
    );

BOOLEAN 
RtlpTraceDatabaseFree (
    PVOID Block,
    IN ULONG Tag    // OPTIONAL in User mode
    );

BOOLEAN 
RtlpTraceDatabaseInitializeLock (
    IN PRTL_TRACE_DATABASE Database
    );

BOOLEAN 
RtlpTraceDatabaseUninitializeLock (
    IN PRTL_TRACE_DATABASE Database
    );

BOOLEAN 
RtlpTraceDatabaseAcquireLock (
    IN PRTL_TRACE_DATABASE Database
    );

BOOLEAN 
RtlpTraceDatabaseReleaseLock (
    IN PRTL_TRACE_DATABASE Database
    );

PRTL_TRACE_SEGMENT
RtlpTraceSegmentCreate (
    IN SIZE_T Size,
    IN ULONG Flags, // OPTIONAL in User mode
    IN ULONG Tag    // OPTIONAL in User mode
    );

//
// Trace database implementation
//

PRTL_TRACE_DATABASE
RtlTraceDatabaseCreate (
    IN ULONG Buckets,
    IN SIZE_T MaximumSize OPTIONAL,
    IN ULONG Flags, // OPTIONAL in User mode
    IN ULONG Tag,   // OPTIONAL in User mode
    IN RTL_TRACE_HASH_FUNCTION HashFunction OPTIONAL
    )
/*++

Routine Description:

    This routine creates a trace database, that is a hash table
    to store stack traces.

Arguments:

    Buckets - no of buckets of the hash table with simple chaining.
    
    MaximumSize - maximum amount of memory that the database can use.
        When limit is hit, database add operations will start to fail.
        If the value is zero then no limit will be imposed.
        
    Flags - flags to control if allocation in K mode is done in P or NP
        pool. The possible bits that can be used right now are:
        RTL_TRACE_USE_PAGED_POOL
        RTL_TRACE_USE_NONPAGED_POOL
        
    Tag - tag used for K mode allocations.
    
    HashFunction - hash function to be used. If null passed a standard hash 
        function will be provided by the module.    

Return Value:

    Pointer to an initialized trace database structure.

Environment:

    Any.

--*/
{
    PVOID RawArea;
    SIZE_T RawSize;
    PRTL_TRACE_DATABASE Database;
    PRTL_TRACE_SEGMENT Segment;
    ULONG FirstFlags;

    //
    // Prepare trace database flags. The first segment of
    // the database will be allocated in nonpaged pool
    // no matter what flags are used because it contains
    // kernel synchronization objects that need to be in
    // that pool. 
    //

    Flags |= RTL_TRACE_IN_KERNEL_MODE;
    FirstFlags = RTL_TRACE_IN_KERNEL_MODE | RTL_TRACE_USE_NONPAGED_POOL;

    //
    // Allocate first segment of trace database that will contain
    // DATABASE, SEGMENT, buckets of the hash table and later traces.
    //

    RawSize = sizeof (RTL_TRACE_DATABASE) +
        sizeof (RTL_TRACE_SEGMENT) +
        Buckets * sizeof (PRTL_TRACE_BLOCK);

    RawSize += RTL_TRACE_SIZE_INCREMENT;
    RawSize &= ~(RTL_TRACE_SIZE_INCREMENT - 1);

    RawArea = RtlpTraceDatabaseAllocate (
        RawSize, 
        FirstFlags,
        Tag);

    if (RawArea == NULL) {
        return NULL;
    }

    Database = (PRTL_TRACE_DATABASE)RawArea;
    Segment = (PRTL_TRACE_SEGMENT)(Database + 1);

    //
    // Initialize the database
    //

    Database->Magic = RTL_TRACE_DATABASE_MAGIC;
    Database->Flags = Flags;
    Database->Tag = Tag;
    Database->SegmentList = NULL;
    Database->MaximumSize = MaximumSize;
    Database->CurrentSize = RTL_TRACE_SIZE_INCREMENT;
    Database->Owner = NULL;

    Database->NoOfHits = 0;
    Database->NoOfTraces = 0;
    RtlZeroMemory (Database->HashCounter, sizeof (Database->HashCounter));

    if (! RtlpTraceDatabaseInitializeLock (Database)) {
        RtlpTraceDatabaseFree (RawArea, Tag);
        return NULL;
    }

    Database->NoOfBuckets = Buckets;      

    if (HashFunction == NULL) {
        Database->HashFunction = RtlpTraceStandardHashFunction;
    }
    else {
        Database->HashFunction = HashFunction;
    }

    //
    // Initialize first segment of the database
    //

    Segment->Magic = RTL_TRACE_SEGMENT_MAGIC;
    Segment->Database = Database;
    Segment->NextSegment = NULL;
    Segment->TotalSize = RTL_TRACE_SIZE_INCREMENT;

    Database->SegmentList = Segment;

    //
    // Initialize the buckets of the database.
    //

    Database->Buckets = (PRTL_TRACE_BLOCK *)(Segment + 1);
    RtlZeroMemory (Database->Buckets, Database->NoOfBuckets * sizeof(PRTL_TRACE_BLOCK));

    //
    // Initialize free pointer for segment
    //

    Segment->SegmentStart = (PCHAR)RawArea;
    Segment->SegmentEnd = Segment->SegmentStart + RTL_TRACE_SIZE_INCREMENT;
    Segment->SegmentFree = (PCHAR)(Segment + 1) + Database->NoOfBuckets * sizeof(PRTL_TRACE_BLOCK);

    return Database;
}

BOOLEAN
RtlTraceDatabaseDestroy (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:

    This routine destroys a trace database. It takes care of
    deallocating everything, uninitializing synchronization 
    objects, etc.

Arguments:

    Database - trace database

Return Value:

    TRUE if destroy operation was successful. FALSE otherwise.

Environment:

    Any.

--*/
{
    PRTL_TRACE_SEGMENT Current;
    BOOLEAN Success;
    BOOLEAN SomethingFailed = FALSE;
    PRTL_TRACE_SEGMENT NextSegment;

    //
    // Sanity checks.
    //

    TRACE_ASSERT (Database && Database->Magic == RTL_TRACE_DATABASE_MAGIC);
    TRACE_ASSERT (RtlTraceDatabaseValidate (Database));

    //
    // Uninitialize the database lock. Even if we fail
    // we will continue to release memory for all segments.
    //
    // N.B. We cannot acquire the lock here for the last time because this
    // has as a side effect elevating the irql (in K mode) and then the 
    // function will return with raised irql.
    //

    Success = RtlpTraceDatabaseUninitializeLock (Database);

    if (! Success) {
        SomethingFailed = TRUE;
    }

    //
    // Traverse the list of segments and release memory one by one.
    // Special attention with the last segment because it contains
    // the database structure itself and we do not want to shoot.
    // ourselves in the foot.
    //

    for (Current = Database->SegmentList;
         Current != NULL;
         Current = NextSegment) {

        //
        // We save the next segment before freeing the structure.
        //

        NextSegment = Current->NextSegment;

        //
        // If this is the last segment we need to offset Current pointer
        // by the size of the database structure.
        //

        if (NextSegment == NULL) {
            
            Current = (PRTL_TRACE_SEGMENT) ((PRTL_TRACE_DATABASE)Current - 1);
        }

        Success = RtlpTraceDatabaseFree (Current, Database->Tag);

        if (! Success) {

            DbgPrint ("Trace database: failed to release segment %p \n", Current);
            SomethingFailed = TRUE;
        }
    }

    if (SomethingFailed) {
        return FALSE;
    }
    else {
        return TRUE;
    }
}

BOOLEAN
RtlTraceDatabaseValidate (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:

    This routine validates the correctness of a trace database.
    It is intended to be used for testing purposes.

Arguments:

    Database - trace database

Return Value:

    TRUE if the database is ok. For most of the inconsistencies this
    function will break in the debugger.

Environment:

    Any.

--*/
{
    PRTL_TRACE_SEGMENT Segment;
    PRTL_TRACE_BLOCK Block;
    ULONG Index;

    TRACE_ASSERT (Database != NULL);
    TRACE_ASSERT (Database->Magic == RTL_TRACE_DATABASE_MAGIC);

    RtlpTraceDatabaseAcquireLock (Database);

    //
    // Check all segments.
    //

    for (Segment = Database->SegmentList;
         Segment != NULL;
         Segment = Segment->NextSegment) {

        TRACE_ASSERT (Segment->Magic == RTL_TRACE_SEGMENT_MAGIC);
    }

    //
    // Check all blocks.
    //
    
    for (Index = 0; Index < Database->NoOfBuckets; Index++) {

        for (Block = Database->Buckets[Index];
             Block != NULL;
             Block = Block->Next) {

            TRACE_ASSERT (Block->Magic == RTL_TRACE_BLOCK_MAGIC);
        }
    }

    RtlpTraceDatabaseReleaseLock (Database);
    return TRUE;
}

BOOLEAN
RtlTraceDatabaseAdd (
    IN PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    )
/*++

Routine Description:

    This routine adds a new stack trace to the database. If the trace
    already exists then only the `Count' field for the trace will be
    incremented.

Arguments:

    Database - trace database
    
    Count - number of pointers (PVOIDs) in the trace
    
    Trace - array of PVOIDs (the trace)
    
    TraceBlock - if not null will contain the address of the block where
        the trace was stored.

Return Value:

    TRUE if a trace was added to the database. TraceBlock will contain
    the address of the block. If the trace was already present in the
    database a block with `Count' greater than 1 will be returned.

Environment:

    Any.

--*/
{
    BOOLEAN Result;

    //
    // Sanity checks.
    //

    TRACE_ASSERT (Database && Database->Magic == RTL_TRACE_DATABASE_MAGIC);

    RtlpTraceDatabaseAcquireLock (Database);

    Result = RtlpTraceDatabaseInternalAdd (
        Database,
        Count,
        Trace,
        TraceBlock);

    RtlpTraceDatabaseReleaseLock (Database);

    return Result;
}

BOOLEAN
RtlTraceDatabaseFind (
    PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    )
/*++

Routine Description:

    This routine searches a trace in the database. If the trace
    is found then the address of the block that stores the trace
    will be returned.

Arguments:

    Database - trace database
    
    Count - number of pointers (PVOIDs) in the trace
    
    Trace - array of PVOIDs (the trace)
    
    TraceBlock - if not null will contain the address of the block where
        the trace is stored.

Return Value:

    TRUE if the trace was found in the database. TraceBlock will contain
    the address of the block that stores the trace.

Environment:

    Any.

--*/
{
    BOOLEAN Result;

    //
    // Sanity checks.
    //

    TRACE_ASSERT (Database && Database->Magic == RTL_TRACE_DATABASE_MAGIC);

    RtlpTraceDatabaseAcquireLock (Database);

    Result = RtlpTraceDatabaseInternalFind (
        Database,
        Count,
        Trace,
        TraceBlock);

    if (Result) {
        Database->NoOfHits += 1;
    }

    RtlpTraceDatabaseReleaseLock (Database);

    return Result;
}

BOOLEAN
RtlpTraceDatabaseInternalAdd (
    IN PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    )
/*++

Routine Description:

    This is the internal routine to add a trace. See RtlTraceDatabaseAdd
    for more details.

Arguments:

    Database - trace database
    
    Count - size of trace (in PVOIDs)
    
    Trace - trace
    
    TraceBlock - address of block where the trace is stored

Return Value:

    TRUE if trace was added.

Environment:

    Called from RtlTraceDatabaseAdd. Assumes the database lock
    is held.

--*/
{
    PRTL_TRACE_BLOCK Block;
    PRTL_TRACE_SEGMENT Segment;
    PRTL_TRACE_SEGMENT TopSegment;
    ULONG HashValue;
    SIZE_T RequestSize;

    //
    // Check if the block is already in the database (hash table).
    // If it is increase the number of hits and return.
    //

    if (RtlpTraceDatabaseInternalFind (Database, Count, Trace, &Block)) {

        Block->Count += 1;

        if (TraceBlock) {
            *TraceBlock = Block;
        }

        Database->NoOfHits += 1;
        return TRUE;
    }

    //
    //  We need to create a new block. First we need to figure out
    // if the current segment can accommodate the new block.
    // 

    RequestSize = sizeof(*Block) + Count * sizeof(PVOID);

    TopSegment = Database->SegmentList;
    if (RequestSize > (SIZE_T)(TopSegment->SegmentEnd - TopSegment->SegmentFree)) {

        //
        // If the database has a maximum size and that limit
        // has been reached then fail the call.
        //

        if (Database->MaximumSize > 0) {
            if (Database->CurrentSize > Database->MaximumSize) {
                
                if (TraceBlock) {
                    *TraceBlock = NULL;
                }

                return FALSE;
            }
        }

        //
        // Allocate a new database segment. Fail call if cannot
        // allocate.
        //

        Segment = RtlpTraceSegmentCreate (RTL_TRACE_SIZE_INCREMENT, 
                                          Database->Flags,
                                          Database->Tag);

        if (Segment == NULL) {
            
            if (TraceBlock) {
                *TraceBlock = NULL;
            }
            
            return FALSE;
        }

        //
        // Add the new segment to the database.
        //

        Segment->Magic = RTL_TRACE_SEGMENT_MAGIC;
        Segment->Database = Database;
        Segment->TotalSize = RTL_TRACE_SIZE_INCREMENT;
        Segment->SegmentStart = (PCHAR)Segment;
        Segment->SegmentEnd = Segment->SegmentStart + RTL_TRACE_SIZE_INCREMENT;
        Segment->SegmentFree = (PCHAR)(Segment + 1);

        Segment->NextSegment = Database->SegmentList;
        Database->SegmentList = Segment;
        TopSegment = Database->SegmentList;

        Database->CurrentSize += RTL_TRACE_SIZE_INCREMENT;
    }

    if (RequestSize > (SIZE_T)(TopSegment->SegmentEnd - TopSegment->SegmentFree)) {

        DbgPrint ("Trace database: failing attempt to save biiiiig trace (size %u) \n", 
                  Count);
        
        if (TraceBlock) {
            *TraceBlock = NULL;
        }

        return FALSE;
    }

    //
    // Finally we can allocate our block.
    //

    Block = (PRTL_TRACE_BLOCK)(TopSegment->SegmentFree);
    TopSegment->SegmentFree += RequestSize;

    //
    // Fill the block with the new trace.
    //

    Block->Magic = RTL_TRACE_BLOCK_MAGIC;
    Block->Size = Count;
    Block->Count = 1;
    Block->Trace = (PVOID *)(Block + 1);

    Block->UserCount = 0;
    Block->UserSize = 0;

    //
    // Copy the trace
    //

    RtlMoveMemory (Block->Trace, Trace, Count * sizeof(PVOID));

    //
    // Add the block to corresponding bucket.
    //

    HashValue = (Database->HashFunction) (Count, Trace);
    HashValue %= Database->NoOfBuckets;
    Database->HashCounter[HashValue / (Database->NoOfBuckets / 16)] += 1;

    Block->Next = Database->Buckets[HashValue];
    Database->Buckets[HashValue] = Block;

    //
    // Loooong function. Finally return success.
    //

    if (TraceBlock) {
        *TraceBlock = Block;
    }

    Database->NoOfTraces += 1;
    return TRUE;
}

BOOLEAN
RtlpTraceDatabaseInternalFind (
    PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    )
/*++

Routine Description:

    This internal routine searches for a trace in the database.

Arguments:

    Database - trace database
    
    Count - size of trace (in PVOIDs)
    
    Trace - trace
    
    TraceBlock - element where the trace is stored.

Return Value:

    TRUE if the trace was found.

Environment:

    Called from RtlTraceDatabaseFind. Assumes the database lock is held.

--*/
{
    ULONG HashValue;
    PRTL_TRACE_BLOCK Current;
    ULONG Index;
    ULONG RequestSize;

    //
    // Find the bucket to search into.
    //

    HashValue = (Database->HashFunction) (Count, Trace);
    Database->HashCounter[HashValue % 16] += 1;
    HashValue %= Database->NoOfBuckets;

    //
    // Traverse the list of blocks for the found bucket
    //

    for (Current = Database->Buckets[HashValue];
         Current != NULL;
         Current = Current->Next) {

        //
        // If the size of the trace matches we might have a chance
        // to find an equal trace.
        //

        if (Count == Current->Size) {

            //
            // Figure out if the whole trace matches.
            //

            for (Index = 0; Index < Count; Index++) {
                if (Current->Trace[Index] != Trace[Index]) {
                    break;
                }
            }

            //
            // If the trace matched completely we have found an entry.
            //

            if (Index == Count) {
                if (TraceBlock) {
                    *TraceBlock = Current;
                }

                return TRUE;
            }
        }
    }

    //
    // If we traversed the whole list for the hashed bucket and did not
    // find anything we will fail the call.
    //

    if (TraceBlock) {
        *TraceBlock = NULL;
    }
    
    return FALSE;
}

ULONG 
RtlpTraceStandardHashFunction (
    IN ULONG Count,
    IN PVOID * Trace
    )
/*++

Routine Description:

    This routine is a simple hash function for stack traces in
    the case the caller of RtlTraceDatabaseCreate does not provide
    one. The function just xor's together all the pointers in the
    trace.

Arguments:

    Count - size of trace (in PVOIDs)
    
    Trace - trace

Return Value:

    Hash value. This needs to be reduced to the number of buckets
    in the hash table by a modulo operation (or something similar).

Environment:

    Called internally by RtlpTraceDatabaseInternalAdd/Find.

--*/
{
    ULONG_PTR Value = 0;
    ULONG Index;
    unsigned short * Key; 

    Key = (unsigned short *)Trace;
    for (Index = 0; Index < Count * (sizeof (PVOID) / sizeof(*Key)); Index += 2) {

        Value += Key[Index] ^ Key[Index + 1];
    }

    return PtrToUlong ((PVOID)Value);
}

PVOID 
RtlpTraceDatabaseAllocate (
    IN SIZE_T Size,
    IN ULONG Flags, // OPTIONAL in User mode
    IN ULONG Tag    // OPTIONAL in User mode
    )
/*++

Routine Description:

    This routine allocates memory and hides all the different
    details for User vs Kernel mode allocation and paged vs
    nonpaged pool.

Arguments:

    Size -  size in bytes
    
    Flags - flags (specify U/K mode and P/NP pool)
    
    Tag - tag used for K mode allocations

Return Value:

    Pointer to memory area allocated or null.

Environment:

    Internal function for trace database module.

--*/
{
    if ((Flags & RTL_TRACE_USE_NONPAGED_POOL)) {
        return ExAllocatePoolWithTag (NonPagedPool, Size, Tag);
    }
    else {
        return ExAllocatePoolWithTag (PagedPool, Size, Tag);
    }
}

BOOLEAN 
RtlpTraceDatabaseFree (
    PVOID Block,
    IN ULONG Tag    // OPTIONAL in User mode
    )
/*++

Routine Description:

    This routine frees memory and hides all the different
    details for User vs Kernel mode allocation and paged vs
    nonpaged pool.

Arguments:

    Block - memory area to free
    
    Tag - tag used for K mode allocation

Return Value:

    TRUE if deallocation was successful.

Environment:

    Internal function for trace database module.
    
--*/
{
    ExFreePoolWithTag (Block, Tag);
    return TRUE;
}

BOOLEAN 
RtlpTraceDatabaseInitializeLock (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:

    This routine initializes the trace database lock.
    It hides all details about the actual nature of the lock.

Arguments:

    Database - trace database

Return Value:

    TRUE if successful.

Environment:

    Internal trace database module function.

--*/
{
    ASSERT((Database->Flags & RTL_TRACE_IN_KERNEL_MODE));

    if ((Database->Flags & RTL_TRACE_USE_NONPAGED_POOL)) {
        KeInitializeSpinLock (&(Database->u.SpinLock));
    }
    else {
        ExInitializeFastMutex (&(Database->u.FastMutex));
    }

    return TRUE;
}


BOOLEAN 
RtlpTraceDatabaseUninitializeLock (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:
    
    This routine uninitializes the trace database lock.
    It hides all details about the actual nature of the lock.
    (e.g. In user mode we need to call RtlDeleteCriticalSection).

Arguments:

    Database - trace database

Return Value:

    TRUE if successful.

Environment:

    Internal trace database module function.

--*/
{
    ASSERT((Database->Flags & RTL_TRACE_IN_KERNEL_MODE));

    if ((Database->Flags & RTL_TRACE_USE_NONPAGED_POOL)) {

        //
        // No "uninitialize" required for spinlocks.
        //
    }
    else {
        
        //
        // No "uninitialize" required for fast mutexes.
        //
    }

    return TRUE;
}


VOID 
RtlTraceDatabaseLock (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:
    
    This routine acquires the trace database lock.
    It hides all details about the actual nature of the lock.
    
    The callers needs to acquire the database lock only if 
    a trace block will be modified (UserCount, UserSize fields).
    The lock is not needed for Add/Find/Enumerate operations.

Arguments:

    Database - trace database

Return Value:

    None.

Environment:

    Called if a trace block will be modified.

--*/
{
    RtlpTraceDatabaseAcquireLock(Database);
}


VOID 
RtlTraceDatabaseUnlock (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:
    
    This routine releases the trace database lock.
    It hides all details about the actual nature of the lock.
    
    The callers needs to acquire/release the database lock only if 
    a trace block will be modified (UserCount, UserSize fields).
    The lock is not needed for Add/Find/Enumerate operations.

Arguments:

    Database - trace database

Return Value:

    None.

Environment:

    Called if a trace block will be modified.

--*/
{
    RtlpTraceDatabaseReleaseLock(Database);
}


BOOLEAN 
RtlpTraceDatabaseAcquireLock (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:
    
    This routine acquires the trace database lock.
    It hides all details about the actual nature of the lock.

Arguments:

    Database - trace database

Return Value:

    TRUE if successful.

Environment:

    Internal trace database module function.

--*/
{
    ASSERT((Database->Flags & RTL_TRACE_IN_KERNEL_MODE));

    if ((Database->Flags & RTL_TRACE_USE_NONPAGED_POOL)) {
        KeAcquireSpinLock (&(Database->u.SpinLock), &(Database->SavedIrql));
    }
    else {
        ExAcquireFastMutex (&(Database->u.FastMutex));
    }

    Database->Owner = KeGetCurrentThread();
    return TRUE;
}

BOOLEAN 
RtlpTraceDatabaseReleaseLock (
    IN PRTL_TRACE_DATABASE Database
    )
/*++

Routine Description:
    
    This routine releases the trace database lock.
    It hides all details about the actual nature of the lock.

Arguments:

    Database - trace database

Return Value:

    TRUE if successful.

Environment:

    Internal trace database module function.

--*/
{
    ASSERT((Database->Flags & RTL_TRACE_IN_KERNEL_MODE));
    Database->Owner = NULL;

    if ((Database->Flags & RTL_TRACE_USE_NONPAGED_POOL)) {
        KeReleaseSpinLock (&(Database->u.SpinLock), Database->SavedIrql);
    }
    else {
        ExReleaseFastMutex (&(Database->u.FastMutex));
    }

    return TRUE;
}

PRTL_TRACE_SEGMENT
RtlpTraceSegmentCreate (
    IN SIZE_T Size,
    IN ULONG Flags, // OPTIONAL in User mode
    IN ULONG Tag    // OPTIONAL in User mode
    )
/*++

Routine Description:

    This routine creates a new segment. The segment is the device
    through which a database can increase in size to accommodata
    more traces.

Arguments:

    Size - size in bytes
    
    Flags - allocation flags (U/K mode, P/NP pool)
    
    Tag - tag for K mode allocations

Return Value:

    New allocated segment or null.

Environment:

    Internal trace database module function.

--*/
{
    PRTL_TRACE_SEGMENT Segment;

    Segment = RtlpTraceDatabaseAllocate (Size, Flags, Tag);
    return Segment;
}


BOOLEAN
RtlTraceDatabaseEnumerate (
    PRTL_TRACE_DATABASE Database,
    OUT PRTL_TRACE_ENUMERATE Enumerate,
    OUT PRTL_TRACE_BLOCK * TraceBlock
    )
/*++

Routine Description:

    This function enumerates all traces in the database. It requires a
    RTL_TRACE_ENUMERATE function (zeroed initially) to keep the state of
    the enumeration. Since the trace database does not support delete
    operations we do not need to keep a lock across multiple calls to
    Enumerate(). However this can change if we add support for deletions.

Arguments:

    Database - trace database pointer
    
    Enumerate - enumeration opaque structure. Used to keep the state of 
        the enumeration.
        
    TraceBlock - on each successful return this pointer gets filled with
        the address of a trace block from the database.        

Return Value:

    TRUE if a trace block was found (during enumeration) and FALSE if there
    are no more blocks in the database.

Environment:

    User/Kernel mode.

--*/

{
    BOOLEAN Result;
    
    TRACE_ASSERT (Database != NULL);
    TRACE_ASSERT (Database->Magic == RTL_TRACE_DATABASE_MAGIC);

    RtlpTraceDatabaseAcquireLock (Database);
    
    //
    // Start the search process if this is the first call.
    // If this is not the first call try to validate what
    // we have inside the enumerator.
    //

    if (Enumerate->Database == NULL) {

        Enumerate->Database = Database;
        Enumerate->Index = 0;
        Enumerate->Block = Database->Buckets[0];
    }
    else {

        if (Enumerate->Database != Database) {
            Result = FALSE;
            goto Exit;
        }

        if (Enumerate->Index >= Database->NoOfBuckets) {
            Result = FALSE;
            goto Exit;
        }
    }

    //
    // Find out the next trace block in case we are at the end
    // of a bucket or the bucket was empty.
    //

    while (Enumerate->Block == NULL) {
        
        Enumerate->Index += 1;
        
        if (Enumerate->Index >= Database->NoOfBuckets) {
            break;
        }
        
        Enumerate->Block = Database->Buckets[Enumerate->Index];
    }
    
    //
    // Figure out if we have finished the enumeration.
    //

    if (Enumerate->Index >= Database->NoOfBuckets && Enumerate->Block == NULL) {

        *TraceBlock = NULL;
        Result = FALSE;
        goto Exit;
    }

    //
    // Fill out the next trace block and advance the enumerator.
    //

    *TraceBlock = Enumerate->Block;
    Enumerate->Block = Enumerate->Block->Next;
    Result = TRUE;

    //
    // Clean up and exit
    //

    Exit:

    RtlpTraceDatabaseReleaseLock (Database);
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\tracedbp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    tracedbp.h

Abstract:

    This header contains the private interfaces for the trace database 
    module (hash table to store stack traces in Kernel mode).

--*/

#ifndef _TRACEDBP_H
#define _TRACEDBP_H

//
// RTL_TRACE_SEGMENT
//

typedef struct _RTL_TRACE_SEGMENT {

    ULONG Magic;

    struct _RTL_TRACE_DATABASE * Database;
    struct _RTL_TRACE_SEGMENT * NextSegment;
    SIZE_T TotalSize;
    PCHAR SegmentStart;
    PCHAR SegmentEnd;
    PCHAR SegmentFree;

} RTL_TRACE_SEGMENT, * PRTL_TRACE_SEGMENT;

//
// RTL_TRACE_DATABASE
//

typedef struct _RTL_TRACE_DATABASE {

    ULONG Magic;
    ULONG Flags;
    ULONG Tag;

    struct _RTL_TRACE_SEGMENT * SegmentList;

    SIZE_T MaximumSize;
    SIZE_T CurrentSize;

    KIRQL SavedIrql;
    PVOID Owner;

    union {
        KSPIN_LOCK SpinLock;
        FAST_MUTEX FastMutex;
    } u;

    ULONG NoOfBuckets;
    struct _RTL_TRACE_BLOCK * * Buckets;
    RTL_TRACE_HASH_FUNCTION HashFunction;

    SIZE_T NoOfTraces;
    SIZE_T NoOfHits;

    ULONG HashCounter[16];

} RTL_TRACE_DATABASE, * PRTL_TRACE_DATABASE;

#endif // #ifndef _TRACEDBP_H
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\amd64\context.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    context.c

Abstract:

    This module implements user mode callable context manipulation routines.
    The interfaces exported from this module are portable, but they must
    be re-implemented for each architecture.

--*/

#include "ntrtlp.h"

#pragma alloc_text(PAGE, RtlInitializeContext)
#pragma alloc_text(PAGE, RtlRemoteCall)

VOID
RtlInitializeContext(
    IN HANDLE Process,
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL
    )

/*++

Routine Description:

    This function initializes a context record so that it can be used in a
    subsequent call to create thread.

Arguments:

    Process - Supplies a handle to the process in which a thread is being
        created.

    Context - Supplies a pointer to a context record.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

Return Value:

    STATUS_BAD_INITIAL_STACK is raised if initial stack pointer value is not
    properly aligned.

--*/

{

    RTL_PAGED_CODE();

    //
    // Check stack alignment.
    //

    if (((ULONG64)InitialSp & 0xf) != 0) {
        RtlRaiseStatus(STATUS_BAD_INITIAL_STACK);
    }

    //
    // Initialize the EFflags field.
    //

    Context->EFlags = EFLAGS_IF_MASK;

    //
    // Initialize the integer registers.
    //

    Context->Rax = 0L;
    Context->Rcx = 2L;
    Context->Rbx = 1L;
    Context->Rsp = (ULONG64)InitialSp;
    Context->Rbp = 0L;
    Context->Rsi = 4L;
    Context->Rdi = 5L;
    Context->R8 = 8;
    Context->R9 = 9;
    Context->R10 = 10;
    Context->R11 = 11;
    Context->R12 = 12;
    Context->R13 = 13;
    Context->R14 = 14;
    Context->R15 = 15;

    //
    // Initialize the floating point state.
    //
    // N.B. This includes both the legacy and extended floating state.
    //

    RtlZeroMemory(&Context->FltSave, sizeof(XMM_SAVE_AREA32));
    Context->MxCsr = INITIAL_MXCSR;
    Context->FltSave.ControlWord = INITIAL_FPCSR;
    Context->FltSave.MxCsr = INITIAL_MXCSR;

    //
    // Initialize the program counter.
    //

    Context->Rip = (ULONG64)InitialPc;

    //
    // Set context record flags.
    //

    Context->ContextFlags = CONTEXT_FULL;

    //
    // Set the initial context of the thread in a machine specific way.
    //

    Context->Rcx = (ULONG64)Parameter;

    //
    // Unique stamp to tell wow64 that this is an RtlCreateUserThread context
    // rather than BaseCreateThread context.
    //

    Context->R9 = 0xf0e0d0c0a0908070UI64;
    return;
}

NTSTATUS
RtlRemoteCall (
    HANDLE Process,
    HANDLE Thread,
    PVOID CallSite,
    ULONG ArgumentCount,
    PULONG_PTR Arguments,
    BOOLEAN PassContext,
    BOOLEAN AlreadySuspended
    )

/*++

Routine Description:

    This function calls a procedure in another thread/process using the
    system functions get and set context. Parameters are passed to the
    target procedure via the nonvolatile registers.

Arguments:

    Process - Supplies an open handle to the target process.

    Thread - Supplies an open handle to the target thread within the target
        process.

    CallSite - Supplies the address of the procedure to call in the target
        process.

    ArgumentCount - Supplies the number of parameters to pass to the target
        procedure.

    Arguments - Supplies a pointer to the array of parameters to pass.

    PassContext - Supplies a boolean value that determines whether a parameter
        is to be passed that points to a context record.

    AlreadySuspended - Supplies a boolean value that determines whether the
        target thread is already in a suspended or waiting state.

Return Value:

    Status - Status value

--*/

{

    CONTEXT Context;
    ULONG Index;
    ULONG64 NewSp;
    NTSTATUS Status;

    RTL_PAGED_CODE();

    //
    // Check if too many arguments are specified.
    //

    if (ArgumentCount > 4) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If necessary, suspend the target thread before getting the thread's
    // current state.
    //

    if (AlreadySuspended == FALSE) {
        Status = NtSuspendThread(Thread, NULL);
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Get the current context of the target thread.
    //

    Context.ContextFlags = CONTEXT_FULL;
    Status = NtGetContextThread(Thread, &Context);
    if (!NT_SUCCESS(Status)) {
        if (AlreadySuspended == FALSE) {
            NtResumeThread(Thread, NULL);
        }

        return Status;
    }

    if (AlreadySuspended != FALSE) {
        Context.Rax = STATUS_ALERTED;
    }

    //
    // Write previous thread context into the stack of the target thread.
    //

    NewSp = Context.Rsp - sizeof(CONTEXT);
	Status = NtWriteVirtualMemory(Process,
				                  (PVOID)NewSp,
				                  &Context,
				                  sizeof(CONTEXT),
				                  NULL);

	if (!NT_SUCCESS(Status)) {
        if (AlreadySuspended == FALSE) {
            NtResumeThread(Thread, NULL);
        }

	    return Status;
	}

    //
    // Pass the parameters to the target thread via the nonvolatile registers
    // R11-R15.
    //

    Context.Rsp = NewSp;
    if (PassContext != FALSE) {
        Context.R11 = NewSp;
        for (Index = 0; Index < ArgumentCount; Index += 1) {
            (&Context.R12)[Index] = Arguments[Index];
        }

    } else {
        for (Index = 0; Index < ArgumentCount; Index += 1) {
            (&Context.R11)[Index] = Arguments[Index];
        }
    }

    //
    // Set the address of the target code into RIP and set the thread context
    // to cause the target procedure to be executed.
    //

    Context.Rip = (ULONG64)CallSite;
    Status = NtSetContextThread(Thread, &Context);
    if (AlreadySuspended == FALSE) {
        NtResumeThread(Thread, NULL);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\amd64\capture.asm ===
title   "Capture and Restore Context"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   capture.asm
;
; Abstract:
;
;   This module implements the platform specific code to capture and restore
;   the context of the caller.
;
;--

include ksamd64.inc

        altentry RcConsolidateFrames

        subttl  "Capture Context"
;++
;
; VOID
; RtlCaptureContext (
;     IN PCONTEXT ContextRecord
;     )
;
; Routine Description:
;
;   This function captures the context of the caller in the specified
;   context record.
;
;   N.B. The stored value of registers rcx and rsp will be a side effect of
;        having made this call. All other registers will be stored as they
;        were when the call to this function was made.
;
; Arguments:
;
;    ContextRecord (rcx) - Supplies a pointer to a context record.
;
; Return Value:
;
;    None.
;
;--

CcFrame struct
        EFlags  dd ?                    ; saved processor flags
        Fill    dd ?                    ; fill
CcFrame ends


        NESTED_ENTRY RtlCaptureContext, _TEXT$00

        rex_push_eflags                 ; save processor flags

        END_PROLOGUE

        mov     CxSegCs[rcx], cs        ; save segment registers
        mov     CxSegDs[rcx], ds        ;
        mov     CxSegEs[rcx], es        ;
        mov     CxSegSs[rcx], ss        ;
        mov     CxSegFs[rcx], fs        ;
        mov     CxSegGs[rcx], gs        ;

        mov     CxRax[rcx], rax         ; save integer registers
        mov     CxRcx[rcx], rcx         ;
        mov     CxRdx[rcx], rdx         ;
        mov     CxRbx[rcx], rbx         ;
        lea     rax, (sizeof CcFrame) + 8[rsp] ; get previous stack address
        mov     CxRsp[rcx], rax         ;
        mov     CxRbp[rcx], rbp         ;
        mov     CxRsi[rcx], rsi         ;
        mov     CxRdi[rcx], rdi         ;
        mov     CxR8[rcx], r8           ;
        mov     CxR9[rcx], r9           ;
        mov     CxR10[rcx], r10         ;
        mov     CxR11[rcx], r11         ;
        mov     CxR12[rcx], r12         ;
        mov     CxR13[rcx], r13         ;
        mov     CxR14[rcx], r14         ;
        mov     CxR15[rcx], r15         ;

        movdqa  CxXmm0[rcx], xmm0       ; save xmm floating registers
        movdqa  CxXmm1[rcx], xmm1       ;
        movdqa  CxXmm2[rcx], xmm2       ;
        movdqa  CxXmm3[rcx], xmm3       ;
        movdqa  CxXmm4[rcx], xmm4       ;
        movdqa  CxXmm5[rcx], xmm5       ;
        movdqa  CxXmm6[rcx], xmm6       ;
        movdqa  CxXmm7[rcx], xmm7       ;
        movdqa  CxXmm8[rcx], xmm8       ;
        movdqa  CxXmm9[rcx], xmm9       ;
        movdqa  CxXmm10[rcx], xmm10     ;
        movdqa  CxXmm11[rcx], xmm11     ;
        movdqa  CxXmm12[rcx], xmm12     ;
        movdqa  CxXmm13[rcx], xmm13     ;
        movdqa  CxXmm14[rcx], xmm14     ;
        movdqa  CxXmm15[rcx], xmm15     ;

        stmxcsr CxMxCsr[rcx]            ; save xmm floating state

        mov     rax, 8[rsp]             ; set return address
        mov     CxRip[rcx], rax         ;

        mov     eax, Ccframe.EFlags[rsp] ; set processor flags
        mov     CxEFlags[rcx], eax      ;

        mov     dword ptr CxContextFlags[rcx], CONTEXT_FULL or CONTEXT_SEGMENTS ; set context flags
        add     rsp, sizeof CcFrame     ; deallocate stack frame
        ret                             ; return

        NESTED_END RtlCaptureContext, _TEXT$00

        subttl  "Restore Context"
;++
;
; VOID
; RtlRestoreContext (
;     IN PCONTEXT ContextRecord,
;     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL
;     )
;
; Routine Description:
;
;   This function restores the context of the caller to the specified
;   context.
;
; Arguments:
;
;    ContextRecord (rcx) - Supplies a pointer to a context record.
;
;    ExceptionRecord (rdx) - Supplies an optional pointer to an exception
;        record.
;
; Return Value:
;
;    None - there is no return from this function.
;
;--

RcFrame struct
        Mframe  db MachineFrameLength dup (?) ; machine frame
        Fill    dq ?                    ; fill to 0 mod 16
RcFrame ends

        NESTED_ENTRY RtlRestoreContext, _TEXT$00

        rex_push_reg rbp                ; save nonvolatile registers
        push_reg rsi                    ;
        push_reg rdi                    ;
        alloc_stack (sizeof RcFrame)    ; allocate stack frame
        set_frame rbp, 0                ; set frame pointer

        END_PROLOGUE

;
; If an exception record is specified and the exception status is the unwind
; consolidation code and there is at least one parameter, then consolidate
; all the frames that have been unwound and call back to a language specified
; routine.
;

        test    rdx, rdx                ; test if exception record specified
        jz      Rc10                    ; if z, no exception record specified
        cmp     dword ptr ErExceptionCode[rdx], STATUS_UNWIND_CONSOLIDATE ; check call back
        jne     short Rc05              ; if ne, not C++ unwind
        cmp     dword ptr ErNumberParameters[rdx], 1 ; check number parameters
        jae     Rc20                    ; if ae, unwind consolidation

;
; If an exception record is specified and the exception status is long jump,
; then restore the nonvolatile registers to their state at the call to set
; jump before restoring the context record.
;

Rc05:   cmp     dword ptr ErExceptionCode[rdx], STATUS_LONGJUMP ; check for long jump
        jne     Rc10                    ; if ne, not a long jump

;
; Long jump unwind.
;
; Copy register values from the jump buffer to the context record.
;

        mov     rax, ErExceptionInformation[rdx] ; get jump buffer address
        mov     r8, JbRbx[rax]          ; move nonvolatile integer registers
        mov     CxRbx[rcx], r8          ; to context record
        mov     r8, JbRsp[rax]          ;
        mov     CxRsp[rcx], r8          ;
        mov     r8, JbRbp[rax]          ;
        mov     CxRbp[rcx], r8          ;
        mov     r8, JbRsi[rax]          ;
        mov     CxRsi[rcx], r8          ;
        mov     r8, JbRdi[rax]          ;
        mov     CxRdi[rcx], r8          ;
        mov     r8, JbR12[rax]          ;
        mov     CxR12[rcx], r8          ;
        mov     r8, JbR13[rax]          ;
        mov     CxR13[rcx], r8          ;
        mov     r8, JbR14[rax]          ;
        mov     CxR14[rcx], r8          ;
        mov     r8, JbR15[rax]          ;
        mov     CxR15[rcx], r8          ;
        mov     r8, JbRip[rax]          ;
        mov     CxRip[rcx], r8          ;

        mov     r8d, JbMxCsr[rax]       ; move MXCSR to context record
        mov     CxMxCsr[rcx], r8d       ;

        movdqa  xmm0, JbXmm6[rax]       ; move nonvolatile floating register
        movdqa  CxXmm6[rcx], xmm0       ;  to context record
        movdqa  xmm0, JbXmm7[rax]       ;
        movdqa  CxXmm7[rcx], xmm0       ;
        movdqa  xmm0, JbXmm8[rax]       ;
        movdqa  CxXmm8[rcx], xmm0       ;
        movdqa  xmm0, JbXmm9[rax]       ;
        movdqa  CxXmm9[rcx], xmm0       ;
        movdqa  xmm0, JbXmm10[rax]      ;
        movdqa  CxXmm10[rcx], xmm0      ;
        movdqa  xmm0, JbXmm11[rax]      ;
        movdqa  CxXmm11[rcx], xmm0      ;
        movdqa  xmm0, JbXmm12[rax]      ;
        movdqa  CxXmm12[rcx], xmm0      ;
        movdqa  xmm0, JbXmm13[rax]      ;
        movdqa  CxXmm13[rcx], xmm0      ;
        movdqa  xmm0, JbXmm14[rax]      ;
        movdqa  CxXmm14[rcx], xmm0      ;
        movdqa  xmm0, JbXmm15[rax]      ;
        movdqa  CxXmm15[rcx], xmm0      ;

;
; Restore context and continue.
;

Rc10:                                   ;
        movdqa  xmm0, CxXmm0[rcx]       ; restore floating registers
        movdqa  xmm1, CxXmm1[rcx]       ;
        movdqa  xmm2, CxXmm2[rcx]       ;
        movdqa  xmm3, CxXmm3[rcx]       ;
        movdqa  xmm4, CxXmm4[rcx]       ;
        movdqa  xmm5, CxXmm5[rcx]       ;
        movdqa  xmm6, CxXmm6[rcx]       ;
        movdqa  xmm7, CxXmm7[rcx]       ;
        movdqa  xmm8, CxXmm8[rcx]       ;
        movdqa  xmm9, CxXmm9[rcx]       ;
        movdqa  xmm10, CxXmm10[rcx]     ;
        movdqa  xmm11, CxXmm11[rcx]     ;
        movdqa  xmm12, CxXmm12[rcx]     ;
        movdqa  xmm13, CxXmm13[rcx]     ;
        movdqa  xmm14, CxXmm14[rcx]     ;
        movdqa  xmm15, CxXmm15[rcx]     ;

        ldmxcsr CxMxCsr[rcx]            ; restore MXCSR

        mov     ax, CxSegSs[rcx]        ; set SS segment
        mov     MfSegSs[rsp], ax        ;
        mov     rax, CxRsp[rcx]         ; set stack address
        mov     MfRsp[rsp], rax         ;
        mov     eax, CxEFlags[rcx]      ; set processor flags
        mov     MfEFlags[rsp], eax      ;
        mov     ax, CxSegCs[rcx]        ; set CS segment
        mov     MfSegCs[rsp], ax        ;
        mov     rax, CxRip[rcx]         ; set return address
        mov     MfRip[rsp], rax         ;

        mov     rax, CxRax[rcx]         ; restore volatile integer registers
        mov     rdx, CxRdx[rcx]         ;
        mov     r8, CxR8[rcx]           ;
        mov     r9, CxR9[rcx]           ;
        mov     r10, CxR10[rcx]         ;
        mov     r11, CxR11[rcx]         ;

        cli                             ; disable interrupts

        mov     rbx, CxRbx[rcx]         ; restore nonvolatile integer registers
        mov     rsi, CxRsi[rcx]         ;
        mov     rdi, CxRdi[rcx]         ;
        mov     rbp, CxRbp[rcx]         ;
        mov     r12, CxR12[rcx]         ;
        mov     r13, CxR13[rcx]         ;
        mov     r14, CxR14[rcx]         ;
        mov     r15, CxR15[rcx]         ;
        mov     rcx, CxRcx[rcx]         ; restore integer register
        iretq                           ; return

;
; Frame consoldation and language specific unwind call back.
; 

Rc20:   sub     rsp, MachineFrameLength + 8; allocate machine frame
        mov     r8, rsp                 ; save machine frame address
        sub     rsp, CONTEXT_FRAME_LENGTH ; allocate context frame
        mov     rsi, rcx                ; set source copy address
        mov     rdi, rsp                ; set destination copy address
        mov     ecx, CONTEXT_FRAME_LENGTH / 8 ; set length of copy
    rep movsq                           ; copy context frame
        mov     rax, CxRsp[rsp]         ; set destination stack address in
        mov     MfRsp[r8], rax          ;   machine frame
        mov     rax, CxRip[rsp]         ; set destination address in machine
        mov     MfRip[r8], rax          ;   frame
        mov     rcx, rdx                ; set address of exception record
        jmp    RcConsolidateFrames      ; consolidate frames - no return

        NESTED_END RtlRestoreContext, _TEXT$00

        subttl  "Frame Consolidation"
;++
;
; The following code is never executed. Its purpose is to provide the dummy
; prologue necessary to consolidate stack frames for unwind call back processing
; at the end of an unwind operation.
;
;--

        NESTED_ENTRY RcFrameConsolidation, _TEXT$00

        .pushframe                      ;
        .allocstack CONTEXT_FRAME_LENGTH ; allocate stack frame
        .savereg rbx, CxRbx             ; save nonvolatile integer registers
        .savereg rbp, CxRbp             ;
        .savereg rsi, CxRsi             ;
        .savereg rdi, CxRdi             ;
        .savereg r12, CxR12             ;
        .savereg r13, CxR13             ;
        .savereg r14, CxR14             ;
        .savereg r15, CxR15             ;
        .savexmm128 xmm6, CxXmm6        ; save nonvolatile floating register
        .savexmm128 xmm7, CxXmm7        ;
        .savexmm128 xmm8, CxXmm8        ;
        .savexmm128 xmm9, CxXmm9        ;
        .savexmm128 xmm10, CxXmm10      ;
        .savexmm128 xmm11, CxXmm11      ;
        .savexmm128 xmm12, CxXmm12      ;
        .savexmm128 xmm13, CxXmm13      ;
        .savexmm128 xmm14, CxXmm14      ;
        .savexmm128 xmm15, CxXmm15      ;

        END_PROLOGUE

;++
;
; VOID
; RcConsolidateFrames (
;     IN PEXCEPTION_RECORD ExceptionRecord
;     )
;
; Routine Description:
;
;   This routine is called at the end of a  unwind operation to logically
;   remove unwound frames from the stack. This is accomplished by building a
;   call frame using a machine frame and a context record and then calling
;   the alternate entry of this function.
;
;   The following code calls the language call back function specified in the
;   exception record. If the function returns, then the destination frame
;   context is restored and control transferred to the address returned by the
;   language call back function. If control does not return, then another
;   exception must be raised.
;
; Arguments:
;
;   ExceptionRecord (rdx) - Supplies a pointer to an exception record.
;
; Implicit Arguments:
;
;   ContextRecord (rsp) - Supplies a pointer to a context record.
;
; Return Value:
;
;   None.
;
;--

        ALTERNATE_ENTRY RcConsolidateFrames

;
; At this point all call frames from the dispatching of the an exception to
; a destination language specific handler have been logically unwound and
; consolidated into a single large frame.
;
; The first parameter in the exception record is the address of a callback
; routine that performs language specific operations. This routine is called
; with the specified exception record as a parameter.
;

        call    qword ptr ErExceptionInformation[rcx] ; call back to handler

;
; Restore context and continue.
;

        mov     rcx, rsp                ; set address of context record
        mov     CxRip[rcx], rax         ; set destination address

        movdqa  xmm0, CxXmm0[rcx]       ; restore floating registers
        movdqa  xmm1, CxXmm1[rcx]       ;
        movdqa  xmm2, CxXmm2[rcx]       ;
        movdqa  xmm3, CxXmm3[rcx]       ;
        movdqa  xmm4, CxXmm4[rcx]       ;
        movdqa  xmm5, CxXmm5[rcx]       ;
        movdqa  xmm6, CxXmm6[rcx]       ;
        movdqa  xmm7, CxXmm7[rcx]       ;
        movdqa  xmm8, CxXmm8[rcx]       ;
        movdqa  xmm9, CxXmm9[rcx]       ;
        movdqa  xmm10, CxXmm10[rcx]     ;
        movdqa  xmm11, CxXmm11[rcx]     ;
        movdqa  xmm12, CxXmm12[rcx]     ;
        movdqa  xmm13, CxXmm13[rcx]     ;
        movdqa  xmm14, CxXmm14[rcx]     ;
        movdqa  xmm15, CxXmm15[rcx]     ;

        ldmxcsr CxMxCsr[rcx]            ; restore floating state

;
; Contruct a machine frame of the stack using information from the context
; record.
;
; N.B. The machine frame overlays the parameter area in the context record.
;

        mov     ax, CxSegSs[rcx]        ; set SS segment
        mov     MfSegSs[rsp], ax        ;
        mov     rax, CxRsp[rcx]         ; set stack address
        mov     MfRsp[rsp], rax         ;
        mov     eax, CxEFlags[rcx]      ; set processor flags
        mov     MfEFlags[rsp], eax      ;
        mov     ax, CxSegCs[rcx]        ; set CS segment
        mov     MfSegCs[rsp], ax        ;
        mov     rax, CxRip[rcx]         ; set return address
        mov     MfRip[rsp], rax         ;

        mov     rax, CxRax[rcx]         ; restore volatile integer registers
        mov     rdx, CxRdx[rcx]         ;
        mov     r8, CxR8[rcx]           ;
        mov     r9, CxR9[rcx]           ;
        mov     r10, CxR10[rcx]         ;
        mov     r11, CxR11[rcx]         ;

        cli                             ; disable interrupts

        mov     rbx, CxRbx[rcx]         ; restore nonvolatile integer registers
        mov     rsi, CxRsi[rcx]         ;
        mov     rdi, CxRdi[rcx]         ;
        mov     rbp, CxRbp[rcx]         ;
        mov     r12, CxR12[rcx]         ;
        mov     r13, CxR13[rcx]         ;
        mov     r14, CxR14[rcx]         ;
        mov     r15, CxR15[rcx]         ;
        mov     rcx, CxRcx[rcx]         ; restore integer register
        iretq                           ; return

        NESTED_END RcFrameConsolidation, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\amd64\misalign.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    miaslign.c

Abstract:

    This module implements __misaligned_access(). 

--*/

#include "ntrtlp.h"


VOID
__misaligned_access (
    IN PVOID Address,
    IN LONG Size,
    IN LONG Alignment,
    IN BOOLEAN Write
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\amd64\chkstk.asm ===
TITLE   "Runtime Stack Checking"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved.
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   chkstk.s
;
; Abstract:
;
;   This module implements runtime stack checking.
;
;--

include ksamd64.inc

        subttl  "Check Stack"
;++
;
; ULONG64
; __chkstk (
;     VOID
;     )
;
; Routine Description:
;
;   This function provides runtime stack checking for local allocations
;   that are more than a page and for storage dynamically allocated with
;   the alloca function. Stack checking consists of probing downward in
;   the stack a page at a time. If the current stack commitment is exceeded,
;   then the system will automatically attempts to expand the stack. If the
;   attempt succeeds, then another page is committed. Otherwise, a stack
;   overflow exception is raised. It is the responsibility of the caller to
;   handle this exception.
;
;   N.B. This routine is called using a non-standard calling sequence since
;        it is typically called from within the prologue. The allocation size
;        argument is in register rax and it must be preserved. Registers r10
;        and r11 are used by this function, but are preserved.
;
;        The typical calling sequence from the prologue is:
;
;        mov    rax, allocation-size    ; set requested stack frame size
;        call   __chkstk                ; check stack page allocation
;        sub    rsp, rax                ; allocate stack frame
;
; Arguments:
;
;   None.
;
; Implicit Arguments:
;
;   Allocation (rax) - Supplies the size of the allocation on the stack.
;
; Return Value:
;
;   The allocation size is returned as the function value.
;
;--

        LEAF_ENTRY __chkstk, _TEXT$00

        ret                             ; return

        LEAF_END __chkstk, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\amd64\exdsptch.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    exdsptch.c

Abstract:

    This module implements the dispatching of exception and the unwinding of
    procedure call frames.

--*/

#include "ntrtlp.h"

//
// Define function address table for kernel mode.
//
// This table is used to initialize the global history table.
//

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance
    );

VOID
KiExceptionDispatch (
    VOID
    );

PVOID RtlpFunctionAddressTable[] = {
    &KiExceptionDispatch,
    &KiDispatchException,
    &RtlDispatchException,
    &RtlpExecuteHandlerForException,
    &__C_specific_handler,
    &RtlUnwindEx,
    NULL
    };

//
// Define opcode and prefix values.
//

#define SIZE64_PREFIX 0x48
#define ADD_IMM8_OP 0x83
#define ADD_IMM32_OP 0x81
#define JMP_IMM8_OP 0xeb
#define JMP_IMM32_OP 0xe9
#define JMP_IND_OP 0xff
#define LEA_OP 0x8d
#define REP_PREFIX 0xf3
#define POP_OP 0x58
#define RET_OP 0xc3
#define RET_OP_2 0xc2

#define IS_REX_PREFIX(x) (((x) & 0xf0) == 0x40)

//
// Define lookup table for providing the number of slots used by each unwind
// code.
// 

UCHAR RtlpUnwindOpSlotTable[] = {
    1,          // UWOP_PUSH_NONVOL
    2,          // UWOP_ALLOC_LARGE (or 3, special cased in lookup code)
    1,          // UWOP_ALLOC_SMALL
    1,          // UWOP_SET_FPREG
    2,          // UWOP_SAVE_NONVOL
    3,          // UWOP_SAVE_NONVOL_FAR
    0,          // UWOP_SPARE_CODE1
    0,          // UWOP_SPARE_CODE2
    2,          // UWOP_SAVE_XMM128
    3,          // UWOP_SAVE_XMM128_FAR
    1           // UWOP_PUSH_MACHFRAME
};

//
// Define forward referenced function prototypes.
//

VOID
RtlpCopyContext (
    OUT PCONTEXT Destination,
    IN PCONTEXT Source
    );

PUNWIND_INFO
RtlpLookupPrimaryUnwindInfo (
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN ULONG64 ImageBase,
    OUT PRUNTIME_FUNCTION *PrimaryEntry
    );

PRUNTIME_FUNCTION
RtlpSameFunction (
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN ULONG64 ImageBase,
    IN ULONG64 ControlPc
    );

BOOLEAN
RtlDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function attempts to dispatch an exception to a frame based
    handler by searching backwards through the stack based call frames.
    The search begins with the frame specified in the context record and
    continues backward until either a handler is found that handles the
    exception, the stack is found to be invalid (i.e., out of limits or
    unaligned), or the end of the call hierarchy is reached.

    As each frame is encounter, the PC where control left the corresponding
    function is determined and used to lookup exception handler information
    in the runtime function table built by the linker. If the respective
    routine has an exception handler, then the handler is called. If the
    handler does not handle the exception, then the prologue of the routine
    is executed backwards to "unwind" the effect of the prologue and then
    the next frame is examined.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    If the exception is handled by one of the frame based handlers, then
    a value of TRUE is returned. Otherwise a value of FALSE is returned.

--*/

{

    BOOLEAN Completion = FALSE;
    CONTEXT ContextRecord1;
    ULONG64 ControlPc;
    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    ULONG64 EstablisherFrame;
    ULONG ExceptionFlags;
    PEXCEPTION_ROUTINE ExceptionRoutine;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 HighLimit;
    PUNWIND_HISTORY_TABLE HistoryTable;
    ULONG64 ImageBase;
    ULONG Index;
    ULONG64 LowLimit;
    ULONG64 NestedFrame;
    BOOLEAN Repeat;
    ULONG ScopeIndex;
    UNWIND_HISTORY_TABLE UnwindTable;

    //
    // Get current stack limits, copy the context record, get the initial
    // PC value, capture the exception flags, and set the nested exception
    // frame pointer.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);
    RtlpCopyContext(&ContextRecord1, ContextRecord);
    ControlPc = (ULONG64)ExceptionRecord->ExceptionAddress;
    ExceptionFlags = ExceptionRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE;
    NestedFrame = 0;

    //
    // Initialize the unwind history table.
    //

    HistoryTable = &UnwindTable;
    HistoryTable->Count = 0;
    HistoryTable->Search = UNWIND_HISTORY_TABLE_NONE;
    HistoryTable->LowAddress = - 1;
    HistoryTable->HighAddress = 0;

    //
    // Start with the frame specified by the context record and search
    // backwards through the call frame hierarchy attempting to find an
    // exception handler that will handle the exception.
    //

    do {

        //
        // Lookup the function table entry using the point at which control
        // left the procedure.
        //

        FunctionEntry = RtlLookupFunctionEntry(ControlPc,
                                               &ImageBase,
                                               HistoryTable);

        //
        // If there is a function table entry for the routine, then virtually
        // unwind to the caller of the current routine to obtain the virtual
        // frame pointer of the establisher and check if there is an exception
        // handler for the frame.
        //

        if (FunctionEntry != NULL) {
            ExceptionRoutine = RtlVirtualUnwind(UNW_FLAG_EHANDLER,
                                                ImageBase,
                                                ControlPc,
                                                FunctionEntry,
                                                &ContextRecord1,
                                                &HandlerData,
                                                &EstablisherFrame,
                                                NULL);

            //
            // If the establisher frame pointer is not within the specified
            // stack limits or the established frame pointer is unaligned,
            // then set the stack invalid flag in the exception record and
            // return exception not handled. Otherwise, check if the current
            // routine has an exception handler.
            //

            if (RtlpIsFrameInBounds(&LowLimit, EstablisherFrame, &HighLimit) == FALSE) {
                ExceptionFlags |= EXCEPTION_STACK_INVALID;
                break;

            } else if (ExceptionRoutine != NULL) {

                //
                // The frame has an exception handler.
                //
                // A linkage routine written in assembler is used to actually
                // call the actual exception handler. This is required by the
                // exception handler that is associated with the linkage
                // routine so it can have access to two sets of dispatcher
                // context when it is called.
                //
                // Call the language specific handler.
                //

                ScopeIndex = 0;
                do {

                    //
                    // Log the exception if exception logging is enabled.
                    //
    
                    ExceptionRecord->ExceptionFlags = ExceptionFlags;

                    if ((NtGlobalFlag & FLG_ENABLE_EXCEPTION_LOGGING) != 0) {
                        Index = RtlpLogExceptionHandler(ExceptionRecord,
                                                        &ContextRecord1,
                                                        ControlPc,
                                                        FunctionEntry,
                                                        sizeof(RUNTIME_FUNCTION));
                    }

                    //
                    // Clear repeat, set the dispatcher context, and call the
                    // exception handler.
                    //

                    Repeat = FALSE;
                    DispatcherContext.ControlPc = ControlPc;
                    DispatcherContext.ImageBase = ImageBase;
                    DispatcherContext.FunctionEntry = FunctionEntry;
                    DispatcherContext.EstablisherFrame = EstablisherFrame;
                    DispatcherContext.ContextRecord = &ContextRecord1;
                    DispatcherContext.LanguageHandler = ExceptionRoutine;
                    DispatcherContext.HandlerData = HandlerData;
                    DispatcherContext.HistoryTable = HistoryTable;
                    DispatcherContext.ScopeIndex = ScopeIndex;
                    Disposition =
                        RtlpExecuteHandlerForException(ExceptionRecord,
                                                       EstablisherFrame,
                                                       ContextRecord,
                                                       &DispatcherContext);

                    if ((NtGlobalFlag & FLG_ENABLE_EXCEPTION_LOGGING) != 0) {
                        RtlpLogLastExceptionDisposition(Index, Disposition);
                    }
    
                    //
                    // Propagate noncontinuable exception flag.
                    //
    
                    ExceptionFlags |=
                        (ExceptionRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE);

                    //
                    // If the current scan is within a nested context and the
                    // frame just examined is the end of the nested region,
                    // then clear the nested context frame and the nested
                    // exception flag in the exception flags.
                    //
    
                    if (NestedFrame == EstablisherFrame) {
                        ExceptionFlags &= (~EXCEPTION_NESTED_CALL);
                        NestedFrame = 0;
                    }
    
                    //
                    // Case on the handler disposition.
                    //
    
                    switch (Disposition) {
    
                        //
                        // The disposition is to continue execution.
                        //
                        // If the exception is not continuable, then raise
                        // the exception STATUS_NONCONTINUABLE_EXCEPTION.
                        // Otherwise return exception handled.
                        //
    
                    case ExceptionContinueExecution :
                        if ((ExceptionFlags & EXCEPTION_NONCONTINUABLE) != 0) {
                            RtlRaiseStatus(STATUS_NONCONTINUABLE_EXCEPTION);
    
                        } else {
                            Completion = TRUE;
                            goto DispatchExit;
                        }
    
                        //
                        // The disposition is to continue the search.
                        //
                        // Get next frame address and continue the search.
                        //
    
                    case ExceptionContinueSearch :
                        break;
    
                        //
                        // The disposition is nested exception.
                        //
                        // Set the nested context frame to the establisher frame
                        // address and set the nested exception flag in the
                        // exception flags.
                        //
    
                    case ExceptionNestedException :
                        ExceptionFlags |= EXCEPTION_NESTED_CALL;
                        if (DispatcherContext.EstablisherFrame > NestedFrame) {
                            NestedFrame = DispatcherContext.EstablisherFrame;
                        }
    
                        break;

                        //
                        // The dispostion is collided unwind.
                        //
                        // A collided unwind occurs when an exception dispatch
                        // encounters a previous call to an unwind handler. In
                        // this case the previous unwound frames must be skipped.
                        //

                    case ExceptionCollidedUnwind:
                        ControlPc = DispatcherContext.ControlPc;
                        ImageBase = DispatcherContext.ImageBase;
                        FunctionEntry = DispatcherContext.FunctionEntry;
                        EstablisherFrame = DispatcherContext.EstablisherFrame;
                        RtlpCopyContext(&ContextRecord1,
                                        DispatcherContext.ContextRecord);

                        ContextRecord1.Rip = ControlPc;
                        ExceptionRoutine = DispatcherContext.LanguageHandler;
                        HandlerData = DispatcherContext.HandlerData;
                        HistoryTable = DispatcherContext.HistoryTable;
                        ScopeIndex = DispatcherContext.ScopeIndex;
                        Repeat = TRUE;
                        break;

                        //
                        // All other disposition values are invalid.
                        //
                        // Raise invalid disposition exception.
                        //
    
                    default :
                        RtlRaiseStatus(STATUS_INVALID_DISPOSITION);
                    }

                } while (Repeat != FALSE);
            }

        } else {

            //
            // If the old control PC is the same as the return address,
            // then no progress is being made and the function tables are
            // most likely malformed.
            //
    
            if (ControlPc == *(PULONG64)(ContextRecord1.Rsp)) {
                break;
            }
    
            //
            // Set the point where control left the current function by
            // obtaining the return address from the top of the stack.
            //

            ContextRecord1.Rip = *(PULONG64)(ContextRecord1.Rsp);
            ContextRecord1.Rsp += 8;
        }

        //
        // Set point at which control left the previous routine.
        //

        ControlPc = ContextRecord1.Rip;
    } while (RtlpIsFrameInBounds(&LowLimit, (ULONG64)ContextRecord1.Rsp, &HighLimit) == TRUE);

    //
    // Set final exception flags and return exception not handled.
    //

    ExceptionRecord->ExceptionFlags = ExceptionFlags;

    //
    // Call vectored continue handlers.
    //

DispatchExit:

    return Completion;
}

VOID
RtlUnwind (
    IN PVOID TargetFrame OPTIONAL,
    IN PVOID TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN PVOID ReturnValue
    )

/*++

Routine Description:

    This function initiates an unwind of procedure call frames. The machine
    state at the time of the call to unwind is captured in a context record
    and the unwinding flag is set in the exception flags of the exception
    record. If the TargetFrame parameter is not specified, then the exit unwind
    flag is also set in the exception flags of the exception record. A backward
    scan through the procedure call frames is then performed to find the target
    of the unwind operation.

    As each frame is encounter, the PC where control left the corresponding
    function is determined and used to lookup exception handler information
    in the runtime function table built by the linker. If the respective
    routine has an exception handler, then the handler is called.

Arguments:

    TargetFrame - Supplies an optional pointer to the call frame that is the
        target of the unwind. If this parameter is not specified, then an exit
        unwind is performed.

    TargetIp - Supplies an optional instruction address that specifies the
        continuation address of the unwind. This address is ignored if the
        target frame parameter is not specified.

    ExceptionRecord - Supplies an optional pointer to an exception record.

    ReturnValue - Supplies a value that is to be placed in the integer
        function return register just before continuing execution.

Return Value:

    None.

--*/

{

    CONTEXT ContextRecord;

    //
    // Call real unwind routine specifying a local context record and history
    // table address as extra arguments.
    //

    RtlUnwindEx(TargetFrame,
                TargetIp,
                ExceptionRecord,
                ReturnValue,
                &ContextRecord,
                NULL);

    return;
}

VOID
RtlUnwindEx (
    IN PVOID TargetFrame OPTIONAL,
    IN PVOID TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN PVOID ReturnValue,
    IN PCONTEXT OriginalContext,
    IN PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL
    )

/*++

Routine Description:

    This function initiates an unwind of procedure call frames. The machine
    state at the time of the call to unwind is captured in a context record
    and the unwinding flag is set in the exception flags of the exception
    record. If the TargetFrame parameter is not specified, then the exit unwind
    flag is also set in the exception flags of the exception record. A backward
    scan through the procedure call frames is then performed to find the target
    of the unwind operation.

    As each frame is encounter, the PC where control left the corresponding
    function is determined and used to lookup exception handler information
    in the runtime function table built by the linker. If the respective
    routine has an exception handler, then the handler is called.

Arguments:

    TargetFrame - Supplies an optional pointer to the call frame that is the
        target of the unwind. If this parameter is not specified, then an exit
        unwind is performed.

    TargetIp - Supplies an optional instruction address that specifies the
        continuation address of the unwind. This address is ignored if the
        target frame parameter is not specified.

    ExceptionRecord - Supplies an optional pointer to an exception record.

    ReturnValue - Supplies a value that is to be placed in the integer
        function return register just before continuing execution.

    OriginalContext - Supplies a pointer to a context record that can be used
        to store context during the unwind operation.

    HistoryTable - Supplies an optional pointer to an unwind history table.

Return Value:

    None.

--*/

{

    ULONG64 ControlPc;
    PCONTEXT CurrentContext;
    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    ULONG64 EstablisherFrame;
    ULONG ExceptionFlags;
    EXCEPTION_RECORD ExceptionRecord1;
    PEXCEPTION_ROUTINE ExceptionRoutine;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 HighLimit;
    ULONG64 ImageBase;
    CONTEXT LocalContext;
    ULONG64 LowLimit;
    PCONTEXT PreviousContext;
    ULONG ScopeIndex;
    PCONTEXT TempContext;

    //
    // Get current stack limits, capture the current context, virtually
    // unwind to the caller of this routine, get the initial PC value, and
    // set the unwind target address.
    //

    CurrentContext = OriginalContext;
    PreviousContext = &LocalContext;
    RtlpGetStackLimits(&LowLimit, &HighLimit);
    RtlCaptureContext(CurrentContext);

    //
    // If a history table is specified, then set to search history table.
    //

    if (ARGUMENT_PRESENT(HistoryTable)) {
        HistoryTable->Search = UNWIND_HISTORY_TABLE_GLOBAL;
    }

    //
    // If an exception record is not specified, then build a local exception
    // record for use in calling exception handlers during the unwind operation.
    //

    if (ARGUMENT_PRESENT(ExceptionRecord) == FALSE) {
        ExceptionRecord = &ExceptionRecord1;
        ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
        ExceptionRecord1.ExceptionRecord = NULL;
        ExceptionRecord1.ExceptionAddress = (PVOID)CurrentContext->Rip;
        ExceptionRecord1.NumberParameters = 0;
    }

    //
    // If the target frame of the unwind is specified, then a normal unwind
    // is being performed. Otherwise, an exit unwind is being performed.
    //

    ExceptionFlags = EXCEPTION_UNWINDING;
    if (ARGUMENT_PRESENT(TargetFrame) == FALSE) {
        ExceptionFlags |= EXCEPTION_EXIT_UNWIND;
    }

    //
    // Scan backward through the call frame hierarchy and call exception
    // handlers until the target frame of the unwind is reached.
    //

    do {

        //
        // Lookup the function table entry using the point at which control
        // left the procedure.
        //

        ControlPc = CurrentContext->Rip;
        FunctionEntry = RtlLookupFunctionEntry(ControlPc,
                                               &ImageBase,
                                               HistoryTable);

        //
        // If there is a function table entry for the routine, then virtually
        // unwind to the caller of the routine to obtain the virtual frame
        // pointer of the establisher, but don't update the context record.
        //

        if (FunctionEntry != NULL) {
            RtlpCopyContext(PreviousContext, CurrentContext);
            ExceptionRoutine = RtlVirtualUnwind(UNW_FLAG_UHANDLER,
                                                ImageBase,
                                                ControlPc,
                                                FunctionEntry,
                                                PreviousContext,
                                                &HandlerData,
                                                &EstablisherFrame,
                                                NULL);

            //
            // If the establisher frame pointer is not within the specified
            // stack limits, the establisher frame pointer is unaligned, or
            // the target frame is below the establisher frame and an exit
            // unwind is not being performed, then raise a bad stack status.
            // Otherwise, check to determine if the current routine has an
            // exception handler.
            //

            if ((RtlpIsFrameInBounds(&LowLimit, EstablisherFrame, &HighLimit) == FALSE) ||
                 ((ARGUMENT_PRESENT(TargetFrame) != FALSE) &&
                  ((ULONG64)TargetFrame < EstablisherFrame))) {

                RtlRaiseStatus(STATUS_BAD_STACK);

            } else if (ExceptionRoutine != NULL) {

                //
                // The frame has a exception handler.
                //
                // A linkage routine written in assembler is used to actually
                // call the actual exception handler. This is required by the
                // exception handler that is associated with the linkage
                // routine so it can have access to two sets of dispatcher
                // context when it is called.
                //
                // Call the language specific handler.
                //

                DispatcherContext.TargetIp = (ULONG64)TargetIp;
                ScopeIndex = 0;
                do {

                    //
                    // If the establisher frame is the target of the unwind
                    // operation, then set the target unwind flag.
                    //

                    if ((ULONG64)TargetFrame == EstablisherFrame) {
                        ExceptionFlags |= EXCEPTION_TARGET_UNWIND;
                    }

                    ExceptionRecord->ExceptionFlags = ExceptionFlags;

                    //
                    // Set the specified return value and target IP in case
                    // the exception handler directly continues execution.
                    //

                    CurrentContext->Rax = (ULONG64)ReturnValue;

                    //
                    // Set the dispatcher context and call the termination
                    // handler.
                    //

                    DispatcherContext.ControlPc = ControlPc;
                    DispatcherContext.ImageBase = ImageBase;
                    DispatcherContext.FunctionEntry = FunctionEntry;
                    DispatcherContext.EstablisherFrame = EstablisherFrame;
                    DispatcherContext.ContextRecord = CurrentContext;
                    DispatcherContext.LanguageHandler = ExceptionRoutine;
                    DispatcherContext.HandlerData = HandlerData;
                    DispatcherContext.HistoryTable = HistoryTable;
                    DispatcherContext.ScopeIndex = ScopeIndex;
                    Disposition =
                        RtlpExecuteHandlerForUnwind(ExceptionRecord,
                                                    EstablisherFrame,
                                                    CurrentContext,
                                                    &DispatcherContext);

                    //
                    // Clear target unwind and collided unwind flags.
                    //

                    ExceptionFlags &=
                        ~(EXCEPTION_COLLIDED_UNWIND | EXCEPTION_TARGET_UNWIND);

                    //
                    // Case on the handler disposition.
                    //

                    switch (Disposition) {

                        //
                        // The disposition is to continue the search.
                        //
                        // If the target frame has not been reached, then
                        // swap context pointers.
                        //

                    case ExceptionContinueSearch :
                        if (EstablisherFrame != (ULONG64)TargetFrame) {
                            TempContext = CurrentContext;
                            CurrentContext = PreviousContext;
                            PreviousContext = TempContext;
                        }

                        break;

                        //
                        // The disposition is collided unwind.
                        //
                        // Copy the context of the previous unwind and
                        // virtually unwind to the caller of the establisher,
                        // then set the target of the current unwind to the
                        // dispatcher context of the previous unwind, and
                        // reexecute the exception handler from the collided
                        // frame with the collided unwind flag set in the
                        // exception record.
                        //

                    case ExceptionCollidedUnwind :
                        ControlPc = DispatcherContext.ControlPc;
                        ImageBase = DispatcherContext.ImageBase;
                        FunctionEntry = DispatcherContext.FunctionEntry;
                        RtlpCopyContext(OriginalContext,
                                        DispatcherContext.ContextRecord);

                        CurrentContext = OriginalContext;
                        PreviousContext = &LocalContext;
                        RtlpCopyContext(PreviousContext, CurrentContext);
                        RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                                         ImageBase,
                                         ControlPc,
                                         FunctionEntry,
                                         PreviousContext,
                                         &HandlerData,
                                         &EstablisherFrame,
                                         NULL);

                        EstablisherFrame = DispatcherContext.EstablisherFrame;
                        ExceptionRoutine = DispatcherContext.LanguageHandler;
                        HandlerData = DispatcherContext.HandlerData;
                        HistoryTable = DispatcherContext.HistoryTable;
                        ScopeIndex = DispatcherContext.ScopeIndex;
                        ExceptionFlags |= EXCEPTION_COLLIDED_UNWIND;
                        break;

                        //
                        // All other disposition values are invalid.
                        //
                        // Raise invalid disposition exception.
                        //

                    default :
                        RtlRaiseStatus(STATUS_INVALID_DISPOSITION);
                    }

                } while ((ExceptionFlags & EXCEPTION_COLLIDED_UNWIND) != 0);

            } else {

                //
                // If the target frame has not been reached, then swap
                // context pointers.
                //

                if (EstablisherFrame != (ULONG64)TargetFrame) {
                    TempContext = CurrentContext;
                    CurrentContext = PreviousContext;
                    PreviousContext = TempContext;
                }
            }

        } else {

            //
            // Set the point where control left the current function by
            // obtaining the return address from the top of the stack.
            //

            CurrentContext->Rip = *(PULONG64)(CurrentContext->Rsp);
            CurrentContext->Rsp += 8;
        }

    } while ((RtlpIsFrameInBounds(&LowLimit, EstablisherFrame, &HighLimit) == TRUE) &&
             (EstablisherFrame != (ULONG64)TargetFrame));

    //
    // If the establisher stack pointer is equal to the target frame pointer,
    // then continue execution. Otherwise, an exit unwind was performed or the
    // target of the unwind did not exist and the debugger and subsystem are
    // given a second chance to handle the unwind.
    //

    if (EstablisherFrame == (ULONG64)TargetFrame) {
        CurrentContext->Rax = (ULONG64)ReturnValue;
        if (ExceptionRecord->ExceptionCode != STATUS_UNWIND_CONSOLIDATE) {
            CurrentContext->Rip = (ULONG64)TargetIp;
        }

        RtlRestoreContext(CurrentContext, ExceptionRecord);

    } else {

        //
        // If the old control PC is the same as the new control PC, then
        // no progress is being made and the function tables are most likely
        // malformed. Otherwise, give the debugger and subsystem a second
        // chance to handle the exception.

        if (ControlPc == CurrentContext->Rip) {
            RtlRaiseStatus(STATUS_BAD_FUNCTION_TABLE);

        } else {
            ZwRaiseException(ExceptionRecord, CurrentContext, FALSE);
        }
    }
}

PRUNTIME_FUNCTION
RtlpUnwindPrologue (
    IN ULONG64 ImageBase,
    IN ULONG64 ControlPc,
    IN ULONG64 FrameBase,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
    )

/*++

Routine Description:

    This function processes unwind codes and reverses the state change
    effects of a prologue. If the specified unwind information contains
    chained unwind information, then that prologue is unwound recursively.
    As the prologue is unwound state changes are recorded in the specified
    context structure and optionally in the specified context pointers
    structures.

Arguments:

    ImageBase - Supplies the base address of the image that contains the
        function being unwound.

    ControlPc - Supplies the address where control left the specified
        function.

    FrameBase - Supplies the base of the stack frame subject function stack
         frame.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

--*/

{

    PM128A FloatingAddress;
    PM128A FloatingRegister;
    ULONG FrameOffset;
    ULONG Index;
    PULONG64 IntegerAddress;
    PULONG64 IntegerRegister;
    BOOLEAN MachineFrame;
    ULONG OpInfo;
    ULONG PrologOffset;
    PULONG64 RegisterAddress;
    PULONG64 ReturnAddress;
    PULONG64 StackAddress;
    PUNWIND_CODE UnwindCode;
    PUNWIND_INFO UnwindInfo;
    ULONG UnwindOp;

    //
    // Process the unwind codes.
    //

    FloatingRegister = &ContextRecord->Xmm0;
    IntegerRegister = &ContextRecord->Rax;
    Index = 0;
    MachineFrame = FALSE;
    PrologOffset = (ULONG)(ControlPc - (FunctionEntry->BeginAddress + ImageBase));
    UnwindInfo = (PUNWIND_INFO)(FunctionEntry->UnwindData + ImageBase);
    while (Index < UnwindInfo->CountOfCodes) {

        //
        // If the prologue offset is greater than the next unwind code offset,
        // then simulate the effect of the unwind code.
        //

        UnwindOp = UnwindInfo->UnwindCode[Index].UnwindOp;
        OpInfo = UnwindInfo->UnwindCode[Index].OpInfo;
        if (PrologOffset >= UnwindInfo->UnwindCode[Index].CodeOffset) {
            switch (UnwindOp) {

                //
                // Push nonvolatile integer register.
                //
                // The operation information is the register number of the
                // register than was pushed.
                //

            case UWOP_PUSH_NONVOL:
                IntegerAddress = (PULONG64)(ContextRecord->Rsp);
                IntegerRegister[OpInfo] = *IntegerAddress;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
                }

                ContextRecord->Rsp += 8;
                break;

                //
                // Allocate a large sized area on the stack.
                //
                // The operation information determines if the size is
                // 16- or 32-bits.
                //

            case UWOP_ALLOC_LARGE:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset;
                if (OpInfo != 0) {
                    Index += 1;
                    FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);

                } else {
                    FrameOffset *= 8;
                }

                ContextRecord->Rsp += FrameOffset;
                break;

                //
                // Allocate a small sized area on the stack.
                //
                // The operation information is the size of the unscaled
                // allocation size (8 is the scale factor) minus 8.
                //

            case UWOP_ALLOC_SMALL:
                ContextRecord->Rsp += (OpInfo * 8) + 8;
                break;

                //
                // Establish the the frame pointer register.
                //
                // The operation information is not used.
                //

            case UWOP_SET_FPREG:
                ContextRecord->Rsp = IntegerRegister[UnwindInfo->FrameRegister];
                ContextRecord->Rsp -= UnwindInfo->FrameOffset * 16;
                break;

                //
                // Save nonvolatile integer register on the stack using a
                // 16-bit displacment.
                //
                // The operation information is the register number.
                //

            case UWOP_SAVE_NONVOL:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 8;
                IntegerAddress = (PULONG64)(FrameBase + FrameOffset);
                IntegerRegister[OpInfo] = *IntegerAddress;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
                }

                break;

                //
                // Save nonvolatile integer register on the stack using a
                // 32-bit displacment.
                //
                // The operation information is the register number.
                //

            case UWOP_SAVE_NONVOL_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                IntegerAddress = (PULONG64)(FrameBase + FrameOffset);
                IntegerRegister[OpInfo] = *IntegerAddress;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
                }

                break;

                //
                // Spare unused codes.
                //

            case UWOP_SPARE_CODE1:
            case UWOP_SPARE_CODE2:

                ASSERT(FALSE);

                break;

                //
                // Save a nonvolatile XMM(128) register on the stack using a
                // 16-bit displacement.
                //
                // The operation information is the register number.
                //

            case UWOP_SAVE_XMM128:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 16;
                FloatingAddress = (PM128A)(FrameBase + FrameOffset);
                FloatingRegister[OpInfo].Low = FloatingAddress->Low;
                FloatingRegister[OpInfo].High = FloatingAddress->High;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
                }

                break;

                //
                // Save a nonvolatile XMM(128) register on the stack using a
                // 32-bit displacement.
                //
                // The operation information is the register number.
                //

            case UWOP_SAVE_XMM128_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                FloatingAddress = (PM128A)(FrameBase + FrameOffset);
                FloatingRegister[OpInfo].Low = FloatingAddress->Low;
                FloatingRegister[OpInfo].High = FloatingAddress->High;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
                }

                break;

                //
                // Push a machine frame on the stack.
                //
                // The operation information determines whether the machine
                // frame contains an error code or not.
                //

            case UWOP_PUSH_MACHFRAME:
                MachineFrame = TRUE;
                ReturnAddress = (PULONG64)(ContextRecord->Rsp);
                StackAddress = (PULONG64)(ContextRecord->Rsp + (3 * 8));
                if (OpInfo != 0) {
                    ReturnAddress += 1;
                    StackAddress +=  1;
                }

                ContextRecord->Rip = *ReturnAddress;
                ContextRecord->Rsp = *StackAddress;
                break;

                //
                // Unused codes.
                //

            default:

                ASSERT(FALSE);

                break;
            }

            Index += 1;

        } else {

            //
            // Skip this unwind operation by advancing the slot index by the
            // number of slots consumed by this operation.
            //

            Index += RtlpUnwindOpSlotTable[UnwindOp];

            //
            // Special case any unwind operations that can consume a variable
            // number of slots.
            // 

            switch (UnwindOp) {

                //
                // A non-zero operation information indicates that an
                // additional slot is consumed.
                //

            case UWOP_ALLOC_LARGE:
                if (OpInfo != 0) {
                    Index += 1;
                }

                break;

                //
                // No other special cases.
                //

            default:
                break;
            }
        }
    }

    //
    // If chained unwind information is specified, then recursively unwind
    // the chained information. Otherwise, determine the return address if
    // a machine frame was not encountered during the scan of the unwind
    // codes.
    //

    if ((UnwindInfo->Flags & UNW_FLAG_CHAININFO) != 0) {
        Index = UnwindInfo->CountOfCodes;
        if ((Index & 1) != 0) {
            Index += 1;
        }

        FunctionEntry = (PRUNTIME_FUNCTION)(&UnwindInfo->UnwindCode[Index]);
        return RtlpUnwindPrologue(ImageBase,
                                  ControlPc,
                                  FrameBase,
                                  FunctionEntry,
                                  ContextRecord,
                                  ContextPointers);

    } else {
        if (MachineFrame == FALSE) {
            ContextRecord->Rip = *(PULONG64)(ContextRecord->Rsp);
            ContextRecord->Rsp += 8;
        }

        return FunctionEntry;
    }
}

PEXCEPTION_ROUTINE
RtlVirtualUnwind (
    IN ULONG HandlerType,
    IN ULONG64 ImageBase,
    IN ULONG64 ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PVOID *HandlerData,
    OUT PULONG64 EstablisherFrame,
    IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
    )

/*++

Routine Description:

    This function virtually unwinds the specified function by executing its
    prologue code backward or its epilogue code forward.

    If a context pointers record is specified, then the address where each
    nonvolatile registers is restored from is recorded in the appropriate
    element of the context pointers record.

Arguments:

    HandlerType - Supplies the handler type expected for the virtual unwind.
        This may be either an exception or an unwind handler.

    ImageBase - Supplies the base address of the image that contains the
        function being unwound.

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    HandlerData - Supplies a pointer to a variable that receives a pointer
        the the language handler data.

    EstablisherFrame - Supplies a pointer to a variable that receives the
        the establisher frame pointer value.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

    If control did not leave the specified function in either the prologue
    or an epilogue and a handler of the proper type is associated with the
    function, then the address of the language specific exception handler
    is returned. Otherwise, NULL is returned.

--*/

{

    ULONG64 BranchBase;
    ULONG64 BranchTarget;
    LONG Displacement;
    ULONG FrameRegister;
    ULONG Index;
    LOGICAL InEpilogue;
    PULONG64 IntegerAddress;
    PULONG64 IntegerRegister;
    PUCHAR NextByte;
    PRUNTIME_FUNCTION PrimaryFunctionEntry;
    ULONG PrologOffset;
    ULONG RegisterNumber;
    PUNWIND_INFO UnwindInfo;

    //
    // If the specified function does not use a frame pointer, then the
    // establisher frame is the contents of the stack pointer. This may
    // not actually be the real establisher frame if control left the
    // function from within the prologue. In this case the establisher
    // frame may be not required since control has not actually entered
    // the function and prologue entries cannot refer to the establisher
    // frame before it has been established, i.e., if it has not been
    // established, then no save unwind codes should be encountered during
    // the unwind operation.
    //
    // If the specified function uses a frame pointer and control left the
    // function outside of the prologue or the unwind information contains
    // a chained information structure, then the establisher frame is the
    // contents of the frame pointer.
    //
    // If the specified function uses a frame pointer and control left the
    // function from within the prologue, then the set frame pointer unwind
    // code must be looked up in the unwind codes to determine if the
    // contents of the stack pointer or the contents of the frame pointer
    // should be used for the establisher frame. This may not actually be
    // the real establisher frame. In this case the establisher frame may
    // not be required since control has not actually entered the function
    // and prologue entries cannot refer to the establisher frame before it
    // has been established, i.e., if it has not been established, then no
    // save unwind codes should be encountered during the unwind operation.
    //
    // N.B. The correctness of these assumptions is based on the ordering of
    //      unwind codes.
    //

    UnwindInfo = (PUNWIND_INFO)(FunctionEntry->UnwindData + ImageBase);
    PrologOffset = (ULONG)(ControlPc - (FunctionEntry->BeginAddress + ImageBase));
    if (UnwindInfo->FrameRegister == 0) {
        *EstablisherFrame = ContextRecord->Rsp;

    } else if ((PrologOffset >= UnwindInfo->SizeOfProlog) ||
               ((UnwindInfo->Flags & UNW_FLAG_CHAININFO) != 0)) {

        *EstablisherFrame = (&ContextRecord->Rax)[UnwindInfo->FrameRegister];
        *EstablisherFrame -= UnwindInfo->FrameOffset * 16;

    } else {
        Index = 0;
        while (Index < UnwindInfo->CountOfCodes) {
            if (UnwindInfo->UnwindCode[Index].UnwindOp == UWOP_SET_FPREG) {
                break;
            }

            Index += 1;
        }

        if (PrologOffset >= UnwindInfo->UnwindCode[Index].CodeOffset) {
            *EstablisherFrame = (&ContextRecord->Rax)[UnwindInfo->FrameRegister];
            *EstablisherFrame -= UnwindInfo->FrameOffset * 16;

        } else {
            *EstablisherFrame = ContextRecord->Rsp;
        }
    }

    //
    // If the point at which control left the specified function is in an
    // epilogue, then emulate the execution of the epilogue forward and
    // return no exception handler.
    //

    IntegerRegister = &ContextRecord->Rax;
    NextByte = (PUCHAR)ControlPc;

    //
    // Check for one of:
    //
    //   add rsp, imm8
    //       or
    //   add rsp, imm32
    //       or
    //   lea rsp, -disp8[fp]
    //       or
    //   lea rsp, -disp32[fp]
    //

    if ((NextByte[0] == SIZE64_PREFIX) &&
        (NextByte[1] == ADD_IMM8_OP) &&
        (NextByte[2] == 0xc4)) {

        //
        // add rsp, imm8.
        //

        NextByte += 4;

    } else if ((NextByte[0] == SIZE64_PREFIX) &&
               (NextByte[1] == ADD_IMM32_OP) &&
               (NextByte[2] == 0xc4)) {

        //
        // add rsp, imm32.
        //

        NextByte += 7;

    } else if (((NextByte[0] & 0xfe) == SIZE64_PREFIX) &&
               (NextByte[1] == LEA_OP)) {

        FrameRegister = ((NextByte[0] & 0x1) << 3) | (NextByte[2] & 0x7);
        if ((FrameRegister != 0) &&
            (FrameRegister == UnwindInfo->FrameRegister)) {

            if ((NextByte[2] & 0xf8) == 0x60) {

                //
                // lea rsp, disp8[fp].
                //

                NextByte += 4;

            } else if ((NextByte[2] &0xf8) == 0xa0) {

                //
                // lea rsp, disp32[fp].
                //

                NextByte += 7;
            }
        }
    }

    //
    // Check for any number of:
    //
    //   pop nonvolatile-integer-register[0..15].
    //

    while (TRUE) {
        if ((NextByte[0] & 0xf8) == POP_OP) {
            NextByte += 1;

        } else if (IS_REX_PREFIX(NextByte[0]) &&
                   ((NextByte[1] & 0xf8) == POP_OP)) {

            NextByte += 2;

        } else {
            break;
        }
    }

    //
    // If the next instruction is a return or an appropriate jump, then
    // control is currently in an epilogue and execution of the epilogue
    // should be emulated. Otherwise, execution is not in an epilogue and
    // the prologue should be unwound.
    //

    InEpilogue = FALSE;
    if ((NextByte[0] == RET_OP) ||
        (NextByte[0] == RET_OP_2) ||
        ((NextByte[0] == REP_PREFIX) && (NextByte[1] == RET_OP))) {

        //
        // A return is an unambiguous indication of an epilogue.
        //

        InEpilogue = TRUE;

    } else if ((NextByte[0] == JMP_IMM8_OP) || (NextByte[0] == JMP_IMM32_OP)) {

        //
        // An unconditional branch to a target that is equal to the start of
        // or outside of this routine is logically a call to another function.
        // 

        BranchTarget = (ULONG64)NextByte - ImageBase;
        if (NextByte[0] == JMP_IMM8_OP) {
            BranchTarget += 2 + (CHAR)NextByte[1];

        } else {
            BranchTarget += 5 + *((LONG UNALIGNED *)&NextByte[1]);
        }

        //
        // Determine whether the branch target refers to code within this
        // function. If not, then it is an epilogue indicator.
        //
        // A branch to the start of self implies a recursive call, so
        // is treated as an epilogue.
        //

        if (BranchTarget < FunctionEntry->BeginAddress ||
            BranchTarget >= FunctionEntry->EndAddress) {

            //
            // The branch target is outside of the region described by
            // this function entry. See whether it is contained within
            // an indirect function entry associated with this same
            // function.
            //
            // If not, then the branch target really is outside of
            // this function.
            //

            PrimaryFunctionEntry = RtlpSameFunction(FunctionEntry,
                                                    ImageBase,
                                                    BranchTarget + ImageBase);

            if ((PrimaryFunctionEntry == NULL) ||
                (BranchTarget == PrimaryFunctionEntry->BeginAddress)) {

                InEpilogue = TRUE;
            }

        } else if ((BranchTarget == FunctionEntry->BeginAddress) &&
                   ((UnwindInfo->Flags & UNW_FLAG_CHAININFO) == 0)) {

            InEpilogue = TRUE;
        }

    } else if ((NextByte[0] == JMP_IND_OP) && (NextByte[1] == 0x25)) {

        //
        // An unconditional jump indirect.
        //
        // This is a jmp outside of the function, probably a tail call
        // to an import function.
        //

        InEpilogue = TRUE;

    } else if (((NextByte[0] & 0xf8) == SIZE64_PREFIX) &&
               (NextByte[1] == 0xff) &&
               (NextByte[2] & 0x38) == 0x20) {

        //
        // This is an indirect jump opcode: 0x48 0xff /4.  The 64-bit
        // flag (REX.W) is always redundant here, so its presence is
        // overloaded to indicate a branch out of the function - a tail
        // call.
        //
        // Such an opcode is an unambiguous epilogue indication.
        //

        InEpilogue = TRUE;
    }

    if (InEpilogue != FALSE) {
        NextByte = (PUCHAR)ControlPc;

        //
        // Emulate one of (if any):
        //
        //   add rsp, imm8
        //       or
        //   add rsp, imm32
        //       or                
        //   lea rsp, disp8[frame-register]
        //       or
        //   lea rsp, disp32[frame-register]
        //

        if ((NextByte[0] & 0xf8) == SIZE64_PREFIX) {
    
            if (NextByte[1] == ADD_IMM8_OP) {
    
                //
                // add rsp, imm8.
                //
    
                ContextRecord->Rsp += (CHAR)NextByte[3];
                NextByte += 4;
    
            } else if (NextByte[1] == ADD_IMM32_OP) {
    
                //
                // add rsp, imm32.
                //
    
                Displacement = NextByte[3] | (NextByte[4] << 8);
                Displacement |= (NextByte[5] << 16) | (NextByte[6] << 24);
                ContextRecord->Rsp += Displacement;
                NextByte += 7;
    
            } else if (NextByte[1] == LEA_OP) {
                if ((NextByte[2] & 0xf8) == 0x60) {
    
                    //
                    // lea rsp, disp8[frame-register].
                    //
    
                    ContextRecord->Rsp = IntegerRegister[FrameRegister];
                    ContextRecord->Rsp += (CHAR)NextByte[3];
                    NextByte += 4;
    
                } else if ((NextByte[2] & 0xf8) == 0xa0) {
    
                    //
                    // lea rsp, disp32[frame-register].
                    //
    
                    Displacement = NextByte[3] | (NextByte[4] << 8);
                    Displacement |= (NextByte[5] << 16) | (NextByte[6] << 24);
                    ContextRecord->Rsp = IntegerRegister[FrameRegister];
                    ContextRecord->Rsp += Displacement;
                    NextByte += 7;
                }
            }
        }

        //
        // Emulate any number of (if any):
        //
        //   pop nonvolatile-integer-register.
        //

        while (TRUE) {
            if ((NextByte[0] & 0xf8) == POP_OP) {

                //
                // pop nonvolatile-integer-register[0..7]
                //

                RegisterNumber = NextByte[0] & 0x7;
                IntegerAddress = (PULONG64)ContextRecord->Rsp;
                IntegerRegister[RegisterNumber] = *IntegerAddress;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[RegisterNumber] = IntegerAddress;
                }

                ContextRecord->Rsp += 8;
                NextByte += 1;

            } else if (IS_REX_PREFIX(NextByte[0]) &&
                       ((NextByte[1] & 0xf8) == POP_OP)) {

                //
                // pop nonvolatile-integer-register[8..15]
                //

                RegisterNumber = ((NextByte[0] & 1) << 3) | (NextByte[1] & 0x7);
                IntegerAddress = (PULONG64)ContextRecord->Rsp;
                IntegerRegister[RegisterNumber] = *IntegerAddress;
                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[RegisterNumber] = IntegerAddress;
                }

                ContextRecord->Rsp += 8;
                NextByte += 2;

            } else {
                break;
            }
        }

        //
        // Emulate return and return null exception handler.
        //
        // Note: this instruction might in fact be a jmp, however
        //       we want to emulate a return regardless.
        //

        ContextRecord->Rip = *(PULONG64)(ContextRecord->Rsp);
        ContextRecord->Rsp += 8;
        return NULL;
    }

    //
    // Control left the specified function outside an epilogue. Unwind the
    // subject function and any chained unwind information.
    //

    FunctionEntry = RtlpUnwindPrologue(ImageBase,
                                       ControlPc,
                                       *EstablisherFrame,
                                       FunctionEntry,
                                       ContextRecord,
                                       ContextPointers);

    //
    // If control left the specified function outside of the prologue and
    // the function has a handler that matches the specified type, then
    // return the address of the language specific exception handler.
    // Otherwise, return NULL.
    //

    UnwindInfo = (PUNWIND_INFO)(FunctionEntry->UnwindData + ImageBase);
    PrologOffset = (ULONG)(ControlPc - (FunctionEntry->BeginAddress + ImageBase));
    if ((PrologOffset >= UnwindInfo->SizeOfProlog) &&
        ((UnwindInfo->Flags & HandlerType) != 0)) {
        Index = UnwindInfo->CountOfCodes;
        if ((Index & 1) != 0) {
            Index += 1;
        }

        *HandlerData = &UnwindInfo->UnwindCode[Index + 2];
        return (PEXCEPTION_ROUTINE)(*((PULONG)&UnwindInfo->UnwindCode[Index]) + ImageBase);

    } else {
        return NULL;
    }
}

DECLSPEC_NOINLINE
VOID
RtlpGetStackLimits (
    OUT PULONG64 LowLimit,
    OUT PULONG64 HighLimit
    )

/*++

Routine Description:

    This function returns the current stack limits.

Arguments:

    LowLimit - Supplies a pointer to a variable that is to receive
        the low limit of the stack.

    HighLimit - Supplies a pointer to a variable that is to receive
        the high limit of the stack.

Return Value:

     None.

--*/

{
    BOOLEAN WithinLimits;
    KERNEL_STACK_LIMITS Type;

    WithinLimits = KeQueryCurrentStackInformation(&Type, LowLimit, HighLimit);
    if (WithinLimits == FALSE) {
        KeBugCheckEx(DRIVER_VERIFIER_DETECTED_VIOLATION,
                     0x91,
                     (ULONG64)KeGetCurrentIrql(),
                     (ULONG64)KeGetCurrentThread(),
                     0);
    }

    return;
}

BOOLEAN
RtlpIsFrameInBounds (
    IN OUT PULONG64 LowLimit,
    IN ULONG64 StackFrame,
    IN OUT PULONG64 HighLimit
    )

/*++

Routine Description:

    This function checks whether the specified frame address is properly
    aligned and within the specified limits. In kernel mode an additional
    check is made if the frame is not within the specified limits since
    the kernel stack can be expanded. For this case the next entry in the
    expansion list, if any, is checked. If the frame is within the next
    expansion extent, then the extent values are stored in the low and
    high limit before returning to the caller.

    N.B. It is assumed that the supplied high limit is the stack base.

Arguments:

    LowLimit - Supplies a pointer to a variable that contains the current
        lower stack limit.

    Frame - Supplies the frame address to check.

    HighLimit - Supplies a pointer to a variable that contains the current
        high stack limit.

Return Value:

    If the specified stack frame is within limits, then a value of TRUE is
    returned as the function value. Otherwise, a value of FALSE is returned.

--*/

{
    PKERNEL_STACK_CONTROL Control;
    ULONG64 LocalHigh;
    ULONG64 LocalLow;

    if ((StackFrame & 0x7) != 0) {
        return FALSE;
    }

    if ((StackFrame < *LowLimit) ||
        (StackFrame >= *HighLimit)) {

        if (KeIsExecutingLegacyDpc() == FALSE) {
            Control = (PKERNEL_STACK_CONTROL)(*HighLimit - sizeof(KERNEL_STACK_CONTROL));
            if (Control->Previous.StackBase != 0) {
                LocalLow = Control->Previous.StackLimit;
                LocalHigh = Control->Previous.StackBase;
                if ((StackFrame >= LocalLow) &&
                    (StackFrame < LocalHigh)) {

                    *LowLimit = LocalLow;
                    *HighLimit = LocalHigh;
                    return TRUE;
                }
            }
        }

        return FALSE;

    } else {
        return TRUE;
    }
}


FORCEINLINE
PRUNTIME_FUNCTION
RtlpConvertFunctionEntry (
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN ULONG64 ImageBase
    )

/*++

Routine Description:

    This function returns the master function table entry for a specified
    function table entry.

Arguments:

    FunctionEntry - Supplies a pointer to a function table entry.

    ImageBase - Supplies the image base address.

Return Value:

    If the function entry address is NULL or the function table entry does
    not specify indirection, then the original function table entry is
    returned. Otherwise, the indirected function table entry is returned.

--*/

{

    //
    // If the specified function entry is not NULL and specifies indirection,
    // then compute the address of the master function table entry.
    //

    if ((FunctionEntry != NULL) &&
        ((FunctionEntry->UnwindData & RUNTIME_FUNCTION_INDIRECT) != 0)) {

        FunctionEntry = (PRUNTIME_FUNCTION)(FunctionEntry->UnwindData + ImageBase - 1);
    }

    return FunctionEntry;
}

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONG64 ControlPc,
    OUT PULONG64 ImageBase,
    IN OUT PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL
    )

/*++

Routine Description:

    This function searches the currently active function tables for an entry
    that corresponds to the specified control PC.

Arguments:

    ControlPc - Supplies the address of an instruction within the specified
        function.

    ImageBase - Supplies the address of a variable that receives the image base
        if a function table entry contains the specified control PC.

    HistoryTable - Supplies an optional pointer to an unwind history table.

Return Value:

    If there is no entry in the function table for the specified PC, then
    NULL is returned.  Otherwise, the address of the function table entry
    that corresponds to the specified PC is returned.

--*/

{

    ULONG64 BaseAddress;
    ULONG64 BeginAddress;
    ULONG64 EndAddress;
    PRUNTIME_FUNCTION FunctionEntry;
    PRUNTIME_FUNCTION FunctionTable;
    LONG High;
    ULONG Index;
    LONG Low;
    LONG Middle;
    ULONG RelativePc;
    ULONG SizeOfTable;

    //
    // Attempt to find an image that contains the specified control PC. If
    // an image is found, then search its function table for a function table
    // entry that contains the specified control PC. If an image is not found
    // then search the dynamic function table for an image that contains the
    // specified control PC.
    //
    // If a history table is supplied and search is specfied, then the current
    // operation that is being performed is the unwind phase of an exception
    // dispatch followed by a unwind. 
    //

    if ((ARGUMENT_PRESENT(HistoryTable)) &&
        (HistoryTable->Search != UNWIND_HISTORY_TABLE_NONE)) {

        //
        // Search the global unwind history table if there is a chance of a
        // match.
        //
        // N.B. The global unwind history table never contains indirect entries.
        //

        if (HistoryTable->Search == UNWIND_HISTORY_TABLE_GLOBAL) {
            if ((ControlPc >= RtlpUnwindHistoryTable.LowAddress) &&
                (ControlPc < RtlpUnwindHistoryTable.HighAddress)) {

                for (Index = 0; Index < RtlpUnwindHistoryTable.Count; Index += 1) {
                    BaseAddress = RtlpUnwindHistoryTable.Entry[Index].ImageBase;
                    FunctionEntry = RtlpUnwindHistoryTable.Entry[Index].FunctionEntry;
                    BeginAddress = FunctionEntry->BeginAddress + BaseAddress;
                    EndAddress = FunctionEntry->EndAddress + BaseAddress;
                    if ((ControlPc >= BeginAddress) && (ControlPc < EndAddress)) {
                        *ImageBase = BaseAddress;
                        return FunctionEntry;
                    }
                }
            }

            HistoryTable->Search = UNWIND_HISTORY_TABLE_LOCAL;
        }

        //
        // Search the dynamic unwind history table if there is a chance of a
        // match.
        //
        // N.B. The dynamic unwind history table can contain indirect entries.
        //

        if ((ControlPc >= HistoryTable->LowAddress) &&
            (ControlPc < HistoryTable->HighAddress)) {
    
            for (Index = 0; Index < HistoryTable->Count; Index += 1) {
                BaseAddress = HistoryTable->Entry[Index].ImageBase;
                FunctionEntry = HistoryTable->Entry[Index].FunctionEntry;
                BeginAddress = FunctionEntry->BeginAddress + BaseAddress;
                EndAddress = FunctionEntry->EndAddress + BaseAddress;
                if ((ControlPc >= BeginAddress) && (ControlPc < EndAddress)) {
                    *ImageBase = BaseAddress;
                    return RtlpConvertFunctionEntry(FunctionEntry, *ImageBase);
                }
            }
        }
    }

    //
    // There was not a match in either of the unwind history tables so attempt
    // to find a matching entry in the loaded module list.
    //

    FunctionTable = RtlLookupFunctionTable((PVOID)ControlPc,
                                            (PVOID *)ImageBase,
                                            &SizeOfTable);

    //
    // If a function table is located, then search for a function table
    // entry that contains the specified control PC.
    //

    if (FunctionTable != NULL) {
        Low = 0;
        High = (SizeOfTable / sizeof(RUNTIME_FUNCTION)) - 1;
        RelativePc = (ULONG)(ControlPc - *ImageBase);
        while (High >= Low) {

            //
            // Compute next probe index and test entry. If the specified
            // control PC is greater than of equal to the beginning address
            // and less than the ending address of the function table entry,
            // then return the address of the function table entry. Otherwise,
            // continue the search.
            //

            Middle = (Low + High) >> 1;
            FunctionEntry = &FunctionTable[Middle];

            if (RelativePc < FunctionEntry->BeginAddress) {
                High = Middle - 1;

            } else if (RelativePc >= FunctionEntry->EndAddress) {
                Low = Middle + 1;

            } else {
                break;
            }
        }

        if (High < Low) {
            FunctionEntry = NULL;
        }

    } else {

        //
        // There was not a match in the loaded module list so attempt to find
        // a matching entry in the dynamic function table list.
        //
    
        FunctionEntry = NULL;
    }

    //
    // If a function table entry was located, search is not specified, and
    // the specfied history table is not full, then attempt to make an entry
    // in the history table.
    //

    if (FunctionEntry != NULL) {
        if (ARGUMENT_PRESENT(HistoryTable) &&
            (HistoryTable->Search == UNWIND_HISTORY_TABLE_NONE) &&
            (HistoryTable->Count < UNWIND_HISTORY_TABLE_SIZE)) {
    
            Index = HistoryTable->Count;
            HistoryTable->Count += 1;
            HistoryTable->Entry[Index].ImageBase = *ImageBase;
            HistoryTable->Entry[Index].FunctionEntry = FunctionEntry;
            BeginAddress = FunctionEntry->BeginAddress + *ImageBase;
            EndAddress = FunctionEntry->EndAddress + *ImageBase;
            if (BeginAddress < HistoryTable->LowAddress) {
                HistoryTable->LowAddress = BeginAddress;
    
            }
    
            if (EndAddress > HistoryTable->HighAddress) {
                HistoryTable->HighAddress = EndAddress;
            }
        }
    }

    return RtlpConvertFunctionEntry(FunctionEntry, *ImageBase);
}

VOID
RtlpCopyContext (
    OUT PCONTEXT Destination,
    IN PCONTEXT Source
    )

/*++

Routine Description:

    This function copies the nonvolatile context required for exception
    dispatch and unwind from the specified source context record to the
    specified destination context record.

Arguments:

    Destination - Supplies a pointer to the destination context record.

    Source - Supplies a pointer to the source context record.

Return Value:

    None.

--*/

{

    //
    // Copy nonvolatile context required for exception dispatch and unwind.
    //

    Destination->Rip = Source->Rip;
    Destination->Rbx = Source->Rbx;
    Destination->Rsp = Source->Rsp;
    Destination->Rbp = Source->Rbp;
    Destination->Rsi = Source->Rsi;
    Destination->Rdi = Source->Rdi;
    Destination->R12 = Source->R12;
    Destination->R13 = Source->R13;
    Destination->R14 = Source->R14;
    Destination->R15 = Source->R15;
    Destination->Xmm6 = Source->Xmm6;
    Destination->Xmm7 = Source->Xmm7;
    Destination->Xmm8 = Source->Xmm8;
    Destination->Xmm9 = Source->Xmm9;
    Destination->Xmm10 = Source->Xmm10;
    Destination->Xmm11 = Source->Xmm11;
    Destination->Xmm12 = Source->Xmm12;
    Destination->Xmm13 = Source->Xmm13;
    Destination->Xmm14 = Source->Xmm14;
    Destination->Xmm15 = Source->Xmm15;
    Destination->SegCs = Source->SegCs;
    Destination->SegSs = Source->SegSs;
    Destination->MxCsr = Source->MxCsr;
    Destination->EFlags = Source->EFlags;

    return;
}

PUNWIND_INFO
RtlpLookupPrimaryUnwindInfo (
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN ULONG64 ImageBase,
    OUT PRUNTIME_FUNCTION *PrimaryEntry
    )

/*++

Routine Description:

    This function determines whether the supplied function entry is a primary
    function entry or a chained function entry. If it is a chained function
    entry, the unwind information associated with the primary function entry
    is returned.

Arguments:

    FunctionEntry - Supplies a pointer to the function entry for which the
        associated primary function entry will be located.

    ImageBase - Supplies the base address of the image containing the
        supplied function entry.

    PrimaryEntry - Supplies the address of a variable that receives a pointer
        to the primary function entry.

Return Value:

    A pointer to the unwind information for the primary function entry is
    returned as the function value.

--*/

{

    ULONG Index;
    PUNWIND_INFO UnwindInfo;

    //
    // Locate the unwind information and determine whether it is chained.
    // If the unwind information is chained, then locate the parent function
    // entry and loop again.
    //

    do {
        UnwindInfo = (PUNWIND_INFO)(FunctionEntry->UnwindData + ImageBase);
        if ((UnwindInfo->Flags & UNW_FLAG_CHAININFO) == 0) {
            break;
        }

        Index = UnwindInfo->CountOfCodes;
        if ((Index & 1) != 0) {
            Index += 1;
        }

        FunctionEntry = (PRUNTIME_FUNCTION)&UnwindInfo->UnwindCode[Index];
    } while (TRUE);

    *PrimaryEntry = FunctionEntry;
    return UnwindInfo;
}

PRUNTIME_FUNCTION
RtlpSameFunction (
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN ULONG64 ImageBase,
    IN ULONG64 ControlPc
    )

/*++

Routine Description:

    This function determines whether the address supplied by control Pc lies
    anywhere within the function associated with FunctionEntry.

Arguments:

    FunctionEntry - Supplies a pointer to a function entry (primary or chained)
        associated with the function.

    ImageBase - Supplies the base address of the image containing the supplied
        function entry.

    ControlPc - Supplies the address that will be tested for inclusion within
        the function associated with FunctionEntry.

Return Value:

    If the address of the unwind information for the specified function is
    equal to the address of the unwind information for the control PC, then
    a pointer to a function table entry that describes the primary function
    table entry is returned as the function value. Otherwise, NULL is returned.

--*/

{

    PRUNTIME_FUNCTION PrimaryFunctionEntry;
    PRUNTIME_FUNCTION TargetFunctionEntry;
    ULONG64 TargetImageBase;
    PUNWIND_INFO UnwindInfo1;
    PUNWIND_INFO UnwindInfo2;

    //
    // Lookup the primary function entry associated with the specified
    // function entry.
    // 

    UnwindInfo1 = RtlpLookupPrimaryUnwindInfo(FunctionEntry,
                                              ImageBase,
                                              &PrimaryFunctionEntry);

    //
    // Determine the function entry containing the control Pc and similarly
    // resolve its primary function entry.  If no function entry can be
    // found then the control pc resides in a different function.
    //

    TargetFunctionEntry = RtlLookupFunctionEntry(ControlPc,
                                                 &TargetImageBase,
                                                 NULL);

    if (TargetFunctionEntry == NULL) {
        return NULL;
    }

    //
    // Lookup the primary function entry associated with the target function
    // entry.
    //

    UnwindInfo2 = RtlpLookupPrimaryUnwindInfo(TargetFunctionEntry,
                                              TargetImageBase,
                                              &PrimaryFunctionEntry);

    //
    // If the address of the two sets of unwind information are equal, then
    // return the address of the primary function entry. Otherwise, return
    // NULL.
    //

    if (UnwindInfo1 == UnwindInfo2) {
        return PrimaryFunctionEntry;

    } else {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\amd64\ntrtlamd64.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    ntrtlamd64.h

Abstract:

    AMD64 specific parts of ntrtlp.h.

--*/

#ifndef _NTRTLAMD64_
#define _NTRTLAMD64_

//
// Define exception routine function prototypes.
//

EXCEPTION_DISPOSITION
RtlpExecuteHandlerForException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN ULONG64 EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PDISPATCHER_CONTEXT DispatcherContext
    );

EXCEPTION_DISPOSITION
RtlpExecuteHandlerForUnwind (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN ULONG_PTR EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PDISPATCHER_CONTEXT DispatcherContext
    );

BOOLEAN
RtlpIsFrameInBounds (
    IN OUT PULONG64 LowLimit,
    IN ULONG64 StackFrame,
    IN OUT PULONG64 HighLimit
    );

#endif // _NTRTLAMD64_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\amd64\debugstb.asm ===
title  "Debug Support Functions"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   debugstb.asm
;
; Abstract:
;
;   This module implements functions to support debugging NT.
;
;--

include ksamd64.inc

        subttl  "Break Point"
;++
;
; VOID
; DbgBreakPoint (
;     VOID
;     )
;
; Routine Description:
;
;   This function executes a breakpoint instruction. Useful for entering
;   the debugger under program control. This breakpoint will always go to
;   the kernel debugger if one is installed, otherwise it will go to the
;   debug subsystem.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY DbgBreakPoint, _TEXT$00

        int     3                       ; break into debugger
        ret                             ; return

        LEAF_END DbgBreakPoint, _TEXT$00

        subttl  "User Break Point"
;++
;
; VOID
; DbgUserBreakPoint()
;
; Routine Description:
;
;   This function executes a breakpoint instruction. Useful for entering
;   the debug subsystem under program control. The kernel debugger will
;   ignore this breakpoint since it will not find the instruction address
;   its breakpoint table.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY DbgUserBreakPoint, _TEXT$00

        int     3                       ; break into debugger
        ret                             ; return

        LEAF_END DbgUserBreakPoint, _TEXT$00

        subttl  "Break Point With Status"
;++
;
; VOID
; DbgBreakPointWithStatus(
;     IN ULONG Status
;     )
;
; Routine Description:
;
;   This function executes a breakpoint instruction. Useful for entering
;   the debugger under program control. This breakpoint will always go to
;   the kernel debugger if one is installed, otherwise it will go to the
;   debug subsystem. This function is identical to DbgBreakPoint, except
;   that it takes an argument which the debugger can see.
;
;   Note: The debugger checks the address of the breakpoint instruction
;   against the address RtlpBreakWithStatusInstruction.  If it matches,
;   we have a breakpoint with status. A breakpoint is normally issued
;   with the break_debug_stop macro which generates two instructions.
;   We can't use the macro here because of the "label on the breakpoint"
;   requirement.
;
; Arguments:
;
;   Status (ecx) - Supplies the break point status code.
;
; Return Value:
;
;    None.
;
;--

        altentry RtlpBreakWithStatusInstruction

        LEAF_ENTRY DbgBreakPointWithStatus, _TEXT$00

        ALTERNATE_ENTRY RtlpBreakWithStatusInstruction

        int     3                       ; break into debugger
        ret                             ; return

        LEAF_END DbgBreakPointWithStatus, _TEXT$00

        subttl  "Debug Print"
;++
;
; NTSTATUS
; DebugPrint(
;     IN PSTRING Output,
;     IN ULONG ComponentId,
;     IN ULONG Level
;     )
;
; Routine Description:
;
;   This function executes a debug print breakpoint.
;
; Arguments:
;
;   Output (rcx) - Supplies a pointer to the output string descriptor.
;
;   ComponentId (edx) - Supplies the Id of the calling component.
;
;   Level (r8d) - Supplies the output importance level.
;
; Return Value:
;
;    STATUS_SUCCESS is returned if the debug print was completed successfully.
;
;    STATUS_BREAKPOINT is returned if user typed a Control-C during print.
;
;    STATUS_DEVICE_NOT_CONNECTED is returned if kernel debugger not present.
;
;--

        LEAF_ENTRY DebugPrint, _TEXT$00

        mov     r9d, r8d                ; set importance level
        mov     r8d, edx                ; set component id
        mov     dx, StrLength[rcx]      ; set length of output string
        mov     rcx, StrBuffer[rcx]     ; set address of output string
        mov     eax, BREAKPOINT_PRINT   ; set debug service type
        int     2dh                     ; call debug service
        int     3                       ; required - do not remove
        ret                             ; return

        LEAF_END DebugPrint, _TEXT$00

        subttl  "Debug Prompt"
;++
;
; ULONG
; DebugPrompt(
;     IN PSTRING Output,
;     IN PSTRING Input
;     )
;
; Routine Description:
;
;   This function executes a debug prompt breakpoint.
;
; Arguments:
;
;   Output (rcx) - Supplies a pointer to the output string descriptor.
;
;   Input (rdx) - Supplies a pointer to the input string descriptor.
;
; Return Value:
;
;   The length of the input string is returned as the function value.
;
;--

        LEAF_ENTRY DebugPrompt, _TEXT$00

        mov     r9w, StrMaximumLength[rdx] ; set maximum length of input string
        mov     r8, StrBuffer[rdx]      ; set address of input string
        mov     dx, StrLength[rcx]      ; set length of output string
        mov     rcx, StrBuffer[rcx]     ; set address of output string
        mov     eax, BREAKPOINT_PROMPT  ; set debug service type
        int     2dh                     ; call debug service
        int     3                       ; required - do not remove
        ret                             ; return

        LEAF_END DebugPrompt, _TEXT$00

;++
;
; VOID
; DebugService2(
;     IN PVOID Param1,
;     IN PVOID Param2,
;     IN ULONG Service
;     )
;
; Routine Description:
;
;   This function calls the kernel debugger to execute a command string.
;
; Arguments:
;
;   Param1 (rcx) - Supplies the first parameter to the KD fault handler
;
;   Param2 (rdx) - Supplies the second parameter to the KD fault handler
;
;   Service (r8d) - Supplies a pointer to the command string.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY DebugService2, _TEXT$00

        mov     eax, r8d                ; set debug service type
        int     2dh                     ; call debug service
        int     3                       ; required - do not remove
        ret                             ; return

        LEAF_END DebugService2, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\amd64\movemem.asm ===
title  "Memory functions"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   movemem.asm
;
; Abstract:
;
;   This module implements functions to fill, copy , and compare blocks of
;   memory.
;
;--

include ksamd64.inc

        extern  memset:proc

        subttl "Compare Memory"
;++
;
; SIZE_T
; RtlCompareMemory (
;     IN PVOID Source1,
;     IN PVOID Source2,
;     IN SIZE_T Length
;     )
;
; Routine Description:
;
;   This function compares two unaligned blocks of memory and returns the
;   number of bytes that compared equal.
;
; Arguments:
;
;   Source1 (rcx) - Supplies a pointer to the first block of memory to
;       compare.
;
;   Source2 (rdx) - Supplies a pointer to the second block of memory to
;       compare.
;
;   Length (r8) - Supplies the Length, in bytes, of the memory to be
;       compared.
;
; Return Value:
;
;   The number of bytes that compared equal is returned as the function
;   value. If all bytes compared equal, then the length of the original
;   block of memory is returned.
;
;--

CmFrame struct
        SavedRsi dq ?                   ; saved nonvolatile registers
        SavedRdi dq ?                   ;
CmFrame ends

        NESTED_ENTRY RtlCompareMemory, _TEXT$00

        alloc_stack (sizeof CmFrame)    ; allocate stack frame
        save_reg rsi, CmFrame.SavedRsi  ; save nonvolatile registers
        save_reg rdi, CmFrame.SavedRdi  ; 

        END_PROLOGUE

        mov     rsi, rcx                ; set address of first string
        mov     rdi, rdx                ; set address of second string
        xor     edx, ecx                ; check if compatible alignment
        and     edx, 07h                ;
        jnz     short RlCM50            ; if nz, incompatible alignment
        cmp     r8, 8                   ; check if length to align
        jb      short RlCM50            ; if b, insufficient alignment length

;
; Buffer alignment is compatible and there are enough bytes for alignment.
;

        mov     r9, rdi                 ; copy destination address
        neg     ecx                     ; compute alignment length
        and     ecx, 07h                ; 
        jz      short RlCM10            ; if z, buffers already aligned
        sub     r8, rcx                 ; reduce count by align length
   repe cmpsb                           ; compare bytes to alignment
        jnz     short RlCM30            ; if nz, not all bytes matched
RlCM10: mov     rcx, r8                 ;
        and     rcx, -8                 ; check if any quarwords to compare
        jz      short RlCM20            ; if z, no quadwords to compare
        sub     r8, rcx                 ; reduce length by compare count
        shr     rcx, 3                  ; compute number of quadwords
   repe cmpsq                           ; compare quadwords
        jz      short RlCM20            ; if z, all quadwords compared
        inc     rcx                     ; increment remaining count
        sub     rsi, 8                  ; back up source address
        sub     rdi, 8                  ; back up destination address
        shl     rcx, 3                  ; compute uncompared bytes
RlCM20: add     r8, rcx                 ; compute residual bytes to compare
        jz      short RlCM40            ; if z, all bytes compared equal
        mov     rcx, r8                 ; set remaining bytes to compare
   repe cmpsb                           ; compare bytes
        jz      short RlCM40            ; if z, all byte compared equal
RlCM30: dec     rdi                     ; back up destination address
RlCM40: sub     rdi, r9                 ; compute number of bytes matched
        mov     rax, rdi                ;
        mov     rsi, CmFrame.SavedRsi[rsp] ; restore nonvolatile registers
        mov     rdi, CmFrame.SavedRdi[rsp] ;
        add     rsp, (sizeof CmFrame)   ; deallocate stack frame
        ret                             ; return

;
; Buffer alignment is incompatible or there is less than 8 bytes to compare.
;

RlCM50: test    r8, r8                  ; test if any bytes to compare
        jz      short RlCM60            ; if z, no bytes to compare
        mov     rcx, r8                 ; set number of bytes to compare
   repe cmpsb                           ; compare bytes
        jz      short RlCM60            ; if z, all bytes compared equal
        inc     rcx                     ; increment remaining count
        sub     r8, rcx                 ; compute number of bytes matched
RlCM60: mov     rax, r8                 ;
        mov     rsi, CmFrame.SavedRsi[rsp] ; restore nonvolatile registers
        mov     rdi, CmFrame.SavedRdi[rsp] ;
        add     rsp, (sizeof CmFrame)   ; deallocate stack frame
        ret                             ; return

        NESTED_END RtlCompareMemory, _TEXT$00

        subttl  "Compare Memory 32-bits"
;++
;
; SIZE_T
; RtlCompareMemoryUlong (
;     IN PVOID Source,
;     IN SIZE_T Length,
;     IN ULONG Pattern
;     )
;
; Routine Description:
;
;   This function compares a block of dword aligned memory with a specified
;   pattern 32-bits at a time.
;
;   N.B. The low two bits of the length are assumed to be zero and are
;        ignored.
;
; Arguments:
;
;   Source (rcx) - Supplies a pointer to the block of memory to compare.
;
;   Length (rdx) - Supplies the length, in bytes, of the memory to compare.       compare.
;
;   Pattern (r8d) - Supplies the pattern to be compared against.
;
; Return Value:
;
;   The number of bytes that compared equal is returned as the function
;   value. If all bytes compared equal, then the length of the original
;   block of memory is returned.
;
;--

        NESTED_ENTRY RtlCompareMemoryUlong, _TEXT$00

        alloc_stack 8                   ; allocate stack frame
        save_reg rdi, 0                 ; save nonvolatile register

        END_PROLOGUE

        mov     rdi, rcx                ; set destination address
        shr     rdx, 2                  ; compute number of dwords
        jz      short RlCU10            ; if z, no dwords to compare
        mov     rcx, rdx                ; set length of compare in dwords
        mov     eax, r8d                ; set comparison pattern
   repe scasd                           ; compare memory with pattern
        jz      short RlCU10            ; if z, all dwords compared
        inc     rcx                     ; increment remaining count
        sub     rdx, rcx                ; compute number of bytes matched
RlCU10: lea     rax, [rdx*4]            ; compute successful compare in bytes
        mov     rdi, [rsp]              ; restore nonvolatile register
        add     rsp, 8                  ; deallocate stack frame
        ret                             ; return

        NESTED_END RtlCompareMemoryUlong, _TEXT$00

        subttl  "Copy Memory NonTemporal"
;++
;
; VOID
; RtlCopyMemoryNonTemporal (
;     OUT VOID UNALIGNED *Destination,
;     IN CONST VOID UNALIGNED * Sources,
;     IN SIZE_T Length
;     )
;
; Routine Description:
;
;   This function copies nonoverlapping from one buffer to another using
;   nontemporal moves that do not pollute the cache.
;
; Arguments:
;
;   Destination (rcx) - Supplies a pointer to the destination buffer.
;
;   Sources (rdx) - Supplies a pointer to the source buffer.
;
;   Length (r8) - Supplies the length, in bytes, of the copy operation.
;
; Return Value:
;
;   None.
;
;--

CACHE_BLOCK equ 01000h                  ; nontemporal move block size

        LEAF_ENTRY RtlCopyMemoryNonTemporal, _TEXT$00

        sub     rdx, rcx                ; compute relative address of source
        cmp     r8, 64 + 8              ; check if 64 + 8 bytes to move
        jb      RlNT50                  ; if b, skip non-temporal move

;
; Align the destination to a 8-byte boundary.
;

        test    cl, 07h                 ; check if destination 8-byte aligned
        jz      RlNT30                  ; if z,  already aligned
        mov     rax, [rdx + rcx]        ; read alignment bytes
        add     r8,  rcx                ; adjust remaining bytes
        movnti  [rcx], rax              ; copy alignment bytes (sfence later) 
        add     rcx, 8                  ; compute aligned destination address
        and     rcx, -8                 ; 
        sub     r8, rcx                 ; adjust remaining bytes 
        jmp     RlNT30                  ; jump to move 64-byte blocks

;
; Copy 64-byte blocks.
;

        align   16

RlNT10: prefetchnta [rdx + rax]         ; prefetch 64 bytes
        add     rax, 64                 ; advance destination address
        dec     r9                      ; decrement count
        jnz     RlNT10                  ; if nz, more to prefetch
        sub     rax, rcx                ; reset move count
RlNT20: mov     r9, [rdx + rcx]         ; copy 64-byte blocks
        mov     r10, [rdx + rcx + 8]    ;
        movnti  [rcx], r9               ; 
        movnti  [rcx + 8], r10          ; 
        mov     r9, [rdx + rcx + 16]    ;
        mov     r10, [rdx + rcx + 24]   ;
        movnti  [rcx + 16], r9          ; 
        movnti  [rcx + 24], r10         ; 
        add     rcx, 64                 ; advance destination address
        mov     r9, [rdx + rcx - 32]    ; 
        mov     r10, [rdx + rcx - 24]   ; 
        movnti  [rcx - 32], r9          ; 
        movnti  [rcx - 24], r10         ; 
        mov     r9, [rdx + rcx - 16]    ;
        mov     r10, [rdx + rcx - 8]    ; 
        movnti  [rcx - 16], r9          ; 
        movnti  [rcx - 8], r10          ; 
        sub     rax, 64                 ; subtract number of bytes moved
        jnz     short RlNT20            ; if nz, more 64-byte blocks to move
RlNT30: cmp     r8, 64                  ; check if more than 64 bytes to move
        jb      RlNT40                  ; if b, no more 64 bytes
        mov     rax, rcx                ; save destination address
        mov     r9, CACHE_BLOCK/64      ; number of 64-byte blocks to move
        sub     r8, CACHE_BLOCK         ; reduce bytes to move
        jae     RlNT10                  ; if ae, more CACHE_BLOCK bytes to move 
        add     r8, CACHE_BLOCK         ; adjust to remaining bytes
        mov     r9, r8                  ; compute number of 64-byte blocks left
        shr     r9, 6                   ;
        and     r8, 64 - 1              ; reduce bytes to move
        jmp     RlNT10                  ; continue to move rest 64-byte blocks
RlNT40:                                 ;
   lock or      byte ptr [rsp], 0       ; flush data to memory

;
; Move residual bytes.
;

RlNT50: sub     r8, 8                   ; subtract out 8-byte block
        jae     short RlNT60            ; if ae, more than 8 bytes left
        add     r8, 8                   ; adjust to remaining bytes
        jnz     short RlNT80            ; if nz, more bytes to move
        ret

        align   16

        db      066h, 066h, 090h
        db      066h, 066h, 090h
        db      066h, 066h, 090h

RlNT60: mov     r9, 8                   ; load constant to r9 
RlNT70: mov     rax, [rdx + rcx]        ; move 8-byte block
        add     rcx, r9                 ; advance to next 8-byte block
        mov     [rcx - 8], rax          ;
        sub     r8, r9                  ; subtract out 8-byte block
        jae     short RlNT70            ; if ae, more 8-byte blocks
        add     r8, r9                  ; adjust to remaining bytes
        jnz     short RlNT80            ; if nz, more bytes to move
        ret

        align   16

RlNT80: mov     al, [rdx + rcx]         ; move bytes
        mov     [rcx], al               ;
        inc     rcx                     ; increment source address
        dec     r8                      ; decrement byte count
        jnz     short RlNT80            ; if nz, more bytes to move
        ret                             ; return

        LEAF_END RtlCopyMemoryNonTemporal, _TEXT$00

        subttl  "Fill Memory"
;++
;
; VOID
; RtlFillMemory (
;     IN VOID UNALIGNED *Destination,
;     IN SIZE_T Length,
;     IN UCHAR Fill
;     )
;
; Routine Description:
;
;   This function fills a block of unaligned memory with a specified pattern.
;
; Arguments:
;
;   Destination (rcx) - Supplies a pointer to the memory to fill.
;
;   Length (rdx) - Supplies the length, in bytes, of the memory to fill.
;
;   Fill (r8b) - Supplies the value to fill memory with.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY RtlFillMemory, _TEXT$00

        xchg    r8, rdx                 ; exchange length and pattern
        jmp     memset                  ; finish in common code

        LEAF_END RtlFillMemory, _TEXT$00

        subttl  "Prefetch Memory NonTemporal"
;++
;
; VOID
; RtlPrefetchMemoryNonTemporal (
;     IN CONST PVOID Source,
;     IN SIZE_T Length
;     )
;
; Routine Description:
;
;   This function prefetches memory at Source, for Length bytes into the
;   closest cache to the processor.
;
; Arguments:
;
;   Source (rcx) - Supplies a pointer to the memory to be prefetched.
;
;   Length (rdx) - Supplies the length, in bytes, of the operation.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY RtlPrefetchMemoryNonTemporal, _TEXT$00

RlPF10: prefetchnta 0[rcx]              ; prefetch line
        add     rcx, 64                 ; increment address to prefetch
        sub     rdx, 64                 ; subtract number of bytes prefetched
        ja      RlPF10                  ; if above zero, more bytes to move
        ret                             ; return

        LEAF_END RtlPrefetchMemoryNonTemporal, _TEXT$00

        subttl  "Zero Memory"
;++
;
; VOID
; RtlZeroMemory (
;     IN VOID UNALIGNED *Destination,
;     IN SIZE_T Length
;     )
;
; Routine Description:
;
;   This function fills a block of unaligned memory with zero.
;
; Arguments:
;
;   Destination (rcx) - Supplies a pointer to the memory to fill.
;
;   Length (rdx) - Supplies the length, in bytes, of the memory to fill.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY RtlZeroMemory, _TEXT$00

        mov     r8, rdx                 ; set length
        xor     edx, edx                ; set fill pattern
        jmp     memset                  ; finish in common code

        LEAF_END RtlZeroMemory, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\amd64\raise.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    raise.c

Abstract:

    This module implements functions to raise and exception and to raise
    status.

--*/

#include "ntrtlp.h"

DECLSPEC_NOINLINE
VOID
RtlRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    )

/*++

Routine Description:

    This function raises a software exception by building a context record
    and calling the raise exception system service.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

Return Value:

    None.

--*/

{

    CONTEXT ContextRecord;
    ULONG64 ControlPc;
    ULONG64 EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 ImageBase;
    NTSTATUS Status = STATUS_INVALID_DISPOSITION;

    //
    // Capture the current context, unwind to the caller of this routine, set
    // the exception address, and call the appropriate exception dispatcher.
    //

    RtlCaptureContext(&ContextRecord);
    ControlPc = ContextRecord.Rip;
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, NULL);
    if (FunctionEntry != NULL) {
        RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                         ImageBase,
                         ControlPc,
                         FunctionEntry,
                         &ContextRecord,
                         &HandlerData,
                         &EstablisherFrame,
                         NULL);

        ExceptionRecord->ExceptionAddress = (PVOID)ContextRecord.Rip;

        if (RtlDispatchException(ExceptionRecord, &ContextRecord) != FALSE) {
            return;
    
        }

        Status = ZwRaiseException(ExceptionRecord, &ContextRecord, FALSE);
    }

    //
    // There should never be a return from either exception dispatch or the
    // system service unless there is a problem with the argument list itself.
    // Raise another exception specifying the status value returned.
    //

    RtlRaiseStatus(Status);
    return;
}

#pragma warning(push)
#pragma warning(disable:4717)       // recursive function

DECLSPEC_NOINLINE
VOID
RtlRaiseStatus (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This function raises an exception with the specified status value. The
    exception is marked as noncontinuable with no parameters.

    N.B. There is no return from this function.

Arguments:

    Status - Supplies the status value to be used as the exception code
        for the exception that is to be raised.

Return Value:

    None.

--*/

{

    CONTEXT ContextRecord;
    EXCEPTION_RECORD ExceptionRecord;

    //
    // Capture the current context and construct an exception record.
    //

    RtlCaptureContext(&ContextRecord);
    ExceptionRecord.ExceptionCode = Status;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.NumberParameters = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    ExceptionRecord.ExceptionAddress = (PVOID)ContextRecord.Rip;

    //
    // Attempt to dispatch the exception.
    //
    // N.B. This exception is non-continuable.
    //

    RtlDispatchException(&ExceptionRecord, &ContextRecord);
    Status = ZwRaiseException(&ExceptionRecord, &ContextRecord, FALSE);

    //
    // There should never be a return from either exception dispatch or the
    // system service unless there is a problem with the argument list itself.
    // Raise another exception specifying the status value returned.
    //

    RtlRaiseStatus(Status);
}

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\debug3.c ===
//++
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
//
// You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//
//
// Module Name:
//
//    debug3.c
//
// Abstract:
//
//    This module implements architecture specific functions to support debugging NT.
//
//--

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntrtlp.h"

//
// Prototype for local procedure
//

NTSTATUS
DebugService(
    ULONG ServiceClass,
    PVOID Arg1,
    PVOID Arg2,
    PVOID Arg3,
    PVOID Arg4
    );

NTSTATUS
DebugService(
    ULONG ServiceClass,
    PVOID Arg1,
    PVOID Arg2,
    PVOID Arg3,
    PVOID Arg4
    )

//++
//
//  Routine Description:
//
//      Allocate an ExceptionRecord, fill in data to allow exception
//      dispatch code to do the right thing with the service, and
//      call RtlRaiseException (NOT ExRaiseException!!!).
//
//  Arguments:
//      ServiceClass - which call is to be performed
//      Arg1 - generic first argument
//      Arg2 - generic second argument
//      Arg3 - generic third argument
//      Arg4 - generic fourth argument
//
//  Returns:
//      Whatever the exception returns in eax
//
//--

{
    NTSTATUS    RetValue;

#if defined(BUILD_WOW6432)

    extern NTSTATUS NtWow64DebuggerCall(ULONG, PVOID, PVOID, PVOID, PVOID);
    RetValue = NtWow64DebuggerCall(ServiceClass, Arg1, Arg2, Arg3, Arg4);

#else
    _asm {
        push    edi
        push    ebx
        mov     eax, ServiceClass
        mov     ecx, Arg1
        mov     edx, Arg2
        mov     ebx, Arg3
        mov     edi, Arg4

        int     2dh                 ; Raise exception
        int     3                   ; DO NOT REMOVE (See KiDebugService)

        pop     ebx
        pop     edi
        mov     RetValue, eax

    }

#endif

    return RetValue;
}


VOID
DebugService2(
    PVOID Arg1,
    PVOID Arg2,
    ULONG ServiceClass
    )

//++
//
//  Routine Description:
//
//      Generic exception dispatcher for the debugger
//
//  Arguments:
//      Arg1 - generic first argument
//      Arg2 - generic second argument
//      ServiceClass - which call is to be performed
//
//  Returns:
//      Whatever the exception returns in eax
//
//--

{
#if defined(BUILD_WOW6432)

    extern NTSTATUS NtWow64DebuggerCall(ULONG, PVOID, PVOID, PVOID, PVOID);
    NtWow64DebuggerCall(ServiceClass, Arg1, Arg2, 0, 0);

#else
    _asm {
        //push    edi
        //push    ebx
        mov     eax, ServiceClass
        mov     ecx, Arg1
        mov     edx, Arg2
        //mov     ebx, Arg3
        //mov     edi, Arg4

        int     2dh                 ; Raise exception
        int     3                   ; DO NOT REMOVE (See KiDebugService)

        //pop     ebx
        //pop     edi

    }

#endif

    return;
}



// DebugPrint must appear after DebugSerive.  Moved
// it down below DebugService, so BBT would have a label after DebugService.
// A label after the above _asm  is necessary so BBT can treat DebugService
// as  "KnownDataRange".   Otherwise, the two  'int' instructions could get broken up
// by BBT's optimizer.
//

NTSTATUS
DebugPrint(
    IN PSTRING Output,
    IN ULONG ComponentId,
    IN ULONG Level
    )
{
    return DebugService(BREAKPOINT_PRINT,
                        Output->Buffer,
                        (PVOID)Output->Length,
                        (PVOID)ComponentId,
                        (PVOID)Level);
}


ULONG
DebugPrompt(
    IN PSTRING Output,
    IN PSTRING Input
    )
{
    return DebugService(BREAKPOINT_PROMPT,
                        Output->Buffer,
                        (PVOID)Output->Length,
                        Input->Buffer,
                        (PVOID)Input->MaximumLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\debug2.asm ===
title  "Debug Support Functions"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    debug.s
;
; Abstract:
;
;    This module implements functions to support debugging NT.
;
;--
.386p


        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

_TEXT	SEGMENT PUBLIC DWORD 'CODE'
ASSUME  DS:FLAT, ES:FLAT, FS:NOTHING, GS:NOTHING, SS:NOTHING

cPublicProc _DbgBreakPoint        ,0
cPublicFpo 0,0
        int 3
        stdRET    _DbgBreakPoint
stdENDP _DbgBreakPoint

cPublicProc _DbgUserBreakPoint        ,0
cPublicFpo 0,0
        int 3
        stdRET    _DbgUserBreakPoint
stdENDP _DbgUserBreakPoint

cPublicProc _DbgBreakPointWithStatus,1
cPublicFpo 1,0
        mov eax,[esp+4]
        public _RtlpBreakWithStatusInstruction@0
_RtlpBreakWithStatusInstruction@0:
        int 3
        stdRET  _DbgBreakPointWithStatus
stdENDP _DbgBreakPointWithStatus


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\amd64\xcptmisc.asm ===
title   "Exception Handling Support Routines"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   xcptmisc.asm
;
; Abstract:
;
;   This module implements stub routines to call language specific handlers
;   for exception dispatching and termination handling.
;
;--

include ksamd64.inc

        subttl  "Local Exception Handler"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExceptionHandler (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN PVOID EstablisherFrame,
;     IN OUT PCONTEXT ContextRecord,
;     IN OUT PVOID DispatcherContext
;     )
;
; Routine Description:
;
;   This function is called when a nested exception occurs. Its function
;   is to retrieve the establisher frame pointer from its establisher's
;   call frame, store this information in the dispatcher context record,
;   and return a disposition value of nested exception.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;   A disposition value nested exception is returned if an unwind is not in
;   progress. Otherwise a value of continue search is returned.
;
;--

EhFrame struct
        P1Home  dq ?                    ; parameter home addresses for
        P2Home  dq ?                    ; called functions
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        Context dq ?                    ; saved dispatcher context address
EhFrame ends

        LEAF_ENTRY RtlpExceptionHandler, _TEXT$00

        mov     eax, ExceptionContinueSearch ; assume unwind in progress
        test    dword ptr ErExceptionFlags[rcx], EXCEPTION_UNWIND ; check for unwind
        jnz     short Eh10              ; if nz, unwind in progress
        mov     rax, EhFrame.Context[rdx] ; get establisher context address
        mov     rax, DcEstablisherFrame[rax] ; copy the establisher frame
        mov     DcEstablisherFrame[r9], rax ; to current dispatcher context
        mov     eax, ExceptionNestedException ; set nested exception disposition
eH10:   ret                             ; return

        LEAF_END RtlpExceptionHandler, _TEXT$00

        subttl  "Execute Handler for Exception"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExecuteHandlerForException (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN PVOID EstablisherFrame,
;     IN OUT PCONTEXT ContextRecord,
;     IN OUT PVOID DispatcherContext
;     )
;
; Routine Description:
;
;   This function allocates a call frame, saves the dispatcher context address,
;   establishes an exception handler, and calls the specified language specific
;   handler routine. If a nested exception occurs, then the exception handler
;   of this function is called and the establisher frame pointer is returned to
;   the exception dispatcher via the dispatcher context parameter.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of the exception handler that is to be called.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;   The disposition value returned by the specified exception handler is
;   returned as the function value.
;
;--

        NESTED_ENTRY RtlpExecuteHandlerForException, _TEXT$00, RtlpExceptionHandler

        alloc_stack (sizeof EhFrame)    ; allocate stack frame

        END_PROLOGUE

        mov     EhFrame.Context[rsp], r9 ; save dispatcher context address
        call    qword ptr DcLanguageHandler[r9] ; call language handler
        nop                             ; required fill for virtual unwind
        add     rsp, sizeof EhFrame     ; deallocate stack frame
        ret                             ; return

        NESTED_END RtlpExecuteHandlerForException, _TEXT$00

        subttl  "Local Unwind Handler"
;++
;
; EXCEPTION_DISPOSITION
; RtlpUnwindHandler (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN PVOID EstablisherFrame,
;     IN OUT PCONTEXT ContextRecord,
;     IN OUT PVOID DispatcherContext
;     )
;
; Routine Description:
;
;   This function is called when a collided unwind occurs. Its function
;   is to retrieve the establisher dispatcher context, copy it to the
;   current dispatcher context, and return a disposition value of collided
;   unwind.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;   A disposition value collided unwind is returned if an unwind is in
;   progress. Otherwise a value of continue search is returned.
;
;--

        LEAF_ENTRY RtlpUnwindHandler, _TEXT$00

        mov     rax, EhFrame.Context[rdx] ; get establisher context address
        mov     r10, DcControlPc[rax]   ; copy control PC
        mov     DcControlPc[r9], r10    ;
        mov     r10, DcImageBase[rax]   ; copy image base
        mov     DcImageBase[r9], r10    ;
        mov     r10, DcFunctionEntry[rax] ; copy function entry
        mov     DcFunctionentry[r9], r10 ;
        mov     r10, DcEstablisherFrame[rax] ; copy establisher frame
        mov     DcEstablisherFrame[r9], r10 ;
        mov     r10, DcContextRecord[rax] ; copy context record address
        mov     DcContextRecord[r9], r10 ;
        mov     r10, DcLanguageHandler[rax] ; copy language handler address
        mov     DcLanguageHandler[r9], r10 ;
        mov     r10, DcHandlerData[rax] ; copy handler data address
        mov     DcHandlerData[r9], r10  ;
        mov     r10, DcHistoryTable[rax] ; copy history table address
        mov     DcHistoryTable[r9], r10 ;
        mov     r10d, DcScopeIndex[rax] ; copy scope table index
        mov     DcScopeIndex[r9], r10d  ;
        mov     eax, ExceptionCollidedUnwind ; set collided unwind disposition
        ret                             ; return

        LEAF_END RtlpUnwindHandler, _TEXT$00

        subttl  "Execute Handler for Unwind"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExecuteHandlerForUnwind (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN PVOID EstablisherFrame,
;     IN OUT PCONTEXT ContextRecord,
;     IN OUT PVOID DispatcherContext
;     )
;
; Routine Description:
;
;   This function allocates a call frame, saves the dispatcher context address,
;   establishes an exception handler, and calls the specified unwind handler.
;   If a collided unwind occurs, then the exception handler of this function is
;   called and the establisher dispatcher context is copied to the current
;   dispatcher context via the dispatcher context parameter.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of the exception handler that is to be called.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to the dispatcher context
;       record.
;
;   ExceptionRoutine (5 * 8[rsp]) - Supplies a pointer to the exception
;       handler that is to be called.
;
; Return Value:
;
;   The disposition value returned by the specified exception handler is
;   returned as the function value.
;
;--

        NESTED_ENTRY RtlpExecuteHandlerForUnwind, _TEXT$00, RtlpUnwindHandler

        alloc_stack (sizeof EhFrame)    ; allocate stack frame

        END_PROLOGUE

        mov     EhFrame.Context[rsp], r9 ; save dispatcher context address
        call    qword ptr DcLanguageHandler[r9] ; call exception handler
        nop                             ; required fill for virtual unwind
        add     rsp, sizeof EhFrame     ; deallocate stack frame
        ret                             ; return

        NESTED_END RtlpExecuteHandlerForUnwind, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\amd64\slist.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    slist.asm
;
; Abstract:
;
;    This module implements functions to support interlocked S-List
;    operations.
;
;--

include ksamd64.inc

        altentry ExpInterlockedFlushSList
        altentry ExpInterlockedPopEntrySList
        altentry ExpInterlockedPopEntrySListEnd
        altentry ExpInterlockedPopEntrySListFault
        altentry ExpInterlockedPopEntrySListResume
        altentry ExpInterlockedPushEntrySList
        altentry RtlInterlockedPopEntrySList

        subttl  "First Entry SList"
;++
;
; PSINGLE_LIST_ENTRY
; FirstEntrySList (
;     IN PSLIST_HEADER SListHead
;     )
;
; Routine Description:
;
;   This function returns the address of the fisrt entry in the SLIST or
;   NULL.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the sequenced listhead from
;       which the first entry address is to be computed.
;
; Return Value:
;
;   The address of the first entry is the specified, or NULL if the list is
;   empty.
;
;--

        LEAF_ENTRY FirstEntrySList, _TEXT$00

        mov     rax, [rcx]              ; get address, sequence, and depth
        and     rax, 0fe000000H         ; isolate packed address

;
; The following code takes advantage of the fact that the high order bit
; for user mode addresses is zero and for system addresses is one.
;

        cmp     rax, 1                  ; set carry if address is zero
        cmc                             ; set carry if address is not zero
        rcr     rax, 1                  ; rotate carry into high bit
        sar     rax, 63 - 43            ; extract first entry address

        ret                             ; return

        LEAF_END FirstEntrySList, _TEXT$00

        subttl  "Interlocked Pop Entry Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; RtlpInterlockedPopEntrySList (
;     IN PSINGLE_LIST_ENTRY ListHead
;     )
;
; Routine Description:
;
;   This function removes an entry from the front of a sequenced singly
;   linked list so that access to the list is synchronized in an MP system.
;   If there are no entries in the list, then a value of NULL is returned.
;   Otherwise, the address of the entry that is removed is returned as the
;   function value.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the sequenced listhead from
;       which an entry is to be removed.
;
; Return Value:
;
;   The address of the entry removed from the list, or NULL if the list is
;   empty.
;
;--

        LEAF_ENTRY RtlpInterlockedPopEntrySList, _TEXT$00

        ALTERNATE_ENTRY ExpInterlockedPopEntrySList
        ALTERNATE_ENTRY RtlInterlockedPopEntrySList

;
; N.B. The following code is the continuation address should a fault occur
;      in the rare case described below.
;

        ALTERNATE_ENTRY ExpInterlockedPopEntrySListResume

Pop10:  prefetchw [rcx]                 ; prefetch entry for write
        mov     rax, [rcx]              ; get address, sequence, and depth
        mov     rdx, rax                ; make a copy
        and     rdx, 0fe000000H         ; isolate packed address
        jz      short Pop20             ; if z, list is empty

;
; The following code takes advantage of the fact that the high order bit
; for user mode addresses is zero and for system addresses is one.
;
        or      rdx, 01fffffh           ; sign-extend resultant address

        ror     rdx, 63 - 42            ; extract next entry address

;
; N.B. It is possible for the following instruction to fault in the rare
;      case where the first entry in the list is allocated on another
;      processor and free between the time the free pointer is read above
;      and the following instruction. When this happens, the access fault
;      code continues execution by skipping the following instruction.
;      This results in the compare failing and the entire operation is
;      retried.
;

        ALTERNATE_ENTRY ExpInterlockedPopEntrySListFault

        mov     r8, [rdx]               ; get address of successor entry
        shl     r8, 63 - 42             ; shift address into position
        mov     r9, rax                 ; adjust depth but not sequence
        dec     r9w                     ;
        and     r9, 01ffffffh           ; isolate sequence and depth
        or      r8, r9                  ; merge address, sequence, and depth

        ALTERNATE_ENTRY ExpInterlockedPopEntrySListEnd

ifndef NT_UP

   lock cmpxchg [rcx], r8               ; compare and exchange

else

        cmpxchg [rcx], r8               ; compare and exchange

endif

        jnz     short Pop10             ; if nz, exchange failed
Pop20:  mov     rax, rdx                ; set address of next entry
        ret                             ;

        LEAF_END RtlpInterlockedPopEntrySList, _TEXT$00

        subttl  "Interlocked Push Entry Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; RtlpInterlockedPushEntrySList (
;     IN PSINGLE_LIST_ENTRY ListHead,
;     IN PSINGLE_LIST_ENTRY ListEntry
;     )
;
; Routine Description:
;
;   This function inserts an entry at the head of a sequenced singly linked
;   list so that access to the list is synchronized in an MP system.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the sequenced listhead into which
;       an entry is to be inserted.
;
;   ListEntry (rdx) - Supplies a pointer to the entry to be inserted at the
;       head of the list.
;
; Return Value:
;
;   Previous contents of list head. NULL implies list went from empty to not
;   empty.
;
;--

        LEAF_ENTRY RtlpInterlockedPushEntrySList,  _TEXT$00

        ALTERNATE_ENTRY ExpInterlockedPushEntrySList

        prefetchw [rcx]                 ; prefetch entry for write
        mov     rax, [rcx]              ; get address, sequence, and depth
        mov     r9, rdx                 ; make copy of list entry pointer
        shl     r9, 63 - 42             ; shift address into position

if DBG

        test    dl, 0fh                 ; test if entry 16-byte aligned
        jz      short Push10            ; if z, entry is 16-byte aligned
        int     3                       ; break into debugger

endif

Push10: mov     r8, rax                 ; copy address, sequence, and depth
        mov     r10, rax                ; copy address, sequence, and depth
        and     r8, 0fe000000h          ; isolate packed address

;
; The following code takes advantage of the fact that the high order bit
; for user mode addresses is zero and for system addresses is one.
;

        cmp     r8, 1                   ; set carry if address is zero
        cmc                             ; set carry if address is not zero
        rcr     r8, 1                   ; rotate carry into high bit
        sar     r8, 63 - 43             ; extract next entry address

        mov     [rdx], r8               ; set next entry to previous first
        add     r10d, 010001h           ; increment sequence and depth fields
        and     r10, 01ffffffh          ; isolate sequence and depth
        or      r10, r9                 ; merge address, sequence, and depth

ifndef NT_UP

   lock cmpxchg [rcx], r10              ; compare and exchange

else

        cmpxchg [rcx], r10              ; compare and exchange

endif

        jnz     short Push10            ; if nz, exchange failed
        mov     rax, r8                 ; set address of first entry
        ret                             ; return

        LEAF_END RtlpInterlockedPushEntrySList,  _TEXT$00

        subttl  "Interlocked Flush Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; RtlpInterlockedFlushSList (
;     IN PSINGLE_LIST_ENTRY ListHead
;     )
;
; Routine Description:
;
;   This function removes the entire list from a sequenced singly
;   linked list so that access to the list is synchronized in an MP system.
;   If there are no entries in the list, then a value of NULL is returned.
;   Otherwise, the address of the entry at the top of the list is removed
;   and returned as the function value and the list header is set to point
;   to NULL.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the sequenced listhead from
;       which the list is to be flushed.
;
; Return Value:
;
;   The address of the entire current list, or NULL if the list is
;   empty.
;
;--

        LEAF_ENTRY RtlpInterlockedFlushSList, _TEXT$00

        ALTERNATE_ENTRY ExpInterlockedFlushSList

        prefetchw [rcx]                 ; prefetch entry for write
        mov     rax, [rcx]              ; get address, sequence, and depth
Fl10:   mov     rdx, rax                ; make copy
        and     rdx, 0fe000000h         ; isolate packed address
        jz      short Fl20              ; if z, list is empty

;
; The following code takes advantage of the fact that the high order bit
; for user mode addresses is zero and for system addresses is one.
;

        or      rdx, 01fffffh           ; sign-extend resultant address

        ror     rdx, 63 - 42            ; extract next entry address
        mov     r8, rax                 ; isolate sequence number
        and     r8, 01ff0000h           ;

ifndef NT_UP

   lock cmpxchg [rcx], r8               ; compare and exchange

else

        cmpxchg [rcx], r8               ; compare and exchange

endif

        jnz     short Fl10              ; if nz, exchange failed
Fl20:   mov     rax, rdx                ; set address of first entry
        ret                             ; return

        LEAF_END RtlpInterlockedFlushSList, _TEXT$00

        subttl  "Interlocked Push List Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; InterlockedPushListSList (
;    IN PSLIST_HEADER ListHead,
;    IN PSINGLE_LIST_ENTRY List,
;    IN PSINGLE_LIST_ENTRY ListEnd,
;    IN ULONG Count
;    )
;
; Routine Description:
;
;   This function pushes the specified singly linked list onto the front of
;   a sequenced list.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the sequenced listhead into which
;       the specified list is inserted.
;
;   List (rdx) - Supplies a pointer to the first entry in the list to be
;       pushed onto the front of the specified sequenced list.
;
;   ListEnd (r8) - Supplies a pointer to the last entry in the list to be
;       pushed onto the front of the specified sequence list.
;
;   Count (r9) - Supplies the number of entries in the list.
;
; Return Value:
;
;   Previous contents of list head. NULL implies list went from empty to not
;   empty.
;
;--

        NESTED_ENTRY InterlockedPushListSList, _TEXT$00

        alloc_stack 8                   ; allocate stack frame
        save_reg rsi, 0                 ; save nonvolatile register

        END_PROLOGUE

        prefetchw [rcx]                 ; prefetch entry for write
        mov     rax, [rcx]              ; get address, sequence, and depth

if DBG

        test    dl, 0fh                 ; test if entry 16-byte aligned
        jnz     short Pshl10            ; if nz, entry not 16-byte aligned
        test    r8b, 0fh                ; test if entry 16-byte aligned
        jz      short Pshl20            ; if z, entry is 16-byte aligned
Pshl10: int     3                       ; break into debugger

endif

Pshl20: shl     rdx, 63 - 42            ; shift first address into position
Pshl30: mov     r10, rax                ; make a copy
        and     r10, 0fe000000H         ; isolate packed address

;
; The following code takes advantage of the fact that the high order bit
; for user mode addresses is zero and for system addresses is one.
;

        cmp     r10, 1                  ; set carry if address is zero
        cmc                             ; set carry if address is not zero
        rcr     r10, 1                  ; rotate carry into high bit
        sar     r10, 63 - 43            ; extract next entry address

        mov     [r8], r10               ; link old first to last in list
        lea     r11d, [rax][r9]         ; add length of list to depth
        and     r11d, 0ffffh            ; wrap depth if overflow
        lea     esi, 010000h[rax]       ; increment sequence
        and     esi, 01ff0000h          ; wrap sequence if overflow
        or      rsi, r11                ; merge address, sequence, and depth
        or      rsi, rdx                ;

ifndef NT_UP

   lock cmpxchg [rcx], rsi              ; compare and exchange

else

        cmpxchg [rcx], rsi              ; compare and exchange

endif

        jnz     short Pshl30            ; if nz, exchange failed
        mov     rax, r10                ; set address of first entry
        mov     rsi, [rsp]              ; restore nonvolatile register
        add     rsp, 8                  ; deallocate stack frame
        ret                             ; return

        NESTED_END InterlockedPushListSList, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\divlarge.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    largediv.c

Abstract:

    This module implements the NT runtime library large integer divide
    routines.

    N.B. These routines use a one bit at a time algorithm and is slow.
         They should be used only when absolutely necessary.

--*/

#include "ntrtlp.h"

LARGE_INTEGER
RtlLargeIntegerDivide (
    IN LARGE_INTEGER Dividend,
    IN LARGE_INTEGER Divisor,
    OUT PLARGE_INTEGER Remainder OPTIONAL
    )

/*++

Routine Description:

    This routine divides an unsigned 64-bit dividend by an unsigned 64-bit
    divisor and returns a 64-bit quotient, and optionally a 64-bit remainder.

Arguments:

    Dividend - Supplies the 64-bit dividend for the divide operation.

    Divisor - Supplies the 64-bit divisor for the divide operation.

    Remainder - Supplies an optional pointer to a variable which receives
        the remainder

Return Value:

    The 64-bit quotient is returned as the function value.

--*/

{

    ULONG Index = 64;
    LARGE_INTEGER Partial = {0, 0};
    LARGE_INTEGER Quotient;

    //
    // Check for divide by zero
    //

    if (!(Divisor.LowPart | Divisor.HighPart)) {
        RtlRaiseStatus (STATUS_INTEGER_DIVIDE_BY_ZERO);
    }

    //
    // Loop through the dividend bits and compute the quotient and remainder.
    //

    Quotient = Dividend;
    do {

        //
        // Shift the next dividend bit into the parital remainder and shift
        // the partial quotient (dividend) left one bit.
        //

        Partial.HighPart = (Partial.HighPart << 1) | (Partial.LowPart >> 31);
        Partial.LowPart = (Partial.LowPart << 1) | ((ULONG)Quotient.HighPart >> 31);
        Quotient.HighPart = (Quotient.HighPart << 1) | (Quotient.LowPart >> 31);
        Quotient.LowPart <<= 1;

        //
        // If the partial remainder is greater than or equal to the divisor,
        // then subtract the divisor from the partial remainder and insert a
        // one bit into the quotient.
        //

        if (((ULONG)Partial.HighPart > (ULONG)Divisor.HighPart) ||
            ((Partial.HighPart == Divisor.HighPart) &&
            (Partial.LowPart >= Divisor.LowPart))) {

            Quotient.LowPart |= 1;
            Partial.HighPart -= Divisor.HighPart;
            if (Partial.LowPart < Divisor.LowPart) {
                Partial.HighPart -= 1;
            }

            Partial.LowPart -= Divisor.LowPart;
        }

        Index -= 1;
    } while (Index > 0);

    //
    // If the remainder is requested, then return the 64-bit remainder.
    //

    if (ARGUMENT_PRESENT(Remainder)) {
        *Remainder = Partial;
    }

    //
    // Return the 64-bit quotient.
    //

    return Quotient;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\context.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    context.c

Abstract:

    This module implements user-mode callable context manipulation routines.
    The interfaces exported from this module are portable, but they must
    be re-implemented for each architecture.

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,RtlInitializeContext)
#pragma alloc_text(PAGE,RtlRemoteCall)
#endif


VOID
RtlInitializeContext(
    IN HANDLE Process,
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL
    )

/*++

Routine Description:

    This function initializes a context structure so that it can
    be used in a subsequent call to NtCreateThread.

Arguments:

    Context - Supplies a context buffer to be initialized by this routine.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

Return Value:

    Raises STATUS_BAD_INITIAL_STACK if the value of InitialSp is not properly
           aligned.

    Raises STATUS_BAD_INITIAL_PC if the value of InitialPc is not properly
           aligned.

--*/

{
    RTL_PAGED_CODE();

    Context->Eax = 0L;
    Context->Ebx = 1L;
    Context->Ecx = 2L;
    Context->Edx = 3L;
    Context->Esi = 4L;
    Context->Edi = 5L;
    Context->Ebp = 0L;

    Context->SegGs = 0;
    Context->SegFs = KGDT_R3_TEB;
    Context->SegEs = KGDT_R3_DATA;
    Context->SegDs = KGDT_R3_DATA;
    Context->SegSs = KGDT_R3_DATA;
    Context->SegCs = KGDT_R3_CODE;

    Context->EFlags = 0x200L;	    // force interrupts on, clear all else.

    //
    // Even though these are optional, they are used as is, since NULL
    // is what these would have been initialized to anyway
    //

    Context->Esp = (ULONG) InitialSp;
    Context->Eip = (ULONG) InitialPc;

    //
    // add code to check alignment and raise exception...
    //

    Context->ContextFlags = CONTEXT_CONTROL|CONTEXT_INTEGER|CONTEXT_SEGMENTS;

    //
    // Set the initial context of the thread in a machine specific way.
    // ie, pass the initial parameter to the start address
    //

    Context->Esp -= sizeof(Parameter);
    ZwWriteVirtualMemory(Process,
			 (PVOID)Context->Esp,
			 (PVOID)&Parameter,
			 sizeof(Parameter),
			 NULL);
    Context->Esp -= sizeof(Parameter); // Reserve room for ret address


}



NTSTATUS
RtlRemoteCall(
    HANDLE Process,
    HANDLE Thread,
    PVOID CallSite,
    ULONG ArgumentCount,
    PULONG Arguments,
    BOOLEAN PassContext,
    BOOLEAN AlreadySuspended
    )

/*++

Routine Description:

    This function calls a procedure in another thread/process, using
    NtGetContext and NtSetContext.  Parameters are passed to the
    target procedure via its stack.

Arguments:

    Process - Handle of the target process

    Thread - Handle of the target thread within that process

    CallSite - Address of the procedure to call in the target process.

    ArgumentCount - Number of 32 bit parameters to pass to the target
                    procedure.

    Arguments - Pointer to the array of 32 bit parameters to pass.

    PassContext - TRUE if an additional parameter is to be passed that
        points to a context record.

    AlreadySuspended - TRUE if the target thread is already in a suspended
                       or waiting state.

Return Value:

    Status - Status value

--*/

{
    NTSTATUS Status;
    CONTEXT Context;
    ULONG NewSp;
    ULONG ArgumentsCopy[5];

    RTL_PAGED_CODE();

    if (ArgumentCount > 4)
        return STATUS_INVALID_PARAMETER;

    //
    // If necessary, suspend the guy before with we mess with his stack.
    //
    if (!AlreadySuspended) {
        Status = NtSuspendThread( Thread, NULL );
        if (!NT_SUCCESS( Status )) {
            return( Status );
            }
        }


    //
    // Get the context record for the target thread.
    //

    Context.ContextFlags = CONTEXT_FULL;
    Status = NtGetContextThread( Thread, &Context );
    if (!NT_SUCCESS( Status )) {
        if (!AlreadySuspended) {
            NtResumeThread( Thread, NULL );
            }
        return( Status );
        }


    //
    //	Pass all parameters on the stack, regardless of whether a
    //	a context record is passed.
    //

    //
    //	Put Context Record on stack first, so it is above other args.
    //
    NewSp = Context.Esp;
    if (PassContext) {
	NewSp -= sizeof( CONTEXT );
	Status = NtWriteVirtualMemory( Process,
				       (PVOID)NewSp,
				       &Context,
				       sizeof( CONTEXT ),
				       NULL
				    );
	if (!NT_SUCCESS( Status )) {
            if (!AlreadySuspended) {
                NtResumeThread( Thread, NULL );
                }
	    return( Status );
	    }
        ArgumentsCopy[0] = NewSp;   // pass pointer to context
        RtlCopyMemory(&(ArgumentsCopy[1]),Arguments,ArgumentCount*sizeof( ULONG ));
        ArgumentCount++;
	}
    else {
        RtlCopyMemory(ArgumentsCopy,Arguments,ArgumentCount*sizeof( ULONG ));
        }

    //
    //	Copy the arguments onto the target stack
    //
    if (ArgumentCount) {
        NewSp -= ArgumentCount * sizeof( ULONG );
        Status = NtWriteVirtualMemory( Process,
                                       (PVOID)NewSp,
                                       ArgumentsCopy,
                                       ArgumentCount * sizeof( ULONG ),
                                       NULL
                                     );
        if (!NT_SUCCESS( Status )) {
            if (!AlreadySuspended) {
                NtResumeThread( Thread, NULL );
                }
            return( Status );
            }
        }

    //
    // Set the address of the target code into Eip, the new target stack
    // into Esp, and reload context to make it happen.
    //
    Context.Esp = NewSp;
    Context.Eip = (ULONG)CallSite;
    Status = NtSetContextThread( Thread, &Context );
    if (!AlreadySuspended) {
        NtResumeThread( Thread, NULL );
        }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\amd64\stkwalk.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    stkwalk.c

Abstract:

    This module implements the routine to get the callers and the callers
    caller address.

--*/

#include "ntrtlp.h"

//
// Counter for the number of simultaneous stack walks in the system. The
// counter is relevant for only for memory management.
//
                              
LONG RtlpStackWalksInProgress;

ULONG
RtlpWalkFrameChainExceptionFilter (
    ULONG ExceptionCode,
    PVOID ExceptionRecord
    );

PRUNTIME_FUNCTION
RtlpConvertFunctionEntry (
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN ULONG64 ImageBase
    );

PRUNTIME_FUNCTION
RtlpLookupFunctionEntryForStackWalks (
    IN ULONG64 ControlPc,
    OUT PULONG64 ImageBase
    )

/*++

Routine Description:

    This function searches the currently active function tables for an entry
    that corresponds to the specified control PC. This function does not
    consider the runtime function table.

Arguments:

    ControlPc - Supplies the address of an instruction within the specified
        function.

    ImageBase - Supplies the address of a variable that receives the image base
        if a function table entry contains the specified control PC.

Return Value:

    If there is no entry in the function table for the specified PC, then
    NULL is returned.  Otherwise, the address of the function table entry
    that corresponds to the specified PC is returned.

--*/

{

    ULONG64 BaseAddress;
    ULONG64 BeginAddress;
    ULONG64 EndAddress;
    PRUNTIME_FUNCTION FunctionEntry;
    PRUNTIME_FUNCTION FunctionTable;
    LONG High;
    ULONG Index;
    LONG Low;
    LONG Middle;
    ULONG RelativePc;
    ULONG SizeOfTable;

    //
    // Attempt to find an image that contains the specified control PC. If
    // an image is found, then search its function table for a function table
    // entry that contains the specified control PC. 
    // If an image is not found then do not search the dynamic function table.
    // The dynamic function table has the same lock as the loader lock, 
    // and searching that table could deadlock a caller of RtlpWalkFrameChain
    //

    //
    // attempt to find a matching entry in the loaded module list.
    //

    FunctionTable = RtlLookupFunctionTable((PVOID)ControlPc,
                                            (PVOID *)ImageBase,
                                            &SizeOfTable);

    //
    // If a function table is located, then search for a function table
    // entry that contains the specified control PC.
    //

    if (FunctionTable != NULL) {
        Low = 0;
        High = (SizeOfTable / sizeof(RUNTIME_FUNCTION)) - 1;
        RelativePc = (ULONG)(ControlPc - *ImageBase);
        while (High >= Low) {

            //
            // Compute next probe index and test entry. If the specified
            // control PC is greater than of equal to the beginning address
            // and less than the ending address of the function table entry,
            // then return the address of the function table entry. Otherwise,
            // continue the search.
            //

            Middle = (Low + High) >> 1;
            FunctionEntry = &FunctionTable[Middle];

            if (RelativePc < FunctionEntry->BeginAddress) {
                High = Middle - 1;

            } else if (RelativePc >= FunctionEntry->EndAddress) {
                Low = Middle + 1;

            } else {
                break;
            }
        }

        if (High < Low) {
            FunctionEntry = NULL;
        }

    } else {
    
        FunctionEntry = NULL;
        
    }

    return RtlpConvertFunctionEntry(FunctionEntry, *ImageBase);
}


DECLSPEC_NOINLINE
USHORT
RtlCaptureStackBackTrace (
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash OPTIONAL
    )

/*++

Routine Description:

    This routine captures a stack back trace by walking up the stack and
    recording the information for each frame.

     N.B. This is an exported function that MUST probe the ability to take
          page faults.

Arguments:

    FramesToSkip - Supplies the number of frames to skip over at the start
        of the back trace.

    FramesToCapture - Supplies the number of frames to be captured.

    BackTrace - Supplies a pointer to the back trace buffer.

    BackTraceHash - Optionally supples a pointer to the computed hash value.

Return Value:

     The number of captured frames is returned as the function value.

--*/

{

    ULONG FramesFound;
    ULONG HashValue;
    ULONG Index;
    PVOID Trace[2 * MAX_STACK_DEPTH];

    //
    // In kernel mode avoid running at IRQL levels where page faults cannot
    // be taken. The walking code will access various sections from driver
    // and system images and this will cause page faults. Also the walking
    // code needs to bail out if the current thread is processing a page 
    // fault since collided faults may occur.
    //

    if (MmCanThreadFault() == FALSE) {
        return 0;
    }

    if (PsGetCurrentThread ()->ActiveFaultCount != 0) {
        return 0;
    }

    //
    // If the number of frames to capture plus the number of frames to skip
    // (one additional frame is skipped for the call to walk the chain), then
    // return zero.
    //

    FramesToSkip += 1;
    if ((FramesToCapture + FramesToSkip) >= (2 * MAX_STACK_DEPTH)) {
        return 0;
    }

    //
    // Capture the stack back trace.
    //

    FramesFound = RtlWalkFrameChain(&Trace[0],
                                    FramesToCapture + FramesToSkip,
                                    0);

    //
    // If the number of frames found is less than the number of frames to
    // skip, then return zero.
    //

    if (FramesFound <= FramesToSkip) {
        return 0;
    }

    //
    // Compute the hash value and transfer the captured trace to the back
    // trace buffer.
    //

    HashValue = 0;
    for (Index = 0; Index < FramesToCapture; Index += 1) {
        if (FramesToSkip + Index >= FramesFound) {
            break;
        }

        BackTrace[Index] = Trace[FramesToSkip + Index];
        HashValue += PtrToUlong(BackTrace[Index]);
    }

    if (ARGUMENT_PRESENT(BackTraceHash)) {
        *BackTraceHash = HashValue;
    }

    return (USHORT)Index;
}

#undef RtlGetCallersAddress

DECLSPEC_NOINLINE
VOID
RtlGetCallersAddress (
    OUT PVOID *CallersPc,
    OUT PVOID *CallersCallersPc
    )

/*++

Routine Description:

    This routine returns the address of the call to the routine that called
    this routine, and the address of the call to the routine that called
    the routine that called this routine. For example, if A called B called
    C which called this routine, the return addresses in B and A would be
    returned.

    N.B. This is an exported function that MUST probe the ability to take
         page faults.

Arguments:

    CallersPc - Supplies a pointer to a variable that receives the address
        of the caller of the caller of this routine (B).

    CallersCallersPc - Supplies a pointer to a variable that receives the
        address of the caller of the caller of the caller of this routine
        (A).

Return Value:

    None.

Note:

    If either of the calling stack frames exceeds the limits of the stack,
    they are set to NULL.

--*/

{

    CONTEXT ContextRecord;
    ULONG64 EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 HighLimit;
    ULONG64 ImageBase;
    ULONG64 LowLimit;

    //
    // Assume the function table entries for the various routines cannot be
    // found or there are not three procedure activation records on the stack.
    //

    *CallersPc = NULL;
    *CallersCallersPc = NULL;

    //
    // In kernel mode avoid running at IRQL levels where page faults cannot
    // be taken. The walking code will access various sections from driver
    // and system images and this will cause page faults. Also the walking
    // code needs to bail out if the current thread is processing a page 
    // fault since collided faults may occur.
    //

    if (MmCanThreadFault() == FALSE) {
        return;
    }

    if (PsGetCurrentThread ()->ActiveFaultCount != 0) {
        return;
    }

    //
    // Get current stack limits, capture the current context, virtually
    // unwind to the caller of this routine, and lookup function table entry.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);
    RtlCaptureContext(&ContextRecord);
    FunctionEntry = RtlpLookupFunctionEntryForStackWalks(ContextRecord.Rip,
                                                         &ImageBase);

    //
    //  Attempt to unwind to the caller of this routine (C).
    //

    if (FunctionEntry != NULL) {
        RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                         ImageBase,
                         ContextRecord.Rip,
                         FunctionEntry,
                         &ContextRecord,
                         &HandlerData,
                         &EstablisherFrame,
                         NULL);

        //
        // Attempt to unwind to the caller of the caller of this routine (B).
        //

        FunctionEntry = RtlpLookupFunctionEntryForStackWalks(ContextRecord.Rip,
                                                             &ImageBase);

        if ((FunctionEntry != NULL) &&
            ((RtlpIsFrameInBounds(&LowLimit, ContextRecord.Rsp, &HighLimit) == TRUE))) {

            RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                             ImageBase,
                             ContextRecord.Rip,
                             FunctionEntry,
                             &ContextRecord,
                             &HandlerData,
                             &EstablisherFrame,
                             NULL);

            *CallersPc = (PVOID)ContextRecord.Rip;

            //
            // Attempt to unwind to the caller of the caller of the caller
            // of the caller of this routine (A).
            //

            FunctionEntry = RtlpLookupFunctionEntryForStackWalks(ContextRecord.Rip,
                                                                 &ImageBase);

            if ((FunctionEntry != NULL) &&
                ((RtlpIsFrameInBounds(&LowLimit, ContextRecord.Rsp, &HighLimit) == TRUE))) {

                RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                                 ImageBase,
                                 ContextRecord.Rip,
                                 FunctionEntry,
                                 &ContextRecord,
                                 &HandlerData,
                                 &EstablisherFrame,
                                 NULL);

                *CallersCallersPc = (PVOID)ContextRecord.Rip;
            }
        }
    }

    return;
}

DECLSPEC_NOINLINE
ULONG
RtlpWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags,
    IN ULONG FramesToSkip
    )

/*++

Routine Description:

    This function attempts to walk the call chain and capture a vector with
    a specified number of return addresses. It is possible that the function
    cannot capture the requested number of callers, in which case, the number
    of captured return addresses will be returned.

    N.B. The ability to take page faults is checked in the wrapper function.

Arguments:

    Callers - Supplies a pointer to an array that is to received the return
        address values.

    Count - Supplies the number of frames to be walked.

    Flags - Supplies the flags value (unused).

    FramesToSkip - Supplies the number of frames to skip.

Return value:

    The number of captured return addresses.

--*/

{

    CONTEXT ContextRecord;
    ULONG64 EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 HighLimit;
    ULONG64 ImageBase;
    ULONG Index;
    ULONG64 LowLimit;

    //
    // No flag values are currently supported on amd64 platforms.
    //

    if (Flags != 0) {
        return 0;
    }

    //
    // Get current stack limits and capture the current context.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);
    RtlCaptureContext(&ContextRecord);

    //
    // Capture the requested number of return addresses if possible.
    //

    InterlockedIncrement (&RtlpStackWalksInProgress);

    Index = 0;
    try {
        while ((Index < Count) && (ContextRecord.Rip != 0)) {

            //
            // Check the next PC value to make sure it is valid in the
            // current process.
            //

            if ((MmIsSessionAddress((PVOID)ContextRecord.Rip) == TRUE && 
                 MmGetSessionId(PsGetCurrentProcess()) == 0) || 
                (MmIsAddressValid((PVOID)ContextRecord.Rip) == FALSE)) {

                break;
            }

            //
            // Lookup the function table entry using the point at which control
            // left the function.
            //

            FunctionEntry = RtlpLookupFunctionEntryForStackWalks(ContextRecord.Rip,
                                                                 &ImageBase);

            //
            // If there is a function table entry for the routine and the stack is
            // within limits, then virtually unwind to the caller of the routine
            // to obtain the return address. Otherwise, discontinue the stack walk.
            //

            if ((FunctionEntry != NULL) &&
                ((RtlpIsFrameInBounds(&LowLimit, ContextRecord.Rsp, &HighLimit) == TRUE))) {

                RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                                 ImageBase,
                                 ContextRecord.Rip,
                                 FunctionEntry,
                                 &ContextRecord,
                                 &HandlerData,
                                 &EstablisherFrame,
                                 NULL);

                if (FramesToSkip != 0){
                    FramesToSkip -= 1;

                } else {
                    Callers[Index] = (PVOID)ContextRecord.Rip;
                    Index += 1;
                }

            } else {
                break;
            }
        }

    } except (RtlpWalkFrameChainExceptionFilter(GetExceptionCode(),
                                                GetExceptionInformation())) {
        
          Index = 0;
    }

    InterlockedDecrement (&RtlpStackWalksInProgress);

    return Index;
}

DECLSPEC_NOINLINE
ULONG
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags
    )

/*++

Routine Description:

    This is a wrapper function for walk frame chain. It's purpose is to
    prevent entering a function that has a huge stack usage to test some
    if the current code path can take page faults.

    N.B. This is an exported function that MUST probe the ability to take
         page faults.

Arguments:

    Callers - Supplies a pointer to an array that is to received the return
        address values.

    Count - Supplies the number of frames to be walked.

    Flags - Supplies the flags value (unused).

Return value:

    Any return value from RtlpWalkFrameChain.

--*/

{

    //
    // In kernel mode avoid running at IRQL levels where page faults cannot
    // be taken. The walking code will access various sections from driver
    // and system images and this will cause page faults. Also the walking
    // code needs to bail out if the current thread is processing a page 
    // fault since collided faults may occur.
    //

    if (MmCanThreadFault() == FALSE) {
        return 0;
    }
    
    if (PsGetCurrentThread ()->ActiveFaultCount != 0) {
        return 0;
    }

    return RtlpWalkFrameChain(Callers, Count, Flags, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\largeint.asm ===
TITLE   "Large Integer Arithmetic"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    largeint.s
;
; Abstract:
;
;    This module implements routines for performing extended integer
;    arithmetic.
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        EXTRNP  _RtlRaiseStatus, 1

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "RtlLargeIntegerAdd"
;++
;
; LARGE_INTEGER
; RtlLargeIntegerAdd (
;    IN LARGE_INTEGER Addend1,
;    IN LARGE_INTEGER Addend2
;    )
;
; Routine Description:
;
;    This function adds a signed large integer to a signed large integer and
;    returns the signed large integer result.
;
; Arguments:
;
;    (TOS+4) = Addend1 - first addend value
;    (TOS+12) = Addend2 - second addend value
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

cPublicProc _RtlLargeIntegerAdd ,4
cPublicFpo 4,0

        mov     eax,[esp]+4             ; (eax)=add1.low
        add     eax,[esp]+12            ; (eax)=sum.low
        mov     edx,[esp]+8             ; (edx)=add1.hi
        adc     edx,[esp]+16            ; (edx)=sum.hi
        stdRET    _RtlLargeIntegerAdd

stdENDP _RtlLargeIntegerAdd


        page
        subttl  "Enlarged Integer Multiply"
;++
;
; LARGE_INTEGER
; RtlEnlargedIntegerMultiply (
;    IN LONG Multiplicand,
;    IN LONG Multiplier
;    )
;
; Routine Description:
;
;    This function multiplies a signed integer by an signed integer and
;    returns a signed large integer result.
;
; Arguments:
;
;    (TOS+4) = Factor1
;    (TOS+8) = Factor2
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

cPublicProc __RtlEnlargedIntegerMultiply ,2
cPublicFpo 2,0

        mov     eax,[esp]+4             ; (eax) = factor1
        imul    dword ptr [esp]+8       ; (edx:eax) = signed result
        stdRET    __RtlEnlargedIntegerMultiply

stdENDP __RtlEnlargedIntegerMultiply


        page
        subttl  "Enlarged Unsigned Integer Multiply"
;++
;
; LARGE_INTEGER
; RtlEnlargedUnsignedMultiply (
;    IN ULONG Multiplicand,
;    IN ULONG Multiplier
;    )
;
; Routine Description:
;
;    This function multiplies an un signed integer by an unsigned integer and
;    returns a signed large integer result.
;
; Arguments:
;
;    (TOS+4) = Factor1
;    (TOS+8) = Factor2
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

cPublicProc __RtlEnlargedUnsignedMultiply ,2
cPublicFpo 2,0

        mov     eax,[esp]+4             ; (eax) = factor1
        mul     dword ptr [esp]+8       ; (edx:eax) = unsigned result
        stdRET    __RtlEnlargedUnsignedMultiply

stdENDP __RtlEnlargedUnsignedMultiply

        page
        subttl  "Enlarged Unsigned Integer Divide"

;++
;
; ULONG
; RtlEnlargedUnsignedDivide (
;    IN ULARGE_INTEGER Dividend,
;    IN ULONG Divisor,
;    IN PULONG Remainder
;    )
;
;
; Routine Description:
;
;    This function divides an unsigned large integer by an unsigned long
;    and returns the resultant quotient and optionally the remainder.
;
; Arguments:
;
;    Dividend - Supplies the dividend value.
;
;    Divisor - Supplies the divisor value.
;
;    Remainder - Supplies an optional pointer to a variable that
;        receives the remainder.
;
; Return Value:
;
;    The unsigned long integer quotient is returned as the function value.
;
;--

cPublicProc __RtlEnlargedUnsignedDivide,4
cPublicFpo 4,0

        mov     eax, [esp+4]            ; (eax) = Dividend.LowPart
        mov     edx, [esp+8]            ; (edx) = Dividend.HighPart
        mov     ecx, [esp+16]           ; (ecx) = pRemainder
        div     dword ptr [esp+12]      ; divide by Divisor

        or      ecx, ecx                ; return remainder?
        jnz     short @f

        stdRET    __RtlEnlargedUnsignedDivide    ; (eax) = Quotient

align 4
@@:     mov     [ecx], edx              ; save remainder
        stdRET    __RtlEnlargedUnsignedDivide    ; (eax) = Quotient

stdENDP __RtlEnlargedUnsignedDivide

        page
        subttl  "Extended Large Integer Divide"

;++
;
; LARGE_INTEGER
; RtlExtendedLargeIntegerDivide (
;     IN LARGE_INTEGER Dividend,
;     IN ULONG Divisor,
;     OUT PULONG Remainder OPTIONAL
;     )
;
; Routine Description:
;
;     This routine divides an unsigned 64 bit dividend by a 32 bit divisor
;     and returns a 64-bit quotient, and optionally the 32-bit remainder.
;
;
; Arguments:
;
;     Dividend - Supplies the 64 bit dividend for the divide operation.
;
;     Divisor - Supplies the 32 bit divisor for the divide operation.
;
;     Remainder - Supplies an optional pointer to a variable which receives
;         the remainder
;
; Return Value:
;
;     The 64-bit quotient is returned as the function value.
;
;--

cPublicProc _RtlExtendedLargeIntegerDivide, 4
cPublicFpo 4,3

        push    esi
        push    edi
        push    ebx

        mov     eax, [esp+16]       ; (eax) = Dividend.LowPart
        mov     edx, [esp+20]       ; (edx) = Dividend.HighPart

lid00:  mov     ebx, [esp+24]       ; (ebx) = Divisor
        or      ebx, ebx
        jz      short lid_zero      ; Attempted a divide by zero

        push    ebp

        mov     ecx, 64             ; Loop count
        xor     esi, esi            ; Clear partial remainder

; (edx:eax) = Dividend
; (ebx) = Divisor
; (ecx) = Loop count
; (esi) = partial remainder

align 4
lid10:  shl     eax, 1              ; (LowPart << 1)  | 0
        rcl     edx, 1              ; (HighPart << 1) | CF
        rcl     esi, 1              ; (Partial << 1)  | CF

        sbb     edi, edi            ; clone CF into edi (0 or -1)

        cmp     esi, ebx            ; check if partial remainder less then divisor
        cmc
        sbb     ebp, ebp            ; clone CF intp ebp
        or      edi, ebp            ; merge with remainder of high bit

        sub     eax, edi            ; merge quotient bit
        and     edi, ebx            ; Select divisor or 0
        sub     esi, edi

        dec     ecx                 ; dec iteration count
        jnz     short lid10         ; go around again

        pop     ebp
        pop     ebx
        pop     edi

        mov     ecx, [esp+20]       ; (ecx) = Remainder
        or      ecx, ecx
        jnz     short lid20

        pop     esi
        stdRET  _RtlExtendedLargeIntegerDivide

align 4
lid20:
        mov     [ecx], esi          ; store remainder
        pop     esi
        stdRET  _RtlExtendedLargeIntegerDivide

lid_zero:
        stdCall _RtlRaiseStatus, <STATUS_INTEGER_DIVIDE_BY_ZERO>

        pop     ebx
        pop     edi
        pop     esi
        stdRET  _RtlExtendedLargeIntegerDivide

stdENDP     _RtlExtendedLargeIntegerDivide

        page
        subttl  "Extended Magic Divide"
;++
;
; LARGE_INTEGER
; RtlExtendedMagicDivide (
;    IN LARGE_INTEGER Dividend,
;    IN LARGE_INTEGER MagicDivisor,
;    IN CCHAR ShiftCount
;    )
;
; Routine Description:
;
;    This function divides a signed large integer by an unsigned large integer
;    and returns the signed large integer result. The division is performed
;    using reciprocal multiplication of a signed large integer value by an
;    unsigned large integer fraction which represents the most significant
;    64-bits of the reciprocal divisor rounded up in its least significant bit
;    and normalized with respect to bit 63. A shift count is also provided
;    which is used to truncate the fractional bits from the result value.
;
; Arguments:
;
;   (ebp+8) = Dividend
;   (ebp+16) = MagicDivisor value is a 64-bit multiplicative reciprocal
;   (ebp+24) = ShiftCount - Right shift adjustment value.
;
; Return Value:
;
;    The large integer result is stored  in (edx:eax)
;
;--

RemdDiv     equ [ebp+8]             ; Dividend
RemdRec     equ [ebp+16]            ; Reciprocal (magic divisor)
RemdShift   equ [ebp+24]
RemdTmp1    equ [ebp-4]
RemdTmp2    equ [ebp-8]
RemdTmp3    equ [ebp-12]

cPublicProc _RtlExtendedMagicDivide ,5

        push    ebp
        mov     ebp,esp
        sub     esp,12
        push    esi

        mov     esi, RemdDiv+4
        test    esi,80000000h
        jz      remd10                  ; no sign, no need to negate

        neg     dword ptr RemdDiv+4
        neg     dword ptr RemdDiv
        sbb     dword ptr RemdDiv+4,0   ; negate

remd10: mov     eax,RemdRec
        mul     dword ptr RemdDiv       ; (edx:eax) = Div.lo * Rec.lo
        mov     RemdTmp1,edx

        mov     eax,RemdRec
        mul     dword ptr RemdDiv+4     ; (edx:eax) = Div.hi * Rec.lo
        mov     RemdTmp2,eax
        mov     RemdTmp3,edx

        mov     eax,RemdRec+4
        mul     dword ptr RemdDiv       ; (edx:eax) = Div.lo * Rec.hi

;
;   Col 0 doesn't matter
;   Col 1 = Hi(Div.lo * Rec.lo) + Low(Div.Hi * Rec.lo) + Low(Div.lo * Rec.hi)
;         = RemdTmp1 + RemdTmp2 + eax
;         -> Only want carry from Col 1
;

        xor     ecx,ecx                 ; (ecx) = 0
        add     eax,RemdTmp1
        adc     ecx, 0                  ; save carry in ecx
        add     eax,RemdTmp2
        adc     ecx, 0                  ; Save Carry, all we want from Col2

        mov     RemdTmp1,edx

        mov     eax,RemdRec+4
        mul     dword ptr RemdDiv+4     ; (edx:eax) = Div.Hi * Rec.Hi

;
;   TOS = carry flag from Col 1
;
;   Col 2 = Col1 CF +
;           Hi(Div.Hi * Rec.Lo) + Hi(Div.Lo * Rec.Hi) + Low(Div.Hi * Rec.Hi)
;         = CF + RemdTmp3 + RemdTmp1 + eax
;
;   Col 3 = Col2 CF + Hi(Div.Hi * Rec.Hi)
;         = CF + edx
;

        add     eax,RemdTmp1
        adc     edx, 0                  ; add carry to edx
        add     eax,RemdTmp3            ; (eax) = col 2
        adc     edx, 0                  ; add carry to edx
        add     eax, ecx
        adc     edx, 0                  ; (edx) = col 3

;
;   (edx:eax) = the high 64 bits of the multiply, shift it right by
;               shift count to discard bits to right of virtual decimal pt.
;
;   RemdShift could be as large as 63 and still not 0 the result, 386
;   will only shift 31 bits at a time, so must do the sift multiple
;   times to get correct effect.
;

        mov     cl,RemdShift
remd20: cmp     cl,31
        jbe     remd30
        sub     cl,31
        shrd    eax,edx,31
        shr     edx,31
        jmp     remd20

remd30: shrd    eax,edx,cl
        shr     edx,cl

;
;   Negate the result if need be
;

        test    esi,80000000h
        jz      remd40                  ; no sign, go return without negate

        neg     edx
        neg     eax
        sbb     edx,0

;
;   Store the result
;

remd40:
        ; results in (edx:eax)

        pop     esi
        mov     esp,ebp
        pop     ebp
        stdRET    _RtlExtendedMagicDivide

stdENDP _RtlExtendedMagicDivide


        page
        subttl  "Extended Integer Multiply"
;++
;
; LARGE_INTEGER
; RtlExtendedIntegerMultiply (
;    IN LARGE_INTEGER Multiplicand,
;    IN ULONG Multiplier
;    )
;
; Routine Description:
;
;    This function multiplies a signed large integer by a signed integer and
;    returns the signed large integer result.
;
; Arguments:
;
;   (ebp+8,12)=multiplican (MCAN)
;   (ebp+16)=multiplier (MPER)
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

ReimMCAN    equ <dword ptr [ebp+8]>
ReimMPER    equ <dword ptr [ebp+16]>

cPublicProc _RtlExtendedIntegerMultiply ,3

        push    ebp
        mov     ebp,esp
        push    esi

        mov     esi,ReimMPER
        xor     esi,ReimMCAN+4              ; (esi) = result sign

        test    ReimMCAN+4,80000000h
        jz      short reim10                ; MCAN pos, go look at MPER

        neg     dword ptr ReimMCAN+4
        neg     dword ptr ReimMCAN
        sbb     dword ptr ReimMCAN+4,0      ; negate multiplican

reim10: test    ReimMPER,80000000h
        jz      short reim20                ; MPER pos, go do multiply

        neg     dword ptr ReimMPER          ; negate multiplier

reim20: mov     eax,ReimMPER
        mul     dword ptr ReimMCAN          ; (edx:eax) = MPER * MCAN.low
        push    edx
        mov     ecx, eax
        mov     eax,ReimMPER
        mul     dword ptr ReimMCAN+4        ; (edx:eax) = MPER * MCAN.high
        add     eax,[esp]                   ; (eax) = hi part of MPER*MCAN.low
                                            ;   plus low part of MPER*MCAN.hi

        test    esi,80000000h
        jz      short reim30                ; result sign is OK, go return

        neg     eax
        neg     ecx
        sbb     eax,0                       ; negate result

reim30: add     esp,4                       ; clean eax off stack
        pop     esi                         ; restore nonvolatile reg
        mov     edx,eax                     ; (edx:ecx) = result
        mov     eax,ecx                     ; (edx:eax) = result

        pop     ebp
        stdRET    _RtlExtendedIntegerMultiply

stdENDP _RtlExtendedIntegerMultiply

        page
        subttl  "Large Integer Shift Left"
;++
;
; LARGE_INTEGER
; RtlLargeIntegerShiftLeft (
;     IN LARGE_INTEGER LargeInteger,
;     IN CCHAR ShiftCount
;     )
;
;
; Routine Description:
;
;     This routine does a left logical shift of a large integer by a
;     specified amount (ShiftCount) modulo 64.
;
; Arguments:
;
;     LargeInteger - Supplies the large integer to be shifted
;
;     ShiftCount - Supplies the left shift count
;
; Return Value:
;
;     LARGE_INTEGER - Receives the shift large integer result
;
;--
cPublicProc _RtlLargeIntegerShiftLeft,3
cPublicFpo 3,0

        mov     ecx, [esp+12]           ; (ecx) = ShiftCount
        and     ecx, 3fh                ; mod 64

        cmp     ecx, 32
        jnc     short sl10
;
;  Shift count is less then 32 bits.
;
        mov     eax, [esp+4]            ; (eax) = LargeInteger.LowPart
        mov     edx, [esp+8]            ; (edx) = LargeInteger.HighPart
        shld    edx, eax, cl
        shl     eax, cl

        stdRET  _RtlLargeIntegerShiftLeft

align 4
sl10:
;
;  Shift count is greater than or equal 32 bits - low half of result is zero,
;  high half is the low half shifted left by remaining count.
;
        mov     edx, [esp+4]            ; (edx) = LargeInteger.LowPart
        xor     eax, eax                ; store lowpart
        shl     edx, cl                 ; store highpart

        stdRET  _RtlLargeIntegerShiftLeft

stdENDP _RtlLargeIntegerShiftLeft

        page
        subttl  "Large Integer Shift Right"

;--
;
;LARGE_INTEGER
;RtlLargeIntegerShiftRight (
;    IN LARGE_INTEGER LargeInteger,
;    IN CCHAR ShiftCount
;    )
;
;Routine Description:
;
;    This routine does a right logical shift of a large integer by a
;    specified amount (ShiftCount) modulo 64.
;
;Arguments:
;
;    LargeInteger - Supplies the large integer to be shifted
;
;    ShiftCount - Supplies the right shift count
;
;Return Value:
;
;    LARGE_INTEGER - Receives the shift large integer result
;
;--*/
cPublicProc _RtlLargeIntegerShiftRight,3
cPublicFpo 3,0

        mov     ecx, [esp+12]           ; (ecx) = ShiftCount
        and     ecx, 3fh                ; mod 64

        cmp     ecx, 32
        jnc     short sr10

;
;  Shift count is less then 32 bits.
;
        mov     eax, [esp+4]            ; (eax) = LargeInteger.LowPart
        mov     edx, [esp+8]            ; (edx) = LargeInteger.HighPart
        shrd    eax, edx, cl
        shr     edx, cl

        stdRET  _RtlLargeIntegerShiftRight

align 4
sr10:
;
;  Shift count is greater than or equal 32 bits - high half of result is zero,
;  low half is the high half shifted right by remaining count.
;
        mov     eax, [esp+8]            ; (eax) = LargeInteger.HighPart
        xor     edx, edx                ; store highpart
        shr     eax, cl                 ; store lowpart

        stdRET  _RtlLargeIntegerShiftRight

stdENDP _RtlLargeIntegerShiftRight

;++
;
;LARGE_INTEGER
;RtlLargeIntegerArithmeticShift (
;    IN LARGE_INTEGER LargeInteger,
;    IN CCHAR ShiftCount
;    )
;
;Routine Description:
;
;    This routine does a right arithmetic shift of a large integer by a
;    specified amount (ShiftCount) modulo 64.
;
;Arguments:
;
;    LargeInteger - Supplies the large integer to be shifted
;
;    ShiftCount - Supplies the right shift count
;
;Return Value:
;
;    LARGE_INTEGER - Receives the shift large integer result
;
;--
cPublicProc _RtlLargeIntegerArithmeticShift,3
cPublicFpo 3,0

        mov     ecx, [esp+12]           ; (ecx) = ShiftCount
        and     ecx, 3fh                ; mod 64

        cmp     ecx, 32
        jc      short sar10

;
;  Shift count is greater than or equal 32 bits - high half of result is sign
;  bit, low half is the high half shifted right by remaining count.
;
        mov     eax, [esp+8]            ; (eax) = LargeInteger.HighPart
        sar     eax, cl                 ; store highpart
        bt      eax, 31                 ; sign bit set?
        sbb     edx, edx                ; duplicate sign bit into highpart

        stdRET  _RtlLargeIntegerArithmeticShift

align 4
sar10:
;
;  Shift count is less then 32 bits.
;
;
        mov     eax, [esp+4]            ; (eax) = LargeInteger.LowPart
        mov     edx, [esp+8]            ; (edx) = LargeInteger.HighPart
        shrd    eax, edx, cl
        sar     edx, cl

        stdRET  _RtlLargeIntegerArithmeticShift

stdENDP _RtlLargeIntegerArithmeticShift,3


        page
        subttl  "Large Integer Negate"
;++
;
; LARGE_INTEGER
; RtlLargeIntegerNegate (
;    IN LARGE_INTEGER Subtrahend
;    )
;
; Routine Description:
;
;    This function negates a signed large integer and returns the signed
;    large integer result.
;
; Arguments:
;
;   (TOS+4) = Subtrahend
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

cPublicProc _RtlLargeIntegerNegate  ,2
cPublicFpo 2,0

        mov     eax,[esp]+4             ; (eax) = lo
        mov     edx,[esp]+8
        neg     edx                     ; (edx) = 2's comp of hi part
        neg     eax                     ; if ((eax) == 0) CF = 0
                                        ; else CF = 1
        sbb     edx,0                   ; (edx) = (edx) - CF
                                        ; (edx:eax) = result
        stdRET    _RtlLargeIntegerNegate

stdENDP _RtlLargeIntegerNegate


        page
        subttl  "Large Integer Subtract"
;++
;
; LARGE_INTEGER
; RtlLargeIntegerSubtract (
;    IN LARGE_INTEGER Minuend,
;    IN LARGE_INTEGER Subtrahend
;    )
;
; Routine Description:
;
;    This function subtracts a signed large integer from a signed large
;    integer and returns the signed large integer result.
;
; Arguments:
;
;    (TOS+4) = Minuend
;    (TOS+12) = Subtrahend
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

cPublicProc _RtlLargeIntegerSubtract    ,4
cPublicFpo 4,0

        mov     eax,[esp]+4
        sub     eax,[esp]+12            ; (eax) = result.low
        mov     edx,[esp]+8
        sbb     edx,[esp]+16            ; (edx) = result.high
        stdRET    _RtlLargeIntegerSubtract

stdENDP _RtlLargeIntegerSubtract

        page
        subttl  "Convert Long to Large Integer"
;++
;
; LARGE_INTEGER
; RtlConvertLongToLargeInteger (
;     IN LONG SignedInteger
;     )
;
; Routine Description:
;
;     This function converts the input signed integer to a signed large
;     integer and returns the latter as the result.
;
; Arguments:
;
;   (TOS+4) = SignedInteger
;
; Return Value:
;
;    The large integer result is stored (edx:eax)
;
;--

cPublicProc ___RtlConvertLongToLargeInteger   ,1
cPublicFpo 1,0

        mov     eax,[esp]+4             ; (eax) = SignedInteger
        cdq                             ; (edx:eax) = signed LargeInt
        stdRET    ___RtlConvertLongToLargeInteger

stdENDP ___RtlConvertLongToLargeInteger


        page
        subttl  "Convert Ulong to Large Integer"
;++
;
; LARGE_INTEGER
; RtlConvertUlongToLargeInteger (
;     IN LONG UnsignedInteger
;     )
;
; Routine Description:
;
;     This function converts the input unsigned integer to a signed large
;     integer and returns the latter as the result.
;
; Arguments:
;
;   (TOS+4) = UnsignedInteger
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

cPublicProc ___RtlConvertUlongToLargeInteger  ,1
cPublicFpo 1,0

        mov     eax,[esp]+4             ; store low
        xor     edx,edx                 ; store 0 in high
        stdRET    ___RtlConvertUlongToLargeInteger

stdENDP ___RtlConvertUlongToLargeInteger


_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\ioaccess.asm ===
title  "ioaccess"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    ioaccess.asm
;
; Abstract:
;
;    Procedures to correctly touch I/O registers.
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;++
;
; I/O memory space read and write functions.
;
;  These have to be actual functions on the 386, because we need
;  to use assembler, but cannot return a value if we inline it.
;
;  This set of functions manipulates I/O registers in MEMORY space.
;  (Uses x86 mov instructions)
;
;--



;++
;
;   UCHAR
;   READ_REGISTER_UCHAR(
;       PUCHAR  Register
;       )
;
;   Memory space references will use lock prefix to force real access,
;   flush through posted write buffers, and so forth.
;
;   Arguments:
;       (esp+4) = Register
;
;   Returns:
;       Value in register.
;
;--
cPublicProc _READ_REGISTER_UCHAR ,1
cPublicFpo 1,0

        mov     edx,[esp+4]             ; (edx) = Register
        mov     al,[edx]                ; (al) = byte, lock forces real access
        stdRET    _READ_REGISTER_UCHAR

stdENDP _READ_REGISTER_UCHAR



;++
;
;   USHORT
;   READ_REGISTER_USHORT(
;       PUSHORT Register
;       )
;
;   Memory space references will use lock prefix to force real access,
;   flush through posted write buffers, and so forth.
;
;   Arguments:
;       (esp+4) = Register
;
;   Returns:
;       Value in register.
;
;--
cPublicProc _READ_REGISTER_USHORT ,1
cPublicFpo 1,0

        mov     edx,[esp+4]             ; (edx) = Register
        mov     ax,[edx]                ; (ax) = word, lock forces real access
        stdRET    _READ_REGISTER_USHORT

stdENDP _READ_REGISTER_USHORT



;++
;
;   ULONG
;   READ_REGISTER_ULONG(
;       PULONG  Register
;       )
;
;   Memory space references will use lock prefix to force real access,
;   flush through posted write buffers, and so forth.
;
;   Arguments:
;       (esp+4) = Register
;
;   Returns:
;       Value in register.
;
;--
cPublicProc _READ_REGISTER_ULONG ,1
cPublicFpo 1,0

        mov     edx,[esp+4]             ; (edx) = Register
        mov     eax,[edx]               ; (eax) = dword, lock forces real access
        stdRET    _READ_REGISTER_ULONG

stdENDP _READ_REGISTER_ULONG


;++
;
;   VOID
;   READ_REGISTER_BUFFER_UCHAR(
;       PUCHAR  Register,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_REGISTER_BUFFER_UCHAR ,3
cPublicFpo 3,0

        mov     eax, esi
        mov     edx, edi                ; Save esi, edi

        mov     ecx,[esp+12]            ; (ecx) = transfer count
        mov     esi,[esp+4]             ; (edx) = Register
        mov     edi,[esp+8]             ; (edi) = buffer
    rep movsb

        mov     edi, edx
        mov     esi, eax

        stdRET    _READ_REGISTER_BUFFER_UCHAR

stdENDP _READ_REGISTER_BUFFER_UCHAR


;++
;
;   VOID
;   READ_REGISTER_BUFFER_USHORT(
;       PUSHORT Register,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_REGISTER_BUFFER_USHORT ,3
cPublicFpo 3,0

        mov     eax, esi
        mov     edx, edi                ; Save esi, edi

        mov     ecx,[esp+12]            ; (ecx) = transfer count
        mov     esi,[esp+4]             ; (edx) = Register
        mov     edi,[esp+8]             ; (edi) = buffer
    rep movsw

        mov     edi, edx
        mov     esi, eax
        stdRET    _READ_REGISTER_BUFFER_USHORT

stdENDP _READ_REGISTER_BUFFER_USHORT


;++
;
;   VOID
;   READ_REGISTER_BUFFER_ULONG(
;       PULONG  Register,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_REGISTER_BUFFER_ULONG ,3
cPublicFpo 3,0

        mov     eax, esi
        mov     edx, edi                ; Save esi, edi

        mov     ecx,[esp+12]            ; (ecx) = transfer count
        mov     esi,[esp+4]             ; (edx) = Register
        mov     edi,[esp+8]             ; (edi) = buffer
    rep movsd

        mov     edi, edx
        mov     esi, eax
        stdRET    _READ_REGISTER_BUFFER_ULONG

stdENDP _READ_REGISTER_BUFFER_ULONG



;++
;
;   VOID
;   WRITE_REGISTER_UCHAR(
;       PUCHAR  Register,
;       UCHAR   Value
;       )
;
;   Memory space references will use lock prefix to force real access,
;   flush through posted write buffers, and so forth.
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Value
;
;--
cPublicProc _WRITE_REGISTER_UCHAR ,2
cPublicFpo 2,0

        mov     edx,[esp+4]             ; (edx) = Register
        mov     al,[esp+8]              ; (al) = Value
        mov     [edx],al                ; do write
   lock or      [esp+4],edx     ; flush processors posted-write buffers
        stdRET    _WRITE_REGISTER_UCHAR

stdENDP _WRITE_REGISTER_UCHAR



;++
;
;   VOID
;   WRITE_REGISTER_USHORT(
;       PUSHORT Register,
;       USHORT  Value
;       )
;
;   Memory space references will use lock prefix to force real access,
;   flush through posted write buffers, and so forth.
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Value
;
;--
cPublicProc _WRITE_REGISTER_USHORT ,2
cPublicFpo 2,0

        mov     edx,[esp+4]             ; (edx) = Register
        mov     eax,[esp+8]             ; (ax) = Value
        mov     [edx],ax                ; do write
   lock or      [esp+4],edx     ; flush processors posted-write buffers
        stdRET    _WRITE_REGISTER_USHORT

stdENDP _WRITE_REGISTER_USHORT



;++
;
;   VOID
;   WRITE_REGISTER_ULONG(
;       PULONG  Register,
;       ULONG   Value
;       )
;
;   Memory space references will use lock prefix to force real access,
;   flush through posted write buffers, and so forth.
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Value
;
;--
cPublicProc _WRITE_REGISTER_ULONG ,2
cPublicFpo 2,0

        mov     edx,[esp+4]             ; (edx) = Register
        mov     eax,[esp+8]             ; (eax) = Value
        mov     [edx],eax               ; do write
   lock or      [esp+4],edx     ; flush processors posted-write buffers
        stdRET    _WRITE_REGISTER_ULONG

stdENDP _WRITE_REGISTER_ULONG


;++
;
;   VOID
;   WRITE_REGISTER_BUFFER_UCHAR(
;       PUCHAR  Register,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_REGISTER_BUFFER_UCHAR ,3
cPublicFpo 3,0

        mov     eax, esi
        mov     edx, edi                ; Save esi, edi

        mov     ecx,[esp+12]            ; (ecx) = transfer count
        mov     esi,[esp+8]             ; (edi) = buffer
        mov     edi,[esp+4]             ; (edx) = Register
    rep movsb
   lock or      [esp+4],ecx     ; flush processors posted-write buffers

        mov     edi, edx
        mov     esi, eax

        stdRET    _WRITE_REGISTER_BUFFER_UCHAR

stdENDP _WRITE_REGISTER_BUFFER_UCHAR


;++
;
;   VOID
;   WRITE_REGISTER_BUFFER_USHORT(
;       PUSHORT Register,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_REGISTER_BUFFER_USHORT ,3
cPublicFpo 3,0

        mov     eax, esi
        mov     edx, edi                ; Save esi, edi

        mov     ecx,[esp+12]            ; (ecx) = transfer count
        mov     esi,[esp+8]             ; (edi) = buffer
        mov     edi,[esp+4]             ; (edx) = Register
    rep movsw
   lock or      [esp+4],ecx     ; flush processors posted-write buffers

        mov     edi, edx
        mov     esi, eax
        stdRET    _WRITE_REGISTER_BUFFER_USHORT

stdENDP _WRITE_REGISTER_BUFFER_USHORT


;++
;
;   VOID
;   WRITE_REGISTER_BUFFER_ULONG(
;       PULONG  Register,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Register
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_REGISTER_BUFFER_ULONG ,3
cPublicFpo  0, 3

;FPO ( 0, 3, 0, 0, 0, 0 )

        mov     eax, esi
        mov     edx, edi                ; Save esi, edi

        mov     ecx,[esp+12]            ; (ecx) = transfer count
        mov     esi,[esp+8]             ; (edi) = buffer
        mov     edi,[esp+4]             ; (edx) = Register
    rep movsd
   lock or      [esp+4],ecx     ; flush processors posted-write buffers

        mov     edi, edx
        mov     esi, eax
        stdRET    _WRITE_REGISTER_BUFFER_ULONG

stdENDP _WRITE_REGISTER_BUFFER_ULONG

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\movemem.asm ===
title  "User Mode Zero and Move Memory functions"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    movemem.asm
;
; Abstract:
;
;    This module implements functions to zero and copy blocks of memory
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

if DBG
_DATA   SEGMENT  DWORD PUBLIC 'DATA'

    public _RtlpZeroCount
    public _RtlpZeroBytes

_RtlpZeroCount dd 0
_RtlpZeroBytes dd 0

_MsgUnalignedPtr    db  'RTL: RtlCompare/FillMemoryUlong called with unaligned pointer (%x)\n',0
_MsgUnalignedCount  db  'RTL: RtlCompare/FillMemoryUlong called with unaligned count (%x)\n',0

_DATA ENDS

        extrn   _KdDebuggerEnabled:BYTE
        EXTRNP  _DbgBreakPoint,0
        extrn   _DbgPrint:near
endif

;
; Alignment parameters for zeroing and moving memory.
;

ZERO_MEMORY_ALIGNMENT = 4
ZERO_MEMORY_ALIGNMENT_LOG2 = 2
ZERO_MEMORY_ALIGNMENT_MASK = ZERO_MEMORY_ALIGNMENT - 1

MEMORY_ALIGNMENT = 4
MEMORY_ALIGNMENT_LOG2 = 2
MEMORY_ALIGNMENT_MASK = MEMORY_ALIGNMENT - 1


;
; Alignment for functions in this module
;

CODE_ALIGNMENT macro
    align   16
endm


_TEXT$00   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl "RtlCompareMemory"
;++
;
; ULONG
; RtlCompareMemory (
;    IN PVOID Source1,
;    IN PVOID Source2,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function compares two blocks of memory and returns the number
;    of bytes that compared equal.
;
; Arguments:
;
;    Source1 (esp+4) - Supplies a pointer to the first block of memory to
;       compare.
;
;    Source2 (esp+8) - Supplies a pointer to the second block of memory to
;       compare.
;
;    Length (esp+12) - Supplies the Length, in bytes, of the memory to be
;       compared.
;
; Return Value:
;
;    The number of bytes that compared equal is returned as the function
;    value. If all bytes compared equal, then the length of the original
;    block of memory is returned.
;
;--

RcmSource1      equ     [esp+12]
RcmSource2      equ     [esp+16]
RcmLength       equ     [esp+20]

CODE_ALIGNMENT
cPublicProc _RtlCompareMemory,3
cPublicFpo 3,0

        push    esi                     ; save registers
        push    edi                     ;
        cld                             ; clear direction
        mov     esi,RcmSource1          ; (esi) -> first block to compare
        mov     edi,RcmSource2          ; (edi) -> second block to compare

;
;   Compare dwords, if any.
;

rcm10:  mov     ecx,RcmLength           ; (ecx) = length in bytes
        shr     ecx,2                   ; (ecx) = length in dwords
        jz      rcm20                   ; no dwords, try bytes
        repe    cmpsd                   ; compare dwords
        jnz     rcm40                   ; mismatch, go find byte

;
;   Compare residual bytes, if any.
;

rcm20:  mov     ecx,RcmLength           ; (ecx) = length in bytes
        and     ecx,3                   ; (ecx) = length mod 4
        jz      rcm30                   ; 0 odd bytes, go do dwords
        repe    cmpsb                   ; compare odd bytes
        jnz     rcm50                   ; mismatch, go report how far we got

;
;   All bytes in the block match.
;

rcm30:  mov     eax,RcmLength           ; set number of matching bytes
        pop     edi                     ; restore registers
        pop     esi                     ;
        stdRET  _RtlCompareMemory

;
;   When we come to rcm40, esi (and edi) points to the dword after the
;   one which caused the mismatch.  Back up 1 dword and find the byte.
;   Since we know the dword didn't match, we can assume one byte won't.
;

rcm40:  sub     esi,4                   ; back up
        sub     edi,4                   ; back up
        mov     ecx,5                   ; ensure that ecx doesn't count out
        repe    cmpsb                   ; find mismatch byte

;
;   When we come to rcm50, esi points to the byte after the one that
;   did not match, which is TWO after the last byte that did match.
;

rcm50:  dec     esi                     ; back up
        sub     esi,RcmSource1          ; compute bytes that matched
        mov     eax,esi                 ;
        pop     edi                     ; restore registers
        pop     esi                     ;
        stdRET  _RtlCompareMemory

stdENDP _RtlCompareMemory


       subttl  "RtlCompareMemory"
EcmlSource       equ     [esp + 4 + 4]
EcmlLength       equ     [esp + 4 + 8]
EcmlPattern      equ     [esp + 4 + 12]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlCompareMemoryUlong  ,3

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     edi,EcmlSource
if DBG
        test    edi,3
        jz      @F
        push    edi
        push    offset FLAT:_MsgUnalignedPtr
        call    _DbgPrint
        add     esp, 2 * 4
        cmp     _KdDebuggerEnabled,0
        je      @F
        call    _DbgBreakPoint@0
@@:
endif
        mov     ecx,EcmlLength
        mov     eax,EcmlPattern
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to compare is non-zero, then do it.
;

        repe    scasd
        je      @F
        sub     edi,4
@@:
        sub     edi,EcmlSource
        mov     eax,edi
        pop     edi
        stdRET    _RtlCompareMemoryUlong

stdENDP _RtlCompareMemoryUlong


       subttl  "RtlFillMemory"
;++
;
; VOID
; RtlFillMemory (
;    IN PVOID Destination,
;    IN ULONG Length,
;    IN UCHAR Fill
;    )
;
; Routine Description:
;
;    This function fills memory with a byte value.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
;    Fill - Supplies the byte value to fill memory with.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EfmDestination  equ     [esp + 4 + 4]
EfmLength       equ     [esp + 4 + 8]
EfmFill         equ     byte ptr [esp + 4 + 12]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlFillMemory  ,3
cPublicFpo 3,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     edi,EfmDestination
        mov     ecx,EfmLength
        mov     al,EfmFill
        mov     ah,al
        shl     eax,16
        mov     al,EfmFill
        mov     ah,al
        cld

        mov     edx,ecx
        and     edx,ZERO_MEMORY_ALIGNMENT_MASK
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to zero is non-zero, then do it.
;

        rep     stosd

;
; If number of extra 8-bit bytes to zero is non-zero, then do it.  In either
; case restore non-volatile registers and return.
;

        or      ecx,edx
        jnz     @F
        pop     edi
        stdRET    _RtlFillMemory
@@:
        rep     stosb
        pop     edi
        stdRET    _RtlFillMemory

stdENDP _RtlFillMemory

       subttl  "RtlFillMemory"
;++
;
; VOID
; RtlFillMemoryUlonglong (
;    IN PVOID Destination,
;    IN ULONG Length,
;    IN ULONG Fill
;    )
;
; Routine Description:
;
;    This function fills memory with a 64-bit value.  The Destination pointer
;    must be aligned on an 8 byte boundary and the low order two bits of the
;    Length parameter are ignored.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
;    Fill - Supplies the 64-bit value to fill memory with.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EfmlDestination  equ     [esp + 0ch]
EfmlLength       equ     [esp + 10h]
EfmlFillLow      equ     [esp + 14h]
EfmlFillHigh     equ     [esp + 18h]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlFillMemoryUlonglong  ,4
cPublicFpo 4,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    esi
        push    edi

;
; Setup the registers for using REP MOVSD instruction to zero memory.
;
;   edi -> memory to fill
;   esi -> first 8 byte chunk of the memory destination to fill
;   ecx = number of 32-bit words to zero
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     ecx,EfmlLength              ; # of bytes
        mov     esi,EfmlDestination         ; Destination pointer

if DBG
        test    ecx,7
        jz      @F
        push    ecx
        push    offset FLAT:_MsgUnalignedPtr
        call    _DbgPrint
        add     esp, 2 * 4
        mov     ecx,EfmlLength              ; # of bytes
        cmp     _KdDebuggerEnabled,0
        je      @F
        call    _DbgBreakPoint@0
@@:

        test    esi,3
        jz      @F
        push    esi
        push    offset FLAT:_MsgUnalignedPtr
        call    _DbgPrint
        add     esp, 2 * 4
        cmp     _KdDebuggerEnabled,0
        je      @F
        call    _DbgBreakPoint@0
@@:
endif
        mov     eax,EfmlFillLow             ; get low portion of the fill arg
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2      ; convert bytes to dwords
        sub     ecx,2                       ; doing the 1st one by hand
        mov     [esi],eax                   ; fill 1st highpart
        mov     eax,EfmlFillHigh            ; get high portion of the fill arg
        lea     edi,[esi+08]                ; initialize the dest pointer
        mov     [esi+04],eax                ; fill 1st lowpart

        rep     movsd                       ; ripple the rest

        pop     edi
        pop     esi
        stdRET    _RtlFillMemoryUlonglong

stdENDP _RtlFillMemoryUlonglong

       subttl  "RtlZeroMemory"
;++
;
; VOID
; RtlFillMemoryUlong (
;    IN PVOID Destination,
;    IN ULONG Length,
;    IN ULONG Fill
;    )
;
; Routine Description:
;
;    This function fills memory with a 32-bit value.  The Destination pointer
;    must be aligned on a 4 byte boundary and the low order two bits of the
;    Length parameter are ignored.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
;    Fill - Supplies the 32-bit value to fill memory with.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EfmlDestination  equ     [esp + 4 + 4]
EfmlLength       equ     [esp + 4 + 8]
EfmlFill         equ     [esp + 4 + 12]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlFillMemoryUlong  ,3
cPublicFpo 3,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     edi,EfmlDestination
if DBG
        test    edi,3
        jz      @F
        push    edi
        push    offset FLAT:_MsgUnalignedPtr
        call    _DbgPrint
        add     esp, 2 * 4
        cmp     _KdDebuggerEnabled,0
        je      @F
        call    _DbgBreakPoint@0
@@:
endif
        mov     ecx,EfmlLength
        mov     eax,EfmlFill
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to zero is non-zero, then do it.
;

        rep     stosd

        pop     edi
        stdRET    _RtlFillMemoryUlong

stdENDP _RtlFillMemoryUlong

       subttl  "RtlZeroMemory"
;++
;
; VOID
; RtlZeroMemory (
;    IN PVOID Destination,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function zeros memory.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EzmDestination  equ     [esp + 4 + 4]
EzmLength       equ     [esp + 4 + 8]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlZeroMemory  ,2
cPublicFpo 2,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = zero (value to store in destination)
;   direction flag is clear for auto-increment
;

        mov     edi,EzmDestination
        mov     ecx,EzmLength
        xor     eax,eax
        cld

        mov     edx,ecx
        and     edx,ZERO_MEMORY_ALIGNMENT_MASK
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to zero is non-zero, then do it.
;

        rep     stosd

;
; If number of extra 8-bit bytes to zero is non-zero, then do it.  In either
; case restore non-volatile registers and return.
;

        or      ecx,edx
        jnz     @F
        pop     edi
        stdRET    _RtlZeroMemory
@@:
        rep     stosb
        pop     edi
        stdRET    _RtlZeroMemory

stdENDP _RtlZeroMemory

        page , 132
        subttl  "RtlMoveMemory"
;++
;
; VOID
; RtlMoveMemory (
;    IN PVOID Destination,
;    IN PVOID Source OPTIONAL,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function moves memory either forward or backward, aligned or
;    unaligned, in 4-byte blocks, followed by any remaining bytes.
;
; Arguments:
;
;    Destination - Supplies a pointer to the destination of the move.
;
;    Source - Supplies a pointer to the memory to move.
;
;    Length - Supplies the Length, in bytes, of the memory to be moved.
;
; Return Value:
;
;    None.
;
;--

; Definitions of arguments
; (TOS) = Return address

EmmDestination  equ     [esp + 8 + 4]
EmmSource       equ     [esp + 8 + 8]
EmmLength       equ     [esp + 8 + 12]

; End of arguments

CODE_ALIGNMENT
cPublicProc _RtlMoveMemory  ,3
cPublicFpo 3,2

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    esi
        push    edi

;
; Setup the registers for using REP MOVS instruction to move memory.
;
;   esi -> memory to move (NULL implies the destination will be zeroed)
;   edi -> destination of move
;   ecx = number of 32-bit words to move
;   edx = number of extra 8-bit bytes to move at the end (0 - 3)
;   direction flag is clear for auto-increment
;

        mov     esi,EmmSource
        mov     edi,EmmDestination
        mov     ecx,EmmLength
if DBG
        inc     _RtlpZeroCount
        add     _RtlpZeroBytes,ecx
endif
        cld

        cmp     esi,edi                 ; Special case if Source > Destination
        jbe     overlap

nooverlap:
        mov     edx,ecx
        and     edx,MEMORY_ALIGNMENT_MASK
        shr     ecx,MEMORY_ALIGNMENT_LOG2

;
; If number of 32-bit words to move is non-zero, then do it.
;

        rep     movsd

;
; If number of extra 8-bit bytes to move is non-zero, then do it.  In either
; case restore non-volatile registers and return.
;

        or      ecx,edx
        jnz     @F
        pop     edi
        pop     esi
        stdRET    _RtlMoveMemory
@@:
        rep     movsb

movedone:
        pop     edi
        pop     esi
        stdRET    _RtlMoveMemory

;
; Here to handle special case when Source > Destination and therefore is a
; potential overlapping move.  If Source == Destination, then nothing to do.
; Otherwise, increment the Source and Destination pointers by Length and do
; the move backwards, a byte at a time.
;

overlap:
        je      movedone
        mov     eax,edi
        sub     eax,esi
        cmp     ecx,eax
        jbe     nooverlap

        std
        add     esi,ecx
        add     edi,ecx
        dec     esi
        dec     edi
        rep     movsb
        cld
        jmp     short movedone

stdENDP _RtlMoveMemory

       subttl  "RtlCopyMemoryNonTemporal"
;
; Register Definitions (for instruction macros).
;

rEAX            equ     0
rECX            equ     1
rEDX            equ     2
rEBX            equ     3
rESP            equ     4
rEBP            equ     5
rESI            equ     6
rEDI            equ     7

MEMORY_ALIGNMENT_MASK0  = 63
MEMORY_ALIGNMENT_LOG2_0 = 6

MEMORY_ALIGNMENT_MASK1  = 3
MEMORY_ALIGNMENT_LOG2_1 = 2

sfence            macro
                   db      0FH, 0AEH, 0F8H
                  endm

prefetchnta_short macro   GeneralReg, Offset
                   db      0FH, 018H,  040H + GeneralReg, Offset
                  endm

prefetchnta_long  macro   GeneralReg, Offset
                   db      0FH, 018H,  080h + GeneralReg
                   dd      Offset
                  endm

movnti_eax        macro   GeneralReg, Offset
                   db  0FH, 0C3H, 040H + GeneralReg, Offset
                  endm

movnti_eax_0_disp macro   GeneralReg
                   db  0FH, 0C3H, 000H + GeneralReg
                  endm

movnti_ebx        macro   GeneralReg, Offset
                   db  0FH, 0C3H, 058H + GeneralReg, Offset
                  endm

;
;
; Macro that moves 64bytes (1 cache line using movnti (eax and ebx registers)
;
;

movnticopy64bytes  macro
                    mov    eax, [esi]
                    mov    ebx, [esi + 4]
                    movnti_eax_0_disp rEDI
                    movnti_ebx rEDI, 4

                    mov    eax, [esi + 8]
                    mov    ebx, [esi + 12]
                    movnti_eax rEDI, 8
                    movnti_ebx rEDI, 12

                    mov    eax, [esi + 16]
                    mov    ebx, [esi + 20]
                    movnti_eax rEDI, 16
                    movnti_ebx rEDI, 20

                    mov    eax, [esi + 24]
                    mov    ebx, [esi + 28]
                    movnti_eax rEDI, 24
                    movnti_ebx rEDI, 28

                    mov    eax, [esi + 32]
                    mov    ebx, [esi + 36]
                    movnti_eax rEDI,32
                    movnti_ebx rEDI, 36

                    mov    eax, [esi + 40]
                    mov    ebx, [esi + 44]
                    movnti_eax rEDI, 40
                    movnti_ebx rEDI,  44

                    mov    eax, [esi + 48]
                    mov    ebx, [esi + 52]
                    movnti_eax rEDI,48
                    movnti_ebx rEDI, 52

                    mov    eax, [esi + 56]
                    mov    ebx, [esi + 60]
                    movnti_eax rEDI, 56
                    movnti_ebx rEDI, 60
                  endm


;++
;
; VOID
; RtlCopyMemoryNonTemporal(
;    IN PVOID Destination,
;    IN PVOID Source ,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;   This function copies nonoverlapping from one buffer to another
;   using nontemporal moves that do not pollute the cache.
;
; Arguments:
;
;    Destination - Supplies a pointer to the destination of the move.
;
;    Source - Supplies a pointer to the memory to move.
;
;    Length - Supplies the Length, in bytes, of the memory to be moved.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _RtlCopyMemoryNonTemporal ,3  

; Definitions of arguments
; (TOS) = Return address

CPNDestination  equ     [ebp + 4 + 4]
CPNSource       equ     [ebp + 4 + 8]
CPNLength       equ     [ebp + 4 + 12]

        push    ebp
        mov     ebp, esp
        push    esi
        push    edi
        push    ebx
       
        mov     esi, CPNSource
        mov     edi, CPNDestination
        mov     ecx, CPNLength


;
; Before prefetching we must guarantee the TLB is valid.
;
        mov     eax, [esi]

        cld

;
;Check if less than 64 bytes 
;
 
        mov     edx, ecx
        and     ecx, MEMORY_ALIGNMENT_MASK0
        shr     edx, MEMORY_ALIGNMENT_LOG2_0
        je      Copy4
        dec     edx
        je      copy64

        prefetchnta_short rESI, 128
        dec     edx
        je      copy128

        prefetchnta_short rESI, 192
        dec     edx
        je      copy192


         
copyLoop:

        prefetchnta_long rESI, 256

        movnticopy64bytes
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]
        
        dec     edx
        jnz     copyLoop


copy192:


        movnticopy64bytes
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]
       
copy128:


        movnticopy64bytes
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]

copy64:

        movnticopy64bytes

        or     ecx, ecx  ; anything less than 64 to do?
        jz     ExitRoutine

        prefetchnta_short rESI, 0
;
;Update pointer for last copy    
;
        
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]

;
;Handle extra bytes here in 32 bit chuncks and then 8-bit bytes    
;

Copy4:
         mov    edx, ecx
         and    ecx, MEMORY_ALIGNMENT_MASK1
         shr    edx, MEMORY_ALIGNMENT_LOG2_1

;
; If the number of 32-bit words to move is non-zero, then do it
;         
         jz     RemainingBytes 

Copy4Loop:
         mov    eax, [esi]
         movnti_eax_0_disp rEDI
         lea    esi, [esi+4]
         lea    edi, [edi+4]
         dec    edx
         jnz    Copy4Loop
         
RemainingBytes:
         or     ecx, ecx
         jz     ExitRoutine
         rep     movsb

ExitRoutine:     

        sfence            ;Make all stores globally visible 
        pop     ebx
        pop     edi
        pop     esi
        pop     ebp
        stdRET  _RtlCopyMemoryNonTemporal 

stdENDP _RtlCopyMemoryNonTemporal

       subttl  "RtlPrefetchMemoryNonTemporal"

;++
;
; VOID
; FASTCALL
; RtlPrefetchMemoryNonTemporal(
;    IN PVOID Source,
;    IN SIZE_T Length
;    )
;
; Routine Description:
;
;   This function prefetches memory at Source, for Length bytes into the
;   closest cache to the processor.
;
; Arguments:
;
;    Source - Supplies a pointer to the memory to prefetch.
;
;    Length - Supplies the Length, in bytes, of the memory to be moved.
;
; Return Value:
;
;    None.
;
;--

        extrn   _KePrefetchNTAGranularity:DWORD

cPublicFastCall RtlPrefetchMemoryNonTemporal ,2

;
; The following instruction will be patched out at boot time if
; this processor supports the prefetch instruction.
;

        ret                                 ; patched out at boot.

        mov     eax, _KePrefetchNTAGranularity  ; get d-cache line size
@@:     prefetchnta_short rECX, 0           ; prefetch line
        add     ecx, eax                    ; bump prefetch address
        sub     edx, eax                    ; decrement length
        ja      short @b                    ; loop if more to get

        fstRET  RtlPrefetchMemoryNonTemporal ; return

fstENDP RtlPrefetchMemoryNonTemporal


_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\getcalr.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    getcalr.c

Abstract:

    This module contains routines to get runtime stack traces 
    for the x86 architecture.

--*/

#include <ntos.h>
#include <ntrtl.h>
#include "ntrtlp.h"
#include <nturtl.h>
#include <zwapi.h>
#include <stktrace.h>

//
// Forward declarations.
//

BOOLEAN
RtlpCaptureStackLimits (
    ULONG_PTR HintAddress,
    PULONG_PTR StartStack,
    PULONG_PTR EndStack
    );

BOOLEAN
RtlpStkIsPointerInDllRange (
    ULONG_PTR Value
    );

BOOLEAN
RtlpStkIsPointerInNtdllRange (
    ULONG_PTR Value
    );

VOID
RtlpCaptureContext (
    OUT PCONTEXT ContextRecord
    );

BOOLEAN
NtdllOkayToLockRoutine(
    IN PVOID Lock
    );

ULONG
RtlpWalkFrameChainExceptionFilter (
    ULONG ExceptionCode,
    PVOID ExceptionRecord
    );

//
// Fuzzy stack traces
//

ULONG
RtlpWalkFrameChainFuzzy (
    OUT PVOID *Callers,
    IN ULONG Count
    );


/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// RtlCaptureStackBackTrace
/////////////////////////////////////////////////////////////////////

USHORT
RtlCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    This routine walks up the stack frames, capturing the return address from
    each frame requested.

Arguments:

    FramesToSkip - frames detected but not included in the stack trace

    FramesToCapture - frames to be captured in the stack trace buffer.
        One of the frames will be for RtlCaptureStackBackTrace.

    BackTrace - stack trace buffer

    BackTraceHash - very simple hash value that can be used to organize
      hash tables. It is just an arithmetic sum of the pointers in the
      stack trace buffer. If NULL then no hash value is computed.

Return Value:

     Number of return addresses returned in the stack trace buffer.

--*/
{
    PVOID Trace [2 * MAX_STACK_DEPTH];
    ULONG FramesFound;
    ULONG HashValue;
    ULONG Index;

    //
    // One more frame to skip for the "capture" function (RtlWalkFrameChain).
    //

    FramesToSkip += 1;

    //
    // Sanity checks.
    //

    if (FramesToCapture + FramesToSkip >= 2 * MAX_STACK_DEPTH) {
        return 0;
    }

    FramesFound = RtlWalkFrameChain (Trace,
                                     FramesToCapture + FramesToSkip,
                                     0);

    if (FramesFound <= FramesToSkip) {
        return 0;
    }

    Index = 0;

    for (HashValue = 0; Index < FramesToCapture; Index++) {

        if (FramesToSkip + Index >= FramesFound) {
            break;
        }

        BackTrace[Index] = Trace[FramesToSkip + Index];
        HashValue += PtrToUlong(BackTrace[Index]);
    }

    if (BackTraceHash != NULL) {

        *BackTraceHash = HashValue;
    }

    //
    // Zero the temporary buffer used to get the stack trace
    // so that we do not leave garbage on the stack. This will
    // improve debugging when we need to look manually at a stack.
    //
    // N.B. We cannot use here a simple call to RtlZeroMemory because the
    //      compiler will optimize away that call since it is performed 
    //      for a buffer that gets out of scope. 
    //
    
    {
        volatile PVOID * Pointer = (volatile PVOID *)Trace;
        SIZE_T Count = sizeof(Trace) / sizeof (PVOID);

        while (Count > 0) {

            *Pointer = NULL;

            Pointer += 1;
            Count -= 1;
        }
    }

    return (USHORT)Index;
}



/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// RtlWalkFrameChain
/////////////////////////////////////////////////////////////////////

#define SIZE_1_KB  ((ULONG_PTR) 0x400)
#define SIZE_1_GB  ((ULONG_PTR) 0x40000000)

#define PAGE_START(address) (((ULONG_PTR)address) & ~((ULONG_PTR)PAGE_SIZE - 1))

#if FPO
#pragma optimize( "y", off ) // disable FPO
#endif

ULONG
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags
    )

/*++

Routine Description:

    This function tries to walk the EBP chain and fill out a vector of
    return addresses. It is possible that the function cannot fill the
    requested number of callers. In this case the function will just return
    with a smaller stack trace. In kernel mode the function should not take
    any exceptions (page faults) because it can be called at all sorts of
    irql levels.

    The `Flags' parameter is used for future extensions. A zero value will be
    compatible with new stack walking algorithms.
    
    A value of 1 for `Flags' means we are running in K-mode and we want to get
    the user mode stack trace.

Return value:

    The number of identified return addresses on the stack. This can be less
    then the Count requested.

--*/

{

    ULONG_PTR Fp, NewFp, ReturnAddress;
    ULONG Index;
    ULONG_PTR StackEnd, StackStart;
    BOOLEAN Result;
    BOOLEAN InvalidFpValue;

    //
    // Get the current EBP pointer which is supposed to
    // be the start of the EBP chain.
    //

    _asm mov Fp, EBP;

    StackStart = Fp;
    InvalidFpValue = FALSE;

    if (Flags == 0) {
        if (! RtlpCaptureStackLimits (Fp, &StackStart, &StackEnd)) {
            return 0;
        }
    }


    try {

        //
        // If we need to get the user mode stack trace from kernel mode
        // figure out the proper limits.
        //

        if (Flags == 1) {

            PKTHREAD Thread = KeGetCurrentThread ();
            PTEB Teb;
            PKTRAP_FRAME TrapFrame;
            ULONG_PTR Esp;

            TrapFrame = Thread->TrapFrame;
            Teb = Thread->Teb;

            //
            // If this is a system thread, it has no Teb and no kernel mode
            // stack, so check for it so we don't dereference NULL.
            //
            // If there is no trap frame (probably an APC), or it's attached,
            // or the irql is greater than dispatch, this code can't log a
            // stack.
            //

            if (Teb == NULL || 
                IS_SYSTEM_ADDRESS((PVOID)TrapFrame) == FALSE || 
                (PVOID)TrapFrame <= Thread->StackLimit ||
                (PVOID)TrapFrame >= Thread->StackBase ||
                KeIsAttachedProcess() || 
                (KeGetCurrentIrql() >= DISPATCH_LEVEL)) {

                return 0;
            }

            StackStart = (ULONG_PTR)(Teb->NtTib.StackLimit);
            StackEnd = (ULONG_PTR)(Teb->NtTib.StackBase);
            Fp = (ULONG_PTR)(TrapFrame->Ebp);

            if (StackEnd <= StackStart) {
                return 0;
            }
            
            ProbeForRead (StackStart, StackEnd - StackStart, sizeof (UCHAR));
        }
        
        for (Index = 0; Index < Count; Index += 1) {

            if (Fp >= StackEnd || 
                ( (Index == 0)?
                      (Fp < StackStart):
                      (Fp <= StackStart) ) ||
                StackEnd - Fp < sizeof(ULONG_PTR) * 2) {
                break;
            }

            NewFp = *((PULONG_PTR)(Fp + 0));
            ReturnAddress = *((PULONG_PTR)(Fp + sizeof(ULONG_PTR)));

            //
            // Figure out if the new frame pointer is ok. This validation
            // should avoid all exceptions in kernel mode because we always
            // read within the current thread's stack and the stack is
            // guaranteed to be in memory (no page faults). It is also guaranteed
            // that we do not take random exceptions in user mode because we always
            // keep the frame pointer within stack limits.
            //

            if (! (Fp < NewFp && NewFp < StackEnd)) {

                InvalidFpValue = TRUE;
            }

            //
            // Figure out if the return address is ok. If return address
            // is a stack address or <64k then something is wrong. There is
            // no reason to return garbage to the caller therefore we stop.
            //

            if (StackStart < ReturnAddress && ReturnAddress < StackEnd) {
                break;
            }

            if (Flags == 0 && IS_SYSTEM_ADDRESS((PVOID)ReturnAddress) == FALSE) {
                break;
            }

            //
            // Store new fp and return address and move on.
            // If the new FP value is bogus but the return address
            // looks ok then we still save the address.
            //

            Callers[Index] = (PVOID)ReturnAddress;
            
            if (InvalidFpValue) {

                Index += 1;
                break;
            }
            else {

                Fp = NewFp;
            }
        }
    }
    except (RtlpWalkFrameChainExceptionFilter (_exception_code(), _exception_info())) {

        Index = 0;
    }

    //
    // Return the number of return addresses identified on the stack.
    //

    return Index;

}


#if FPO
#pragma optimize( "y", off ) // disable FPO
#endif


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////// RtlCaptureStackContext
/////////////////////////////////////////////////////////////////////

#if FPO
#pragma optimize( "y", off ) // disable FPO
#endif

ULONG
RtlCaptureStackContext (
    OUT PULONG_PTR Callers,
    OUT PRTL_STACK_CONTEXT Context,
    IN ULONG Limit
    )
/*++

Routine Description:

    This routine will detect up to `Limit' potential callers from the stack.

    A potential caller is a pointer (PVOID) that points into one of the
    regions occupied by modules loaded into the process space (user mode -- dlls)
    or kernel space (kernel mode -- drivers).

    Note. Based on experiments you need to save at least 64 pointers to be sure you
    get a complete stack.

Arguments:

    Callers - vector to be filled with potential return addresses. Its size is
        expected to be `Limit'. If it is not null then Context should be null.

    Context - if not null the caller wants the stack context to be saved here
        as opposed to the Callers parameter.

    Limit - # of pointers that can be written into Callers and Offsets.

Return value:

    The number of potential callers detected and written into the
    `Callers' buffer.

--*/
{
    ULONG_PTR Current;
    ULONG_PTR Value;
    ULONG Index;
    ULONG_PTR Offset;
    ULONG_PTR StackStart;
    ULONG_PTR StackEnd;
    ULONG_PTR Hint;
    ULONG_PTR Caller;
    ULONG_PTR ContextSize;

    //
    // Avoid weird conditions. Doing this in an ISR is never a good idea.
    //

    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
        return 0;
    }

    if (Limit == 0) {
        return 0;
    }

    Caller = (ULONG_PTR)_ReturnAddress();

    if (Context) {
        Context->Entry[0].Data = Caller;
        ContextSize = sizeof(RTL_STACK_CONTEXT) + (Limit - 1) * sizeof (RTL_STACK_CONTEXT_ENTRY);
    }
    else {
        Callers[0] = Caller;
    }

    //
    // Get stack limits
    //

    _asm mov Hint, EBP;


    if (! RtlpCaptureStackLimits (Hint, &StackStart, &StackEnd)) {
        return 0;
    }

    //
    // Synchronize stack traverse pointer to the next word after the first
    // return address.
    //

    for (Current = StackStart; Current < StackEnd; Current += sizeof(ULONG_PTR)) {

        if (*((PULONG_PTR)Current) == Caller) {
            break;
        }
    }

    if (Context) {
        Context->Entry[0].Address = Current;
    }

    //
    // Iterate the stack and pickup potential callers on the way.
    //

    Current += sizeof(ULONG_PTR);

    Index = 1;

    for ( ; Current < StackEnd; Current += sizeof(ULONG_PTR)) {

        //
        // If potential callers buffer is full then wrap this up.
        //

        if (Index == Limit) {
            break;
        }

        //
        // Skip `Callers' buffer because it will give false positives.
        // It is very likely for this to happen because most probably the buffer
        // is allocated somewhere upper in the call chain.
        //

        if (Context) {

            if (Current >= (ULONG_PTR)Context && Current < (ULONG_PTR)Context + ContextSize ) {
                continue;
            }

        }
        else {

            if ((PULONG_PTR)Current >= Callers && (PULONG_PTR)Current < Callers + Limit ) {
                continue;
            }
        }

        Value = *((PULONG_PTR)Current);

        //
        // Skip small numbers.
        //

        if (Value <= 0x10000) {
            continue;
        }

        //
        // Skip stack pointers.
        //

        if (Value >= StackStart && Value <= StackEnd) {
            continue;
        }

        //
        // Check if `Value' points inside one of the loaded modules.
        //

        if (RtlpStkIsPointerInDllRange (Value)) {

            if (Context) {

                Context->Entry[Index].Address = Current;
                Context->Entry[Index].Data = Value;
            }
            else {

                Callers[Index] = Value;
            }

            Index += 1;
        }

    }

    if (Context) {
        Context->NumberOfEntries = Index;
    }

    return Index;
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Dll ranges bitmap
/////////////////////////////////////////////////////////////////////

//
// DLL ranges bitmap
//
// This range scheme is needed in order to capture stack contexts on x86
// machines fast. On IA64 there are totally different algorithms for getting
// stack traces.
//
// Every bit represents 1Mb of virtual space. Since we use the code either
// in user mode or kernel mode the first bit of a pointer is not interesting.
// Therefore we have to represent 2Gb / 1Mb regions. This totals 256 bytes.
//
// The bits are set only in loader code paths when a DLL (or driver) gets loaded.
// The writing is protected by the loader lock. The bits are read in stack
// capturing function.The reading does not require lock protection.
//

UCHAR RtlpStkDllRanges [2048 / 8];

BOOLEAN
RtlpStkIsPointerInDllRange (
    ULONG_PTR Value
    )
{
    ULONG Index;

    Value &= ~0x80000000;
    Index = (ULONG)(Value >> 20);

    if (RtlpStkDllRanges[Index >> 3] & (UCHAR)(1 << (Index & 7))) {

        return TRUE;
    }
    else {

        return FALSE;
    }
}

#define SIZE_1_MB 0x100000

#if defined(ROUND_DOWN)
#undef ROUND_DOWN
#endif

#if defined(ROUND_UP)
#undef ROUND_UP
#endif

#define ROUND_DOWN(a,b) ((ULONG_PTR)(a) & ~((ULONG_PTR)(b) - 1))
#define ROUND_UP(a,b) (((ULONG_PTR)(a) + ((ULONG_PTR)(b) - 1)) & ~((ULONG_PTR)(b) - 1))

VOID
RtlpStkMarkDllRange (
    PLDR_DATA_TABLE_ENTRY DllEntry
    )
/*++

Routine description:

    This routine marks the corresponding bits for the loaded dll in the
    RtlpStkDllRanges variable. This global is used within RtlpDetectDllReferences
    to save a stack context.

Arguments:

    Loader structure for a loaded dll.

Return value:

    None.

Environment:

    In user mode this function is called from loader code paths. The Peb->LoaderLock
    is always held while executing this function.

--*/
{
    PVOID Base;
    ULONG Size;
    ULONG_PTR Current;
    ULONG_PTR Start;
    ULONG_PTR End;
    ULONG Index;
    ULONG_PTR Value;

    Base = DllEntry->DllBase;
    Size = DllEntry->SizeOfImage;

    //
    // Find out where is ntdll loaded if we do not know yet.
    //

    Start = ROUND_DOWN(Base, SIZE_1_MB);
    End = ROUND_UP((ULONG_PTR)Base + Size, SIZE_1_MB);

    for (Current = Start; Current < End; Current += SIZE_1_MB) {

        Value = Current & ~0x80000000;

        Index = (ULONG)(Value >> 20);

        RtlpStkDllRanges[Index >> 3] |= (UCHAR)(1 << (Index & 7));
    }
}



BOOLEAN
RtlpCaptureStackLimits (
    ULONG_PTR HintAddress,
    PULONG_PTR StartStack,
    PULONG_PTR EndStack
    )
/*++

Routine Description:

    This routine figures out what are the stack limits for the current thread.
    This is used in other routines that need to grovel the stack for various
    information (e.g. potential return addresses).

    The function is especially tricky in K-mode where the information kept in
    the thread structure about stack limits is not always valid because the
    thread might execute a DPC routine and in this case we use a different stack
    with different limits.

Arguments:

    HintAddress - Address of a local variable or parameter of the caller of the
        function that should be the start of the stack.

    StartStack - start address of the stack (lower value).

    EndStack - end address of the stack (upper value).

Return value:

    False if some weird condition is discovered, like an End lower than a Start.

--*/
{
    //
    // Avoid weird conditions. Doing this in an ISR is never a good idea.
    //

    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
        return FALSE;
    }

    *StartStack = (ULONG_PTR)(KeGetCurrentThread()->StackLimit);
    *EndStack = (ULONG_PTR)(KeGetCurrentThread()->StackBase);

    if (*StartStack <= HintAddress && HintAddress <= *EndStack) {

        *StartStack = HintAddress;
    }
    else {

        *EndStack = (ULONG_PTR)(KeGetPcr()->Prcb->DpcStack);
        *StartStack = *EndStack - KERNEL_STACK_SIZE;

        //
        // Check if this is within the DPC stack for the current
        // processor.
        //

        if (*EndStack && *StartStack <= HintAddress && HintAddress <= *EndStack) {

            *StartStack = HintAddress;
        }
        else {

            //
            // This is not current thread's stack and is not the DPC stack
            // of the current processor. We will return just the rest of the
            // stack page containing HintAddress as a valid stack range.
            //

            *StartStack = HintAddress;

            *EndStack = (*StartStack + PAGE_SIZE) & ~((ULONG_PTR)PAGE_SIZE - 1);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\exdsptch.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    exdsptch.c

Abstract:

    This module implements the dispatching of exception and the unwinding of
    procedure call frames.

--*/

#include "ntrtlp.h"

//
// Dispatcher context structure definition.
//

typedef struct _DISPATCHER_CONTEXT {
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    } DISPATCHER_CONTEXT;

//
// Execute handler for exception function prototype.
//

EXCEPTION_DISPOSITION
RtlpExecuteHandlerForException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PVOID DispatcherContext,
    IN PEXCEPTION_ROUTINE ExceptionRoutine
    );

//
// Execute handler for unwind function prototype.
//

EXCEPTION_DISPOSITION
RtlpExecuteHandlerForUnwind (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PVOID DispatcherContext,
    IN PEXCEPTION_ROUTINE ExceptionRoutine
    );

typedef struct {
    PVOID Handler;
    PULONG HandlerTable;
    ULONG HandlerTableLength;
    ULONG MatchedEntry;
} HANDLERLIST;

HANDLERLIST HandlerList[5];
int HandlerCount;

VOID
RtlInvalidHandlerDetected(
    PVOID Handler, 
    PULONG FunctionTable,
    ULONG FunctionTableLength
    )
{
    return;
}


BOOLEAN
RtlIsValidHandler (
    IN PEXCEPTION_ROUTINE Handler
    )
{
    PULONG FunctionTable;
    ULONG FunctionTableLength;
    PVOID Base;

    FunctionTable = RtlLookupFunctionTable(Handler, &Base, &FunctionTableLength);

    if (FunctionTable && FunctionTableLength) {
        PEXCEPTION_ROUTINE FunctionEntry;
        LONG High, Middle, Low;

        if ((FunctionTable == LongToPtr(-1)) && (FunctionTableLength == (ULONG)-1)) {
            // Address is in an image that shouldn't have any handlers (like a resource only dll).
            RtlInvalidHandlerDetected((PVOID)((ULONG)Handler+(ULONG)Base), LongToPtr(-1), -1);
            return FALSE;
        }
    
        // Bias the handler value down by the image base and see if the result
        // is in the table

        (ULONG)Handler -= (ULONG)Base;
        Low = 0;
        High = FunctionTableLength;
        while (High >= Low) {
            Middle = (Low + High) >> 1;
            FunctionEntry = (PEXCEPTION_ROUTINE)FunctionTable[Middle];
            if (Handler < FunctionEntry) {
                High = Middle - 1;
            } else if (Handler > FunctionEntry) {
                Low = Middle + 1;
            } else {
                // found it
                return TRUE;
            }
        }
        // Didn't find it
        RtlInvalidHandlerDetected((PVOID)((ULONG)Handler+(ULONG)Base), FunctionTable, FunctionTableLength);

        return FALSE;
    }

    // Can't verify
    return TRUE;
}

BOOLEAN
RtlDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function attempts to dispatch an exception to a call frame based
    handler by searching backwards through the stack based call frames. The
    search begins with the frame specified in the context record and continues
    backward until either a handler is found that handles the exception, the
    stack is found to be invalid (i.e., out of limits or unaligned), or the end
    of the call hierarchy is reached.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    If the exception is handled by one of the frame based handlers, then
    a value of TRUE is returned. Otherwise a value of FALSE is returned.

--*/

{

    BOOLEAN Completion = FALSE;
    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    PEXCEPTION_REGISTRATION_RECORD NestedRegistration;
    ULONG HighAddress;
    ULONG HighLimit;
    ULONG LowLimit;
    EXCEPTION_RECORD ExceptionRecord1;
    ULONG Index;

    //
    // Get current stack limits.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);

    //
    // Start with the frame specified by the context record and search
    // backwards through the call frame hierarchy attempting to find an
    // exception handler that will handler the exception.
    //

    RegistrationPointer = RtlpGetRegistrationHead();
    NestedRegistration = 0;

    while (RegistrationPointer != EXCEPTION_CHAIN_END) {

        //
        // If the call frame is not within the specified stack limits or the
        // call frame is unaligned, then set the stack invalid flag in the
        // exception record and return FALSE. Else check to determine if the
        // frame has an exception handler.
        //

        HighAddress = (ULONG)RegistrationPointer +
            sizeof(EXCEPTION_REGISTRATION_RECORD);

        if ( ((ULONG)RegistrationPointer < LowLimit) ||
             (HighAddress > HighLimit) ||
             (((ULONG)RegistrationPointer & 0x3) != 0) 
           ) {

            //
            // Allow for the possibility that the problem occured on the
            // DPC stack.
            //

            ULONG TestAddress = (ULONG)RegistrationPointer;

            if (((TestAddress & 0x3) == 0) &&
                KeGetCurrentIrql() >= DISPATCH_LEVEL) {

                PKPRCB Prcb = KeGetCurrentPrcb();
                ULONG DpcStack = (ULONG)Prcb->DpcStack;

                if ((Prcb->DpcRoutineActive) &&
                    (HighAddress <= DpcStack) &&
                    (TestAddress >= DpcStack - KERNEL_STACK_SIZE)) {

                    //
                    // This error occured on the DPC stack, switch
                    // stack limits to the DPC stack and restart
                    // the loop.
                    //

                    HighLimit = DpcStack;
                    LowLimit = DpcStack - KERNEL_STACK_SIZE;
                    continue;
                }
            }

            ExceptionRecord->ExceptionFlags |= EXCEPTION_STACK_INVALID;
            goto DispatchExit;
        }

        // See if the handler is reasonable

        if (!RtlIsValidHandler(RegistrationPointer->Handler)) {
            ExceptionRecord->ExceptionFlags |= EXCEPTION_STACK_INVALID;
            goto DispatchExit;
        }

        //
        // The handler must be executed by calling another routine
        // that is written in assembler. This is required because
        // up level addressing of the handler information is required
        // when a nested exception is encountered.
        //

        if (NtGlobalFlag & FLG_ENABLE_EXCEPTION_LOGGING) {
            Index = RtlpLogExceptionHandler(
                            ExceptionRecord,
                            ContextRecord,
                            0,
                            (PULONG)RegistrationPointer,
                            4 * sizeof(ULONG));
                    // can't use sizeof(EXCEPTION_REGISTRATION_RECORD
                    // because we need the 2 dwords above it.
        }

        Disposition = RtlpExecuteHandlerForException(
            ExceptionRecord,
            (PVOID)RegistrationPointer,
            ContextRecord,
            (PVOID)&DispatcherContext,
            (PEXCEPTION_ROUTINE)RegistrationPointer->Handler);

        if (NtGlobalFlag & FLG_ENABLE_EXCEPTION_LOGGING) {
            RtlpLogLastExceptionDisposition(Index, Disposition);
        }

        //
        // If the current scan is within a nested context and the frame
        // just examined is the end of the context region, then clear
        // the nested context frame and the nested exception in the
        // exception flags.
        //

        if (NestedRegistration == RegistrationPointer) {
            ExceptionRecord->ExceptionFlags &= (~EXCEPTION_NESTED_CALL);
            NestedRegistration = 0;
        }

        //
        // Case on the handler disposition.
        //

        switch (Disposition) {

            //
            // The disposition is to continue execution. If the
            // exception is not continuable, then raise the exception
            // STATUS_NONCONTINUABLE_EXCEPTION. Otherwise return
            // TRUE.
            //

        case ExceptionContinueExecution :
            if ((ExceptionRecord->ExceptionFlags &
               EXCEPTION_NONCONTINUABLE) != 0) {
                ExceptionRecord1.ExceptionCode =
                                        STATUS_NONCONTINUABLE_EXCEPTION;
                ExceptionRecord1.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                ExceptionRecord1.ExceptionRecord = ExceptionRecord;
                ExceptionRecord1.NumberParameters = 0;
                RtlRaiseException(&ExceptionRecord1);

            } else {
                Completion = TRUE;
                goto DispatchExit;
            }

            //
            // The disposition is to continue the search. If the frame isn't
            // suspect/corrupt, get next frame address and continue the search 
            //

        case ExceptionContinueSearch :
            if (ExceptionRecord->ExceptionFlags & EXCEPTION_STACK_INVALID)
                goto DispatchExit;

            break;

            //
            // The disposition is nested exception. Set the nested
            // context frame to the establisher frame address and set
            // nested exception in the exception flags.
            //

        case ExceptionNestedException :
            ExceptionRecord->ExceptionFlags |= EXCEPTION_NESTED_CALL;
            if (DispatcherContext.RegistrationPointer > NestedRegistration) {
                NestedRegistration = DispatcherContext.RegistrationPointer;
            }

            break;

            //
            // All other disposition values are invalid. Raise
            // invalid disposition exception.
            //

        default :
            ExceptionRecord1.ExceptionCode = STATUS_INVALID_DISPOSITION;
            ExceptionRecord1.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            ExceptionRecord1.ExceptionRecord = ExceptionRecord;
            ExceptionRecord1.NumberParameters = 0;
            RtlRaiseException(&ExceptionRecord1);
            break;
        }

        //
        // If chain goes in wrong direction or loops, report an
        // invalid exception stack, otherwise go on to the next one.
        //

        RegistrationPointer = RegistrationPointer->Next;
    }

    //
    // Call vectored continue handlers.
    //

DispatchExit:

    return Completion;
}

#ifdef _X86_
#pragma optimize("y", off)      // RtlCaptureContext needs EBP to be correct
#endif

VOID
RtlUnwind (
    IN PVOID TargetFrame OPTIONAL,
    IN PVOID TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN PVOID ReturnValue
    )

/*++

Routine Description:

    This function initiates an unwind of procedure call frames. The machine
    state at the time of the call to unwind is captured in a context record
    and the unwinding flag is set in the exception flags of the exception
    record. If the TargetFrame parameter is not specified, then the exit unwind
    flag is also set in the exception flags of the exception record. A backward
    walk through the procedure call frames is then performed to find the target
    of the unwind operation.

    N.B.    The captured context passed to unwinding handlers will not be
            a  completely accurate context set for the 386.  This is because
            there isn't a standard stack frame in which registers are stored.

            Only the integer registers are affected.  The segment and
            control registers (ebp, esp) will have correct values for
            the flat 32 bit environment.

    N.B.    If you change the number of arguments, make sure you change the
            adjustment of ESP after the call to RtlpCaptureContext (for
            STDCALL calling convention)

Arguments:

    TargetFrame - Supplies an optional pointer to the call frame that is the
        target of the unwind. If this parameter is not specified, then an exit
        unwind is performed.

    TargetIp - Supplies an optional instruction address that specifies the
        continuation address of the unwind. This address is ignored if the
        target frame parameter is not specified.

    ExceptionRecord - Supplies an optional pointer to an exception record.

    ReturnValue - Supplies a value that is to be placed in the integer
        function return register just before continuing execution.

Return Value:

    None.

--*/

{
    PCONTEXT ContextRecord;
    CONTEXT ContextRecord1;
    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    PEXCEPTION_REGISTRATION_RECORD PriorPointer;
    ULONG HighAddress;
    ULONG HighLimit;
    ULONG LowLimit;
    EXCEPTION_RECORD ExceptionRecord1;
    EXCEPTION_RECORD ExceptionRecord2;

    //
    // Get current stack limits.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);

    //
    // If an exception record is not specified, then build a local exception
    // record for use in calling exception handlers during the unwind operation.
    //

    if (ARGUMENT_PRESENT(ExceptionRecord) == FALSE) {
        ExceptionRecord = &ExceptionRecord1;
        ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
        ExceptionRecord1.ExceptionFlags = 0;
        ExceptionRecord1.ExceptionRecord = NULL;
        ExceptionRecord1.ExceptionAddress = _ReturnAddress();
        ExceptionRecord1.NumberParameters = 0;
    }

    //
    // If the target frame of the unwind is specified, then set EXCEPTION_UNWINDING
    // flag in the exception flags. Otherwise set both EXCEPTION_EXIT_UNWIND and
    // EXCEPTION_UNWINDING flags in the exception flags.
    //

    if (ARGUMENT_PRESENT(TargetFrame) == TRUE) {
        ExceptionRecord->ExceptionFlags |= EXCEPTION_UNWINDING;
    } else {
        ExceptionRecord->ExceptionFlags |= (EXCEPTION_UNWINDING |
                                                        EXCEPTION_EXIT_UNWIND);
    }

    //
    // Capture the context.
    //

    ContextRecord = &ContextRecord1;
    ContextRecord1.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL | CONTEXT_SEGMENTS;
    RtlpCaptureContext(ContextRecord);

    //
    // Adjust captured context to pop our arguments off the stack
    //
    ContextRecord->Esp += sizeof(TargetFrame) +
                          sizeof(TargetIp)    +
                          sizeof(ExceptionRecord) +
                          sizeof(ReturnValue);
    ContextRecord->Eax = (ULONG)ReturnValue;

    //
    // Scan backward through the call frame hierarchy, calling exception
    // handlers as they are encountered, until the target frame of the unwind
    // is reached.
    //

    RegistrationPointer = RtlpGetRegistrationHead();
    while (RegistrationPointer != EXCEPTION_CHAIN_END) {

        //
        // If this is the target of the unwind, then continue execution
        // by calling the continue system service.
        //

        if ((ULONG)RegistrationPointer == (ULONG)TargetFrame) {
            ZwContinue(ContextRecord, FALSE);

        //
        // If the target frame is lower in the stack than the current frame,
        // then raise STATUS_INVALID_UNWIND exception.
        //

        } else if ( (ARGUMENT_PRESENT(TargetFrame) == TRUE) &&
                    ((ULONG)TargetFrame < (ULONG)RegistrationPointer) ) {
            ExceptionRecord2.ExceptionCode = STATUS_INVALID_UNWIND_TARGET;
            ExceptionRecord2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            ExceptionRecord2.ExceptionRecord = ExceptionRecord;
            ExceptionRecord2.NumberParameters = 0;
            RtlRaiseException(&ExceptionRecord2);
        }

        //
        // If the call frame is not within the specified stack limits or the
        // call frame is unaligned, then raise the exception STATUS_BAD_STACK.
        // Else restore the state from the specified frame to the context
        // record.
        //

        HighAddress = (ULONG)RegistrationPointer +
            sizeof(EXCEPTION_REGISTRATION_RECORD);

        if ( ((ULONG)RegistrationPointer < LowLimit) ||
             (HighAddress > HighLimit) ||
             (((ULONG)RegistrationPointer & 0x3) != 0) 
           ) {

            //
            // Allow for the possibility that the problem occured on the
            // DPC stack.
            //

            ULONG TestAddress = (ULONG)RegistrationPointer;

            if (((TestAddress & 0x3) == 0) &&
                KeGetCurrentIrql() >= DISPATCH_LEVEL) {

                PKPRCB Prcb = KeGetCurrentPrcb();
                ULONG DpcStack = (ULONG)Prcb->DpcStack;

                if ((Prcb->DpcRoutineActive) &&
                    (HighAddress <= DpcStack) &&
                    (TestAddress >= DpcStack - KERNEL_STACK_SIZE)) {

                    //
                    // This error occured on the DPC stack, switch
                    // stack limits to the DPC stack and restart
                    // the loop.
                    //

                    HighLimit = DpcStack;
                    LowLimit = DpcStack - KERNEL_STACK_SIZE;
                    continue;
                }
            }

            ExceptionRecord2.ExceptionCode = STATUS_BAD_STACK;
            ExceptionRecord2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            ExceptionRecord2.ExceptionRecord = ExceptionRecord;
            ExceptionRecord2.NumberParameters = 0;
            RtlRaiseException(&ExceptionRecord2);
        } else {

            //
            // The handler must be executed by calling another routine
            // that is written in assembler. This is required because
            // up level addressing of the handler information is required
            // when a collided unwind is encountered.
            //

            Disposition = RtlpExecuteHandlerForUnwind(
                ExceptionRecord,
                (PVOID)RegistrationPointer,
                ContextRecord,
                (PVOID)&DispatcherContext,
                RegistrationPointer->Handler);

            //
            // Case on the handler disposition.
            //

            switch (Disposition) {

                //
                // The disposition is to continue the search. Get next
                // frame address and continue the search.
                //

            case ExceptionContinueSearch :
                break;

                //
                // The disposition is colided unwind. Maximize the target
                // of the unwind and change the context record pointer.
                //

            case ExceptionCollidedUnwind :

                //
                // Pick up the registration pointer that was active at
                // the time of the unwind, and simply continue.
                //

                RegistrationPointer = DispatcherContext.RegistrationPointer;
                break;


                //
                // All other disposition values are invalid. Raise
                // invalid disposition exception.
                //

            default :
                ExceptionRecord2.ExceptionCode = STATUS_INVALID_DISPOSITION;
                ExceptionRecord2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                ExceptionRecord2.ExceptionRecord = ExceptionRecord;
                ExceptionRecord2.NumberParameters = 0;
                RtlRaiseException(&ExceptionRecord2);
                break;
            }

            //
            // Step to next registration record
            //

            PriorPointer = RegistrationPointer;
            RegistrationPointer = RegistrationPointer->Next;

            //
            // Unlink the unwind handler, since it's been called.
            //

            RtlpUnlinkHandler(PriorPointer);

            //
            // If chain goes in wrong direction or loops, raise an
            // exception.
            //

        }
    }

    if (TargetFrame == EXCEPTION_CHAIN_END) {

        //
        //  Caller simply wants to unwind all exception records.
        //  This differs from an exit_unwind in that no "exit" is desired.
        //  Do a normal continue, since we've effectively found the
        //  "target" the caller wanted.
        //

        ZwContinue(ContextRecord, FALSE);

    } else {

        //
        //  Either (1) a real exit unwind was performed, or (2) the
        //  specified TargetFrame is not present in the exception handler
        //  list.  In either case, give debugger and subsystem a chance
        //  to see the unwind.
        //

        ZwRaiseException(ExceptionRecord, ContextRecord, FALSE);

    }
    return;
}

#ifdef _X86_
#pragma optimize("", on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\slist.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    slist.asm
;
; Abstract:
;
;    This module implements functions to support interlocked S-List
;    operations.
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
        .list


_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Interlocked Flush Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; FASTCALL
; RtlpInterlockedFlushSList (
;    IN PSINGLE_LIST_ENTRY ListHead
;    )
;
; Routine Description:
;
;    This function removes the entire list from a sequenced singly
;    linked list so that access to the list is synchronized in an MP system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry at the top of the list is removed
;    and returned as the function value and the list header is set to point
;    to NULL.
;
; Arguments:
;
;    (ecx) = ListHead - Supplies a pointer to the sequenced listhead from
;         which the list is to be flushed.
;
; Return Value:
;
;    The address of the entire current list, or NULL if the list is
;    empty.
;
;--

;
; These old interfaces just fall into the new ones
;
cPublicFastCall ExInterlockedFlushSList, 1
fstENDP ExInterlockedFlushSList

cPublicFastCall RtlpInterlockedFlushSList, 1

cPublicFpo 0,1

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        xor     ebx, ebx                ; zero out new pointer
        mov     ebp, ecx                ; save listhead address
        mov     edx, [ebp] + 4          ; get current sequence number
        mov     eax, [ebp] + 0          ; get current next link

;
; N.B. The following code is the retry code should the compare
;      part of the compare exchange operation fail
;
; If the list is empty, then there is nothing that can be removed.
;

Efls10: or      eax, eax                ; check if list is empty
        jz      short Efls20            ; if z set, list is empty
        mov     ecx, edx   		; copy sequence number
        mov     cx, bx                  ; clear depth leaving sequence number

.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr [ebp]       ; compare and exchange

endif
.386

        jnz     short Efls10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

Efls20: pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    RtlpInterlockedFlushSList

fstENDP RtlpInterlockedFlushSList

        page , 132
        subttl  "Interlocked Pop Entry Sequenced List"
;++
;
; PVOID
; FASTCALL
; RtlpInterlockedPopEntrySList (
;    IN PSLIST_HEADER ListHead
;    )
;
; Routine Description:
;
;    This function removes an entry from the front of a sequenced singly
;    linked list so that access to the list is synchronized in an MP system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
; Arguments:
;
;    (ecx) = ListHead - Supplies a pointer to the sequenced listhead from
;         which an entry is to be removed.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

;
; These older interfaces just fall into the new code below
;

cPublicFastCall InterlockedPopEntrySList, 1
fstENDP InterlockedPopEntrySList

cPublicFastCall ExInterlockedPopEntrySList, 2
fstENDP ExInterlockedPopEntrySList

cPublicFastCall RtlpInterlockedPopEntrySList, 1

cPublicFpo 0,2

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
;
; N.B. The following code is the continuation address should a fault
;      occur in the rare case described below.
;

        public  ExpInterlockedPopEntrySListResume
        public  _ExpInterlockedPopEntrySListResume@0
ExpInterlockedPopEntrySListResume:      ;
_ExpInterlockedPopEntrySListResume@0:   ;

Epop10: mov     edx,[ebp] + 4           ; get current sequence number
        mov     eax,[ebp] + 0           ; get current next link

;
; If the list is empty, then there is nothing that can be removed.
;

        or      eax, eax                ; check if list is empty
        jz      short Epop20            ; if z set, list is empty
        lea     ecx, [edx-1]            ; Adjust depth only

;
; N.B. It is possible for the following instruction to fault in the rare
;      case where the first entry in the list is allocated on another
;      processor and free between the time the free pointer is read above
;      and the following instruction. When this happens, the access fault
;      code continues execution by skipping the following instruction.
;      This results in the compare failing and the entire operation is
;      retried.
;

        public  ExpInterlockedPopEntrySListFault
        public  _ExpInterlockedPopEntrySListFault@0
ExpInterlockedPopEntrySListFault:       ;
_ExpInterlockedPopEntrySListFault@0:

        mov     ebx, [eax]              ; get address of successor entry

        public  ExpInterlockedPopEntrySListEnd
        public  _ExpInterlockedPopEntrySListEnd@0
ExpInterlockedPopEntrySListEnd:         ;
_ExpInterlockedPopEntrySListEnd@0:      ;

.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr [ebp]       ; compare and exchange

endif
.386

        jnz     short Epop10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

Epop20: pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    RtlpInterlockedPopEntrySList

fstENDP RtlpInterlockedPopEntrySList

        page , 132
        subttl  "Interlocked Push Entry Sequenced List"
;++
;
; PVOID
; FASTCALL
; RtlpInterlockedPushEntrySList (
;    IN PSLIST_HEADER ListHead,
;    IN PVOID ListEntry
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a sequenced singly linked
;    list so that access to the list is synchronized in an MP system.
;
; Arguments:
;
;    (ecx) ListHead - Supplies a pointer to the sequenced listhead into which
;          an entry is to be inserted.
;
;    (edx) ListEntry - Supplies a pointer to the entry to be inserted at the
;          head of the list.
;
; Return Value:
;
;    Previous contents of ListHead.  NULL implies list went from empty
;       to not empty.
;
;--

;
; This old interface just fall into the new code below.
;

cPublicFastCall ExInterlockedPushEntrySList, 3
       pop	[esp]			; Drop the lock argument
fstENDP ExInterlockedPushEntrySList

cPublicFastCall InterlockedPushEntrySList, 2
fstENDP InterlockedPushEntrySList


cPublicFastCall RtlpInterlockedPushEntrySList, 2

cPublicFpo 0,2

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
        mov     ebx, edx                ; save list entry address
        mov     edx,[ebp] + 4           ; get current sequence number
        mov     eax,[ebp] + 0           ; get current next link
Epsh10: mov     [ebx], eax              ; set next link in new first entry
        lea     ecx, [edx+010001H]      ; increment sequence number and depth

.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr[ebp]        ; compare and exchange

endif
.386

        jnz     short Epsh10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET  RtlpInterlockedPushEntrySList

fstENDP RtlpInterlockedPushEntrySList

;++
;
; SINGLE_LIST_ENTRY
; FASTCALL
; InterlockedPushListSList (
;     IN PSLIST_HEADER ListHead,
;     IN PSINGLE_LIST_ENTRY List,
;     IN PSINGLE_LIST_ENTRY ListEnd,
;     IN ULONG Count
;    )
;
; Routine Description:
;
;    This function will push multiple entries onto an SList at once
;
; Arguments:
;
;     ListHead - List head to push the list to.
;
;     List - The list to add to the front of the SList
;     ListEnd - The last element in the chain
;     Count - The number of items in the chain
;
; Return Value:
;
;     PSINGLE_LIST_ENTRY - The old header pointer is returned
;
;--

cPublicFastCall InterlockedPushListSList, 4

cPublicFpo 0,4
        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
        mov     ebx, edx                ; save list entry address
        mov     edx,[ebp] + 4           ; get current sequence number
        mov     eax,[ebp] + 0           ; get current next link
Epshl10:
        mov     ecx, [esp+4*3]          ; Fetch address of list tail
        mov     [ecx], eax              ; Store new forward pointer in tail entry
        lea     ecx, [edx+010000H]      ; increment sequence number
        add     ecx, [esp+4*4]		; Add in new count to create correct depth
.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr[ebp]        ; compare and exchange

endif
.386
        jnz     short Epshl10           ; if z clear, exchange failed

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET  InterlockedPushListSList

fstENDP InterlockedPushListSList

;++
;
; PSINGLE_LIST_ENTRY
; FirstEntrySList (
;     IN PSLIST_HEADER SListHead
;     )
;
; Routine Description:
;
;   This function returns the address of the fisrt entry in the SLIST or
;   NULL.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the sequenced listhead from
;       which the first entry address is to be computed.
;
; Return Value:
;
;   The address of the first entry is the specified, or NULL if the list is
;   empty.
;
;--

cPublicProc _FirstEntrySList, 1
cPublicFpo 1,0

        mov       eax, [esp+4]
        mov       eax, [eax]
        stdRET    _FirstEntrySList

stdENDP _FirstEntrySList

;++
;
; LONGLONG
; FASTCALL
; RtlInterlockedCompareExchange64 (
;    IN OUT PLONGLONG Destination,
;    IN PLONGLONG Exchange,
;    IN PLONGLONG Comperand
;    )
;
; Routine Description:
;
;    This function performs a compare and exchange of 64-bits.
;
; Arguments:
;
;    (ecx) Destination - Supplies a pointer to the destination variable.
;
;    (edx) Exchange - Supplies a pointer to the exchange value.
;
;    (esp+4) Comperand - Supplies a pointer to the comperand value.
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicFastCall RtlInterlockedCompareExchange64, 3

cPublicFpo 0,2

;
; Save nonvolatile registers and read the exchange and comperand values.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; set destination address
        mov     ebx, [edx]              ; get exchange value
        mov     ecx, [edx] + 4          ;
        mov     edx, [esp] + 12         ; get comperand address
        mov     eax, [edx]              ; get comperand value
        mov     edx, [edx] + 4          ;

.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr[ebp]        ; compare and exchange

endif
.386

;
; Restore nonvolatile registers and return result in edx:eax.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET  RtlInterlockedCompareExchange64

fstENDP RtlInterlockedCompareExchange64

;++
;
; LONGLONG
; InterlockedCompareExchange64 (
;    IN OUT PLONGLONG Destination,
;    IN LONGLONG Exchange,
;    IN LONGLONG Comperand
;    )
;
; Routine Description:
;
;    This function performs a compare and exchange of 64-bits.
;
; Arguments:
;
;    (esp+4) Destination - Supplies a pointer to the destination variable.
;
;    (esp+8) Exchange - Supplies the exchange value.
;
;    (esp+16) Comperand - Supplies the comperand value.
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicProc _InterlockedCompareExchange64, 5
cPublicFpo 5,0

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, [esp+12]           ; set destination address
        mov     ebx, [esp+16]           ; get exchange value
        mov     ecx, [esp+20]           ;
        mov     eax, [esp+24]           ; get comperand value
        mov     edx, [esp+28]           
.586
   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange
.386

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;
        stdRET    _InterlockedCompareExchange64

stdENDP _InterlockedCompareExchange64

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\raise.asm ===
title  "Raise Exception"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    raise.asm
;
; Abstract:
;
;    This module implements the function to raise a software exception.
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        EXTRNP  _ZwRaiseException,3
        EXTRNP  _RtlDispatchException,2
        EXTRNP  _ZwContinue,2
        EXTRNP  _RtlCaptureContext,1

_TEXT$01 SEGMENT DWORD PUBLIC 'CODE'
         ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
; Context flags definition.
;

CONTEXT_SETTING EQU CONTEXT_INTEGER OR CONTEXT_CONTROL OR CONTEXT_SEGMENTS

        page
        subttl  "Raise Software Exception"
;++
;
; VOID
; RtlRaiseException (
;    IN PEXCEPTION_RECORD ExceptionRecord
;    )
;
; Routine Description:
;
;    This function raises a software exception by building a context record,
;    and calling the exception dispatcher. If the exception dispatcher finds
;    a handler to process the exception the handler is invoked and execution 
;    is resumed. Otherwise the ZwRaiseException system service is invoked to 
;    provide default handling.
;
;    N.B. On the 386, floating point state is not defined for non-fp exceptions.
;      Therefore, this routine does not attempt to capture it.
;
;      This means this routine cannot be used to report fp exceptions.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _RtlRaiseException, 1

        push    ebp
        mov     ebp, esp
        lea     esp, dword ptr [esp-ContextFrameLength]  ; Allocate a context record

;
; Invoke the helper routine to capture the caller's context. This 
; will capture the segment registers, volatile/nonvolatile registers,
; and the control registers. Note that the status flags have not been
; perturbed from their state prior to this call.
;

        stdCall _RtlCaptureContext, <esp> ; Assumes esp is pushed prior to decrement

;
; Get a pointer to exception report record, and set the exception address
; field to be the return address of this function.
;
; The captured stack pointer does not take into account the arguments
; passed to this function. Make sure to adjust it here (assuming esp is 
; properly restored).
;


        mov     edx, [ebp+4]
        mov     eax, [ebp+8]                    ; (eax) -> ExceptionReportRecord
                
        add     dword ptr [esp].CsEsp, 4        ; Adjust captured esp
        
        mov     [eax].ErExceptionAddress, edx
        
;
; Set Context flags, note that FLOATING_POINT is NOT set.
;

        mov     dword ptr [esp].CsContextFlags, CONTEXT_SETTING

;
; Perform a direct dispatch of the exception (assuming esp is pushed
; prior to any modification).
;

        stdCall _RtlDispatchException, <[ebp+8], esp>
        test    al,al
        jz      short rre02             

;
; In this case, the handler indicated that execution will be resumed. Continue
; execution via the ZwContinue system service.
;

        mov     ecx, esp                ; Restore context record address
        stdCall  _ZwContinue, <ecx, 0>
        jmp     rre03                   ; Raise a status exception if we ever get here.

;
; The exception was not handled. Raise a second chance exception. Take
; care to restore the address of the context record (assuming esp is
; restored correctly by RtlDispatchException above).
;

rre02:  mov     ecx, esp
        stdCall _ZwRaiseException, <[ebp+8], ecx, 0>

;
; There should never be a return from either exception dispatch or the
; system service unless there is a problem with the argument list itself.
; Raise another exception specifying the status value returned.
;

rre03:  stdCall _RtlRaiseStatus, <eax>
     
;
; The code should not return here as RtlRaiseStatus raises a
; non-continuable exception.
;
                
stdENDP _RtlRaiseException

        subttl  "Raise Non-Continuable Software Exception"
;++
;
; VOID
; RtlRaiseStatus (
;     IN NTSTATUS Status
;     )
;
; Routine Description:
;
;    This function raises an exception with the specified status value. The
;    exception is marked as noncontinuable with no parameters.
;
;    N.B. On the 386, floating point state is not defined for non-fp exceptions.  
;      Therefore, this routine does not attempt to capture it.
;
;      This means this routine cannot be used to report fp exceptions.
;
;    N.B. There is no return from this routine.
;
; Arguments:
;
;     Status - Supplies the status value to be used as the exception code
;        for the exception that is to be raised.
;
; Return Value:
;
;     None.
;--

cPublicProc _RtlRaiseStatus, 1
        push    ebp
        mov     ebp,esp
        lea     esp, dword ptr [esp-ContextFrameLength-ExceptionRecordLength]

;
; Invoke the helper routine to capture the caller's context. This 
; will capture the segment registers, volatile/nonvolatile registers,
; and the control registers. Note that the status flags have not been
; perturbed from their state prior to this call.
;

        stdCall _RtlCaptureContext, <esp> ; Assumes esp is pushed prior to decrement

;
; The captured stack pointer does not take into account the arguments
; passed to this function. Adjust it here.
;

        add dword ptr [esp].CsEsp, 4

;
; Get pointer to exception report record, and set the exception address
; field to be this routine's return address. Additionally, set the
; appropriate context flags in the context record.
;

        lea     ecx, dword ptr [esp+ContextFrameLength] ; Exception record
        mov     eax, [ebp+4]                            ; Return address
        mov     dword ptr [esp].CsContextFlags, CONTEXT_SETTING
        
        mov     dword ptr [ecx].ErExceptionAddress, eax   
        and     dword ptr [ecx].ErNumberParameters, 0
        mov     eax, [ebp+8]                            ; Exception code
        and     dword ptr [ecx].ErExceptionRecord, 0
        mov     dword ptr [ecx].ErExceptionCode, eax
        mov     dword ptr [ecx].ErExceptionFlags, EXCEPTION_NONCONTINUABLE

;
; ecx - Exception record
; esp - Context record
;

        stdCall _RtlDispatchException, <ecx, esp> ; Assumes esp is pushed prior to decrement
        
;
; If execution returns here, raise a second chance exception. Take care
; to reload the volatile registers, assuming esp is restored properly
; by RtlDispatchException above.
;

        lea     ecx, dword ptr [esp+ContextFrameLength]
        mov     edx, esp
        stdCall _ZwRaiseException, <ecx, edx, 0>

;
; There should never be a return from either exception dispatch or the
; system service unless there is a problem with the argument list itself.
; Recursively raise another exception specifying the status value returned.
;

        stdCall _RtlRaiseStatus, <eax>
     
;
; The code should not return here as RtlRaiseStatus raises a
; non-continuable exception.
;
        
stdENDP _RtlRaiseStatus

_TEXT$01 ends
         end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\ntrtl386.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    ntrtl386.h

Abstract:

    i386 specific parts of ntrtlp.h

--*/

//
// Exception handling procedure prototypes.
//
VOID
RtlpCaptureContext (
    OUT PCONTEXT ContextRecord
    );

VOID
RtlpUnlinkHandler (
    PEXCEPTION_REGISTRATION_RECORD UnlinkPointer
    );

PEXCEPTION_REGISTRATION_RECORD
RtlpGetRegistrationHead (
    VOID
    );

//
//  Record dump procedures.
//

VOID
RtlpContextDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    );

VOID
RtlpExceptionReportDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    );

VOID
RtlpExceptionRegistrationDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\stkwalk.asm ===
TITLE   "Capture Stack Back Trace"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    stkwalk.asm
;
; Abstract:
;
;    This module implements the routine RtlCaptureStackBackTrace.  It will
;    walker the stack back trace and capture a portion of it.
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        EXTRNP  _MmIsAddressValid,1

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "RtlGetCallersAddress"
;++
;
; VOID
; RtlGetCallersAddress(
;    OUT PVOID *CallersAddress,
;    OUT PVOID *CallersCaller
;    )
;
; Routine Description:
;
;    This routine walks up the stack frames, capturing the first two return
;    addresses
;
;
; Arguments:
;
;    OUT PVOID CallersAddress - returns callers return address
;    OUT PVOID CallersCaller - returns callers caller return address
;
; Return Value:
;
;     None.
;
;
;--
RgcaCallersAddress      EQU [ebp+08h]
RgcaCallersCaller       EQU [ebp+0Ch]
cPublicProc _RtlGetCallersAddress ,2
        push    ebp
        mov     ebp, esp
        push    ebx                     ; Save EBX
        push    esi                     ; Save ESI
        push    edi                     ; Save EDI
        mov     eax, PCR[PcPrcbData+PbCurrentThread] ; (eax)->current thread
        push    ThInitialStack[eax]     ;  RcbtInitialStack = base of kernel stack
        push    esp                     ; Save current esp for handler
        push    offset RgcaFault        ; Address of handler
        push    PCR[PcExceptionList]    ; Save current list head
        mov     PCR[PcExceptionList],esp; Put us on list
        xor     esi,esi                 ; (ESI) will contain callers return address
        xor     edi,edi                 ; (EDI) will contain callers caller return address

        mov     edx,ebp                 ; (EDX) = current frame pointer
        mov     edx,[edx]               ; (EDX) = callers frame pointer
        cmp     edx,ebp                 ; If outside stack limits,
        jbe     short RgcaExit          ; ...then exit
        cmp     edx,RcbtInitialStack
        jae     short RgcaCheckForDpcStack
        cmp     edx,ThStackLimit[eax]
        jb      short RgcaCheckForDpcStack

Rgca20:
        mov     esi,[edx].4             ; Get callers return address

        mov     edx,[edx]               ; (EDX) = callers caller frame pointer
        cmp     edx,ebp                 ; If outside stack limits,
        jbe     short RgcaExit          ; ...then exit
        cmp     edx,RcbtInitialStack
        jae     short RgcaExit

        mov     edi,[edx].4             ; Get callers caller return address
RgcaExit:
        mov     ecx,RgcaCallersAddress
        jecxz   @F
        mov     [ecx],esi
@@:
        mov     ecx,RgcaCallersCaller
        jecxz   @F
        mov     [ecx],edi
@@:
        pop     PCR[PcExceptionList]    ; Restore Exception list
        pop     edi                     ; discard handler address
        pop     edi                     ; discard saved esp
        pop     edi                     ; discard RcbtInitialStack
        pop     edi                     ; Restore EDI
        pop     esi                     ; Restore ESI
        pop     ebx                     ; Restore EBX
        pop     ebp
        stdRET  _RtlGetCallersAddress

;
; We may be executing on the DPC stack for this processor which is ok.
;

RgcaCheckForDpcStack:

        ; Check if DPC active.

        cmp     dword ptr PCR[PcPrcbData+PbDpcRoutineActive], 0
        mov     eax, PCR[PcPrcbData+PbDpcStack]
        je      short RgcaExit          ; if no DPC active, must be bad stack.

        ; Check if address if below DPC stack upper bound
        ;
        ; Note: If we ARE on the DPC stack, we need to adjust this function's
        ; idea of the initial stack pointer so it will succeed the check at
        ; the next level.   We do not support transitioning across stacks in
        ; this function.

        cmp     edx, eax
        mov     RcbtInitialStack, eax
        jae     short RgcaExit          ; exit if above upper bound

        ; Check if below DPC stack lower bound.

        sub     eax, KERNEL_STACK_SIZE
        cmp     edx, eax
        ja      short Rgca20            ; jif on DPC stack
        jmp     short RgcaExit          ; not on DPC stack.


RgcaFault:
;
; Quick and dirty exception handler.  This will not unwind properly, which
; is ok because this function is a leaf except for calling KeGetCurrentIrql,
; which has no exception handler.
;
        mov     eax,[esp+0Ch]           ; (esp)->Context
        mov     edi,CsEdi[eax]          ; restore buffer pointer
        mov     esp,[esp+8]             ; (esp)->ExceptionList
        jmp     RgcaExit                ;
stdENDP _RtlGetCallersAddress

RcbtInitialStack        EQU [ebp-10h]

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\stringsp.asm ===
TITLE   "String support routines"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    stringsup.asm
;
; Abstract:
;
;    This module implements supplementary routines for performing string
;    operations.
;
;--

.386p

include ks386.inc
include callconv.inc            ; calling convention macros

if DBG
_DATA   SEGMENT  DWORD PUBLIC 'DATA'

_MsgStringTooLong   db  'RTL: RtlInit*String called with string length: (%x)\n',0

_DATA ENDS

    extrn   _KdDebuggerEnabled:BYTE
    EXTRNP  _DbgBreakPoint,0
    extrn   _DbgPrint:near
endif


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "RtlInitAnsiString"
;++
;
; VOID
; RtlInitAnsiString(
;     OUT PANSI_STRING DestinationString,
;     IN PSZ SourceString OPTIONAL
;     )
;
;
; Routine Description:
;
;    The RtlInitAnsiString function initializes an NT counted string.
;    The DestinationString is initialized to point to the SourceString
;    and the Length and MaximumLength fields of DestinationString are
;    initialized to the length of the SourceString, which is zero if
;    SourceString is not specified.
;
; Arguments:
;
;    (TOS+4) = DestinationString - Pointer to the counted string to initialize
;
;    (TOS+8) = SourceString - Optional pointer to a null terminated string that
;        the counted string is to point to.
;
;
; Return Value:
;
;    None.
;
; NOTE:
;       This routine assumes that the string is less than 64K in size.
;
;--

cPublicProc _RtlInitString ,2
cPublicFpo 2,2
        push    edi
        mov     edi,[esp]+8+4           ; (edi)= SourceString
        mov     edx,[esp]+4+4           ; (esi)= DestinationString
        mov     DWORD PTR [edx], 0      ; (Destination).Length = (Destination).MaximumLength = 0
        mov     DWORD PTR [edx]+4, edi  ; (Destination).Buffer = 0
        or      edi, edi
        jz      @f
        or      ecx, -1
        xor     eax, eax
        repne   scasb
        not     ecx
        cmp     ecx,0ffffh
        jbe     rtis

;
; spew length and bp if debugger attached.
;
if DBG
        push    edx
        push    ecx
        push    offset FLAT:_MsgStringTooLong
        call    _DbgPrint
        add     esp, 2 * 4
        cmp     _KdDebuggerEnabled,0
        je      nobp1
        call    _DbgBreakPoint@0
nobp1:  pop     edx
endif

        mov     ecx,0ffffh              ; overflow, truncate at MAXUSHORT
rtis:   mov     [edx]+2, cx             ; Save maximum length
        dec     ecx
        mov     [edx], cx               ; Save length
@@:     pop     edi
        stdRET    _RtlInitString

stdENDP _RtlInitString


cPublicProc _RtlInitAnsiString ,2
cPublicFpo 2,2
        push    edi
        mov     edi,[esp]+8+4           ; (edi)= SourceString
        mov     edx,[esp]+4+4           ; (esi)= DestinationString
        mov     DWORD PTR [edx], 0      ; (Destination).Length = (Destination).MaximumLength = 0
        mov     DWORD PTR [edx]+4, edi  ; (Destination).Buffer = 0
        or      edi, edi
        jz      @f
        or      ecx, -1
        xor     eax, eax
        repne   scasb
        not     ecx
        cmp     ecx,0ffffh
        jbe     rtias
;
; spew length and bp if debugger attached.
;
if DBG
        push    edx
        push    ecx
        push    offset FLAT:_MsgStringTooLong
        call    _DbgPrint
        add     esp, 2 * 4
        cmp     _KdDebuggerEnabled,0
        je      nobp2
        call    _DbgBreakPoint@0
nobp2:  pop    edx
endif

        mov     ecx,0ffffh              ; overflow, truncate at MAXUSHORT
rtias:  mov     [edx]+2, cx             ; Save maximum length
        dec     ecx
        mov     [edx], cx               ; Save length
@@:     pop     edi
        stdRET    _RtlInitAnsiString

stdENDP _RtlInitAnsiString


        page
        subttl  "RtlInitUnicodeString"
;++
;
; VOID
; RtlInitUnicodeString(
;     OUT PUNICODE_STRING DestinationString,
;     IN PWSTR SourceString OPTIONAL
;     )
;
;
; Routine Description:
;
;    The RtlInitUnicodeString function initializes an NT counted string.
;    The DestinationString is initialized to point to the SourceString
;    and the Length and MaximumLength fields of DestinationString are
;    initialized to the length of the SourceString, which is zero if
;    SourceString is not specified.
;
; Arguments:
;
;    (TOS+4) = DestinationString - Pointer to the counted string to initialize
;
;    (TOS+8) = SourceString - Optional pointer to a null terminated string that
;        the counted string is to point to.
;
;
; Return Value:
;
;    None.
;
; NOTE:
;       This routine assumes that the string is less than 64K in size.
;
;--

cPublicProc _RtlInitUnicodeString ,2
cPublicFpo 2,2
        push    edi
        mov     edi,[esp]+8+4           ; (edi)= SourceString
        mov     edx,[esp]+4+4           ; (esi)= DestinationString
        mov     DWORD PTR [edx], 0      ; (Destination).Length = (Destination).MaximumLength = 0
        mov     DWORD PTR [edx]+4, edi  ; (Destination).Buffer = 0
        or      edi, edi
        jz      @f
        or      ecx, -1
        xor     eax, eax
        repne   scasw
        not     ecx
        shl     ecx,1
        cmp     ecx,0fffeh
        jbe     rtius

;
; spew length and bp if debugger attached.
;
if DBG
        push    edx
        push    ecx
        push    offset FLAT:_MsgStringTooLong
        call    _DbgPrint
        add     esp, 2 * 4
        cmp     _KdDebuggerEnabled,0
        je      nobp3
        call    _DbgBreakPoint@0
nobp3:  pop     edx
endif

        mov     ecx,0fffeh              ; overflow, truncate at MAX_USTRING
rtius:  mov     [edx]+2, cx             ; Save maximum length
        dec     ecx
        dec     ecx
        mov     [edx], cx               ; Save length
@@:     pop     edi
        stdRET    _RtlInitUnicodeString

stdENDP _RtlInitUnicodeString

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\accessck.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Accessck.c

Abstract:

    This Module implements the access check procedures.  Both NtAccessCheck
    and SeAccessCheck check to is if a user (denoted by an input token) can
    be granted the desired access rights to object protected by a security
    descriptor and an optional object owner.  Both procedures use a common
    local procedure to do the test.

--*/

#include "pch.h"

#pragma hdrstop

#include <sertlp.h>


//
//  Define the local macros and procedure for this module
//

#if DBG

extern BOOLEAN SepDumpSD;
extern BOOLEAN SepDumpToken;
BOOLEAN SepShowAccessFail;

#endif // DBG



VOID
SepUpdateParentTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN ULONG StartIndex
    );

typedef enum {
    UpdateRemaining,
    UpdateCurrentGranted,
    UpdateCurrentDenied
} ACCESS_MASK_FIELD_TO_UPDATE;

VOID
SepAddAccessTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN ULONG StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate
    );

NTSTATUS
SeAccessCheckByType (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    IN BOOLEAN ReturnResultList
    );

VOID
SepMaximumAccessCheck(
    IN PTOKEN EToken,
    IN PTOKEN PrimaryToken,
    IN PACL Dacl,
    IN PSID PrincipalSelfSid,
    IN ULONG LocalTypeListLength,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN ULONG ObjectTypeListLength,
    IN BOOLEAN Restricted
    );

VOID
SepNormalAccessCheck(
    IN ACCESS_MASK Remaining,
    IN PTOKEN EToken,
    IN PTOKEN PrimaryToken,
    IN PACL Dacl,
    IN PSID PrincipalSelfSid,
    IN ULONG LocalTypeListLength,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN ULONG ObjectTypeListLength,
    IN BOOLEAN Restricted
    );

BOOLEAN
SepSidInTokenEx (
    IN PACCESS_TOKEN AToken,
    IN PSID PrincipalSelfSid,
    IN PSID Sid,
    IN BOOLEAN DenyAce,
    IN BOOLEAN Restricted
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SeCaptureObjectTypeList)
#pragma alloc_text(PAGE,SeFreeCapturedObjectTypeList)
#pragma alloc_text(PAGE,SepUpdateParentTypeList)
#pragma alloc_text(PAGE,SepObjectInTypeList)
#pragma alloc_text(PAGE,SepAddAccessTypeList)
#pragma alloc_text(PAGE,SepSidInToken)
#pragma alloc_text(PAGE,SepSidInTokenEx)
#pragma alloc_text(PAGE,SepAccessCheck)
#pragma alloc_text(PAGE,NtAccessCheck)
#pragma alloc_text(PAGE,NtAccessCheckByType)
#pragma alloc_text(PAGE,NtAccessCheckByTypeResultList)
#pragma alloc_text(PAGE,SeAccessCheckByType)
#pragma alloc_text(PAGE,SeFreePrivileges)
#pragma alloc_text(PAGE,SeAccessCheck)
#pragma alloc_text(PAGE,SePrivilegePolicyCheck)
#pragma alloc_text(PAGE,SepTokenIsOwner)
#pragma alloc_text(PAGE,SeFastTraverseCheck)
#pragma alloc_text(PAGE,SepMaximumAccessCheck)
#pragma alloc_text(PAGE,SepNormalAccessCheck)
#pragma alloc_text(PAGE,SeMaximumAuditMask)
#endif


NTSTATUS
SeCaptureObjectTypeList (
    __in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in ULONG ObjectTypeListLength,
    __in KPROCESSOR_MODE RequestorMode,
    __out PIOBJECT_TYPE_LIST *CapturedObjectTypeList
)
/*++

Routine Description:

    This routine probes and captures a copy of any object type list
    that might have been provided via the ObjectTypeList argument.

    The object type list is converted to the internal form that explicitly
    specifies the hierarchical relationship between the entries.

    The object types list is validated to ensure a valid hierarchical
    relationship is represented.

Arguments:

    ObjectTypeList - The object type list from which the type list
        information is to be retrieved.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    RequestorMode - Indicates the processor mode by which the access
        is being requested.

    CapturedObjectTypeList - Receives the captured type list which
        must be freed using SeFreeCapturedObjectTypeList().

Return Value:

    STATUS_SUCCESS indicates no exceptions were encountered.

    Any access violations encountered will be returned.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;
    PIOBJECT_TYPE_LIST LocalTypeList = NULL;

    ULONG Levels[ACCESS_MAX_LEVEL+1];

    PAGED_CODE();

    //
    //  Set default return
    //

    *CapturedObjectTypeList = NULL;

    if (RequestorMode != UserMode) {
        return STATUS_NOT_IMPLEMENTED;
    }

    try {

        if ( ObjectTypeListLength == 0 ) {

            // Drop through

        } else if ( !ARGUMENT_PRESENT(ObjectTypeList) ) {

            Status = STATUS_INVALID_PARAMETER;

        } else {

            if ( !IsValidElementCount( ObjectTypeListLength, IOBJECT_TYPE_LIST ) )
            {
                Status = STATUS_INVALID_PARAMETER ;

                //
                // No more to do, get out of the try statement:
                //

                leave ;
            }

            ProbeForRead( ObjectTypeList,
                          sizeof(OBJECT_TYPE_LIST) * ObjectTypeListLength,
                          sizeof(ULONG)
                          );

            //
            // Allocate a buffer to copy into.
            //

            LocalTypeList = ExAllocatePoolWithTag( PagedPool, sizeof(IOBJECT_TYPE_LIST) * ObjectTypeListLength, 'tOeS' );

            if ( LocalTypeList == NULL ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;

            //
            // Copy the callers structure to the local structure.
            //

            } else {
                GUID * CapturedObjectType;
                for ( i=0; i<ObjectTypeListLength; i++ ) {
                    USHORT CurrentLevel;

                    //
                    // Limit ourselves
                    //
                    CurrentLevel = ObjectTypeList[i].Level;
                    if ( CurrentLevel > ACCESS_MAX_LEVEL ) {
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }

                    //
                    // Copy data the caller passed in
                    //
                    LocalTypeList[i].Level = CurrentLevel;
                    LocalTypeList[i].Flags = 0;
                    CapturedObjectType = ObjectTypeList[i].ObjectType;
                    ProbeForReadSmallStructure(
                        CapturedObjectType,
                        sizeof(GUID),
                        sizeof(ULONG)
                        );
                    LocalTypeList[i].ObjectType = *CapturedObjectType;
                    LocalTypeList[i].Remaining = 0;
                    LocalTypeList[i].CurrentGranted = 0;
                    LocalTypeList[i].CurrentDenied = 0;

                    //
                    // Ensure that the level number is consistent with the
                    //  level number of the previous entry.
                    //

                    if ( i == 0 ) {
                        if ( CurrentLevel != 0 ) {
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                        }

                    } else {

                        //
                        // The previous entry is either:
                        //  my immediate parent,
                        //  my sibling, or
                        //  the child (or grandchild, etc.) of my sibling.
                        //
                        if ( CurrentLevel > LocalTypeList[i-1].Level + 1 ) {
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                        }

                        //
                        // Don't support two roots.
                        //
                        if ( CurrentLevel == 0 ) {
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                        }

                    }

                    //
                    // If the above rules are maintained,
                    //  then my parent object is the last object seen that
                    //  has a level one less than mine.
                    //

                    if ( CurrentLevel == 0 ) {
                        LocalTypeList[i].ParentIndex = -1;
                    } else {
                        LocalTypeList[i].ParentIndex = Levels[CurrentLevel-1];
                    }

                    //
                    // Save this object as the last object seen at this level.
                    //

                    Levels[CurrentLevel] = i;

                }

            }

        } // end_if

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();

    } // end_try


    if ( NT_SUCCESS( Status ) ) {

        *CapturedObjectTypeList = LocalTypeList;

    } else {

        //
        // If we captured any proxy data, we need to free it now.
        //

        if ( LocalTypeList != NULL ) {
            ExFreePool( LocalTypeList );
        }
    }

    return Status;
}


VOID
SeFreeCapturedObjectTypeList(
    __in PVOID ObjectTypeList
    )

/*++

Routine Description:

    This routine frees the data associated with a captured ObjectTypeList
    structure.

Arguments:

    ObjectTypeList - Points to a captured object type list structure.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    if ( ObjectTypeList != NULL ) {
        ExFreePool( ObjectTypeList );
    }

    return;
}




BOOLEAN
SepObjectInTypeList (
    IN GUID *ObjectType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    OUT PULONG ReturnedIndex
)
/*++

Routine Description:

    This routine searches an ObjectTypeList to determine if the specified
    object type is in the list.

Arguments:

    ObjectType - Object Type to search for.

    ObjectTypeList - The object type list to search.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    ReturnedIndex - Index to the element ObjectType was found in


Return Value:

    TRUE: ObjectType was found in list.
    FALSE: ObjectType was not found in list.

--*/

{
    ULONG Index;
    GUID *LocalObjectType;

    PAGED_CODE();

    ASSERT( sizeof(GUID) == sizeof(ULONG) * 4 );
    for ( Index=0; Index<ObjectTypeListLength; Index++ ) {

        LocalObjectType = &ObjectTypeList[Index].ObjectType;

        if  ( RtlpIsEqualGuid( ObjectType, LocalObjectType ) ) {
            *ReturnedIndex = Index;
            return TRUE;
        }
    }

    return FALSE;
}


VOID
SepUpdateParentTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN ULONG StartIndex
)
/*++

Routine Description:

    Update the Access fields of the parent object of the specified object.


        The "remaining" field of a parent object is the logical OR of
        the remaining field of all of its children.

        The CurrentGranted field of the parent is the collection of bits
        granted to every one of its children..

        The CurrentDenied fields of the parent is the logical OR of
        the bits denied to any of its children.

    This routine takes an index to one of the children and updates the
    remaining field of the parent (and grandparents recursively).

Arguments:

    ObjectTypeList - The object type list to update.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    StartIndex - Index to the "child" element whose parents are to be updated.

Return Value:

    None.


--*/

{
    ULONG Index;
    ULONG ParentIndex;
    ULONG Level;
    ACCESS_MASK NewRemaining = 0;
    ACCESS_MASK NewCurrentGranted = 0xFFFFFFFF;
    ACCESS_MASK NewCurrentDenied = 0;

    PAGED_CODE();

    //
    // If the target node is at the root,
    //  we're all done.
    //

    if ( ObjectTypeList[StartIndex].ParentIndex == -1 ) {
        return;
    }

    //
    // Get the index to the parent that needs updating and the level of
    // the siblings.
    //

    ParentIndex = ObjectTypeList[StartIndex].ParentIndex;
    Level = ObjectTypeList[StartIndex].Level;

    //
    // Loop through all the children.
    //

    for ( Index=ParentIndex+1; Index<ObjectTypeListLength; Index++ ) {

        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if ( ObjectTypeList[Index].Level <= ObjectTypeList[ParentIndex].Level ) {
            break;
        }

        //
        // Only handle direct children of the parent.
        //

        if ( ObjectTypeList[Index].Level != Level ) {
            continue;
        }

        //
        // Compute the new bits for the parent.
        //

        NewRemaining |= ObjectTypeList[Index].Remaining;
        NewCurrentGranted &= ObjectTypeList[Index].CurrentGranted;
        NewCurrentDenied |= ObjectTypeList[Index].CurrentDenied;

    }

    //
    // If we've not changed the access to the parent,
    //  we're done.
    //

    if ( NewRemaining == ObjectTypeList[ParentIndex].Remaining &&
         NewCurrentGranted == ObjectTypeList[ParentIndex].CurrentGranted &&
        NewCurrentDenied == ObjectTypeList[ParentIndex].CurrentDenied ) {
        return;
    }


    //
    // Change the parent.
    //

    ObjectTypeList[ParentIndex].Remaining = NewRemaining;
    ObjectTypeList[ParentIndex].CurrentGranted = NewCurrentGranted;
    ObjectTypeList[ParentIndex].CurrentDenied = NewCurrentDenied;

    //
    // Go update the grand parents.
    //

    SepUpdateParentTypeList( ObjectTypeList,
                             ObjectTypeListLength,
                             ParentIndex );
}


VOID
SepAddAccessTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN ULONG StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate
)
/*++

Routine Description:

    This routine grants the specified AccessMask to all of the objects that
    are descendents of the object specified by StartIndex.

    The Access fields of the parent objects are also recomputed as needed.

    For example, if an ACE granting access to a Property Set is found,
        that access is granted to all the Properties in the Property Set.

Arguments:

    ObjectTypeList - The object type list to update.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    StartIndex - Index to the target element to update.

    AccessMask - Mask of access to grant to the target element and
        all of its descendents

    FieldToUpdate - Indicate which fields to update in object type list

Return Value:

    None.

--*/

{
    ULONG Index;
    ACCESS_MASK OldRemaining;
    ACCESS_MASK OldCurrentGranted;
    ACCESS_MASK OldCurrentDenied;
    BOOLEAN AvoidParent = FALSE;

    PAGED_CODE();

    //
    // Update the requested field.
    //
    // Always handle the target entry.
    //
    // If we've not actually changed the bits,
    //  early out.
    //

    switch (FieldToUpdate ) {
    case UpdateRemaining:

        OldRemaining = ObjectTypeList[StartIndex].Remaining;
        ObjectTypeList[StartIndex].Remaining = OldRemaining & ~AccessMask;

        if ( OldRemaining == ObjectTypeList[StartIndex].Remaining ) {
            return;
        }
        break;

    case UpdateCurrentGranted:

        OldCurrentGranted = ObjectTypeList[StartIndex].CurrentGranted;
        ObjectTypeList[StartIndex].CurrentGranted |=
            AccessMask & ~ObjectTypeList[StartIndex].CurrentDenied;

        if ( OldCurrentGranted == ObjectTypeList[StartIndex].CurrentGranted ) {
            //
            // We can't simply return here.
            // We have to visit our children.  Consider the case where there
            // was a previous deny ACE on a child.  That deny would have
            // propagated up the tree to this entry.  However, this allow ACE
            // needs to be added all of the children that haven't been
            // explictly denied.
            //
            AvoidParent = TRUE;
        }
        break;

    case UpdateCurrentDenied:

        OldCurrentDenied = ObjectTypeList[StartIndex].CurrentDenied;
        ObjectTypeList[StartIndex].CurrentDenied |=
            AccessMask & ~ObjectTypeList[StartIndex].CurrentGranted;

        if ( OldCurrentDenied == ObjectTypeList[StartIndex].CurrentDenied ) {
            
            //
            // We must visit the children - consider the case where we
            // are applying an ACCESS_DENIED Ace to the entire tree.  
            // Suppose a node of the tree was already DENIED the same bits
            // via an ACCESS_DENIED_OBJECT_ACE.  Those deny bits would have
            // propagated up the tree.  If we are denying the bits to this
            // node then we must visit the children.
            //

            AvoidParent = TRUE;
        }
        break;

    default:
        return;
    }


    //
    // Go update parent of the target.
    //

    if ( !AvoidParent ) {
        SepUpdateParentTypeList( ObjectTypeList,
                                 ObjectTypeListLength,
                                 StartIndex );
    }

    //
    // Loop handling all children of the target.
    //

    for ( Index=StartIndex+1; Index<ObjectTypeListLength; Index++ ) {

        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if ( ObjectTypeList[Index].Level <= ObjectTypeList[StartIndex].Level ) {
            break;
        }

        //
        // Grant access to the children
        //

        switch (FieldToUpdate) {
        case UpdateRemaining:

            ObjectTypeList[Index].Remaining &= ~AccessMask;
            break;

        case UpdateCurrentGranted:

            ObjectTypeList[Index].CurrentGranted |=
                AccessMask & ~ObjectTypeList[Index].CurrentDenied;
            break;

        case UpdateCurrentDenied:

            ObjectTypeList[Index].CurrentDenied |=
                AccessMask & ~ObjectTypeList[Index].CurrentGranted;
            break;

        default:
            return;
        }
    }
}

BOOLEAN
SepSidInToken (
    IN PACCESS_TOKEN AToken,
    IN PSID PrincipalSelfSid,
    IN PSID Sid,
    IN BOOLEAN DenyAce
    )

/*++

Routine Description:

    Checks to see if a given SID is in the given token.

    N.B. The code to compute the length of a SID and test for equality
         is duplicated from the security runtime since this is such a
         frequently used routine.

Arguments:

    Token - Pointer to the token to be examined

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.


    Sid - Pointer to the SID of interest

Return Value:

    A value of TRUE indicates that the SID is in the token, FALSE
    otherwise.

--*/

{

    ULONG i;
    PISID MatchSid;
    ULONG SidLength;
    PTOKEN Token;
    PSID_AND_ATTRIBUTES TokenSid;
    ULONG UserAndGroupCount;
    USHORT TargetShort;

    C_ASSERT (FIELD_OFFSET (SID, Revision) + sizeof (((SID *)Sid)->Revision) == FIELD_OFFSET (SID, SubAuthorityCount));
    C_ASSERT (sizeof (((SID *)Sid)->Revision) + sizeof (((SID *)Sid)->SubAuthorityCount) == sizeof (USHORT));


    PAGED_CODE();

#if DBG

    SepDumpTokenInfo(AToken);

#endif

    //
    // If Sid is the constant PrincipalSelfSid,
    //  replace it with the passed in PrincipalSelfSid.
    //

    if ( PrincipalSelfSid != NULL &&
         RtlEqualSid( SePrincipalSelfSid, Sid ) ) {
        Sid = PrincipalSelfSid;
    }

    //
    // Get the length of the source SID since this only needs to be computed
    // once.
    //
    SidLength = 8 + (4 * ((PISID)Sid)->SubAuthorityCount);

    //
    // To speed up processing we compare the sub authority count and the revision at the same time.
    //
    TargetShort = *(USHORT *)&((PISID)Sid)->Revision;

    //
    // Get address of user/group array and number of user/groups.
    //

    Token = (PTOKEN)AToken;
    TokenSid = Token->UserAndGroups;
    UserAndGroupCount = Token->UserAndGroupCount;

    //
    // Scan through the user/groups and attempt to find a match with the
    // specified SID.
    //

    for (i = 0 ; i < UserAndGroupCount ; i += 1) {
        MatchSid = (PISID)TokenSid->Sid;

        //
        // If revision and sub authority count matches, then compare the SIDs
        // for equality.
        //

        if (*(USHORT *) &MatchSid->Revision == TargetShort) {
            if (RtlEqualMemory(Sid, MatchSid, SidLength)) {

                //
                // If this is the first one in the list, then it is the User,
                // and return success immediately.
                //
                // If this is not the first one, then it represents a group,
                // and we must make sure the group is currently enabled before
                // we can say that the group is "in" the token.
                //

                if ((i == 0) || (TokenSid->Attributes & SE_GROUP_ENABLED) ||
                    (DenyAce && (TokenSid->Attributes & SE_GROUP_USE_FOR_DENY_ONLY))) {
                    return TRUE;

                } else {
                    return FALSE;
                }
            }
        }

        TokenSid += 1;
    }

    return FALSE;
}

BOOLEAN
SepSidInTokenEx (
    IN PACCESS_TOKEN AToken,
    IN PSID PrincipalSelfSid,
    IN PSID Sid,
    IN BOOLEAN DenyAce,
    IN BOOLEAN Restricted
    )

/*++

Routine Description:

    Checks to see if a given restricted SID is in the given token.

    N.B. The code to compute the length of a SID and test for equality
         is duplicated from the security runtime since this is such a
         frequently used routine.

Arguments:

    Token - Pointer to the token to be examined

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.


    Sid - Pointer to the SID of interest

    DenyAce - The ACE being evaluated is a DENY or ACCESS DENIED ace

    Restricted - The access check being performed uses the restricted sids.

Return Value:

    A value of TRUE indicates that the SID is in the token, FALSE
    otherwise.

--*/

{

    ULONG i;
    PISID MatchSid;
    ULONG SidLength;
    PTOKEN Token;
    PSID_AND_ATTRIBUTES TokenSid;
    ULONG UserAndGroupCount;
    USHORT TargetShort;

    C_ASSERT (FIELD_OFFSET (SID, Revision) + sizeof (((SID *)Sid)->Revision) == FIELD_OFFSET (SID, SubAuthorityCount));
    C_ASSERT (sizeof (((SID *)Sid)->Revision) + sizeof (((SID *)Sid)->SubAuthorityCount) == sizeof (USHORT));

    PAGED_CODE();

#if DBG

    SepDumpTokenInfo(AToken);

#endif

    //
    // If Sid is the constant PrincipalSelfSid,
    //  replace it with the passed in PrincipalSelfSid.
    //

    if ( PrincipalSelfSid != NULL &&
         RtlEqualSid( SePrincipalSelfSid, Sid ) ) {
        Sid = PrincipalSelfSid;
    }

    //
    // Get the length of the source SID since this only needs to be computed
    // once.
    //

    //
    // Get the length of the source SID since this only needs to be computed
    // once.
    //
    SidLength = 8 + (4 * ((PISID)Sid)->SubAuthorityCount);

    //
    // To speed up processing we compare the sub authority count and the revision at the same time.
    //
    TargetShort = *(USHORT *)&((PISID)Sid)->Revision;

    //
    // Get address of user/group array and number of user/groups.
    //

    Token = (PTOKEN)AToken;
    if (Restricted) {
        TokenSid = Token->RestrictedSids;
        UserAndGroupCount = Token->RestrictedSidCount;
    } else {
        TokenSid = Token->UserAndGroups;
        UserAndGroupCount = Token->UserAndGroupCount;
    }

    //
    // Scan through the user/groups and attempt to find a match with the
    // specified SID.
    //

    for (i = 0; i < UserAndGroupCount ; i += 1) {
        MatchSid = (PISID)TokenSid->Sid;

        //
        // If the SID revision and length matches, then compare the SIDs
        // for equality.
        //

        if (*(USHORT *) &MatchSid->Revision == TargetShort) {
            if (RtlEqualMemory(Sid, MatchSid, SidLength)) {

                //
                // If this is the first one in the list and not deny-only it
                // is not a restricted token then it is the User, and return
                // success immediately.
                //
                // If this is not the first one, then it represents a group,
                // and we must make sure the group is currently enabled before
                // we can say that the group is "in" the token.
                //

                if ((!Restricted && (i == 0) && ((TokenSid->Attributes & SE_GROUP_USE_FOR_DENY_ONLY) == 0)) ||
                    (TokenSid->Attributes & SE_GROUP_ENABLED) ||
                    (DenyAce && (TokenSid->Attributes & SE_GROUP_USE_FOR_DENY_ONLY))) {
                    return TRUE;

                } else {
                    return FALSE;
                }

            }
        }

        TokenSid += 1;
    }

    return FALSE;
}

VOID
SepMaximumAccessCheck(
    IN PTOKEN EToken,
    IN PTOKEN PrimaryToken,
    IN PACL Dacl,
    IN PSID PrincipalSelfSid,
    IN ULONG LocalTypeListLength,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN ULONG ObjectTypeListLength,
    IN BOOLEAN Restricted
    )
/*++

Routine Description:

    Does an access check for maximum allowed or with a result list. If the
    Restricted flag is set, it is done for a restricted token. The sids
    checked are the restricted sids, not the users and groups. The current
    granted access is stored in the Remaining access and then another access
    check is run.

Arguments:

    EToken - Effective token of caller.

    PrimaryToken - Process token of calling process

    Dacl - ACL to check

    PrincipalSelfSid - Sid to use in replacing the well-known self sid

    LocalTypeListLength - Length of list of types.

    LocalTypeList - List of types.

    ObjectTypeList - Length of caller-supplied list of object types.

Return Value:

    none

--*/

{
    ULONG i,j;
    PVOID Ace;
    ULONG AceCount;
    ULONG Index;
    ULONG ResultListIndex;

    //
    // The remaining bits are the granted bits for each object type on a
    // restricted check
    //

    if ( Restricted ) {
        for ( j=0; j<LocalTypeListLength; j++ ) {
            LocalTypeList[j].Remaining = LocalTypeList[j].CurrentGranted;
            LocalTypeList[j].CurrentGranted = 0;
        }
    }


    AceCount = Dacl->AceCount;

    //
    // granted == NUL
    // denied == NUL
    //
    //  for each ACE
    //
    //      if grant
    //          for each SID
    //              if SID match, then add all that is not denied to grant mask
    //
    //      if deny
    //          for each SID
    //              if SID match, then add all that is not granted to deny mask
    //

    for ( i = 0, Ace = FirstAce( Dacl ) ;
          i < AceCount  ;
          i++, Ace = NextAce( Ace )
        ) {

        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) {

            if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_ACE_TYPE) ) {

                if (SepSidInTokenEx( EToken, PrincipalSelfSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart, FALSE, Restricted )) {

                    //
                    // Only grant access types from this mask that have
                    // not already been denied
                    //

                    // Optimize 'normal' case
                    if ( LocalTypeListLength == 1 ) {
                        LocalTypeList->CurrentGranted |=
                           (((PACCESS_ALLOWED_ACE)Ace)->Mask & ~LocalTypeList->CurrentDenied);
                    } else {
                       //
                       // The zeroeth object type represents the object itself.
                       //
                       SepAddAccessTypeList(
                            LocalTypeList,          // List to modify
                            LocalTypeListLength,    // Length of list
                            0,                      // Element to update
                            ((PACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                            UpdateCurrentGranted );
                    }
                 }


             //
             // Handle an object specific Access Allowed ACE
             //
             } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE) ) {
                 GUID *ObjectTypeInAce;

                 //
                 // If no object type is in the ACE,
                 //  treat this as an ACCESS_ALLOWED_ACE.
                 //

                 ObjectTypeInAce = RtlObjectAceObjectType(Ace);

                 if ( ObjectTypeInAce == NULL ) {

                     if ( SepSidInTokenEx( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), FALSE, Restricted ) ) {

                         // Optimize 'normal' case
                         if ( LocalTypeListLength == 1 ) {
                             LocalTypeList->CurrentGranted |=
                                (((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask & ~LocalTypeList->CurrentDenied);
                         } else {
                             SepAddAccessTypeList(
                                 LocalTypeList,          // List to modify
                                 LocalTypeListLength,    // Length of list
                                 0,                      // Element to update
                                 ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                 UpdateCurrentGranted );
                         }
                     }

                 //
                 // If no object type list was passed,
                 //  don't grant access to anyone.
                 //

                 } else if ( ObjectTypeListLength == 0 ) {

                     // Drop through


                //
                // If an object type is in the ACE,
                //   Find it in the LocalTypeList before using the ACE.
                //
                } else {

                     if ( SepSidInTokenEx( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), FALSE, Restricted ) ) {

                         if ( SepObjectInTypeList( ObjectTypeInAce,
                                                   LocalTypeList,
                                                   LocalTypeListLength,
                                                   &Index ) ) {
                             SepAddAccessTypeList(
                                  LocalTypeList,          // List to modify
                                  LocalTypeListLength,   // Length of list
                                  Index,                  // Element already updated
                                  ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                  UpdateCurrentGranted );
                         }
                     }
                }

             } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE) ) {

                 //
                 //  If we're impersonating, EToken is set to the Client, and if we're not,
                 //  EToken is set to the Primary.  According to the DSA architecture, if
                 //  we're asked to evaluate a compound ACE and we're not impersonating,
                 //  pretend we are impersonating ourselves.  So we can just use the EToken
                 //  for the client token, since it's already set to the right thing.
                 //


                 if ( SepSidInTokenEx(EToken, PrincipalSelfSid, RtlCompoundAceClientSid( Ace ), FALSE, Restricted) &&
                      SepSidInTokenEx(PrimaryToken, NULL, RtlCompoundAceServerSid( Ace ), FALSE, FALSE)
                    ) {

                     //
                     // Only grant access types from this mask that have
                     // not already been denied
                     //

                     // Optimize 'normal' case
                     if ( LocalTypeListLength == 1 ) {
                         LocalTypeList->CurrentGranted |=
                            (((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask & ~LocalTypeList->CurrentDenied);
                     } else {
                        //
                        // The zeroeth object type represents the object itself.
                        //
                        SepAddAccessTypeList(
                             LocalTypeList,          // List to modify
                             LocalTypeListLength,    // Length of list
                             0,                      // Element to update
                             ((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                             UpdateCurrentGranted );
                     }

                 }


             } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_ACE_TYPE) ) {

                 if ( SepSidInTokenEx( EToken, PrincipalSelfSid, &((PACCESS_DENIED_ACE)Ace)->SidStart, TRUE, Restricted )) {

                      //
                      // Only deny access types from this mask that have
                      // not already been granted
                      //

                     // Optimize 'normal' case
                     if ( LocalTypeListLength == 1 ) {
                         LocalTypeList->CurrentDenied |=
                             (((PACCESS_DENIED_ACE)Ace)->Mask & ~LocalTypeList->CurrentGranted);
                     } else {
                         //
                         // The zeroeth object type represents the object itself.
                         //
                         SepAddAccessTypeList(
                             LocalTypeList,          // List to modify
                             LocalTypeListLength,    // Length of list
                             0,                      // Element to update
                             ((PACCESS_DENIED_ACE)Ace)->Mask, // Access denied
                             UpdateCurrentDenied );
                    }
                 }


             //
             // Handle an object specific Access Denied ACE
             //
             } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_OBJECT_ACE_TYPE) ) {

                 if ( SepSidInTokenEx( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), TRUE, Restricted ) ) {
                     GUID *ObjectTypeInAce;

                     //
                     // If there is no object type in the ACE,
                     //  or if the caller didn't specify an object type list,
                     //  apply this deny ACE to the entire object.
                     //

                     ObjectTypeInAce = RtlObjectAceObjectType(Ace);

                     if ( ObjectTypeInAce == NULL ) {

                         if ( LocalTypeListLength == 1 ) {
                             LocalTypeList->CurrentDenied |=
                                 (((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask & ~LocalTypeList->CurrentGranted);
                         } else {

                             //
                             // The zeroeth object type represents the object itself.
                             //

                             SepAddAccessTypeList(
                                 LocalTypeList,          // List to modify
                                 LocalTypeListLength,    // Length of list
                                 0,
                                 ((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask, // Access denied
                                 UpdateCurrentDenied );
                         }
                     //
                     // If no object type list was passed,
                     //  don't grant access to anyone.
                     //

                     } else if ( ObjectTypeListLength == 0 ) {

                         LocalTypeList->CurrentDenied |=
                             (((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask & ~LocalTypeList->CurrentGranted);


                     //
                     // If an object type is in the ACE,
                     //   Find it in the LocalTypeList before using the ACE.
                     //

                     } else if ( SepObjectInTypeList( ObjectTypeInAce,
                                                          LocalTypeList,
                                                          LocalTypeListLength,
                                                          &Index ) ) {

                            SepAddAccessTypeList(
                                LocalTypeList,          // List to modify
                                LocalTypeListLength,    // Length of list
                                Index,                  // Element to update
                                ((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask, // Access denied
                                UpdateCurrentDenied );

                    }
                }
            }
        }
    }

    //
    // If this check was performed on the restricted SIDs, then CurrentGranted
    // contains the MAXIMUM_ALLOWED access for the set of SIDs.  A check on the
    // restricted SIDs must be constrained by the check on the normal SIDs, so 
    // AND the results together now.
    //

    if ( Restricted ) {
        for ( j=0; j<LocalTypeListLength; j++ ) {
            LocalTypeList[j].CurrentGranted &= LocalTypeList[j].Remaining;
        }
    }
}

VOID
SepNormalAccessCheck(
    IN ACCESS_MASK Remaining,
    IN PTOKEN EToken,
    IN PTOKEN PrimaryToken,
    IN PACL Dacl,
    IN PSID PrincipalSelfSid,
    IN ULONG LocalTypeListLength,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN ULONG ObjectTypeListLength,
    IN BOOLEAN Restricted
    )
/*++

Routine Description:

    Does an access check when the caller isn't asking for MAXIMUM_ALLOWED or
    a type result list. If the Restricted flag is set, the sids checked are
    the restricted sids, not the users and groups. The Remaining field is
    reset to the original remaining value and then another access check is run.

Arguments:

    Remaining - Remaining access desired after special checks

    EToken - Effective token of caller.

    PrimaryToken - Process token of calling process

    Dacl - ACL to check

    PrincipalSelfSid - Sid to use in replacing the well-known self sid

    LocalTypeListLength - Length of list of types.

    LocalTypeList - List of types.

    ObjectTypeList - Length of caller-supplied list of object types.

    Restricted - Use the restricted sids for the access check.

Return Value:

    none

--*/
{
    ULONG i,j;
    PVOID Ace;
    ULONG AceCount;
    ULONG Index;

    AceCount = Dacl->AceCount;

    //
    // The remaining bits are "remaining" at all levels
    //

    for ( j=0; j<LocalTypeListLength; j++ ) {
        LocalTypeList[j].Remaining = Remaining;
    }

    //
    // Process the DACL handling individual access bits.
    //

    for ( i = 0, Ace = FirstAce( Dacl ) ;
          ( i < AceCount ) && ( LocalTypeList->Remaining != 0 )  ;
          i++, Ace = NextAce( Ace ) ) {

        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) {

            //
            // Handle an Access Allowed ACE
            //

            if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_ACE_TYPE) ) {

               if ( SepSidInTokenEx( EToken, PrincipalSelfSid, &((PACCESS_ALLOWED_ACE   )Ace)->SidStart, FALSE, Restricted ) ) {

                   // Optimize 'normal' case
                   if ( LocalTypeListLength == 1 ) {
                       LocalTypeList->Remaining &= ~((PACCESS_ALLOWED_ACE)Ace)->Mask;
                   } else {
                       //
                       // The zeroeth object type represents the object itself.
                       //
                       SepAddAccessTypeList(
                            LocalTypeList,          // List to modify
                            LocalTypeListLength,    // Length of list
                            0,                      // Element to update
                            ((PACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                            UpdateRemaining );
                   }

               }


            //
            // Handle an object specific Access Allowed ACE
            //
            } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE) ) {
                GUID *ObjectTypeInAce;

                //
                // If no object type is in the ACE,
                //  treat this as an ACCESS_ALLOWED_ACE.
                //

                ObjectTypeInAce = RtlObjectAceObjectType(Ace);

                if ( ObjectTypeInAce == NULL ) {

                    if ( SepSidInTokenEx( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), FALSE, Restricted ) ) {

                       // Optimize 'normal' case
                       if ( LocalTypeListLength == 1 ) {
                           LocalTypeList->Remaining &= ~((PACCESS_ALLOWED_ACE)Ace)->Mask;
                       } else {
                           SepAddAccessTypeList(
                                LocalTypeList,          // List to modify
                                LocalTypeListLength,    // Length of list
                                0,                      // Element to update
                                ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                UpdateRemaining );
                       }
                    }

                //
                // If no object type list was passed,
                //  don't grant access to anyone.
                //

                } else if ( ObjectTypeListLength == 0 ) {

                    // Drop through


               //
               // If an object type is in the ACE,
               //   Find it in the LocalTypeList before using the ACE.
               //
               } else {

                    if ( SepSidInTokenEx( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), FALSE, Restricted ) ) {

                        if ( SepObjectInTypeList( ObjectTypeInAce,
                                                  LocalTypeList,
                                                  LocalTypeListLength,
                                                  &Index ) ) {
                            SepAddAccessTypeList(
                                 LocalTypeList,          // List to modify
                                 LocalTypeListLength,   // Length of list
                                 Index,                  // Element already updated
                                 ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                 UpdateRemaining );
                        }
                    }
               }


            //
            // Handle a compound Access Allowed ACE
            //

            } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE) ) {

                //
                // See comment in MAXIMUM_ALLOWED case as to why we can use EToken here
                // for the client.
                //

                if ( SepSidInTokenEx(EToken, PrincipalSelfSid, RtlCompoundAceClientSid( Ace ), FALSE, Restricted) &&
                     SepSidInTokenEx(PrimaryToken, NULL, RtlCompoundAceServerSid( Ace ), FALSE, Restricted) ) {

                    // Optimize 'normal' case
                    if ( LocalTypeListLength == 1 ) {
                        LocalTypeList->Remaining &= ~((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask;
                    } else {
                        SepAddAccessTypeList(
                             LocalTypeList,          // List to modify
                             LocalTypeListLength,    // Length of list
                             0,                      // Element to update
                             ((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                             UpdateRemaining );
                    }
                }



            //
            // Handle an Access Denied ACE
            //

            } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_ACE_TYPE) ) {

                if ( SepSidInTokenEx( EToken, PrincipalSelfSid, &((PACCESS_DENIED_ACE)Ace)->SidStart, TRUE, Restricted ) ) {

                    //
                    // The zeroeth element represents the object itself.
                    //  Just check that element.
                    //
                    if (LocalTypeList->Remaining & ((PACCESS_DENIED_ACE)Ace)->Mask) {

                        break;
                    }
                }


            //
            // Handle an object specific Access Denied ACE
            //
            } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_OBJECT_ACE_TYPE) ) {

                if ( SepSidInTokenEx( EToken, PrincipalSelfSid, RtlObjectAceSid(Ace), TRUE, Restricted ) ) {
                    GUID *ObjectTypeInAce;

                    //
                    // If there is no object type in the ACE,
                    //  or if the caller didn't specify an object type list,
                    //  apply this deny ACE to the entire object.
                    //

                    ObjectTypeInAce = RtlObjectAceObjectType(Ace);
                    if ( ObjectTypeInAce == NULL ||
                         ObjectTypeListLength == 0 ) {

                        //
                        // The zeroeth element represents the object itself.
                        //  Just check that element.
                        //
                        if (LocalTypeList->Remaining & ((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask) {
                            break;
                        }

                    //
                    // Otherwise apply the deny ACE to the object specified
                    //  in the ACE.
                    //

                    } else if ( SepObjectInTypeList( ObjectTypeInAce,
                                                  LocalTypeList,
                                                  LocalTypeListLength,
                                                  &Index ) ) {

                        if (LocalTypeList[Index].Remaining & ((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask) {
                            break;
                        }

                    }
               }
            }

        }
    }
}


VOID
SeMaximumAuditMask(
    IN PACL Sacl,
    IN ACCESS_MASK GrantedAccess,
    IN PACCESS_TOKEN Token,
    OUT PACCESS_MASK pAuditMask
    )
/*++

Routine Description:

    This routine takes the passed security descriptor and applies the
    "MAXIMUM_ALLOWED" algorithm to the SACL contained in the security
    descriptor if one exists.  This mask represents all the success audits
    that can occur from the passed subject context accessing the passed
    security descriptor.

    The code walks the SACL and for each SYSTEM_AUDIT_ACE found that
    matches the passed subject context, keeps a running total of the
    access bits in the ACE.  The resulting mask is then masked by the
    passed GrantedAccess mask, since we're only interested in the
    bits that the object is actually being opened for.

Arguments:

    Sacl - The Sacl to be examined.

    GrantedAccess - The access that has been granted to the object.

    Token - Supplies to effective token for the access attempt.

    pAuditMask - Returns the mask of bits to be audited (if any).

Return Value:

    None


--*/
{
    USHORT AceCount        = 0;
    PACE_HEADER Ace        = NULL;
    ACCESS_MASK AccessMask = (ACCESS_MASK)0;
    UCHAR AceFlags         = 0;

    USHORT i;

    //
    // Initialize OUT parameters
    //

    *pAuditMask = (ACCESS_MASK)0;

    //
    // Determine if there is an SACL in the security descriptor.
    // If not, nothing to do.
    //

    if (0 == (AceCount = Sacl->AceCount)) {
        return;
    }

    //
    // Iterate through the ACEs on the Sacl until either we reach
    // the end or discover that we have to take all possible actions,
    // in which case it doesn't pay to look any further
    //

    for ( i = 0, Ace = FirstAce( Sacl ) ;
          (i < AceCount) ;
          i++, Ace = NextAce( Ace ) ) {

        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) {

            if ( (((PACE_HEADER)Ace)->AceType == SYSTEM_AUDIT_ACE_TYPE) ) {

                AccessMask = ((PSYSTEM_AUDIT_ACE)Ace)->Mask;
                AceFlags   = ((PACE_HEADER)Ace)->AceFlags;

                if ((AccessMask & GrantedAccess) && (AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG)) {

                    if ( SepSidInToken( (PACCESS_TOKEN)Token, NULL, &((PSYSTEM_AUDIT_ACE)Ace)->SidStart, FALSE ) ) {

                        *pAuditMask |= (AccessMask & GrantedAccess);
                    }
                }
            }
        }
    }
}



BOOLEAN
SepAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN PTOKEN PrimaryToken,
    IN PTOKEN ClientToken OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN PIOBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN ACCESS_MASK PreviouslyGrantedAccess,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PACCESS_MASK GrantedAccess,
    OUT PPRIVILEGE_SET *Privileges OPTIONAL,
    OUT PNTSTATUS AccessStatus,
    IN BOOLEAN ReturnResultList,
    OUT PBOOLEAN ReturnSomeAccessGranted,
    OUT PBOOLEAN ReturnSomeAccessDenied
    )

/*++

Routine Description:

    Worker routine for SeAccessCheck and NtAccessCheck.  We actually do the
    access checking here.

    Whether or not we actually evaluate the DACL is based on the following
    interaction between the SE_DACL_PRESENT bit in the security descriptor
    and the value of the DACL pointer itself.


                          SE_DACL_PRESENT

                        SET          CLEAR

                   +-------------+-------------+
                   |             |             |
             NULL  |    GRANT    |    GRANT    |
                   |     ALL     |     ALL     |
     DACL          |             |             |
     Pointer       +-------------+-------------+
                   |             |             |
            !NULL  |  EVALUATE   |    GRANT    |
                   |    ACL      |     ALL     |
                   |             |             |
                   +-------------+-------------+

Arguments:

    SecurityDescriptor - Pointer to the security descriptor from the object
        being accessed.

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    PrimaryToken / ClientToken - Pointers to user's token objects.

    PreviousMode - Previous processor privilege mode

    TokenLocked - Boolean describing whether or not there is a read lock
        on the token.

    DesiredAccess - Access mask describing the user's desired access to the
        object.  This mask is assumed not to contain generic access types.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    PreviouslyGrantedAccess - Access mask indicating any access' that have
        already been granted by higher level routines

    GrantedAccess - Returns an access mask describing all granted access',
        or NULL.

    Privileges - Optionally supplies a pointer in which will be returned
        any privileges that were used for the access.  If this is null,
        it will be assumed that privilege checks have been done already.

    AccessStatus - Returns STATUS_SUCCESS or other error code to be
        propagated back to the caller

    ReturnResultList - If true, GrantedAccess and AccessStatus is actually
        an array of entries ObjectTypeListLength elements long.

    ReturnSomeAccessGranted - Returns a value of TRUE to indicate that some access'
        were granted, FALSE otherwise.

    ReturnSomeAccessDenied - Returns a value of FALSE if some of the requested
        access was not granted.  This will always be an inverse of SomeAccessGranted
        unless ReturnResultList is TRUE.  In that case,

Return Value:

    A value of TRUE indicates that some access' were granted, FALSE
    otherwise.

--*/
{
    NTSTATUS Status;
    ACCESS_MASK Remaining;
    BOOLEAN RetVal = TRUE;

    PACL Dacl;

    PVOID Ace;
    ULONG AceCount;

    ULONG i;
    ULONG j;
    ULONG Index;
    ULONG PrivilegeCount = 0;
    BOOLEAN Success = FALSE;
    BOOLEAN SystemSecurity = FALSE;
    BOOLEAN WriteOwner = FALSE;
    PTOKEN EToken;

    IOBJECT_TYPE_LIST FixedTypeList;
    PIOBJECT_TYPE_LIST LocalTypeList;
    ULONG LocalTypeListLength;
    ULONG ResultListIndex;

    PAGED_CODE();

#if DBG

    SepDumpSecurityDescriptor(
        SecurityDescriptor,
        "Input to SeAccessCheck\n"
        );

    if (ARGUMENT_PRESENT( ClientToken )) {
        SepDumpTokenInfo( ClientToken );
    }

    SepDumpTokenInfo( PrimaryToken );

#endif


    EToken = ARGUMENT_PRESENT( ClientToken ) ? ClientToken : PrimaryToken;

    //
    // Assert that there are no generic accesses in the DesiredAccess
    //

    SeAssertMappedCanonicalAccess( DesiredAccess );

    Remaining = DesiredAccess;


    //
    // Check for ACCESS_SYSTEM_SECURITY here,
    // fail if he's asking for it and doesn't have
    // the privilege.
    //

    if ( Remaining & ACCESS_SYSTEM_SECURITY ) {

        //
        // Bugcheck if we weren't given a pointer to return privileges
        // into.  Our caller was supposed to have taken care of this
        // in that case.
        //

        ASSERT( ARGUMENT_PRESENT( Privileges ));

        Success = SepSinglePrivilegeCheck (
                    SeSecurityPrivilege,
                    EToken,
                    PreviousMode
                    );

        if (!Success) {
            PreviouslyGrantedAccess = 0;
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto ReturnOneStatus;
        }

        //
        // Success, remove ACCESS_SYSTEM_SECURITY from remaining, add it
        // to PreviouslyGrantedAccess
        //

        Remaining &= ~ACCESS_SYSTEM_SECURITY;
        PreviouslyGrantedAccess |= ACCESS_SYSTEM_SECURITY;

        PrivilegeCount++;
        SystemSecurity = TRUE;

        if ( Remaining == 0 ) {
            Status = STATUS_SUCCESS;
            goto ReturnOneStatus;
        }

    }


    //
    // Get pointer to client SID's
    //

    Dacl = RtlpDaclAddrSecurityDescriptor( (PISECURITY_DESCRIPTOR)SecurityDescriptor );

    //
    //  If the SE_DACL_PRESENT bit is not set, the object has no
    //  security, so all accesses are granted.  If he's asking for
    //  MAXIMUM_ALLOWED, return the GENERIC_ALL field from the generic
    //  mapping.
    //
    //  Also grant all access if the Dacl is NULL.
    //

    if ( !RtlpAreControlBitsSet(
             (PISECURITY_DESCRIPTOR)SecurityDescriptor,
             SE_DACL_PRESENT) || (Dacl == NULL)) {


        //
        // Restricted tokens treat a NULL dacl the same as a DACL with no
        // ACEs.
        //
#ifdef SECURE_NULL_DACLS
        if (SeTokenIsRestricted( EToken )) {
            //
            // We know that Remaining != 0 here, because we
            // know it was non-zero coming into this routine,
            // and we've checked it against 0 every time we've
            // cleared a bit.
            //

            ASSERT( Remaining != 0 );

            //
            // There are ungranted accesses.  Since there is
            // nothing in the DACL, they will not be granted.
            // If, however, the only ungranted access at this
            // point is MAXIMUM_ALLOWED, and something has been
            // granted in the PreviouslyGranted mask, return
            // what has been granted.
            //

            if ( (Remaining == MAXIMUM_ALLOWED) && (PreviouslyGrantedAccess != (ACCESS_MASK)0) ) {
                Status = STATUS_SUCCESS;
                goto ReturnOneStatus;

            } else {
                PreviouslyGrantedAccess = 0;
                Status = STATUS_ACCESS_DENIED;
                goto ReturnOneStatus;
            }
        }
#endif //SECURE_NULL_DACLS
        if (DesiredAccess & MAXIMUM_ALLOWED) {

            //
            // Give him:
            //   GenericAll
            //   Anything else he asked for
            //

            PreviouslyGrantedAccess =
                GenericMapping->GenericAll |
                (DesiredAccess | PreviouslyGrantedAccess) & ~MAXIMUM_ALLOWED;

        } else {

            PreviouslyGrantedAccess |= DesiredAccess;
        }

        Status = STATUS_SUCCESS;
        goto ReturnOneStatus;
    }

    //
    // There is security on this object.  Check to see
    // if he's asking for WRITE_OWNER, and perform the
    // privilege check if so.
    //

    if ( (Remaining & WRITE_OWNER) && ARGUMENT_PRESENT( Privileges ) ) {

        Success = SepSinglePrivilegeCheck (
                    SeTakeOwnershipPrivilege,
                    EToken,
                    PreviousMode
                    );

        if (Success) {

            //
            // Success, remove WRITE_OWNER from remaining, add it
            // to PreviouslyGrantedAccess
            //

            Remaining &= ~WRITE_OWNER;
            PreviouslyGrantedAccess |= WRITE_OWNER;

            PrivilegeCount++;
            WriteOwner = TRUE;

            if ( Remaining == 0 ) {
                Status = STATUS_SUCCESS;
                goto ReturnOneStatus;
            }
        }
    }


    //
    // If the DACL is empty,
    // deny all access immediately.
    //

    if ((AceCount = Dacl->AceCount) == 0) {

        //
        // We know that Remaining != 0 here, because we
        // know it was non-zero coming into this routine,
        // and we've checked it against 0 every time we've
        // cleared a bit.
        //

        ASSERT( Remaining != 0 );

        //
        // There are ungranted accesses.  Since there is
        // nothing in the DACL, they will not be granted.
        // If, however, the only ungranted access at this
        // point is MAXIMUM_ALLOWED, and something has been
        // granted in the PreviouslyGranted mask, return
        // what has been granted.
        //

        if ( (Remaining == MAXIMUM_ALLOWED) && (PreviouslyGrantedAccess != (ACCESS_MASK)0) ) {
            Status = STATUS_SUCCESS;
            goto ReturnOneStatus;

        } else {
            PreviouslyGrantedAccess = 0;
            Status = STATUS_ACCESS_DENIED;
            goto ReturnOneStatus;
        }
    }

    //
    // Fake out a top level ObjectType list if none is passed by the caller.
    //

    if ( ObjectTypeListLength == 0 ) {
        LocalTypeList = &FixedTypeList;
        LocalTypeListLength = 1;
        RtlZeroMemory( &FixedTypeList, sizeof(FixedTypeList) );
        FixedTypeList.ParentIndex = -1;
    } else {
        LocalTypeList = ObjectTypeList;
        LocalTypeListLength = ObjectTypeListLength;
    }

    //
    // If the caller wants the MAXIMUM_ALLOWED or the caller wants the
    //  results on all objects and subobjects, use a slower algorithm
    //  that traverses all the ACEs.
    //

    if ( (DesiredAccess & MAXIMUM_ALLOWED) != 0 ||
         ReturnResultList ) {

        //
        // Do the normal maximum-allowed access check
        //

        SepMaximumAccessCheck(
            EToken,
            PrimaryToken,
            Dacl,
            PrincipalSelfSid,
            LocalTypeListLength,
            LocalTypeList,
            ObjectTypeListLength,
            FALSE
            );

        //
        // If this is a restricted token, do the additional access check
        //

        if (SeTokenIsRestricted( EToken ) ) {
            SepMaximumAccessCheck(
                EToken,
                PrimaryToken,
                Dacl,
                PrincipalSelfSid,
                LocalTypeListLength,
                LocalTypeList,
                ObjectTypeListLength,
                TRUE
                );
        }


        //
        // If the caller wants to know the individual results of each sub-object,
        //  sub-object,
        //  break it down for him.
        //

        if ( ReturnResultList ) {
            ACCESS_MASK GrantedAccessMask;
            ACCESS_MASK RequiredAccessMask;
            BOOLEAN SomeAccessGranted = FALSE;
            BOOLEAN SomeAccessDenied = FALSE;

            //
            // Compute mask of Granted access bits to tell the caller about.
            //  If he asked for MAXIMUM_ALLOWED,
            //      tell him everything,
            //  otherwise
            //      tell him what he asked about.
            //

            if (DesiredAccess & MAXIMUM_ALLOWED) {
                GrantedAccessMask = (ACCESS_MASK) ~MAXIMUM_ALLOWED;
                RequiredAccessMask = (DesiredAccess | PreviouslyGrantedAccess) & ~MAXIMUM_ALLOWED;
            } else {
                GrantedAccessMask = DesiredAccess | PreviouslyGrantedAccess;
                RequiredAccessMask = DesiredAccess | PreviouslyGrantedAccess;
            }




            //
            // Loop computing the access granted to each object and sub-object.
            //
            for ( ResultListIndex=0;
                  ResultListIndex<LocalTypeListLength;
                  ResultListIndex++ ) {

                //
                // Return the subset of the access granted that the caller
                //  expressed interest in.
                //

                GrantedAccess[ResultListIndex] =
                    (LocalTypeList[ResultListIndex].CurrentGranted |
                     PreviouslyGrantedAccess ) &
                    GrantedAccessMask;

                //
                // If absolutely no access was granted,
                //  indicate so.
                //
                if ( GrantedAccess[ResultListIndex] == 0 ) {
                    AccessStatus[ResultListIndex] = STATUS_ACCESS_DENIED;
                    SomeAccessDenied = TRUE;
                } else {

                    //
                    // If some requested access is still missing,
                    //  the bottom line is that access is denied.
                    //
                    // Note, that ByTypeResultList actually returns the
                    // partially granted access mask even though the caller
                    // really has no access to the object.
                    //

                    if  ( ((~GrantedAccess[ResultListIndex]) & RequiredAccessMask ) != 0 ) {
                        AccessStatus[ResultListIndex] = STATUS_ACCESS_DENIED;
                        SomeAccessDenied = TRUE;
                    } else {
                        AccessStatus[ResultListIndex] = STATUS_SUCCESS;
                        SomeAccessGranted = TRUE;
                    }
                }
            }

            if ( SomeAccessGranted && PrivilegeCount != 0 ) {

                SepAssemblePrivileges(
                    PrivilegeCount,
                    SystemSecurity,
                    WriteOwner,
                    Privileges
                    );

                if ( ( Privileges != NULL ) && ( *Privileges == NULL ) ) {

                    RetVal = FALSE;
                    SomeAccessGranted = FALSE;
                    SomeAccessDenied = TRUE;

                    for ( ResultListIndex=0;
                          ResultListIndex<LocalTypeListLength;
                          ResultListIndex++ ) {

                        AccessStatus[ResultListIndex] = STATUS_NO_MEMORY;
                        GrantedAccess[ResultListIndex] = 0;
                    }

                }
            }

            if ( ARGUMENT_PRESENT(ReturnSomeAccessGranted)) {
                *ReturnSomeAccessGranted = SomeAccessGranted;
            }
            if ( ARGUMENT_PRESENT(ReturnSomeAccessDenied)) {
                *ReturnSomeAccessDenied = SomeAccessDenied;
            }

            return RetVal;

        //
        // If the caller is only interested in the access to the object itself,
        //  just summarize.
        //

        } else {

            //
            // Turn off the MAXIMUM_ALLOWED bit and whatever we found that
            // he was granted.  If the user passed in extra bits in addition
            // to MAXIMUM_ALLOWED, make sure that he was granted those access
            // types.  If not, he didn't get what he wanted, so return failure.
            //

            Remaining &= ~(MAXIMUM_ALLOWED | LocalTypeList->CurrentGranted);

            if (Remaining != 0) {

                Status = STATUS_ACCESS_DENIED;
                PreviouslyGrantedAccess = 0;
                goto ReturnOneStatus;

            }



            PreviouslyGrantedAccess |= LocalTypeList->CurrentGranted;
            Status = STATUS_SUCCESS;
            goto ReturnOneStatus;

        }

    } // if MAXIMUM_ALLOWED...


    //
    // Do the normal access check first
    //

    SepNormalAccessCheck(
        Remaining,
        EToken,
        PrimaryToken,
        Dacl,
        PrincipalSelfSid,
        LocalTypeListLength,
        LocalTypeList,
        ObjectTypeListLength,
        FALSE
        );

    if (LocalTypeList->Remaining != 0) {
        Status = STATUS_ACCESS_DENIED;
        PreviouslyGrantedAccess = 0;
        goto ReturnOneStatus;
    }

    //
    // If this is a restricted token, do the additional access check
    //

    if (SeTokenIsRestricted( EToken ) ) {
        SepNormalAccessCheck(
            Remaining,
            EToken,
            PrimaryToken,
            Dacl,
            PrincipalSelfSid,
            LocalTypeListLength,
            LocalTypeList,
            ObjectTypeListLength,
            TRUE
            );
    }


    if (LocalTypeList->Remaining != 0) {
        Status = STATUS_ACCESS_DENIED;
        PreviouslyGrantedAccess = 0;
        goto ReturnOneStatus;
    }

    Status = STATUS_SUCCESS;
    PreviouslyGrantedAccess |= DesiredAccess;

    //
    // Return a single status code to the caller.
    //

    ReturnOneStatus:
    if ( Status == STATUS_SUCCESS && PreviouslyGrantedAccess == 0 ) {
        Status = STATUS_ACCESS_DENIED;
    }

    if ( NT_SUCCESS(Status) ) {
        if ( PrivilegeCount > 0 ) {
            SepAssemblePrivileges(
                PrivilegeCount,
                SystemSecurity,
                WriteOwner,
                Privileges
                );

            if ( ( Privileges != NULL ) && ( *Privileges == NULL ) ) {
                RetVal = FALSE;
                Status = STATUS_NO_MEMORY;
                PreviouslyGrantedAccess = 0;
            }
        }
    }
    //
    // If the caller asked for a list of status',
    //  duplicate the status all over.
    //
    if ( ReturnResultList ) {
        for ( ResultListIndex=0; ResultListIndex<ObjectTypeListLength; ResultListIndex++ ) {
            AccessStatus[ResultListIndex] = Status;
            GrantedAccess[ResultListIndex] = PreviouslyGrantedAccess;
        }
    } else {
        *AccessStatus = Status;
        *GrantedAccess = PreviouslyGrantedAccess;
    }

    if ( NT_SUCCESS(Status) ) {
        if ( ARGUMENT_PRESENT(ReturnSomeAccessGranted)) {
            *ReturnSomeAccessGranted = TRUE;
        }
        if ( ARGUMENT_PRESENT(ReturnSomeAccessDenied)) {
            *ReturnSomeAccessDenied = FALSE;
        }
    } else {
        if ( ARGUMENT_PRESENT(ReturnSomeAccessGranted)) {
            *ReturnSomeAccessGranted = FALSE;
        }
        if ( ARGUMENT_PRESENT(ReturnSomeAccessDenied)) {
            *ReturnSomeAccessDenied = TRUE;
        }
    }
    return RetVal;

}




NTSTATUS
NtAccessCheck (
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in HANDLE ClientToken,
    __in ACCESS_MASK DesiredAccess,
    __in PGENERIC_MAPPING GenericMapping,
    __out_bcount(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    __inout PULONG PrivilegeSetLength,
    __out PACCESS_MASK GrantedAccess,
    __out PNTSTATUS AccessStatus
    )


/*++

Routine Description:

    See module abstract.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccess - Returns an access mask describing the granted access.

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

Return Value:

    STATUS_SUCCESS - The attempt proceeded normally.  This does not
        mean access was granted, rather that the parameters were
        correct.

    STATUS_GENERIC_NOT_MAPPED - The DesiredAccess mask contained
        an unmapped generic access.

    STATUS_BUFFER_TOO_SMALL - The passed buffer was not large enough
        to contain the information being returned.

    STATUS_NO_IMPERSONTAION_TOKEN - The passed Token was not an impersonation
        token.

--*/

{

    PAGED_CODE();

    return SeAccessCheckByType (
                 SecurityDescriptor,
                 NULL,      // No Principal Self sid
                 ClientToken,
                 DesiredAccess,
                 NULL,      // No ObjectType List
                 0,         // No ObjectType List
                 GenericMapping,
                 PrivilegeSet,
                 PrivilegeSetLength,
                 GrantedAccess,
                 AccessStatus,
                 FALSE );  // Return a single GrantedAccess and AccessStatus


}






NTSTATUS
NtAccessCheckByType (
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in HANDLE ClientToken,
    __in ACCESS_MASK DesiredAccess,
    __in_ecount(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in ULONG ObjectTypeListLength,
    __in PGENERIC_MAPPING GenericMapping,
    __out_bcount(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    __inout PULONG PrivilegeSetLength,
    __out PACCESS_MASK GrantedAccess,
    __out PNTSTATUS AccessStatus
    )


/*++

Routine Description:

    See module abstract.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccess - Returns an access mask describing the granted access.

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

Return Value:

    STATUS_SUCCESS - The attempt proceeded normally.  This does not
        mean access was granted, rather that the parameters were
        correct.

    STATUS_GENERIC_NOT_MAPPED - The DesiredAccess mask contained
        an unmapped generic access.

    STATUS_BUFFER_TOO_SMALL - The passed buffer was not large enough
        to contain the information being returned.

    STATUS_NO_IMPERSONTAION_TOKEN - The passed Token was not an impersonation
        token.

--*/

{

    PAGED_CODE();

    return SeAccessCheckByType (
                 SecurityDescriptor,
                 PrincipalSelfSid,
                 ClientToken,
                 DesiredAccess,
                 ObjectTypeList,
                 ObjectTypeListLength,
                 GenericMapping,
                 PrivilegeSet,
                 PrivilegeSetLength,
                 GrantedAccess,
                 AccessStatus,
                 FALSE );  // Return a single GrantedAccess and AccessStatus
}





NTSTATUS
NtAccessCheckByTypeResultList (
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in HANDLE ClientToken,
    __in ACCESS_MASK DesiredAccess,
    __in_ecount(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in ULONG ObjectTypeListLength,
    __in PGENERIC_MAPPING GenericMapping,
    __out_bcount(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    __inout PULONG PrivilegeSetLength,
    __out_ecount(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    __out_ecount(ObjectTypeListLength) PNTSTATUS AccessStatus
    )


/*++

Routine Description:

    See module abstract.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccess - Returns an access mask describing the granted access.

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

Return Value:

    STATUS_SUCCESS - The attempt proceeded normally.  This does not
        mean access was granted, rather that the parameters were
        correct.

    STATUS_GENERIC_NOT_MAPPED - The DesiredAccess mask contained
        an unmapped generic access.

    STATUS_BUFFER_TOO_SMALL - The passed buffer was not large enough
        to contain the information being returned.

    STATUS_NO_IMPERSONTAION_TOKEN - The passed Token was not an impersonation
        token.

--*/

{

    PAGED_CODE();

    return SeAccessCheckByType (
                 SecurityDescriptor,
                 PrincipalSelfSid,
                 ClientToken,
                 DesiredAccess,
                 ObjectTypeList,
                 ObjectTypeListLength,
                 GenericMapping,
                 PrivilegeSet,
                 PrivilegeSetLength,
                 GrantedAccess,
                 AccessStatus,
                 TRUE );  // Return an array of GrantedAccess and AccessStatus
}






NTSTATUS
SeAccessCheckByType (
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in HANDLE ClientToken,
    __in ACCESS_MASK DesiredAccess,
    __in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in ULONG ObjectTypeListLength,
    __in PGENERIC_MAPPING GenericMapping,
    __out_ecount_part(*PrivilegeSetLength, *PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    __inout PULONG PrivilegeSetLength,
    __out PACCESS_MASK GrantedAccess,
    __out PNTSTATUS AccessStatus,
    __in BOOLEAN ReturnResultList
    )


/*++

Routine Description:

    See module abstract.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccess - Returns an access mask describing the granted access.

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

    ReturnResultList - If true, GrantedAccess and AccessStatus are actually
        arrays of entries ObjectTypeListLength elements long.

Return Value:

    STATUS_SUCCESS - The attempt proceeded normally.  This does not
        mean access was granted, rather that the parameters were
        correct.

    STATUS_GENERIC_NOT_MAPPED - The DesiredAccess mask contained
        an unmapped generic access.

    STATUS_BUFFER_TOO_SMALL - The passed buffer was not large enough
        to contain the information being returned.

    STATUS_NO_IMPERSONTAION_TOKEN - The passed Token was not an impersonation
        token.

--*/

{
    ACCESS_MASK LocalGrantedAccess;
    PACCESS_MASK LocalGrantedAccessPointer = NULL;
    NTSTATUS LocalAccessStatus;
    PNTSTATUS LocalAccessStatusPointer = NULL;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status = STATUS_SUCCESS;
    PTOKEN Token = NULL;
    PSECURITY_DESCRIPTOR CapturedSecurityDescriptor = NULL;
    PSID CapturedPrincipalSelfSid = NULL;
    ACCESS_MASK PreviouslyGrantedAccess = 0;
    GENERIC_MAPPING LocalGenericMapping;
    PIOBJECT_TYPE_LIST LocalObjectTypeList = NULL;
    PPRIVILEGE_SET Privileges = NULL;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    ULONG LocalPrivilegeSetLength = 0;
    ULONG ResultListIndex = 0;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode == KernelMode) {
        ASSERT( !ReturnResultList );
        *AccessStatus = STATUS_SUCCESS;
        *GrantedAccess = DesiredAccess;
        return(STATUS_SUCCESS);
    }

    try {

        if ( ReturnResultList ) {

            if ( ObjectTypeListLength == 0 ) {
                Status = STATUS_INVALID_PARAMETER;
                leave ;
            }

            if ( !IsValidElementCount( ObjectTypeListLength, OBJECT_TYPE_LIST ) )
            {
                Status = STATUS_INVALID_PARAMETER ;

                leave ;
            }

            ProbeForWrite(
                AccessStatus,
                sizeof(NTSTATUS) * ObjectTypeListLength,
                sizeof(ULONG)
                );

            ProbeForWrite(
                GrantedAccess,
                sizeof(ACCESS_MASK) * ObjectTypeListLength,
                sizeof(ULONG)
                );

        } else {
            ProbeForWriteUlong((PULONG)AccessStatus);
            ProbeForWriteUlong((PULONG)GrantedAccess);
        }

        LocalPrivilegeSetLength = ProbeAndReadUlong( PrivilegeSetLength );
        ProbeForWriteUlong(
            PrivilegeSetLength
            );

        ProbeForWrite(
            PrivilegeSet,
            LocalPrivilegeSetLength,
            sizeof(ULONG)
            );

        //
        // initialize PrivilegeCount in case the caller passed in an
        // uninitialized PrivilegeSet
        //

        if ( PrivilegeSet &&
             ( LocalPrivilegeSetLength >= sizeof(PRIVILEGE_SET) )) {

            PrivilegeSet->PrivilegeCount = 0;
        }

        ProbeForReadSmallStructure(
            GenericMapping,
            sizeof(GENERIC_MAPPING),
            sizeof(ULONG)
            );

        LocalGenericMapping = *GenericMapping;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    if (!NT_SUCCESS( Status ) ) {
        return( Status );
    }

    if (DesiredAccess &
        ( GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL )) {


        Status = STATUS_GENERIC_NOT_MAPPED;
        goto Cleanup;
    }

    //
    // Obtain a pointer to the passed token
    //

    Status = ObReferenceObjectByHandle(
                 ClientToken,                  // Handle
                 (ACCESS_MASK)TOKEN_QUERY,     // DesiredAccess
                 SeTokenObjectType,           // ObjectType
                 PreviousMode,                 // AccessMode
                 (PVOID *)&Token,              // Object
                 0                             // GrantedAccess
                 );

    if (!NT_SUCCESS(Status)) {
        Token = NULL;
        goto Cleanup;
    }

    //
    // It must be an impersonation token, and at impersonation
    // level of Identification or above.
    //

    if (Token->TokenType != TokenImpersonation) {
        Status = STATUS_NO_IMPERSONATION_TOKEN;
        goto Cleanup;
    }

    if ( Token->ImpersonationLevel < SecurityIdentification ) {
        Status = STATUS_BAD_IMPERSONATION_LEVEL;
        goto Cleanup;
    }

    //
    // Capture any Object type list
    //

    Status = SeCaptureObjectTypeList( ObjectTypeList,
                                      ObjectTypeListLength,
                                      PreviousMode,
                                      &LocalObjectTypeList );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Compare the DesiredAccess with the privileges in the
    // passed token, and see if we can either satisfy the requested
    // access with a privilege, or bomb out immediately because
    // we don't have a privilege we need.
    //

    Status = SePrivilegePolicyCheck(
                 &DesiredAccess,
                 &PreviouslyGrantedAccess,
                 NULL,
                 (PACCESS_TOKEN)Token,
                 &Privileges,
                 PreviousMode
                 );

    if (!NT_SUCCESS( Status )) {

        try {

            if ( ReturnResultList ) {
                for ( ResultListIndex=0; ResultListIndex<ObjectTypeListLength; ResultListIndex++ ) {
                    AccessStatus[ResultListIndex] = Status;
                    GrantedAccess[ResultListIndex] = 0;
                }

            } else {
                *AccessStatus = Status;
                *GrantedAccess = 0;
            }

            Status = STATUS_SUCCESS;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();
        }

        goto Cleanup;
    }

    //
    // Make sure the passed privileges buffer is large enough for
    // whatever we have to put into it.
    //

    if (Privileges != NULL) {

        if ( ((ULONG)SepPrivilegeSetSize( Privileges )) > LocalPrivilegeSetLength ) {

            try {

                *PrivilegeSetLength = SepPrivilegeSetSize( Privileges );
                Status = STATUS_BUFFER_TOO_SMALL;

            } except ( EXCEPTION_EXECUTE_HANDLER ) {

                Status = GetExceptionCode();
            }

            SeFreePrivileges( Privileges );

            goto Cleanup;

        } else {

            try {

                RtlCopyMemory(
                    PrivilegeSet,
                    Privileges,
                    SepPrivilegeSetSize( Privileges )
                    );

            } except ( EXCEPTION_EXECUTE_HANDLER ) {

                SeFreePrivileges( Privileges );
                Status = GetExceptionCode();
                goto Cleanup;
            }

        }
        SeFreePrivileges( Privileges );

    } else {

        //
        // No privileges were used, construct an empty privilege set
        //

        if ( LocalPrivilegeSetLength < sizeof(PRIVILEGE_SET) ) {

            try {

                *PrivilegeSetLength = sizeof(PRIVILEGE_SET);
                Status = STATUS_BUFFER_TOO_SMALL;

            } except ( EXCEPTION_EXECUTE_HANDLER ) {

                Status = GetExceptionCode();
            }

            goto Cleanup;
        }

        try {

            PrivilegeSet->PrivilegeCount = 0;
            PrivilegeSet->Control = 0;

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
            goto Cleanup;

        }

    }

    //
    // Capture the PrincipalSelfSid.
    //

    if ( PrincipalSelfSid != NULL ) {
        Status = SeCaptureSid(
                     PrincipalSelfSid,
                     PreviousMode,
                     NULL, 0,
                     PagedPool,
                     TRUE,
                     &CapturedPrincipalSelfSid );

        if (!NT_SUCCESS(Status)) {
            CapturedPrincipalSelfSid = NULL;
            goto Cleanup;
        }
    }


    //
    // Capture the passed security descriptor.
    //
    // SeCaptureSecurityDescriptor probes the input security descriptor,
    // so we don't have to
    //

    Status = SeCaptureSecurityDescriptor (
                SecurityDescriptor,
                PreviousMode,
                PagedPool,
                FALSE,
                &CapturedSecurityDescriptor
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    //
    // If there's no security descriptor, then we've been
    // called without all the parameters we need.
    // Return invalid security descriptor.
    //

    if ( CapturedSecurityDescriptor == NULL ) {
        Status = STATUS_INVALID_SECURITY_DESCR;
        goto Cleanup;
    }

    //
    // A valid security descriptor must have an owner and a group
    //

    if ( RtlpOwnerAddrSecurityDescriptor(
                (PISECURITY_DESCRIPTOR)CapturedSecurityDescriptor
                ) == NULL ||
         RtlpGroupAddrSecurityDescriptor(
                (PISECURITY_DESCRIPTOR)CapturedSecurityDescriptor
                ) == NULL ) {

        SeReleaseSecurityDescriptor (
            CapturedSecurityDescriptor,
            PreviousMode,
            FALSE
            );

        Status = STATUS_INVALID_SECURITY_DESCR;
        goto Cleanup;
    }


    SeCaptureSubjectContext( &SubjectContext );

    SepAcquireTokenReadLock( Token );

    //
    // If the user in the token is the owner of the object, we
    // must automatically grant ReadControl and WriteDac access
    // if desired.  If the DesiredAccess mask is empty after
    // these bits are turned off, we don't have to do any more
    // access checking (ref section 4, DSA ACL Arch)
    //


    if ( DesiredAccess & (WRITE_DAC | READ_CONTROL | MAXIMUM_ALLOWED) ) {

        if (SepTokenIsOwner( Token, CapturedSecurityDescriptor, TRUE )) {

            if ( DesiredAccess & MAXIMUM_ALLOWED ) {

                PreviouslyGrantedAccess |= (WRITE_DAC | READ_CONTROL);

            } else {

                PreviouslyGrantedAccess |= (DesiredAccess & (WRITE_DAC | READ_CONTROL));
            }

            DesiredAccess &= ~(WRITE_DAC | READ_CONTROL);
        }

    }

    if (DesiredAccess == 0) {

        try {


            if ( ReturnResultList ) {
                for ( ResultListIndex=0; ResultListIndex<ObjectTypeListLength; ResultListIndex++ ) {

                    //
                    // Do not allow the request to go thru if the granted access
                    // evaluated to ZERO.
                    //

                    if (PreviouslyGrantedAccess == 0) {
                        AccessStatus[ResultListIndex] = STATUS_ACCESS_DENIED;
                        GrantedAccess[ResultListIndex] = 0;
                    } else {
                        AccessStatus[ResultListIndex] = STATUS_SUCCESS;
                        GrantedAccess[ResultListIndex] = PreviouslyGrantedAccess;
                    }
                }

            } else {

                //
                // Do not allow the request to go thru if the granted access
                // evaluated to ZERO.
                //

                if (PreviouslyGrantedAccess == 0) {
                    *AccessStatus = STATUS_ACCESS_DENIED;
                    *GrantedAccess = 0;
                } else {
                    *AccessStatus = STATUS_SUCCESS;
                    *GrantedAccess = PreviouslyGrantedAccess;
                }
            }
            Status = STATUS_SUCCESS;

        } except (EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

        }

        SepReleaseTokenReadLock( Token );

        SeReleaseSubjectContext( &SubjectContext );

        SeReleaseSecurityDescriptor (
            CapturedSecurityDescriptor,
            PreviousMode,
            FALSE
            );

        goto Cleanup;

    }


    //
    // Finally, handle the case where we actually have to check the DACL.
    //

    if ( ReturnResultList ) {
        LocalGrantedAccessPointer =
            ExAllocatePoolWithTag( PagedPool, (sizeof(ACCESS_MASK)+sizeof(NTSTATUS)) * ObjectTypeListLength, 'aGeS' );

        if (LocalGrantedAccessPointer == NULL) {

            SepReleaseTokenReadLock( Token );

            SeReleaseSubjectContext( &SubjectContext );

            SeReleaseSecurityDescriptor (
                CapturedSecurityDescriptor,
                PreviousMode,
                FALSE
                );

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        LocalAccessStatusPointer = (PNTSTATUS)(LocalGrantedAccessPointer + ObjectTypeListLength);
    } else {
        LocalGrantedAccessPointer = &LocalGrantedAccess;
        LocalAccessStatusPointer =  &LocalAccessStatus;
    }

    //
    // This does not ask for privilege set to be returned so we can ignore
    // the return value of the call.
    //

    (VOID) SepAccessCheck (
               CapturedSecurityDescriptor,
               CapturedPrincipalSelfSid,
               SubjectContext.PrimaryToken,
               Token,
               DesiredAccess,
               LocalObjectTypeList,
               ObjectTypeListLength,
               &LocalGenericMapping,
               PreviouslyGrantedAccess,
               PreviousMode,
               LocalGrantedAccessPointer,
               NULL,
               LocalAccessStatusPointer,
               ReturnResultList,
               NULL,
               NULL );

    SepReleaseTokenReadLock( Token );

    SeReleaseSubjectContext( &SubjectContext );

    SeReleaseSecurityDescriptor (
        CapturedSecurityDescriptor,
        PreviousMode,
        FALSE
        );

    try {

        if ( ReturnResultList ) {
            for ( ResultListIndex=0; ResultListIndex<ObjectTypeListLength; ResultListIndex++ ) {
                AccessStatus[ResultListIndex] = LocalAccessStatusPointer[ResultListIndex];
                GrantedAccess[ResultListIndex] = LocalGrantedAccessPointer[ResultListIndex];
            }

        } else {
            *AccessStatus = *LocalAccessStatusPointer;
            *GrantedAccess = *LocalGrantedAccessPointer;
        }

        Status = STATUS_SUCCESS;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if ( ReturnResultList ) {
        if ( LocalGrantedAccessPointer != NULL ) {
            ExFreePool( LocalGrantedAccessPointer );
        }
    }


    //
    // Free locally used resources.
    //
Cleanup:

    if ( Token != NULL ) {
        ObDereferenceObject( Token );
    }

    if ( LocalObjectTypeList != NULL ) {
        SeFreeCapturedObjectTypeList( LocalObjectTypeList );
    }

    if (CapturedPrincipalSelfSid != NULL) {
        SeReleaseSid( CapturedPrincipalSelfSid, PreviousMode, TRUE);
    }

    return Status;
}



VOID
SeFreePrivileges(
    __in PPRIVILEGE_SET Privileges
    )

/*++

Routine Description:

    This routine frees a privilege set returned by SeAccessCheck.

Arguments:

    Privileges - Supplies a pointer to the privilege set to be freed.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ExFreePool( Privileges );
}



BOOLEAN
SeAccessCheck (
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    __in BOOLEAN SubjectContextLocked,
    __in ACCESS_MASK DesiredAccess,
    __in ACCESS_MASK PreviouslyGrantedAccess,
    __deref_out_opt PPRIVILEGE_SET *Privileges,
    __in PGENERIC_MAPPING GenericMapping,
    __in KPROCESSOR_MODE AccessMode,
    __out PACCESS_MASK GrantedAccess,
    __out PNTSTATUS AccessStatus
    )

/*++

Routine Description:

    See module abstract

    This routine MAY perform tests for the following
    privileges:

                SeTakeOwnershipPrivilege
                SeSecurityPrivilege

    depending upon the accesses being requested.

    This routine may also check to see if the subject is the owner
    of the object (to grant WRITE_DAC access).

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the
         object being accessed

    SubjectSecurityContext - A pointer to the subject's captured security
         context

    SubjectContextLocked - Supplies a flag indicating whether or not
        the user's subject context is locked, so that it does not have
        to be locked again.

    DesiredAccess - Supplies the access mask that the user is attempting to
         acquire

    PreviouslyGrantedAccess - Supplies any accesses that the user has
        already been granted, for example, as a result of holding a
        privilege.

    Privileges - Supplies a pointer in which will be returned a privilege
        set indicating any privileges that were used as part of the
        access validation.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    AccessMode - Supplies the access mode to be used in the check

    GrantedAccess - Pointer to a returned access mask indicatating the
         granted access

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.


Return Value:

    BOOLEAN - TRUE if access is allowed and FALSE otherwise

--*/

{
    BOOLEAN Success;

    PAGED_CODE();

    if (AccessMode == KernelMode) {

        if (DesiredAccess & MAXIMUM_ALLOWED) {

            //
            // Give him:
            //   GenericAll
            //   Anything else he asked for
            //

            *GrantedAccess = GenericMapping->GenericAll;
            *GrantedAccess |= (DesiredAccess & ~MAXIMUM_ALLOWED);
            *GrantedAccess |= PreviouslyGrantedAccess;

        } else {

            *GrantedAccess = DesiredAccess | PreviouslyGrantedAccess;
        }
        *AccessStatus = STATUS_SUCCESS;
        return(TRUE);
    }

    //
    // If the object doesn't have a security descriptor (and it's supposed
    // to), return access denied.
    //

    if ( SecurityDescriptor == NULL) {

       *AccessStatus = STATUS_ACCESS_DENIED;
       return( FALSE );

    }

    //
    // If we're impersonating a client, we have to be at impersonation level
    // of SecurityImpersonation or above.
    //

    if ( (SubjectSecurityContext->ClientToken != NULL) &&
         (SubjectSecurityContext->ImpersonationLevel < SecurityImpersonation)
       ) {
           *AccessStatus = STATUS_BAD_IMPERSONATION_LEVEL;
           return( FALSE );
    }

    if ( DesiredAccess == 0 ) {

        if ( PreviouslyGrantedAccess == 0 ) {
            *AccessStatus = STATUS_ACCESS_DENIED;
            return( FALSE );
        }

        *GrantedAccess = PreviouslyGrantedAccess;
        *AccessStatus = STATUS_SUCCESS;
        *Privileges = NULL;
        return( TRUE );

    }

    SeAssertMappedCanonicalAccess( DesiredAccess );


    //
    // If the caller did not lock the subject context for us,
    // lock it here to keep lower level routines from having
    // to lock it.
    //

    if ( !SubjectContextLocked ) {
        SeLockSubjectContext( SubjectSecurityContext );
    }

    //
    // If the user in the token is the owner of the object, we
    // must automatically grant ReadControl and WriteDac access
    // if desired.  If the DesiredAccess mask is empty after
    // these bits are turned off, we don't have to do any more
    // access checking (ref section 4, DSA ACL Arch)
    //

    if ( DesiredAccess & (WRITE_DAC | READ_CONTROL | MAXIMUM_ALLOWED) ) {

        if ( SepTokenIsOwner(
                 EffectiveToken( SubjectSecurityContext ),
                 SecurityDescriptor,
                 TRUE
                 ) ) {

            if ( DesiredAccess & MAXIMUM_ALLOWED ) {

                PreviouslyGrantedAccess |= (WRITE_DAC | READ_CONTROL);

            } else {

                PreviouslyGrantedAccess |= (DesiredAccess & (WRITE_DAC | READ_CONTROL));
            }

            DesiredAccess &= ~(WRITE_DAC | READ_CONTROL);
        }
    }

    if (DesiredAccess == 0) {

        if ( !SubjectContextLocked ) {
            SeUnlockSubjectContext( SubjectSecurityContext );
        }

        *GrantedAccess = PreviouslyGrantedAccess;
        *AccessStatus = STATUS_SUCCESS;
        return( TRUE );

    } else {

        BOOLEAN b = SepAccessCheck(
                        SecurityDescriptor,
                        NULL,   // No PrincipalSelfSid
                        SubjectSecurityContext->PrimaryToken,
                        SubjectSecurityContext->ClientToken,
                        DesiredAccess,
                        NULL,   // No object type list
                        0,      // No object type list
                        GenericMapping,
                        PreviouslyGrantedAccess,
                        AccessMode,
                        GrantedAccess,
                        Privileges,
                        AccessStatus,
                        FALSE,   // Don't return a list
                        &Success,
                        NULL
                        );
#if DBG
          if (!Success && SepShowAccessFail) {
              DbgPrint("SE: Access check failed, DesiredAccess = 0x%x\n",
                DesiredAccess);
              SepDumpSD = TRUE;
              SepDumpSecurityDescriptor(
                  SecurityDescriptor,
                  "Input to SeAccessCheck\n"
                  );
              SepDumpSD = FALSE;
              SepDumpToken = TRUE;
              SepDumpTokenInfo( EffectiveToken( SubjectSecurityContext ) );
              SepDumpToken = FALSE;
          }
#endif

        //
        // If we locked it in this routine, unlock it before we
        // leave.
        //

        if ( !SubjectContextLocked ) {
            SeUnlockSubjectContext( SubjectSecurityContext );
        }

        //
        // We return failure if any of the following is TRUE
        //   1. The user was really not granted access.
        //   2. The resource manager asked for the list of privileges used to
        //      determine granted access and we failed to allocate memory
        //      required to return these.
        //

        return( b && Success );
    }
}



NTSTATUS
SePrivilegePolicyCheck(
    __inout PACCESS_MASK RemainingDesiredAccess,
    __inout PACCESS_MASK PreviouslyGrantedAccess,
    __in_opt PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    __in_opt PACCESS_TOKEN ExplicitToken,
    __deref_out PPRIVILEGE_SET *PrivilegeSet,
    __in KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This routine implements privilege policy by examining the bits in
    a DesiredAccess mask and adjusting them based on privilege checks.

    Currently, a request for ACCESS_SYSTEM_SECURITY may only be satisfied
    by the caller having SeSecurityPrivilege.  WRITE_OWNER may optionally
    be satisfied via SeTakeOwnershipPrivilege.

Arguments:

    RemainingDesiredAccess - The desired access for the current operation.
        Bits may be cleared in this if the subject has particular privileges.

    PreviouslyGrantedAccess - Supplies an access mask describing any
        accesses that have already been granted.  Bits may be set in
        here as a result of privilege checks.

    SubjectSecurityContext - Optionally provides the subject's security
        context.

    ExplicitToken - Optionally provides the token to be examined.

    PrivilegeSet - Supplies a pointer to a location in which will be
        returned a pointer to a privilege set.

    PreviousMode - The previous processor mode.

Return Value:

    STATUS_SUCCESS - Any access requests that could be satisfied via
        privileges were done.

    STATUS_PRIVILEGE_NOT_HELD - An access type was being requested that
        requires a privilege, and the current subject did not have the
        privilege.



--*/

{
    BOOLEAN Success;
    PTOKEN Token;
    BOOLEAN WriteOwner = FALSE;
    BOOLEAN SystemSecurity = FALSE;
    ULONG PrivilegeNumber = 0;
    ULONG PrivilegeCount = 0;
    ULONG SizeRequired;

    PAGED_CODE();

    if (ARGUMENT_PRESENT( SubjectSecurityContext )) {

        Token = (PTOKEN)EffectiveToken( SubjectSecurityContext );

    } else {

        Token = (PTOKEN)ExplicitToken;
    }


    if (*RemainingDesiredAccess & ACCESS_SYSTEM_SECURITY) {

        Success = SepSinglePrivilegeCheck (
                    SeSecurityPrivilege,
                    Token,
                    PreviousMode
                    );

        if (!Success) {

            return( STATUS_PRIVILEGE_NOT_HELD );
        }

        PrivilegeCount++;
        SystemSecurity = TRUE;

        *RemainingDesiredAccess &= ~ACCESS_SYSTEM_SECURITY;
        *PreviouslyGrantedAccess |= ACCESS_SYSTEM_SECURITY;
    }

    if (*RemainingDesiredAccess & WRITE_OWNER) {

        Success = SepSinglePrivilegeCheck (
                    SeTakeOwnershipPrivilege,
                    Token,
                    PreviousMode
                    );

        if (Success) {

            PrivilegeCount++;
            WriteOwner = TRUE;

            *RemainingDesiredAccess &= ~WRITE_OWNER;
            *PreviouslyGrantedAccess |= WRITE_OWNER;

        }
    }

    if (PrivilegeCount > 0) {
        SizeRequired = sizeof(PRIVILEGE_SET) +
                        (PrivilegeCount - ANYSIZE_ARRAY) *
                        (ULONG)sizeof(LUID_AND_ATTRIBUTES);

        *PrivilegeSet = ExAllocatePoolWithTag( PagedPool, SizeRequired, 'rPeS' );

        if ( *PrivilegeSet == NULL ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }

        (*PrivilegeSet)->PrivilegeCount = PrivilegeCount;
        (*PrivilegeSet)->Control = 0;

        if (WriteOwner) {
            (*PrivilegeSet)->Privilege[PrivilegeNumber].Luid = SeTakeOwnershipPrivilege;
            (*PrivilegeSet)->Privilege[PrivilegeNumber].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;
            PrivilegeNumber++;
        }

        if (SystemSecurity) {
            (*PrivilegeSet)->Privilege[PrivilegeNumber].Luid = SeSecurityPrivilege;
            (*PrivilegeSet)->Privilege[PrivilegeNumber].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;
        }
    }

    return( STATUS_SUCCESS );
}



BOOLEAN
SepTokenIsOwner(
    IN PACCESS_TOKEN EffectiveToken,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN TokenLocked
    )

/*++

Routine Description:

    This routine will determine of the Owner of the passed security descriptor
    is in the passed token. If the token is restricted it cannot be the
    owner.


Arguments:

    Token - The token representing the current user.

    SecurityDescriptor - The security descriptor for the object being
        accessed.

    TokenLocked - A boolean describing whether the caller has taken
        a read lock for the token.


Return Value:

    TRUE - The user of the token is the owner of the object.

    FALSE - The user of the token is not the owner of the object.

--*/

{
    PSID Owner;
    BOOLEAN rc;

    PISECURITY_DESCRIPTOR ISecurityDescriptor;
    PTOKEN Token;

    PAGED_CODE();

    ISecurityDescriptor = (PISECURITY_DESCRIPTOR)SecurityDescriptor;
    Token = (PTOKEN)EffectiveToken;


    Owner = RtlpOwnerAddrSecurityDescriptor( ISecurityDescriptor );
    ASSERT( Owner != NULL );

    if (!TokenLocked) {
        SepAcquireTokenReadLock( Token );
    }

    rc = SepSidInToken( Token, NULL, Owner, FALSE );

    //
    // For restricted tokens, check the restricted sids too.
    //

    if (rc && (Token->TokenFlags & TOKEN_IS_RESTRICTED) != 0) {
        rc = SepSidInTokenEx( Token, NULL, Owner, FALSE, TRUE );

    }

    if (!TokenLocked) {
        SepReleaseTokenReadLock( Token );
    }

    return( rc );
}


#define WORLD_TRAVERSAL_INCLUDES_ANONYMOUS 1

BOOLEAN
SeFastTraverseCheck(
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in PACCESS_STATE AccessState,
    __in ACCESS_MASK TraverseAccess,
    __in KPROCESSOR_MODE AccessMode
    )
/*++

Routine Description:

    This routine will perform a fast check against the DACL of the passed
    Security Descriptor to see if Traverse access would be granted. If so, no
    further access checking is necessary.

    Note that the SubjectContext for the client process does not have
    to be locked to make this call, since it does not examine any data
    structures in the Token.

    The caller has the following responsibilities:
    1. It is the job of the caller to verify AccessMode is not KernelMode!
    2. The *caller* is expected to check AccessState for
       TOKEN_HAS_TRAVERSE_PRIVILEGE if the override is applicable!

Arguments:

    SecurityDescriptor - The Security Descriptor protecting the container
        object being traversed.

    AccessState - Running security access state containing caller token
        information for operation.

    TraverseAccess - Access mask describing Traverse access for this
        object type. There must be only one bit specified in the mask.

    AccessMode - Supplies the access mode to be used in the check


Return Value:

    TRUE - if Traverse access to this container can be granted. FALSE otherwise.

--*/

{
    PACL Dacl;
    ULONG i;
    PVOID Ace;
    ULONG AceCount;
#if !WORLD_TRAVERSAL_INCLUDES_ANONYMOUS
    LOGICAL FoundWorld;
    LOGICAL FoundAnonymous;
#endif

    PAGED_CODE();

    //
    // Note that I/O calls this function even if the traverse bypass privilege
    // is set. This is done as I/O doesn't want the performance override to
    // apply to the DeviceObject->FileName boundary, as not all filesystems
    // supply file-level security.
    //

    ASSERT ( AccessMode != KernelMode );

    if (SecurityDescriptor == NULL) {
        return( FALSE );
    }

    //
    // See if there is a valid DACL in the passed Security Descriptor.
    // No DACL, no security, all is granted. Note that this function returns
    // NULL if SE_DACL_PRESENT isn't set.
    //

    Dacl = RtlpDaclAddrSecurityDescriptor( (PISECURITY_DESCRIPTOR)SecurityDescriptor );

    //
    // If no DACL is supplied, the object has no security, so all accesses are
    // granted.
    //

    if ( Dacl == NULL ) {

        return(TRUE);
    }

    //
    // There is security on this object.  If the DACL is empty, deny all access
    // immediately
    //

    if ((AceCount = Dacl->AceCount) == 0) {

        return( FALSE );
    }

    //
    // A restricted token is a token with two lists of SIDs. Access checks are
    // done against each list, passing only if both lists grant access. The
    // second "restricting SID" list can contain *any allow* SID.
    //
    // This routine doesn't walk a restricted token's restricting-SID list. As
    // such, restricted tokens require a full access check.
    //
    if (AccessState->Flags & TOKEN_IS_RESTRICTED) {

        return FALSE;
    }

    //
    // There's stuff in the DACL, walk down the list and see
    // if both Everyone and Anonymous have been granted TraverseAccess
    //
#if !WORLD_TRAVERSAL_INCLUDES_ANONYMOUS
    FoundWorld = FALSE;
    FoundAnonymous = FALSE;
#endif

    for ( i = 0, Ace = FirstAce( Dacl ) ;
          i < AceCount  ;
          i++, Ace = NextAce( Ace )
        ) {

        if (((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE) {

            continue;
        }

        if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_ACE_TYPE) ) {

            if ( (TraverseAccess & ((PACCESS_ALLOWED_ACE)Ace)->Mask) ) {

                if ( RtlEqualSid( SeWorldSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart ) ) {
#if WORLD_TRAVERSAL_INCLUDES_ANONYMOUS
                    return( TRUE );
                }
#else
                    if (FoundAnonymous) {

                        return( TRUE );

                    } else {

                        FoundWorld = TRUE;
                    }

                } else if ( RtlEqualSid( SeAnonymousLogonSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart ) ) {

                    if (FoundWorld) {

                        return( TRUE );

                    } else {

                        FoundAnonymous = TRUE;
                    }
                }
#endif
            }

        } else if ( (((PACE_HEADER)Ace)->AceType == ACCESS_DENIED_ACE_TYPE) ) {

            if ( (TraverseAccess & ((PACCESS_DENIED_ACE)Ace)->Mask) ) {

                //
                // This ACE might refer to a group the user belongs to
                // (or could be the user). Force a full access check.
                //

                return( FALSE );
            }
        }
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\adt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    adt.h

Abstract:

    Auditing - Defines, Function Prototypes and Macro Functions.
               These are public to the Security Component only.

--*/

#include <ntlsa.h>


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Auditing Routines visible to rest of Security Component outside Auditing //
// subcomponent.                                                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


BOOLEAN
SepAdtInitializePhase0();

BOOLEAN
SepAdtInitializePhase1();

VOID
SepAdtLogAuditRecord(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    );

NTSTATUS
SepAdtCopyToLsaSharedMemory(
    IN HANDLE LsaProcessHandle,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PVOID *LsaBufferAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\rtl\i386\xcptmisc.asm ===
title   "Miscellaneous Exception Handling"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    xcptmisc.asm
;
; Abstract:
;
;    This module implements miscellaneous routines that are required to
;    support exception handling. Functions are provided to call an exception
;    handler for an exception, call an exception handler for unwinding, get
;    the caller's stack pointer, get the caller's frame pointer, get the
;    caller's floating status, get the caller's processor state, get the
;    caller's extended processor status, and get the current stack limits.
;
;--
.386p

        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

;
; Unwind flags.
;

Unwind  equ EXCEPTION_UNWINDING OR EXCEPTION_EXIT_UNWIND

_TEXT$01   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
        subttl  "Execute Handler for Exception"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExecuteHandlerForException (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext,
;    IN PEXCEPTION_ROUTINE ExceptionRoutine
;    )
;
; Routine Description:
;
;    This function allocates a call frame, stores the handler address and
;    establisher frame pointer in the frame, establishes an exception
;    handler, and then calls the specified exception handler as an exception
;    handler. If a nested exception occurs, then the exception handler of
;    of this function is called and the handler address and establisher
;    frame pointer are returned to the exception dispatcher via the dispatcher
;    context parameter. If control is returned to this routine, then the
;    frame is deallocated and the disposition status is returned to the
;    exception dispatcher.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (ebp+12) - Supplies the frame pointer of the establisher
;       of the exception handler that is to be called.
;
;    ContextRecord (ebp+16) - Supplies a pointer to a context record.
;
;    DispatcherContext (ebp+20) - Supplies a pointer to the dispatcher context
;       record.
;
;    ExceptionRoutine (ebp+24) - supplies a pointer to the exception handler
;       that is to be called.
;
; Return Value:
;
;    The disposition value returned by the specified exception handler is
;    returned as the function value.
;
;--

cPublicProc _RtlpExecuteHandlerForException,5

        mov     edx,offset FLAT:ExceptionHandler    ; Set who to register
        jmp     ExecuteHandler                      ; jump to common code

stdENDP _RtlpExecuteHandlerForException


        page
        subttl  "Execute Handler for Unwind"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExecuteHandlerForUnwind (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext,
;    IN PEXCEPTION_ROUTINE ExceptionRoutine
;    )
;
; Routine Description:
;
;    This function allocates a call frame, stores the handler address and
;    establisher frame pointer in the frame, establishes an exception
;    handler, and then calls the specified exception handler as an unwind
;    handler. If a collided unwind occurs, then the exception handler of
;    of this function is called and the handler address and establisher
;    frame pointer are returned to the unwind dispatcher via the dispatcher
;    context parameter. If control is returned to this routine, then the
;    frame is deallocated and the disposition status is returned to the
;    unwind dispatcher.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (ebp+12) - Supplies the frame pointer of the establisher
;       of the exception handler that is to be called.
;
;    ContextRecord (ebp+16) - Supplies a pointer to a context record.
;
;    DispatcherContext (ebp+20) - Supplies a pointer to the dispatcher context
;       record.
;
;    ExceptionRoutine (ebp+24) - supplies a pointer to the exception handler
;       that is to be called.
;
; Return Value:
;
;    The disposition value returned by the specified exception handler is
;    returned as the function value.
;
;--

cPublicProc _RtlpExecuteHandlerForUnwind    ,5

        mov     edx,offset FLAT:UnwindHandler

;;  N.B. - FALL into ExecuteHandler

stdENDP _RtlpExecuteHandlerForUnwind



;
;   ExecuteHandler is the common tail for RtlpExecuteHandlerForException
;   and RtlpExecuteHandlerForUnwind - we clean up some registers so they don't
;   leak through the handler, then call the real execute code.
;
;   (edx) = handler (Exception or Unwind) address
;

cPublicProc   ExecuteHandler,5
        push    ebx
	push    esi
	push    edi
	xor     eax, eax
	xor     ebx, ebx
	xor     esi, esi
	xor     edi, edi
	push    [esp+32]          ; ExceptionRoutine
	push    [esp+32]          ; DispatcherContext
	push    [esp+32]          ; ContextRecord
	push    [esp+32]          ; EstablisherFrame
	push    [esp+32]          ; ExceptionRecord
	call    ExecuteHandler2
	pop     edi
	pop     esi
	pop     ebx
        stdRET  ExecuteHandler
stdENDP ExecuteHandler


ExceptionRecord     equ [ebp+8]
EstablisherFrame    equ [ebp+12]
ContextRecord       equ [ebp+16]
DispatcherContext   equ [ebp+20]
ExceptionRoutine    equ [ebp+24]


cPublicProc   ExecuteHandler2,5

        push    ebp
        mov     ebp,esp

        push    EstablisherFrame        ; Save context of exception handler
                                        ; that we're about to call.

    .errnz   ErrHandler-4
        push    edx                     ; Set Handler address

    .errnz   ErrNext-0
        push    fs:PcExceptionList                      ; Set next pointer


        mov     fs:PcExceptionList,esp                  ; Link us on

; Call the specified exception handler.

        push    DispatcherContext
        push    ContextRecord
        push    EstablisherFrame
        push    ExceptionRecord

        mov     ecx,ExceptionRoutine
        call    ecx
        mov     esp,fs:PcExceptionList

; Don't clean stack here, code in front of ret will blow it off anyway

; Disposition is in eax, so all we do is deregister handler and return

    .errnz  ErrNext-0
        pop     fs:PcExceptionList

        mov     esp,ebp
        pop     ebp
        stdRET  ExecuteHandler2

stdENDP ExecuteHandler2

        page
        subttl  "Local Exception Handler"
;++
;
; EXCEPTION_DISPOSITION
; ExceptionHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext
;    )
;
; Routine Description:
;
;    This function is called when a nested exception occurs. Its function
;    is to retrieve the establisher frame pointer and handler address from
;    its establisher's call frame, store this information in the dispatcher
;    context record, and return a disposition value of nested exception.
;
; Arguments:
;
;    ExceptionRecord (exp+4) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (esp+8) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;    ContextRecord (esp+12) - Supplies a pointer to a context record.
;
;    DispatcherContext (esp+16) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;    A disposition value ExceptionNestedException is returned if an unwind
;    is not in progress. Otherwise a value of ExceptionContinueSearch is
;    returned.
;
;--

stdPROC   ExceptionHandler,4

        mov     ecx,dword ptr [esp+4]           ; (ecx) -> ExceptionRecord
        test    dword ptr [ecx.ErExceptionFlags],Unwind
        mov     eax,ExceptionContinueSearch     ; Assume unwind
        jnz     eh10                            ; unwind, go return

;
; Unwind is not in progress - return nested exception disposition.
;

        mov     ecx,[esp+8]             ; (ecx) -> EstablisherFrame
        mov     edx,[esp+16]            ; (edx) -> DispatcherContext
        mov     eax,[ecx+8]             ; (eax) -> EstablisherFrame for the
                                        ;          handler active when we
                                        ;          nested.
        mov     [edx],eax               ; Set DispatcherContext field.
        mov     eax,ExceptionNestedException

eh10:   stdRET    ExceptionHandler

stdENDP ExceptionHandler

        page
        subttl  "Local Unwind Handler"
;++
;
; EXCEPTION_DISPOSITION
; UnwindHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext
;    )
;
; Routine Description:
;
;    This function is called when a collided unwind occurs. Its function
;    is to retrieve the establisher frame pointer and handler address from
;    its establisher's call frame, store this information in the dispatcher
;    context record, and return a disposition value of nested unwind.
;
; Arguments:
;
;    ExceptionRecord (esp+4) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (esp+8) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;    ContextRecord (esp+12) - Supplies a pointer to a context record.
;
;    DispatcherContext (esp+16) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;    A disposition value ExceptionCollidedUnwind is returned if an unwind is
;    in progress. Otherwise a value of ExceptionContinueSearch is returned.
;
;--

stdPROC   UnwindHandler,4

        mov     ecx,dword ptr [esp+4]           ; (ecx) -> ExceptionRecord
        test    dword ptr [ecx.ErExceptionFlags],Unwind
        mov     eax,ExceptionContinueSearch     ; Assume NOT unwind
        jz      uh10                            ; not unwind, go return


;
; Unwind is in progress - return collided unwind disposition.
;

        mov     ecx,[esp+8]             ; (ecx) -> EstablisherFrame
        mov     edx,[esp+16]            ; (edx) -> DispatcherContext
        mov     eax,[ecx+8]             ; (eax) -> EstablisherFrame for the
                                        ;          handler active when we
                                        ;          nested.
        mov     [edx],eax               ; Set DispatcherContext field.
        mov     eax,ExceptionCollidedUnwind

uh10:   stdRET    UnwindHandler

stdENDP UnwindHandler

        page
        subttl  "Unlink Exception Registration Record & Handler"
;++
;
; VOID
; RtlpUnlinkHandler(PEXCEPTION_REGISTRATION_RECORD UnlinkPointer)
;
; Routine Description:
;
;   This function removes the specified exception registration record
;   (and thus the relevant handler) from the exception traversal
;   chain.
;
; Arguments:
;
;    UnlinkPointer (esp+4) - Address of registration record to unlink.
;
; Return Value:
;
;    The caller's return address.
;
;--

cPublicProc _RtlpUnlinkHandler ,1

        mov     ecx,dword ptr [esp+4]
        mov     ecx,[ecx.ErrNext]
        mov     fs:PcExceptionList,ecx
        stdRET    _RtlpUnlinkHandler

stdENDP _RtlpUnlinkHandler

        page
        subttl  "Capture Context"
;++
;
; VOID
; RtlCaptureContext (PCONTEXT ContextRecord)
; RtlpCaptureContext (PCONTEXT ContextRecord)
;
; Routine Description:
;
;   This function fills in the specified context record with the
;   current state of the machine, except that the values of EBP
;   and ESP are computed to be those of the caller's caller.
;
;   N.B.  This function assumes it is called from a 'C' procedure with
;         the old ebp at [ebp], the return address at [ebp+4], and
;         old esp = ebp + 8.
;
;         Certain 'C' optimizations may cause this to not be true.
;
;   N.B.  This function does NOT adjust ESP to pop the arguments off
;         the caller's stack.  In other words, it provides a __cdecl ESP,
;         NOT a __stdcall ESP.  This is mainly because we can't figure
;         out how many arguments the caller takes.
;
;   N.B.  Floating point state is NOT captured.
;
;   RtlpCaptureContext does not capture volitales.
;   RtlCaptureContext captures volitales.
;
; Arguments:
;
;    ContextRecord  (esp+4) - Address of context record to fill in.
;
; Return Value:
;
;    The caller's return address.
;
;--

cPublicProc _RtlCaptureContext ,1

        push    ebx
        mov     ebx,[esp+8]         ; (ebx) -> ContextRecord

        mov     dword ptr [ebx.CsEax],eax
        mov     dword ptr [ebx.CsEcx],ecx
        mov     dword ptr [ebx.CsEdx],edx
        mov     eax, [esp]
        mov     dword ptr [ebx.CsEbx],eax

        mov     dword ptr [ebx.CsEsi],esi
        mov     dword ptr [ebx.CsEdi],edi
        jmp     RtlpCaptureCommon
stdENDP _RtlCaptureContext

cPublicProc _RtlpCaptureContext ,1

        push    ebx
        mov     ebx,[esp+8]         ; (ebx) -> ContextRecord

        mov     dword ptr [ebx.CsEax],0
        mov     dword ptr [ebx.CsEcx],0
        mov     dword ptr [ebx.CsEdx],0
        mov     dword ptr [ebx.CsEbx],0

        mov     dword ptr [ebx.CsEsi],0
        mov     dword ptr [ebx.CsEdi],0

RtlpCaptureCommon:
        mov     [ebx.CsSegCs],cs
        mov     [ebx.CsSegDs],ds
        mov     [ebx.CsSegEs],es
        mov     [ebx.CsSegFs],fs
        mov     [ebx.CsSegGs],gs
        mov     [ebx.CsSegSs],ss

        pushfd
        pop     [ebx.CsEflags]

        mov     eax,[ebp+4]
        mov     [ebx.CsEip],eax

        mov     eax,[ebp]
        mov     [ebx.CsEbp],eax

        lea     eax,[ebp+8]
        mov     [ebx.CsEsp],eax

        pop     ebx
        stdRET    _RtlpCaptureContext

stdENDP _RtlpCaptureContext

        page
        subttl  "Capture Context (private)"
;++
;
; VOID
; RtlCaptureContext (PCONTEXT ContextRecord)
;
; Routine Description:
;
;   This function is similar to RtlpCaptureContext except that
;   volatiles are captured as well.
;
;   This function fills in the specified context record with the
;   current state of the machine, except that the values of EBP
;   and ESP are computed to be those of the caller's caller.
;
;   N.B.  This function does NOT adjust ESP to pop the arguments off
;         the caller's stack.  In other words, it provides a __cdecl ESP,
;         NOT a __stdcall ESP.  This is mainly because we can't figure
;         out how many arguments the caller takes.
;
;   N.B.  Floating point state is NOT captured.
;
; Arguments:
;
;    ContextRecord  (esp+4) - Address of context record to fill in.
;
; Return Value:
;
;    The caller's return address.
;
;--


        page
        subttl  "Get Stack Limits"
;++
;
; VOID
; RtlpGetStackLimits (
;    OUT PULONG LowLimit,
;    OUT PULONG HighLimit
;    )
;
; Routine Description:
;
;    This function returns the current stack limits based on the current
;    processor mode.
;
; Arguments:
;
;    LowLimit (esp+4) - Supplies a pointer to a variable that is to receive
;       the low limit of the stack.
;
;    HighLimit (esp+8) - Supplies a pointer to a variable that is to receive
;       the high limit of the stack.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _RtlpGetStackLimits ,2
;cPublicFpo 2,0


        mov     eax,fs:PcPrcbData+PbCurrentThread ; get current thread address
        mov     eax,[eax]+ThStackLimit  ; get thread stack limit

        mov     ecx,[esp+4]
        mov     [ecx],eax               ; Save low limit

        mov     eax,fs:PcPrcbData+PbCurrentThread ; get current thread address
        mov     eax,[eax].ThInitialStack
        sub     eax, NPX_FRAME_LENGTH
        mov     ecx,[esp+8]
        mov     [ecx],eax               ; Save high limit

        stdRET    _RtlpGetStackLimits

stdENDP _RtlpGetStackLimits

        page
        subttl  "Get Exception Registration List Head"
;++
;
;   PVOID
;   RtlpGetRegistrationHead()
;
;   Routine Description:
;
;       This function returns the address of the first Exception
;       registration record for the current context.
;
;   Arguments:
;
;       None.
;
;   Return Value:
;
;       The address of the first registration record.
;
;--

cPublicProc _RtlpGetRegistrationHead    ,0
;cPublicFpo 0,0

        mov     eax,fs:PcExceptionList
        stdRET    _RtlpGetRegistrationHead

stdENDP _RtlpGetRegistrationHead
_TEXT$01   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\adtinit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    adtinit.c

Abstract:

    Auditing - Initialization Routines

--*/

#include "pch.h"

#pragma hdrstop


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SepAdtValidateAuditBounds)
#pragma alloc_text(PAGE,SepAdtInitializeBounds)
#pragma alloc_text(INIT,SepAdtInitializeCrashOnFail)
#pragma alloc_text(INIT,SepAdtInitializePrivilegeAuditing)
#pragma alloc_text(INIT,SepAdtInitializeAuditingOptions)
#endif


BOOLEAN
SepAdtValidateAuditBounds(
    ULONG Upper,
    ULONG Lower
    )

/*++

Routine Description:

    Examines the audit queue high and low water mark values and performs
    a general sanity check on them.

Arguments:

    Upper - High water mark.

    Lower - Low water mark.

Return Value:

    TRUE - values are acceptable.

    FALSE - values are unacceptable.


--*/

{
    PAGED_CODE();

    if ( Lower >= Upper ) {
        return( FALSE );
    }

    if ( Lower < 16 ) {
        return( FALSE );
    }

    if ( (Upper - Lower) < 16 ) {
        return( FALSE );
    }

    return( TRUE );
}


VOID
SepAdtInitializeBounds(
    VOID
    )

/*++

Routine Description:

    Queries the registry for the high and low water mark values for the
    audit log.  If they are not found or are unacceptable, returns without
    modifying the current values, which are statically initialized.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PSEP_AUDIT_BOUNDS AuditBounds;
    UCHAR Buffer[8];
    

    PAGED_CODE();

    Status = SepRegQueryHelper(
                 L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa",
                 L"Bounds",
                 REG_BINARY,
                 8,             // 8 bytes
                 Buffer,
                 NULL
                 );

    if (!NT_SUCCESS( Status )) {

        //
        // Didn't work, take the defaults
        //

        return;
    }

    AuditBounds = (PSEP_AUDIT_BOUNDS) Buffer;

    //
    // Sanity check what we got back
    //

    if(SepAdtValidateAuditBounds( AuditBounds->UpperBound,
                                  AuditBounds->LowerBound ))
    {
        //
        // Take what we got from the registry.
        //

        SepAdtMaxListLength = AuditBounds->UpperBound;
        SepAdtMinListLength = AuditBounds->LowerBound;
    }
}



NTSTATUS
SepAdtInitializeCrashOnFail(
    VOID
    )

/*++

Routine Description:

    Reads the registry to see if the user has told us to crash if an audit fails.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    ULONG    CrashOnAuditFail = 0;

    PAGED_CODE();

    SepCrashOnAuditFail = FALSE;

    //
    // Check the value of the CrashOnAudit flag in the registry.
    //

    Status = SepRegQueryDwordValue(
                 L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa",
                 CRASH_ON_AUDIT_FAIL_VALUE,
                 &CrashOnAuditFail
                 );

    //
    // If the key isn't there, don't turn on CrashOnFail.
    //

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        return( STATUS_SUCCESS );
    }


    if (NT_SUCCESS( Status )) {

        if ( CrashOnAuditFail == LSAP_CRASH_ON_AUDIT_FAIL) {
            SepCrashOnAuditFail = TRUE;
        }
    }

    return( STATUS_SUCCESS );
}


BOOLEAN
SepAdtInitializePrivilegeAuditing(
    VOID
    )

/*++

Routine Description:

    Checks to see if there is an entry in the registry telling us to do full privilege auditing
    (which currently means audit everything we normall audit, plus backup and restore privileges).

Arguments:

    None

Return Value:

    BOOLEAN - TRUE if Auditing has been initialized correctly, else FALSE.

--*/

{
    HANDLE KeyHandle;
    NTSTATUS Status;
    NTSTATUS TmpStatus;
    OBJECT_ATTRIBUTES Obja;
    ULONG ResultLength;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    CHAR KeyInfo[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(BOOLEAN)];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;
    BOOLEAN Verbose;

    PAGED_CODE();

    //
    // Query the registry to set up the privilege auditing filter.
    //

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa");

    InitializeObjectAttributes( &Obja,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );

    Status = NtOpenKey(
                 &KeyHandle,
                 KEY_QUERY_VALUE | KEY_SET_VALUE,
                 &Obja
                 );


    if (!NT_SUCCESS( Status )) {

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

            return ( SepInitializePrivilegeFilter( FALSE ));

        } else {

            return( FALSE );
        }
    }

    RtlInitUnicodeString( &ValueName, FULL_PRIVILEGE_AUDITING );

    Status = NtQueryValueKey(
                 KeyHandle,
                 &ValueName,
                 KeyValuePartialInformation,
                 KeyInfo,
                 sizeof(KeyInfo),
                 &ResultLength
                 );

    TmpStatus = NtClose(KeyHandle);
    ASSERT(NT_SUCCESS(TmpStatus));

    if (!NT_SUCCESS( Status )) {

        Verbose = FALSE;

    } else {

        pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)KeyInfo;
        Verbose = (BOOLEAN) *(pKeyInfo->Data);
    }

    return ( SepInitializePrivilegeFilter( Verbose ));
}


VOID
SepAdtInitializeAuditingOptions(
    VOID
    )

/*++

Routine Description:

    Initialize options that control auditing.
    (please refer to note in adtp.h near the def. of SEP_AUDIT_OPTIONS)

Arguments:

    None

Return Value:

    None

--*/

{
    NTSTATUS Status;
    ULONG OptionValue = 0;

    PAGED_CODE();

    //
    // initialize the default value
    //

    SepAuditOptions.DoNotAuditCloseObjectEvents = FALSE;

    //
    // if the value is present and set to 1, set the global
    // auditing option accordingly
    //

    Status = SepRegQueryDwordValue(
                 L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa\\AuditingOptions",
                 L"DoNotAuditCloseObjectEvents",
                 &OptionValue
                 );

    if (NT_SUCCESS(Status) && OptionValue)
    {
        SepAuditOptions.DoNotAuditCloseObjectEvents = TRUE;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\adtutil.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    adtutil.h - Security Auditing - Utility Routines

Abstract:

    This Module contains miscellaneous utility routines private to the
    Security Auditing Component.

--*/

NTSTATUS
SepRegQueryDwordValue(
    IN  PCWSTR KeyName,
    IN  PCWSTR ValueName,
    OUT PULONG Value
    );

NTSTATUS
SepRegQueryHelper(
    IN  PCWSTR KeyName,
    IN  PCWSTR ValueName,
    IN  ULONG  ValueType,
    IN  ULONG  ValueLength,
    OUT PVOID  ValueBuffer,
    OUT PULONG LengthRequired
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\adtlog.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    adtlog.c

Abstract:

    Auditing - Audit Record Queuing and Logging Routines

    This file contains functions that construct Audit Records in self-
    relative form from supplied information, enqueue/dequeue them and
    write them to the log.

--*/

#include "pch.h"

#pragma hdrstop

#include <msaudite.h>


#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE,SepAdtLogAuditRecord)
#pragma alloc_text(PAGE,SepAuditFailed)
#pragma alloc_text(PAGE,SepAdtMarshallAuditRecord)
#pragma alloc_text(PAGE,SepAdtCopyToLsaSharedMemory)
#pragma alloc_text(PAGE,SepQueueWorkItem)
#pragma alloc_text(PAGE,SepDequeueWorkItem)

#endif

VOID
SepAdtLogAuditRecord(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    )

/*++

Routine Description:

    This function manages the logging of Audit Records.  It provides the
    single interface to the Audit Logging component from the Audit/Alarm
    generation routines.  The function constructs an Audit Record in
    self-relative format from the information provided and appends it to
    the Audit Record Queue, a doubly-linked list of Audit Records awaiting
    output to the Audit Log.  A dedicated thread reads this queue, writing
    Audit Records to the Audit Log and removing them from the Audit Queue.

Arguments:

    AuditEventType - Specifies the type of the Audit Event described by
        the audit information provided.

    AuditInformation - Pointer to buffer containing captured auditing
        information related to an Audit Event of type AuditEventType.

Return Value:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL - Audit record was not queued
    STATUS_INSUFFICIENT_RESOURCES - unable to allocate heap

--*/

{
    NTSTATUS Status;
    BOOLEAN ForceQueue;
    PSEP_LSA_WORK_ITEM AuditWorkItem;

    PAGED_CODE();

    AuditWorkItem = ExAllocatePoolWithTag( PagedPool, sizeof( SEP_LSA_WORK_ITEM ), 'iAeS' );

    if ( AuditWorkItem == NULL ) {

        SepAuditFailed( STATUS_INSUFFICIENT_RESOURCES );
        return;
    }

    AuditWorkItem->Tag = SepAuditRecord;
    AuditWorkItem->CommandNumber = LsapWriteAuditMessageCommand;
    AuditWorkItem->ReplyBuffer = NULL;
    AuditWorkItem->ReplyBufferLength = 0;
    AuditWorkItem->CleanupFunction = NULL;

    //
    // Build an Audit record in self-relative format from the supplied
    // Audit Information.
    //

    Status = SepAdtMarshallAuditRecord(
                 AuditParameters,
                 (PSE_ADT_PARAMETER_ARRAY *) &AuditWorkItem->CommandParams.BaseAddress,
                 &AuditWorkItem->CommandParamsMemoryType
                 );

    if (NT_SUCCESS(Status)) {

        //
        // Extract the length of the Audit Record.  Store it as the length
        // of the Command Parameters buffer.
        //

        AuditWorkItem->CommandParamsLength =
            ((PSE_ADT_PARAMETER_ARRAY) AuditWorkItem->CommandParams.BaseAddress)->Length;

        //
        // If we're going to crash on a discarded audit, ignore the queue bounds
        // check and force the item onto the queue.
        //

        if (SepCrashOnAuditFail || AuditParameters->AuditId == SE_AUDITID_AUDITS_DISCARDED) {
            ForceQueue = TRUE;
        } else {
            ForceQueue = FALSE;
        }

        if (!SepQueueWorkItem( AuditWorkItem, ForceQueue )) {

            ExFreePool( AuditWorkItem->CommandParams.BaseAddress );
            ExFreePool( AuditWorkItem );

            //
            // We failed to put the record on the queue.  Take whatever action is
            // appropriate.
            //

            SepAuditFailed( STATUS_UNSUCCESSFUL );
        }

    } else {

        ExFreePool( AuditWorkItem );
        SepAuditFailed( Status );
    }
}



VOID
SepAuditFailed(
    IN NTSTATUS AuditStatus
    )

/*++

Routine Description:

    Bugchecks the system due to a missed audit (optional requirement
    for C2 compliance).

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE KeyHandle;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    ULONG NewValue;

    ASSERT(sizeof(UCHAR) == sizeof(BOOLEAN));

    if (!SepCrashOnAuditFail) {
        return;
    }

    //
    // Turn off flag in the registry that controls crashing on audit failure
    //

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa");

    InitializeObjectAttributes( &Obja,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE | 
                                    OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL
                                );
    do {

        Status = ZwOpenKey(
                     &KeyHandle,
                     KEY_SET_VALUE,
                     &Obja
                     );

    } while ((Status == STATUS_INSUFFICIENT_RESOURCES) || (Status == STATUS_NO_MEMORY));

    //
    // If the LSA key isn't there, he's got big problems.  But don't crash.
    //

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        SepCrashOnAuditFail = FALSE;
        return;
    }

    if (!NT_SUCCESS( Status )) {
        goto bugcheck;
    }

    RtlInitUnicodeString( &ValueName, CRASH_ON_AUDIT_FAIL_VALUE );

    NewValue = LSAP_ALLOW_ADIMIN_LOGONS_ONLY;

    do {

        Status = ZwSetValueKey( KeyHandle,
                                &ValueName,
                                0,
                                REG_DWORD,
                                &NewValue,
                                sizeof(ULONG)
                                );

    } while ((Status == STATUS_INSUFFICIENT_RESOURCES) || (Status == STATUS_NO_MEMORY));
    ASSERT(NT_SUCCESS(Status));

    if (!NT_SUCCESS( Status )) {
        goto bugcheck;
    }

    do {

        Status = ZwFlushKey( KeyHandle );

    } while ((Status == STATUS_INSUFFICIENT_RESOURCES) || (Status == STATUS_NO_MEMORY));
    ASSERT(NT_SUCCESS(Status));

    //
    // go boom.
    //

bugcheck:

    KeBugCheckEx(STATUS_AUDIT_FAILED, AuditStatus, 0, 0, 0);
}



NTSTATUS
SepAdtMarshallAuditRecord(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters,
    OUT PSE_ADT_PARAMETER_ARRAY *MarshalledAuditParameters,
    OUT PSEP_RM_LSA_MEMORY_TYPE RecordMemoryType
    )

/*++

Routine Description:

    This routine will take an AuditParameters structure and create
    a new AuditParameters structure that is suitable for sending
    to LSA.  It will be in self-relative form and allocated as
    a single chunk of memory.

Arguments:


    AuditParameters - A filled in set of AuditParameters to be marshalled.

    MarshalledAuditParameters - Returns a pointer to a block of heap memory
        containing the passed AuditParameters in self-relative form suitable
        for passing to LSA.

    RecordMemoryType -- type of memory returned. currently always uses
                        paged pool (returns SepRmPagedPoolMemory)

Return Value:

    NTSTATUS code

--*/

{
    ULONG i;
    ULONG TotalSize = sizeof( SE_ADT_PARAMETER_ARRAY );
    PUNICODE_STRING TargetString;
    PCHAR Base;
    ULONG BaseIncr;
    ULONG Size;
    PSE_ADT_PARAMETER_ARRAY_ENTRY pInParam, pOutParam;

    PAGED_CODE();

    ASSERT( AuditParameters );

    ASSERT(IsValidParameterCount(AuditParameters->ParameterCount));
    
    //
    // Calculate the total size required for the passed AuditParameters
    // block.  This calculation will probably be an overestimate of the
    // amount of space needed, because data smaller that 2 dwords will
    // be stored directly in the parameters structure, but their length
    // will be counted here anyway.  The overestimate can't be more than
    // 24 dwords, and will never even approach that amount, so it isn't
    // worth the time it would take to avoid it.
    //

    for (i=0; i<AuditParameters->ParameterCount; i++) {
        Size = AuditParameters->Parameters[i].Length;
        TotalSize += PtrAlignSize( Size );
    }

    //
    // Allocate a big enough block of memory to hold everything.
    // If it fails, quietly abort, since there isn't much else we
    // can do.
    //

    *MarshalledAuditParameters = ExAllocatePoolWithTag( PagedPool, TotalSize, 'pAeS' );

    if (*MarshalledAuditParameters == NULL) {

        *RecordMemoryType = SepRmNoMemory;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    *RecordMemoryType = SepRmPagedPoolMemory;

    RtlCopyMemory (
       *MarshalledAuditParameters,
       AuditParameters,
       sizeof( SE_ADT_PARAMETER_ARRAY )
       );

   (*MarshalledAuditParameters)->Length = TotalSize;
   (*MarshalledAuditParameters)->Flags  = SE_ADT_PARAMETERS_SELF_RELATIVE;

    pInParam  = &AuditParameters->Parameters[0];
    pOutParam = &((*MarshalledAuditParameters)->Parameters[0]);
   
    //
    // Start walking down the list of parameters and marshall them
    // into the target buffer.
    //

    Base = (PCHAR) ((PCHAR)(*MarshalledAuditParameters) + sizeof( SE_ADT_PARAMETER_ARRAY ));

    for (i=0; i<AuditParameters->ParameterCount; i++, pInParam++, pOutParam++) {


        switch (AuditParameters->Parameters[i].Type) {
            case SeAdtParmTypeNone:
            case SeAdtParmTypeUlong:
            case SeAdtParmTypeHexUlong:
            case SeAdtParmTypeLogonId:
            case SeAdtParmTypeLuid:
            case SeAdtParmTypeNoLogonId:
            case SeAdtParmTypeTime:
            case SeAdtParmTypeAccessMask:
            case SeAdtParmTypePtr:
            case SeAdtParmTypeDuration:
            case SeAdtParmTypeHexInt64:
            case SeAdtParmTypeDateTime:
            case SeAdtParmTypeMessage:
                {
                    //
                    // Nothing to do for this
                    //

                    break;

                }
            case SeAdtParmTypeString:
            case SeAdtParmTypeFileSpec:
                {
                    PUNICODE_STRING SourceString;
                    //
                    // We must copy the body of the unicode string
                    // and then copy the body of the string.  Pointers
                    // must be turned into offsets.

                    TargetString = (PUNICODE_STRING)Base;

                    SourceString = pInParam->Address;

                    *TargetString = *SourceString;

                    //
                    // Reset the data pointer in the output parameters to
                    // 'point' to the new string structure.
                    //

                    pOutParam->Address = Base - (ULONG_PTR)(*MarshalledAuditParameters);

                    Base += sizeof( UNICODE_STRING );

                    RtlCopyMemory( Base, SourceString->Buffer, SourceString->Length );

                    //
                    // Make the string buffer in the target string point to where we
                    // just copied the data.
                    //

                    TargetString->Buffer = (PWSTR)(Base - (ULONG_PTR)(*MarshalledAuditParameters));

                    BaseIncr = PtrAlignSize(SourceString->Length);

                    Base += BaseIncr;

                    ASSERT( (ULONG_PTR)Base <= (ULONG_PTR)(*MarshalledAuditParameters) + TotalSize );
                    break;
                }

            //
            // Handle types where we simply copy the buffer.
            //
            case SeAdtParmTypePrivs:
            case SeAdtParmTypeSid:
            case SeAdtParmTypeObjectTypes:
            case SeAdtParmTypeSockAddr:
            case SeAdtParmTypeGuid:

                {
                    //
                    // Copy the data into the output buffer
                    //

                    RtlCopyMemory( Base, pInParam->Address, pInParam->Length );

                    //
                    // Reset the 'address' of the data to be its offset in the
                    // buffer.
                    //

                    pOutParam->Address = Base - (ULONG_PTR)(*MarshalledAuditParameters);

                    Base +=  PtrAlignSize( pInParam->Length );


                    ASSERT( (ULONG_PTR)Base <= (ULONG_PTR)(*MarshalledAuditParameters) + TotalSize );
                    break;
                }

            default:
                {
                    //
                    // We got passed junk, complain.
                    //

                    ASSERT( FALSE );
                    break;
                }
        }
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
SepAdtCopyToLsaSharedMemory(
    IN HANDLE LsaProcessHandle,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PVOID *LsaBufferAddress
    )

/*++

Routine Description:

    This function allocates memory shared with the LSA and optionally copies
    a given buffer to it.

Arguments:

    LsaProcessHandle - Specifies a handle to the Lsa Process.

    Buffer - Pointer to the buffer to be copied.

    BufferLength - Length of buffer.

    LsaBufferAddress - Receives the address of the buffer valid in the
        Lsa process context.

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes returned by called routines.
--*/

{
    NTSTATUS Status, SecondaryStatus;
    PVOID OutputLsaBufferAddress = NULL;
    SIZE_T RegionSize = BufferLength;
    SIZE_T NumberOfBytesWritten = 0;
    BOOLEAN VmAllocated = FALSE;
    
    PAGED_CODE();

    Status = ZwAllocateVirtualMemory(
                 LsaProcessHandle,
                 &OutputLsaBufferAddress,
                 0,             // do not apply zero bits constraint
                 &RegionSize,
                 MEM_COMMIT,
                 PAGE_READWRITE
                 );

    if (!NT_SUCCESS(Status)) {

        goto CopyToLsaSharedMemoryError;
    }

    VmAllocated = TRUE;

    Status = ZwWriteVirtualMemory(
                 LsaProcessHandle,
                 OutputLsaBufferAddress,
                 Buffer,
                 BufferLength,
                 &NumberOfBytesWritten
                 );

    if (!NT_SUCCESS(Status)) {

        goto CopyToLsaSharedMemoryError;
    }

    *LsaBufferAddress = OutputLsaBufferAddress;
    return(Status);

CopyToLsaSharedMemoryError:

    //
    // If we allocated memory, free it.
    //

    if ( VmAllocated ) {

        RegionSize = 0;

        SecondaryStatus = ZwFreeVirtualMemory(
                              LsaProcessHandle,
                              &OutputLsaBufferAddress,
                              &RegionSize,
                              MEM_RELEASE
                              );

        ASSERT(NT_SUCCESS(SecondaryStatus));
    }

    return(Status);
}


BOOLEAN
SepQueueWorkItem(
    IN PSEP_LSA_WORK_ITEM LsaWorkItem,
    IN BOOLEAN ForceQueue
    )

/*++

Routine Description:

    Puts the passed work item on the queue to be passed to LSA,
    and returns the state of the queue upon arrival.

Arguments:

    LsaWorkItem - Pointer to the work item to be queued.

    ForceQueue - Indicate that this item is not to be discarded
        because of a full queue.

Return Value:

    TRUE - The item was successfully queued.

    FALSE - The item was not queued and must be discarded.

--*/

{
    BOOLEAN rc = TRUE;
    BOOLEAN StartExThread = FALSE ;

    PAGED_CODE();

    SepLockLsaQueue();

    //
    // See if LSA has died. If it has then just return with an error.
    //
    if (SepAdtLsaDeadEvent != NULL) {
        rc = FALSE;
        goto Exit;
    }

    if (SepAdtDiscardingAudits && !ForceQueue) {

        if (SepAdtCurrentListLength < SepAdtMinListLength) {

            //
            // We need to generate an audit saying how many audits we've
            // discarded.
            //
            // Since we have the mutex protecting the Audit queue, we don't
            // have to worry about anyone coming along and logging an
            // audit.  But *we* can, since a mutex may be acquired recursively.
            //
            // Since we are so protected, turn off the SepAdtDiscardingAudits
            // flag here so that we don't come through this path again.
            //

            SepAdtDiscardingAudits = FALSE;

            SepAdtGenerateDiscardAudit();

            //
            // We must assume that that worked, so clear the discard count.
            //

            SepAdtCountEventsDiscarded = 0;

            //
            // Our 'audits discarded' audit is now on the queue,
            // continue logging the one we started with.
            //

        } else {

            //
            // We are not yet below our low water mark.  Toss
            // this audit and increment the discard count.
            //

            SepAdtCountEventsDiscarded++;
            rc = FALSE;
            goto Exit;
        }
    }

    if (SepAdtCurrentListLength < SepAdtMaxListLength || ForceQueue) {

        InsertTailList(&SepLsaQueue, &LsaWorkItem->List);

        if (++SepAdtCurrentListLength == 1) {

            StartExThread = TRUE ;
        }

    } else {

        //
        // There is no room for this audit on the queue,
        // so change our state to 'discarding' and tell
        // the caller to toss this audit.
        //

        SepAdtDiscardingAudits = TRUE;

        rc = FALSE;
    }

Exit:

    SepUnlockLsaQueue();

    if ( StartExThread )
    {
        ExInitializeWorkItem( &SepExWorkItem.WorkItem,
                              (PWORKER_THREAD_ROUTINE) SepRmCallLsa,
                              &SepExWorkItem
                              );

        ExQueueWorkItem( &SepExWorkItem.WorkItem, DelayedWorkQueue );
    }

    return( rc );
}



PSEP_LSA_WORK_ITEM
SepDequeueWorkItem(
    VOID
    )

/*++

Routine Description:

    Removes the top element of the SepLsaQueue and returns the
    next element if there is one, NULL otherwise.

Arguments:

    None.

Return Value:

    A pointer to the next SEP_LSA_WORK_ITEM, or NULL.

--*/

{
    PSEP_LSA_WORK_ITEM OldWorkQueueItem;

    PAGED_CODE();

    SepLockLsaQueue();

    OldWorkQueueItem = (PSEP_LSA_WORK_ITEM)RemoveHeadList(&SepLsaQueue);
    OldWorkQueueItem->List.Flink = NULL;

    SepAdtCurrentListLength--;

    if (IsListEmpty( &SepLsaQueue )) {
        //
        // If LSA has died and the RM thread is waiting till we finish up. Notify it that we are all done
        //
        if (SepAdtLsaDeadEvent != NULL) {
            KeSetEvent (SepAdtLsaDeadEvent, 0, FALSE);
        }
        SepUnlockLsaQueue();

        ExFreePool( OldWorkQueueItem );
        return( NULL );
    }

    //
    // We know there's something on the queue now, so we
    // can unlock it.
    //

    SepUnlockLsaQueue();

    ExFreePool( OldWorkQueueItem );

    return((PSEP_LSA_WORK_ITEM)(&SepLsaQueue)->Flink);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\adtutil.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    adtutil.c - Security Auditing - Utility Routines

Abstract:

    This Module contains miscellaneous utility routines private to the
    Security Auditing Component.

--*/

#include "pch.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SepRegQueryDwordValue)
#endif



NTSTATUS
SepRegQueryHelper(
    IN  PCWSTR KeyName,
    IN  PCWSTR ValueName,
    IN  ULONG  ValueType,
    IN  ULONG  ValueLength,
    OUT PVOID  ValueBuffer,
    OUT PULONG LengthRequired
    )
/*++

Routine Description:

    Open regkey KeyName, read the value specified by ValueName
    and return the value.

Arguments:

    KeyName        - name of key to open

    ValueName      - name of value to read

    ValueType      - type of value to read (REG_DWORD etc.)

    ValueLength    - size in bytes of the value to read

    ValueBuffer    - pointer to returned value

    LengthRequired - if the passed buffer is not sufficient to hold
                     the value, this param will return the actual size
                     in bytes required.

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    UNICODE_STRING usKey, usValue;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };

    //
    // we will read-in data up to 64 bytes in stack buffer
    //

    CHAR KeyInfo[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 64];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;
    HANDLE hKey = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS CloseStatus;
    ULONG ResultLength;
        
    PAGED_CODE();

    RtlInitUnicodeString( &usKey, KeyName );
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &usKey,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    Status = ZwOpenKey(
                 &hKey,
                 KEY_QUERY_VALUE | OBJ_KERNEL_HANDLE,
                 &ObjectAttributes
                 );

    if (NT_SUCCESS( Status ))
    {
        RtlInitUnicodeString( &usValue, ValueName );

        Status = ZwQueryValueKey(
                     hKey,
                     &usValue,
                     KeyValuePartialInformation,
                     KeyInfo,
                     sizeof(KeyInfo),
                     &ResultLength
                     );
        
        if (NT_SUCCESS( Status ))
        {
            pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)KeyInfo;

            if (( pKeyInfo->Type == ValueType) &&
                ( pKeyInfo->DataLength == ValueLength ))
            {
                switch (ValueType)
                {
                    case REG_DWORD:
                        *((PULONG)ValueBuffer) = *((PULONG) (pKeyInfo->Data));
                        break;

                    case REG_BINARY:
                        RtlCopyMemory( ValueBuffer, pKeyInfo->Data, ValueLength );
                        break;
                        
                    default:
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                }
            }
            else
            {
                Status = STATUS_OBJECT_TYPE_MISMATCH;
            }
        }

        CloseStatus = ZwClose(hKey);
        
        ASSERT( NT_SUCCESS( CloseStatus ));
    }

    return Status;
}


NTSTATUS
SepRegQueryDwordValue(
    IN  PCWSTR KeyName,
    IN  PCWSTR ValueName,
    OUT PULONG Value
    )
/*++

Routine Description:

    Open regkey KeyName, read a REG_DWORD value specified by ValueName
    and return the value.

Arguments:

    KeyName - name of key to open

    ValueName - name of value to read

    Value - pointer to returned value

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    
    return SepRegQueryHelper(
               KeyName,
               ValueName,
               REG_DWORD,
               sizeof(ULONG),
               Value,
               NULL
               );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\adtp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    adtp.h

Abstract:

    Auditing - Private Defines, Function Prototypes and Macro Functions

--*/

#ifndef _ADTP_H_
#define _ADTP_H_

#include "tokenp.h"

//
// Audit Log Information
//

POLICY_AUDIT_LOG_INFO SepAdtLogInformation;

extern BOOLEAN SepAdtAuditingEnabled;

//
// High and low water marks to control the length of the audit queue
//

extern ULONG SepAdtMaxListLength;
extern ULONG SepAdtMinListLength;
//
// Set when LSA has died.
//
extern PKEVENT SepAdtLsaDeadEvent;
//
// Structure used to query the above values from the registry
//

typedef struct _SEP_AUDIT_BOUNDS {

    ULONG UpperBound;
    ULONG LowerBound;

} SEP_AUDIT_BOUNDS, *PSEP_AUDIT_BOUNDS;


//
// Number of events discarded
//

extern ULONG SepAdtCountEventsDiscarded;


//
// Number of events on the queue
//

extern ULONG SepAdtCurrentListLength;


//
// Flag to tell us that we're discarding audits
//

extern BOOLEAN SepAdtDiscardingAudits;

//
// Flag to tell us that we should crash if we miss an audit.
//

extern BOOLEAN SepCrashOnAuditFail;

//
// Value name for verbose privilege auditing
//

#define FULL_PRIVILEGE_AUDITING   L"FullPrivilegeAuditing"

//
// security descriptor to be used for adding a SACL on system processes
//

extern PSECURITY_DESCRIPTOR SepProcessAuditSd;

//
// security descriptor to check if a given token has any one of
// following sids in it:
// -- SeLocalSystemSid
// -- SeLocalServiceSid
// -- SeNetworkServiceSid
//

extern PSECURITY_DESCRIPTOR SepImportantProcessSd;

//
// pseudo access bit used in each ACE of SepImportantProcessSd
//

#define SEP_QUERY_MEMBERSHIP 1

//
// used with SepImportantProcessSd
//

extern GENERIC_MAPPING GenericMappingForMembershipCheck;

NTSTATUS
SepAdtMarshallAuditRecord(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters,
    OUT PSE_ADT_PARAMETER_ARRAY *MarshalledAuditParameters,
    OUT PSEP_RM_LSA_MEMORY_TYPE RecordMemoryType
    );


BOOLEAN
SepAdtPrivilegeObjectAuditAlarm (
    IN PUNICODE_STRING CapturedSubsystemName OPTIONAL,
    IN PVOID HandleId,
    IN PTOKEN ClientToken OPTIONAL,
    IN PTOKEN PrimaryToken,
    IN PVOID ProcessId,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET CapturedPrivileges,
    IN BOOLEAN AccessGranted
    );

VOID
SepAdtTraverseAuditAlarm(
    IN PLUID OperationID,
    IN PVOID DirectoryObject,
    IN PSID UserSid,
    IN LUID AuthenticationId,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET Privileges OPTIONAL,
    IN BOOLEAN AccessGranted,
    IN BOOLEAN GenerateAudit,
    IN BOOLEAN GenerateAlarm
    );

VOID
SepAdtCreateInstanceAuditAlarm(
    IN PLUID OperationID,
    IN PVOID Object,
    IN PSID UserSid,
    IN LUID AuthenticationId,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET Privileges OPTIONAL,
    IN BOOLEAN AccessGranted,
    IN BOOLEAN GenerateAudit,
    IN BOOLEAN GenerateAlarm
    );

VOID
SepAdtCreateObjectAuditAlarm(
    IN PLUID OperationID,
    IN PUNICODE_STRING DirectoryName,
    IN PUNICODE_STRING ComponentName,
    IN PSID UserSid,
    IN LUID AuthenticationId,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN AccessGranted,
    IN BOOLEAN GenerateAudit,
    IN BOOLEAN GenerateAlarm
    );

VOID
SepAdtPrivilegedServiceAuditAlarm (
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN PUNICODE_STRING CapturedSubsystemName,
    IN PUNICODE_STRING CapturedServiceName,
    IN PTOKEN ClientToken OPTIONAL,
    IN PTOKEN PrimaryToken,
    IN PPRIVILEGE_SET CapturedPrivileges,
    IN BOOLEAN AccessGranted
    );


VOID
SepAdtCloseObjectAuditAlarm(
    IN PUNICODE_STRING CapturedSubsystemName,
    IN PVOID HandleId,
    IN PSID UserSid
    );

VOID
SepAdtDeleteObjectAuditAlarm(
    IN PUNICODE_STRING CapturedSubsystemName,
    IN PVOID HandleId,
    IN PSID UserSid
    );

BOOLEAN
SepAdtOpenObjectAuditAlarm (
    IN PUNICODE_STRING CapturedSubsystemName,
    IN PVOID *HandleId OPTIONAL,
    IN PUNICODE_STRING CapturedObjectTypeName,
    IN PUNICODE_STRING CapturedObjectName OPTIONAL,
    IN PTOKEN ClientToken OPTIONAL,
    IN PTOKEN PrimaryToken,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess,
    IN PLUID OperationId,
    IN PPRIVILEGE_SET CapturedPrivileges OPTIONAL,
    IN BOOLEAN AccessGranted,
    IN HANDLE ProcessID,
    IN POLICY_AUDIT_EVENT_TYPE AuditType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PACCESS_MASK GrantedAccessArray OPTIONAL
    );

BOOLEAN
SepAdtOpenObjectForDeleteAuditAlarm(
    IN PUNICODE_STRING CapturedSubsystemName,
    IN PVOID *HandleId,
    IN PUNICODE_STRING CapturedObjectTypeName,
    IN PUNICODE_STRING CapturedObjectName,
    IN PTOKEN ClientToken OPTIONAL,
    IN PTOKEN PrimaryToken,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess,
    IN PLUID OperationId,
    IN PPRIVILEGE_SET CapturedPrivileges OPTIONAL,
    IN BOOLEAN AccessGranted,
    IN HANDLE ProcessID
    );

VOID
SepAdtObjectReferenceAuditAlarm(
    IN PVOID Object,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN AccessGranted
    );

#define SepAdtAuditThisEvent(AuditType, AccessGranted)                  \
    (SepAdtAuditingEnabled &&                                           \
    ((SeAuditingState[AuditType].AuditOnSuccess && *AccessGranted) ||   \
    (SeAuditingState[AuditType].AuditOnFailure && !(*AccessGranted))))

VOID
SepAdtInitializeBounds(
    VOID
    );

VOID
SepAuditFailed(
    IN NTSTATUS AuditStatus
    );

NTSTATUS
SepAdtInitializeCrashOnFail(
    VOID
    );

BOOLEAN
SepInitializePrivilegeFilter(
    BOOLEAN Verbose
    );

BOOLEAN
SepAdtInitializePrivilegeAuditing(
    VOID
    );

// ----------------------------------------------------------------------
// The following is used only temporarily for NT5.
//
// NT5 does not provide any facility to enable/disable auditing at
// audit-event level. It only supports it at audit category level.
// This creates problems if one wants to audit only certain specific
// audit events of a category. The current design gives you all or none for
// each category.
//
// Post NT5 auditing will provide a better/flexible design that will address
// this issue. For now, to delight some valuable customers, we provide this
// hack / registry based solution. This solution will be removed post NT5.
//

VOID
SepAdtInitializeAuditingOptions(
    VOID
    );

typedef struct _SEP_AUDIT_OPTIONS
{
    BOOLEAN DoNotAuditCloseObjectEvents;
} SEP_AUDIT_OPTIONS;

extern SEP_AUDIT_OPTIONS SepAuditOptions;

// ----------------------------------------------------------------------

#endif // _ADTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\adtvars.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    adtvars.c

Abstract:

    Auditing - Private Variables

--*/

#include "pch.h"

#pragma hdrstop


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

//
// Auditing State.  This contains the Auditing Mode and the array of
// Event Auditing Options
//

//POLICY_AUDIT_EVENTS_INFO SepAdtState;

//
// Audit Log Information
//

POLICY_AUDIT_LOG_INFO SepAdtLogInformation = {0};

//
// High and low water marks to control the length of the audit queue
// These are initialized to their default values in case we can't get
// them out of the registry.
//

ULONG SepAdtMaxListLength = 0x3000;
ULONG SepAdtMinListLength = 0x2000;

ULONG SepAdtCurrentListLength = 0;

//
// Number of events discarded
//

ULONG SepAdtCountEventsDiscarded = 0;

//
// Flag used to indicate that we are currently discarding audit events
//

BOOLEAN SepAdtDiscardingAudits = FALSE;

//
// see note in adtp.h regarding SEP_AUDIT_OPTIONS
//

SEP_AUDIT_OPTIONS SepAuditOptions = { 0 };

//
// Used to indicate that LSA process has died
// (see adtlog.c and rmmain.c)
//

PKEVENT SepAdtLsaDeadEvent = NULL;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\pch.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
//
// You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//
//

#pragma warning(push, 3)
#include <ntos.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include "zwapi.h"
#include "nturtl.h"

#include "sep.h"
#include "tokenp.h"
#include "sertlp.h"
#include "adt.h"
#include "adtp.h"
#include "rmp.h"
#include "adtutil.h"
#pragma warning(pop)                                      

//
// uncomment the following to enable a lot of warnings
// 
// #include <warning.h>
// #pragma warning(3:4100)   // Unreferenced formal parameter
// #pragma warning(3:4701)   // local may be used w/o init
// #pragma warning(3:4702)   // Unreachable code
// #pragma warning(3:4705)   // Statement has no effect
// #pragma warning(3:4706)   // assignment w/i conditional expression
// #pragma warning(3:4709)   // command operator w/o index expression
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\capture.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Capture.c

Abstract:

    This Module implements the security data structure capturing routines.
    There are corresponding Release routines for the data structures that
    are captured into allocated pool.

--*/

#include "pch.h"
#pragma hdrstop

#pragma alloc_text(PAGE,SeCaptureSecurityDescriptor)
#pragma alloc_text(PAGE,SeReleaseSecurityDescriptor)
#pragma alloc_text(PAGE,SepCopyProxyData)
#pragma alloc_text(PAGE,SepFreeProxyData)
#pragma alloc_text(PAGE,SepProbeAndCaptureQosData)
#pragma alloc_text(PAGE,SeFreeCapturedSecurityQos)
#pragma alloc_text(PAGE,SeCaptureSecurityQos)
#pragma alloc_text(PAGE,SeCaptureSid)
#pragma alloc_text(PAGE,SeReleaseSid)
#pragma alloc_text(PAGE,SeCaptureAcl)
#pragma alloc_text(PAGE,SeReleaseAcl)
#pragma alloc_text(PAGE,SeCaptureLuidAndAttributesArray)
#pragma alloc_text(PAGE,SeReleaseLuidAndAttributesArray)
#pragma alloc_text(PAGE,SeCaptureSidAndAttributesArray)
#pragma alloc_text(PAGE,SeReleaseSidAndAttributesArray)
#pragma alloc_text(PAGE,SeCaptureAuditPolicy)
#pragma alloc_text(PAGE,SeReleaseAuditPolicy)
#pragma alloc_text(PAGE,SeComputeQuotaInformationSize)
#pragma alloc_text(PAGE,SeValidSecurityDescriptor)

#define LongAligned( ptr )  (LongAlignPtr(ptr) == (ptr))

NTSTATUS
SeCaptureSecurityDescriptor (
    __in PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    __in KPROCESSOR_MODE RequestorMode,
    __in POOL_TYPE PoolType,
    __in BOOLEAN ForceCapture,
    __deref_out PSECURITY_DESCRIPTOR *OutputSecurityDescriptor
    )

/*++

Routine Description:

    This routine probes and captures a copy of the security descriptor based
    upon the following tests.

    if the requestor mode is not kernel mode then

        probe and capture the input descriptor
        (the captured descriptor is self-relative)

    if the requestor mode is kernel mode then

        if force capture is true then

            do not probe the input descriptor, but do capture it.
            (the captured descriptor is self-relative)

        else

            do nothing
            (the input descriptor is expected to be self-relative)

Arguments:

    InputSecurityDescriptor - Supplies the security descriptor to capture.
    This parameter is assumed to have been provided by the mode specified
    in RequestorMode.

    RequestorMode - Specifies the caller's access mode.

    PoolType - Specifies which pool type to allocate the captured
        descriptor from

    ForceCapture - Specifies whether the input descriptor should always be
        captured

    OutputSecurityDescriptor - Supplies the address of a pointer to the
        output security descriptor.  The captured descriptor will be
        self-relative format.

Return Value:

    STATUS_SUCCESS if the operation is successful.

    STATUS_INVALID_SID - An SID within the security descriptor is not
        a valid SID.

    STATUS_INVALID_ACL - An ACL within the security descriptor is not
        a valid ACL.

    STATUS_UNKNOWN_REVISION - The revision level of the security descriptor
        is not one known to this revision of the capture routine.
--*/

{
#define SEP_USHORT_OVERFLOW ((ULONG) ((USHORT) -1))

    SECURITY_DESCRIPTOR Captured;
    SECURITY_DESCRIPTOR_RELATIVE *PIOutputSecurityDescriptor;
    PCHAR DescriptorOffset;

    ULONG SaclSize;
    ULONG NewSaclSize;

    ULONG DaclSize;
    ULONG NewDaclSize;

    ULONG OwnerSubAuthorityCount=0;
    ULONG OwnerSize=0;
    ULONG NewOwnerSize;

    ULONG GroupSubAuthorityCount=0;
    ULONG GroupSize=0;
    ULONG NewGroupSize;

    ULONG Size;

    PAGED_CODE();

    //
    //  if the security descriptor is null then there is really nothing to
    //  capture
    //

    if (InputSecurityDescriptor == NULL) {

        (*OutputSecurityDescriptor) = NULL;

        return STATUS_SUCCESS;

    }

    //
    //  check if the requestors mode is kernel mode and we are not
    //  to force a capture
    //

    if ((RequestorMode == KernelMode) && (ForceCapture == FALSE)) {

        //
        //  Yes it is so we don't need to do any work and can simply
        //  return a pointer to the input descriptor
        //

        (*OutputSecurityDescriptor) = InputSecurityDescriptor;

        return STATUS_SUCCESS;

    }


    //
    //  We need to probe and capture the descriptor.
    //  To do this we need to probe the main security descriptor record
    //  first.
    //

    if (RequestorMode != KernelMode) {

        //
        // Capture of UserMode SecurityDescriptor.
        //

        try {

            //
            // Probe the main record of the input SecurityDescriptor
            //

            ProbeForReadSmallStructure( InputSecurityDescriptor,
                                        sizeof(SECURITY_DESCRIPTOR_RELATIVE),
                                        sizeof(ULONG) );

            //
            //  Capture the SecurityDescriptor main record.
            //

            RtlCopyMemory( (&Captured),
                          InputSecurityDescriptor,
                          sizeof(SECURITY_DESCRIPTOR_RELATIVE) );

            //
            // Verify the alignment is correct for absolute case. This is
            // only needed when pointer are 64 bits.
            //

            if (!(Captured.Control & SE_SELF_RELATIVE)) {

               if ((ULONG_PTR) InputSecurityDescriptor & (sizeof(ULONG_PTR) - 1)) {
                   ExRaiseDatatypeMisalignment();
               }
            }


        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

    } else {

        //
        //  Force capture of kernel mode SecurityDescriptor.
        //
        //  Capture the SecurityDescriptor main record.
        //  It doesn't need probing because requestor mode is kernel.
        //

        RtlCopyMemory( (&Captured),
                      InputSecurityDescriptor,
                      sizeof(SECURITY_DESCRIPTOR_RELATIVE) );

    }

    //
    // Make sure it is a revision we recognize
    //

    if (Captured.Revision != SECURITY_DESCRIPTOR_REVISION) {
       return STATUS_UNKNOWN_REVISION;
    }


    //
    // In case the input security descriptor is self-relative, change the
    // captured main record to appear as an absolute form so we can use
    // common code for both cases below.
    //
    // Note that the fields of Captured are left pointing to user
    // space addresses.  Treat them carefully.
    //

    try {

        Captured.Owner = RtlpOwnerAddrSecurityDescriptor(
            (SECURITY_DESCRIPTOR *)InputSecurityDescriptor
            );
        Captured.Group = RtlpGroupAddrSecurityDescriptor(
            (SECURITY_DESCRIPTOR *)InputSecurityDescriptor
            );
        Captured.Sacl  = RtlpSaclAddrSecurityDescriptor (
            (SECURITY_DESCRIPTOR *)InputSecurityDescriptor
            );
        Captured.Dacl  = RtlpDaclAddrSecurityDescriptor (
            (SECURITY_DESCRIPTOR *)InputSecurityDescriptor
            );
        Captured.Control &= ~SE_SELF_RELATIVE;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }



    //
    //  Indicate the size we are going to need to allocate for the captured
    //  acls
    //

    SaclSize = 0;
    DaclSize = 0;

    NewSaclSize = 0;
    NewDaclSize = 0;
    NewGroupSize = 0;
    NewOwnerSize = 0;

    //
    //  Probe (if necessary) and capture each of the components of a
    //  SECURITY_DESCRIPTOR.
    //

    //
    //  System ACL first
    //

    if ((Captured.Control & SE_SACL_PRESENT) &&
        (Captured.Sacl != NULL) ) {

        if (RequestorMode != KernelMode) {

            try {
                SaclSize = ProbeAndReadUshort( &(Captured.Sacl->AclSize) );
                ProbeForRead( Captured.Sacl,
                              SaclSize,
                              sizeof(ULONG) );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }

        } else {

            SaclSize = Captured.Sacl->AclSize;

        }

        NewSaclSize = (ULONG)LongAlignSize( SaclSize );

        //
        // Make sure that we do not have an overflow.
        //

        if (NewSaclSize > SEP_USHORT_OVERFLOW) {
            return STATUS_INVALID_ACL;
        }

    } else {
        //
        // Force the SACL to null if the bit is off
        //
        Captured.Sacl = NULL;
    }

    //
    //  Discretionary ACL
    //

    if ((Captured.Control & SE_DACL_PRESENT) &&
        (Captured.Dacl != NULL) ) {

        if (RequestorMode != KernelMode) {

            try {
                DaclSize = ProbeAndReadUshort( &(Captured.Dacl->AclSize) );
                ProbeForRead( Captured.Dacl,
                              DaclSize,
                              sizeof(ULONG) );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }

        } else {

            DaclSize = Captured.Dacl->AclSize;

        }

        NewDaclSize = (ULONG)LongAlignSize( DaclSize );

        //
        // Make sure that we do not have an overflow.
        //

        if (NewDaclSize > SEP_USHORT_OVERFLOW) {
            return STATUS_INVALID_ACL;
        }

    } else {
        //
        // Force the DACL to null if it is not present
        //
        Captured.Dacl = NULL;
    }

    //
    //  Owner SID
    //

    if (Captured.Owner != NULL)  {

        if (RequestorMode != KernelMode) {

            try {
                OwnerSubAuthorityCount =
                    ProbeAndReadUchar( &(((SID *)(Captured.Owner))->SubAuthorityCount) );
                OwnerSize = RtlLengthRequiredSid( OwnerSubAuthorityCount );
                ProbeForRead( Captured.Owner,
                              OwnerSize,
                              sizeof(ULONG) );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }

        } else {

            OwnerSubAuthorityCount = ((SID *)(Captured.Owner))->SubAuthorityCount;
            OwnerSize = RtlLengthRequiredSid( OwnerSubAuthorityCount );

        }

        NewOwnerSize = (ULONG)LongAlignSize( OwnerSize );

    }

    //
    //  Group SID
    //

    if (Captured.Group != NULL)  {

        if (RequestorMode != KernelMode) {

            try {
                GroupSubAuthorityCount =
                    ProbeAndReadUchar( &(((SID *)(Captured.Group))->SubAuthorityCount) );
                GroupSize = RtlLengthRequiredSid( GroupSubAuthorityCount );
                ProbeForRead( Captured.Group,
                              GroupSize,
                              sizeof(ULONG) );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }

        } else {

            GroupSubAuthorityCount = ((SID *)(Captured.Group))->SubAuthorityCount;
            GroupSize = RtlLengthRequiredSid( GroupSubAuthorityCount );

        }

        NewGroupSize = (ULONG)LongAlignSize( GroupSize );

    }



    //
    //  Now allocate enough pool to hold the descriptor
    //

    Size = sizeof(SECURITY_DESCRIPTOR_RELATIVE) +
           NewSaclSize +
           NewDaclSize +
           NewOwnerSize +
           NewGroupSize;

    (PIOutputSecurityDescriptor) = (SECURITY_DESCRIPTOR_RELATIVE *)ExAllocatePoolWithTag( PoolType,
                                                                                 Size,
                                                                                 'cSeS' );

    if ( PIOutputSecurityDescriptor == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    (*OutputSecurityDescriptor) = (PSECURITY_DESCRIPTOR)PIOutputSecurityDescriptor;
    DescriptorOffset = (PCHAR)(PIOutputSecurityDescriptor);


    //
    //  Copy the main security descriptor record over
    //

    RtlCopyMemory( DescriptorOffset,
                  &Captured,
                  sizeof(SECURITY_DESCRIPTOR_RELATIVE) );
    DescriptorOffset += sizeof(SECURITY_DESCRIPTOR_RELATIVE);

    //
    // Indicate the output descriptor is self-relative
    //

    PIOutputSecurityDescriptor->Control |= SE_SELF_RELATIVE;

    //
    //  If there is a System Acl, copy it over and set
    //  the output descriptor's offset to point to the newly captured copy.
    //

    if ((Captured.Control & SE_SACL_PRESENT) && (Captured.Sacl != NULL)) {


        try {
            RtlCopyMemory( DescriptorOffset,
                          Captured.Sacl,
                          SaclSize );


        } except(EXCEPTION_EXECUTE_HANDLER) {
            ExFreePool( PIOutputSecurityDescriptor );
            return GetExceptionCode();
        }

        if ((RequestorMode != KernelMode) &&
            (!SepCheckAcl( (PACL) DescriptorOffset, SaclSize )) ) {

            ExFreePool( PIOutputSecurityDescriptor );
            return STATUS_INVALID_ACL;
        }

        //
        // Change pointer to offset
        //

        PIOutputSecurityDescriptor->Sacl =
            RtlPointerToOffset( PIOutputSecurityDescriptor,
                                DescriptorOffset
                                );

        ((PACL) DescriptorOffset)->AclSize = (USHORT) NewSaclSize;
        DescriptorOffset += NewSaclSize;
    } else {
        PIOutputSecurityDescriptor->Sacl = 0;
    }

    //
    //  If there is a Discretionary Acl, copy it over and set
    //  the output descriptor's offset to point to the newly captured copy.
    //

    if ((Captured.Control & SE_DACL_PRESENT) && (Captured.Dacl != NULL)) {


        try {
            RtlCopyMemory( DescriptorOffset,
                          Captured.Dacl,
                          DaclSize );
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ExFreePool( PIOutputSecurityDescriptor );
            return GetExceptionCode();
        }

        if ((RequestorMode != KernelMode) &&
            (!SepCheckAcl( (PACL) DescriptorOffset, DaclSize )) ) {

            ExFreePool( PIOutputSecurityDescriptor );
            return STATUS_INVALID_ACL;
        }

        //
        // Change pointer to offset
        //

        PIOutputSecurityDescriptor->Dacl =
                   RtlPointerToOffset(
                        PIOutputSecurityDescriptor,
                        DescriptorOffset
                        );

        ((PACL) DescriptorOffset)->AclSize = (USHORT) NewDaclSize;
        DescriptorOffset += NewDaclSize;
    } else {
        PIOutputSecurityDescriptor->Dacl = 0;
    }

    //
    //  If there is an Owner SID, copy it over and set
    //  the output descriptor's offset to point to the newly captured copy.
    //

    if (Captured.Owner != NULL) {


        try {
            RtlCopyMemory( DescriptorOffset,
                          Captured.Owner,
                          OwnerSize );
            ((SID *) (DescriptorOffset))->SubAuthorityCount = (UCHAR) OwnerSubAuthorityCount;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            ExFreePool( PIOutputSecurityDescriptor );
            return GetExceptionCode();
        }

        if ((RequestorMode != KernelMode) &&
            (!RtlValidSid( (PSID) DescriptorOffset )) ) {

            ExFreePool( PIOutputSecurityDescriptor );
            return STATUS_INVALID_SID;
        }

        //
        // Change pointer to offset
        //

        PIOutputSecurityDescriptor->Owner =
                    RtlPointerToOffset(
                        PIOutputSecurityDescriptor,
                        DescriptorOffset
                        );

        DescriptorOffset += NewOwnerSize;

    } else {
        PIOutputSecurityDescriptor->Owner = 0;
    }

    //
    //  If there is a group SID, copy it over and set
    //  the output descriptor's offset to point to the newly captured copy.
    //

    if (Captured.Group != NULL) {


        try {
            RtlCopyMemory( DescriptorOffset,
                          Captured.Group,
                          GroupSize );

            ((SID *) DescriptorOffset)->SubAuthorityCount = (UCHAR) GroupSubAuthorityCount;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ExFreePool( PIOutputSecurityDescriptor );
            return GetExceptionCode();
        }

        if ((RequestorMode != KernelMode) &&
            (!RtlValidSid( (PSID) DescriptorOffset )) ) {

            ExFreePool( PIOutputSecurityDescriptor );
            return STATUS_INVALID_SID;
        }

        //
        // Change pointer to offset
        //

        PIOutputSecurityDescriptor->Group =
                    RtlPointerToOffset(
                        PIOutputSecurityDescriptor,
                        DescriptorOffset
                        );

        DescriptorOffset += NewGroupSize;
    } else {
        PIOutputSecurityDescriptor->Group = 0;
    }

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;

}

VOID
SeReleaseSecurityDescriptor (
    __in PSECURITY_DESCRIPTOR CapturedSecurityDescriptor,
    __in KPROCESSOR_MODE RequestorMode,
    __in BOOLEAN ForceCapture
    )

/*++

Routine Description:

    This routine releases a previously captured security descriptor.
    Only

Arguments:

    CapturedSecurityDescriptor - Supplies the security descriptor to release.

    RequestorMode - The processor mode specified when the descriptor was
        captured.

    ForceCapture - The ForceCapture value specified when the descriptor was
        captured.

Return Value:

    None.

--*/

{
    //
    // We only have something to deallocate if the requestor was user
    // mode or kernel mode requesting ForceCapture.
    //

    PAGED_CODE();

    if ( ((RequestorMode == KernelMode) && (ForceCapture == TRUE)) ||
          (RequestorMode == UserMode ) ) {
        if ( CapturedSecurityDescriptor ) {
            ExFreePool(CapturedSecurityDescriptor);
            }
    }

    return;

}

NTSTATUS
SepCopyProxyData (
    OUT PSECURITY_TOKEN_PROXY_DATA * DestProxyData,
    IN PSECURITY_TOKEN_PROXY_DATA SourceProxyData
    )

/*++

Routine Description:

    This routine copies a token proxy data structure from one token to another.

Arguments:

    DestProxyData - Receives a pointer to a new proxy data structure.

    SourceProxyData - Supplies a pointer to an already existing proxy data structure.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES on failure.

--*/

{

    PAGED_CODE();

    *DestProxyData = ExAllocatePoolWithTag( PagedPool, PtrAlignSize(sizeof( SECURITY_TOKEN_PROXY_DATA )) + SourceProxyData->PathInfo.Length, 'dPoT' );

    if (*DestProxyData == NULL) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    (*DestProxyData)->PathInfo.Buffer = (PWSTR)(((PUCHAR)(*DestProxyData)) + PtrAlignSize(sizeof( SECURITY_TOKEN_PROXY_DATA )));

    (*DestProxyData)->Length = SourceProxyData->Length;
    (*DestProxyData)->ProxyClass = SourceProxyData->ProxyClass;
    (*DestProxyData)->PathInfo.MaximumLength =
        (*DestProxyData)->PathInfo.Length = SourceProxyData->PathInfo.Length;
    (*DestProxyData)->ContainerMask = SourceProxyData->ContainerMask;
    (*DestProxyData)->ObjectMask = SourceProxyData->ObjectMask;

    RtlCopyUnicodeString( &(*DestProxyData)->PathInfo, &SourceProxyData->PathInfo );

    return( STATUS_SUCCESS );
}

VOID
SepFreeProxyData (
    IN PSECURITY_TOKEN_PROXY_DATA ProxyData
    )

/*++

Routine Description:

    This routine frees a SECURITY_TOKEN_PROXY_DATA structure and all sub structures.

Arguments:

    ProxyData - Supplies a pointer to an existing proxy data structure.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    if (ProxyData != NULL) {

        ExFreePool( ProxyData );
    }
}

NTSTATUS
SepProbeAndCaptureQosData(
    IN PSECURITY_ADVANCED_QUALITY_OF_SERVICE CapturedSecurityQos
    )

/*++

Routine Description:

    This routine probes and captures the embedded structures in a
    Security Quality of Service structure.

    This routine assumes that it is being called under an existing
    try-except clause.

Arguments:

    CapturedSecurityQos - Points to the captured body of a QOS
        structure.  The pointers in this structure are presumed
        not to be probed or captured at this point.

Return Value:

    STATUS_SUCCESS indicates no exceptions were encountered.

    Any access violations encountered will be returned.

--*/
{
    NTSTATUS Status;
    PSECURITY_TOKEN_PROXY_DATA CapturedProxyData;
    PSECURITY_TOKEN_AUDIT_DATA CapturedAuditData;
    SECURITY_TOKEN_PROXY_DATA StackProxyData;
    PAGED_CODE();

    CapturedProxyData = CapturedSecurityQos->ProxyData;
    CapturedSecurityQos->ProxyData = NULL;
    CapturedAuditData = CapturedSecurityQos->AuditData;
    CapturedSecurityQos->AuditData = NULL;

    if (ARGUMENT_PRESENT( CapturedProxyData )) {

        //
        // Make sure the body of the proxy data is ok to read.
        //

        ProbeForReadSmallStructure(
            CapturedProxyData,
            sizeof(SECURITY_TOKEN_PROXY_DATA),
            sizeof(ULONG)
            );

        StackProxyData = *CapturedProxyData;

        if (StackProxyData.Length != sizeof( SECURITY_TOKEN_PROXY_DATA )) {
            return( STATUS_INVALID_PARAMETER );
        }


        //
        // Probe the passed pathinfo buffer
        //

        ProbeForRead(
            StackProxyData.PathInfo.Buffer,
            StackProxyData.PathInfo.Length,
            sizeof( UCHAR )
            );

        Status = SepCopyProxyData( &CapturedSecurityQos->ProxyData, &StackProxyData );

        if (!NT_SUCCESS(Status)) {

            if (CapturedSecurityQos->ProxyData != NULL) {
                SepFreeProxyData( CapturedSecurityQos->ProxyData );
                CapturedSecurityQos->ProxyData = NULL;
            }

            return( Status );
        }

    }

    if (ARGUMENT_PRESENT( CapturedAuditData )) {

        PSECURITY_TOKEN_AUDIT_DATA LocalAuditData;

        //
        // Probe the audit data structure and make sure it looks ok
        //

        ProbeForReadSmallStructure(
            CapturedAuditData,
            sizeof( SECURITY_TOKEN_AUDIT_DATA ),
            sizeof( ULONG )
            );


        LocalAuditData = ExAllocatePool( PagedPool, sizeof( SECURITY_TOKEN_AUDIT_DATA ));

        if (LocalAuditData == NULL) {

            //
            // Cleanup any proxy data we may have allocated.
            //

            SepFreeProxyData( CapturedSecurityQos->ProxyData );
            CapturedSecurityQos->ProxyData = NULL;

            return( STATUS_INSUFFICIENT_RESOURCES );

        }

        //
        // Copy the data to the local buffer. Note: we do this in this
        // order so that if the final assignment fails the caller will
        // still be able to free the allocated pool.
        //

        CapturedSecurityQos->AuditData = LocalAuditData;

        *CapturedSecurityQos->AuditData = *CapturedAuditData;

        if ( LocalAuditData->Length != sizeof( SECURITY_TOKEN_AUDIT_DATA ) ) {
            SepFreeProxyData( CapturedSecurityQos->ProxyData );
            CapturedSecurityQos->ProxyData = NULL;
            ExFreePool(CapturedSecurityQos->AuditData);
            CapturedSecurityQos->AuditData = NULL;
            return( STATUS_INVALID_PARAMETER );
        }
    }

    return( STATUS_SUCCESS );

}

VOID
SeFreeCapturedSecurityQos(
    __in PVOID SecurityQos
    )

/*++

Routine Description:

    This routine frees the data associated with a captured SecurityQos
    structure.  It does not free the body of the structure, just whatever
    its internal fields point to.

Arguments:

    SecurityQos - Points to a captured security QOS structure.

Return Value:

    None.

--*/

{
    PSECURITY_ADVANCED_QUALITY_OF_SERVICE IAdvancedSecurityQos;

    PAGED_CODE();

    IAdvancedSecurityQos = (PSECURITY_ADVANCED_QUALITY_OF_SERVICE)SecurityQos;

    if (IAdvancedSecurityQos->Length == sizeof( SECURITY_ADVANCED_QUALITY_OF_SERVICE )) {

        if (IAdvancedSecurityQos->AuditData != NULL) {
            ExFreePool( IAdvancedSecurityQos->AuditData );
        }

        SepFreeProxyData( IAdvancedSecurityQos->ProxyData );
    }

    return;
}

NTSTATUS
SeCaptureSecurityQos (
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in KPROCESSOR_MODE RequestorMode,
    __out PBOOLEAN SecurityQosPresent,
    __out PSECURITY_ADVANCED_QUALITY_OF_SERVICE CapturedSecurityQos
)
/*++

Routine Description:

    This routine probes and captures a copy of any security quality
    of service parameters that might have been provided via the
    ObjectAttributes argument.

Arguments:

    ObjectAttributes - The object attributes from which the QOS
        information is to be retrieved.

    RequestorMode - Indicates the processor mode by which the access
        is being requested.

    SecurityQosPresent - Receives a boolean value indicating whether
        or not the optional security QOS information was available
        and copied.

    CapturedSecurityQos - Receives the security QOS information if available.

Return Value:

    STATUS_SUCCESS indicates no exceptions were encountered.

    Any access violations encountered will be returned.

--*/

{

    PSECURITY_QUALITY_OF_SERVICE LocalSecurityQos;
    ULONG LocalQosLength;
    PSECURITY_ADVANCED_QUALITY_OF_SERVICE LocalAdvancedSecurityQos;
    NTSTATUS Status;
    BOOLEAN CapturedQos;

    PAGED_CODE();

    CapturedQos =  FALSE;
    //
    //  Set default return
    //

    (*SecurityQosPresent) = FALSE;

    //
    //  check if the requestors mode is kernel mode
    //

    if (RequestorMode != KernelMode) {
        try {

            if ( ARGUMENT_PRESENT(ObjectAttributes) ) {

                ProbeForReadSmallStructure( ObjectAttributes,
                                            sizeof(OBJECT_ATTRIBUTES),
                                            sizeof(ULONG)
                                          );

                LocalSecurityQos =
                    (PSECURITY_QUALITY_OF_SERVICE)ObjectAttributes->SecurityQualityOfService;

                if ( ARGUMENT_PRESENT(LocalSecurityQos) ) {

                    ProbeForReadSmallStructure(
                        LocalSecurityQos,
                        sizeof(SECURITY_QUALITY_OF_SERVICE),
                        sizeof(ULONG)
                        );

                    LocalQosLength = LocalSecurityQos->Length;

                    //
                    // Check the length and see if this is a QOS or Advanced QOS
                    // structure.
                    //

                    if (LocalQosLength == sizeof( SECURITY_QUALITY_OF_SERVICE )) {

                        //
                        // It's a downlevel QOS, copy what's there and leave.
                        //

                        (*SecurityQosPresent) = TRUE;
                        RtlCopyMemory( CapturedSecurityQos, LocalSecurityQos, sizeof( SECURITY_QUALITY_OF_SERVICE ));
                        CapturedSecurityQos->ProxyData = NULL;
                        CapturedSecurityQos->AuditData = NULL;
                        CapturedSecurityQos->Length = LocalQosLength;

                    } else {

                        if (LocalQosLength == sizeof( SECURITY_ADVANCED_QUALITY_OF_SERVICE )) {

                            LocalAdvancedSecurityQos =
                                (PSECURITY_ADVANCED_QUALITY_OF_SERVICE)ObjectAttributes->SecurityQualityOfService;

                                ProbeForReadSmallStructure(
                                    LocalAdvancedSecurityQos,
                                    sizeof(SECURITY_ADVANCED_QUALITY_OF_SERVICE),
                                    sizeof(ULONG)
                                    );

                            (*SecurityQosPresent) = TRUE;
                            *CapturedSecurityQos = *LocalAdvancedSecurityQos;
                            CapturedSecurityQos->Length = LocalQosLength;

                            //
                            // Capture the proxy and audit data, if necessary.
                            //

                            if ( ARGUMENT_PRESENT(CapturedSecurityQos->ProxyData) || ARGUMENT_PRESENT( CapturedSecurityQos->AuditData ) ) {

                                CapturedQos = TRUE;
                                Status = SepProbeAndCaptureQosData( CapturedSecurityQos );

                                if (!NT_SUCCESS( Status )) {

                                    return( Status );
                                }
                            }

                        } else {

                            return( STATUS_INVALID_PARAMETER );
                        }
                    }

                } // end_if


            } // end_if

        } except(EXCEPTION_EXECUTE_HANDLER) {


            //
            // If we captured any proxy data, we need to free it now.
            //

            if ( CapturedQos ) {

                SepFreeProxyData( CapturedSecurityQos->ProxyData );

                if ( CapturedSecurityQos->AuditData != NULL ) {
                    ExFreePool( CapturedSecurityQos->AuditData );
                }
            }

            return GetExceptionCode();
        } // end_try


    } else {

        if ( ARGUMENT_PRESENT(ObjectAttributes) ) {
            if ( ARGUMENT_PRESENT(ObjectAttributes->SecurityQualityOfService) ) {
                (*SecurityQosPresent) = TRUE;

                if (((PSECURITY_QUALITY_OF_SERVICE)(ObjectAttributes->SecurityQualityOfService))->Length == sizeof( SECURITY_QUALITY_OF_SERVICE )) {

                    RtlCopyMemory( CapturedSecurityQos, ObjectAttributes->SecurityQualityOfService, sizeof( SECURITY_QUALITY_OF_SERVICE ));
                    CapturedSecurityQos->ProxyData = NULL;
                    CapturedSecurityQos->AuditData = NULL;

                } else {

                    (*CapturedSecurityQos) =
                        (*(SECURITY_ADVANCED_QUALITY_OF_SERVICE *)(ObjectAttributes->SecurityQualityOfService));
                }


            } // end_if
        } // end_if

    } // end_if

    return STATUS_SUCCESS;
}

NTSTATUS
SeCaptureSid (
    __in PSID InputSid,
    __in KPROCESSOR_MODE RequestorMode,
    __inout_bcount_opt(CaptureBufferLength) PVOID CaptureBuffer,
    __in ULONG CaptureBufferLength,
    __in POOL_TYPE PoolType,
    __in BOOLEAN ForceCapture,
    __deref_out PSID *CapturedSid
)
/*++

Routine Description:

    This routine probes and captures a copy of the specified SID.
    The SID is either captured into a provided buffer, or pool
    allocated to receive the SID.


    if the requestor mode is not kernel mode then

        probe and capture the input SID

    if the requestor mode is kernel mode then

        if force capture is true then

            do not probe the input SID, but do capture it

        else

            return address of original, but don't copy

Arguments:

    InputSid - Supplies the SID to capture.  This parameter is assumed
        to have been provided by the mode specified in RequestorMode.

    RequestorMode - Specifies the caller's access mode.

    CaptureBuffer - Specifies a buffer into which the SID is to be
        captured.  If this parameter is not provided, pool will be allocated
        to hold the captured data.

    CaptureBufferLength - Indicates the length, in bytes, of the capture
        buffer.

    PoolType - Specifies which pool type to allocate to capture the
        SID into.  This parameter is ignored if CaptureBuffer is provided.

    ForceCapture - Specifies whether the SID should be captured even if
        requestor mode is kernel.

    CapturedSid - Supplies the address of a pointer to an SID.
        The pointer will be set to point to the captured (or uncaptured) SID.

    AlignedSidSize - Supplies the address of a ULONG to receive the length
        of the SID rounded up to the next longword boundary.

Return Value:

    STATUS_SUCCESS indicates the capture was successful.

    STATUS_BUFFER_TOO_SMALL - indicates the buffer provided to capture the SID
        into wasn't large enough to hold the SID.

    Any access violations encountered will be returned.

--*/

{



    ULONG GetSidSubAuthorityCount;
    ULONG SidSize;

    PAGED_CODE();

    //
    //  check if the requestors mode is kernel mode and we are not
    //  to force a capture.
    //

    if ((RequestorMode == KernelMode) && (ForceCapture == FALSE)) {

        //
        //  We don't need to do any work and can simply
        //  return a pointer to the input SID
        //

        (*CapturedSid) = InputSid;

        return STATUS_SUCCESS;
    }


    //
    // Get the length needed to hold the SID
    //

    if (RequestorMode != KernelMode) {

        try {
            GetSidSubAuthorityCount =
                ProbeAndReadUchar( &(((SID *)(InputSid))->SubAuthorityCount) );
            SidSize = RtlLengthRequiredSid( GetSidSubAuthorityCount );
            ProbeForRead( InputSid,
                          SidSize,
                          sizeof(ULONG) );
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

    } else {

        GetSidSubAuthorityCount = ((SID *)(InputSid))->SubAuthorityCount;
        SidSize = RtlLengthRequiredSid( GetSidSubAuthorityCount );

    }


    //
    // If a buffer was provided, compare lengths.
    // Otherwise, allocate a buffer.
    //

    if (ARGUMENT_PRESENT(CaptureBuffer)) {

        if (SidSize > CaptureBufferLength) {
            return STATUS_BUFFER_TOO_SMALL;
        } else {

            (*CapturedSid) = CaptureBuffer;
        }

    } else {

        (*CapturedSid) = (PSID)ExAllocatePoolWithTag(PoolType, SidSize, 'iSeS');

        if ( *CapturedSid == NULL ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }

    }

    //
    // Now copy the SID and validate it
    //

    try {

        RtlCopyMemory( (*CapturedSid), InputSid, SidSize );
        ((SID *)(*CapturedSid))->SubAuthorityCount = (UCHAR) GetSidSubAuthorityCount;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        if (!ARGUMENT_PRESENT(CaptureBuffer)) {
            ExFreePool( (*CapturedSid) );
            *CapturedSid = NULL;
        }

        return GetExceptionCode();
    }

    if ((!RtlValidSid( (*CapturedSid) )) ) {

        if (!ARGUMENT_PRESENT(CaptureBuffer)) {
            ExFreePool( (*CapturedSid) );
            *CapturedSid = NULL;
        }

        return STATUS_INVALID_SID;
    }

    return STATUS_SUCCESS;

}

VOID
SeReleaseSid (
    __in PSID CapturedSid,
    __in KPROCESSOR_MODE RequestorMode,
    __in BOOLEAN ForceCapture
    )

/*++

Routine Description:

    This routine releases a previously captured SID.

    This routine should NOT be called if the SID was captured into a
    provided CaptureBuffer (see SeCaptureSid).

Arguments:

    CapturedSid - Supplies the SID to release.

    RequestorMode - The processor mode specified when the SID was captured.

    ForceCapture - The ForceCapture value specified when the SID was
        captured.

Return Value:

    None.

--*/

{
    //
    // We only have something to deallocate if the requestor was user
    // mode or kernel mode requesting ForceCapture.
    //

    PAGED_CODE();

    if ( ((RequestorMode == KernelMode) && (ForceCapture == TRUE)) ||
          (RequestorMode == UserMode ) ) {

        ExFreePool(CapturedSid);

    }

    return;

}

NTSTATUS
SeCaptureAcl (
    __in PACL InputAcl,
    __in KPROCESSOR_MODE RequestorMode,
    __inout_bcount_opt(CaptureBufferLength) PVOID CaptureBuffer,
    __in ULONG CaptureBufferLength,
    __in POOL_TYPE PoolType,
    __in BOOLEAN ForceCapture,
    __deref_out_bcount_full(*AlignedAclSize) PACL *CapturedAcl,
    __out PULONG AlignedAclSize
    )

/*++

Routine Description:

    This routine probes and captures a copy of the specified ACL.
    The ACL is either captured into a provided buffer, or pool
    allocated to receive the ACL.

    Any ACL captured will have its structure validated.


    if the requestor mode is not kernel mode then

        probe and capture the input ACL

    if the requestor mode is kernel mode then

        if force capture is true then

            do not probe the input ACL, but do capture it

        else

            return address of original, but don't copy

Arguments:

    InputAcl - Supplies the ACL to capture.  This parameter is assumed
        to have been provided by the mode specified in RequestorMode.

    RequestorMode - Specifies the caller's access mode.

    CaptureBuffer - Specifies a buffer into which the ACL is to be
        captured.  If this parameter is not provided, pool will be allocated
        to hold the captured data.

    CaptureBufferLength - Indicates the length, in bytes, of the capture
        buffer.

    PoolType - Specifies which pool type to allocate to capture the
        ACL into.  This parameter is ignored if CaptureBuffer is provided.

    ForceCapture - Specifies whether the ACL should be captured even if
        requestor mode is kernel.

    CapturedAcl - Supplies the address of a pointer to an ACL.
        The pointer will be set to point to the captured (or uncaptured) ACL.

    AlignedAclSize - Supplies the address of a ULONG to receive the length
        of the ACL rounded up to the next longword boundary.

Return Value:

    STATUS_SUCCESS indicates the capture was successful.

    STATUS_BUFFER_TOO_SMALL - indicates the buffer provided to capture the ACL
        into wasn't large enough to hold the ACL.

    Any access violations encountered will be returned.

--*/

{

    ULONG AclSize;

    PAGED_CODE();

    //
    //  check if the requestors mode is kernel mode and we are not
    //  to force a capture.
    //

    if ((RequestorMode == KernelMode) && (ForceCapture == FALSE)) {

        //
        //  We don't need to do any work and can simply
        //  return a pointer to the input ACL
        //

        (*CapturedAcl) = InputAcl;

        return STATUS_SUCCESS;
    }


    //
    // Get the length needed to hold the ACL
    //

    if (RequestorMode != KernelMode) {

        try {

            AclSize = ProbeAndReadUshort( &(InputAcl->AclSize) );

            ProbeForRead( InputAcl,
                          AclSize,
                          sizeof(ULONG) );

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

    } else {

        AclSize = InputAcl->AclSize;

    }

    //
    // If the passed pointer is non-null, it has better at least
    // point to a well formed ACL
    //

    if (AclSize < sizeof(ACL)) {
        return( STATUS_INVALID_ACL );
    }

    (*AlignedAclSize) = (ULONG)LongAlignSize( AclSize );


    //
    // If a buffer was provided, compare lengths.
    // Otherwise, allocate a buffer.
    //

    if (ARGUMENT_PRESENT(CaptureBuffer)) {

        if (AclSize > CaptureBufferLength) {
            return STATUS_BUFFER_TOO_SMALL;
        } else {

            (*CapturedAcl) = CaptureBuffer;
        }

    } else {

        (*CapturedAcl) = (PACL)ExAllocatePoolWithTag(PoolType, AclSize, 'cAeS');

        if ( *CapturedAcl == NULL ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }

    }

    //
    // Now copy the ACL and validate it
    //

    try {

        RtlCopyMemory( (*CapturedAcl), InputAcl, AclSize );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        if (!ARGUMENT_PRESENT(CaptureBuffer)) {
            ExFreePool( (*CapturedAcl) );
        }

        *CapturedAcl = NULL;
        return GetExceptionCode();
    }

    if ( (!SepCheckAcl( (*CapturedAcl), AclSize )) ) {

        if (!ARGUMENT_PRESENT(CaptureBuffer)) {
            ExFreePool( (*CapturedAcl) );
        }

        *CapturedAcl = NULL;
        return STATUS_INVALID_ACL;
    }

    return STATUS_SUCCESS;

}

VOID
SeReleaseAcl (
    __in PACL CapturedAcl,
    __in KPROCESSOR_MODE RequestorMode,
    __in BOOLEAN ForceCapture
    )

/*++

Routine Description:

    This routine releases a previously captured ACL.

    This routine should NOT be called if the ACL was captured into a
    provided CaptureBuffer (see SeCaptureAcl).

Arguments:

    CapturedAcl - Supplies the ACL to release.

    RequestorMode - The processor mode specified when the ACL was captured.

    ForceCapture - The ForceCapture value specified when the ACL was
        captured.

Return Value:

    None.

--*/

{
    //
    // We only have something to deallocate if the requestor was user
    // mode or kernel mode requesting ForceCapture.
    //

    PAGED_CODE();

    if ( ((RequestorMode == KernelMode) && (ForceCapture == TRUE)) ||
          (RequestorMode == UserMode ) ) {

        ExFreePool(CapturedAcl);

    }

}

NTSTATUS
SeCaptureLuidAndAttributesArray (
    __in_ecount(ArrayCount) PLUID_AND_ATTRIBUTES InputArray,
    __in ULONG ArrayCount,
    __in KPROCESSOR_MODE RequestorMode,
    __in_bcount_opt(CaptureBufferLength) PVOID CaptureBuffer,
    __in ULONG CaptureBufferLength,
    __in POOL_TYPE PoolType,
    __in BOOLEAN ForceCapture,
    __deref_out_bcount_full(*AlignedArraySize) PLUID_AND_ATTRIBUTES *CapturedArray,
    __out PULONG AlignedArraySize
    )

/*++

Routine Description:

    This routine probes and captures a copy of the specified
    LUID_AND_ATTRIBUTES array.

    The array is either captured into a provided buffer, or pool
    allocated to receive the array.


    if the requestor mode is not kernel mode then

        probe and capture the input array

    if the requestor mode is kernel mode then

        if force capture is true then

            do not probe the input array, but do capture it

        else

            return address of original, but don't copy

Arguments:

    InputArray - Supplies the array to capture.  This parameter is assumed
        to have been provided by the mode specified in RequestorMode.

    ArrayCount - Indicates the number of elements in the array to capture.

    RequestorMode - Specifies the caller's access mode.

    CaptureBuffer - Specifies a buffer into which the array is to be
        captured.  If this parameter is not provided, pool will be allocated
        to hold the captured data.

    CaptureBufferLength - Indicates the length, in bytes, of the capture
        buffer.

    PoolType - Specifies which pool type to allocate to capture the
        array into.  This parameter is ignored if CaptureBuffer is provided.

    ForceCapture - Specifies whether the array should be captured even if
        requestor mode is kernel.

    CapturedArray - Supplies the address of a pointer to an array.
        The pointer will be set to point to the captured (or uncaptured) array.

    AlignedArraySize - Supplies the address of a ULONG to receive the length
        of the array rounded up to the next longword boundary.

Return Value:

    STATUS_SUCCESS indicates the capture was successful.

    STATUS_BUFFER_TOO_SMALL - indicates the buffer provided to capture the array
        into wasn't large enough to hold the array.

    Any access violations encountered will be returned.

--*/

{

    ULONG ArraySize;

    PAGED_CODE();

    //
    // Make sure the array isn't empty
    //

    if (ArrayCount == 0) {
        (*CapturedArray) = NULL;
        (*AlignedArraySize) = 0;
        return STATUS_SUCCESS;
    }

    //
    // If there are too many LUIDs, return failure
    //

    if (ArrayCount > SEP_MAX_PRIVILEGE_COUNT) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    //  check if the requestors mode is kernel mode and we are not
    //  to force a capture.
    //

    if ((RequestorMode == KernelMode) && (ForceCapture == FALSE)) {

        //
        //  We don't need to do any work and can simply
        //  return a pointer to the input array
        //

        (*CapturedArray) = InputArray;

        return STATUS_SUCCESS;
    }


    //
    // Get the length needed to hold the array
    //

    ArraySize = ArrayCount * (ULONG)sizeof(LUID_AND_ATTRIBUTES);
    (*AlignedArraySize) = (ULONG)LongAlignSize( ArraySize );

    if (RequestorMode != KernelMode) {

        try {


            ProbeForRead( InputArray,
                          ArraySize,
                          sizeof(ULONG) );

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

    }



    //
    // If a buffer was provided, compare lengths.
    // Otherwise, allocate a buffer.
    //

    if (ARGUMENT_PRESENT(CaptureBuffer)) {

        if (ArraySize > CaptureBufferLength) {
            return STATUS_BUFFER_TOO_SMALL;
        } else {

            (*CapturedArray) = CaptureBuffer;
        }

    } else {

        (*CapturedArray) =
            (PLUID_AND_ATTRIBUTES)ExAllocatePoolWithTag(PoolType, ArraySize, 'uLeS');

        if ( *CapturedArray == NULL ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }

    }

    //
    // Now copy the array
    //

    try {

        RtlCopyMemory( (*CapturedArray), InputArray, ArraySize );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        if (!ARGUMENT_PRESENT(CaptureBuffer)) {
            ExFreePool( (*CapturedArray) );
        }

        return GetExceptionCode();
    }

    return STATUS_SUCCESS;

}

VOID
SeReleaseLuidAndAttributesArray (
    __in PLUID_AND_ATTRIBUTES CapturedArray,
    __in KPROCESSOR_MODE RequestorMode,
    __in BOOLEAN ForceCapture
    )

/*++

Routine Description:

    This routine releases a previously captured array of LUID_AND_ATTRIBUTES.

    This routine should NOT be called if the array was captured into a
    provided CaptureBuffer (see SeCaptureLuidAndAttributesArray).

Arguments:

    CapturedArray - Supplies the array to release.

    RequestorMode - The processor mode specified when the array was captured.

    ForceCapture - The ForceCapture value specified when the array was
        captured.

Return Value:

    None.

--*/

{
    //
    // We only have something to deallocate if the requestor was user
    // mode or kernel mode requesting ForceCapture.
    //

    PAGED_CODE();

    if ( ((RequestorMode == KernelMode) && (ForceCapture == TRUE)) ||
          (RequestorMode == UserMode )) {
        //
        // the capture routine returns success with a null pointer for zero elements.
        //
        if (CapturedArray != NULL)
           ExFreePool(CapturedArray);

    }

    return;

}

NTSTATUS
SeCaptureSidAndAttributesArray (
    __in_ecount(ArrayCount) PSID_AND_ATTRIBUTES InputArray,
    __in ULONG ArrayCount,
    __in KPROCESSOR_MODE RequestorMode,
    __in_bcount_opt(CaptureBufferLength) PVOID CaptureBuffer,
    __in ULONG CaptureBufferLength,
    __in POOL_TYPE PoolType,
    __in BOOLEAN ForceCapture,
    __deref_out_bcount_full(AlignedArraySize) PSID_AND_ATTRIBUTES *CapturedArray,
    __out PULONG AlignedArraySize
    )

/*++

Routine Description:

    This routine probes and captures a copy of the specified
    SID_AND_ATTRIBUTES array, along with the SID values pointed
    to.

    The array is either captured into a provided buffer, or pool
    allocated to receive the array.

    The format of the captured information is an array of SID_AND_ATTRIBUTES
    data structures followed by the SID values.  THIS MAY NOT BE THE CASE
    FOR KERNEL MODE UNLESS A FORCE CAPTURE IS SPECIFIED.


    if the requestor mode is not kernel mode then

        probe and capture the input array

    if the requestor mode is kernel mode then

        if force capture is true then

            do not probe the input array, but do capture it

        else

            return address of original, but don't copy

Arguments:

    InputArray - Supplies the array to capture.  This parameter is assumed
        to have been provided by the mode specified in RequestorMode.

    ArrayCount - Indicates the number of elements in the array to capture.

    RequestorMode - Specifies the caller's access mode.

    CaptureBuffer - Specifies a buffer into which the array is to be
        captured.  If this parameter is not provided, pool will be allocated
        to hold the captured data.

    CaptureBufferLength - Indicates the length, in bytes, of the capture
        buffer.

    PoolType - Specifies which pool type to allocate to capture the
        array into.  This parameter is ignored if CaptureBuffer is provided.

    ForceCapture - Specifies whether the array should be captured even if
        requestor mode is kernel.

    CapturedArray - Supplies the address of a pointer to an array.
        The pointer will be set to point to the captured (or uncaptured) array.

    AlignedArraySize - Supplies the address of a ULONG to receive the length
        of the array rounded up to the next longword boundary.

Return Value:

    STATUS_SUCCESS indicates the capture was successful.

    STATUS_BUFFER_TOO_SMALL - indicates the buffer provided to capture the array
        into wasn't large enough to hold the array.

    Any access violations encountered will be returned.

--*/

{

typedef struct _TEMP_ARRAY_ELEMENT {
    PISID  Sid;
    ULONG SidLength;
} TEMP_ARRAY_ELEMENT;


    TEMP_ARRAY_ELEMENT *TempArray = NULL;

    NTSTATUS CompletionStatus = STATUS_SUCCESS;

    ULONG ArraySize;
    ULONG AlignedLengthRequired;

    ULONG NextIndex;

    PSID_AND_ATTRIBUTES NextElement;
    PVOID NextBufferLocation;

    ULONG GetSidSubAuthorityCount;
    ULONG SidSize;
    ULONG AlignedSidSize;

    PAGED_CODE();

    //
    // Make sure the array isn't empty
    //

    if (ArrayCount == 0) {
        (*CapturedArray) = NULL;
        (*AlignedArraySize) = 0;
        return STATUS_SUCCESS;
    }

    //
    // Check there aren't too many SIDs
    //

    if (ArrayCount > SEP_MAX_GROUP_COUNT) {
        return(STATUS_INVALID_PARAMETER);
    }
    //
    //  check if the requestor's mode is kernel mode and we are not
    //  to force a capture.
    //

    if ((RequestorMode == KernelMode) && (ForceCapture == FALSE)) {

        //
        //  We don't need to do any work and can simply
        //  return a pointer to the input array
        //

        (*CapturedArray) = InputArray;

        return STATUS_SUCCESS;
    }


    //
    // ---------- For RequestorMode == UserMode ----------------------
    //
    // the algorithm for capturing an SID_AND_ATTRIBUTES array is somewhat
    // convoluted to avoid problems that could occur if the data is
    // being changed while being captured.
    //
    // The algorithm uses two loops.
    //
    //    Allocate a temporary buffer to house the fixed length data.
    //
    //    1st loop:
    //          For each SID:
    //              Capture the Pointers to the SID and the length of the SID.
    //
    //    Allocate a buffer large enough to hold all of the data.
    //
    //    2nd loop:
    //          For each SID:
    //               Capture the Attributes.
    //               Capture the SID.
    //               Set the pointer to the SID.
    //
    //    Deallocate temporary buffer.
    //
    // ------------ For RequestorMode == KernelMode --------------------
    //
    // There is no need to capture the length and address of the SIDs
    // in the first loop (since the kernel can be trusted not to change
    // them while they are being copied.)  So for kernel mode, the first
    // loop just adds up the length needed.  Kernel mode, thus, avoids
    // having to allocate a temporary buffer.
    //

    //
    // Get the length needed to hold the array elements.
    //

    ArraySize = ArrayCount * (ULONG)sizeof(TEMP_ARRAY_ELEMENT);
    AlignedLengthRequired = (ULONG)LongAlignSize( ArraySize );

    if (RequestorMode != KernelMode) {

        //
        // Allocate a temporary array to capture the array elements into
        //

        TempArray =
            (TEMP_ARRAY_ELEMENT *)ExAllocatePoolWithTag(PoolType, AlignedLengthRequired, 'aTeS');

        if ( TempArray == NULL ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }


        try {

            //
            // Make sure we can read each SID_AND_ATTRIBUTE
            //

            ProbeForRead( InputArray,
                          ArraySize,
                          sizeof(ULONG) );

            //
            // Probe and capture the length and address of each SID
            //

            NextIndex = 0;
            while (NextIndex < ArrayCount) {
                PSID TempSid;

                TempSid = InputArray[NextIndex].Sid;
                GetSidSubAuthorityCount =
                    ProbeAndReadUchar( &((PISID)TempSid)->SubAuthorityCount);

                if (GetSidSubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                    CompletionStatus = STATUS_INVALID_SID;
                    break;
                }

                TempArray[NextIndex].Sid = ((PISID)(TempSid));
                TempArray[NextIndex].SidLength =
                    RtlLengthRequiredSid( GetSidSubAuthorityCount );

                ProbeForRead( TempArray[NextIndex].Sid,
                              TempArray[NextIndex].SidLength,
                              sizeof(ULONG) );

                AlignedLengthRequired +=
                    (ULONG)LongAlignSize( TempArray[NextIndex].SidLength );

                NextIndex += 1;

            }  //end while

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ExFreePool( TempArray );
            return GetExceptionCode();
        }

        if (!NT_SUCCESS(CompletionStatus)) {
            ExFreePool( TempArray );
            return(CompletionStatus);
        }

    } else {

        //
        // No need to capture anything.
        // But, we do need to add up the lengths of the SIDs
        // so we can allocate a buffer (or check the size of one provided).
        //

        NextIndex = 0;

        while (NextIndex < ArrayCount) {

            GetSidSubAuthorityCount =
                ((PISID)(InputArray[NextIndex].Sid))->SubAuthorityCount;

            AlignedLengthRequired +=
                (ULONG)LongAlignSize(RtlLengthRequiredSid(GetSidSubAuthorityCount));

            NextIndex += 1;

        }  //end while

    }


    //
    // Now we know how much memory we need.
    // Return this value in the output parameter.
    //

    (*AlignedArraySize) = AlignedLengthRequired;

    //
    // If a buffer was provided, make sure it is long enough.
    // Otherwise, allocate a buffer.
    //

    if (ARGUMENT_PRESENT(CaptureBuffer)) {

        if (AlignedLengthRequired > CaptureBufferLength) {

            if (RequestorMode != KernelMode) {
                ExFreePool( TempArray );
            }

            return STATUS_BUFFER_TOO_SMALL;

        } else {

            (*CapturedArray) = CaptureBuffer;
        }

    } else {

        (*CapturedArray) =
            (PSID_AND_ATTRIBUTES)ExAllocatePoolWithTag(PoolType, AlignedLengthRequired, 'aSeS');

        if ( *CapturedArray == NULL ) {
                if (RequestorMode != KernelMode) {
                    ExFreePool( TempArray );
                }
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
    }


    //
    // Now copy everything.
    // This is done by copying all the SID_AND_ATTRIBUTES and then
    // copying each individual SID.
    //
    // All SIDs have already been probed for READ access.  We just
    // need to copy them.
    //
    //

    if (RequestorMode != KernelMode) {
        try {

            //
            //  Copy the SID_AND_ATTRIBUTES array elements
            //  This really only sets the attributes, since we
            //  over-write the SID pointer field later on.
            //

            NextBufferLocation = (*CapturedArray);
            RtlCopyMemory( NextBufferLocation, InputArray, ArraySize );
            NextBufferLocation = (PVOID)((ULONG_PTR)NextBufferLocation +
                                         (ULONG)LongAlignSize(ArraySize) );

            //
            //  Now go through and copy each referenced SID.
            //  Validate each SID as it is copied.
            //

            NextIndex = 0;
            NextElement = (*CapturedArray);
            while (  (NextIndex < ArrayCount) &&
                     (CompletionStatus == STATUS_SUCCESS) ) {


                RtlCopyMemory( NextBufferLocation,
                    TempArray[NextIndex].Sid,
                    TempArray[NextIndex].SidLength );


                NextElement[NextIndex].Sid = (PSID)NextBufferLocation;
                NextBufferLocation =
                    (PVOID)((ULONG_PTR)NextBufferLocation +
                            (ULONG)LongAlignSize(TempArray[NextIndex].SidLength));

                //
                // Verify the sid is valid and its length didn't change
                //

                if (!RtlValidSid(NextElement[NextIndex].Sid) ) {
                    CompletionStatus = STATUS_INVALID_SID;
                } else if (RtlLengthSid(NextElement[NextIndex].Sid) != TempArray[NextIndex].SidLength) {
                    CompletionStatus = STATUS_INVALID_SID;
                }


                NextIndex += 1;

            }  //end while


        } except(EXCEPTION_EXECUTE_HANDLER) {

            if (!ARGUMENT_PRESENT(CaptureBuffer)) {
                ExFreePool( (*CapturedArray) );
            }

            ExFreePool( TempArray );

            return GetExceptionCode();
        }
    } else {

        //
        // Requestor mode is kernel mode -
        // don't need protection, probing, and validating
        //

        //
        //  Copy the SID_AND_ATTRIBUTES array elements
        //  This really only sets the attributes, since we
        //  over-write the SID pointer field later on.
        //

        NextBufferLocation = (*CapturedArray);
        RtlCopyMemory( NextBufferLocation, InputArray, ArraySize );
        NextBufferLocation = (PVOID)( (ULONG_PTR)NextBufferLocation +
                                      (ULONG)LongAlignSize(ArraySize));

        //
        //  Now go through and copy each referenced SID
        //

        NextIndex = 0;
        NextElement = (*CapturedArray);
        while (NextIndex < ArrayCount) {

            GetSidSubAuthorityCount =
                ((PISID)(NextElement[NextIndex].Sid))->SubAuthorityCount;

            RtlCopyMemory(
                NextBufferLocation,
                NextElement[NextIndex].Sid,
                RtlLengthRequiredSid(GetSidSubAuthorityCount) );
                SidSize = RtlLengthRequiredSid( GetSidSubAuthorityCount );
                AlignedSidSize = (ULONG)LongAlignSize(SidSize);

            NextElement[NextIndex].Sid = (PSID)NextBufferLocation;

            NextIndex += 1;
            NextBufferLocation = (PVOID)((ULONG_PTR)NextBufferLocation +
                                                   AlignedSidSize);

        }  //end while

    }

    if (RequestorMode != KernelMode) {
        ExFreePool( TempArray );
    }

    if (!ARGUMENT_PRESENT(CaptureBuffer) && !NT_SUCCESS(CompletionStatus)) {
        ExFreePool( (*CapturedArray) );
        *CapturedArray = NULL ;
    }

    return CompletionStatus;
}

VOID
SeReleaseSidAndAttributesArray (
    __in PSID_AND_ATTRIBUTES CapturedArray,
    __in KPROCESSOR_MODE RequestorMode,
    __in BOOLEAN ForceCapture
    )

/*++

Routine Description:

    This routine releases a previously captured array of SID_AND_ATTRIBUTES.

    This routine should NOT be called if the array was captured into a
    provided CaptureBuffer (see SeCaptureSidAndAttributesArray).

Arguments:

    CapturedArray - Supplies the array to release.

    RequestorMode - The processor mode specified when the array was captured.

    ForceCapture - The ForceCapture value specified when the array was
        captured.

Return Value:

    None.

--*/

{
    //
    // We only have something to deallocate if the requestor was user
    // mode or kernel mode requesting ForceCapture.
    //

    PAGED_CODE();

    if ( ((RequestorMode == KernelMode) && (ForceCapture == TRUE)) ||
          (RequestorMode == UserMode ) ) {

        ExFreePool(CapturedArray);

    }

    return;

}

NTSTATUS
SeCaptureAuditPolicy(
    __in PTOKEN_AUDIT_POLICY Policy,
    __in KPROCESSOR_MODE RequestorMode,
    __in_bcount_opt(CaptureBufferLength) PVOID CaptureBuffer,
    __in_opt ULONG CaptureBufferLength,
    __in POOL_TYPE PoolType,
    __in BOOLEAN ForceCapture,
    __deref_out PTOKEN_AUDIT_POLICY *CapturedPolicy
    )

/*++

Routine Description

    This routine probes and captures a copy of the specified
    TOKEN_AUDIT_POLICY.

    It is either captured into a provided buffer, or pool
    allocated to receive the policy.

    if the requestor mode is not kernel mode then

        probe and capture the input 

    if the requestor mode is kernel mode then

        if force capture is true then

            do not probe the input, but do capture it

        else

            return address of original, but don't copy

Arguments:

    RequestorMode - Specifies the caller's access mode.

    CaptureBuffer - Specifies a buffer into which the policy is to be
        captured.  If this parameter is not provided, pool will be allocated
        to hold the captured data.

    CaptureBufferLength - Indicates the length, in bytes, of the capture
        buffer.

    PoolType - Specifies which pool type to allocate to capture the
        input into.  This parameter is ignored if CaptureBuffer is provided.

    ForceCapture - Specifies whether the policy should be captured even if
        requestor mode is kernel.

    CapturedPolicy - Supplies the address of a pointer to a TOKEN_AUDIT_POLICY.
        The pointer will be set to point to the captured (or uncaptured) policy.

Return Value:

    STATUS_SUCCESS indicates the capture was successful.

    STATUS_BUFFER_TOO_SMALL - indicates the buffer provided to capture the policy
        into wasn't large enough.

    Any access violations encountered will be returned.

--*/

{
    ULONG PolicyCount;
    ULONG PolicySize;
    ULONG i;

    PAGED_CODE();

    //
    //  check if the requestors mode is kernel mode and we are not
    //  to force a capture.
    //

    if ((RequestorMode == KernelMode) && (ForceCapture == FALSE)) {

        //
        //  We don't need to do any work and can simply
        //  return a pointer to the input policy
        //

        (*CapturedPolicy) = Policy;

        return STATUS_SUCCESS;
    }

    //
    // Get the length needed to hold the policy
    //

    if (RequestorMode != KernelMode) {

        try {

            PolicyCount = ProbeAndReadLong( &Policy->PolicyCount );
            PolicySize  = PER_USER_AUDITING_POLICY_SIZE_BY_COUNT(PolicyCount);

            ProbeForRead( 
                Policy,
                PolicySize,
                sizeof(ULONG) 
                );

        } except(EXCEPTION_EXECUTE_HANDLER) {

              return GetExceptionCode();
        }

    } else {

        PolicyCount = Policy->PolicyCount;
        PolicySize  = PER_USER_AUDITING_POLICY_SIZE_BY_COUNT(PolicyCount);
    }


    //
    // If a buffer was provided, compare lengths.
    // Otherwise, allocate a buffer.
    //

    if (ARGUMENT_PRESENT( CaptureBuffer )) {

        if (PolicySize > CaptureBufferLength) {
            
            return STATUS_BUFFER_TOO_SMALL;
        
        } else {

            (*CapturedPolicy) = CaptureBuffer;
        }

    } else {

        (*CapturedPolicy) = (PTOKEN_AUDIT_POLICY)ExAllocatePoolWithTag(PoolType, PolicySize, 'aPeS');

        if ( (*CapturedPolicy) == NULL ) {
            
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
    }

    //
    // Now copy the Policy and validate it
    //

    try {

        RtlCopyMemory( (*CapturedPolicy), Policy, PolicySize );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        
        if (!ARGUMENT_PRESENT(CaptureBuffer)) {
            
            ExFreePool( (*CapturedPolicy) );
            *CapturedPolicy = NULL;
        }

        return GetExceptionCode();

    }

    //
    // Validate captured structure.
    //

    for (i = 0; i < PolicyCount; i++) {

        if (!VALID_TOKEN_AUDIT_POLICY_ELEMENT( (*CapturedPolicy)->Policy[i] )) {
#if DBG
            DbgPrint("SeCaptureAuditPolicy: element %d mask 0x%x category %d invalid.\n", 
                i,
                (*CapturedPolicy)->Policy[i].PolicyMask, 
                (*CapturedPolicy)->Policy[i].Category
                );
            ASSERT(FALSE);
#endif
            if (!ARGUMENT_PRESENT(CaptureBuffer)) {
                
                ExFreePool( (*CapturedPolicy) );
                *CapturedPolicy = NULL;
            }

            return STATUS_INVALID_PARAMETER;
        }
    }

    return STATUS_SUCCESS;
}

VOID
SeReleaseAuditPolicy (
    __in PTOKEN_AUDIT_POLICY CapturedPolicy,
    __in KPROCESSOR_MODE RequestorMode,
    __in BOOLEAN ForceCapture
    )

/*++

Routine Description:

    This routine releases a previously captured TOKEN_AUDIT_POLICY.

    This routine should NOT be called if the policy was captured into a
    provided CaptureBuffer (see SeCaptureAuditPolicy).

Arguments:

    CapturedPolicy - Supplies the policy to release.

    RequestorMode - The processor mode specified when the data was captured.

    ForceCapture - The ForceCapture value specified when the data was
        captured.

Return Value:

    None.

--*/

{
    //
    // We only have something to deallocate if the requestor was user
    // mode or kernel mode requesting ForceCapture.
    //

    PAGED_CODE();

    if ( CapturedPolicy && 
         (((RequestorMode == KernelMode) && (ForceCapture == TRUE)) || (RequestorMode == UserMode)) ) {

        ExFreePool(CapturedPolicy);

    }
}
                
NTSTATUS
SeComputeQuotaInformationSize(
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __out PULONG Size
    )

/*++

Routine Description:

    This routine computes the size of the Group and DACL for the
    passed security descriptor.

    This quantity will later be used in calculating the amount
    of quota to charge for this object.

Arguments:

    SecurityDescriptor - Supplies a pointer to the security descriptor
        to be examined.

    Size - Returns the size in bytes of the sum of the Group and Dacl
        fields of the security descriptor.

Return Value:

    STATUS_SUCCESS - The operation was successful.

    STATUS_INVALID_REVISION - The passed security descriptor was of
        an unknown revision.

--*/

{
    PISECURITY_DESCRIPTOR ISecurityDescriptor;

    PSID Group;
    PACL Dacl;

    PAGED_CODE();

    ISecurityDescriptor = (PISECURITY_DESCRIPTOR)SecurityDescriptor;
    *Size = 0;

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return( STATUS_UNKNOWN_REVISION );
    }

    Group = RtlpGroupAddrSecurityDescriptor( ISecurityDescriptor );

    Dacl = RtlpDaclAddrSecurityDescriptor( ISecurityDescriptor );

    if (Group != NULL) {
        *Size += (ULONG)LongAlignSize(SeLengthSid( Group ));
    }

    if (Dacl != NULL) {
        *Size += (ULONG)LongAlignSize(Dacl->AclSize);
    }

    return( STATUS_SUCCESS );
}

BOOLEAN
SeValidSecurityDescriptor(
    __in ULONG Length,
    __in_bcount(Length) PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    Validates a security descriptor for structural correctness.  The idea is to make
    sure that the security descriptor may be passed to other kernel callers, without
    fear that they're going to choke while manipulating it.

    This routine does not enforce policy (e.g., ACL/ACE revision information).  It is
    entirely possible for a security descriptor to be approved by this routine, only
    to be later found to be invalid by some later routine.

    This routine is designed to be used by callers who have a security descriptor in
    kernel memory.  Callers wishing to validate a security descriptor passed from user
    mode should call RtlValidSecurityDescriptor.

Arguments:

    Length - Length in bytes of passed Security Descriptor.

    SecurityDescriptor - Points to the Security Descriptor (in kernel memory) to be
        validatated.

Return Value:

    TRUE - The passed security descriptor is correctly structured
    FALSE - The passed security descriptor is badly formed

--*/

{
    PISECURITY_DESCRIPTOR_RELATIVE ISecurityDescriptor =
        (PISECURITY_DESCRIPTOR_RELATIVE)SecurityDescriptor;
    PISID OwnerSid;
    PISID GroupSid;
    PACE_HEADER Ace;
    PISID Sid;
    PISID Sid2;
    PACL Dacl;
    PACL Sacl;
    ULONG i;

    PAGED_CODE();

    if (Length < sizeof(SECURITY_DESCRIPTOR_RELATIVE)) {
        return(FALSE);
    }

    //
    // Check the revision information.
    //

    if (ISecurityDescriptor->Revision != SECURITY_DESCRIPTOR_REVISION) {
        return(FALSE);
    }

    //
    // Make sure the passed SecurityDescriptor is in self-relative form
    //

    if (!(ISecurityDescriptor->Control & SE_SELF_RELATIVE)) {
        return(FALSE);
    }

    //
    // Check the owner.  A valid SecurityDescriptor must have an owner.
    // It must also be long aligned.
    //

    if ((ISecurityDescriptor->Owner == 0) ||
        (!LongAligned((PVOID)(ULONG_PTR)(ULONG)ISecurityDescriptor->Owner)) ||
        (ISecurityDescriptor->Owner > Length) ||
        (Length - ISecurityDescriptor->Owner < sizeof(SID))) {

        return(FALSE);
    }

    //
    // It is safe to reference the owner's SubAuthorityCount, compute the
    // expected length of the SID
    //

    OwnerSid = (PSID)RtlOffsetToPointer( ISecurityDescriptor, ISecurityDescriptor->Owner );

    if (OwnerSid->Revision != SID_REVISION) {
        return(FALSE);
    }

    if (OwnerSid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
        return(FALSE);
    }

    if (Length - ISecurityDescriptor->Owner < (ULONG) SeLengthSid(OwnerSid)) {
        return(FALSE);
    }

    //
    // The owner appears to be a structurally valid SID that lies within
    // the bounds of the security descriptor.  Do the same for the Group
    // if there is one.
    //

    if (ISecurityDescriptor->Group != 0) {

        //
        // Check alignment
        //

        if (!LongAligned( (PVOID)(ULONG_PTR)(ULONG)ISecurityDescriptor->Group)) {
            return(FALSE);
        }

        if (ISecurityDescriptor->Group > Length) {
            return(FALSE);
        }

        if (Length - ISecurityDescriptor->Group < sizeof (SID)) {
            return(FALSE);
        }

        //
        // It is safe to reference the Group's SubAuthorityCount, compute the
        // expected length of the SID
        //

        GroupSid = (PSID)RtlOffsetToPointer( ISecurityDescriptor, ISecurityDescriptor->Group );

        if (GroupSid->Revision != SID_REVISION) {
            return(FALSE);
        }

        if (GroupSid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
            return(FALSE);
        }

        if (Length - ISecurityDescriptor->Group < (ULONG) SeLengthSid(GroupSid)) {
            return(FALSE);
        }
    }

    //
    // Validate the DACL.  A structurally valid SecurityDescriptor may not necessarily
    // have a DACL.
    //

    if (ISecurityDescriptor->Dacl != 0) {

        //
        // Check alignment
        //

        if (!LongAligned( (PVOID)(ULONG_PTR)(ULONG)ISecurityDescriptor->Dacl)) {
            return(FALSE);
        }

        //
        // Make sure the DACL structure is within the bounds of the security descriptor.
        //

        if ((ISecurityDescriptor->Dacl > Length) ||
            (Length - ISecurityDescriptor->Dacl < sizeof(ACL))) {
            return(FALSE);
        }

        Dacl = (PACL) RtlOffsetToPointer( ISecurityDescriptor, ISecurityDescriptor->Dacl );


        //
        // Make sure the DACL length fits within the bounds of the security descriptor.
        //

        if (Length - ISecurityDescriptor->Dacl < Dacl->AclSize) {
            return(FALSE);
        }

        //
        // Make sure the ACL is structurally valid.
        //

        if (!RtlValidAcl( Dacl )) {
            return(FALSE);
        }
    }

    //
    // Validate the SACL.  A structurally valid SecurityDescriptor may not
    // have a SACL.
    //

    if (ISecurityDescriptor->Sacl != 0) {

        //
        // Check alignment
        //

        if (!LongAligned( (PVOID)(ULONG_PTR)(ULONG)ISecurityDescriptor->Sacl)) {
            return(FALSE);
        }

        //
        // Make sure the SACL structure is within the bounds of the security descriptor.
        //

        if ((ISecurityDescriptor->Sacl > Length) ||
            (Length - ISecurityDescriptor->Sacl < sizeof(ACL))) {
            return(FALSE);
        }

        //
        // Make sure the Sacl structure is within the bounds of the security descriptor.
        //

        Sacl = (PACL)RtlOffsetToPointer( ISecurityDescriptor, ISecurityDescriptor->Sacl );


        if (Length - ISecurityDescriptor->Sacl < Sacl->AclSize) {
            return(FALSE);
        }

        //
        // Make sure the ACL is structurally valid.
        //

        if (!RtlValidAcl( Sacl )) {
            return(FALSE);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\rmaudit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    rmaudit.c

Abstract:

   This module contains the Reference Monitor Auditing Command Workers.
   These workers call functions in the Auditing sub-component to do the real
   work.

--*/

#include "pch.h"

#pragma hdrstop

VOID
SepRmSetAuditLogWrkr(
    IN PRM_COMMAND_MESSAGE CommandMessage,
    OUT PRM_REPLY_MESSAGE ReplyMessage
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SepRmSetAuditEventWrkr)
#endif



VOID
SepRmSetAuditEventWrkr(
    IN PRM_COMMAND_MESSAGE CommandMessage,
    OUT PRM_REPLY_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    This function carries out the Reference Monitor Set Audit Event
    Command.  This command enables or disables auditing and optionally
    sets the auditing events.


Arguments:

    CommandMessage - Pointer to structure containing RM command message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command number (RmSetAuditStateCommand) and a single command
        parameter in structure form.

    ReplyMessage - Pointer to structure containing RM reply message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command ReturnedStatus field in which a status code from the
        command will be returned.

Return Value:

    VOID

--*/

{

    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
    POLICY_AUDIT_EVENT_TYPE EventType;

    PAGED_CODE();

    SepAdtInitializeBounds();

    ReplyMessage->ReturnedStatus = STATUS_SUCCESS;

    //
    // Strict check that command is correct one for this worker.
    //

    ASSERT( CommandMessage->CommandNumber == RmAuditSetCommand );

    //
    // Extract the AuditingMode flag and put it in the right place.
    //

    SepAdtAuditingEnabled = (((PLSARM_POLICY_AUDIT_EVENTS_INFO) CommandMessage->CommandParams)->
                                AuditingMode);

    //
    // For each element in the passed array, process changes to audit
    // nothing, and then success or failure flags.
    //

    EventAuditingOptions = ((PLSARM_POLICY_AUDIT_EVENTS_INFO) CommandMessage->CommandParams)->
                           EventAuditingOptions;


    for ( EventType=AuditEventMinType;
          EventType <= AuditEventMaxType;
          EventType++ ) {

        SeAuditingState[EventType].AuditOnSuccess = FALSE;
        SeAuditingState[EventType].AuditOnFailure = FALSE;

        if ( EventAuditingOptions[EventType] & POLICY_AUDIT_EVENT_SUCCESS ) {

            SeAuditingState[EventType].AuditOnSuccess = TRUE;
        }

        if ( EventAuditingOptions[EventType] & POLICY_AUDIT_EVENT_FAILURE ) {

            SeAuditingState[EventType].AuditOnFailure = TRUE;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\rmlogon.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    rmlogon.c

Abstract:

    This module implements the kernel mode logon tracking performed by the
    reference monitor.  Logon tracking is performed by keeping a count of
    how many tokens exist for each active logon in a system.  When a logon
    session's reference count drops to zero, the LSA is notified so that
    authentication packages can clean up any related context data.

--*/

#include "pch.h"

#pragma hdrstop

#include "rmp.h"
#include <bugcodes.h>
#include <stdio.h>
#include <zwapi.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

SEP_LOGON_SESSION_TERMINATED_NOTIFICATION
SeFileSystemNotifyRoutinesHead = {0};


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Internally defined data types                                          //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

typedef struct _SEP_FILE_SYSTEM_NOTIFY_CONTEXT {
    WORK_QUEUE_ITEM WorkItem;
    LUID LogonId;
} SEP_FILE_SYSTEM_NOTIFY_CONTEXT, *PSEP_FILE_SYSTEM_NOTIFY_CONTEXT;


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Internally defined routines                                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


VOID
SepInformLsaOfDeletedLogon(
    IN PLUID LogonId
    );

VOID
SepInformFileSystemsOfDeletedLogon(
    IN PLUID LogonId
    );

VOID
SepNotifyFileSystems(
    IN PVOID Context
    );

NTSTATUS
SepCleanupLUIDDeviceMapDirectory(
    PLUID pLogonId
    );

NTSTATUS
SeGetLogonIdDeviceMap(
    IN PLUID pLogonId,
    OUT PDEVICE_MAP* ppDevMap
    );

//
// declared in ntos\ob\obp.h
// defined in ntos\ob\obdir.c
// Used to dereference the LUID device map
//
VOID
FASTCALL
ObfDereferenceDeviceMap(
    IN PDEVICE_MAP DeviceMap
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SepRmCreateLogonSessionWrkr)
#pragma alloc_text(PAGE,SepRmDeleteLogonSessionWrkr)
#pragma alloc_text(PAGE,SepReferenceLogonSession)
#pragma alloc_text(PAGE,SepCleanupLUIDDeviceMapDirectory)
#pragma alloc_text(PAGE,SepDeReferenceLogonSession)
#pragma alloc_text(PAGE,SepCreateLogonSessionTrack)
#pragma alloc_text(PAGE,SepDeleteLogonSessionTrack)
#pragma alloc_text(PAGE,SepInformLsaOfDeletedLogon)
#pragma alloc_text(PAGE,SeRegisterLogonSessionTerminatedRoutine)
#pragma alloc_text(PAGE,SeUnregisterLogonSessionTerminatedRoutine)
#pragma alloc_text(PAGE,SeMarkLogonSessionForTerminationNotification)
#pragma alloc_text(PAGE,SepInformFileSystemsOfD