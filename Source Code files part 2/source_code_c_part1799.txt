 iBlkMax 16

#define MaskBomb  0x80
#define MaskVisit 0x40
#define MaskFlags 0xE0
#define MaskData  0x1F

#define NOTMaskBomb 0x7F

#define cBlkMax (27*32)


/* Leds */

#define iLed0         0
#define iLed1         1
#define iLed9         9
#define iLedBlank    10
#define iLedNegative 11

#define iLedMax 12


/* Buttons */

#define iButtonHappy   0
#define iButtonCaution 1
#define iButtonLose    2
#define iButtonWin     3
#define iButtonDown    4

#define iButtonMax 5



#define wGameBegin  0
#define wGameInter  1
#define wGameExpert 2
#define wGameOther  3



/*** Macros ***/

#define fInRange(x,y)   (((x)>0) && ((y)>0) && ((x)<=xBoxMac) && ((y)<=yBoxMac))

#define IBLK(x,y)    (rgBlk[ ((y)<<5) + (x)])
#define iBLK(x,y)    ( (IBLK(x,y) & MaskData) )

#define SetBorder(x,y) (IBLK(x,y) =  iBlkMax)
#define fBORDER(x,y)   (IBLK(x,y) == iBlkMax)

#define SetBomb(x,y)   (IBLK(x,y) |= MaskBomb)
#define ClearBomb(x,y) (IBLK(x,y) &= NOTMaskBomb)
#define fISBOMB(x,y)   ((IBLK(x,y) & MaskBomb) != 0)

#define SetVisit(x,y)  (IBLK(x,y) |= MaskVisit)
#define fVISIT(x,y)    ((IBLK(x,y) & MaskVisit) != 0)

#define fGUESSBOMB(x,y)  (iBLK(x,y) == iBlkBombUp)
#define fGUESSMARK(x,y)  (iBLK(x,y) == iBlkGuessUp)
#define SetBlk(x,y,blk)  (IBLK(x,y) = (char) ((IBLK(x,y) & MaskFlags) | blk))


/*** Status Stuff ***/

#define fPlay      0x01		/* ON if playing game, OFF if game over */
#define fPause     0x02		/* ON if paused */
#define fPanic     0x04		/* ON if panic  */
#define fIcon      0x08    /* ON if iconic */
#define fDemo      0x10		/* ON if demo   */

#define fStatusIcon    (fStatus & fIcon)
#define fStatusPlay    (fStatus & fPlay)
#define fStatusPanic   (fStatus & fPanic)
#define fStatusPause   (fStatus & fPause)
#define fStatusDemo    (fStatus & fDemo)

#define SetStatusPlay  (fStatus = fPlay)
#define SetStatusPause (fStatus |= fPause)
#define SetStatusPanic (fStatus |= fPanic)
#define SetStatusIcon  (fStatus |= fIcon)
#define SetStatusDemo  (fStatus = fDemo)

#define ClrStatusPlay  (fStatus &= 0xFE)
#define ClrStatusPause (fStatus &= 0xFD)
#define ClrStatusPanic (fStatus &= 0xFB)
#define ClrStatusIcon  (fStatus &= 0xF7)
#define ClrStatusDemo  (fStatus &= 0xEF)

#define fLose  fFalse
#define fWin   fTrue


typedef INT BLK;



/*** Routines ***/

VOID StartGame(VOID);
VOID StopGame(VOID);
VOID DoTimer(VOID);

VOID TrackMouse(INT, INT);
VOID DoButton1Up(VOID);
VOID MakeGuess(INT, INT);

VOID PauseGame(VOID);
VOID ResumeGame(VOID);
VOID ClearField(VOID);

VOID CalcFrameRect(VOID);
VOID UpdateBombCount(INT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\rtns.c ===
/**********/
/* mine.c */
/**********/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "res.h"
#include "main.h"
#include "rtns.h"
#include "util.h"
#include "grafix.h"
#include "sound.h"
#include "pref.h"


/*** External Data ***/

extern HWND   hwndMain;

/*** Global/Local Variables ***/


PREF    Preferences;

INT     xBoxMac;                        /* Current width of field        */
INT     yBoxMac;                        /* Current height of field       */

INT     dxWindow;               /* current width of window */
INT     dyWindow;

INT wGameType;          /* Type of game */
INT iButtonCur = iButtonHappy;

INT     cBombStart;             /* Count of bombs in field       */
INT     cBombLeft;              /* Count of bomb locations left  */
INT     cBoxVisit;              /* Count of boxes visited        */
INT     cBoxVisitMac;   /* count of boxes need to visit */

INT     cSec;                           /* Count of seconds remaining    */


BOOL  fTimer = fFalse;
BOOL  fOldTimerStatus = fFalse;

INT     xCur = -1;      /* Current position of down box */
INT     yCur = -1;

CHAR rgBlk[cBlkMax];


#define iStepMax 100

INT rgStepX[iStepMax];
INT rgStepY[iStepMax];

INT iStepMac;



/*** Global/External Variables ***/

extern BOOL fBlock;


extern INT fStatus;




/****** F  C H E C K  W I N ******/

/* Return TRUE if player won the game */

#if 0

BOOL fCheckWin(VOID)
{
        if (cBombLeft)
                return (fFalse);
        else
                return ((cBoxVisit + cBombStart) == (xBoxMac*yBoxMac));

}

#else

#define fCheckWin()     (cBoxVisit == cBoxVisitMac)

#endif



/****** C H A N G E  B L K ******/

VOID ChangeBlk(INT x, INT y, INT iBlk)
{

        SetBlk(x,y, iBlk);

        DisplayBlk(x,y);
}


/****** C L E A R  F I E L D ******/

VOID ClearField(VOID)
{
        REGISTER i;

        for (i = cBlkMax; i-- != 0; )                   /* zero all of data */
                rgBlk[i] = (CHAR) iBlkBlankUp;

        for (i = xBoxMac+2; i-- != 0; ) /* initialize border */
                {
                SetBorder(i,0);
                SetBorder(i,yBoxMac+1);
                }
        for (i = yBoxMac+2; i-- != 0;)
                {
                SetBorder(0,i);
                SetBorder(xBoxMac+1,i);
                }
}



/******* C O U N T  B O M B S *******/

/* Count the bombs surrounding the point */

INT CountBombs(INT xCenter, INT yCenter)
{
        REGISTER INT    x;
        REGISTER INT    y;
        INT     cBombs = 0;

        for(y = yCenter-1; y <= yCenter+1; y++)
                for(x = xCenter-1; x <= xCenter+1; x++)
                        if(fISBOMB(x,y))
                                cBombs++;

        return(cBombs);
}


/****** S H O W  B O M B S ******/

/* Display hidden bombs and wrong bomb guesses */

VOID ShowBombs(INT iBlk)
{
        REGISTER INT    x;
        REGISTER INT    y;

        for(y = 1; y <= yBoxMac; y++)
                {
                for(x = 1; x <= xBoxMac; x++)
                        {
                        if (!fVISIT(x,y))
                                {
                                if (fISBOMB(x,y))
                                        {
                                        if (!fGUESSBOMB(x,y) )
                                                SetBlk(x,y, iBlk);
                                        }
                                else if (fGUESSBOMB(x,y))
                                        SetBlk(x,y, iBlkWrong);
                                }
                        }
                }

        DisplayGrid();
}



/****** G A M E  O V E R ******/

VOID GameOver(BOOL fWinLose)
{
        fTimer = fFalse;
        DisplayButton(iButtonCur = fWinLose ? iButtonWin : iButtonLose);
        ShowBombs(fWinLose ? iBlkBombUp : iBlkBombDn);
        if (fWinLose && (cBombLeft != 0))
                UpdateBombCount(-cBombLeft);
        PlayTune(fWinLose ? TUNE_WINGAME : TUNE_LOSEGAME);
        SetStatusDemo;

        if (fWinLose && (Preferences.wGameType != wGameOther)
                && (cSec < Preferences.rgTime[Preferences.wGameType]))
                {
                Preferences.rgTime[Preferences.wGameType] = cSec;
                DoEnterName();
                DoDisplayBest();
                }
}


/****** D O  T I M E R ******/

VOID DoTimer(VOID)
{
        if (fTimer && (cSec < 999))
                {
                cSec++;
                DisplayTime();
                PlayTune(TUNE_TICK);
                }
}



/****** S T E P  X Y ******/

VOID StepXY(INT x, INT y)
{
        INT cBombs;
        INT iBlk = (y<<5) + x;
        BLK blk = rgBlk[iBlk];

        if ( (blk & MaskVisit) ||
                  ((blk &= MaskData) == iBlkMax) ||
                  (blk == iBlkBombUp) )
                return;

        cBoxVisit++;
        rgBlk[iBlk] = (CHAR) (MaskVisit | (cBombs = CountBombs(x,y)));

//
//      SetDIBitsToDevice(hDCCapture,
//              (x<<4)+(dxGridOff-dxBlk), (y<<4)+(dyGridOff-dyBlk),
//              dxBlk, dyBlk, 0, 0, 0, dyBlk,
//              lpDibBlks + rgDibOff[cBombs],
//              (LPBITMAPINFO) lpDibBlks, DIB_RGB_COLORS);
//
        DisplayBlk(x,y);

        if (cBombs != 0)
                return;

        rgStepX[iStepMac] = x;
        rgStepY[iStepMac] = y;

        if (++iStepMac == iStepMax)
                iStepMac = 0;
}


/****** S T E P  B O X ******/

VOID StepBox(INT x, INT y)
{
        INT iStepCur = 0;

        iStepMac = 1;


        StepXY(x,y);

        if (++iStepCur != iStepMac)

                while (iStepCur != iStepMac)
                        {
                        x = rgStepX[iStepCur];
                        y = rgStepY[iStepCur];

                        StepXY(x-1, --y);
                        StepXY(x,   y);
                        StepXY(x+1, y);

                        StepXY(x-1, ++y);
                        StepXY(x+1, y);

                        StepXY(x-1, ++y);
                        StepXY(x,   y);
                        StepXY(x+1, y);

                        if (++iStepCur == iStepMax)
                                iStepCur = 0;
                        }


}


/****** S T E P  S Q U A R E ******/

/* Step on a single square */

VOID StepSquare(INT x, INT y)
{
        if (fISBOMB(x,y))
                {
                if (cBoxVisit == 0)
                        {
                        INT xT, yT;
                        for (yT = 1; yT < yBoxMac; yT++)
                                for (xT = 1; xT < xBoxMac; xT++)
                                        if (!fISBOMB(xT,yT))
                                                {
                                                IBLK(x,y) = (CHAR) iBlkBlankUp; /* Move bomb out of way */
                                                SetBomb(xT, yT);
                                                StepBox(x,y);
                                                return;
                                                }
                        }
                else
                        {
                        ChangeBlk(x, y, MaskVisit | iBlkExplode);
                        GameOver(fLose);
                        }
                }
        else
                {
                StepBox(x,y);

                if (fCheckWin())
                        GameOver(fWin);
                }
}


/******* C O U N T  M A R K S *******/

/* Count the bomb marks surrounding the point */

INT CountMarks(INT xCenter, INT yCenter)
{
        REGISTER INT    x;
        REGISTER INT    y;
        INT     cBombs = 0;

        for(y = yCenter-1; y <= yCenter+1; y++)
                for(x = xCenter-1; x <= xCenter+1; x++)
                        if (fGUESSBOMB(x,y))
                                cBombs++;

        return(cBombs);
}



/****** S T E P  B L O C K ******/

/* Step in a block around a single square */

VOID StepBlock(INT xCenter, INT yCenter)
{
        REGISTER INT    x;
        REGISTER INT    y;
        BOOL fGameOver = fFalse;

        if (  (!fVISIT(xCenter,yCenter))
/*                      || fGUESSBOMB(xCenter,yCenter) */
                        || (iBLK(xCenter,yCenter) != CountMarks(xCenter,yCenter)) )
                                {
                                /* not a safe thing to do */
                                TrackMouse(-2, -2);     /* pop up the blocks */
                                return;
                                }

        for(y=yCenter-1; y<=yCenter+1; y++)
                for(x=xCenter-1; x<=xCenter+1; x++)
                        {
                        if (!fGUESSBOMB(x,y) && fISBOMB(x,y))
                                {
                                fGameOver = fTrue;
                                ChangeBlk(x, y, MaskVisit | iBlkExplode);
                                }
                        else
                                StepBox(x,y);
                        }

        if (fGameOver)
                GameOver(fLose);
        else if (fCheckWin())
                GameOver(fWin);
}


/****** S T A R T  G A M E *******/

VOID StartGame(VOID)
{
        BOOL fAdjust;
        INT     x;
        INT     y;

        fTimer = fFalse;

        fAdjust = (Preferences.Width != xBoxMac || Preferences.Height != yBoxMac)
                ? (fResize | fDisplay) : fDisplay;

        xBoxMac = Preferences.Width;
        yBoxMac = Preferences.Height;

        ClearField();
        iButtonCur = iButtonHappy;

        cBombStart = Preferences.Mines;

        do
                {
                do
                        {
                        x = Rnd(xBoxMac) + 1;
                        y = Rnd(yBoxMac) + 1;
                        }
                while ( fISBOMB(x,y) );

                SetBomb(x,y);
                }
        while(--cBombStart);

        cSec   = 0;
        cBombLeft = cBombStart = Preferences.Mines;
        cBoxVisit = 0;
        cBoxVisitMac = (xBoxMac * yBoxMac) - cBombLeft;
        SetStatusPlay;

        UpdateBombCount(0);

        AdjustWindow(fAdjust);
}


#define fValidStep(x,y)  (! (fVISIT(x,y) || fGUESSBOMB(x,y)) )



/****** P U S H  B O X ******/

VOID PushBoxDown(INT x, INT y)
{
        BLK iBlk = iBLK(x,y);

        if (iBlk == iBlkGuessUp)
                iBlk = iBlkGuessDn;
        else if (iBlk == iBlkBlankUp)
                iBlk = iBlkBlank;

        SetBlk(x,y,iBlk);
}


/****** P O P  B O X  U P ******/

VOID PopBoxUp(INT x, INT y)
{
        BLK iBlk = iBLK(x,y);

        if (iBlk == iBlkGuessDn)
                iBlk = iBlkGuessUp;
        else if (iBlk == iBlkBlank)
                iBlk = iBlkBlankUp;

        SetBlk(x,y,iBlk);
}



/****** T R A C K  M O U S E ******/

VOID TrackMouse(INT xNew, INT yNew)
{
        if((xNew == xCur) && (yNew == yCur))
                return;

        {
        INT xOld = xCur;
        INT yOld = yCur;

        xCur = xNew;
        yCur = yNew;

        if (fBlock)
                {
                INT x;
                INT y;
                BOOL fValidNew = fInRange(xNew, yNew);
                BOOL fValidOld = fInRange(xOld, yOld);

                INT yOldMin = max(yOld-1,1);
                INT yOldMax = min(yOld+1,yBoxMac);
                INT yCurMin = max(yCur-1,1);
                INT yCurMax = min(yCur+1,yBoxMac);
                INT xOldMin = max(xOld-1,1);
                INT xOldMax = min(xOld+1,xBoxMac);
                INT xCurMin = max(xCur-1,1);
                INT xCurMax = min(xCur+1,xBoxMac);


                if (fValidOld)
                        for (y=yOldMin; y<=yOldMax; y++)
                                for (x=xOldMin; x<=xOldMax; x++)
                                        if (!fVISIT(x,y))
                                                PopBoxUp(x, y);

                if (fValidNew)
                        for (y=yCurMin; y<=yCurMax; y++)
                                for (x=xCurMin; x<=xCurMax; x++)
                                        if (!fVISIT(x,y))
                                                PushBoxDown(x, y);

                if (fValidOld)
                        for (y=yOldMin; y<=yOldMax; y++)
                                for (x=xOldMin; x<=xOldMax; x++)
                                        DisplayBlk(x, y);

                if (fValidNew)
                        for (y=yCurMin; y<=yCurMax; y++)
                                for (x=xCurMin; x<=xCurMax; x++)
                                        DisplayBlk(x, y);
                }
        else
                {
                if (fInRange(xOld, yOld) && !fVISIT(xOld,yOld) )
                        {
                        PopBoxUp(xOld, yOld);
                        DisplayBlk(xOld, yOld);
                        }
                if (fInRange(xNew, yNew) && fValidStep(xNew, yNew))
                        {
                        PushBoxDown(xCur, yCur);
                        DisplayBlk(xCur, yCur);
                        }
                }
        }
}





/****** M A K E  G U E S S ******/

VOID MakeGuess(INT x, INT y)
{
        BLK     iBlk;

        if(fInRange(x,y))
                {
                if(!fVISIT(x,y))
                        {
                        if(fGUESSBOMB(x,y))
                                {
                                if (Preferences.fMark)
                                        iBlk = iBlkGuessUp;
                                else
                                        iBlk = iBlkBlankUp;
                                UpdateBombCount(+1);
                                }
                        else if(fGUESSMARK(x,y))
                                {
                                iBlk = iBlkBlankUp;
                                }
                        else
                                {
                                iBlk = iBlkBombUp;
                                UpdateBombCount(-1);
                                }

                        ChangeBlk(x,y, iBlk);

                        if (fGUESSBOMB(x,y) && fCheckWin())
                                GameOver(fWin);
                        }
                }
}

/****** D O  B U T T O N  1  U P ******/

VOID DoButton1Up(VOID)
{
        if (fInRange(xCur, yCur))
                {

                if ((cBoxVisit == 0) && (cSec == 0))
                        {
                        PlayTune(TUNE_TICK);
                        cSec++;
                        DisplayTime();
                        fTimer = fTrue;

                        // Start the timer now. If we had started it earlier,
                        // the interval between tick 1 and 2 is not correct.
                        if (SetTimer(hwndMain, ID_TIMER, 1000 , NULL) == 0)
		                    {
		                    ReportErr(ID_ERR_TIMER);
		                    }
                        }

                if (!fStatusPlay)
                        xCur = yCur = -2;

                if (fBlock)
                        StepBlock(xCur, yCur);
                else
                        if (fValidStep(xCur, yCur))
                                StepSquare(xCur, yCur);
                }

        DisplayButton(iButtonCur);
}


/****** P A U S E  G A M E ******/

VOID PauseGame(VOID)
{
        EndTunes();
        // remember the oldtimer status.

	if (!fStatusPause)
        	fOldTimerStatus = fTimer;
        if (fStatusPlay)
                fTimer = fFalse;

        SetStatusPause;
}


/****** R E S U M E  G A M E ******/

VOID ResumeGame(VOID)
{
        // restore to the old timer status.
        if (fStatusPlay)
                fTimer = fOldTimerStatus;

        ClrStatusPause;
}


/****** U P D A T E  B O M B  C O U N T ******/

VOID UpdateBombCount(INT BombAdjust)
{
        cBombLeft += BombAdjust;
        DisplayBombCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\sound.c ===
/***********/
/* sound.c */
/***********/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>
#include <mmsystem.h>

#include "main.h"
#include "sound.h"
#include "rtns.h"
#include "pref.h"
#include "res.h"

extern HANDLE hInst;
extern PREF Preferences;



/****** F I N I T  T U N E S ******/

INT FInitTunes( VOID )
{
	// Even if the user has chosen the sound option
	// but does not have sound playing capabilities,
	// put the sound off.
	if ( PlaySound(NULL, NULL, SND_PURGE)  == FALSE)
		return fsoundOff;
	
	return fsoundOn;
}



/****** E N D  T U N E S ******/

VOID EndTunes(VOID)
{
	// Just stop the tune ..
	if (FSoundOn())
	{
		PlaySound(NULL, NULL, SND_PURGE);
	}
}



/****** P L A Y  T U N E ******/

VOID PlayTune(INT tune)
{

    if (!FSoundOn())
        return;

	// Play the appropriate .wav file.
	switch (tune)
	{
	case TUNE_TICK:
        PlaySound(MAKEINTRESOURCE(ID_TUNE_TICK), hInst, SND_RESOURCE | SND_ASYNC);
		break;

	case TUNE_WINGAME:
	    PlaySound(MAKEINTRESOURCE(ID_TUNE_WON), hInst, SND_RESOURCE | SND_ASYNC); 
		break;

	case TUNE_LOSEGAME:
	    PlaySound(MAKEINTRESOURCE(ID_TUNE_LOST), hInst, SND_RESOURCE | SND_ASYNC);
		break;

	default:
#ifdef DEBUG
		Oops(TEXT("Invalid Tune"));
#endif
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\sound.h ===
/*****************/
/* file: sound.h */
/*****************/

#define TUNE_TICK      1
#define TUNE_WINGAME   2
#define TUNE_LOSEGAME  3

#define fsoundOn  3
#define fsoundOff 2

#define FSoundSwitchable()  (Preferences.fSound > 1)
#define FSoundOn()          (Preferences.fSound == fsoundOn)

INT  FInitTunes(VOID);
VOID PlayTune(INT);
VOID EndTunes(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\strings.inc ===
/* strings.inc */

STRINGTABLE
  BEGIN
    ID_GAMENAME      "Minesweeper"
    ID_ERR_TITLE     "Minesweeper Error"
    ID_ERR_TIMER,    "Unable to allocate a timer.  Please exit some of your applications and try again."
    ID_ERR_UNKNOWN,  "Error: %d"
    ID_ERR_MEM,      "Out of Memory"
    ID_NAME_DEFAULT, "Anonymous"
    ID_MSG_SEC,      "%d seconds"
    ID_MSG_BEGIN,    "You have the fastest time\rfor beginner level.\rPlease enter your name."
    ID_MSG_INTER,    "You have the fastest time\rfor intermediate level.\rPlease enter your name."
    ID_MSG_EXPERT,   "You have the fastest time\rfor expert level.\rPlease enter your name."
    ID_MSG_VERSION,  "Minesweeper"
    ID_MSG_CREDIT,   "by Robert Donner and Curt Johnson"
  END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\util.c ===
/**********/
/* util.c */
/**********/

#define  _WINDOWS
#include <windows.h>
#include <htmlhelp.h>   // for HtmlHelp()
#include "shellapi.h"   // for ShellAbout
#include <port1632.h>

#include "main.h"
#include "res.h"
#include "pref.h"
#include "util.h"
#include "sound.h"
#include "rtns.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "dos.h"

extern INT dypBorder;
extern INT dxpBorder;
extern INT dypCaption;
extern INT dypMenu;

extern TCHAR szClass[cchNameMax];
extern TCHAR szTime[cchNameMax];
extern TCHAR szDefaultName[cchNameMax];

extern HANDLE hInst;
extern HWND   hwndMain;
extern HMENU  hMenu;

extern PREF Preferences;

extern  HKEY g_hReg;
extern  TCHAR * rgszPref[iszPrefMax];
TCHAR   szIniFile[] = TEXT("entpack.ini");


/****** R N D ******/

/* Return a random number between 0 and rndMax */

INT Rnd(INT rndMax)
{
        return (rand() % rndMax);
}



/****** R E P O R T  E R R ******/

/* Report and error and exit */

VOID ReportErr(WORD idErr)
{
        TCHAR szMsg[cchMsgMax];
        TCHAR szMsgTitle[cchMsgMax];

        if (idErr < ID_ERR_MAX)
                LoadString(hInst, idErr, szMsg, cchMsgMax);
        else
                {
                LoadString(hInst, ID_ERR_UNKNOWN, szMsgTitle, cchMsgMax);
                wsprintf(szMsg, szMsgTitle, idErr);
                }

        LoadString(hInst, ID_ERR_TITLE, szMsgTitle, cchMsgMax);

        MessageBox(NULL, szMsg, szMsgTitle, MB_OK | MB_ICONHAND);
}


/****** L O A D  S Z ******/

VOID LoadSz(WORD id, TCHAR * sz, DWORD cch)
{
        if (LoadString(hInst, id, sz, cch) == 0)
                ReportErr(1001);
}


// Routines to read the ini file.

INT ReadIniInt(INT iszPref, INT valDefault, INT valMin, INT valMax)
{
	return max(valMin, min(valMax,
		(INT) GetPrivateProfileInt(szClass, rgszPref[iszPref], valDefault, szIniFile) ) );
}

#define ReadIniBool(iszPref, valDefault) ReadIniInt(iszPref, valDefault, 0, 1)


VOID ReadIniSz(INT iszPref, TCHAR FAR * szRet)
{
	GetPrivateProfileString(szClass, rgszPref[iszPref], szDefaultName, szRet, cchNameMax, szIniFile);
}




/****** I N I T  C O N S T ******/

VOID InitConst(VOID)
{
INT     iAlreadyPlayed = 0;     // have we already updated the registry ?
DWORD   dwDisposition;
       

        srand(LOWORD(GetCurrentTime()));

        LoadSz(ID_GAMENAME, szClass, ARRAYSIZE(szClass));
        LoadSz(ID_MSG_SEC,  szTime, ARRAYSIZE(szTime));
        LoadSz(ID_NAME_DEFAULT, szDefaultName, ARRAYSIZE(szDefaultName));

        dypCaption = GetSystemMetrics(SM_CYCAPTION) + 1;
        dypMenu    = GetSystemMetrics(SM_CYMENU)    + 1;
        dypBorder  = GetSystemMetrics(SM_CYBORDER)  + 1;
        dxpBorder  = GetSystemMetrics(SM_CXBORDER)  + 1;

        // Open the registry key;
        if (RegCreateKeyEx(HKEY_CURRENT_USER, SZWINMINEREG, 0, NULL, 0, KEY_READ, NULL, 
                   &g_hReg, &dwDisposition) == ERROR_SUCCESS)
        {
            iAlreadyPlayed = ReadInt(iszPrefAlreadyPlayed, 0, 0, 1);
            RegCloseKey(g_hReg);
        }


        // Read it from the .ini file and write it to registry.
        if (!iAlreadyPlayed)
        {
            Preferences.Height= ReadIniInt(iszPrefHeight,MINHEIGHT,DEFHEIGHT,25);
            Preferences.Width= ReadIniInt(iszPrefWidth,MINWIDTH,DEFWIDTH,30);

            Preferences.wGameType = (WORD)ReadIniInt(iszPrefGame,wGameBegin, wGameBegin, wGameExpert+1);
            Preferences.Mines    = ReadIniInt(iszPrefMines, 10, 10, 999);
            Preferences.xWindow  = ReadIniInt(iszPrefxWindow, 80, 0, 1024);
            Preferences.yWindow  = ReadIniInt(iszPrefyWindow, 80, 0, 1024);

            Preferences.fSound = ReadIniInt(iszPrefSound, 0, 0, fsoundOn);
            Preferences.fMark  = ReadIniBool(iszPrefMark,  fTrue);
            Preferences.fTick  = ReadIniBool(iszPrefTick,  fFalse);
            Preferences.fMenu  = ReadIniInt(iszPrefMenu,  fmenuAlwaysOn, fmenuAlwaysOn, fmenuOn);
	
            Preferences.rgTime[wGameBegin]  = ReadIniInt(iszPrefBeginTime, 999, 0, 999);
            Preferences.rgTime[wGameInter]  = ReadIniInt(iszPrefInterTime, 999, 0, 999);
            Preferences.rgTime[wGameExpert] = ReadIniInt(iszPrefExpertTime, 999, 0, 999);

            ReadIniSz(iszPrefBeginName, Preferences.szBegin);
            ReadIniSz(iszPrefInterName, Preferences.szInter);
            ReadIniSz(iszPrefExpertName, Preferences.szExpert);

            // set the color preference so we will use the right bitmaps
            // numcolors may return -1 on true color devices
            {
            HDC hDC = GetDC(GetDesktopWindow());
            Preferences.fColor  = ReadIniBool(iszPrefColor, (GetDeviceCaps(hDC, NUMCOLORS) != 2));
            ReleaseDC(GetDesktopWindow(),hDC);
            }

            if (FSoundOn())
                Preferences.fSound = FInitTunes();
            
            // Write it to registry.
            WritePreferences();
        }

}



/* * * * * *  M E N U S  * * * * * */

/****** C H E C K  E M ******/

VOID CheckEm(WORD idm, BOOL fCheck)
{
        CheckMenuItem(hMenu, idm, fCheck ? MF_CHECKED : MF_UNCHECKED);
}

/****** S E T  M E N U  B A R ******/

VOID SetMenuBar(INT fActive)
{
        Preferences.fMenu = fActive;
        FixMenus();
        SetMenu(hwndMain, FMenuOn() ? hMenu : NULL);
        AdjustWindow(fResize);
}


/****** D O  A B O U T ******/

VOID DoAbout(VOID)
{
        TCHAR szVersion[cchMsgMax];
        TCHAR szCredit[cchMsgMax];

        LoadSz(ID_MSG_VERSION, szVersion, ARRAYSIZE(szVersion));
        LoadSz(ID_MSG_CREDIT,  szCredit, ARRAYSIZE(szCredit));

        ShellAbout(hwndMain,
          szVersion, szCredit, LoadIcon(hInst, MAKEINTRESOURCE(ID_ICON_MAIN)));
}


/****** D O  H E L P ******/

VOID DoHelp(WORD wCommand, UINT lParam)
{
        CHAR szHelpFile[cchMaxPathname];
        CHAR * pch;

        // If we are showing help_onhelp, use the 
        // nthelp.chm file else use winmine.chm
        if (wCommand != HELP_HELPONHELP)
        {
            /*
            * Replace the .exe extension on the complete path with
            * the .hlp extension instead.
            */
            pch = szHelpFile +
                  GetModuleFileNameA(hInst, szHelpFile, cchMaxPathname) - 1;

            if ( (pch-szHelpFile > 4) &&
                 (*(pch-3) == '.') ) {
                    pch -= 3;
            }
            strcpy(pch, ".chm");
        }
        else strcpy(szHelpFile, "NTHelp.chm");

        HtmlHelpA(GetDesktopWindow(), szHelpFile, lParam, 0);
}



/****** G E T  D L G  I N T ******/

INT GetDlgInt(HWND hDlg, INT dlgID, INT numLo, INT numHi)
{
        INT num;
        BOOL fFlag;

        num = GetDlgItemInt(hDlg, dlgID, &fFlag, fFalse);

        if (num < numLo)
                num = numLo;
        else if (num > numHi)
                num = numHi;

        return num;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\util.h ===
/**********/
/* util.h */
/**********/

#define ARRAYSIZE(x) (sizeof(x) / sizeof(x[0]))

VOID InitConst(VOID);
VOID LoadSz(WORD, TCHAR *, DWORD);
VOID ReportErr(WORD);
INT  Rnd(INT);

INT  GetDlgInt(HWND, INT, INT, INT);

VOID DoHelp(WORD, UINT);
VOID DoAbout(VOID);

VOID CheckEm(WORD, BOOL);
VOID SetMenuBar(INT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\winmine.c ===
/****************************************************************************

    PROGRAM: WinMine  (a.k.a. Mines, BombSquad, MineSweeper...)

****************************************************************************/

#define _WINDOWS
#include <windows.h>
#include <port1632.h>
#include <htmlhelp.h>   // for HtmlHelp()
#include <commctrl.h>   // for fusion classes.

#include "main.h"
#include "rtns.h"
#include "grafix.h"
#include "res.h"
#include "pref.h"
#include "util.h"
#include "sound.h"
#include "context.h"
#include "string.h"
#include "stdio.h"
#include "dos.h"

#ifndef WM_ENTERMENULOOP
#define WM_ENTERMENULOOP 0x0211
#define WM_EXITMENULOOP  0x0212
#endif

BOOL bInitMinimized;  /* Bug #13328: HACK!  Don't permit MoveWindow or  */
                      /* InvalidateRect when initially minimized.       */
                      /* 19 September 1991   Clark R. Cyr               */

HANDLE hInst;
HWND   hwndMain;
HMENU  hMenu;

// Icon handles to load the winmine icon.
HICON   hIconMain;

BOOL fButton1Down = fFalse;
BOOL fBlock       = fFalse;
BOOL fIgnoreClick = fFalse;

INT dypCaption;
INT dypMenu;
INT dypBorder;
INT dxpBorder;

INT  fStatus = (fDemo + fIcon);
BOOL fLocalPause = fFalse;

TCHAR szClass[cchNameMax];
#define szWindowTitle szClass

TCHAR szTime[cchNameMax];
TCHAR szDefaultName[cchNameMax];


extern BOOL fUpdateIni;

extern INT xCur;
extern INT yCur;
extern INT iButtonCur;

extern INT xBoxMac;
extern INT yBoxMac;

extern PREF Preferences;
extern INT  cBoxVisit;

INT dxWindow;
INT dyWindow;
INT dypCaption;
INT dypMenu;
INT dypAdjust;


INT idRadCurr = 0;

#define iPrefMax 3
#define idRadMax 3

INT	rgPrefEditID[iPrefMax] =
	{ID_EDIT_MINES, ID_EDIT_HEIGHT, ID_EDIT_WIDTH};

INT	rgLevelData[idRadMax][iPrefMax] = {
	{10, MINHEIGHT,  MINWIDTH, },
	{40, 16, 16,},
	{99, 16, 30,}
	};


#ifndef DEBUG
#define XYZZY
#define cchXYZZY 5
INT     iXYZZY = 0;
TCHAR   szXYZZY[cchXYZZY+1] = TEXT("XYZZY");
extern  CHAR rgBlk[cBlkMax];
#endif


LRESULT  APIENTRY MainWndProc(HWND,  UINT, WPARAM, LPARAM);
INT_PTR  APIENTRY PrefDlgProc(HWND,  UINT, WPARAM, LPARAM);
INT_PTR  APIENTRY BestDlgProc(HWND,  UINT, WPARAM, LPARAM);
INT_PTR  APIENTRY EnterDlgProc(HWND,  UINT, WPARAM, LPARAM);





/****** W I N  M A I N ******/

MMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow)
/* { */
	MSG msg;
	HANDLE hAccel;

	hInst = hInstance;

	InitConst();

    bInitMinimized = (nCmdShow == SW_SHOWMINNOACTIVE) ||
                     (nCmdShow == SW_SHOWMINIMIZED) ;

#ifdef WIN16
	if (hPrevInstance)
		{
		HWND hWnd = FindWindow(szClass, NULL);
		hWnd = GetLastActivePopup(hWnd);
		BringWindowToTop(hWnd);
		if (!bInitMinimized && IsIconic(hWnd))
			SendMessage(hwnd, WM_SYSCOMMAND, SC_RESTORE, 0L);
		return fFalse;
		}
#endif

#ifdef NOSERVER		/*** Not in final release ***/
	{
	TCHAR  szFile[256];

	GetModuleFileName(hInst, szFile, 250);

	if (szFile[0] > TEXT('C'))
		{
		szFile[0] = TEXT('X');
		if (!lstrcmp(szFile, TEXT("X:\\WINGAMES\\WINMINE\\WINMINE.EXE")))
			{
			MessageBox(GetFocus(),
				TEXT("Please copy winmine.exe and aboutwep.dll to your machine and run it from there."),
				TEXT("NO NO NO NO NO"),
				MB_OK);
			return fFalse;
			}
		}
	}
#endif


#ifdef EXPIRE			/*** Not in final release ***/
	{
	struct dosdate_t ddt;

	_dos_getdate(&ddt);

	if ((ddt.month + ddt.year*12) > (9 + 1990*12))
		{
		MessageBox(GetFocus(),
			TEXT("This game has expired. Please obtain an official copy from the Windows Entertainment Package."),
			TEXT("SORRY"),
			MB_OK);
		return fFalse;
		}
	}
#endif


	{
	WNDCLASS  wc;
	INITCOMMONCONTROLSEX icc;   // common control registration.

	// Register the common controls.
	icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
	icc.dwICC  = ICC_ANIMATE_CLASS | ICC_BAR_CLASSES | ICC_COOL_CLASSES | ICC_HOTKEY_CLASS | ICC_LISTVIEW_CLASSES | 
			ICC_PAGESCROLLER_CLASS | ICC_PROGRESS_CLASS | ICC_TAB_CLASSES | ICC_UPDOWN_CLASS | ICC_USEREX_CLASSES;
	InitCommonControlsEx(&icc);


	hIconMain = LoadIcon(hInst, MAKEINTRESOURCE(ID_ICON_MAIN));

	wc.style = 0;
	wc.lpfnWndProc   = MainWndProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = hInst;
	wc.hIcon         = hIconMain;
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = GetStockObject(LTGRAY_BRUSH);
	wc.lpszMenuName  = NULL;
	wc.lpszClassName = szClass;

	if (!RegisterClass(&wc))
		return fFalse;
	}

	hMenu = LoadMenu(hInst, MAKEINTRESOURCE(ID_MENU));
	hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(ID_MENU_ACCEL));


	ReadPreferences();

	hwndMain = CreateWindow( szClass, szWindowTitle,
                WS_OVERLAPPED | WS_MINIMIZEBOX | WS_CAPTION | WS_SYSMENU, 
                Preferences.xWindow-dxpBorder, Preferences.yWindow-dypAdjust,
		dxWindow+dxpBorder, dyWindow +dypAdjust,
		NULL, NULL, hInst, NULL);

	if (!hwndMain)
		{
		ReportErr(1000);
		return fFalse;
		}

	AdjustWindow(fCalc);


	if (!FInitLocal())
		{
		ReportErr(ID_ERR_MEM);
		return fFalse;
		}

	SetMenuBar(Preferences.fMenu);

	StartGame();

	ShowWindow(hwndMain, SW_SHOWNORMAL);
	UpdateWindow(hwndMain);

    bInitMinimized = FALSE;

	while (GetMessage(&msg, NULL, 0, 0))
		{
		if (!TranslateAccelerator(hwndMain, hAccel, &msg))
			{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			}
		}

	CleanUp();

    if (fUpdateIni)
        WritePreferences();

	return ((INT) msg.wParam);
}


/****** F  L O C A L  B U T T O N ******/

BOOL FLocalButton(LPARAM lParam)
{
	BOOL fDown = fTrue;
	RECT rcCapt;
	MSG msg;

	msg.pt.x = LOWORD(lParam);
	msg.pt.y = HIWORD(lParam);

	rcCapt.right  = dxButton + (rcCapt.left = (dxWindow-dxButton) >> 1);
	rcCapt.bottom = dyButton +	(rcCapt.top = dyTopLed);

	if (!PtInRect(&rcCapt, msg.pt))
		return fFalse;

	SetCapture(hwndMain);

	DisplayButton(iButtonDown);

	MapWindowPoints(hwndMain , NULL , (LPPOINT) &rcCapt , 2);

	while (fTrue)
		{
      if (PeekMessage(&msg, hwndMain, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
			{

		switch (msg.message)
			{
	   case WM_LBUTTONUP:
			if (fDown)
				{
				if (PtInRect(&rcCapt, msg.pt))
					{
					DisplayButton(iButtonCur = iButtonHappy);
					StartGame();
					}
				}
			ReleaseCapture();
			return fTrue;

	   case WM_MOUSEMOVE:
			if (PtInRect(&rcCapt, msg.pt))
		   	{
				if (!fDown)
					{
               fDown = fTrue;
					DisplayButton(iButtonDown);
					}
				}
			else
				{
				if (fDown)
					{
               fDown = fFalse;
					DisplayButton(iButtonCur);
					}
				}
		default:
			;
			}	/* switch */
		}	

    	}	/* while */
}



/****** F I X  M E N U S ******/

VOID FixMenus(VOID)
{
	CheckEm(IDM_BEGIN,  Preferences.wGameType == wGameBegin);
	CheckEm(IDM_INTER,  Preferences.wGameType == wGameInter);
	CheckEm(IDM_EXPERT, Preferences.wGameType == wGameExpert);
	CheckEm(IDM_CUSTOM, Preferences.wGameType == wGameOther);

	CheckEm(IDM_COLOR,  Preferences.fColor);
	CheckEm(IDM_MARK,   Preferences.fMark);
	CheckEm(IDM_SOUND,  Preferences.fSound);
}



/****** D O  P R E F ******/

VOID DoPref(VOID)
{

	DialogBox(hInst, MAKEINTRESOURCE(ID_DLG_PREF), hwndMain, PrefDlgProc);

    Preferences.wGameType = wGameOther;
	FixMenus();
	fUpdateIni = fTrue;
	StartGame();
}


/****** D O  E N T E R  N A M E ******/

VOID DoEnterName(VOID)
{
	DialogBox(hInst, MAKEINTRESOURCE(ID_DLG_ENTER), hwndMain, EnterDlgProc);
	fUpdateIni = fTrue;
}


/****** D O  D I S P L A Y  B E S T ******/

VOID DoDisplayBest(VOID)
{
	DialogBox(hInst, MAKEINTRESOURCE(ID_DLG_BEST), hwndMain, BestDlgProc);
}

				
/****** M A I N  W N D  P R O C ******/

LRESULT  APIENTRY MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{

	switch (message)
		{
	case WM_WINDOWPOSCHANGED:
		if (!fStatusIcon)
			{
			Preferences.xWindow = ((LPWINDOWPOS) (lParam))->x;
			Preferences.yWindow = ((LPWINDOWPOS) (lParam))->y;
			}	
		break;

	case WM_SYSCOMMAND:
		switch (wParam & 0xFFF0)
			{
		case SC_MINIMIZE:

            		PauseGame();
			SetStatusPause;
			SetStatusIcon;
			break;
			
		case SC_RESTORE:
			ClrStatusPause;
			ClrStatusIcon;
			ResumeGame();

//Japan Bug fix: 1/19/93 Enable the first click after restoring from icon.
			fIgnoreClick = fFalse;
			break;

		default:
			break;
			}
			
		break;


	case WM_COMMAND:
	    {
	    switch(GET_WM_COMMAND_ID(wParam, lParam)) {

	    case IDM_NEW:
		    StartGame();
		    break;
						
	    /** IDM_NEW **/
	    case IDM_EXIT:
		    ShowWindow(hwndMain, SW_HIDE);
#ifdef ORGCODE
		    goto LExit;
#else
            SendMessage(hwndMain, WM_SYSCOMMAND, SC_CLOSE, 0);
            return(0);
#endif
	    /** IDM_SKILL **/
	    case IDM_BEGIN:
	    case IDM_INTER:
	    case IDM_EXPERT:
		    Preferences.wGameType = (WORD)(GET_WM_COMMAND_ID(wParam, lParam) - IDM_BEGIN);
		    Preferences.Mines  = rgLevelData[Preferences.wGameType][0];
		    Preferences.Height = rgLevelData[Preferences.wGameType][1];
		    Preferences.Width  = rgLevelData[Preferences.wGameType][2];
		    StartGame();
		    goto LUpdateMenu;

	    case IDM_CUSTOM:
		    DoPref();
		    break;

	    /** IDM_OPTIONS **/
	    case IDM_SOUND:
		    if (Preferences.fSound)
			    {
			    EndTunes();
			    Preferences.fSound = fFalse;
			    }
		    else
			    {
			    Preferences.fSound = FInitTunes();
			    }
		    goto LUpdateMenu;

	    case IDM_COLOR:
		    Preferences.fColor = !Preferences.fColor;
		    FreeBitmaps();
		    if (!FLoadBitmaps())
			    {
			    ReportErr(ID_ERR_MEM);
#ifdef ORGCODE
			    goto LExit;
#else
                SendMessage(hwndMain, WM_SYSCOMMAND, SC_CLOSE, 0);
                return(0);
#endif
			    }
		    DisplayScreen();
		    goto LUpdateMenu;

	    case IDM_MARK:
		    Preferences.fMark = !Preferences.fMark;
	    /* IE	goto LUpdateMenu;	*/

    LUpdateMenu:
		    fUpdateIni = fTrue;
		    SetMenuBar(Preferences.fMenu);
		    break;

	    case IDM_BEST:
		    DoDisplayBest();
		    break;


	    /** IDM_HELP **/
	    case IDM_HELP:
		    DoHelp(HELP_INDEX, HH_DISPLAY_TOPIC);
		    break;

	    case IDM_HOW2PLAY:
		    DoHelp(HELP_CONTEXT, HH_DISPLAY_INDEX);
		    break;

	    case IDM_HELP_HELP:
		    DoHelp(HELP_HELPONHELP, HH_DISPLAY_TOPIC);
		    break;

	    case IDM_HELP_ABOUT:
		    DoAbout();
		    return 0;

	    default:
		    break;
	    }

	} /**** END OF MENUS ****/

		break;



	case WM_KEYDOWN:
		switch (wParam)
			{

#if 0
		case VK_F1:
			DoHelp(HELP_INDEX, 0L);
			break;

		case VK_F2:
			StartGame();
			break;

		case VK_F3:
			break;

#endif
		case VK_F4:
			if (FSoundSwitchable())
				if (FSoundOn())
					{
					EndTunes();
					Preferences.fSound = fsoundOff;
					}
				else
					Preferences.fSound = FInitTunes();
			break;

		case VK_F5:
			if (FMenuSwitchable())
				SetMenuBar(fmenuOff);
			break;

		case VK_F6:
			if (FMenuSwitchable())
				SetMenuBar(fmenuOn);
			break;

#ifdef XYZZY
		case VK_SHIFT:
			if (iXYZZY >= cchXYZZY)
				iXYZZY ^= 20;
			break;

		default:
			if (iXYZZY < cchXYZZY)
				iXYZZY = (szXYZZY[iXYZZY] == (TCHAR) wParam) ? iXYZZY+1 : 0;
			break;

#else
		default:
			break;
#endif
			}	
		break;

/*  	case WM_QUERYENDSESSION:    SHOULDNT BE USED (JAP)*/

	case WM_DESTROY:
//LExit:
        KillTimer(hwndMain, ID_TIMER);
    	PostQuitMessage(0);
	    break;

	case WM_MBUTTONDOWN:
		if (fIgnoreClick)
			{
			fIgnoreClick = fFalse;
			return 0;
			}

		if (!fStatusPlay)
			break;

		fBlock = fTrue;
		goto LBigStep;

	case WM_LBUTTONDOWN:

		if (fIgnoreClick)
			{
			fIgnoreClick = fFalse;
			return 0;
			}

		if (FLocalButton(lParam))
			return 0;

		if (!fStatusPlay)
			break;
		fBlock = (wParam & (MK_SHIFT | MK_RBUTTON)) ? fTrue : fFalse;

LBigStep:
		SetCapture(hWnd);
		fButton1Down = fTrue;

		xCur = -1;
		yCur = -1;
		DisplayButton(iButtonCaution);

	case WM_MOUSEMOVE:
		if (fButton1Down)
			{
			if (fStatus & fPlay)
				TrackMouse(xBoxFromXpos(LOWORD(lParam)), yBoxFromYpos(HIWORD(lParam)) );
			else
				goto LFixTimeOut;
			}
#ifdef XYZZY
        //
        // This is the cheat:
        // If you hold down the shift key and type 'XYZZY'
        // then when you hold down the control key, to upper
        // left hand corner pixel will show the state of the
        // mine field under the mouse.  Oh. joy.  I can win.
        //
		else if (iXYZZY != 0)
			if (((iXYZZY == cchXYZZY) && (wParam & MK_CONTROL))
			   ||(iXYZZY > cchXYZZY))
			{
			xCur = xBoxFromXpos(LOWORD(lParam));
			yCur = yBoxFromYpos(HIWORD(lParam));
			if (fInRange(xCur, yCur))
				{
                HDC hDC = GetDC(NULL);                
				SetPixel(hDC, 0, 0, fISBOMB(xCur, yCur) ? 0L : 0x00FFFFFFL);
				ReleaseDC(NULL, hDC);
				}
			}
#endif
		break;

	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
	case WM_LBUTTONUP:
		if (fButton1Down)
			{
LFixTimeOut:
			fButton1Down = fFalse;
			ReleaseCapture();
			if (fStatus & fPlay)
				DoButton1Up();
			else
				TrackMouse(-2,-2);
			}
		break;

	case WM_RBUTTONDOWN:
		if (fIgnoreClick)
			{
			fIgnoreClick = fFalse;
			return 0;
			}

		if(!fStatusPlay)
			break;

		if (fButton1Down)
			{
			TrackMouse(-3,-3);
			fBlock = fTrue;
			PostMessage(hwndMain, WM_MOUSEMOVE, wParam, lParam);
			}
		else if (wParam & MK_LBUTTON)
			goto LBigStep;
		else if (!fLocalPause)
			MakeGuess(xBoxFromXpos(LOWORD(lParam)), yBoxFromYpos(HIWORD(lParam)) );
		return 0;

	case WM_ACTIVATE:
		/* Window is being activated by a mouse click */
		if (GET_WM_ACTIVATE_STATE(wParam, lParam) == 2)
			fIgnoreClick = fTrue;
		break;

	case WM_TIMER:
#ifdef CHEAT
		if (!fLocalPause)
#endif
			DoTimer();
		return 0;

	case WM_ENTERMENULOOP:
		fLocalPause = fTrue;
		break;

	case WM_EXITMENULOOP:
		fLocalPause = fFalse;
		break;

	case WM_PAINT:
		{
		PAINTSTRUCT ps;
		HDC hDC = BeginPaint(hWnd,&ps);
		DrawScreen(hDC);
		EndPaint(hWnd, &ps);
		}
		return 0;

	default:
		break;

    }

	return (DefWindowProc(hWnd, message, wParam, lParam));
}




/****** DIALOG PROCEDURES ******/

/*** P R E F  D L G  P R O C ***/

INT_PTR  APIENTRY PrefDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    // for context sensitive help
    static DWORD aIds[] = {     
        ID_EDIT_HEIGHT,        IDH_PREF_EDIT_HEIGHT,
        ID_EDIT_WIDTH,         IDH_PREF_EDIT_WIDTH,
        ID_EDIT_MINES,         IDH_PREF_EDIT_MINES,
        ID_TXT_HEIGHT,         IDH_PREF_EDIT_HEIGHT,
        ID_TXT_WIDTH,          IDH_PREF_EDIT_WIDTH,
        ID_TXT_MINES,          IDH_PREF_EDIT_MINES,
        0,0 }; 

	switch (message)
		{
	case WM_INITDIALOG:
		SetDlgItemInt(hDlg, ID_EDIT_HEIGHT, Preferences.Height ,fFalse);
		SetDlgItemInt(hDlg, ID_EDIT_WIDTH,  Preferences.Width  ,fFalse);
		SetDlgItemInt(hDlg, ID_EDIT_MINES,  Preferences.Mines  ,fFalse);
		return (fTrue);

	case WM_COMMAND:
		switch(GET_WM_COMMAND_ID(wParam, lParam)) {
		case ID_BTN_OK:
		case IDOK:
			{

			Preferences.Height = GetDlgInt(hDlg, ID_EDIT_HEIGHT, MINHEIGHT, 24);
			Preferences.Width  = GetDlgInt(hDlg, ID_EDIT_WIDTH,  MINWIDTH,  30);
			Preferences.Mines  = GetDlgInt(hDlg, ID_EDIT_MINES,  10,
				min(999, (Preferences.Height-1) * (Preferences.Width-1) ) );

			}

			/* Fall Through & Exit */
		case ID_BTN_CANCEL:
		case IDCANCEL:
			EndDialog(hDlg, fTrue);	      /* Exits the dialog box	     */
			return fTrue;

		default:
			break;
			}
        break;

    // context sensitive help.
    case WM_HELP: 
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("winmine.hlp"), 
                HELP_WM_HELP, (ULONG_PTR) aIds);         
        break;  

    case WM_CONTEXTMENU: 
        WinHelp((HWND) wParam, TEXT("winmine.hlp"), HELP_CONTEXTMENU, 
                (ULONG_PTR) aIds);         
        break;   
		}

    return (fFalse);			/* Didn't process a message    */
}


/*** S E T  D T E X T ***/

VOID SetDText(HWND hDlg, INT id, INT time, TCHAR FAR * szName)
{
	TCHAR sz[cchNameMax];

	wsprintf(sz, szTime, time);
	SetDlgItemText(hDlg, id, sz);
	SetDlgItemText(hDlg, id+1, szName);
}


/****** B E S T  D L G  P R O C ******/

INT_PTR  APIENTRY BestDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    // for context sensitive help
    static DWORD aIds[] = {     
        ID_BTN_RESET,        IDH_BEST_BTN_RESET,
        ID_STEXT1,           IDH_STEXT,
        ID_STEXT2,           IDH_STEXT,
        ID_STEXT3,           IDH_STEXT,
        ID_TIME_BEGIN,       IDH_STEXT,
        ID_TIME_INTER,       IDH_STEXT,
        ID_TIME_EXPERT,      IDH_STEXT,
        ID_NAME_BEGIN,       IDH_STEXT,
        ID_NAME_INTER,       IDH_STEXT,
        ID_NAME_EXPERT,      IDH_STEXT,

        0,0 }; 

	switch (message)
		{
	case WM_INITDIALOG:
LReset:	
		SetDText(hDlg, ID_TIME_BEGIN, Preferences.rgTime[wGameBegin], Preferences.szBegin);
		SetDText(hDlg, ID_TIME_INTER, Preferences.rgTime[wGameInter],  Preferences.szInter);
		SetDText(hDlg, ID_TIME_EXPERT, Preferences.rgTime[wGameExpert], Preferences.szExpert);
		return (fTrue);

	case WM_COMMAND:
		switch(GET_WM_COMMAND_ID(wParam, lParam)) {
		case ID_BTN_RESET:
			Preferences.rgTime[wGameBegin] = Preferences.rgTime[wGameInter]
				= Preferences.rgTime[wGameExpert] = 999;
			lstrcpy(Preferences.szBegin,  szDefaultName);
			lstrcpy(Preferences.szInter,  szDefaultName);
			lstrcpy(Preferences.szExpert, szDefaultName);
			fUpdateIni = fTrue;
			goto LReset;
			
		case ID_BTN_OK:
		case IDOK:
		case ID_BTN_CANCEL:
		case IDCANCEL:
			EndDialog(hDlg, fTrue);	      /* Exits the dialog box	     */
			return fTrue;

		default:
			break;
			}
        break;

    // context sensitive help.
    case WM_HELP: 
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("winmine.hlp"), 
                HELP_WM_HELP, (ULONG_PTR) aIds);         
        break;  

    case WM_CONTEXTMENU: 
        WinHelp((HWND) wParam, TEXT("winmine.hlp"), HELP_CONTEXTMENU, 
                (ULONG_PTR) aIds);         
        break;   
		}

	return (fFalse);			/* Didn't process a message    */
}



/****** E N T E R  D L G  P R O C ******/

INT_PTR  APIENTRY EnterDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

	switch (message)
		{
	case WM_INITDIALOG:
		{
		TCHAR sz[cchMsgMax];

		LoadSz((WORD)(Preferences.wGameType+ID_MSG_BEGIN), sz, ARRAYSIZE(sz));

		SetDlgItemText(hDlg, ID_TEXT_BEST, sz);

		SendMessage(GetDlgItem(hDlg, ID_EDIT_NAME), EM_SETLIMITTEXT, cchNameMax, 0L);

		SetDlgItemText(hDlg, ID_EDIT_NAME,
			(Preferences.wGameType == wGameBegin) ? Preferences.szBegin :
			(Preferences.wGameType == wGameInter) ? Preferences.szInter :
			 Preferences.szExpert);
		}
		return (fTrue);

	case WM_COMMAND:
		switch(GET_WM_COMMAND_ID(wParam, lParam)) {
		case ID_BTN_OK:
		case IDOK:
		case ID_BTN_CANCEL:
		case IDCANCEL:

			GetDlgItemText(hDlg, ID_EDIT_NAME,
				(Preferences.wGameType == wGameBegin) ? Preferences.szBegin :
				(Preferences.wGameType == wGameInter) ? Preferences.szInter :
				 Preferences.szExpert, cchNameMax);

			EndDialog(hDlg, fTrue);	      /* Exits the dialog box	     */
			return fTrue;

		default:
			break;
			}
		}

	return (fFalse);			/* Didn't process a message    */
        (lParam);
}





/****** A D J U S T  W I N D O W ******/

// Our verion of GetSystemMetrics
// 
// Tries to return whole screen (include other monitor) info
//

INT OurGetSystemMetrics( INT nIndex )
{
    INT Result=0;

    switch( nIndex )
    {
    case SM_CXSCREEN:
        Result= GetSystemMetrics( SM_CXVIRTUALSCREEN );
        if( !Result )
            Result= GetSystemMetrics( SM_CXSCREEN );
        break;

    case SM_CYSCREEN:
        Result= GetSystemMetrics( SM_CYVIRTUALSCREEN );
        if( !Result )
            Result= GetSystemMetrics( SM_CYSCREEN );
        break;

    default:
        Result= GetSystemMetrics( nIndex );
        break;
    }

    return( Result );
}

VOID AdjustWindow(INT fAdjust)
{
	REGISTER t;
	RECT rect;
    BOOL bDiffLevel = FALSE;
    RECT rectGame, rectHelp;

	// an extra check
	if (!hwndMain)
		return;

	dypAdjust = dypCaption;

	if (FMenuOn())
        {
        // dypMenu is initialized to GetSystemMetrics(SM_CYMENU) + 1,
        // which is the height of one menu line
        dypAdjust += dypMenu;

        // If the menu extends on two lines (because of the large-size
        // font the user has chosen for the menu), increase the size
        // of the window.

        // The two menus : "Game" and "Help" are on the same line, if
        // their enclosing rectangles top match. In that case, we don't
        // need to extend the window size.
        // If the tops do not match, that means they are on two lines.
        // In that case, extend the size of the window by size of
        // one menu line.
       
        if (hMenu && GetMenuItemRect(hwndMain, hMenu, 0, &rectGame) &&
                GetMenuItemRect(hwndMain, hMenu, 1, &rectHelp))
            {
            if (rectGame.top != rectHelp.top)
                {
                dypAdjust += dypMenu;
                bDiffLevel = TRUE;
                }
            }
        }

	dxWindow = dxBlk * xBoxMac + dxGridOff + dxRightSpace;
	dyWindow = dyBlk * yBoxMac + dyGridOff + dyBottomSpace;

	if ((t = Preferences.xWindow+dxWindow - OurGetSystemMetrics(SM_CXSCREEN)) > 0)
		{
		fAdjust |= fResize;
		Preferences.xWindow -= t;
		}

	if ((t = Preferences.yWindow+dyWindow - OurGetSystemMetrics(SM_CYSCREEN)) > 0)
		{
		fAdjust |= fResize;
		Preferences.yWindow -= t;
		}

    if (!bInitMinimized)
        {
    	if (fAdjust & fResize)
    		{
    		MoveWindow(hwndMain, Preferences.xWindow, Preferences.yWindow,
    			dxWindow+dxpBorder, dyWindow + dypAdjust, fTrue);
    		}

        // after the window is adjusted, the "Game" and "Help" may move to the
        // same line creating extra space at the bottom. so check again!

        if (bDiffLevel && hMenu && GetMenuItemRect(hwndMain, hMenu, 0, &rectGame) &&
                GetMenuItemRect(hwndMain, hMenu, 1, &rectHelp))
            {
            if (rectGame.top == rectHelp.top)
                {
                dypAdjust -= dypMenu;
    		    MoveWindow(hwndMain, Preferences.xWindow, Preferences.yWindow,
    			    dxWindow+dxpBorder, dyWindow + dypAdjust, fTrue);
                }
            }
       
    	if (fAdjust & fDisplay)
    		{
    		SetRect(&rect, 0, 0, dxWindow, dyWindow);
    		InvalidateRect(hwndMain, &rect, fTrue);
    		}


        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\cpanel.h ===
#ifndef __PCONTROL_H__
#define __PCONTROL_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "fvscodes.h"    // FVS_xxxxxx (font validation status) codes & macros.
                         // \nt\private\windows\shell\control\t1instal\fvscodes.h

//
//  Global definitions
//
//
// Note for file macros below.
// The LZxxx functions are no longer used in the macro substitutions.
// The need to use LZxxx implementations is a function of the file type, not
// the target platform.  Wherever LZxxx functions are required, they
// are now used explicitely.
//

#ifdef WINNT

#define FOPEN( sz, lpsz )        MyOpenFile( sz, lpsz, OF_READ )
#define FREAD( fh, buf, len )    MyAnsiReadFile( fh, CP_ACP, buf, len )
#define FWRITE( fh, buf, len )   MyAnsiWriteFile( fh, CP_ACP, buf, len )
#define FREADBYTES(fh,buf,len)   MyByteReadFile( fh, buf, len )
#define FWRITEBYTES(fh,buf,len)  MyByteWriteFile( fh, buf, len )

#define FSEEK( fh, off, i )      MyFileSeek( fh, (DWORD) off, i )
#define FCLOSE( fh )             MyCloseFile( fh )
#define FCREATE( sz )            MyOpenFile( sz, NULL, OF_READWRITE | OF_CREATE )

#else

#define FOPEN( sz )              _lopen( sz, OF_READ )
#define FCLOSE( fh )             _lclose( fh )
#define FREAD( fh, buf, len )    _lread( fh, buf, len )
#define FREADBYTES(fh, buf, len) _lread( fh, buf, len )
#define FSEEK( fh, off, i )      _llseek( fh, (DWORD) off, i )

#define FCREATE( sz )            _lcreat( sz, 0 )
#define FWRITE( fh, buf, len )   _lwrite( fh, buf, len )
#define FWRITEBYTES(fh, buf, len) _lwrite( fh, buf, len )

#endif  //  WINNT



//
//  Global variables
//

extern  FullPathName_t e_szDirOfSrc;
extern  UINT s_wBrowseDoneMsg;


//
//  Flags for ReadLine
//

#define  RL_MORE_MEM       -1
#define  RL_SECTION_END    -2

#define  SEEK_BEG           0
#define  SEEK_CUR           1
#define  SEEK_END           2

#define  PRN               148
#define  MON_OF_YR         276
#define  MOUSE           MON_OF_YR+48
#define  INSTALL         MOUSE+16


//
//  Font file types used in Fonts applet - installation
//

#define NOT_TT_OR_T1        0       //  Neither TrueType or Type 1 font (FALSE)
#define TRUETYPE_FONT       1       //  This is a TrueType font (TRUE)
#define TYPE1_FONT          2       //  This is an Adobe Type1 font
#define TYPE1_FONT_NC       3       //  Type1 font that cannot be converted to TT
#define OPENTYPE_FONT       4       //  Font is OpenType.

//
//  Font file types used in Fonts applet - Main dlg "Installed Fonts" lbox
//

#define IF_OTHER            0       //  TrueType or Bitmap 1 font (FALSE)
#define IF_TYPE1            1       //  Adobe Type1 font
#define IF_TYPE1_TT         2       //  Matching TT font for Adobe Type1 font

#define T1_MAX_DATA     (2 * PATHMAX + 6)

//
//  Return codes from InstallT1Font routine
//

#define TYPE1_INSTALL_IDOK       IDOK        //  User pressed OK from MessageBox error
#define TYPE1_INSTALL_IDYES      IDYES       //  Same as IDOK
#define TYPE1_INSTALL_IDNO       IDNO        //  Font not installed - user pressed NO
#define TYPE1_INSTALL_IDCANCEL   IDCANCEL    //  Entire installation cancelled
#define TYPE1_INSTALL_PS_ONLY     10         //  Only the PS Font installed.
#define TYPE1_INSTALL_PS_AND_MTT  11         //  PostScript Font installed and matching
                                             //   TT font already installed.
#define TYPE1_INSTALL_TT_AND_PS   12         //  PS Font installed and converted to TT.
#define TYPE1_INSTALL_TT_ONLY     13         //  PS Font converted to TT only.
#define TYPE1_INSTALL_TT_AND_MPS  14         //  PS Font converted to TT and matching
                                             //   PS font already installed.
//
//  Global functions
//

//
//  append.cpp
//

BOOL FAR PASCAL fnAppendSplitFiles( LPTSTR FAR *, LPTSTR, int );

//
//  instfls.c
//

typedef int (FAR PASCAL *INSTALL_PROC)(HWND hDlg, WORD wMsg, int i,
             LPTSTR FAR *pszFiles, LPTSTR lpszDir );

#define IFF_CHECKINI  0x0001
#define IFF_SRCANDDST 0x0002

#define IF_ALREADY_INSTALLED    1
#define IF_ALREADY_RUNNING      2
#define IF_JUST_INSTALLED       3

PTSTR  FAR PASCAL CopyString( LPTSTR szStr );
PTSTR  FAR PASCAL MyLoadString( WORD wId );
LPTSTR FAR PASCAL CpyToChr( LPTSTR pDest, LPTSTR pSrc, TCHAR cChr, int iMax );

VOID FAR PASCAL GetDiskAndFile( LPTSTR pszInf,
                                short /* int */ FAR *nDsk,
                                LPTSTR pszDriver,
                                WORD wSize );

DWORD FAR PASCAL InstallFiles( HWND hwnd, LPTSTR FAR *pszFiles, int nCount,
                               INSTALL_PROC lpfnNewFile, WORD wFlags );

//
//  PFONT.CPP
//

extern VOID NEAR PASCAL vConvertExtension( LPTSTR pszFile,  LPTSTR szExt );

class CFontManager;
extern BOOL FAR PASCAL bCPAddFonts( HWND ma );

#define CPDI_CANCEL  -1
#define CPDI_FAIL     0
#define CPDI_SUCCESS  1

extern int FAR PASCAL CPDropInstall( HWND hwndParent,
                                     LPTSTR szFile,
                                     DWORD  dwEffect,
                                     LPTSTR lpszDestName = NULL,
                                     int    iCount = 0 );

extern VOID FAR  PASCAL vCPDeleteFromSharedDir( LPTSTR pszFileOnly );
extern VOID FAR  PASCAL vCPFilesToDescs( );
extern BOOL NEAR PASCAL bUniqueOnSharedDir( LPTSTR lpszDst,  LPTSTR lpszSrc );
extern VOID NEAR PASCAL vHashToNulls( LPTSTR lpStr );
extern BOOL FAR  PASCAL bUniqueFilename (LPTSTR lpszDst, LPTSTR lpszSrc, LPTSTR lpszDir);

//
//  cpsetup.c
//

typedef WORD (*LPSETUPINFPROC)( LPTSTR, LPVOID );
extern DWORD ReadSetupInfSection( LPTSTR pszInfPath,
                                  LPTSTR pszSection,
                                  LPTSTR *ppszSectionItems );


extern WORD ReadSetupInfCB( LPTSTR pszInfPath,
                            LPTSTR pszSection,
                            LPSETUPINFPROC,
                            LPVOID pData);

extern int    FAR PASCAL ReadSetupInfIntoLBs( HWND hLBName,
                                              HWND hLBDBase,
                                              WORD wAddMsg,
                                              LPTSTR pszSection,
                                              WORD (FAR PASCAL *lpfnGetName)(LPTSTR, LPTSTR) );

//
//  PINSTALL.CPP
//

extern BOOL FAR PASCAL bCPInstallFile( HWND hwndParent,
                                       LPTSTR lpDir,
                                       LPTSTR lpFrom,
                                       LPTSTR lpTo );

//
//  PFILES.CPP
//

extern BOOL FAR PASCAL bCPValidFontFile( LPTSTR lpszFile,
                                         LPTSTR lpszDesc = NULL,
                                         WORD FAR *lpwType = NULL,
                                         BOOL bFOTOK = FALSE,
                                         LPDWORD lpdwStatus = NULL);
//
//  PUTIL.CPP
//

extern BOOL FAR PASCAL bCPSetupFromSource( );
extern BOOL FAR PASCAL bCPIsHelp( WORD message );
extern BOOL FAR PASCAL bCPIsBrowseDone( WORD message );
extern RC   FAR PASCAL rcCPLoadFontList( );
extern VOID FAR PASCAL vCPHelp( HWND );
extern VOID FAR PASCAL vCPStripBlanks( LPTSTR lpszString );
extern VOID FAR PASCAL vCPUpdateSourceDir( );
extern VOID FAR PASCAL vCPWinIniFontChange( );
extern VOID FAR PASCAL vCPPanelInit( );
extern LPTSTR FAR PASCAL lpCPBackSlashTerm( LPTSTR lpszPath );
extern BOOL bFileIsInFontsDirectory(LPCTSTR lpszPath);
extern int FAR PASCAL DoDialogBoxParam( int nDlg,
                                        HWND hParent,
                                        DLGPROC lpProc,
                                        DWORD dwHelpContext,
                                        LPARAM dwParam);

#ifdef WINNT
extern HANDLE PASCAL wCPOpenFileWithShare( LPTSTR, LPTSTR, WORD );
#else
extern WORD FAR PASCAL wCPOpenFileWithShare( LPTSTR, LPOFSTRUCT, WORD );
#endif  //  WINNT

extern UINT MyAnsiReadFile( HANDLE  hFile,
                            UINT uCodePage,
                            LPVOID  lpUnicode,
                            DWORD  cchUnicode );

extern UINT MyAnsiWriteFile( HANDLE  hFile,
                             UINT uCodePage,
                             LPVOID lpUnicode,
                             DWORD cchUnicode );

extern UINT   MyByteReadFile( HANDLE  hFile, LPVOID lpBuffer, DWORD nBytes );
extern UINT   MyByteWriteFile( HANDLE hFile, LPVOID lpBuffer, DWORD nBytes );
extern BOOL   MyCloseFile( HANDLE  hFile );
extern LONG   MyFileSeek( HANDLE hFile, LONG lDistanceToMove, DWORD dwMoveMethod );
extern HANDLE MyOpenFile( LPTSTR lpszFile, TCHAR * lpszPath, DWORD fuMode );

VOID  CentreWindow( HWND hwnd );


typedef struct _StringObject {
   HANDLE   h;
   DWORD    dwLen;
} StringObject;

extern BOOL FAR PASCAL AddStringToObject( StringObject&, LPTSTR, WORD );

#define ASO_GLOBAL  0x0001
#define ASO_FIXED   0x0002
#define ASO_EXACT   0x0004
#define ASO_COMPACT 0x0008


#ifdef ROM
extern HANDLE FAR PASCAL IsROMModule( LPTSTR lpName, BOOL fSelector );
#endif


LPVOID AllocMem( DWORD cb );
BOOL   FreeMem( LPVOID pMem, DWORD  cb );
LPVOID ReallocMem( LPVOID lpOldMem, DWORD cbOld, DWORD cbNew );
LPTSTR AllocStr( LPTSTR lpStr );
BOOL   FreeStr( LPTSTR lpStr );
BOOL   ReallocStr( LPTSTR *plpStr, LPTSTR lpStr );


/* t1.cpp */

BOOL CheckT1Install( LPTSTR pszDesc, LPTSTR pszData );
BOOL DeleteT1Install( HWND hwndParent, LPTSTR pszDesc, BOOL bDeleteFiles );
BOOL EnumType1Fonts( HWND hLBox );
BOOL GetT1Install( LPTSTR pszDesc, LPTSTR pszPfmFile, LPTSTR pszPfbFile );
int  InstallT1Font( HWND hwndParent, BOOL bCopyTTFile, BOOL bCopyType1Files,
                    BOOL bInSharedDir, LPTSTR szPfmName, LPTSTR szDesc );

HWND InitProgress( HWND hwnd );
BOOL InstallCancelled(void);
void InitPSInstall( );
BOOL IsPSFont( LPTSTR lpszKey, LPTSTR lpszDesc, LPTSTR lpszPfm, LPTSTR lpszPfb,
               BOOL *pbCreatedPFM, LPDWORD lpdwStatus = NULL );

BOOL OkToConvertType1ToTrueType(LPCTSTR pszFontDesc, LPCTSTR pszPFB, HWND hwndParent);

BOOL ExtractT1Files( LPTSTR pszMulti, LPTSTR pszPfmFile, LPTSTR pszPfbFile );
void Progress2( int PercentDone, LPTSTR szDesc );
void RemoveDecoration( LPTSTR pszDesc, BOOL bDeleteTrailingSpace );
void ResetProgress( );
void TermProgress( );
void TermPSInstall( );
void UpdateProgress( int iTotalCount, int iFontInstalling, int iProgress );

BOOL WriteType1RegistryEntry( HWND hwndParent, LPTSTR szDesc, LPTSTR szPfmName,
                              LPTSTR szPfbName, BOOL bInFontsDir );

HWND GetFirstAncestor( HWND hWnd );

#ifdef WINNT
BOOL BuildType1FontResourceName(LPCTSTR pszPfm, LPCTSTR pszPfb,
                                  LPTSTR pszDest, DWORD cchDest);

#define MAX_TYPE1_FONT_RESOURCE  (MAX_PATH * 2)  // 2 paths + separator.
#endif // WINNT

#ifdef __cplusplus
}
#endif

#endif

/****************************************************************************
 * $lgb$
 * 1.0     7-Mar-94   eric Initial revision.
 * $lge$
 *
 ****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\dbutl.h ===
/***************************************************************************
 * dbutl.h -- Debugging utilities. 
 *
 *
 ***************************************************************************/

#if !defined(__DBUTL_H__)
#define __DBUTL_H__

// ********************************************************************
// Write a debug message to the debugger or a file
//
#define DM_ERROR          0x0001
#define DM_TRACE1         0x0002  // interface call tracing (except for messages)
#define DM_TRACE2         0x0004  // status type stuff.  These messages only
                                  // make sense with DM_TRACE1 enabled
#define DM_MESSAGE_TRACE1  0x0008  // message tracing
#define DM_MESSAGE_TRACE2 0x0010  // trace all messages (processed or not)
#define DM_NOW            0x0020  // Used for temp debugging during dev.
#define DM_NOEOL          0x1000 // don't follow the message with a \r\n

#ifdef _DEBUG
#include <assert.h>

#define DEBUGBREAK      DebugBreak()
#define DEBUGMSG(a)     DebugMessage a
#define DEBUGHRESULT(a) DebugHRESULT a
#define DEBUGREFIID(a)  DebugREFIID a

void DebugMessage(UINT mask, LPCTSTR pszMsg, ... );
void DebugHRESULT(int flags, HRESULT hResult);
void DebugREFIID(int flags, REFIID riid);

#define ASSERT(a)    assert((a))

#else
#define DEBUGBREAK
#define DEBUGMSG(a)
#define DEBUGHRESULT(a)
#define DEBUGREFIID(a)
#define ASSERT(a)
#endif


#endif // __DBUTL_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\extinit.h ===
/**********************************************************************
 * ExtInit.h - Definition for the CShellExtInit, our implementation for
 *             IShellExtInit.
 *
 **********************************************************************/

#if !defined(__EXTINIT_H__)
#define __EXTINIT_H__

class CShellExtInit : public IShellExtInit, public IContextMenu,
   public IShellPropSheetExt
{
public:
   CShellExtInit();
   ~CShellExtInit();
   BOOL bInit();

   // *** IUnknown methods ***

   STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   // *** IShellExtInit methods ***

   STDMETHODIMP Initialize( LPCITEMIDLIST pidlFolder,
                            LPDATAOBJECT lpdobj,
                            HKEY hkeyProgID);

   // ** IContextMenu methods ***

   STDMETHODIMP QueryContextMenu( HMENU hmenu,
                                  UINT indexMenu,
                                  UINT idCmdFirst,
                                  UINT idCmdLast,
                                  UINT uFlags);

   STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

   STDMETHODIMP GetCommandString( UINT_PTR idCmd,
                                  UINT   uFlags,
                                  UINT  *pwReserved,
                                  LPSTR  pszName,
                                  UINT   cchMax);

   // ***IShellPropSheet Ext ***
   //
   STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
   STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);


private:
   // Data for IUnknown
   //
   ULONG          m_cRef;

   // Data for IShellExtInit
   //
   LPDATAOBJECT   m_poData;
};


#endif // __EXTINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\extricon.h ===
#ifndef __EXTRICON_H__
#define __EXTRICON_H__
///////////////////////////////////////////////////////////////////////////////
/*  File: extricon.h

    Description: Contains implementation of IExtractIcon for the font folder.
        This code provides icon identification for both TrueType and OpenType
        font files.  The logic used is as follows:
        
            TrueType(1)  DSIG?   CFF?    Icon
            ------------ ------- ------- -----------
            yes          no      no      TT
            yes          no      yes     OTp
            yes          yes     no      OTt
            yes          yes     yes     OTp

        (1) Files must contain required TrueType tables to be considered
            a TrueType font file.

        This icon handler is used by both the shell and the font folder
        to display TrueType and OpenType font icons.  It is designed to be
        easily extensible if support for dynamic icon identification is
        required in other fonts.

        Classes (indentation denotes inheritance):

            CFontIconHandler
            IconHandler
                TrueTypeIconHandler
               

        NOTE:  The design is sort of in a state of limbo right now.  Originally
               the idea was to support two types of OpenType icons along with
               the conventional TrueType and raster font icons.  The OpenType
               icons were OTt and OTp with the 't' and 'p' meaning "TrueType"
               and "PostScript".  Later we decided to only show the icons as
               "OT" without the subscript 't' or 'p'.  The code still distinguishes
               the difference but we just use the same "OT" icon for both the
               OTt and OTp conditions.  Make sense?  Anyway, This OTt and OTp
               stuff may come back at a later date (GDI guys haven't decided)
               so I'm leaving that code in place. [brianau - 4/7/98]

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/13/97    Initial creation.                                    BrianAu
    04/08/98    Removed OpenTypeIconHandler and folded it into       BrianAu
                TrueTypeIconHandler.  There's no need for the 
                separation.  Also added detection of "required"
                TrueType tables.
*/
///////////////////////////////////////////////////////////////////////////////

//
// Pure virtual base class for all types of icon handlers.
//
class IconHandler
{
    public:
        //
        // Simple encapsulation of a mapped file for opening font files.
        //
        class MappedFile
        {
            public:
                MappedFile(VOID)
                    : m_hFile(INVALID_HANDLE_VALUE),
                      m_hFileMapping(INVALID_HANDLE_VALUE),
                      m_pbBase(NULL) { }

                ~MappedFile(VOID);
                HRESULT Open(LPCTSTR pszFile);
                VOID Close(VOID);

                LPBYTE Base(VOID)
                    { return m_pbBase; }

            private:
                HANDLE m_hFile;
                HANDLE m_hFileMapping;
                LPBYTE m_pbBase;

                //
                // Prevent copy.
                //
                MappedFile(const MappedFile& rhs);
                MappedFile& operator = (const MappedFile& rhs);
        };

        virtual ~IconHandler(VOID) { };
        //
        // Derived classes implement this to retrieve the index (ID) of the 
        // desired icon in fontext.dll.
        //
        virtual INT GetIconIndex(LPCTSTR pszFileName) = 0;
        //
        // Derived classes implement this to retrieve the large and small
        // icons corresponding to an index.  The index should be one returned
        // from GetIconIndex().
        //
        virtual HRESULT GetIcons(UINT iIconIndex, HICON *phiconLarge, HICON *phiconSmall) = 0;
        //
        // This static function creates an icon handler object of the proper
        // derived type for the font file extension specified in pszFileExt.
        //
        static IconHandler *Create(LPCTSTR pszFile);
};

/*
//
// This is a template for creating a new type of icon handler for 
// other types of font files. 
//
// To create a new handler:
// 1. Create new handler class from template below.
// 2. Provide implementations for GetIconIndex and GetIcons.
// 3. Load icons in constructor.  See OpenTypeIconHandler as an example.
// 4. Modify IconHandler::Create() to instantiate the new handler type.
//
class XXXXIconHandler : public IconHandler
{
    public:
        XXXXIconHandler(VOID);
        virtual INT GetIconIndex(LPCTSTR pszFileName);
        virtual HRESULT GetIcons(UINT iIconIndex, HICON *phiconLarge, HICON *phiconSmall);

    private:
        static HICON m_hiconLarge;
        static HICON m_hiconSmall;
};
*/    


//
// Icon handler for TrueType font files.
//
class TrueTypeIconHandler : public IconHandler
{
    public:
        TrueTypeIconHandler(DWORD dwTables);
        ~TrueTypeIconHandler(void);

        virtual INT GetIconIndex(LPCTSTR pszFileName);
        virtual HRESULT GetIcons(UINT iIconIndex, HICON *phiconLarge, HICON *phiconSmall);
        //
        // Scans TTF or OTF file identifying tables.
        // Used by TrueTypeIconHandler and any subclasses.
        //
        static BOOL GetFileTables(LPCTSTR pszFile, LPDWORD pfTables);

        enum TABLES { 
                         //
                         // These are the only tables we're interested in.
                         //
                         TABLE_CFF  = 0x00000001,
                         TABLE_DSIG = 0x00000002,
                         TABLE_HEAD = 0x00000004,
                         TABLE_NAME = 0x00000008,
                         TABLE_CMAP = 0x00000010,
                         TABLE_HHEA = 0x00000020,
                         TABLE_HMTX = 0x00000040,
                         TABLE_OS2  = 0x00000080,
                         TABLE_POST = 0x00000100,
                         TABLE_GLYF = 0x00000200,
                         TABLE_MAXP = 0x00000400,
                         TABLE_LOCA = 0x00000800,
                         TABLE_TTCF = 0x00001000  // this is a pseudo table.
                    };

        static DWORD RequiredOpenTypeTables(void)
            { return (TABLE_CMAP |
                      TABLE_HEAD |
                      TABLE_HHEA |
                      TABLE_HMTX |
                      TABLE_MAXP |
                      TABLE_NAME |
                      TABLE_POST |
                      TABLE_OS2); }

        static DWORD RequiredTrueTypeTables(void)
            { return (RequiredOpenTypeTables() |
                      TABLE_GLYF |
                      TABLE_LOCA); }

    protected:
        enum eIcons {iICON_LARGE_TT,
                     iICON_SMALL_TT,
                     iICON_LARGE_OTt,
                     iICON_SMALL_OTt,
                     iICON_LARGE_OTp,
                     iICON_SMALL_OTp,
                     iICON_LARGE_TTC,
                     iICON_SMALL_TTC,
                     MAX_ICONS };

        DWORD m_dwTables;
        HICON m_rghIcons[MAX_ICONS]; // Array of icon handles.

    private:
        static BOOL ReadFileTables(IconHandler::MappedFile& file, LPDWORD pfTables);
        static INT FilterReadFileTablesException(INT nException);
        HICON GetIcon(int iIcon);
};


//
// Declaration for the DLL's icon handler.
// This is the object that is instantiated whenever a client asks CLSID_FontExt 
// for IID_IExtractIcon or IID_IPersistFile.
//
class CFontIconHandler : public IExtractIconW, 
                         public IExtractIconA, 
                         public IPersistFile
{
    public:
        CFontIconHandler(VOID);
        ~CFontIconHandler(VOID);

        //
        // IUnknown methods.
        //
        STDMETHODIMP
        QueryInterface(
            REFIID riid,
            LPVOID *ppvOut);

        STDMETHODIMP_(ULONG)
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG)
        Release(
            VOID);

        //
        // IExtractIconW methods.
        //
        STDMETHODIMP Extract(
            LPCWSTR pszFileW,
            UINT nIconIndex,
            HICON *phiconLarge,
            HICON *phiconSmall,
            UINT nIconSize);

        STDMETHODIMP GetIconLocation(
            UINT uFlags,
            LPWSTR szIconFileW,
            UINT cchMax,
            int *piIndex,
            UINT *pwFlags);

        //
        // IExtractIconA methods.
        //
        STDMETHODIMP Extract(
            LPCSTR pszFileA,
            UINT nIconIndex,
            HICON *phiconLarge,
            HICON *phiconSmall,
            UINT nIconSize);

        STDMETHODIMP GetIconLocation(
            UINT uFlags,
            LPSTR szIconFileA,
            UINT cchMax,
            int *piIndex,
            UINT *pwFlags);

        //
        // IPersist methods.
        //
        STDMETHODIMP GetClassID(
            CLSID *pClassID);

        //
        // IPersistFile methods.
        //
        STDMETHODIMP IsDirty(
            VOID);

        STDMETHODIMP Load(
            LPCOLESTR pszFileName,
            DWORD dwMode);

        STDMETHODIMP Save(
            LPCOLESTR pszFileName,
            BOOL fRemember);

        STDMETHODIMP SaveCompleted(
            LPCOLESTR pszFileName);

        STDMETHODIMP GetCurFile(
            LPOLESTR *ppszFileName);

    private:
        LONG         m_cRef;
        TCHAR        m_szFileName[MAX_PATH];    // Name of icon file.
        IconHandler *m_pHandler;                // Ptr to type-specific handler.
        static TCHAR m_szFontExtDll[MAX_PATH];  // Path to FONTEXT.DLL

        INT GetIconIndex(VOID);
        HRESULT GetIcons(UINT iIconIndex, HICON *phiconLarge, HICON *phiconSmall);
};

#endif // __EXTRICON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\fdir.h ===
/***************************************************************************
 * fdir.h -- Interface for the class: CFontDir
 *
 *
 * Copyright (C) 1992-93 ElseWare Corporation.    All rights reserved.
 ***************************************************************************/

#if !defined(__FDIR_H__)
#define __FDIR_H__

#include "vecttmpl.h"

#define MAX_DIR_LEN             MAX_PATH  /* MAX_PATH_LEN */

typedef TCHAR DIRNAME[ MAX_DIR_LEN + 1 ];


class CFontDir {
public:
   CFontDir();
   virtual ~CFontDir();

   BOOL     bInit( LPCTSTR lpPath, int iLen);
   BOOL     bSameDir( LPTSTR lpStr, int iLen );
   BOOL     bOnSysDir() { return m_bSysDir; };
   VOID     vOnSysDir( BOOL b ) { m_bSysDir = b; };
   LPTSTR   lpString();

private: 
   int      m_iLen;
   BOOL     m_bSysDir;
   DIRNAME  m_oPath;
};

//
// Class representing a dynamic array of CFontDir object ptrs.
// Implemented as a singleton object through the static member
// function GetSingleton.
//
// History:  
//     In the original font folder code (as written for Win95), 
//     this directory list was implemented as a simple derivation 
//     from CIVector<CFontDir> with a single instance allocated 
//     on the heap and attached to the static member variable 
//     CFontClass::s_poDirList.  There was no code to delete
//     this instance so we had a memory leak.  To fix this I've
//     replaced this instance with a true Singleton object.  
//     Class CFontDirList is that singleton.  Memory management 
//     is now correct.
//     [brianau - 2/27/01]
//
class CFontDirList
{
    public:
        ~CFontDirList(void);

        void Clear(void);
        BOOL Add(CFontDir *poDir);
        CFontDir *Find(LPTSTR pszPath, int iLen, BOOL bAdd = FALSE);
        BOOL IsEmpty(void) const;
        int Count(void) const;
        CFontDir *GetAt(int index) const;
        //
        // Singleton access function.
        //
        static BOOL GetSingleton(CFontDirList **ppDirList);

    private:
        //
        // Dynamic vector holding CFontDir ptrs.
        //
        CIVector<CFontDir> *m_pVector;
        //
        // Ctor is private to enforce singleton usage.
        //
        CFontDirList(void);
};        



#endif   // __FDIR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\fontdir.h ===
#ifndef __FONTDIR_H__
#define __FONTDIR_H__

/* font file header (Adaptation Guide section 6.4) */

typedef struct {
    WORD     dfVersion;         /* not in FONTINFO */
    DWORD    dfSize;            /* not in FONTINFO */
    BYTE     dfCopyright[60];   /* not in FONTINFO */
    WORD     dfType;
    WORD     dfPoints;
    WORD     dfVertRes;
    WORD     dfHorizRes;
    WORD     dfAscent;
    WORD     dfInternalLeading;
    WORD     dfExternalLeading;
    BYTE     dfItalic;
    BYTE     dfUnderline;
    BYTE     dfStrikeOut;
    WORD     dfWeight;
    BYTE     dfnCharSet;
    WORD     dfPixWidth;
    WORD     dfPixHeight;
    BYTE     dfPitchAndFamily;
    WORD     dfAvgWidth;
    WORD     dfMaxWidth;
    BYTE     dfFirstChar;
    BYTE     dfLastChar;
    BYTE     dfDefaultCHar;
    BYTE     dfBreakChar;
    WORD     dfWidthBytes;
    DWORD    dfDevice;          /* See Adaptation Guide 6.3.10 and 6.4 */
    DWORD    dfFace;            /* See Adaptation Guide 6.3.10 and 6.4 */
    DWORD    dfBitsPointer;     /* See Adaptation Guide 6.3.10 and 6.4 */
} FFH;

/*
    The lpFDirEntry is a string corresponding to the resource
    index (two bytes) prepended to an Fontdefs.h FFH structure, with device
    and face name strings appended
    First word is number of fonts, skip to first font resource name
*/

typedef struct {
    WORD    dfFontCount;        /* Overall info */
    WORD    dfSkipper;          /* ?? */
    FFH     xFFH;
    char    cfFace;
} FFHWRAP, FAR* LPFHHWRAP;

#endif



/****************************************************************************
 * $lgb$
 * 1.0     7-Mar-94   eric Initial revision.
 * $lge$
 *
 ****************************************************************************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\fontcl.h ===
/***************************************************************************
 * fontcl.h - declarations for the font class and it related buddies:
 *
 *       PANOSEBytesClass  - The list of decoded PANOSE bytes
 *       PANOSENumClass    - The PANOSE number
 *       DirFilenameClass   - Directory slot and filename
 *       CFontClass         - Font class itself
 *
 * Copyright (C) 1992-93 ElseWare Corporation.   All rights reserved.
 ***************************************************************************/

#ifndef __FONTCL_H__
#define __FONTCL_H__

#include <stdio.h>
#include <string.h>

#if !defined(__FDIR_H__)
#include "fdir.h"
#endif


/*************************************************************************
 * PANOSE definitions.
 *************************************************************************/

#define NUM_PAN_DIGITS        10
#define PANOSE_LEN            10
#define PANOSE_ANY            0
#define PANOSE_NOFIT          1

#define FAMILY_LATTEXT        2

/***************************************************************************
 * LATIN TEXT PANOSE INDICES
 *
 * Indices into an array containing the standard 10-digit PANOSE number.
 ***************************************************************************/

#define PAN_IND_FAMILY         0
#define PAN_IND_SERIF          1
#define PAN_IND_WEIGHT         2
#define PAN_IND_PROPORTION     3
#define PAN_IND_CONTRAST       4
#define PAN_IND_STROKE         5
#define PAN_IND_ARMSTYLE       6
#define PAN_IND_LTRFORM        7
#define PAN_IND_MIDLINE        8
#define PAN_IND_XHEIGHT        9
#define PAN_IND__LAST          9

/***************************************************************************
 * PURPOSE:  Check a 10-digit PANOSE for validity.  We just look for any
 *           PANOSE_ANY's and disqualify it if we find one.  We probably should]
 *           also check for digits greater than DIGIT__LAST.
 ***************************************************************************/

class far PANOSEBytesClass {
public :
    PANOSEBytesClass ()        {   vClear (); };
    VOID  vClear  ()           { for( int i = 0; i < PANOSE_LEN; i++ )
                                     m_ajBytes[i] = PANOSE_NOFIT; };
    BOOL  bVerify ()           {  for( int i = 0; i < PANOSE_LEN; i++ )
                                    if( m_ajBytes[i] == PANOSE_ANY )
                                       return FALSE;
                                return TRUE; };
    BYTE  jFamily ()            { return jGet(PAN_IND_FAMILY); };
    BYTE  jGet( int i )         { return m_ajBytes[i]; };

public   : // fields

    BYTE   m_ajBytes[ PANOSE_LEN ];

};  // end PANOSEBytesClass

/* required wrapper */

class far PANOSENumClass {
public :   
   BYTE    m_ajNumMem[ NUM_PAN_DIGITS ];    // m_xNumMem. Old extended pan.
};


/*
 * Path and filename
 */

class far DirFilenameClass
{
public :
    void  vGetFullName( PTSTR pstr );

    void  vGetFileName( PTSTR pstr )      { lstrcpy( pstr, m_szFOnly ); };

    BOOL  bSameFileName( PTSTR pstr )
                            {  return( lstrcmpi( pstr, m_szFOnly ) == 0 ); } ;

    void  vSet (CFontDir * poDir, LPTSTR lps) 
                            {  m_poDir = poDir;
                               lstrcpy( m_szFOnly, lps ); };

    BOOL  bSameName( PTSTR szName )
                           { return lstrcmp( szName, m_szFOnly ) == 0; };
    BOOL  bOnSysDir( )   { return m_poDir->bOnSysDir(); };

private:
    CFontDir *  m_poDir;
    FILENAME    m_szFOnly;      // File name portion only
};

/************************************************************************* 
 * Font record
 */
class far CFontClass {
public   :
         CFontClass   ()
            : m_cRef(0),
              m_bAttributesValid(FALSE) { m_eFileKind = eFKNone; vClear( ); };
         ~CFontClass  () { vFreeFOT( ); }

    ULONG AddRef(void);
    ULONG Release(void);

    static int s_cFonts;
    //
    // WARNING:  This function zeros out the ENTIRE object using memset.
    //          This is so bogus I can't believe the original author did it.
    //          I'm not changing it because I don't want to break anything but
    //          be aware that it's here.  If you introduce a virtual function,
    //          into this class, this call will overwrite your vtable ptr 
    //          with NULL (ugh!).  If you add a non-trivial class as a member,
    //          this function will wipe out any initialization and any vtable
    //          ptr it might contain (double ugh!).  [brianau - 3/24/98]
    //
    void  vClear      ()         { memset( this, 0, sizeof( *this ) );
                                   m_lpszFamName = m_szFamName; };

   /* PANOSE stuff */

    BYTE *lpBasePANOSE( )     { bFillIn(); return (BYTE *)&m_xPANOSE.m_ajBytes;};

//   BOOL  bSameFamily (CFontClass* lpTarget)
//                       { return bMatchFamily(lpTarget->m_jFamily); };
//   BOOL  bMatchFamily   (BYTE f) {   bFillIn(); return m_jFamily == f; };

    BOOL  bLTDFamily( )       { bFillIn(); return m_jFamily == FAMILY_LATTEXT; };
    BOOL  bLTDAndPANOSE( )    { bFillIn(); return /* m_fHavePANOSE && */
                                         bLTDFamily();};

    /**********************************************************************    
     * Name (also Family and filename) stuff 
     */
    BOOL  bSameFileName( PTSTR pStr )  { return m_dirfn.bSameFileName(pStr); };

    BOOL  bGetFQName( LPTSTR lpszName, WORD wLen );

    BOOL  GetFileTime( FILETIME* pft );

    void  GetFileInfo( );

    void  vGetFileName( PTSTR pStr )   { m_dirfn.vGetFileName( pStr );     };

    DWORD dwGetFileAttributes(void);
        
    void InvalidateFileAttributes(void) { m_bAttributesValid = FALSE; }

    void  vGetDirFN( PTSTR pStr )      { m_dirfn.vGetFullName( pStr );     };

    BOOL  bSameDirName( PTSTR pStr )   { return m_dirfn.bSameName( pStr ); };

    RC    rcStoreDirFN ( LPTSTR pStr ) { return rcStoreDirFN (pStr, m_dirfn); };
    
    void  vGetDesc( PTSTR pstr )       { lstrcpy( pstr, m_szFontLHS );   };

    const LPTSTR szGetDesc( )          { return m_szFontLHS; }

    void  vGetName( PTSTR pstr )    { _tcsncpy( pstr, m_szFontLHS, m_wNameLen );
                                      PTSTR p2 = pstr + m_wNameLen; *p2=0; };
                      
    BOOL  bNameOverlap( PTSTR pstr )
                   {  int iLen = lstrlen( pstr );
                      if( iLen > m_wNameLen ) iLen = m_wNameLen;
                      int iCmp = _tcsnicmp( m_szFontLHS, pstr, iLen );
                      return( iCmp == 0 ); } ;
    
    BOOL  bSameName( PTSTR pstr )
                   {  int iCmp = ( lstrlen( pstr ) - m_wNameLen ); 
                      if( iCmp == 0 )
                         iCmp = _tcsnicmp( m_szFontLHS, pstr, m_wNameLen );
                      return iCmp == 0; };
    
    BOOL  bSameDesc( PTSTR pstr ) { return( lstrcmpi( pstr, m_szFontLHS ) == 0 ); };
    
    int   iCompareName( CFontClass* pComp )
             { return _tcsnccmp( m_szFontLHS, pComp->m_szFontLHS, m_wNameLen ); };
    
    void  vGetFamName( PTSTR pstr )  { bFillIn(); lstrcpy (pstr, m_lpszFamName); };

    void  vSetFamName( PTSTR pstr )  { lstrcpy (m_lpszFamName, pstr); };
    
    BOOL  bSameFamily( CFontClass* pComp )
                {  if( pComp == NULL ) return FALSE;
//
// I removed this part of the "same family" logic so that when the user
// selects "Hide Variations", there is only one object per family.
// Including this statement treats Times Roman (TrueType) as a different family
// than Times Roman (Type1).  [brianau]
//
#ifndef WINNT
                   if( pComp->iFontType() != m_eFileKind )
                      return FALSE;
#endif
                   bFillIn();
                   pComp->bFillIn();
                   return lstrcmp( m_lpszFamName, pComp->m_lpszFamName ) == 0;};
    
    /**********************************************************************    
     * font data stuff 
     */
    
    int   iFontType( )      { return m_eFileKind; }
    BOOL  bDeviceType( )    { return m_eFileKind == eFKDevice;    }
    BOOL  bTrueType( )      { return ((m_eFileKind == eFKTrueType) || 
                                   (m_eFileKind == eFKTTC)); }
    BOOL  bOpenType( )      { return m_eFileKind == eFKOpenType; }
    BOOL  bTTC( )           { return m_eFileKind == eFKTTC; }
    BOOL  bType1( )         { return m_eFileKind == eFKType1; }
    
    /**********************************************************************    
     * AddFontResource and RemoveFontResource
     */
    BOOL  bAFR();
    BOOL  bRFR();
    
    /********************************************************************** 
     * For dealing with the font family list 
     */
    VOID  vSetFamilyFont( )          {  m_bFamily = TRUE;    };

    VOID  vSetNoFamilyFont( )        {  m_bFamily = FALSE;
                                        /* m_wFamIdx = IDX_NULL; */ };

    VOID  vSetFamIndex( WORD wVal )  {  m_wFamIdx = wVal; };

    WORD  wGetFamIndex( )            {  return m_wFamIdx; };

    BOOL  bSameFamIndex( CFontClass* pComp )
                               { return pComp->m_wFamIdx == m_wFamIdx; };
    
    /**********************************************************************
     * For dealing with the flags 
     */
    DWORD dwStyle( )        { return m_dwStyle; }

    BOOL  bHavePANOSE( )    { bFillIn(); return (m_jFamily != PANOSE_ANY); }

//    BOOL  bSymbolSet( )   { bFillIn(); return m_fSymbol;         };

    BOOL  bFamilyFont( )    { return m_bFamily;         };
    
    BOOL  bOnSysDir( )      { return m_dirfn.bOnSysDir(); };

    WORD  wFontSize( )      { return m_wFileK;    };
    
    BOOL  bFilledIn( )      { return m_bFilledIn; };
    
    
    DWORD dCalcFileSize( );

    RC    rcStoreDirFN( LPTSTR pStr, DirFilenameClass& dirfn );
    
//    HFONT hPrivateFont( HDC hDC, int iPoints );

    BOOL  bInit( LPTSTR lpszDesc, LPTSTR lpPath, LPTSTR lpAltPath = NULL );

    BOOL  bFillIn( );
    
    BOOL  bFOT()        { return( m_lpszFOT != NULL ); };

    BOOL  bGetFOT( LPTSTR pszFOT, UINT uFOTLen )
    {
        if( !bFOT( ) )
            return( FALSE );

        lstrcpyn( pszFOT, m_lpszFOT, uFOTLen );

        return( TRUE );
    }
    
    BOOL  bPFB()        { return( m_lpszPFB != NULL ); };

    BOOL  bGetPFB( LPTSTR pszPFB, UINT uPFBLen )
    {
        if( !bType1( ) )
            return( FALSE );

        lstrcpyn( pszPFB, m_lpszPFB, uPFBLen );

        return( TRUE );
    }
    
    BOOL  bGetFileToDel( LPTSTR szFileName );
    
private :
    CFontDir * poAddDir( LPTSTR lpPath, LPTSTR * lpName );
    BOOL bAddDirToDirList(CFontDirList *pDirList, LPCTSTR pszDir, BOOL bSystemDir);
    VOID  vSetDeviceType( )        { m_eFileKind = eFKDevice;   };
    VOID  vSetTrueType( BOOL bFOT) { m_eFileKind = eFKTrueType; }
    VOID  vSetOpenType( )          { m_eFileKind = eFKOpenType; }
    VOID  vSetTTCType( )           { m_eFileKind = eFKTTC; }
    VOID  vSetType1( )             { m_eFileKind = eFKType1; }
    
    BOOL  bSetFOT( LPCTSTR pszFOT )
    {
        m_lpszFOT = (LPTSTR) LocalAlloc(LMEM_FIXED,
                                  (lstrlen( pszFOT ) + 1) * sizeof( TCHAR ) );

        if( !m_lpszFOT )
            return( FALSE );

        lstrcpy( m_lpszFOT, pszFOT );

        return( TRUE );
    }

    void  vFreeFOT() { if( bFOT( ) ) LocalFree( m_lpszFOT ); m_lpszFOT = NULL; }

    BOOL  bSetPFB( LPCTSTR pszPFB )
    {
        m_lpszPFB = (LPTSTR) LocalAlloc(LMEM_FIXED,
                                  (lstrlen( pszPFB ) + 1) * sizeof( TCHAR ) );

        if( !m_lpszPFB )
            return( FALSE );

        lstrcpy( m_lpszPFB, pszPFB );

        return( TRUE );
    }

    void  vFreePFB() { if( bType1( ) ) LocalFree( m_lpszPFB ); m_lpszPFB = NULL; }

#ifdef WINNT
    //
    // Functions for getting information from Type1 fonts and 
    // 32-bit font resources.
    //
    DWORD GetType1Info(LPCTSTR pszPath, 
                       LPTSTR pszFamilyBuf, 
                       UINT nBufChars, 
                       LPDWORD pdwStyle, 
                       LPWORD pwWeight);

    DWORD GetLogFontInfo(LPTSTR pszPath, LOGFONT **ppLogFontInfo);

#endif  // WINNT
    
//  VOID  vStuffPANOSE   ();
    
//  RC    rcPANOSEFromTTF( PANOSEBytesClass& xUsePANOSE );
    

private :
    LONG              m_cRef;        // Reference count.

    // Some things are filled in on the first pass, others are
    // filled in on the second pass during background processing,
    // idle time, or on demand.
    //
    BOOL              m_bAFR;        // True if the font is in GDI
    FontDesc_t        m_szFontLHS;   // 1
    FAMNAME           m_szFamName;   // 2
    LPTSTR            m_lpszFamName; // 2
    
    BOOL              m_bFilledIn;   // True after 2nd pass
    BYTE              m_wNameLen;    // 1
    BYTE              m_jFamily;     // 2
    PANOSEBytesClass  m_xPANOSE;     // 2
    
    DirFilenameClass  m_dirfn;       // 1. Path in WIN.INI, not real TTF path
    WORD              m_wFileK;      // 2.
    WORD              m_wFamIdx;     // Set externally.
    eFileKind         m_eFileKind;   // Always an int
    
    BOOL              m_bFileInfoFetched;
    FILETIME          m_ft;
    
    LPTSTR            m_lpszFOT;
    LPTSTR            m_lpszPFB;
    DWORD             m_dwFileAttributes; // Cached file attributes.
    BOOL              m_bAttributesValid; 

public:   // TODO: Add access functions for this.
    WORD              m_wWeight;      // 2. From OS/2 table
    BOOL              m_bFamily;      // 2. Set if main family font
    DWORD             m_dwStyle;      // 2. Same values as 

#if 0
    union {   WORD    m_bFlags;      // Compiler makes word regardless
    /*
     *    fHavePANOSE  - TRUE if PANOSE number derived by looking into file
     */
       struct { 
          unsigned m_fHavePANOSE   : 1;   // 0
          unsigned m_fSymbol      : 1;   // 1
          unsigned m_fFamily      : 1;   // 2
          unsigned m_fFOTFile     : 1;   // 3
          unsigned m_fUnderline   : 1;   // 4
          unsigned m_fStrikeout   : 1;   // 5
          unsigned fUnused        : 9; }; // 7-15
       }; // end union
#endif
//   TCHAR   pad[256-USEDSIZE];
};


BOOL PASCAL bMakeFQName( LPTSTR, PTSTR, DWORD, BOOL bSearchPath=FALSE );

BOOL bTTFFromFOT( LPCTSTR lpFOTPath, LPTSTR lpTTF, WORD wLen );

BOOL FFGetFileResource( LPCTSTR szFile, LPCTSTR szType, LPCTSTR szRes,
                        DWORD dwReserved, DWORD *pdwLen, LPVOID lpvData );

LPTSTR PASCAL lpNamePart( LPCTSTR lpszPath );


#endif   // __FONTCL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\fontext.h ===
//
// Class ID for the registry browser extension
// {BD84B380-8CA2-1069-AB1D-08000948F534}
//

DEFINE_GUID(CLSID_FontExt, 0xBD84B380L, 0x8CA2, 0x1069, 0xAB, 0x1D, 0x08,
        0x00, 0x09, 0x48, 0xF5, 0x34);

extern HINSTANCE g_hmodThisDll;   // Module handle for this dll
extern HANDLE    g_crefThisDll;   // Reference count for the dll


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\fonthelp.h ===
//------------------------------------------------------------------------
// FONTHELP.H
//
// ID's for help topics. The Fonts Folder has the range from 8100-8199
// for help topics.
//------------------------------------------------------------------------

#ifndef __FONTHELP_H__
#define __FONTHELP_H__

// This needs to be defined by the Documentation folks.
//
#define IDH_WINDOWS_FONTS_ADDNEW_31HELP   8100
#define IDH_FONTS_ADD_SELECTALL           8101
#define IDH_FONTS_TRUETYPE_ON_COMPUTER    8105
#define IDH_FONTS_ADD_COPY_TO_FONT_DIR    8106
#define IDH_FONTS_ADD_FONTLIST            8107


#endif   // __FONTHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\fontvect.h ===
/**********************************************************************
 * FontVect.h  -- Font vector. An indirect array of FontID objects.
 *
 **********************************************************************/

#if !defined(__FONTVECT_H__)
#define __FONTVECT_H__

#include "vecttmpl.h"


// ********************************************************************
// Forward Declarations
//
class CFontClass;

typedef CIVector<CFontClass> CFontVector;



#endif   // __FONTVECT_H__ 

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\fontman.h ===
/***************************************************************************
 * FontMan.h   -- Definintion for the class: CFontManager
 *
 *
 * Copyright (C) 1992-93 ElseWare Corporation.    All rights reserved.
 ***************************************************************************/

#if !defined(__FONTMAN_H__)
#define __FONTMAN_H__

#if !defined(__FSNOTIFY_H__)
#include "fsnotify.h"
#endif

#include "strtab.h"

// The database search capabilities have been extended.
enum {
    kSearchAny = 1,
    kSearchTT,
    kSearchNotTT
};


//*********************************************************************
// Forward declarations
//
class CFontClass;
class CFontList;
class CFontManager;
struct IPANOSEMapper;

DWORD dwResetFamilyFlags(void);

//*********************************************************************
// Class CFontManager
//
class CFontManager
{
public:
    virtual ~CFontManager( );
    
    BOOL  bInit( );          // Any initialization
    BOOL  bLoadFontList( );  // Build the font list
    
    VOID  vReconcileFolder( int iPriority );
    VOID  vDoReconcileFolder();

    CFontClass *   poAddToList( LPTSTR lpName, LPTSTR lpPath, LPTSTR lpCompFile = NULL );
    CFontList  *   poLockFontList( );
    void           vReleaseFontList( );
    
    void           vGetFamily( CFontClass * poFont, CFontList * poList );
    
    int            iSearchFontList( PTSTR pszTarget, BOOL bExact = TRUE, int iType = kSearchAny );
    int            iSearchFontListLHS( PTSTR pszLHS );
    int            iSearchFontListFile( PTSTR pszFile );
    CFontClass *   poSearchFontList( PTSTR pszTarget, BOOL bExact = TRUE, int iType = kSearchAny );
    CFontClass *   poSearchFontListLHS( PTSTR pszLHS );
    CFontClass *   poSearchFontListFile( PTSTR pszFile );
    
    VOID           vResetFamilyFlags( );
    VOID           vDoResetFamilyFlags( );
    BOOL           bWaitOnFamilyReset( );
    BOOL           bLoadFamList( );
    BOOL           bRefresh( BOOL bCheckDup = TRUE );
    
    void           vToBeRemoved( CFontList * poList );
    BOOL           bCheckTBR( );
    void           vUndoTBR( );
 
    void           vVerifyList( );
    
    void           vDeleteFontList( CFontList * poList, BOOL bDelete = TRUE );
    void           vDeleteFont( CFontClass * pFont,  BOOL bRemoveFile );
    void           vDeleteFontFamily( CFontClass * pFont,  BOOL bRemoveFile );
    
    int            iCompare( CFontClass * pFont1, CFontClass * pFont2, CFontClass * pOrigin );
    USHORT         nDiff( CFontClass * pFont1, CFontClass * pFont2 );
    
    int            GetFontsDirectory( LPTSTR lpDir, int iLen );
    BOOL           ShouldAutoInstallFile( PTSTR pstr, DWORD dwAttrib );
    BOOL           bFamiliesNeverReset(void) { return m_bFamiliesNeverReset; }
    
//
//  Members are obsolete.  Superceded by dwWaitForInstallationMutex() and
//  bReleaseInstallationMutex().
//  See comment in header of CFontManager::iSuspendNotify() for details.
//
//  int            iSuspendNotify( );
//  int            iResumeNotify( );

    //
    // Enumerated return values for dwWaitForInstallationMutex().
    //
    enum           { MUTEXWAIT_SUCCESS,  // Got the mutex.
                     MUTEXWAIT_TIMEOUT,  // Wait timed out.
                     MUTEXWAIT_FAILED,   // Wait failed.
                     MUTEXWAIT_WMQUIT    // Rcvd WM_QUIT while waiting.
                   };

    DWORD          dwWaitForInstallationMutex(DWORD dwTimeout = 2000);
    BOOL           bReleaseInstallationMutex(void);

#ifdef WINNT
    BOOL           CheckForType1FontDriver(void);
    BOOL           Type1FontDriverInstalled(void)
                        { return m_bType1FontDriverInstalled; }
#endif

private: // Methods
    CFontManager();
    VOID           ProcessRegKey( HKEY hk, BOOL bCheckDup );
    VOID           ProcessT1RegKey( HKEY hk, BOOL bCheckDup );
    int            GetSection( LPTSTR lpFile,
                               LPTSTR lpSection,
                               LPHANDLE hSection);
    
    HRESULT        GetPanMapper( IPANOSEMapper ** ppMapper );

    CFontList     *  m_poFontList;
    CFontList     *  m_poTempList;
    IPANOSEMapper *  m_poPanMap;
    BOOL             m_bTriedOnce;   // Set to true if an attempt has been made
                                     // to get at the pan mapper.
    
    BOOL             m_bFamiliesNeverReset; // T = family reset never done yet.
    CFontList     *  m_poRemoveList; // List of fonts being dragged out.
    
    NOTIFYWATCH m_Notify;
    HANDLE      m_hNotifyThread;
//
//  Member is obsolete.  See comment in header of CFontManager::iSuspendNotify()
//
//  int         m_iSuspendNotify;    // The count of suspends
    
    HANDLE      m_hReconcileThread;
    HANDLE      m_hResetFamThread;
    
    HANDLE      m_hEventTerminateThreads;
    HANDLE      m_hEventResetFamily;
    HANDLE      m_hMutexResetFamily;
    HANDLE      m_hMutexInstallation;  // Prevent concurrent installation
                                       // by reconciliation and main threads.
    CRITICAL_SECTION  m_cs;
   
    class HiddenFilesList : public StringTable
    {
        public:
            HiddenFilesList(void) { }
            ~HiddenFilesList(void) { }

            DWORD Initialize(void);

    } m_HiddenFontFilesList;

#ifdef WINNT
    BOOL        m_bType1FontDriverInstalled;
#endif    

friend DWORD dwResetFamilyFlags(LPVOID);
friend DWORD dwNotifyWatchProc(LPVOID);
friend DWORD dwReconcileThread(LPVOID);
friend HRESULT GetOrReleaseFontManager(CFontManager **ppoFontManager, bool bGet);

};

//
// Singleton instance management.
//
HRESULT GetFontManager(CFontManager **ppoFontManager);
void ReleaseFontManager(CFontManager **poFontManager);


#endif // __FONTMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\fontfile.h ===
#ifndef _INC_FONTEXT_FONTFILE
#define _INC_FONTEXT_FONTFILE

class CFontFileIo;

//
// This class provides an abstraction that hides the differences required to read
// compressed and non-compressed font files.  The font folder was originally written
// to use the LZ APIs provided in LZ32.DLL for all reading of font files.  These
// APIs work with compressed and non-compressed files.  The problems is that the
// APIs are very old and are based on the OpenFile API and DOS file handles.  This
// means they're not UNICODE aware and have a maximum path length of 128 characters.
// So, even though compressed font files are rare today, all font files are 
// subject to these limitations in the font folder.  The LZ APIs are considered 
// legacy code and are not going to be being modified.  
//
// Since we can't modify the LZ APIs I decided to create this CFontFile class
// which defers the IO functionality to a properly-typed subclass.  Non-compressed
// files are handled with Win32 functions (i.e. CreateFile, ReadFile etc).  
// Compressed files are handled with LZ functions (i.e. LZOpenFile, LZRead etc).
// This means that the UNICODE and path length restrictions only affect compressed
// files and that non-compressed files (the vast majority today) are unaffected. 
//
// brianau [3/1/99]
//
class CFontFile
{
    public:
        CFontFile(void)
            : m_pImpl(NULL) { }

        ~CFontFile(void);

        DWORD Open(LPCTSTR pszPath, DWORD dwAccess, DWORD dwShareMode, bool bCreate = false);

        void Close(void);

        DWORD Read(LPVOID pbDest, DWORD cbDest, LPDWORD pcbRead = NULL);

        DWORD Seek(UINT uDistance, DWORD dwMethod);

        DWORD Reset(void)
            { return Seek(0, FILE_BEGIN); }

        DWORD GetExpandedName(LPCTSTR pszFile, LPTSTR pszDest, UINT cchDest);

        DWORD CopyTo(LPCTSTR pszTo);

    private:
        CFontFileIo *m_pImpl;  // Properly-typed implementation.

        bool IsCompressed(void);

        //
        // Prevent copy.
        //
        CFontFile(const CFontFile& rhs);
        CFontFile& operator = (const CFontFile& rhs);
};


#endif // _INC_FONTEXT_FONTFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\fontfldr.h ===
/**********************************************************************
 * FontFldr.h - Definition for the CFontFolder, our implementation for
 *       the IShellFolder in our browser.
 *
 **********************************************************************/

#if !defined(__FONTFLDR_H__)
#define __FONTFLDR_H__

// Forward declarations --------------------------------------------------
//
#if defined(__FCN__)
#include "fsnotify.h"      // for NOTIFYWATCH
#endif

#if !defined(__VIEWVECT_H__)
#include "viewvect.h"
#endif

class CFontList;
class CFontView;

// ********************************************************************
class CFontFolder : public IShellFolder, public IPersistFolder
{
public:
    CFontFolder();
    ~CFontFolder();
    int Init();
    
    // Utility functions.
    //
     CFontList * poFontList ( );
    BOOL bRefresh( );
    BOOL bRefView( CFontView * poView );
    BOOL bReleaseView( CFontView * poView );

#if defined(__FCN__)
    VOID vReconcileFolder( );    // Launch a thread to call vDoReconcileFolder
    VOID vDoReconcileFolder( );
#endif

    // *** IUnknown methods ***

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj );
    STDMETHODIMP_(ULONG) AddRef( void );
    STDMETHODIMP_(ULONG) Release( void );
    
    // *** IShellFolder methods ***

    STDMETHODIMP ParseDisplayName ( HWND hwndOwner,
                                    LPBC pbc, 
                                    LPOLESTR lpszDisplayName,
                                    ULONG * pchEaten, 
                                    LPITEMIDLIST * ppidl,
                                    ULONG *pdwAttributes) ;
    
    STDMETHODIMP EnumObjects( HWND hwndOwner,
                              DWORD grfFlags,
                              LPENUMIDLIST * ppenumIDList) ;
    
    STDMETHODIMP BindToObject( LPCITEMIDLIST pidl,
                               LPBC pbcReserved,
                               REFIID riid,
                               LPVOID * ppvOut) ;

    STDMETHODIMP BindToStorage( LPCITEMIDLIST pidl,
                                LPBC pbcReserved,
                                REFIID riid,
                                LPVOID * ppvObj) ;

    STDMETHODIMP CompareIDs( LPARAM lParam,
                             LPCITEMIDLIST pidl1,
                             LPCITEMIDLIST pidl2) ;

    STDMETHODIMP CreateViewObject( HWND hwndOwner,
                                   REFIID riid,
                                   LPVOID * ppvOut) ;

    STDMETHODIMP GetAttributesOf( UINT cidl,
                                  LPCITEMIDLIST * apidl,
                                  ULONG * rgfInOut) ;

    STDMETHODIMP GetUIObjectOf( HWND hwndOwner,
                                UINT cidl,
                                LPCITEMIDLIST * apidl,
                                REFIID riid,
                                UINT * prgfInOut,
                                LPVOID * ppvOut) ;

    STDMETHODIMP GetDisplayNameOf( LPCITEMIDLIST pidl,
                                   DWORD uFlags,
                                   LPSTRRET lpName) ;

    STDMETHODIMP SetNameOf( HWND hwndOwner,
                            LPCITEMIDLIST pidl,
                            LPCOLESTR lpszName,
                            DWORD uFlags,
                            LPITEMIDLIST * ppidlOut) ;

    
    // *** IPersist methods ***

    STDMETHODIMP GetClassID( LPCLSID lpClassID );
    
    // *** IPersistFolder methods ***

    STDMETHODIMP Initialize( LPCITEMIDLIST pidl );
    
    
private:
    static int sm_id;
    int m_id;
    int m_cRef;

#if defined(__FCN__)
    NOTIFYWATCH m_Notify;
    HANDLE      m_hNotifyThread;
#endif

    CViewVector *  m_poViewList;

};

#endif   // __FONTFLDR_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\fontinfo.h ===
/***************************************************************************
 * fontinfo.h - declarations for the font info class
 *
 * This header defines interfaces for the following classes:
 *      OS_2TableClass - holds info from the OS_2 table (not true class)
 *      TTFInfoClass   - holds partial info from the TT file.
 *      FontInfoClass  - hold font info - this is the true public interface
 *
 *  By putting these guys in classes, not only do we ensure they're not
 *  used in some bad fashions, but we can automatically handle memory
 *  release (via destructors)
 *
 * Copyright (C) 1992-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __FONTINFO_H__
#define __FONTINFO_H__

typedef    TCHAR    FQNAME[255];

class far OS_2TableClass {
     public :  OS_2TableClass () {};
     public :    // fields:

        WORD   wVersion;
        short  ixAvgCharWidth;
        WORD   wusWeightClass;
        WORD   wusWidthClass;
        short  ifsType;
        short  iySubXSize;
        short  iySubYSize;
        short  iySubXOffset;
        short  iySubYOffset;
        short  iySupXSize;
        short  iySupYSize;
        short  iySupXOffset;
        short  iySupYOffset;
        short  iyStrikeoutSize;
        short  iyStrikeoutPosition;
        short  isFamilyClass;
        PANOSEBytesClass PANOSE;
        ULONG  ulCharRange[4];
        TCHAR  achVendID[4];
        WORD   wfsSelection;
        WORD   wusFirstCharIndex;
        WORD   wusLastCharIndex;
        WORD   wusTypoAscender;
        WORD   wusTypeoDescender;
        WORD   wwsTypoLineGap;
        WORD   wusWinAscent;
        WORD   wusWinDescent;
};
typedef OS_2TableClass* LPOS_2TABLE;

/* The string block is a dynamically allocated section of the
 * TRUETYPE info block.  We don't have any idea how big these guys
 * can be until we probe and dig into the file
 */

typedef struct _tagStrings {
        LPTSTR     m_lpszCopyright;
        LPTSTR     m_lpszTrademark;
        LPTSTR     m_lpszVersion;
}    InfoStrings_t, FAR* LPInfoStrings;

class far TTFInfoClass {
public :     
            TTFInfoClass () { vClear (); };
                ~TTFInfoClass () { vFree  (); };
        VOID    vFree( ) {  if (m_lpInfoStrings.m_lpszCopyright)
                                delete[] m_lpInfoStrings.m_lpszCopyright;
                            if( m_lpInfoStrings.m_lpszTrademark )
                                delete[] m_lpInfoStrings.m_lpszTrademark;
                            if( m_lpInfoStrings.m_lpszVersion )
                                delete[] m_lpInfoStrings.m_lpszVersion;

                            vClear (); };

        BOOL    bLoadInfo( HDC hDC );
        // BOOL    bGrowTTFInfo (WORD wLen, LPWORD, LPWORD);

private :    // routines

        VOID    vClear( ) { memset (this, 0, sizeof(*this) ); };

public  :    // fields
   InfoStrings_t    m_lpInfoStrings; // The OS2 table we've allocated
};

class FontInfoClass {
    public : // routines

        FontInfoClass    () {  vClear(); };
        VOID    vClear    () {  m_bValid = FALSE; vFree (); };
        VOID    vFree     () {  m_xTTFInfo.vFree(); };

        LPTSTR lpGetTrademark ()
            {    LPTSTR lp = NULL;
                if( m_bValid )
                    lp = m_xTTFInfo.m_lpInfoStrings.m_lpszTrademark;
                return lp; };

        LPTSTR lpGetCopyright ()
            {    LPTSTR lp = NULL;
                if( m_bValid )
                    lp = m_xTTFInfo.m_lpInfoStrings.m_lpszCopyright;
                return lp; };

        void    vGetVersion( UINT id, PTSTR szVersion );
        BOOL    bGetFontInfo( CFontClass* lpFontRec );
        BOOL    bValid( )   { return m_bValid; };

    private    :    // fields
        BOOL            m_bValid;
        TTFInfoClass    m_xTTFInfo;
        OS_2TableClass  m_OS_2Table;
};
#endif



/****************************************************************************
 * $lgb$
 * 1.0     7-Mar-94   eric Initial revision.
 * $lge$
 *
 ****************************************************************************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\fsnotify.h ===
//------------------------------------------------------------------------
// FSNotify.h
//
// Include file for FSNotify.cpp
//------------------------------------------------------------------------

#if !defined(__FSNOTIFY_H__)
#define __FSNOTIFY_H__

#if defined(__FCN__)

// Forward Declarations --------------------------------------------------
//
class CFontManager;

//------------------------------------------------------------------------

typedef struct {
   HANDLE          m_hWatch;  // Returned from FindFirstChangeNotify.
} NOTIFYWATCH, FAR * LPNOTIFYWATCH;

DWORD dwNotifyWatchProc( LPVOID pvParams );

#endif // __FCN__ 

#endif   // __FSNOTIFY_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\fontlist.h ===
/**********************************************************************
 * FontList.h  -- Manages a list of FontID objects via an array of
 *             FontVector objects.
 *
 **********************************************************************/

#if !defined(__FONTLIST_H__)
#define __FONTLIST_H__


#include "fontvect.h"

class CFontClass;

const int kDefaultVectSize = 50;   // Number of fonts in each CFontArray

class CFontList {
public:
    CFontList( int iSize, int iVectorSize = kDefaultVectSize );
    ~CFontList();
    
    int bInit();
    CFontList *Clone(void);
        
    //
    //  The real array functions.
    //

    int   iCount( void );
    int   bAdd( CFontClass * t );
    CFontClass *  poObjectAt( int idx );
    CFontClass *  poDetach( int idx );
    CFontClass *  poDetach( CFontClass * t );
    void  vDetachAll( );
    int   bDelete( int idx );
    int   bDelete( CFontClass * t );
    void  vDeleteAll( );
    int   iFind( CFontClass * t );
    void  ReleaseAll(void);
    void  AddRefAll(void);
    
private:
    CFontVector **  m_pData;
    int   m_iCount;         // Number of Fonts
    int   m_iVectorCount;   // Number of vectors allocated
    int   m_iVectorBounds;  // Total number of vector points
    int   m_iVectorSize;    // Number of fonts in each vector
};



/**********************************************************************
 * Some things you can do with a font list.
 */
HDROP hDropFromList( CFontList * poList );

#endif   // __FONTLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\fontview.h ===
/**********************************************************************
 * FontView.h - Definition for the CFontView, our implementation for
 *       the IShellView in our browser.
 *
 **********************************************************************/

#if !defined(__FONTVIEW_H__)
#define __FONTVIEW_H__

#ifndef __EXTRICON_H__
#include "extricon.h"
#endif

//
// Defining the macro TOOLTIP_FONTSAMPLE activates code to display a
// font sample in a tooltip window whenever the mouse cursor pauses over
// an item in the font folder.  This is currently an experimental feature
// so I want to allow conditional compilation for now.  If it goes into
// the product, the conditional compilation directives may be removed.
// [brianau - 5/17/97].
//
#define TOOLTIP_FONTSAMPLE 1

// Forward declarations.
class CFontClass;
class CFontList;
class CFontView;
class CFontManager;

VOID InstallDataObject( LPDATAOBJECT pdobj, DWORD dwEffect, HWND hWnd, CFontView * poView = NULL);

// ********************************************************************


class CFontData : public IDataObject
{
public:
    // ctor, dtor, and init.
    //
    CFontData();
    ~CFontData();
    BOOL bInit( CFontList * poList );
    CFontList *poDetachList(void);
    CFontList *poCloneList(void);

    // *** IUnknown methods ***

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj );
    STDMETHODIMP_(ULONG) AddRef( void );
    STDMETHODIMP_(ULONG) Release( void );

    // **** IDataObject ****
    //
    STDMETHODIMP GetData( FORMATETC *pformatetcIn, STGMEDIUM *pmedium );
    STDMETHODIMP GetDataHere( FORMATETC *pformatetc, STGMEDIUM *pmedium );
    STDMETHODIMP QueryGetData( FORMATETC *pformatetc );

    STDMETHODIMP GetCanonicalFormatEtc( FORMATETC *pformatectIn,
                                        FORMATETC *pformatetcOut );

    STDMETHODIMP SetData( FORMATETC *pformatetc,
                          STGMEDIUM *pmedium,
                          BOOL fRelease );

    STDMETHODIMP EnumFormatEtc( DWORD dwDirection,
                                IEnumFORMATETC **ppenumFormatEtc );

    STDMETHODIMP DAdvise( FORMATETC  *pformatetc,
                          DWORD advf,
                          IAdviseSink *pAdvSink,
                          DWORD *pdwConnection);

    STDMETHODIMP DUnadvise( DWORD dwConnection);

    STDMETHODIMP EnumDAdvise( IEnumSTATDATA **ppenumAdvise );

    // Additional public interfaces.
    //
    BOOL bAFR();      // AddFontResource() for each of these
    BOOL bRFR();      // RemoveFontResource for each object.

    static CLIPFORMAT s_CFPerformedDropEffect; // Performed Drop Effect CF atom.
    static CLIPFORMAT s_CFPreferredDropEffect;
    static CLIPFORMAT s_CFLogicalPerformedDropEffect;

    //
    // Get the performed data transfer effect from the Data Object.
    //
    DWORD GetPerformedDropEffect(void)
        { return m_dwPerformedDropEffect; }
    void SetPerformedDropEffect(DWORD dwEffect)
        { m_dwPerformedDropEffect = dwEffect; }
        
    DWORD GetLogicalPerformedDropEffect(void)
        { return m_dwLogicalPerformedDropEffect; }
    void SetLogicalPerformedDropEffect(DWORD dwEffect)
        { m_dwLogicalPerformedDropEffect = dwEffect; }
        
    DWORD GetPreferredDropEffect(void)
        { return m_dwPreferredDropEffect; }
    void SetPreferredDropEffect(DWORD dwEffect)
        { m_dwPreferredDropEffect = dwEffect; }

private:
    int   m_cRef;
    CFontList * m_poList;

    DWORD m_dwPerformedDropEffect;        // DROPEFFECT_XXXX.
    DWORD m_dwPreferredDropEffect;        // DROPEFFECT_XXXX.
    DWORD m_dwLogicalPerformedDropEffect;

    HRESULT ReleaseStgMedium(LPSTGMEDIUM pmedium);
};


// ********************************************************************
class CFontView : public IShellView, public IDropTarget, public IPersistFolder
{
public:
    CFontView(void);
    ~CFontView( );

    int Compare( CFontClass * pFont1, CFontClass * pFont2 );
    void vShapeView( );

    // *** IUnknown methods ***

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj );
    STDMETHODIMP_(ULONG) AddRef( void );
    STDMETHODIMP_(ULONG) Release( void );

    // *** IOleWindow methods ***

    STDMETHODIMP GetWindow( HWND * lphwnd );
    STDMETHODIMP ContextSensitiveHelp( BOOL fEnterMode );

    // *** IShellView methods ***

    STDMETHODIMP TranslateAccelerator( LPMSG msg );
    STDMETHODIMP EnableModeless( BOOL fEnable );
    STDMETHODIMP UIActivate( UINT uState );
    STDMETHODIMP Refresh( void );

    STDMETHODIMP CreateViewWindow( IShellView * lpPrevView,
                                   LPCFOLDERSETTINGS lpfs,
                                   IShellBrowser * psb,
                                   RECT * prcView,
                                   HWND * phwnd);

    STDMETHODIMP DestroyViewWindow( void );
    STDMETHODIMP GetCurrentInfo( LPFOLDERSETTINGS lpfs );
    STDMETHODIMP AddPropertySheetPages( DWORD dwReserved,
                                        LPFNADDPROPSHEETPAGE lpfn,
                                        LPARAM lparam);

    STDMETHODIMP SaveViewState( void );
    STDMETHODIMP SelectItem( LPCITEMIDLIST lpvID, UINT uFlags );
    STDMETHODIMP GetItemObject( UINT uItem, REFIID riid, LPVOID *ppv );


    // **** IDropTarget ****
    //
    STDMETHODIMP DragEnter( IDataObject __RPC_FAR *pDataObj,
                            DWORD grfKeyState, POINTL pt,
                            DWORD __RPC_FAR *pdwEffect );

    STDMETHODIMP DragOver( DWORD grfKeyState,
                           POINTL pt,
                           DWORD __RPC_FAR *pdwEffect );

    STDMETHODIMP DragLeave( void );

    STDMETHODIMP Drop( IDataObject __RPC_FAR *pDataObj,
                       DWORD grfKeyState,
                       POINTL pt,
                       DWORD __RPC_FAR *pdwEffect );

    // *** IPersist methods ***

    STDMETHODIMP GetClassID( LPCLSID lpClassID );

    // *** IPersistFolder methods ***

    STDMETHODIMP Initialize( LPCITEMIDLIST pidl );

public:
    void StatusPush( UINT nStatus );
    void StatusPush( LPTSTR lpsz );
    void StatusPop( );
    void StatusClear( );
    //
    // Exposing this is a violation of the design of this object.
    // However, it is needed so that we can provide a parent to the installation
    // progress dialog.
    //
    HWND GetViewWindow(void)
        { return m_hwndView; }
    DWORD GetDateReading(void)
        { return m_dwDateFormat; }

    IDataObject *m_pdtobjHdrop; // Used to support drag-drop from Win3.1 app.

private:
    enum CLICKMODE
    {
        CLICKMODE_SINGLE = 1,
        CLICKMODE_DOUBLE = 2,
    };

    int RegisterWindowClass( );
    STDMETHODIMP GetSavedViewState( );
    void SortObjects( );
    void FillObjects( );
    int AddObject( CFontClass * poFont );
    LRESULT BeginDragDrop( NM_LISTVIEW FAR *lpn );
    int OnActivate( UINT state );
    int OnDeactivate( );
    int MergeToolbar( );
    static INT_PTR CALLBACK FontViewDlgProc( HWND, UINT, WPARAM, LPARAM );
    static LRESULT CALLBACK FontViewWndProc( HWND, UINT, WPARAM, LPARAM );
    static INT_PTR CALLBACK OptionsDlgProc( HWND, UINT, WPARAM, LPARAM) ;
    int OnMenuSelect( HWND hWnd, UINT nID, UINT nFlags, HMENU hMenu );
    int OnCommand( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );
    int OnNotify( LPNMHDR lpn );
    VOID OnLVN_ItemActivate(LPNMITEMACTIVATE pnma);
    void OnDropFiles( HDROP hDrop, DWORD dwEffect = DROPEFFECT_MOVE );
    void OnCmdCutCopy( UINT nID );
    void OnCmdDelete( );
    void OnCmdPaste( );
    void OnCmdProperties( );
    void OnPointSize( int nPlus );
    void OnHelpTopics( HWND hWnd );
    INT ItemImageIndex(CFontClass *poFont);
    CLICKMODE SetListviewClickMode(VOID);
    void UpdateUnderlines(void);
    void LV_OnGetInfoTip(LPNMLVGETINFOTIP lpnm);

#ifdef TOOLTIP_FONTSAMPLE
    VOID LV_OnHoverNotify(LPNMLISTVIEW pnmlv);
    BOOL CreateToolTipWindow(VOID);
    VOID UpdateFontSample(INT iItem);
#endif //TOOLTIP_FONTSAMPLE

    //
    // Functions to support Attributes column in details view and
    // alternate coloring of compressed files.
    //
    int OnShellChangeNotify(WPARAM wParam, LPARAM lParam);
    int OnCustomDrawNotify(LPNMHDR lpn);
    void UpdateFontViewObject(CFontClass *poFont);
    int CompareByFileAttributes(CFontClass *poFont1, CFontClass *poFont2);
    LPTSTR BuildAttributeString(DWORD dwAttributes, LPTSTR pszString, UINT nChars);

    //
    // Functions to support drag-drop from Win3.1 app.
    //
    void OldDAD_DropTargetLeaveAndReleaseData(void);
    LRESULT OldDAD_HandleMessages(UINT message, WPARAM wParam, const DROPSTRUCT *lpds);


#ifdef USE_OWNERDRAW
    void SetDimensions( );
    BOOL OnMeasureItem( LPMEASUREITEMSTRUCT lpmi );
    BOOL OnDrawItem( LPDRAWITEMSTRUCT lpdi );
#endif

    void UpdateMenuItems( HMENU hMenu );
    void UpdateToolbar( );
    LRESULT ProcessMessage( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );
    BOOL OpenCurrent( );
    BOOL PrintCurrent( );
    BOOL ViewValue( CFontClass * poFont );
    BOOL PrintValue( CFontClass *poFont );

    void vLoadCombo( );
    void SetViewMode( UINT uMode );
    void UpdatePanColumn( );
    void vToggleSelection( BOOL bSelectAll );
    int  iCurrentSelection( );

    HRESULT  GetUIObjectFromItem( REFIID riid, LPVOID FAR *ppobj, UINT nItem );
    HRESULT  GetFontList( CFontList **ppoList, UINT nItem );
    void ReleaseFontObjects(void);
    void UpdateSelectedCount();


private:
    int   m_cRef;
//   int   m_iCurrentSelection;
    BOOL  m_bFamilyOnly;
    CFontClass * m_poPanose;
    HWND  m_hwndView;
    HWND  m_hwndList;
    HWND  m_hwndText;
    HWND  m_hwndCombo;
    HWND  m_hwndParent;
    HWND  m_hwndNextClip;       // Next window in the viewer chain

    DWORD m_dwDateFormat;

#ifdef TOOLTIP_FONTSAMPLE
    HWND    m_hwndToolTip;        // Tooltip window handle.
    BOOL    m_bShowPreviewToolTip;// User preference setting.
    LPTSTR  m_pszSampleText;      // Sample string used for character fonts.
    LPTSTR  m_pszSampleSymbols;   // Sample string used for symbol fonts.
    INT     m_iTTLastHit;         // Last item with active tooltip.
    HFONT   m_hfontSample;        // Font for displaying sample in tooltip window.
#endif // TOOLTIP_FONTSAMPLE


    HIMAGELIST m_hImageList;
    HIMAGELIST m_hImageListSmall;
    int   m_iFirstBitmap;
    HMENU m_hmenuCur;
    IShellBrowser* m_psb;

    UINT  m_uState;             // Deactivated, active-focus, active-nofocus
    UINT  m_idViewMode;
    UINT  m_ViewModeReturn;
    UINT  m_fFolderFlags;
    UINT  m_nComboWid;
    int   m_iSortColumn;
    int   m_iSortLast;
    BOOL  m_bSortAscending;     // TRUE = ascending, FALSE = descending.
    CLICKMODE m_iViewClickMode; // CLICKMODE_SINGLE or CLICKMODE_DOUBLE.

    DWORD m_dwEffect;           // Drag/drop effect.
    DWORD m_dwOldDADEffect;     // Drag/drop effect for Win3.1-style drops.
    DWORD m_grfKeyState;
    BOOL  m_bDragSource;
    int m_iHidden;
    HANDLE m_hAccel;
    BOOL  m_bResizing;          // Resizing the view window ?
    BOOL  m_bUIActivated;       // UI Activated through UIActivate( )
                                // This flag is used to prevent processing
                                // NM_SETFOCUS before UIActivate( ) has
                                // been called.
    ULONG m_uSHChangeNotifyID;  // Registered shell change notification ID.
    CFontIconHandler m_IconHandler;
    CFontManager *m_poFontManager;

#ifdef WINNT
    BOOL  m_bShowCompColor;     // T = user want's alternate color for compressed items.
#endif // WINNT
    BOOL  m_bShowHiddenFonts;

#ifdef USE_OWNERDRAW
    // DrawItem measurements for the listview.
    //
    UINT  m_nItemHeight;
#endif

};


#endif   // __FONTVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\mapsort.h ===
/***************************************************************************
 * mapsort.h -
 *
 * $keywords: mapsort.h 1.0  7-Mar-94 2:39:49 PM$
 *
 * Copyright (C) 1992-93 ElseWare Corporation.    All rights reserved.
 ***************************************************************************/

#ifndef __MAPSORT_H_
#define __MAPSORT_H_


/* API to the Map/Sort module
 */

extern RC      FAR PASCAL rcMPInit( );
extern VOID    FAR PASCAL vMPLoadListBox( );
extern VOID    FAR PASCAL vMPSort( FontClass* lpFontRec );
extern WORD    FAR PASCAL wMPGetEquivList( FontClass* lpFontRec,
                                           WORD       wRequestedHits,
                                           FontClass* * pEquiv );

#endif /* __MAPSORT_H_ */



/****************************************************************************
 * $lgb$
 * 1.0     7-Mar-94   eric Initial revision.
 * $lge$
 *
 ****************************************************************************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\lstrfns.h ===
#ifndef _INC_SHLWAPI
// If these routines are not already defined in shlwapi, do it here.

#define OFFSET(x) ((PTSTR)(LOWORD((DWORD)(x))))

extern UINT   PASCAL StrCpyN( LPTSTR lpDest, LPTSTR lpSource, short nBufSize );
extern LPTSTR PASCAL StrChr( LPTSTR lpStart, WORD wMatch );
extern LPTSTR PASCAL StrRChr( LPTSTR lpStart, LPTSTR lpEnd, WORD wMatch );
extern LPTSTR PASCAL StrChrI( LPTSTR lpStart, WORD wMatch );
extern LPTSTR PASCAL StrRChrI( LPTSTR lpStart, LPTSTR lpEnd, WORD wMatch );
extern LPTSTR PASCAL StrStr( LPTSTR lpFirst, LPTSTR lpSrch );
extern LPTSTR PASCAL StrRStr( LPTSTR lpSource, LPTSTR lpLast, LPTSTR lpSrch );
extern LPTSTR PASCAL StrStrI( LPTSTR lpFirst, LPTSTR lpSrch );
extern LPTSTR PASCAL StrRStrI( LPTSTR lpSource, LPTSTR lpLast, LPTSTR lpSrch );
extern short  PASCAL StrCmpN( LPTSTR lpStr1, LPTSTR lpStr2, short nChar );
extern short PASCAL StrCmpNI( LPTSTR lpStr1, LPTSTR lpStr2, short nChar );

#endif

/****************************************************************************
 * $lgb$
 * 1.0     7-Mar-94   eric Initial revision.
 * $lge$
 *
 ****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\priv.h ===
#define _INC_OLE
#define CONST_VTABLE
#define DONT_WANT_SHELLDEBUG   1

#include <windows.h>
#include <windowsx.h>
#include <winuserp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlobj.h>
#include <shellapi.h>
#include <shlobjp.h>
#include <shfusion.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <ole2.h>

#include <tchar.h>

// define __FCN__ to enable the FileChangeNotify procession.
//
#define __FCN__

#ifdef _fstrcpy
#undef _fstrcpy
#endif
#ifdef _fstrcat
#undef _fstrcat
#endif
#ifdef _fstrlen
#undef _fstrlen
#endif

#define _fstrcpy lstrcpy
#define _fstrcat lstrcat
#define _fstrlen lstrlen

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\pnewexe.h ===
/*static char *SCCSID = "@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERESWDS]; /* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    unsigned short int  ne_magic;       /* Magic number NE_MAGIC */
    char                ne_ver;         /* Version number */
    char                ne_rev;         /* Revision number */
    unsigned short int  ne_enttab;      /* Offset of Entry Table */
    unsigned short int  ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short int  ne_flags;       /* Flag word */
    unsigned short int  ne_autodata;    /* Automatic data segment number */
    unsigned short int  ne_heap;        /* Initial heap allocation */
    unsigned short int  ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short int  ne_cseg;        /* Count of file segments */
    unsigned short int  ne_cmod;        /* Entries in Module Reference Table */
    unsigned short int  ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short int  ne_segtab;      /* Offset of Segment Table */
    unsigned short int  ne_rsrctab;     /* Offset of Resource Table */
    unsigned short int  ne_restab;      /* Offset of resident name table */
    unsigned short int  ne_modtab;      /* Offset of Module Reference Table */
    unsigned short int  ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short int  ne_cmovent;     /* Count of movable entries */
    unsigned short int  ne_align;       /* Segment alignment shift count */
    unsigned short int  ne_cres;        /* Count of resource segments */

#ifdef NEVER
    unsigned short int  ne_psegcsum;    /* offset to segment chksums */
#else
    unsigned char    ne_exetyp;    /* Target Operating system */
    unsigned char    ne_flagsothers;    /* Other .EXE flags */
#endif
    unsigned short int  ne_pretthunks;  /* offset to return thunks */
    unsigned short int  ne_psegrefbytes;/* offset to segment ref. bytes */
    unsigned short int  ne_swaparea;    /* Minimum code swap area size */
    unsigned short int  ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res
#define NE_EXETYPE(x)    (x).ne_exetyp

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   c                                  Non-conforming
 *    e                                 Errors in image
 *     xxxxxxxxx                        Unused
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR          0x2000          /* Errors in image */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

struct new_seg                          /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
    unsigned short      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            unsigned short      ns_niter;       /* number of iterations */
            unsigned short      ns_nbytes;      /* number of bytes */
            char                ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            char                ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    unsigned short      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    char                nr_stype;       /* Source type */
    char                nr_flags;       /* Flag byte */
    unsigned short      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            char        nr_segno;       /* Target segment number */
            char        nr_res;         /* Reserved */
            unsigned short nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            unsigned short nr_mod;      /* Index into Module Reference Table */
            unsigned short nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */
#define OSFIXUP     0x03        /* Floating point fixup */


/* Resource type or name string */
struct rsrc_string
    {
    char rs_len;            /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    unsigned short rn_offset;   /* file offset to resource data */
    unsigned short rn_length;   /* length of resource data */
    unsigned short rn_flags;    /* resource flags */
    unsigned short rn_id;       /* resource name id */
    unsigned short rn_handle;   /* If loaded, then global handle */
    unsigned short rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004      /* True if handler proc return handle */

/* Resource table */
struct new_rsrc
    {
    unsigned short rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align

/* Target operating systems:  Possible values of ne_exetyp field */

#define NE_UNKNOWN    0    /* Unknown (any "new-format" OS) */
#define NE_OS2        1    /* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS    2    /* Microsoft Windows         */
#define NE_DOS4       3    /* Microsoft MS-DOS 4.x         */
#define NE_DEV386     4    /* Microsoft Windows 386     */



/****************************************************************************
 * $lgb$
 * 1.0     7-Mar-94   eric Initial revision.
 * $lge$
 *
 ****************************************************************************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\panmap.h ===
/***************************************************************************
 * PANMAP.H - Base definitions for ElseWare PANOSE(tm) 1.0 Font Mapper.
 *            OLE 2.0 Implementation
 *
 *
 * Copyright (C) 1991-94 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __PANOLE2_H__
#define __PANOLE2_H__

#ifdef INITGUID

/* A Global Unique Identifier and an Interface ID for the PANOSE mapper.
 */

DEFINE_GUID(CLSID_PANOSEMapper, 0xBD84B381L, 0x8CA2, 0x1069, 0xAB, 0x1D, 0x08,
        0x00, 0x09, 0x48, 0xF5, 0x34);
DEFINE_GUID(IID_IPANOSEMapper, 0xBD84B382L, 0x8CA2, 0x1069, 0xAB, 0x1D, 0x08,
        0x00, 0x09, 0x48, 0xF5, 0x34);
#else

#if defined(__cplusplus)
extern "C" {
#endif

extern const CLSID CLSID_PANOSEMapper;
extern const IID IID_IPANOSEMapper;

#if defined(__cplusplus)
}
#endif

#endif



DECLARE_INTERFACE_( IPANOSEMapper, IUnknown)
{
    /* IUnknown 
     */
    STDMETHOD(QueryInterface) (THIS_
                               REFIID riid,
                               LPVOID FAR* ppvObj) PURE;

    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    /* The PANOSE Mapper interface.
     */

    STDMETHOD_(USHORT, unPANMatchFonts) ( THIS_
                                          LPBYTE lpPanWant,
                                          ULONG ulSizeWant,
                                          LPBYTE lpPanThis,
                                          ULONG ulSizeThis,
                                          BYTE jMapToFamily) PURE;
    
    
    STDMETHOD_(VOID, vPANMakeDummy)( THIS_
                                     LPBYTE lpPanThis,
                                     USHORT unSize ) PURE;
    
    STDMETHOD_(SHORT, nPANGetMapDefault)( THIS_
                                          LPBYTE lpPanDef,
                                          USHORT unSizePanDef ) PURE;
    
    STDMETHOD_(SHORT, nPANSetMapDefault) (THIS_
                                          LPBYTE lpPanDef,
                                          USHORT unSizePanDef ) PURE;
    
    STDMETHOD_(BOOL, bPANEnableMapDefault) (THIS_
                                            BOOL bEnable )  PURE;
    
    STDMETHOD_(BOOL, bPANIsDefaultEnabled) (THIS)  PURE;
    
    STDMETHOD_(USHORT, unPANPickFonts) (THIS_
                                        USHORT FAR *lpIndsBest,
                                        USHORT FAR *lpMatchValues,
                                        LPBYTE lpPanWant,
                                        USHORT unNumInds,
                                        LPBYTE lpPanFirst,
                                        USHORT unNumAvail,
                                        SHORT nRecSize,
                                        BYTE jMapToFamily ) PURE ;
    
    STDMETHOD_(USHORT, unPANGetMapThreshold) (THIS) PURE;
    
    STDMETHOD_(BOOL, bPANSetMapThreshold) (THIS_
                                           USHORT unThreshold ) PURE;
    
    STDMETHOD_(BOOL, bPANIsThresholdRelaxed) (THIS) PURE;
    
    STDMETHOD_(VOID, vPANRelaxThreshold) (THIS) PURE;
    
    STDMETHOD_(BOOL, bPANRestoreThreshold) (THIS) PURE;
    
    STDMETHOD_(BOOL, bPANGetMapWeights) (THIS_
                                         BYTE jFamilyA,
                                         BYTE jFamilyB,
                                         LPBYTE lpjWts,
                                         LPBOOL lpbIsCustom ) PURE;
    
    STDMETHOD_(BOOL, bPANSetMapWeights) (THIS_
                                         BYTE jFamilyA,
                                         BYTE jFamilyB, LPBYTE lpjWts ) PURE;
    
    STDMETHOD_(BOOL, bPANClearMapWeights) (THIS_
                                           BYTE jFamilyA,
                                           BYTE jFamilyB ) PURE;
};
typedef IPANOSEMapper FAR * LPPANOSEMAPPER;


//------------------------------------------------------------------------
// Mapper definitions.
//

#endif   // __PANOLE2_H__


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\globals.h ===
/***************************************************************************
 * globals.h - TrueType Font Manager global data declaration.
 *
 * $keywords: globals.h 1.3 17-Mar-94 2:38:47 PM$
 *
 * Copyright (C) 1992-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __GLOBALS_H__
#define __GLOBALS_H__

#define ERR_FAIL 0
#define NOERR 1

#include <fstream.h>

//
//  Forward declarations.
//
class CFontFolder;

//
//  Constants
//

#define MAX_NAME_LEN            64
#define MAX_LOG_NAME_LEN        32
#define MAX_PATH_LEN            MAX_PATH
#define MAX_FILE_LEN            MAX_PATH_LEN
// #define MAX_DIRS                32
#define IDX_NULL                0xFFFF      // index out of range
#define IDX_ZERO                0x0000
#define PANOSE_LEN              10
#define COPYRIGHT_LEN           60

//
//  Defines
//

#define PATHMAX MAX_PATH   // path length max - used for Get...Directory() calls
#define DESCMAX 129        // max description in newexe header
#define MODNAMEMAX 20      // max module name in newexe header

//
//  Name/string types
//

typedef TCHAR   FullPathName_t[ PATHMAX ];
typedef TCHAR   FontDesc_t[ DESCMAX ];
typedef TCHAR   ModName_t[ MODNAMEMAX ];

typedef TCHAR   LOGNAME[ MAX_LOG_NAME_LEN + 1 ]; // log font name
typedef TCHAR   FAMNAME[ MAX_LOG_NAME_LEN + 1 ]; // font Family name
typedef TCHAR   FONTNAME[ MAX_NAME_LEN + 1 ];
typedef TCHAR   PATHNAME[ MAX_PATH_LEN + 1 ];
typedef TCHAR   FILENAME[ MAX_FILE_LEN + 1 ];


//
//  Globals
//

extern BOOL      g_bTrace;
extern BOOL      g_bDiag;
extern BOOL      g_bTimer;

extern HINSTANCE g_hInst;

extern TCHAR     g_szType1Key[];

extern char      g_szFontsDirA[];

extern TCHAR     c_szTrueType[];
extern TCHAR     c_szOpenType[];
extern TCHAR     c_szPostScript[];
extern TCHAR     c_szDescFormat[];
extern TCHAR     szNull[];

extern FullPathName_t   s_szSharedDir;


//
// Far East character handling.
//
extern BOOL g_bDBCS;

//
//  Number of references to objects in this dll
//

extern LONG      g_cRefThisDll;

extern CFontFolder * g_poFontFolder;

//
//  Types
//

typedef short  RC;
typedef WORD   SFIDX;      /* display sorted index into font list */
typedef WORD   FTIDX;
typedef WORD   POINTSIZE;     /* Size of point measurement */

// EMR: This needs to be a WORD so it fits in the ListITEMDATA struct.
//typedef int         FONTNUM;    /* Font number */
typedef WORD         FONTNUM;    /* Font number */
typedef FONTNUM*     PFONTNUM;   /* Font number */
typedef FONTNUM FAR* LPFONTNUM;  /* Font number */

//
//  typedefs.
//

//
//  Font description info. Used during installation and to retrieve info
//  about a font.
//
//  szFile must is filled in by calling proc. The rest is filled in depending
//       on the flags.
//

#define  FDI_DESC    1
#define  FDI_FAMILY  2
#define  FDI_PANOSE  4
#define  FDI_STYLE   8
#define  FDI_ALL     (DWORD)(15)
#define  FDI_NONE    0

#define  FDI_VTC     16    // Version Trademark and copyright.

//
// Style bits. These can be OR'd together
//

#define  FDI_S_REGULAR  0
#define  FDI_S_BOLD     1
#define  FDI_S_ITALIC   2


typedef struct {
   DWORD          dwFlags;
   FullPathName_t szFile;
   FontDesc_t     szDesc;
   FAMNAME        szFamily;
   DWORD          dwStyle;
   WORD           wWeight;
   TCHAR          jPanose[ PANOSE_LEN ];

   //
   // These strings are allocated by the routine that actually retrieves
   // the strings. They should be deleted using the C++ delete operator.
   //

   TCHAR *  lpszVersion;
   TCHAR *  lpszTrademark;
   TCHAR *  lpszCopyright;
   
} FONTDESCINFO, FAR * LPFONTDESCINFO;



//
//  Enums
//

typedef enum {
   eFKNone     = 0,
   eFKDevice,
   eFKTrueType,
   eFKOpenType,
   eFKTTC,
   eFKType1
} eFileKind;

typedef enum _tagMPVIEW {
   eVFont    = 0,
   eVFamily,
   eVFile,
   eVPanose
} MPVIEW;


extern BOOL  NEAR PASCAL bIsTrueType( LPFONTDESCINFO lpFile, LPDWORD pdwTableTags = NULL, LPDWORD lpdwStatus = NULL );
extern BOOL  NEAR PASCAL bIsNewExe( LPFONTDESCINFO lpFile );

extern int GetFontsDirectory( LPTSTR lpDir, int nSize);
extern BOOL WriteToRegistry( LPTSTR lpDesc, LPTSTR lpFile );

extern int  FAR PASCAL iUIErrMemDlg(HWND hwndParent);   // Everyone needs this
extern int  FAR PASCAL iUIMsgBox( HWND hwndParent, 
                                  WORD wIDStr,
                                  WORD wCAPStr,
                                  UINT uiMBFlags,
                                  LPCTSTR wArg1 = 0,
                                  LPCTSTR wArg2 = 0,
                                  LPCTSTR wArg3 = 0,
                                  LPCTSTR wArg4 = 0);
//
//  These are 3 simple covers which make calling the message routine
//  much simpler.
//

int FAR PASCAL iUIMsgBoxWithCaption(HWND hwndParent, WORD wIDStr, WORD wCaption);
int FAR PASCAL iUIMsgYesNoExclaim(HWND hwndParent, WORD wIDStr, LPCTSTR wArg = 0);
int FAR PASCAL iUIMsgYesNoExclaim(HWND hwndParent, WORD wIDStr, WORD wCap, LPCTSTR wArg=0);
int FAR PASCAL iUIMsgOkCancelExclaim(HWND hwndParent, WORD wIDStr, WORD wCap, LPCTSTR wArg=0);
int FAR PASCAL iUIMsgRetryCancelExclaim(HWND hwndParent, WORD wIDStr, LPCTSTR wArg=0 );
int FAR PASCAL iUIMsgExclaim(HWND hwndParent, WORD wIDStr, LPCTSTR wArg = 0);
int FAR PASCAL iUIMsgBox(HWND hwndParent, WORD wIDStr, LPCTSTR wArg = 0);
int FAR PASCAL iUIMsgInfo(HWND hwndParent, WORD wIDStr, LPCTSTR wArg = 0);

//
// Special-purpose message box for reporting font validation failures.
// dwStatusCode must be one of FVS_XXXXXXXX values as defined in fvscodes.h
// 
int iUIMsgBoxInvalidFont(HWND hwndParent, LPCTSTR pszFontFile, LPCTSTR pszFontDesc,
                         DWORD dwStatusCode,
                         UINT uStyle = (MB_OKCANCEL | MB_ICONEXCLAMATION));

#include "fvscodes.h"  // \nt\private\windows\shell\control\t1instal\fvscodes.h
                       // Contains FVS_xxxxx codes and related macros.


#endif /* __GLOBALS_H_ */

/****************************************************************************
 * $lgb$
 * 1.0     7-Mar-94   eric Initial revision.
 * 1.1     9-Mar-94   eric Background thread and g_hDBMutex
 * 1.2     9-Mar-94   eric Added Gdi mutex.
 * 1.3    17-Mar-94   eric Removed mutex handles.
 * $lge$
 *
 ****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\oeminf.h ===
/*
** oeminf.h - Public interface for oeminf.c.
*/

// Constants
/////////////

#define MAX_INF_COMP_LEN      0xffff   // Must not overrun a segment.
#define MAX_INF_READ_SIZE     0xffff   // INT_MAX  // Must not overrun an int.

#define INF_PREFIX            TEXT( "oem" )
#define INF_EXTENSION         TEXT( "inf" )

#define MAX_5_DEC_DIGITS      99999

// Buffer size for Get...Directory() calls.
#define MAX_NET_PATH          MAX_PATH

// .inf file specification and length.
#define OEM_STAR_DOT_INF      TEXT( "\\oem*.inf" )
#define OEM_STAR_DOT_INF_LEN  9


// Macros
//////////

#define IS_PATH_SEPARATOR(c)  ((c) == TEXT( '\\' ) || (c) == TEXT( '/' ) || (c) == TEXT( ':' ))
#define IS_SLASH(c)           ((c) == TEXT( '\\' ) || (c) == TEXT( '/' ))

BOOL   FAR PASCAL RunningFromNet( void );
HANDLE FAR PASCAL ReadFileIntoBuffer( int doshSource );
int    FAR PASCAL FilesMatch( HANDLE h1, HANDLE h2, unsigned uLength );
LPTSTR FAR PASCAL TruncateFileName( LPTSTR lpszPathSpec );
int    FAR PASCAL OpenFileAndGetLength( LPTSTR pszSourceFile, LPLONG plFileLength );
int    FAR PASCAL IsNewFile( LPTSTR lpszSourceFile, LPTSTR lpszSearchSpec );
LPTSTR FAR PASCAL MakeUniqueFilename( LPTSTR pszDirName, LPTSTR pszPrefix, LPTSTR pszExtension );
BOOL   FAR PASCAL CopyNewOEMInfFile( LPTSTR pszOEMInfPath );

// Macros
//////////

#define FILEMAX            14          // 8.3 + null terminator

// #define FOPEN(sz)          _lopen(sz, OF_READ)
// #define FCLOSE(fh)         _lclose(fh)
// #define FCREATE(sz)        _lcreat(sz, 0)



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\t1.h ===
// --------------------------------------------------------------------
//    T1.h
//
//    Type 1 utilities.
//
// --------------------------------------------------------------------

#if !defined(__T1_H__)
#define __T1_H__

// define this in priv.h for T1->TT support. (NB: It's not finished, yet.)
//
#if defined(T1_SUPPORT)


// --------------------------------------------------------------------

typedef struct {
    // The following are filled in for a Type 1 font.
    //
    FullPathName_t  pfm;
    FullPathName_t  pfb;
    FullPathName_t  ttf;
    BOOL            bCreatedPFM;
} T1_INFO, FAR * LPT1_INFO;


BOOL NEAR PASCAL bIsType1 (
    LPTSTR        lpFile, 
    FontDesc_t *  lpDesc,                 
    LPT1_INFO     lpInfo = NULL );


BOOL NEAR PASCAL bConvertT1( LPT1_INFO lpInfo );


#endif

// --------------------------------------------------------------------


#endif    // __T1_H__ 

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\strtab.h ===
#ifndef __STRING_TABLE_H
#define __STRING_TABLE_H
///////////////////////////////////////////////////////////////////////////////
// Class: StringTable
//
// This class implements a simple hash table for storing text strings.
// The purpose of the table is to store strings and then verify later
// if the table contains a given string.  Since there is no data associated
// with the string, the stored strings act as both key and data.  Therefore,
// there is no requirement for string retrieval.  Only existence checks
// are required.
// The structure maintains a fixed-length array of pointers, each pointing
// to a linked list structure (List).  These lists are used to handle the
// problem of hash collisions (sometimes known as "separate chaining").
//
// Note that these classes do not contain all the stuff that is usually
// considered necessary in C++ classes.  Things like copy constructors,
// assignment operator, type conversion etc are excluded.  The classes
// are very specialized for the Font Folder application and these things
// would be considered "fat".  Should this hash table class be later used 
// in a situation where these things are needed, they can be added then.
//
// The public interfaces to the table are:
//
//      Initialize  - Initialize a new string table.
//      Add         - Add a new string to a table.
//      Exists      - Determine if a string exists in a table.
//      Count       - Return the number of strings in a table.
//
// Destruction of the object automatically releases all memory associated
// with the table.
//
// BrianAu - 4/11/96
///////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <tchar.h>

//
// Hash table containing text strings.
// 
class StringTable {
    private:
        //
        // Linked list for hash collisions.
        //
        class List {
            private:
                //
                // Element in hash collision list.
                //
                class Element {
                    public:
                        LPTSTR m_pszText;   // Pointer to string text.
                        Element *m_pNext;   // Pointer to next in list.

                        Element(void);
                        ~Element(void);
                        BOOL Initialize(LPCTSTR pszItem);
                        BOOL operator == (const Element& ele) const;
                        BOOL operator != (const Element& ele) const;
#ifdef DEBUG
                        void DebugOut(void) const;
#endif
                };

                Element *m_pHead;  // Ptr to head of list;
                DWORD   m_dwCount; // Count of elements in list.

            public:
                List(void);
                ~List(void);
                BOOL Add(LPCTSTR pszText, BOOL bAllowDuplicates = TRUE);
                BOOL Exists(LPCTSTR pszText) const;
                DWORD Count(void) const { return m_dwCount; }
#ifdef DEBUG
                void DebugOut(void) const;
#endif
        };

        CRITICAL_SECTION m_cs;    // Protect from concurrent access.
        List **m_apLists;         // Array of ptrs to collision lists.
        DWORD m_dwItemCount;      // Number of items in table.
        DWORD m_dwHashBuckets;    // Number of pointers in hash array.
        BOOL  m_bCaseSensitive;   // Key strings treated case-sensitive?
        BOOL  m_bAllowDuplicates; // Allow duplicate strings?

        DWORD Hash(LPCTSTR pszText) const;
        LPTSTR StringTable::CreateUpperCaseString(LPCTSTR pszText) const;
        BOOL Exists(DWORD dwHashCode, LPCTSTR pszText);

    public:
        StringTable(void);
        ~StringTable(void);
        BOOL Initialize(DWORD dwHashBuckets, 
                        BOOL bCaseSensitive   = TRUE,
                        BOOL bAllowDuplicates = FALSE);

        BOOL IsInitialized(void);
        void Destroy(void);
        BOOL Add(LPCTSTR pszText);
        BOOL Exists(LPCTSTR pszText);
        DWORD Count(void) const { return m_dwItemCount; }
#ifdef DEBUG
        void DebugOut(void) const;
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\resource.h ===
/**************************************************************************
 * resource.h - Font assistant resource constants.
 *
 * Copyright (C) 1992-93 ElseWare Corporation.    All rights reserved.
 ***************************************************************************/

#ifndef __RESOURCE_H__
#define __RESOURCE_H__

#include <dlgs.h>

//*********************************************************************
// Icons
//
#define IDI_ICON                        1

#define IDI_FIRSTFONTICON               2  // First in image list.

#define IDI_TTF                         2
#define IDI_FON                         3
#define IDI_TTC                         4
#define IDI_T1                          5
#define IDI_OTFp                        6  // "OTp" icon
#define IDI_OTFt                        7  // "OTt" icon

#define IDI_LASTFONTICON                7  // Update this if you add another.

#define TYPE1ICON                     IDI_T1

   // Extracted from SHELL32.DLL
   //
#define IDI_X_LINK                      30
#define IDI_X_NUKE_FILE                 161
#define IDI_X_DELETE                    142


//*********************************************************************
// Bitmaps
//
#define IDB_TOOLICONS                   15

//*********************************************************************
// Accelerator table
//
#define ACCEL_DEF                       20

//*********************************************************************
// Menus and Menu Items
//
#define MENU_DEFSHELLVIEW               29

#define IDM_FILE_SAMPLE                 30
#define IDM_FILE_PRINT                  31
#define IDM_FILE_INSTALL                32
#define IDM_FILE_LINK                   33
#define IDM_FILE_DEL                    34
#define IDM_FILE_RENAME                 35
#define IDM_FILE_PROPERTIES             36

#define IDM_EDIT_SELECTALL              37
#define IDM_EDIT_SELECTINVERT           38
#define IDM_EDIT_CUT                    39
#define IDM_EDIT_COPY                   40
#define IDM_EDIT_PASTE                  41

// --------------------------------------------------------
// The following IDs need to be kept in sequetial order: 
//    IDM_VIEW_ICON to IDM_POINT_DOWN
//
#define IDM_VIEW_ICON                   42
#define IDM_VIEW_LIST                   43
#define IDM_VIEW_PANOSE                 44
#define IDM_VIEW_DETAILS                45

#define IDM_VIEW_ACTUAL                 46
#define IDM_EDIT_UNDO                   47  
#define IDM_VIEW_PREVIEW                48
// --------------------------------------------------------

#define IDM_VIEW_VARIATIONS             49

// Popups for context menus.
#define IDM_POPUPS                      58
#define IDM_POPUP_NOITEM                59
#define IDM_POPUP_DRAGDROP              60


// Other messages delivered through WM_COMMAND
//
#define IDM_IDLE                        61
#define IDM_POPUP_MOVE                  62
#define IDM_POPUP_COPY                  63
#define IDM_POPUP_LINK                  64
#define IDM_POPUP_CANCEL                65

#define IDM_HELP_TOPIC                  66
#define IDM_HELP_ABOUT                  67

//*********************************************************************
// Dialogs
//
#define ID_DLG_FONT2                   70  // Install dialog
#define ID_LB_ADD      ctlLast+1
#define ID_SS_PCT      ctlLast+2

#define ID_DLG_MAIN                    76
#define ID_TXT_SIM                     77
#define ID_CB_PANOSE                   78

#define ID_DLG_PROPPAGE                80

#define ID_DLG_OPTIONS                 85
#define IDC_TTONLY                     86

#define DLG_INSTALL                    90
#define IDD_INSTALL                    91
#define COLOR_SAVE                     92
#define IDD_HELP                       93

#define DLG_BROWSE                     100
#define IDD_BROWSE                     101

#define DLG_PROGRESS                   110
#define DLG_INSTALL_PS                 120

#define DLG_COPYRIGHT_NOTIFY           130
#define IDC_COPYRIGHT_FONTNAME         131
#define IDC_COPYRIGHT_VENDORNAME       132
//
// Help ids
//

#define IDH_HELPFIRST        5000
#define IDH_SYSMENU     (IDH_HELPFIRST + 2000)
#define IDH_MBFIRST     (IDH_HELPFIRST + 2001)
#define IDH_DLG_FONT2   (IDH_HELPFIRST + 2002)
#define IDH_MBLAST      (IDH_HELPFIRST + 2099)
#define IDH_DLGFIRST    (IDH_HELPFIRST + 3000)

//#define IDH_DLG_REMOVEFONT  (IDH_DLGFIRST + DLG_REMOVEFONT)
#define IDH_DLG_BROWSE      (IDH_DLGFIRST + DLG_BROWSE)

#define IDH_DLG_INSTALL_PS     (IDH_DLGFIRST + DLG_INSTALL_PS)
//#define IDH_DLG_REMOVEFONT_PS  (IDH_DLGFIRST + DLG_REMOVEFONT_PS)

//
//  Progress dialog control ids
//

#define ID_INSTALLMSG           42
#define ID_PROGRESSMSG          43
#define ID_BAR                  44
#define ID_OVERALL              45


//
//  Font dialogs control ids
//

#define IDD_YESALL        122

#define FONT_REMOVEMSG    418
#define FONT_REMOVECHECK  419
#define FONT_TRUETYPEONLY 420
#define FONT_CONVERT_PS   431
#define FONT_INSTALL_PS   432
#define FONT_COPY_PS      433
#define FONT_REMOVE_PS    434
#define FONT_INSTALLMSG   435




//*********************************************************************
// Strings
//

/* General messsages.  If the message is a constant string, we call
 * it IDS_MSG_xxx or IDX_TXT_xxx.
 * If we substitute something (via sprintf or similar), its IDS_FMT_xxx
 */

#define IDS_FONTS_FOLDER        140    // The name of the fonts folder in the windows dir.

#define IDS_MSG_CAPTION         151
#define IDS_MSG_NOVERSION       153
#define IDS_MSG_NSFMEM          154

#define IDS_MSG_PANOSE          163

#define IDS_MSG_ALLFILTER       165
#define IDS_MSG_NORMALFILTER    166


#define IDS_FMT_VERSION         177

/* Font installer messages */

#define IDSI_CAP_NOINSTALL      210
#define IDSI_CAP_NOCREATE       211
#define IDSE_CAP_CREATERR       212

#define IDSI_MSG_TTDISABLED     215
#define IDSI_MSG_NOFONTS        216
#define IDSI_MSG_COPYCONFIRM    217
#define IDSI_MSG_DEFDIR         218

#define IDSI_FMT_BADINSTALL     222
#define IDSI_FMT_ISINSTALLED    223
#define IDSI_FMT_RETRIEVE       224
#define IDSI_FMT_COMPRFILE      225
#define IDSI_FMT_FILEFNF        229
#define IDSI_UNKNOWN_VENDOR     232



#define INSTALL0        250
#define INSTALL1        251
#define INSTALL2        252
#define INSTALL3        253
#define INSTALL4        254
#define INSTALL5        255
#define INSTALL6        256
#define INSTALL7        257
#define INSTALL8        258
#define INSTALL9        259

// COLUMN String info for the List Views
#define IDS_PAN_COL1          301
#define IDS_PAN_COL2          302

#define IDS_FILE_COL1         303
#define IDS_FILE_COL2         304
#define IDS_FILE_COL3         305
#define IDS_FILE_COL4         306
#define IDS_FILE_COL5         307
#define IDS_ATTRIB_CHARS      308
#define IDS_FONTSAMPLE_TEXT   309
#define IDS_FONTSAMPLE_SYMBOLS 310

#define IDS_VIEW_ICON         311
#define IDS_VIEW_LIST         312
#define IDS_VIEW_PANOSE       313
#define IDS_VIEW_DETAILS      314


// File types
#define IDS_FONT_FILE         407
#define IDS_TT_FILE           408

#define IDS_NO_PAN_INFO       409
#define IDS_PAN_VERY_SIMILAR  410
#define IDS_PAN_SIMILAR       411
#define IDS_PAN_NOT_SIMILAR   412
#define IDS_FMT_FILEK         413
#define IDS_TTC_CONCAT        414


// Strings for Shell Extension
//
#define IDS_EXT_INSTALL       420
#define IDS_EXT_INSTALL_HELP  421

//
// Strings for font file validation errors.
// FVS = Font Validation Status.
//
#define IDS_FMT_FVS_PREFIX      450
#define IDS_FMT_FVS_FILEOPEN    451
#define IDS_FMT_FVS_FILECREATE  452
#define IDS_FMT_FVS_FILEEXISTS  453
#define IDS_FMT_FVS_BADVERSION  454
#define IDS_FMT_FVS_INVFONTFILE 455
#define IDS_FMT_FVS_FILEIO      466
#define IDS_FMT_FVS_INTERNAL    467


// Status messages.
//

#define IDST_FILE_SAMPLE       490
#define IDST_FILE_PRINT        491
#define IDST_FILE_INSTALL      492
#define IDST_FILE_LINK         493

#define IDST_FILE_DEL          494
#define IDST_FILE_RENAME       495
#define IDST_FILE_PROPERTIES   496
                                
#define IDST_EDIT_SELECTALL    497
#define IDST_EDIT_SELECTINVERT 498
#define IDST_EDIT_CUT          499
#define IDST_EDIT_COPY         500
#define IDST_EDIT_PASTE        501

#define IDST_VIEW_ICON         502
#define IDST_VIEW_LIST         503
#define IDST_VIEW_PANOSE       504
#define IDST_VIEW_DETAILS      505

#define IDST_EDIT_UNDO         506
                                
#define IDST_VIEW_VARIATIONS   509
#define IDST_VIEW_PREVIEW      510
#define IDST_HELP_TOPICS       511

#define IDS_SELECTED_FONT_COUNT         520
#define IDS_TOTAL_FONT_COUNT            521
#define IDS_TOTAL_AND_HIDDEN_FONT_COUNT 522
#define IDSI_FMT_DELETECONFIRM          523

#define IDS_NEXTREBOOT          524
#define IDS_INSTALL_MUTEX_WAIT_FAILED 525

#define INSTALLIT               530     /* Two messages for installing */

#define MYFONT                  600

#define IDC_LIST_OF_FONTS		601
#endif   //  __RESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\ui.h ===
//------------------------------------------------------------------------
// UI.H
//
// Commonly used UI routines, classes, etc.
//------------------------------------------------------------------------

#if !defined(__UI_H__)
#define __UI_H__


#define vUIPStatusShow(a,b)

VOID FAR PASCAL vUIMsgInit( );
int FAR PASCAL iUIErrMemDlg( );

/*  The wait cursor is used to cause an hourglass for the duration of a
 *  routine.  The constructor sets the cursor to the hourglass, holding
 *  the previous. The destructor recovers the original cursor (or arrow if
 *  none).
 */

class WaitCursor
{
    public :
        WaitCursor () { m_Cursor = SetCursor(LoadCursor(NULL, IDC_WAIT));};
        ~WaitCursor () { if (m_Cursor != NULL)
                            SetCursor (m_Cursor);
                         else
                            SetCursor(LoadCursor(NULL, IDC_ARROW)); };
    private :
        HCURSOR    m_Cursor;
};

#endif // __UI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\viewvect.h ===
/**********************************************************************
 * FontVect.h  -- Font vector. An indirect array of FontID objects.
 *
 **********************************************************************/

#if !defined(__VIEWVECT_H__)
#define __VIEWVECT_H__

#include "vecttmpl.h"

// ********************************************************************
// Forward Declarations
//
class CFontView;

typedef CIVector<CFontView> CViewVector;

#endif   // __VIEWVECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\append.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// append.cpp
//      Explorer Font Folder extension routines
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
// These logic are originally in sdkinstall.
// I rewrote these as used in CP font installation for JAPAN spec. -yutakan
//
// Modifies: now fnAppendSplitFiles takes pszFiles param that contains
//           list of split files, and szDest which should have destination path.
//           - 06/10/1992 yutakan
//
//  Create: 06/09/1992 Yutaka Nakajima [mskk]
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"
#include "cpanel.h"

#include "lstrfns.h"
#include "ui.h"

#define ALLOC( n )               (VOID *)LocalAlloc( LPTR, n )
#define FREE( p )                LocalFree( (HANDLE) p )


#define MAX_BUF         5120


//
// Import from dos.asm
// extern int FAR PASCAL OEMInfDosChDir( LPTSTR szDir );
//

#ifdef WINNT

BOOL AttachComponentFile( HANDLE fhDst, int fhSrc );


#else

BOOL AttachComponentFile( int fhDst, int fhSrc );

#endif  // WINNT


///////////////////////////////////////////////////////////////////////////////
//
// BOOL fnAppendSplitFiles( LPTSTR FAR *pszFiles, LPTSTR szDest );
//
// ASSUMES: The component files have already been LZ-copied to their
//          respective destination directories.
//          Explicitly uses LZxxxx functions for reading the component files.
//          Component files are compressed.
//
// ENTRY: LPTSTR FAR * pszFiles  .. has list of source files
//                                 files should be ordered in the order
//                                 in which they should be attached.
//        LPTSTR szDest          .. file name for destination.
//        int   nComp           .. number of component files we're attaching . 
//
// EXIT:  BOOL                  .. TRUE if succeed.
//
///////////////////////////////////////////////////////////////////////////////

BOOL far pascal fnAppendSplitFiles( LPTSTR FAR *pszFiles, LPTSTR szDest, int nComp )
{
    TCHAR    szCompFile[ 80 ];
    int      i;
    LPTSTR   lpDestFileName;
    LPTSTR   lpTemp;

#ifdef WINNT
    HANDLE   fhDst;
    TCHAR    lppath[ MAX_PATH ];
#else
    int      fhDst;
#endif  //  WINNT

    int      fhComp;
    OFSTRUCT ofstruct;

    if( lpDestFileName = StrRChr( szDest, NULL, TEXT( '\\' ) ) )
    {
        *lpDestFileName = TEXT( '\0' );
        lpDestFileName++;
    }
    else
        return FALSE;

    //
    // Change to destination directory.
    //

    // if (OEMInfDosChDir(szDest) != 0)

    if( !SetCurrentDirectory( szDest ) )
        return FALSE;

    //
    //  Create destination file for writing. If it already exists,
    //  it is truncated to zero length.
    //

    fhDst = FCREATE ( lpDestFileName );

    if ( !fhDst )
        return FALSE;

    //
    //  When appending files, Cursor should be in HourGlass.
    //   1992.12.22 by yutakas
    //

    {

        WaitCursor wait;

        //
        //  Append all the component files one-by one to the destination
        //  file
        //

        for( i = 0; i < nComp; i++)
        {
            if( lstrlen( pszFiles[ i ] ) < 2 ) 
                goto BadParam;

            //
            // Assume pszFiles has list of string already formated as x:name,y:name...
            //

            if( lpTemp = StrChr( pszFiles[ i ], TEXT( ':' ) ) )
                lstrcpy( szCompFile, lpTemp+1 );
            else
                lstrcpy( szCompFile, pszFiles[ i ] );

            fhComp = LZOpenFile(szCompFile, &ofstruct, OF_READ | OF_SHARE_DENY_WRITE);

            if ( fhComp < 0 )
            {
BadParam:
                FCLOSE ( fhDst );
                return FALSE;
            }

            if( !AttachComponentFile( fhDst, fhComp ) )
            {
                FCLOSE ( fhDst );
                LZClose(fhComp);
                return FALSE;
            }

            //
            //  delete component file
            //
            LZClose(fhComp);
            DeleteFile(szCompFile);
        }   

        //
        //  close destination file
        //

        FCLOSE ( fhDst );
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//
// AttachComponentFile( fhDst, fhSrc )
//
// Appends a single file to another file using an intermediate buffer.
// Explicitly uses LZxxxx functions for reading the component file.
// Component files are compressed.
//
// ENTRY: int fhDst - handle of open destination file.
//        int fhSrc - handle of open component file.
//
// EXIT: BOOL
//     - TRUE on success, FALSE on failure  [ yutakan ] - 06/10/1992
//     - [ lalithar ] - 05/21/91
//
// NOTE: current buffer size set to 5K. The limit may be increased to a
//       larger value if needed.
//
///////////////////////////////////////////////////////////////////////////////

#ifdef WINNT

BOOL AttachComponentFile( HANDLE fhDst, int fhSrc )

#else

BOOL AttachComponentFile( int fhDst, int fhSrc )

#endif  // WINNT
{

#define BUF_STEP         1024

    char *pBuf, *pTmp;
    long   dwLen;
    int    wBufSize = MAX_BUF;

    //
    // determine the length of the component file
    //

    dwLen = LZSeek( fhSrc, 0L, SEEK_END );

    LZSeek(fhSrc, 0L, SEEK_SET);

    //
    // allocate a buffer of a reasonable size
    //

    pBuf = (LPSTR) ALLOC( wBufSize );

    for ( ; ( pBuf == NULL ) && wBufSize; wBufSize -= BUF_STEP )
    {
        pBuf = (LPSTR) ALLOC( wBufSize );
    }

    if( !pBuf )
        return FALSE;

    //
    //  Read MAX_BUF bytes of the component file into the buffer
    //  and write out the buffer to the destination file. Repeat this
    //  until the entire source file has been copied to the dest. file.
    //

    for( pTmp = pBuf; dwLen > wBufSize ; dwLen -= wBufSize )
    {
        LZRead( fhSrc, pTmp, wBufSize );
        FWRITEBYTES( fhDst, pTmp, wBufSize );
    }

    LZRead( fhSrc, pTmp, dwLen );
    FWRITEBYTES( fhDst, pTmp, dwLen );

    FREE ( pBuf );

   return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\cpsetup.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// cpsetup.cpp
//      Explorer Font Folder extension routines
//      This file holds all the code for reading setup.inf
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//      2/24/96 [BrianAu]
//          Replaced INF parsing code with Win32 Setup API.
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================
#include "priv.h"
#include "globals.h"
#include "cpanel.h"   // Needs "extern" declaration for exports.

#include "setupapi.h"

#define USE_WIN32_SETUP_API 1  // Replace INF parsing code with Win32 Profile API

#ifdef USE_WIN32_SETUP_API

//
// I have re-worked this code so that the original INF parsing code
// has been replaced with calls to the Win32 Setup API.  This not
// only greatly simplifies the code but also shields the font folder
// from any ANSI/DBCS/UNICODE parsing issues as well as compressed file
// issues.
// I have disabled the old code with the USE_WIN32_SETUP_API macro.
//
// You'll notice that the Setup API extracts fields from the INF section
// and we paste them back together to form a key=value string.  This is
// because the calling code previously used GetPrivateProfileSection() which
// returned information as key=value<nul>key=value<nul>key=value<nul><nul>.
// The function ReadSetupInfSection assembles the required information into
// the same format so that the calling code remains unchanged.
//
// [BrianAu 2/24/96]

//
// ReadSetupInfFieldKey
//
// Reads the key name from an Inf key=value pair.
//
// pContext - Pointer to Setup Inf Line context.
// pszBuf   - Pointer to destination buffer.
// cchBuf   - Size of destination buffer in characters.
//
// If destination buffer is not large enough for the name, function returns
// the number of characters required.  Otherwise, the number of characters
// read is returned.
//
DWORD ReadSetupInfFieldKey(INFCONTEXT *pContext, LPTSTR pszBuf, DWORD cchBuf)
{
    DWORD cchRequired = 0;

    if (!SetupGetStringField(pContext,
                             0,                  // Get key name
                             pszBuf,
                             cchBuf,
                             &cchRequired))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            cchRequired = 0;
    }
    return cchRequired;
}


//
// ReadSetupInfFieldText
//
// Reads the value text from an Inf key=value pair.
//
// pContext - Pointer to Setup Inf Line context.
// pszBuf   - Pointer to destination buffer.
// cchBuf   - Size of destination buffer in characters.
//
// If destination buffer is not large enough for text, function returns
// the number of characters required.  Otherwise, the number of characters
// read is returned.
//
DWORD ReadSetupInfFieldText(INFCONTEXT *pContext, LPTSTR pszBuf, DWORD cchBuf)
{
    DWORD cchRequired = 0;


    if (!SetupGetLineText(pContext,
                          NULL,
                          NULL,
                          NULL,
                          pszBuf,
                          cchBuf,
                          &cchRequired))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            cchRequired = 0;
    }

    return cchRequired;
}



//
// ReadSetupInfSection
//
// pszInfPath - Name of INF file to read.
// pszSection - Name of INF file section to read.
// ppszItems  - Address of pointer to receive address of
//              buffer containing INF items.  If *ppszItems
//              is non-null, the addressed buffer contains items read from
//              section in INF.  Each item is nul-terminated with a double
//              nul terminating the entire list.  The caller is responsible for
//              freeing this buffer with LocalFree( ).
//
// Returns: Number of characters read from INF section.  Count includes nul
//          separators and double-nul terminator.
//          0 = Section not found or section empty or couldn't allocate buffer.
//              *ppszItems will be NULL.
//
// The information returned through *ppszItems is in the format:
//
//      key=value<nul>key=value<nul>key=value<nul><nul>
//
DWORD ReadSetupInfSection( LPTSTR pszInfPath, LPTSTR pszSection, LPTSTR *ppszItems )
{
    DWORD cchTotalRead = 0;

    //
    // Input pointers must be non-NULL.
    //
    if (NULL != pszInfPath && NULL != pszSection && NULL != ppszItems)
    {
        HANDLE hInf = INVALID_HANDLE_VALUE;

        //
        // Initialize caller's buffer pointer.
        //
        *ppszItems = NULL;

        hInf = SetupOpenInfFile(pszInfPath,         // Path to inf file.
                                NULL,               // Allow any inf type.
                                INF_STYLE_OLDNT,    // Old-style text format.
                                NULL);              // Don't care where error happens.

        if (INVALID_HANDLE_VALUE != hInf)
        {
            INFCONTEXT FirstLineContext;            // Context for first line in sect.
            INFCONTEXT ScanningContext;             // Used while scanning.
            INFCONTEXT *pContext        = NULL;     // The one we're using.
            LPTSTR     pszLines         = NULL;     // Buffer for sections.
            DWORD      cchTotalRequired = 0;        // Bytes reqd for section.

            if (SetupFindFirstLine(hInf,         
                                   pszSection,      // Section name.
                                   NULL,            // No key.  Find first line.
                                   &FirstLineContext))
            {
                //
                // Make a copy of context so we can re-use the original later.
                // Start using the copy.
                //
                CopyMemory(&ScanningContext, &FirstLineContext, sizeof(INFCONTEXT));
                pContext = &ScanningContext;

                //
                // Find how large buffer needs to be to hold section text.
                // The value returned by each of these ReadSetupXXXXX calls 
                // includes a terminating nul character.
                //
                do
                {
                    cchTotalRequired += ReadSetupInfFieldKey(pContext,
                                                             NULL,
                                                             0);
                    cchTotalRequired += ReadSetupInfFieldText(pContext,
                                                              NULL,
                                                              0);
                }
                while(SetupFindNextLine(pContext, pContext));

                cchTotalRequired++;  // For terminating double nul.

                //
                // Allocate the buffer.
                //
                pszLines = (LPTSTR)LocalAlloc(LPTR, cchTotalRequired * sizeof(TCHAR));
                if (NULL != pszLines)
                {
                    LPTSTR pszWrite     = pszLines;
                    DWORD  cchAvailable = cchTotalRequired;
                    DWORD  cchThisPart  = 0;        

                    //
                    // We can use the first line context now.
                    // Doesn't matter if we alter it.
                    //
                    pContext = &FirstLineContext;

                    do
                    {
                        cchThisPart = ReadSetupInfFieldKey(pContext,
                                                           pszWrite,
                                                           cchAvailable);

                        if (cchThisPart <= cchAvailable)
                        {
                            cchAvailable -= cchThisPart;  // Decr avail counter.
                            pszWrite     += cchThisPart;  // Adv write pointer.
                            *(pszWrite - 1) = TEXT('=');  // Replace nul with '='
                            cchTotalRead += cchThisPart;  // Adv total counter.
                        }
                        else
                        {
                            //
                            // Something went wrong and we tried to overflow
                            // buffer.  This shouldn't happen.
                            //
                            cchTotalRead = 0;
                            goto InfReadError;
                        }

                        cchThisPart = ReadSetupInfFieldText(pContext,
                                                            pszWrite,
                                                            cchAvailable);

                        if (cchThisPart <= cchAvailable)
                        {
                            cchAvailable -= cchThisPart;  // Decr avail counter.
                            pszWrite     += cchThisPart;  // Adv write pointer.
                            cchTotalRead += cchThisPart;  // Adv total counter.
                        }
                        else
                        {
                            //
                            // Something went wrong and we tried to overflow
                            // buffer.  This shouldn't happen.
                            //
                            cchTotalRead = 0;
                            goto InfReadError;
                        }
                    }
                    while(SetupFindNextLine(pContext, pContext));

                    if (cchAvailable > 0)
                    {
                        //
                        // SUCCESS! Section read without errors.
                        // Return address of buffer to caller.
                        // By allocating buffer with LPTR, text is already 
                        // double-nul terminated.
                        //
                        *ppszItems = pszLines;   
                    }
                    else
                    {
                        //
                        // Something went wrong and we tried to overflow
                        // buffer.  This shouldn't happen.
                        //
                        cchTotalRead = 0;
                    }
                }
            }

InfReadError:

            SetupCloseInfFile(hInf);
        }
    }
    return cchTotalRead;
}




//
// ReadSetupInfCB
//
// pszSection   - Name of INF section without surrounding [].
// lpfnNextLine - Address of callback function called for each item in the section.
// pData        - Data item contains info stored in dialog listbox.
//
// Returns:  0 = Success.
//          -1 = Item callback failed.
//          INSTALL+14 = No INF section found.
//
WORD ReadSetupInfCB(LPTSTR pszInfPath,
                    LPTSTR pszSection,
                    WORD (*lpfnNextLine)(LPTSTR, LPVOID),
                    LPVOID pData)
{
    LPTSTR lpBuffer  = NULL;
    WORD   wResult   = INSTALL+14;       // This is the "no file" message

    //
    // Read in the section from the INF file.
    //
    ReadSetupInfSection(pszInfPath, pszSection, &lpBuffer);

    if (NULL != lpBuffer)
    {
        //
        // Got a buffer full of section text.
        // Each item is nul-terminated with a double nul
        // terminating the entire set of items.
        // Now iterate over the set, calling the callback function
        // for each item.
        //
        LPTSTR pInfEntry = lpBuffer;
        wResult = 0;

        while(TEXT('\0') != *pInfEntry)
        {
            wResult = (*lpfnNextLine)(pInfEntry, pData);
            if ((-1) == wResult)
                break;

            pInfEntry += lstrlen(pInfEntry) + 1;
        }
        LocalFree(lpBuffer);
    }
    return wResult;
}


#else                                 

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//                                                                      //
//         OBSOLETE CODE - Replaced with Win32 Setup API abov  e        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
#include "dbutl.h"
#include "lstrfns.h"

extern TCHAR szSetupInfPath[ PATHMAX ];

#define DEBUGMESSAGES 0

#define READ_BUFSIZE       1024
#define MAX_SCHEMESIZE     180

//
// For Windows NT version, we use UNICODE instead of DBCS and already
// know how to handle AnsiPrev/Next and IsDBCSLeadByte.
//

#ifndef WINNT

#define DBCS
#ifndef DBCS
#define AnsiNext(x) ((x)+1)
#define AnsiPrev(y,x) ((x)-1)
#define IsDBCSLeadByte(x) (FALSE)
#endif
#endif // WINNT


// Function Prototypes

///////////////////////////////////////////////////////////////////////////////
//
// OpenSetupInf() takes the string held in szSetupInfPath as the path
//                to find SETUP.INF and attempts to open it.  The
//                global structure SetupInf is filled.
//  return   -1 indicates failure (see OpenFile doc)
//
///////////////////////////////////////////////////////////////////////////////

#ifdef WINNT

HANDLE FAR PASCAL OpenSetupInf( void )
{
    HANDLE fh;

    DEBUGMSG( (DM_TRACE1, TEXT( "OpenSetupInf: opening %s" ), szSetupInfPath ) );


    if( ( fh = FOPEN( (LPTSTR) szSetupInfPath, NULL ) )
                    == (HANDLE) INVALID_HANDLE_VALUE )
        return( (HANDLE) -1 );
    else
        return( fh );
}

#else

int FAR PASCAL OpenSetupInf( void )
{
    OFSTRUCT os;

    DEBUGMSG( (DM_TRACE1, TEXT( "OpenSetupInf: opening %s" ), szSetupInfPath ) );

    return LZOpenFile( (LPTSTR) szSetupInfPath, (LPOFSTRUCT) &os, OF_READ );
}

#endif  // WINNT

///////////////////////////////////////////////////////////////////////////////
//
// SkipWhite is real straightforward.  Jump over space, tab, carraige
//            returns and newlines.
//
// return:  Pointer to next non-white char or end of string
//
///////////////////////////////////////////////////////////////////////////////

LPTSTR NEAR PASCAL SkipWhite( LPTSTR lpch )
{
    for( ; ; lpch = CharNext( lpch ) )
    {
        switch( *lpch )
        {
            case TEXT( ' ' ):
            case TEXT( '\t' ):
            case TEXT( '\r' ):
            case TEXT( '\n' ):
                break;

            default:
                return( lpch );
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Terminate a line on an unquoted ';', or an EOL.
//  Return 0 if neither one is found, the length otherwise.
//
///////////////////////////////////////////////////////////////////////////////

LPTSTR NEAR PASCAL TermLine( LPTSTR lpPos, LPTSTR pEnd )
{
    BOOL bQuoted = FALSE;

    for( ; ; lpPos = CharNext( lpPos ) )
    {
        if( lpPos >= pEnd )
            return( lpPos );

        switch( *lpPos )
        {
            case TEXT( ';' ):
                if(  bQuoted )
                    break;

            //
            //  This allows a comment at the end of a line. Notice the comment
            //  will actually be skipped when reading the next line.
            //

            case TEXT( '\r' ):
            case TEXT( '\n' ):
                return( lpPos );

            case TEXT( '\0' ):
                return( NULL );

            case TEXT( '"' ):
                bQuoted = !bQuoted;
                break;
        }
    }
}


//
// Locates a given section in an INF file.
// 
// fh - Handle to open INF file.
// pszSect - Section name string.
//
// Returns - Character offset (in file) of first character in section name.
//
DWORD FAR PASCAL FindSection(
#ifdef WINNT
                              HANDLE fh,
#else
                              short fh,
#endif  // WINNT
                              LPTSTR pszSect )
{
    HANDLE  hGlobalBuf  = NULL;
    LPTSTR  lpGlobalBuf = NULL;
    LPTSTR  pch         = NULL;
    LPTSTR  pTmp        = NULL;
    DWORD   dwPos       = 0;
    WORD    cchLen      = 0;
    WORD    cchSize     = 0;
    WORD    cchRead     = 0;
    TCHAR   buffer[ 200 ];
    
    cchLen = lstrlen(pszSect);
    
    //
    // Go to beginning of file
    //

    FSEEK( fh, 0L, SEEK_BEG );

    cchSize = READ_BUFSIZE + 1;
    
    if( !( hGlobalBuf = GlobalAlloc( GMEM_MOVEABLE, cchSize * sizeof(TCHAR) ) )
         || !( lpGlobalBuf = (LPTSTR) GlobalLock( hGlobalBuf ) ) )
    {
        lpGlobalBuf = buffer;
        cchSize = ARRAYSIZE(buffer);
    }
    
    cchSize -= cchLen + (2 + 1);

    FREAD( fh, lpGlobalBuf, cchLen + 2);
    
    do
    {
        //
        // in case of DBCS, it is possible that the last read is a leading byte.
        //
        if (g_bDBCS)
        {
            cchRead = FREAD( fh, lpGlobalBuf + cchLen + 2, cchSize - 1 );
        }
        else
        {
            cchRead = FREAD( fh, lpGlobalBuf + cchLen + 2, cchSize );
        }
        if (0 != cchRead)
        {
            BOOL bEOF = FALSE;

            lpGlobalBuf[ cchRead + cchLen + 2 ] = TEXT( '\0' );

            if (g_bDBCS)
            {
                //
                // in case of DBCS, it is possible that the last read is a leading
                // byte. So appending an extra character for CharNext.
                //
                lpGlobalBuf[ cchRead + cchLen + 3 ] = TEXT( '\0' );
            }

            //
            // Continue as long as I have a complete line.
            //

            pch = lpGlobalBuf;

            while( pTmp = StrChr( pch, TEXT( '\n' ) ) )
            {
               ++pTmp;

               if( *(pch++)==TEXT( '[' ) && !StrCmpN( pch, pszSect, cchLen ) )
               {
                   dwPos += pTmp - lpGlobalBuf;
                   goto FoundIt;
               }

               pch = pTmp;
            }
        
            //
            // Bail out when we reach the end of the file.
            //
            if (g_bDBCS)
            {
                //
                // in case of DBCS, it is possible that the last read is a leading byte.
                //
                bEOF = (cchRead + 1 < cchSize);
            }
            else
            {
                bEOF = cchRead < cchSize;
            }
            if (bEOF)
                break;

            dwPos += cchRead;

            //
            //  Note that we put a TEXT( '\0' ) at offset nRead+wLen+2 and that
            //  TEXT( '\0' ) is illegal in an inf file, so this will copy the last
            //  wLen+2 bytes from the end to the beginning of the buffer
            //

            lstrcpy( lpGlobalBuf, lpGlobalBuf + cchRead );
        }
    }
    while(0 != cchRead);

FoundIt:

    if( lpGlobalBuf != (LPTSTR) buffer )
        GlobalUnlock( hGlobalBuf );

    if( hGlobalBuf )
        GlobalFree( hGlobalBuf );

    return( pTmp ? dwPos : 0 );
}




///////////////////////////////////////////////////////////////////////////////
//
//  Read a line into pPos; the line will start with non-white, and will
//  not contain a comment
//
///////////////////////////////////////////////////////////////////////////////

WORD FAR PASCAL ReadSetupInfCB( LPTSTR pszSection,
                                WORD (FAR PASCAL *lpfnNextLine)( LPTSTR, LPVOID ),
                                LPVOID pData )
{
    HANDLE   hLocal;
    LPTSTR   pBegin, pNext, pEnd, pTemp;
    short    nSize, nReadSize;
    BOOL     bInComment = FALSE;
    DWORD    dwPos;
    WORD     wRet = INSTALL+14;       // This is the "no file" message
    TCHAR    cTemp;


#ifdef WINNT

    HANDLE   fhSetupInf;

    if( ( fhSetupInf = OpenSetupInf( ) ) == (HANDLE) -1 )
        goto Error1;
#else

    int      fhSetupInf;

    if( ( fhSetupInf = OpenSetupInf( ) ) == -1 )
        goto Error1;

#endif  //  WINNT
    
    if( !( dwPos = FindSection( fhSetupInf, pszSection ) ) )
        goto Error2;
    
    nSize = 0;

    wRet = PRN + 3;

GetMoreMem:

    if( !(hLocal = LocalAlloc( LMEM_MOVEABLE | LMEM_ZEROINIT,
                                nSize += READ_BUFSIZE ) ) )
        goto Error2;

    pBegin = (LPTSTR) LocalLock( hLocal );
    
    //
    //  Account for a terminating NULL
    //

    nReadSize = nSize - 1;

    pNext = pBegin;

    pEnd = pBegin + nReadSize;
    
SeekAndRead:

    dwPos += pNext - pBegin;

    //
    //  Get to file position; If we get to EOF, return TRUE
    //

    if( pNext != pEnd )
        FSEEK( fhSetupInf, dwPos, SEEK_BEG );

    if( ( nReadSize = FREAD( fhSetupInf, (LPTSTR)(pNext = pBegin), nReadSize ) ) <= 0 )
        goto FoundEOS;

    *(pEnd = pBegin + nReadSize) = TEXT( '\0' );
    
    while( 1 )
    {
        //
        //  If we were skipping a comment, continue doing so
        //

        if( bInComment )
            goto SkipComment;
    
        while( 1 )
        {
            if( (pNext = SkipWhite( pNext ) ) >= pEnd )
                goto SeekAndRead;
    
            //
            //  We have found a good line if this is not a comment
            //

            if( !( bInComment = (*pNext == TEXT( ';' ) ) ) )
                break;
    
SkipComment:
            for( ; *pNext!=TEXT( '\n' ); pNext = CharNext( pNext ) )
            {
                if( pNext >= pEnd )
                {
                    if (g_bDBCS)
                    {
                        //
                        //  This can only happen if the last byte is a DBCS
                        //  lead byte
                        //

                        if( pNext > pEnd )
                            pNext -= 2;
                    }
                    goto SeekAndRead;
                  }
            }
            bInComment = FALSE;
        }
    
        //
        //  Return TRUE if we have come to the end of the section
        //

        if( *pNext == TEXT( '[' ) )
            break;
    
        //
        //  pTemp==0 means I encountered a TEXT( '\0' ) in the middle of
        //  the file
        //

        if( !( pTemp = TermLine( pNext, pEnd ) ) )
            break;
    
        //
        //  I'm using nSize-1 != nReadSize to indicate EOF
        //  so read again if we have not hit EOL and we are not at EOF
        //

        if( pTemp >= pEnd && nReadSize == nSize-1 )
        {
            if( pNext == pBegin )
            {
                LocalUnlock( hLocal );
                LocalFree( hLocal );
                goto GetMoreMem;
            }
            else
                goto SeekAndRead;
        }
    
        cTemp = *pTemp;

        *pTemp = TEXT( '\0' );

        if( wRet = (*lpfnNextLine )( pNext, pData ) )
            goto Error3;

        *(pNext = pTemp) = cTemp;
    }
    
FoundEOS:
    wRet = NULL;

Error3:
    LocalUnlock( hLocal );
    LocalFree( hLocal );

Error2:
    FCLOSE( fhSetupInf );

Error1:
    return( wRet );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Read a line into pPos; the line will start with non-white, and will
//  not contain a comment
//
///////////////////////////////////////////////////////////////////////////////

short NEAR PASCAL ReadLine(
#ifdef WINNT
                            HANDLE fh,
#else
                            short fh,
#endif  // WINNT
                            DWORD dwPos,
                            LPTSTR pPos,
                            short nSize )
{
    DWORD  dwSavePos = dwPos;
    LPTSTR pStart, pEnd, pTemp;
    short  nSaveSize;
    
    //
    //  Account for a terminating NULL
    //

    nSaveSize = --nSize;
    pStart = pPos;
    
SeekAndRead:
    dwPos += pPos - pStart;

    //
    //  Get to file position
    //

    FSEEK( fh, dwPos, SEEK_BEG );

    if( (nSize = FREAD( fh, (LPTSTR)( pPos = pStart ), nSize ) ) <= 0 )
        return( RL_SECTION_END );

    *(pEnd = pPos + nSize) = TEXT( '\0' );

    while( 1 )
    {
        if( (pPos = OFFSET( SkipWhite( pPos ) ) ) >= pEnd )
            goto SeekAndRead;

        //
        //  We have found a good line if this is not a comment
        //

        if( *pPos != TEXT( ';' ) )
            break;

        for(  ; *pPos != TEXT( '\n' ); pPos = CharNext( pPos ) )
        {
            if( pPos >= pEnd )
            {
                dwPos += pPos - pStart;
                if (g_bDBCS)
                {
                    if( pPos > pEnd )
                    {
                        dwPos -= 2;
                        FSEEK( fh, dwPos, SEEK_BEG );
                    }
                }

                if( (nSize = FREAD( fh, (LPTSTR)( pPos = pStart ), nSize ) )
                             <= 0 )
                {
                    return( RL_SECTION_END );
                }

                *(pEnd = pPos + nSize) = TEXT( '\0' );
            }
        }
    }

    if( *pPos == TEXT( '[' ) )
        return( RL_SECTION_END );

    //
    //  This means I encountered a TEXT( '\0' ) in the middle of the file
    //

    if( !(pTemp = OFFSET( TermLine( pPos, pEnd ) ) ) )
        return( RL_SECTION_END );

    //
    //  I'm using nSize != nSaveSize to indicate EOF
    //

    if( pTemp >= pEnd && nSize == nSaveSize )
    {
        if( pPos == pStart )
            return( RL_MORE_MEM );
        else
            goto SeekAndRead;
    }

    *pTemp = TEXT( '\0' );

    lstrcpy( pStart, pPos );

    return( (int)( dwPos - dwSavePos ) + pTemp - pStart );
}

////////////////////////////////////////////////////////////////////////////////
//
//  This reads a section of setup.inf (control.inf) into a listbox
//  and puts the names into a listbox or combobox; just pass in
//  LB(CB)_ADDSTRING(INSERTSTRING).  If the box is sorted, then
//  ADDSTRING will put it in sorted order.  INSERTSTRING will put
//  it in setup.inf order.
//
///////////////////////////////////////////////////////////////////////////////

int FAR PASCAL ReadSetupInfIntoLBs( HWND hLBName,
                                    HWND hLBDBase,
                                    WORD wAddMsg,
                                    LPTSTR pszSection,
                                    WORD (FAR PASCAL *lpfnGetName)(LPTSTR, LPTSTR ) )
{
#ifdef WINNT
    HANDLE   fhSetupInf;
#else
    int      fhSetupInf;
#endif  //  WINNT
    int    nEntries = 0;
    int    nPlace;
    short  nSuccess;
    DWORD  dwFileLength, dwFilePos;
    HANDLE hLocal, hTemp;
    PTSTR  pLocal;
    TCHAR  szName[ 256 ];
    WORD   wDelMsg, wSize;
    
    //
    //  Determine the delete message (listbox or combobox ).
    //

    wDelMsg = (wAddMsg == LB_ADDSTRING || wAddMsg == LB_INSERTSTRING ) ?
              LB_DELETESTRING : CB_DELETESTRING;
    
    //
    //  Open the file and search for the given section and determine the length.
    //
    
#ifdef WINNT

    if( (fhSetupInf = OpenSetupInf( ) ) == (HANDLE) -1 )
        goto Error1;

#else

    if( (fhSetupInf = OpenSetupInf( ) ) == -1 )
        goto Error1;

#endif  //  WINNT
    
    if( !(dwFilePos = FindSection( fhSetupInf, pszSection ) ) )
        goto Error2;
    
    dwFileLength = FSEEK( fhSetupInf, 0L, SEEK_END );
    
    //
    //  Allocate some memory for reading a line.
    //
    
    if( !(hLocal = LocalAlloc( LMEM_MOVEABLE, wSize = READ_BUFSIZE ) ) )
        goto Error2;
    
    pLocal = (LPTSTR) LocalLock( hLocal );
    
    //
    //  Read a line at a time and add it to the listbox.
    //
    
    while( 1 )
    {
        switch( nSuccess = ReadLine( fhSetupInf, dwFilePos, pLocal, wSize ) )
        {
        case 0:
            goto FileEndReached;
    
        case RL_MORE_MEM:
            //
            //  We should never get to here with reasonable length lines.
            //  If we do get here and are unable to grow the buffer, we must
            //  exit.
            //

            LocalUnlock( hLocal );

            if( !(hTemp = LocalReAlloc( hLocal, wSize += READ_BUFSIZE, LMEM_MOVEABLE ) ) )
                goto Error3;

            pLocal = (LPTSTR) LocalLock( hLocal = hTemp );
            break;
    
        case RL_SECTION_END:
            goto FileEndReached;
            break;
    
        default:
            //
            //  Get the name; add the name (possibly in sorted order);
            //  add the inf string, and increment nEntries if successful,
            //  delete the name otherwise; update the file position.
            //

            (*lpfnGetName )((LPTSTR)szName, (LPTSTR) pLocal );

            if( (nPlace = (int)SendMessage( hLBName, wAddMsg, (UINT) -1,
                                            (DWORD)(LPTSTR) szName ) )
                       >= 0 )
            {
               if( (int) SendMessage( hLBDBase, LB_INSERTSTRING, nPlace,
                                      (DWORD)(LPTSTR) pLocal )
                            >= 0 )
                  ++nEntries;
               else
                  SendMessage( hLBName, wDelMsg, nPlace, 0L );
            }
            if( (dwFilePos += nSuccess) >= dwFileLength )
               goto FileEndReached;
    
            break;
        }
    }
    
FileEndReached:
    LocalUnlock( hLocal );
    
Error3:
    LocalFree( hLocal );
    
Error2:
    FCLOSE( fhSetupInf );
    
Error1:
    return( nEntries );
}


#endif // USE_WIN32_SETUP_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\inc\vecttmpl.h ===
/**********************************************************************
 * VectTmpl.h
 *
 * Template for a vector class.
 *
 **********************************************************************/


#if !defined(__VECTTMPL_H__)
#define __VECTTMPL_H__

#ifndef __DBUTL_H__
#include "dbutl.h"
#endif


const int kNotFound = -1;

//
//  The CIVector class is a vector of pointers to objects (The I is for
//  Indirect).
//

template <class T>
class CIVector {
public:
    CIVector( int iSize );
    ~CIVector( );
    
    int bInit( );
    
    //
    //  The real array functions.
    //

    int   iCount( void );
    int   bAdd( T * t );
    T *   poObjectAt( int idx );
    T *   poDetach( int idx );
    int   bDelete( int idx );
    int   bDelete( T * t );
    void  vDeleteAll( );
    int   iFind( T * t );
    
private:
    T **  m_pData;
    int   m_iSize;
    int   m_iCount;

};

////////////////////////////////////////////////////////////////////////////
template <class T> 
CIVector<T>::CIVector(int iSize)
   :  m_pData(0),
      m_iSize(iSize),
      m_iCount(0)
{}

template <class T> CIVector<T>::~CIVector()
{
    ASSERT( this );
    vDeleteAll( );
    delete [] m_pData;
}

template <class T> int CIVector<T>::bInit()
{
    ASSERT( this );
    int   iRet = 0;
    
    if( !m_pData && (m_iSize > 0) )
    {
        m_pData = new T * [ m_iSize ];

        if( m_pData )
            return 1;
    }
    
    //
    //  Error. Clean up.
    //

    delete this;
    
    return 0;
}


template <class T> int CIVector<T>::iCount(void)
{
    ASSERT( this );
    return m_iCount;
}


template <class T> int CIVector<T>::bAdd(T * t)
{
    ASSERT( this );

#ifdef _DEBUG
    if( !m_pData )
    {
        OutputDebugString( TEXT( "CIVector::bAdd()  m_pData not allocated" ) );
        DebugBreak();
    }

    if( ! t )
        DebugBreak();
#endif

    if ( m_iCount < m_iSize )
    {
        m_pData[ m_iCount++ ] = t;
        return 1;
    }

    return 0;
}

template <class T> T * CIVector<T>::poObjectAt(int idx)
{
    ASSERT( this );

    if( idx >= 0 && idx < m_iCount )
    {
        ASSERT( m_pData[ idx ] );

        return m_pData[ idx ];
    }
    return 0;
}

template <class T> T * CIVector<T>::poDetach(int idx)
{
    ASSERT( this );

    if( idx >= 0 && idx < m_iCount )
    {
        ASSERT( m_pData );

        T * pID = m_pData[ idx ];

        //
        //  Move the last one down
        //

        m_pData[ idx ] = m_pData[ --m_iCount ];

#ifdef _DEBUG
        //
        //  When debugging, put a 0 in the slot.
        //

        m_pData[ m_iCount ] = (T *) 0;
#endif

        ASSERT ( pID );

        return pID;
    }

    return (T *)0;
}

template <class T> int CIVector<T>::bDelete( int idx )
{
    ASSERT( this );
    
    T * pID = poDetach( idx );
    
    if ( pID )
    {
        delete pID;
        return 1;
    }
    
    return 0;
}

template <class T> int CIVector<T>::bDelete( T * t )
{
    ASSERT( this );

    return bDelete( iFind( t ) );
}

template <class T> void CIVector<T>::vDeleteAll()
{
    ASSERT( this );

    while( m_iCount )
        bDelete( 0 );
}

template <class T> int CIVector<T>::iFind( T * t )
{
    ASSERT( this );

    for( int i = 0; i < m_iCount; i++ )
    {
        if( m_pData[ i ] == t )
            return i;
    }

    return kNotFound;
}

#endif   // __VECTTMPL_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\fontcl.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fontcl.cpp
//      Explorer Font Folder extension routines.
//      module to handle classes defined in fontcl.h:
//      CFontClass and DirFilenameClass
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//   All routines for these classes are in this module, EXCEPT:
//   1) inline functions - in FONTCL.H of course
//
// $keywords: fontcl.cpp 1.7  4-May-94 5:24:41 PM$
//
//***************************************************************************
// $lgb$
// 1.0     7-Mar-94 eric Initial revision.
// 1.1     9-Mar-94 eric Background thread and g_hDBMutex
// 1.2     9-Mar-94 eric Added m_bFilledIn
// 1.3     7-Apr-94 eric Removed LoadLibrary on FOT files.
// 1.4     8-Apr-94 eric Added s_szFontsDir
// 1.5    13-Apr-94 eric Calling bFillIn appropriately
// 1.6    15-Apr-94 eric Rip control
// 1.7     4-May-94 build GetOTM changes
// $lge$
//***************************************************************************
//
//  Copyright (C) 1992-93 ElseWare Corporation. All rights reserved.
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include <sys/types.h>
#include <sys/stat.h>

#include "fontcl.h"
#include "fdir.h"
#include "fontdir.h"
#include "resource.h"

#include "lstrfns.h"
#include "dbutl.h"
#include "cpanel.h"
#include "fontman.h"

#include <shlobjp.h>

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifdef WINNT

#ifdef __cplusplus
extern "C" {
#endif

//
// [stevecat]   This used to reside in "wingdip.h" (included with <winp.h>)
//  6/29/95     but I have taken it out because of C++ name-mangling problems
//              with that header file that are not going to be fixed because
//              this file is going to change significantly (according to
//              EricK) when we switch over to Kernel mode GDI/User.
//
//
//#include <stddef.h>     //  Needed for winp.h
//#include <winp.h>       //  For private GDI entry point:  GetFontResourceInfo
//

// Private Control Panel entry point to enumerate fonts by file.

#define GFRI_NUMFONTS       0L
#define GFRI_DESCRIPTION    1L
#define GFRI_LOGFONTS       2L
#define GFRI_ISTRUETYPE     3L
#define GFRI_TTFILENAME     4L
#define GFRI_ISREMOVED      5L
#define GFRI_FONTMETRICS    6L


#include <winfont.h> //Type1 PFM file offsets and reader macros.

extern BOOL WINAPI GetFontResourceInfoW( LPWSTR  lpPathname,
                                         LPDWORD lpBytes,
                                         LPVOID  lpBuffer,
                                         DWORD   iType );

#ifdef __cplusplus
}
#endif

#endif


#define  BYTESTOK(Len) ((Len + 1023) / 1024)   // Convert from bytes to K

//
// Include file to define types and constants needed by the font manager
//   and font routines.
//

#define DEFAULTPOINTS        14

#define FONT_MAN_VERSION     0x0100
#define SMART_FONT_VERSION   0x0200
#define NEW_FONT_VERSION     0x0300

#ifdef ROM
HANDLE FAR PASCAL IsROMModule( LPTSTR lpName, BOOL fSelector );
#endif


BOOL bTTFFromFOT( LPTSTR lpFOTPath, LPTSTR lpTTF, WORD wLen )
{
    PATHNAME szTTFPath;
    BOOL     bValid;

#ifdef WINNT

    ULONG    iSize = sizeof(szTTFPath);


    bValid = GetFontResourceInfoW( lpFOTPath, &iSize, szTTFPath,
                                   GFRI_TTFILENAME );

#else

    HFILE    hfile;
    BOOL     bOpen;


    hfile  = _lopen( lpFOTPath, OF_READ );

    bValid = hfile != HFILE_ERROR;

    //
    //  Peek into the FOT file to find the TTF name
    //

    if( bValid )
    {
        bOpen  = TRUE;
        bValid = _llseek( hfile, 0x400, 0 ) != HFILE_ERROR;
    };

    if( bValid )
         bValid = _lread( hfile, szTTFPath, sizeof( szTTFPath ) ) != HFILE_ERROR;

    if( bOpen )
        _lclose( hfile );

#endif  //  WINNT

    //
    //  We make sure there's a terminating null at the end of the path name.
    //  Then make up a full name.
    //

    if( bValid )
    {
        szTTFPath[ MAX_PATH_LEN ] = TEXT( '\0' );

        bValid = bMakeFQName( lpTTF, szTTFPath, wLen );
    }

    return bValid;

}


/***************************************************************************
 * FUNCTION:
 *
 * PURPOSE:  Load the full directory/path/filename into the given string.
 *              The full name includes the directory name from the database,
 *              with the file name appended to it.
 *
 * RETURNS:  void
 ***************************************************************************/

int GetFontsDirectory( LPTSTR lpPath, int iLen )
{
    static   FullPathName_t s_szFontsDir;
    static   BOOL           s_Fetched = FALSE;
    static   int            iRet = 0;

    //
    //  Get the system directory, which we'll store and pre-fix whenever
    //  a file needs it. Note that there isn't a backslash unless the name
    //  is the root directory.
    //

    if( ( !s_Fetched &&
          SHGetSpecialFolderPath( NULL, s_szFontsDir, CSIDL_FONTS, FALSE ) ) )
    {
        DWORD dwAttr = GetFileAttributes( s_szFontsDir );

        if( dwAttr != (DWORD) -1 && ( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) )
        {
            s_Fetched = TRUE;
            iRet = lstrlen( s_szFontsDir );
        }
    }


    if( !s_Fetched )
    {
        int wLen = GetSystemWindowsDirectory( s_szFontsDir, ARRAYSIZE( s_szFontsDir ) );

        s_Fetched = ( wLen > 0 ) && ( wLen <= ARRAYSIZE( s_szFontsDir ) );

        //
        //  Build up the Fonts directory. This is no longer the System folder.
        //

        if( s_Fetched )
        {
            //
            // Find the last TEXT( "\" ).
            //

            if( s_szFontsDir[ wLen-1 ] != TEXT( '\\' ) )
            {
                s_szFontsDir[ wLen ]   = TEXT( '\\' );
                s_szFontsDir[ wLen+1 ] = 0;
                wLen++;
            }

            LoadString( g_hInst,
                        IDS_FONTS_FOLDER,
                        s_szFontsDir + wLen,
                        ARRAYSIZE( s_szFontsDir ) - wLen );
        }

        iRet = lstrlen( s_szFontsDir );
    }

#ifdef UNICODE
    //
    //  Make an ANSI version of szSharedDir for t1instal call
    //
    if( WideCharToMultiByte( CP_ACP, 0, s_szFontsDir, -1,
                              g_szFontsDirA, PATHMAX, NULL, NULL ) == FALSE )
    {
        //
        //  Report initialization error
        //

        iUIMsgExclaim(NULL, MYFONT + 18, s_szFontsDir );

        return (FALSE);
    }
#else
    lstrcpy(g_szFontsDirA, s_szFontsDir);
#endif

    if( iRet <= iLen )
        lstrcpy( lpPath, s_szFontsDir );

    return iRet;
}


/***************************************************************************
 * DirFilenameClass routines:
 ***************************************************************************/

/***************************************************************************
 * FUNCTION: vGetFullName
 *
 * PURPOSE:  Load the full directory/path/filename into the given string.
 *              The full name includes the directory name from the database,
 *              with the file name appended to it.
 *
 * RETURNS:  void
 ***************************************************************************/

void DirFilenameClass :: vGetFullName( PTSTR pStr )
{
    ASSERT(NULL != m_poDir);
    lstrcpy( pStr, m_poDir->lpString( ) );

    if( pStr[ lstrlen( pStr ) - 1 ] != TEXT( '\\' ) )
        lstrcat( pStr, TEXT( "\\" ) );

    lstrcat( pStr, m_szFOnly );
}


//
// Add a single directory to a directory list.
//
BOOL CFontClass::bAddDirToDirList(
    CFontDirList *pDirList,
    LPCTSTR pszDir,
    BOOL bSystemDir
    )
{
    BOOL bResult = FALSE;

    CFontDir *poDir = new CFontDir;
    if (NULL != poDir)
    {
        if (poDir->bInit(pszDir, lstrlen(pszDir)))
        {
            poDir->vOnSysDir(bSystemDir);
            if (pDirList->Add(poDir))
            {
                poDir   = NULL;  // Now owned by list.
                bResult = TRUE;
            }
        }
        if (NULL != poDir)
        {
            //
            // CFontDir object not owned by list.
            //
            delete poDir;
        }
    }
    return bResult;
}
    
    


/***************************************************************************
 * FUNCTION: rcStoreDirFN
 *
 * PURPOSE:  Store a directory path in our path list.
 *
 * RETURNS:  RC - NOERR unless directory list full or name too long
 ***************************************************************************/

CFontDir * CFontClass::poAddDir( LPTSTR lpPath, LPTSTR * lpName )
{
    *lpName = NULL;

    LPTSTR lpLastSlash;
    LPTSTR lpFileOnly;
    CFontDir * poDir = 0;

    //
    //  The first time through, allocate the directory struct.
    //
    CFontDirList *pDirList;
    if (CFontDirList::GetSingleton(&pDirList))
    {
        if (pDirList->IsEmpty())
        {
            //
            //  Load the default directory into the font dir list. It is expected
            //  to be at location 0, so we add it first.
            //
            FullPathName_t szBaseDir;
            szBaseDir[0] = 0;
            
            GetFontsDirectory(szBaseDir, ARRAYSIZE(szBaseDir));
            if (!bAddDirToDirList(pDirList, szBaseDir, TRUE))
            {
                pDirList->Clear();
                return 0;
            }
            //
            //  Add the <win>\system directory. We use it for compatibility reasons.
            // It is located in slot 1.
            //
            szBaseDir[0] = 0;
            GetSystemDirectory(szBaseDir, ARRAYSIZE(szBaseDir));
            if (!bAddDirToDirList(pDirList, szBaseDir, TRUE))
            {
                pDirList->Clear();
                return 0;
            }
        }
 
        //
        //  If we find a backslash in the path name, the name includes a directory
        //  If so, we're going to store the directory name in a separate list.
        //  Otherwise, we reserve slot 0 for the default directory cases.
        //

        // Force same case file (?)
        // lstrcpy( lpPath, /* _strlwr */ (lpPath ) );

        lpLastSlash = StrRChr( lpPath, NULL, TEXT( '\\' ) );


        TCHAR szTempFile[ MAX_PATH_LEN ];


        if( !lpLastSlash )
        {
            if( !bMakeFQName( szTempFile, lpPath, MAX_PATH_LEN, TRUE ) )
            {
                return( NULL );
            }

            *lpName = lpPath;
            lpPath = szTempFile;

            lpLastSlash = StrRChr( lpPath, NULL, TEXT( '\\' ) );

            if( !lpLastSlash )
            {
                //
                // This should never happen
                //

                return( NULL );
            }
        }

        lpFileOnly = lpLastSlash+1;

        //
        // Try to find the directory in the list.
        //

        int iLen = (int)(lpFileOnly - lpPath - 1);

        poDir = pDirList->Find( lpPath, iLen, TRUE );

        if( !*lpName )
        {
            *lpName = lpFileOnly;
        }
    }
    return poDir;
}


RC CFontClass :: rcStoreDirFN( LPTSTR lpszPath, DirFilenameClass& dirfn )
{
    RC     rc = ERR_FAIL;
    LPTSTR lpName;
    CFontDir * poDir = poAddDir( lpszPath, &lpName );

    if( poDir && ( lstrlen( lpName ) <= MAX_FILE_LEN ) )
    {
        dirfn.vSet( poDir, lpName );

        rc = NOERR;
    }

    return rc;
}


#if 0
/***************************************************************************
 * FUNCTION: vStuffPANOSE
 *
 * PURPOSE:  Load the PANOSE info for this font (if needed).
 *
 * RETURNS:  void
 ***************************************************************************/

void CFontClass :: vStuffPANOSE( )
{
    PANOSEBytesClass xUsePANOSE;    // Will initialize as dummy;

    //
    // The best thing would be to get the PANOSE info from the font itself,
    // so try that first.  Even if we can read it, we need to determine if
    // we really have a PANOSE number, or just a dummy.  The problem is,
    // the TT file will have the OS2 table, but the PANOSE number might
    // be bogus.  With any luck, it'll be something we can recognize as
    // invalid.
    //

    if( rcPANOSEFromTTF( xUsePANOSE ) == NOERR )
        m_fHavePANOSE = xUsePANOSE.bVerify( );
    else
        m_fHavePANOSE = FALSE;

    //
    //  If we don't have a valid PANOSE number, make sure we've got a clean one
    //

    if( !m_fHavePANOSE )
        xUsePANOSE.vClear( );

    m_jFamily = xUsePANOSE.jFamily( );

    memcpy( m_xPANOSE.m_ajNumMem,
            xUsePANOSE.m_ajBytes,
            sizeof( m_xPANOSE.m_ajNumMem ) );

}
#endif

DWORD CFontClass :: dCalcFileSize( )
{
    //
    //  First we get the size of the basis file
    //

    GetFileInfo( );

    return m_wFileK;
}


/***************************************************************************
 * Start of Public routines
 ***************************************************************************/

/***************************************************************************
 * FUNCTION: bAFR
 *
 * PURPOSE:  Add font resource
 *
 * RETURNS:  TRUE on success.
 ***************************************************************************/

BOOL CFontClass::bAFR( )
{
    if( !m_bAFR )
    {
        FullPathName_t szFile;
        LPTSTR pszResourceName = szFile;

#ifdef WINNT
        TCHAR szType1FontResourceName[MAX_TYPE1_FONT_RESOURCE];
#endif

        if( !bGetFOT( szFile, ARRAYSIZE( szFile ) ) )
        {
            bGetFQName( szFile, ARRAYSIZE( szFile ) );
        }

#ifdef WINNT

        if (bType1())
        {
            //
            // Font is a Type1.
            // Create a Type1 font resource name as:  "<pfm>|<pfb>"
            //
            TCHAR szPfbPath[MAX_PATH];

            if (bGetPFB(szPfbPath, ARRAYSIZE(szPfbPath)) &&
                BuildType1FontResourceName(szFile,
                                           szPfbPath,
                                           szType1FontResourceName,
                                           ARRAYSIZE(szType1FontResourceName)))
            {
                pszResourceName = szType1FontResourceName;
            }
        }
#endif // WINNT

        if( AddFontResource(pszResourceName) )
            m_bAFR = TRUE;
   }

   return m_bAFR;
}


void CFontClass::GetFileInfo( )
{
    TCHAR szPath[ MAX_PATH ];
    WIN32_FIND_DATA fd;

//
// TODO: [stevecat] Change this to check the FONT Type for this font.
//                  if bType1 == TRUE then add size of PFB file also
//                  to total font size for a more accurate representation
//                  of total Type1 font file sizes.
//


    if( !m_bFileInfoFetched )
    {
        m_ft.dwLowDateTime  = 0;
        m_ft.dwHighDateTime = 0;

        if( bGetFQName( szPath, ARRAYSIZE( szPath ) ) )
        {
            HANDLE hfind = FindFirstFile( szPath, &fd );

            m_bFileInfoFetched  = TRUE;

            if( hfind != INVALID_HANDLE_VALUE )
            {
                m_wFileK = (UINT) BYTESTOK( fd.nFileSizeLow );
                m_ft     = fd.ftLastWriteTime;

                FindClose( hfind );
            }
        }

//
// [stevecat] Add check for existing PFB file and add its size to this
//  FIXIFX - test this to be sure PFB filename is getting full path for
//           FindFile call.
//

        if( bPFB( ) )
        {
//            TCHAR szPfbFile[ MAX_PATH ];

//            if( bGetPFB( szPfbFile, ARRAYSIZE( szPfbFile ) )
//            {
//                if( bMakeFQName( szPath, szPfbFile, ARRAYSIZE( szPath ) ) )

            if( bMakeFQName( szPath, m_lpszPFB, ARRAYSIZE( szPath ) ) )
            {
                HANDLE hfind = FindFirstFile( szPath, &fd );

                m_bFileInfoFetched  = TRUE;

                if( hfind != INVALID_HANDLE_VALUE )
                {
                    m_wFileK += (UINT) BYTESTOK( fd.nFileSizeLow );

                    FindClose( hfind );
                }
            }
//            }
        }

    }
}


BOOL CFontClass::GetFileTime( FILETIME * pft )
{
    GetFileInfo( );

    *pft = m_ft;

    return( pft->dwLowDateTime || pft->dwHighDateTime );
}


/***************************************************************************
 * FUNCTION: bRFR
 *
 * PURPOSE:  Remove font resource
 *
 * RETURNS:  TRUE on success.
 ***************************************************************************/
BOOL CFontClass::bRFR( )
{
    if( m_bAFR )
    {
        FullPathName_t szFile;
        LPTSTR pszResourceName = szFile;

#ifdef WINNT
        TCHAR szType1FontResourceName[MAX_TYPE1_FONT_RESOURCE];
#endif

        //
        // GDI seems to be particular about full pathname and partial name.
        // Try both if necessary.
        //

        if( !bGetFOT( szFile, ARRAYSIZE( szFile ) ) )
        {
            bGetFQName( szFile, ARRAYSIZE( szFile ) );
        }

        m_bAFR = FALSE;

#ifdef WINNT

        if (bType1())
        {
            //
            // Font is a Type1.
            // Create a Type1 font resource name as:  "<pfm>|<pfb>"
            //
            TCHAR szPfbPath[MAX_PATH];

            if (bGetPFB(szPfbPath, ARRAYSIZE(szPfbPath)) &&
                BuildType1FontResourceName(szFile,
                                           szPfbPath,
                                           szType1FontResourceName,
                                           ARRAYSIZE(szType1FontResourceName)))
            {
                pszResourceName = szType1FontResourceName;
            }
        }

#endif // WINNT

        if( !RemoveFontResource( pszResourceName ) )
        {
            TCHAR szFN[ MAX_PATH_LEN ];

            vGetFileName( szFN );

            if( bFOT( ) || !RemoveFontResource( szFN ) )
            {
                //
                // If the file doesn't exist, then it couldn't be in GDI.
                //

                if( GetFileAttributes( szFile ) != 0xffffffff )
                    m_bAFR = TRUE;
            }
        }
    }

    return( !m_bAFR );
}


#ifndef    CHECKFILENAMEFIRST

BOOL CFontClass :: bInit( LPTSTR lpszDesc, LPTSTR lpFileName, LPTSTR lpCompanionFile )
{
    static const TCHAR    c_szPLOTTER     [] = TEXT( " (PLOTTER)" );
    static const TCHAR    c_szTRUETYPE    [] = TEXT( " (TRUETYPE)" );
    static const TCHAR    c_szTRUETYPEALT [] = TEXT( " (TRUE TYPE)" );
    static const TCHAR    c_szTYPE1       [] = TEXT( " (TYPE 1)" );
    static const TCHAR    c_szTYPE1ALT    [] = TEXT( " (POSTSCRIPT)" );
    static const TCHAR    c_szFOT         [] = TEXT( ".FOT" );
    static const TCHAR    c_szTTF         [] = TEXT( ".TTF" );
    static const TCHAR    c_szTTC         [] = TEXT( ".TTC" );
    static const TCHAR    c_szOTF         [] = TEXT( ".OTF" );
    static const TCHAR    c_szPFM         [] = TEXT( ".PFM" );
    static const TCHAR    c_szINF         [] = TEXT( ".INF" );

    LPTSTR  pTT;
    LPTSTR  lpszEn;
    BOOL    bSuccess = TRUE;


    LPCTSTR lpName = lpNamePart( lpFileName );


    if( !lpName )
    {
        lpName = lpFileName;
    }

    FullPathName_t szName;

    lstrcpyn( szName, lpName, ARRAYSIZE( szName ) );

    CharUpper( szName );

    m_bFileInfoFetched = FALSE;

    //
    // Store the file name.
    //

    if( rcStoreDirFN( lpFileName ) != NOERR )
    {
        delete this;
        return FALSE;
    }

    //
    // Figure out what type of font this is.
    //

    lpszEn = _tcsstr( lpszDesc, TEXT( " (" ) );

    if( lpszEn == NULL )
    {
        //
        //  There's no additional description, so set filetype based on
        //  extension.
        //

        m_wNameLen = (BYTE)lstrlen( lpszDesc );

        if( _tcsstr( szName, c_szTTF ) )
            vSetTrueType( FALSE );
        else if( _tcsstr( szName, c_szOTF ) )
            vSetOpenType( );
        else if( _tcsstr( szName, c_szTTC ) )
            vSetTTCType( );
        else if( _tcsstr( szName, c_szPFM ) )
        {
            vSetType1( );

            if( lpCompanionFile != NULL )
                bSetPFB( lpCompanionFile );
        }
        else if( _tcsstr( szName, c_szINF ) )
        {
            vSetType1( );

            if( lpCompanionFile != NULL )
                bSetPFB( lpCompanionFile );
        }
    }
    else
    {
        m_wNameLen = (BYTE)(lpszEn-lpszDesc);

        FontDesc_t szEn;

        lstrcpyn( szEn, lpszEn, ARRAYSIZE( szEn ) );

        CharUpper( szEn );

        pTT = _tcsstr( szEn, c_szTRUETYPE );

        if( !pTT )
            pTT = _tcsstr( szEn, c_szTRUETYPEALT );

        if( pTT )
        {
            //
            //  This is either a TTF or an FOT
            //

            BOOL bFOT = ( _tcsstr( szName, c_szFOT ) != (LPTSTR) NULL );

            if( bFOT )
            {
                FullPathName_t szTTF;
                FullPathName_t szFOT;

                if( bMakeFQName( szFOT, lpFileName, ARRAYSIZE( szFOT ) ) )
                {
                    bSuccess = bTTFFromFOT( szFOT, szTTF, ARRAYSIZE( szTTF ) );

                    if( bSuccess )
                    {
                        if( !bSetFOT( szFOT ) )
                        {
                            delete this;
                            return( FALSE );
                        }

                        return bInit( lpszDesc, szTTF, NULL );
                    }
                }

                //
                //  error
                //

                delete this;
                return FALSE;
            }

            vSetTrueType( bFOT );

            if( _tcsstr( szName, c_szTTC ) )
                vSetTTCType( );
        }
        else if( _tcsstr( szName, c_szOTF ) )
        {
            vSetOpenType( );
        }
        else if( _tcsstr( szName, c_szTTC ) )
        {
            vSetTTCType( );
        }
        else if( _tcsstr( szName, c_szTYPE1 ) )
        {
            vSetType1( );

            if( lpCompanionFile != NULL )
                bSetPFB( lpCompanionFile );
        }
        else if( _tcsstr( szName, c_szTYPE1ALT ) )
        {
            vSetType1( );

            if( lpCompanionFile != NULL )
                bSetPFB( lpCompanionFile );
        }
        else    //   if( _tcsstr( szEn, c_szPLOTTER ) == NULL )
        {
            vSetDeviceType( );
        }
    }

    lstrcpyn( m_szFontLHS, lpszDesc, ARRAYSIZE( m_szFontLHS ) );

    //
    //  It is assumed that this font is already installed.
    //  Set the flag to assume it.
    //

    m_bAFR = TRUE;

    //
    // Set this to be the main family font. This will be reset as necessary.
    //

    m_wFamIdx = IDX_NULL;

    vSetFamilyFont( );

    //
    // Invalidate the font object's cached file attributes.
    // They will be refreshed next time dwGetFileAttributes() is called for
    // this object.
    //
    InvalidateFileAttributes();

    return bSuccess;
}

#else    // !CHECKFILENAMEFIRST

BOOL CFontClass :: bInit( LPTSTR lpszDesc, LPTSTR lpFileName, LPTSTR lpCompanionFile )
{
    static const TCHAR    c_szTRUETYPE    [] = TEXT( " (TRUETYPE)" );
    static const TCHAR    c_szTRUETYPEALT [] = TEXT( " (TRUE TYPE)" );
    static const TCHAR    c_szTYPE1       [] = TEXT( " (TYPE 1)" );
    static const TCHAR    c_szTYPE1ALT    [] = TEXT( " (POSTSCRIPT)" );
    static const TCHAR    c_szFOT         [] = TEXT( ".FOT" );
    static const TCHAR    c_szTTF         [] = TEXT( ".TTF" );
    static const TCHAR    c_szTTC         [] = TEXT( ".TTC" );
    static const TCHAR    c_szFON         [] = TEXT( ".FON" );
    static const TCHAR    c_szPFM         [] = TEXT( ".PFM" );
    static const TCHAR    c_szINF         [] = TEXT( ".INF" );

    BOOL    bFoundType = FALSE;

    m_bFileInfoFetched = FALSE;

    //
    //  Store the file name.
    //

    if( rcStoreDirFN( lpFileName ) != NOERR )
    {
        delete this;
        return FALSE;
    }

    //
    //  Figure out what type of font this is.
    //

    LPTSTR lpExt = PathFindExtension( lpFileName );

    if( lpExt )
    {
        bFoundType = TRUE;

        FullPathName_t szExt;

        lstrcpyn( szExt, lpExt, ARRAYSIZE( szExt ) );

        PathRemoveBlanks( szExt );

        if( _tcsicmp( szExt, c_szTTF ) == 0 )
        {
            vSetTrueType( FALSE );
        }
        else if( _tcsicmp( szName, c_szTTC ) == 0 )
        {
            vSetTTCType( );
        }
        else if( _tcsicmp( szName, c_szFON ) == 0 )
        {
            vSetDeviceType( );
        }
        else if( _tcsicmp( szName, c_szPFM ) == 0 )
        {
            vSetType1( );

            if( lpCompanionFile != NULL )
                bSetPFB( lpCompanionFile );
        }
        else if( _tcsicmp( szName, c_szINF ) == 0 )
        {
            vSetType1( );

            if( lpCompanionFile != NULL )
                bSetPFB( lpCompanionFile );
        }
        else if( _tcsicmp( szName, c_szFOT ) == 0 )
        {
            FullPathName_t szTTF;
            FullPathName_t szFOT;

            if( bMakeFQName( szFOT, lpFileName, ARRAYSIZE( szFOT ) ) )
            {
                if( bTTFFromFOT( szFOT, szTTF, ARRAYSIZE( szTTF ) ) )
                {
                    if( bSetFOT( szFOT ) )
                    {
                        delete this;
                        return bInit( lpszDesc, szTTF, NULL );
                    }
                }
            }

            //
            //  Bad thing if we got here
            //

            delete this;
            return( FALSE );
        }
        else
        {
            bFoundType = FALSE;
        }
    }

    LPTSTR lpszEn = _tcsstr( lpszDesc, TEXT( " (" ) );

    if( lpszEn == NULL )
    {
        m_wNameLen = lstrlen( lpszDesc );
    }
    else
    {
        m_wNameLen = lpszEn-lpszDesc;

        if( !bFoundType )
        {
            FontDesc_t szEn;

            lstrcpyn( szEn, lpszEn, ARRAYSIZE( szEn ) );

            CharUpper( szEn );

            LPTSTR pTT = _tcsstr( szEn, szTRUETYPE );

            if( !pTT )
            {
                pTT = _tcsstr( szEn, szTRUETYPEALT );
            }

            if( pTT )
            {
                vSetTrueType( FALSE );
            }
            else if( _tcsstr( szName, c_szTYPE1 ) )
            {
                vSetType1( );

                if( lpCompanionFile != NULL )
                    bSetPFB( lpCompanionFile );
            }
            else if( _tcsstr( szName, c_szTYPE1ALT ) )
            {
                vSetType1( );

                if( lpCompanionFile != NULL )
                    bSetPFB( lpCompanionFile );
            }
            else
            {
                vSetDeviceType( );
            }
        }
    }

    lstrcpy( m_szFontLHS, lpszDesc );

    //
    //  It is assumed that this font is already installed.
    //  Set the flag to assume it.
    //

    m_bAFR = TRUE;

    //
    //  Set this to be the main family font. This will be reset as necessary.
    //

    m_wFamIdx = IDX_NULL;

    vSetFamilyFont( );

    //
    // Invalidate the font object's cached file attributes.
    // They will be refreshed next time dwGetFileAttributes() is called for
    // this object.
    //
    InvalidateFileAttributes();

    return( TRUE );
}
#endif    // !CHECKFILENAMEFIRST


//
// Retrieve the font object's cached file attributes.
// If invalid, refresh attribute value from the file system.
//
DWORD CFontClass::dwGetFileAttributes(void)
{
    if (!m_bAttributesValid)
    {
        //
        // Cached value is invalid.
        // Refresh from file system.
        //
        TCHAR szPath[MAX_PATH] = { TEXT('\0') };

        //
        // Get full path to file.
        //
        if (!bGetFileToDel(szPath))   // Gets path if local font file.
            vGetDirFN(szPath);        // Gets path if remote font file.

        if (TEXT('\0') != szPath[0])
        {
            DWORD dwAttr = GetFileAttributes(szPath);
            if ((DWORD)~0 != dwAttr)
                m_dwFileAttributes = dwAttr;
        }
        m_bAttributesValid;            
    }
    return m_dwFileAttributes;
}


#ifdef WINNT

///////////////////////////////////////////////////////////////////////////////
// FUNCTION: CFontClass::GetLogFontInfo
//
//  DESCRIP: Retrieves a list of LOGFONT structures for a font resource.
//
//     ARGS: pszPath
//              Pointer to the font file path string.
//
//           ppLogFontInfo
//              Address of a pointer to an array of LOGFONT structures.
//              The function writes the address of the LOGFONT array
//              to this location.
//
//  RETURNS: Number of LOGFONT structures in returned array.
//
//    NOTES: If *ppLogFontInfo is non-NULL on return,
//           caller must delete array of LOGFONT structures using
//           LocalFree() when finished with it.
//
///////////////////////////////////////////////////////////////////////////////
DWORD CFontClass::GetLogFontInfo(LPTSTR pszPath, LOGFONT **ppLogFontInfo)
{
    DWORD dwNumFonts = 0;
    DWORD dwBufSize = 0;

    ASSERT(NULL != pszPath);
    ASSERT(NULL != ppLogFontInfo);

    dwBufSize = sizeof(dwNumFonts);
    //
    // Get the number of fonts in the font resource.
    //
    if ( NULL != pszPath &&
         NULL != ppLogFontInfo &&
         GetFontResourceInfoW(pszPath,
                              &dwBufSize,
                              &dwNumFonts,
                              GFRI_NUMFONTS) )
    {
        *ppLogFontInfo = (LPLOGFONT)LocalAlloc(LPTR, sizeof(LOGFONT) * dwNumFonts);

        if ( NULL != *ppLogFontInfo )
        {
            dwBufSize = sizeof(LOGFONT) * dwNumFonts;
            //
            // Now get the array of LOGFONT structures.
            //
            if (!GetFontResourceInfoW(pszPath,
                                      &dwBufSize,
                                      *ppLogFontInfo,
                                      GFRI_LOGFONTS))
            {
                //
                // GetFontResourceInfo failed.
                // Clean up and adjust return value to indicate failure.
                //
                LocalFree(*ppLogFontInfo);
                *ppLogFontInfo = NULL;
                dwNumFonts     = 0;
            }
        }
    }
    return dwNumFonts;
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION: CFontClass::GetType1Info
//
//  DESCRIP: Retrieves the family name, style and weight metrics from a Type 1
//           PFM (printer font metrics) file.  Maps a view of the file and
//           reads the required information.
//           Offsets into the PFM file are obtained from the gdi file winfont.h.
//
//           The macros READ_WORD( ) and READ_DWORD( ) handle byte-ordering
//           differences between the Type1 file and memory.
//
//     ARGS: pszPath
//              Pointer to the font file path string.
//
//           pszFamilyBuf
//              Address of destination buffer for family name string.
//              Can be NULL.
//
//           nBufChars
//              Number of characters in family name buffer.
//              Ignored if pszFamilyBuf is NULL.
//
//           pdwStyle
//              Address of DWORD where style value is written.
//              Style will be FDI_S_ITALIC or FDI_S_REGULAR.
//              Can be NULL.
//
//           pwWeight
//              Address of WORD where weight value is written.
//              Can be NULL.
//
//  RETURNS: SUCCESS
//           or Win32 Error code.
//
///////////////////////////////////////////////////////////////////////////////
DWORD CFontClass::GetType1Info(LPCTSTR pszPath,
                               LPTSTR pszFamilyBuf,
                               UINT nBufChars,
                               LPDWORD pdwStyle,
                               LPWORD pwWeight)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwResult = ERROR_SUCCESS;

    ASSERT(NULL != pszPath);

    if (NULL != pszPath &&
       (hFile = CreateFile(pszPath,
                           GENERIC_READ,
                           0,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL)) != INVALID_HANDLE_VALUE )
    {
        HANDLE hFileMapping = INVALID_HANDLE_VALUE;

        if ((hFileMapping = CreateFileMapping(hFile,
                                              NULL,
                                              PAGE_READONLY,
                                              0,
                                              0,
                                              NULL)) != NULL)
        {
            LPCSTR pbFile = NULL;

            if ((pbFile = (LPCSTR)MapViewOfFile(hFileMapping,
                                                FILE_MAP_READ,
                                                0,
                                                0,
                                                0)) != NULL)
            {
                //
                // Get font style.
                //
                if ( NULL != pdwStyle )
                    *pdwStyle = READ_DWORD(&pbFile[OFF_Italic]) ? FDI_S_ITALIC : FDI_S_REGULAR;

                //
                // Get font weight.
                //
                if ( NULL != pwWeight )
                    *pwWeight = READ_WORD(&pbFile[OFF_Weight]);

                //
                // Get family (face) name string.
                //
                if ( NULL != pszFamilyBuf )
                {
                    LPCSTR pszFaceName = (LPCSTR)(pbFile + READ_DWORD(&pbFile[OFF_Face]));

                    MultiByteToWideChar(CP_ACP,
                                        0,
                                        pszFaceName,
                                        -1,
                                        pszFamilyBuf,
                                        nBufChars);
                }
                UnmapViewOfFile(pbFile);
            }
            else
                dwResult = GetLastError();

            CloseHandle(hFileMapping);
        }
        else
            dwResult = GetLastError();

        CloseHandle(hFile);
    }
    else
        dwResult = GetLastError();

    return dwResult;
}

#endif // WINNT


/***************************************************************************
 * FUNCTION: bFillIn
 *
 * PURPOSE:  This functions is used to fill in values that may not be
 *           necessary right away. This includes: Panose number and
 *           family name.
 *
 *
 * RETURNS:  TRUE if value is successfully filled in.
 ***************************************************************************/
BOOL CFontClass :: bFillIn( )
{
    FONTDESCINFO   fdi;

    if( !m_bFilledIn )
    {
        //
        //  If this is a TTC file, we don't care about PANOSE numbers and
        //  family names.
        //

        if( bTTC( ) )
        {
            // vSetFamName( szGetDesc( ) );

            m_lpszFamName = m_szFontLHS;

            vSetFamilyFont( );
        }
        else if( bTrueType( ) || bOpenType( ) )
        {
            if( !bGetFQName( fdi.szFile, ARRAYSIZE( fdi.szFile ) ) )
                goto errout1;

            fdi.dwFlags = FDI_ALL;

            //
            //  Set this as a family font. (We set it so it
            //  doesn't disappear on "hide variations". It will get reset as
            //  soon as possible.)
            //

            vSetFamilyFont( );

            if( !bIsTrueType( &fdi ) )
            {
                //
                // Couldn't open font file for Type1 info.
                // One reason is a font shortcut who's link has been broken.
                // All we have for a name is the LHS string from the registry.
                // Remove the decoration and use it.
                //
                lstrcpyn(m_szFamName, m_szFontLHS, ARRAYSIZE(m_szFamName));
                RemoveDecoration(m_szFamName, TRUE);
                goto errout1;
            }

            //
            //  Copy over font info.
            //

            memcpy( m_xPANOSE.m_ajBytes, &fdi.jPanose, PANOSE_LEN );

            lstrcpy( m_szFamName, fdi.szFamily );

            m_wWeight = fdi.wWeight;

            // m_fItalic = fdi.dwStyle & FDI_S_ITALIC;

            m_dwStyle = fdi.dwStyle;

            //
            //  Verify the PANOSE number.
            //

            if( !m_xPANOSE.bVerify( ) )
            {
                m_xPANOSE.vClear( );

                // m_fHavePANOSE = FALSE;
            }
            else
                // m_fHavePANOSE = TRUE;
                m_jFamily = m_xPANOSE.jFamily( );
        }
#ifdef WINNT
        else if ( bType1() )
        {
            if( ! bGetFQName( fdi.szFile, ARRAYSIZE( fdi.szFile ) ) )
                goto errout1;

            //
            // Make sure we're dealing with a PFM file.
            // GetType1Info only knows how to read a PFM.
            //
            LPTSTR pszDot = StrRChr(fdi.szFile, NULL, TEXT('.'));

            if (NULL != pszDot && lstrcmpi(pszDot+1, TEXT("PFM")) == 0)
            {
                if (ERROR_SUCCESS != GetType1Info(fdi.szFile,
                                                  m_szFamName,
                                                  ARRAYSIZE(m_szFamName),
                                                  &m_dwStyle,
                                                  &m_wWeight))
                {
                    //
                    // Couldn't open font file for Type1 info.
                    // One reason is a font shortcut who's link has been broken.
                    // All we have for a name is the LHS string from the registry.
                    // Remove the decoration and use it.
                    //
                    lstrcpyn(m_szFamName, m_szFontLHS, ARRAYSIZE(m_szFamName));
                    RemoveDecoration(m_szFamName, TRUE);
                }
            }
            else
            {
                //
                // If this code is hit, it means that we have installed
                // something other than a PFM file as a Type1 font.  This is
                // an error that must be corrected.
                // Fill in with some safe values so we don't have just garbage.
                // During development, complain about it.
                //
                DEBUGMSG((DM_TRACE1, TEXT("Non-PFM file (%s) installed for Type1 font."),
                                     fdi.szFile));
                ASSERT(0);

                m_szFamName[0] = TEXT('\0');
                m_dwStyle      = 0;
                m_wWeight      = 0;
            }
        }
#else
        //
        // Win95 doesn't support Type 1 fonts (yet).
        //
#endif
        //
        //  FNT files.
        //
        else
        {
            if( ! bGetFQName( fdi.szFile, ARRAYSIZE( fdi.szFile ) ) )
                goto errout1;

            fdi.dwFlags = FDI_ALL;

            vSetFamilyFont( );

            if( bIsNewExe( &fdi ) )
            {
                //
                // Copy over font info.
                //

                lstrcpy( m_szFamName, fdi.szFamily );

                m_wWeight = fdi.wWeight;

                m_dwStyle = fdi.dwStyle;
            }
#ifdef WINNT
            else
            {
                //
                // Probably a 32-bit font resource.
                // Even if there are multiple fonts in resource,
                // just use info from first font.
                //
                LOGFONT *paLogFontInfo = NULL;
                DWORD dwNumLogFonts    = 0;

                dwNumLogFonts = GetLogFontInfo(fdi.szFile, &paLogFontInfo);
                if ( 0 != dwNumLogFonts && NULL != paLogFontInfo)
                {
                    lstrcpy(m_szFamName, (paLogFontInfo + 0)->lfFaceName);
                    m_wWeight = (WORD)((paLogFontInfo + 0)->lfWeight);
                    m_dwStyle = ((paLogFontInfo + 0)->lfItalic ? FDI_S_ITALIC : FDI_S_REGULAR);
                    LocalFree(paLogFontInfo);
                }
                else
                    goto errout1;
            }
#else
            else
                goto errout1;
#endif

        }

        m_bFilledIn = TRUE;
    }

errout1:
    return m_bFilledIn;
}


/***************************************************************************
 * FUNCTION: bGetFQName
 *
 * PURPOSE:  Get the fully qualified FOT filename of the file associated with
 *              the input font record.  This is the FQ version of the filename
 *              found in WIN.INI.
 *
 *           Assumes: lpsz is of size wLen + 1
 *
 * RETURNS:  TRUE if successful
 ***************************************************************************/
BOOL CFontClass :: bGetFQName( LPTSTR lpsz, WORD wLen )
{
    //
    //  Get the font's directory path, and make the fully qualified name from
    //  that.
    //

    PATHNAME  szPath;

    vGetDirFN( szPath );

    return bMakeFQName( lpsz, szPath, wLen );
}


BOOL CFontClass::bGetFileToDel( LPTSTR szFileName )
{
    if( bFOT( ) )
    {
        LPTSTR lpPath = m_lpszFOT;
        LPTSTR lpLastSlash = StrRChr( lpPath, NULL, TEXT( '\\' ) );

        TCHAR szTempFile[ MAX_PATH_LEN ];

        if( !lpLastSlash )
        {
            if( !bMakeFQName( szTempFile, lpPath, MAX_PATH_LEN, TRUE ) )
            {
                return( FALSE );
            }

            lpPath = szTempFile;

            lpLastSlash = StrRChr( lpPath, NULL, TEXT( '\\' ) );

            if( !lpLastSlash )
            {
                //
                //  This should never happen
                //
                return( FALSE );
            }
        }

        LPTSTR lpFileOnly = lpLastSlash + 1;

        //
        //  Try to find the directory in the list, but do not add it
        //

        int iLen = (int)(lpFileOnly - lpPath - 1);

        CFontDirList *pDirList;
        if (CFontDirList::GetSingleton(&pDirList))
        {
            CFontDir *poDir = pDirList->Find( lpPath, iLen, FALSE );

            if( poDir && poDir->bOnSysDir( ) )
            {
                bGetFOT( szFileName, sizeof( FullPathName_t ) / sizeof( TCHAR ) );
                return( TRUE );
            }
        }
    }
    else if( bOnSysDir( ) )
    {
        vGetDirFN( szFileName );
        return( TRUE );
    }

    return( FALSE );
}

int CFontClass::s_cFonts = 0;
ULONG CFontClass::AddRef(void)
{
    ULONG ulReturn = m_cRef + 1;

    InterlockedIncrement(&m_cRef);

    return ulReturn;
}

ULONG CFontClass::Release(void)
{
    ULONG ulReturn = m_cRef - 1;

    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}



/*****************************************************************************
    Local functions:
*****************************************************************************/

typedef enum
{
    DC_ERROR,
    DC_YES,
    DC_NO,
} DC_RETURN;

DC_RETURN bDirContains( LPCTSTR szInName,
                        LPCTSTR szDir,
                        BOOL bCheckExist,
                        LPTSTR lpszName,
                        DWORD dwNameLen )
{
    size_t wInNameLen = lstrlen( szInName );

    //
    //  If the path doesn't have a disk or directory specifier in it, start
    //  the resulting name with the system directory (this is ready for
    //  appending).  Otherwise, start with nothing - we'll append the entire
    //  input path.
    //

    lstrcpyn( lpszName, szDir, dwNameLen );

    //
    //  Make sure there's room to append the input path name to the output
    //  name.  If not (shouldn't ever happen), clear the output name and fail.
    //

    if( ( lstrlen( lpszName ) + wInNameLen ) >= dwNameLen )
    {
        return( DC_ERROR );
    }

    // DEBUGMSG( (DM_TRACE1,TEXT( "About to strcat % onto the end of %s" ), szInName, lpszName ) );

    lstrcat( lpszName, szInName );

    if( !bCheckExist )
    {
        return( DC_YES );
    }

#ifdef WINNT

    return( MyOpenFile( lpszName, NULL, OF_EXIST )
                        != (HANDLE) INVALID_HANDLE_VALUE ? DC_YES : DC_NO );

#else

    OFSTRUCT os;

    return( OpenFile( lpszName, &os, OF_EXIST )!=HFILE_ERROR ? DC_YES : DC_NO );

#endif  //  WINNT
}


/***************************************************************************
 * FUNCTION: bMakeFQName
 *
 * PURPOSE:  Build a fully qualified filename based on the input name
 *              and the system directory (obtained from win.ini).  If there's
 *              already a device and/or directory, don't append the sys dir.
 *
 * RETURNS:  TRUE if FQ name will fit in return, error FALSE
 ***************************************************************************/
BOOL PASCAL bMakeFQName( LPTSTR lpszName,
                         LPTSTR szInName,
                         DWORD  dwFQNameLen,
                         BOOL   bSearchPath )
{
    size_t wInNameLen = lstrlen( szInName );

    if( _tcscspn( szInName, TEXT( ":\\" ) ) != wInNameLen )
    {
        //
        //  (Presumably) fully qualified; no need to check anything
        //

        if( wInNameLen >= dwFQNameLen )
        {
            return( FALSE );
        }

        lstrcpy( lpszName, szInName );
        return( TRUE );
    }

    FullPathName_t szDir;

    if( bSearchPath )
    {
        //
        //  Set the current dir to the Fonts folder so it will get searched
        //  first
        //

        if( !GetFontsDirectory( szDir, ARRAYSIZE( szDir ) ) )
        {
            return( FALSE );
        }

        SetCurrentDirectory( szDir );

        //
        //  Check to see if the file exists on the path.
        //

#ifdef WINNT

        TCHAR szPathName[ PATHMAX ];

        if( MyOpenFile( szInName, szPathName, OF_EXIST )
                    != (HANDLE) INVALID_HANDLE_VALUE )
        {
            if( (DWORD) lstrlen( szPathName ) >= dwFQNameLen )
            {
                return( FALSE );
            }

            lstrcpy( lpszName, szPathName );
            return( TRUE );
        }
#else

        OFSTRUCT os;

        if( OpenFile( szInName, &os, OF_EXIST ) != HFILE_ERROR )
        {
            if( (DWORD) lstrlen( os.szPathName ) >= dwFQNameLen )
            {
                return( FALSE );
            }

            lstrcpy( lpszName, os.szPathName );
            return( TRUE );
        }
#endif  // WINNT

        //
        //  If not on the path, we will fall through and just fill in the
        //  Fonts dir
    }
    else
    {
        //
        //  First check in the system directory; always check for existence
        //

        if( !GetSystemDirectory( szDir, ARRAYSIZE( szDir ) ) )
        {
            return( FALSE );
        }

        lpCPBackSlashTerm( szDir );

        switch( bDirContains( szInName, szDir, TRUE, lpszName, dwFQNameLen ) )
        {
        case DC_YES:
            return( TRUE );
            break;
        }

        //
        //  Next check in the fonts directory; only check for existence if we
        //  are really looking for the file to exist
        //

        if( !GetFontsDirectory( szDir, ARRAYSIZE( szDir ) ) )
        {
            return( FALSE );
        }
    }

    lpCPBackSlashTerm( szDir );

    switch( bDirContains( szInName, szDir, FALSE, lpszName, dwFQNameLen ) )
    {
    case DC_ERROR:
        return( FALSE );
        break;
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\fdir.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fdir.cpp
//      Explorer Font Folder extension routines
//      Implementation for the class: CFontDir
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-93 ElseWare Corporation.    All rights reserved.
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
// #include <windows.h>
// #include <windowsx.h>
#include "globals.h"
#include "fdir.h"


#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

CFontDir::CFontDir( )
   :  m_iLen( 0 ),
      m_bSysDir( FALSE )
{}


CFontDir::~CFontDir( )
{}


BOOL CFontDir::bInit( LPCTSTR lpPath, int iLen )
{

    if( iLen >= 0 && iLen <= ARRAYSIZE( m_oPath ) )
    {
        m_iLen = iLen;

        _tcsncpy( m_oPath, lpPath, iLen );

        m_oPath[ iLen ] = 0;

        return TRUE;
    }

    //
    // Error. Clean up and return.
    //

    delete this;
    return FALSE;
}


BOOL CFontDir::bSameDir( LPTSTR lpStr, int iLen )
{
    return( ( iLen == m_iLen ) && ( _tcsnicmp( m_oPath, lpStr, iLen ) == 0 ) );
}


LPTSTR CFontDir::lpString( )
{
    return m_oPath;
}


//-----------------------------------------------------------------------------
// CFontDirList
//-----------------------------------------------------------------------------
//
// Class representing a dynamic array of CFontDir object ptrs.
// Implemented as a singleton object through the static member
// function GetSingleton.
//
CFontDirList::CFontDirList(
    void
    ) : m_pVector(NULL)
{

}

CFontDirList::~CFontDirList(
    void
    )
{
    delete m_pVector;
}


//
// Retrieve the address of the singleton object.
//
BOOL 
CFontDirList::GetSingleton(  // [static]
    CFontDirList **ppDirList
    )
{
    static CFontDirList TheList;

    *ppDirList = NULL;
    if (NULL == TheList.m_pVector)
    {
        //
        // Singleton not yet initialized.  Initialize it.
        //
        TheList.m_pVector = new CIVector<CFontDir>(64);
        if (NULL != TheList.m_pVector)
        {
            if (!TheList.m_pVector->bInit())
            {
                delete TheList.m_pVector;
                TheList.m_pVector = NULL;
            }
        }
    }
    if (NULL != TheList.m_pVector)
    {
        //
        // Singleton is initialized.  Return it's address.
        //
        *ppDirList = &TheList;
    }
    return (NULL != *ppDirList);
}        


//
// Clear all entries from the directory list.
//
void
CFontDirList::Clear(
    void
    )
{
    m_pVector->vDeleteAll();
}


//
// Add an entry to the directory list.
//
BOOL
CFontDirList::Add(
    CFontDir *poDir
    )
{
    BOOL bAdded = FALSE;
    if (m_pVector->bAdd(poDir))
    {
        bAdded = TRUE;
    }
    else
    {
        //
        // The original font folder code cleared the list if
        // any one addition failed.
        //
        Clear();
    }
    return bAdded;
}


BOOL
CFontDirList::IsEmpty(
    void
    ) const
{
    return 0 == Count();
}


int
CFontDirList::Count(
    void
    ) const
{
    return m_pVector->iCount();
}


//
// Returns the address of the CFontDir object at 
// a given index.
//
CFontDir*
 CFontDirList::GetAt(
    int index
    ) const
{
    return m_pVector->poObjectAt(index);
}


//
// Locates and returns a given CFontDir object in the list.
//
CFontDir *
CFontDirList::Find(
    LPTSTR lpPath, 
    int iLen, 
    BOOL bAddToList  // optional.  Default == FALSE
    )
{
    //
    // Try to find the directory in the list.
    //
    CFontDir *poDir = NULL;
    const int iCnt  = Count();

    for (int i = 0; i < iCnt; i++, poDir = 0)
    {
        poDir = GetAt( i );

        if (poDir->bSameDir(lpPath, iLen))
            break;
    }

    //
    // If we didn't find one, create one and add it.
    //
    if (!poDir && bAddToList)
    {
        poDir = new CFontDir;
        if (poDir)
        {
            if (!poDir->bInit(lpPath, iLen) || !Add(poDir))
            {
                delete poDir;
                poDir = NULL;
            }
        }
    }
    return( poDir );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\extinit.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// extinit.cpp
//      Explorer Font Folder extension routines
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include "extinit.h"
#include "resource.h"
#include "ui.h"
#include "cpanel.h"
#include "fontcl.h"
// #include "fontinfo.h"
#include "fontview.h"

#include "dbutl.h"


#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))


//------------------------------------------------------------------------

HRESULT MyReleaseStgMedium( LPSTGMEDIUM pmedium )
{
    if( pmedium->pUnkForRelease )
    {
        pmedium->pUnkForRelease->Release( );
    }
    else
    {
        switch( pmedium->tymed )
        {
        case TYMED_HGLOBAL:
            GlobalFree( pmedium->hGlobal );
            break;

        case TYMED_ISTORAGE:
        case TYMED_ISTREAM:
            //
            // hack, the stream and storage overlap eachother in the union
            // so this works for both.
            //

            pmedium->pstm->Release( );
            break;

        default:
            //
            // Assert( 0 );        // unknown type
            // Not fullly implemented.

            MessageBeep( 0 );
                break;
        }
    }

    return NOERROR;
}


//------------------------------------------------------------------------
CShellExtInit::CShellExtInit( )
   :  m_cRef( 0 ),
      m_poData( NULL )
{
    g_cRefThisDll++;
}

CShellExtInit::~CShellExtInit( )
{
    if( m_poData )
    {
        m_poData->Release( );
        m_poData = NULL;
    }

    g_cRefThisDll--;
}

BOOL CShellExtInit::bInit( )
{
    return TRUE;
}

STDMETHODIMP CShellExtInit::QueryInterface( REFIID riid,
                                            LPVOID FAR* ppvObj )
{
    *ppvObj = NULL;

    DEBUGMSG( ( DM_NOEOL | DM_TRACE1,
              TEXT( "FONTEXT: CShellExtInit::QueryInterface called for: " ) ) );

    //
    // Dump out the riid here
    //

    DEBUGREFIID( ( DM_TRACE1, riid ) );

    if( riid == IID_IUnknown )
        *ppvObj = (IUnknown*)( (IShellExtInit *)this );

      // The (IShellExtInit *) ^^^ up there is to disambiguate :) the reference

    else if( riid == IID_IShellExtInit )
        *ppvObj = (IShellExtInit *) this;

    else if( riid == IID_IContextMenu )
        *ppvObj = (IContextMenu*)this;

    else if( riid == IID_IShellPropSheetExt )
        *ppvObj = (IShellPropSheetExt*)this;

    if( *ppvObj )
    {
        ( (LPUNKNOWN)*ppvObj)->AddRef( );
        return NOERROR;
    }

    return( ResultFromScode( E_NOINTERFACE ) );
}


STDMETHODIMP_(ULONG ) CShellExtInit::AddRef( void )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CShellExtInit::AddRef called: %d->%d references" ),
              m_cRef, m_cRef + 1 ) );

    return( ++m_cRef );
}


STDMETHODIMP_(ULONG) CShellExtInit::Release( void )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CShellExtInit::Release called: %d->%d references" ),
              m_cRef, m_cRef - 1 ) );

    ULONG retval;

    retval = --m_cRef;

    if( !retval ) delete this;

    return( retval );
}


STDMETHODIMP CShellExtInit::Initialize( LPCITEMIDLIST pidlFolder,
                                        LPDATAOBJECT lpdobj,
                                        HKEY hkeyProgID )
{
    if( m_poData )
        m_poData->Release( );

    m_poData = lpdobj;
    m_poData->AddRef( );

    return NOERROR;
}


STDMETHODIMP CShellExtInit::QueryContextMenu( HMENU hmenu,
                                              UINT indexMenu,
                                              UINT idCmdFirst,
                                              UINT idCmdLast,
                                              UINT uFlags )
{
    UINT  nCmd = idCmdFirst;
    TCHAR  szCmd[ 64 ];


    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: QueryContextMenu called with following:" ) ) );
    DEBUGMSG( (DM_TRACE2, TEXT( "         indexMenu:  %d" ), indexMenu ) );
    DEBUGMSG( (DM_TRACE2, TEXT( "         idCmdFirst: %d" ), idCmdFirst ) );
    DEBUGMSG( (DM_TRACE2, TEXT( "         uFlags:     %d" ), uFlags ) );

    LoadString( g_hInst, IDS_EXT_INSTALL, szCmd, ARRAYSIZE( szCmd ) );

    InsertMenu( hmenu, indexMenu++, MF_STRING|MF_BYPOSITION, nCmd++, szCmd );

    return (HRESULT)( 1 );
}

STDMETHODIMP CShellExtInit::InvokeCommand( LPCMINVOKECOMMANDINFO lpici )
{
   HRESULT hr   = ResultFromScode( E_INVALIDARG );
   UINT    nCmd = LOWORD( lpici->lpVerb );

   //
   // We only have one command: Install
   //

   if( !nCmd && m_poData )
   {
        //
        // The fact that we got here is success. The install may or may not work.
        //
        hr = NOERROR;

        InstallDataObject( m_poData, DROPEFFECT_COPY, lpici->hwnd );
   }

   return hr;
}

STDMETHODIMP CShellExtInit::GetCommandString( UINT_PTR idCmd,
                                              UINT    uFlags,
                                              UINT   *pwReserved,
                                              LPSTR   pszName,
                                              UINT    cchMax )
{
    HRESULT  hr = ResultFromScode( E_INVALIDARG );
    UINT  nID;

    if( !idCmd )
    {
        if( uFlags & GCS_HELPTEXT )
            nID = IDS_EXT_INSTALL_HELP;
        else
            nID = IDS_EXT_INSTALL;

        if( uFlags & GCS_UNICODE )
            if( LoadStringW( g_hInst, nID, (LPWSTR) pszName, cchMax ) )
                hr = NOERROR;
        else
            if( LoadStringA( g_hInst, nID, (LPSTR) pszName, cchMax ) )
                hr = NOERROR;
    }

    return hr;
}


//---------------------------------------------------------------------------
//
// FSPage_InitDialog
//
//  This function is called when the dialog procedure receives the
// WM_INITDIALOG message. In this sample code, we simply fill the
// listbox with the list of fully qualified paths to the file and
// directories.
//
//---------------------------------------------------------------------------

void FSPage_InitDialog( HWND hDlg, LPPROPSHEETPAGE psp )
{
    LPDATAOBJECT   poData = (LPDATAOBJECT)psp->lParam;

    FORMATETC fmte = {
                 CF_HDROP,
                 (DVTARGETDEVICE FAR *)NULL,
                 DVASPECT_CONTENT,
                 -1,
                 TYMED_HGLOBAL };

    STGMEDIUM medium;

    HRESULT hres = poData->GetData( &fmte, &medium );


    if( SUCCEEDED( hres ) )
    {
        HDROP        hDrop = (HDROP) medium.hGlobal;
        FONTDESCINFO fdi;
        TCHAR        szAll[ 512 ];

        fdi.dwFlags = FDI_ALL | FDI_VTC;

        ::DragQueryFile( hDrop, 0, fdi.szFile, ARRAYSIZE( fdi.szFile ) );

        if( bIsTrueType( &fdi ) || bIsNewExe( &fdi ) )
        {
            SetDlgItemText( hDlg, stc1, fdi.szDesc );

            //
            // Get the copyright info and put it in the edit control, edt1.
            //

            wsprintf( szAll, TEXT( "%s\r\n\r\n%s\r\n\r\n%s" ), fdi.lpszVersion,
                      fdi.lpszTrademark, fdi.lpszCopyright );

            SetDlgItemText( hDlg, edt1, szAll );

            //
            // Clean up the fdi.
            //

            if( fdi.lpszVersion )
                delete fdi.lpszVersion;

            if( fdi.lpszCopyright )
                delete fdi.lpszCopyright;

            if( fdi.lpszTrademark )
                delete fdi.lpszTrademark;
        }

        MyReleaseStgMedium( &medium );
    }
}


//---------------------------------------------------------------------------
//
// FSPage_DlgProc
//
//  The dialog procedure for the TEXT( "FSPage" ) property sheet page.
//
//---------------------------------------------------------------------------

INT_PTR CALLBACK FSPage_DlgProc( HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam )
{
    LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)GetWindowLongPtr( hDlg, DWLP_USER );

    switch( uMessage )
    {
    //
    //  When the shell creates a dialog box for a property sheet page,
    // it passes the pointer to the PROPSHEETPAGE data structure as
    // lParam. The dialog procedures of extensions typically store it
    // in the DWL_USER of the dialog box window.
    //
    case WM_INITDIALOG:
        SetWindowLongPtr( hDlg, DWLP_USER, lParam );

        psp = (LPPROPSHEETPAGE)lParam;

        FSPage_InitDialog( hDlg, psp );

        break;

    case WM_DESTROY:
        break;

    case WM_COMMAND:
        break;

    case WM_NOTIFY:
        switch( ( (NMHDR FAR *)lParam)->code )
        {
        case PSN_SETACTIVE:
           break;

        case PSN_APPLY:
           break;

        default:
           break;
        }
        break;

    default:
        return( FALSE );
    }

    return( TRUE );
}

//
//
//
#if 0
void CALLBACK FSPage_ReleasePage( LPPROPSHEETPAGE psp )
{
    GlobalFree( (HDROP)psp->lParam );
}
#endif


STDMETHODIMP CShellExtInit::AddPages( LPFNADDPROPSHEETPAGE lpfnAddPage,
                                      LPARAM lParam )
{
    HRESULT  hr = NOERROR;      // ResultFromScode( E_INVALIDARG );

    if( m_poData )
    {
        //
        // Get an HDROP, if possible.
        //
        FORMATETC fmte = {
                       CF_HDROP,
                       (DVTARGETDEVICE FAR *)NULL,
                       DVASPECT_CONTENT,
                       -1,
                       TYMED_HGLOBAL };

        STGMEDIUM medium;

        hr = m_poData->GetData( &fmte, &medium );

        if( SUCCEEDED( hr ) )
        {
            //
            // Only add a page if there is exactly one font selected.
            //

            HDROP hDrop = (HDROP) medium.hGlobal;
            UINT cnt = ::DragQueryFile( hDrop, (UINT)-1, NULL, 0 );

            if( cnt == 1 )
            {
                PROPSHEETPAGE  psp;
                HPROPSHEETPAGE hpage;

                psp.dwSize      = sizeof( psp );        // no extra data.
                psp.dwFlags     = PSP_USEREFPARENT;
                psp.hInstance   = g_hInst;
                psp.pszTemplate = MAKEINTRESOURCE( ID_DLG_PROPPAGE );
                psp.pfnDlgProc  = FSPage_DlgProc;
                psp.pcRefParent = (UINT *)&g_cRefThisDll;
              // psp.pfnRelease  = FSPage_ReleasePage;
                psp.lParam      = (LPARAM)m_poData;

                hpage = CreatePropertySheetPage( &psp );

                if( hpage )
                {
                    if( !lpfnAddPage( hpage, lParam ) )
                        DestroyPropertySheetPage( hpage );
                }
            }

            MyReleaseStgMedium( &medium );
        }
    }

    return hr;
}


STDMETHODIMP CShellExtInit::ReplacePage( UINT uPageID,
                                         LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                         LPARAM lParam )
{
    return NOERROR;
}

const TCHAR c_szFileNameMap[] = CFSTR_FILENAMEMAP;       // "FileNameMap"

VOID InstallDataObject( LPDATAOBJECT pdobj,
                        DWORD dwEffect,
                        HWND hWnd,
                        CFontView * poView)
{
    //
    // Get an HDROP, if possible.
    //

    FORMATETC fmte = {
                    CF_HDROP,
                    (DVTARGETDEVICE FAR *)NULL,
                    DVASPECT_CONTENT,
                    -1,
                    TYMED_HGLOBAL };

    STGMEDIUM medium;

    HRESULT hres = pdobj->GetData( &fmte, &medium );

    if( SUCCEEDED( hres ) )
    {
        WaitCursor     cWaiter;           // Starts and stops busy cursor
        STGMEDIUM      mediumNameMap;
        HDROP          hDrop = (HDROP) medium.hGlobal;
        BOOL           bAdded = FALSE;
        FullPathName_t szFile;

        UINT   cfFileNameMap = RegisterClipboardFormat( c_szFileNameMap );
        LPTSTR lpszNameMap   = NULL;

        fmte.cfFormat = (CLIPFORMAT) cfFileNameMap;

        if( pdobj->GetData( &fmte, &mediumNameMap ) == S_OK )
        {
            lpszNameMap = (LPTSTR) GlobalLock( mediumNameMap.hGlobal );
        }

        UINT cnt = ::DragQueryFile( hDrop, (UINT) -1, NULL, 0 );

        for( UINT i = 0; i < cnt; )
        {
            ::DragQueryFile( hDrop, i, szFile, ARRAYSIZE( szFile ) );

            if( poView )
                poView->StatusPush( szFile );

            switch( CPDropInstall( poView->GetViewWindow(),
                                   szFile,
                                   dwEffect,
                                   lpszNameMap,
                                   (int) (cnt - ++i) ) )
            {
            case CPDI_SUCCESS:
                bAdded = TRUE;
                break;

            case CPDI_FAIL:
                break;

            case CPDI_CANCEL:
                i = cnt;
                break;
            }

            if( lpszNameMap && *lpszNameMap )
            {
                lpszNameMap += lstrlen( lpszNameMap ) + 1;
            }
        }

        poView->StatusClear( );

        if( lpszNameMap )
        {
            GlobalUnlock( mediumNameMap.hGlobal );
            MyReleaseStgMedium( &mediumNameMap );
        }


        if( bAdded )
        {
          vCPWinIniFontChange( );

        }

        MyReleaseStgMedium( &medium );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\extricon.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: extricon.cpp

    Description: Contains implementation of IExtractIcon for the font folder.
        This code provides icon identification for both TrueType and OpenType
        font files.  The logic used is as follows:
        
            TrueType(1)  DSIG?   CFF?    Icon
            ------------ ------- ------- -----------
            yes          no      no      TT
            yes          no      yes     OTp
            yes          yes     no      OTt
            yes          yes     yes     OTp

        (1) Files must contain required TrueType tables to be considered
            a TrueType font file.

        This icon handler is used by both the shell and the font folder
        to display TrueType and OpenType font icons.  It is designed to be
        easily extensible if support for dynamic icon identification is
        required in other fonts.

        Classes (indentation denotes inheritance):

            CFontIconHandler
            IconHandler
                TrueTypeIconHandler
               

        NOTE:  The design is sort of in a state of limbo right now.  Originally
               the idea was to support two types of OpenType icons along with
               the conventional TrueType and raster font icons.  The OpenType
               icons were OTt and OTp with the 't' and 'p' meaning "TrueType"
               and "PostScript".  Later we decided to only show the icons as
               "OT" without the subscript 't' or 'p'.  The code still distinguishes
               the difference but we just use the same "OT" icon for both the
               OTt and OTp conditions.  Make sense?  Anyway, This OTt and OTp
               stuff may come back at a later date (GDI guys haven't decided)
               so I'm leaving that code in place. [brianau - 4/7/98]

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/13/97    Initial creation.                                    BrianAu
    04/08/98    Removed OpenTypeIconHandler and folded it into       BrianAu
                TrueTypeIconHandler.  There's no need for the 
                separation.  Also added detection of "required"
                TrueType tables.
    03/04/99    Added explicit support for IExtractIconW and         BrianAu
                IExtractIconA.  Was previously only supporting
                IExtractIconW implicitely through UNICODE build.
*/
///////////////////////////////////////////////////////////////////////////////
#include "priv.h"

#include "dbutl.h"
#include "globals.h"
#include "fontext.h"
#include "resource.h"
#include "extricon.h"


#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

//
// TrueType/OpenType table tag values.
// Note that MAKETAG macro is defined in winuserp.h
//
static const DWORD TAG_DSIGTABLE = MAKETAG('D','S','I','G');
static const DWORD TAG_CFFTABLE  = MAKETAG('C','F','F',' ');
//
// Required TrueType tables.  This is per the TrueType
// specification at http://www.microsoft.com/typography/tt/ttf_spec
//
static const DWORD TAG_NAMETABLE = MAKETAG('n','a','m','e');
static const DWORD TAG_CMAPTABLE = MAKETAG('c','m','a','p');
static const DWORD TAG_HEADTABLE = MAKETAG('h','e','a','d');
static const DWORD TAG_HHEATABLE = MAKETAG('h','h','e','a');
static const DWORD TAG_HMTXTABLE = MAKETAG('h','m','t','x');
static const DWORD TAG_OS2TABLE  = MAKETAG('O','S','/','2');
static const DWORD TAG_POSTTABLE = MAKETAG('p','o','s','t');
static const DWORD TAG_GLYFTABLE = MAKETAG('g','l','y','f');
static const DWORD TAG_LOCATABLE = MAKETAG('l','o','c','a');
static const DWORD TAG_MAXPTABLE = MAKETAG('m','a','x','p');
//
// "ttcf" isn't really a table.  It's a tag found at the front of 
// a TTC (TrueType Collection) font file.  Treating it like a table
// tag fits well with this scheme.
//
static const DWORD TAG_TTCFILE   = MAKETAG('t','t','c','f');

//
// Helper to swap bytes in a word.
//
inline WORD
SWAP2B(WORD x) 
{
    return ((x << 8) | HIBYTE(x));
}

//
// Template of a TrueType file header.
//
struct TrueTypeFileHdr {
  DWORD dwVersion;
  WORD  uNumTables;
  WORD  uSearchRange;
  WORD  uEntrySelector;
  WORD  uRangeShift;
};

//
// Template of a TrueType table header.
//
struct TrueTypeTableHdr {
  DWORD dwTag;
  DWORD dwCheckSum;
  DWORD dwOffset;
  DWORD dwLength;
};


//-----------------------------------------------------------------------------
// CFontIconHandler
//-----------------------------------------------------------------------------
//
// Path to FONTEXT.DLL.  Only one instance required.
//
TCHAR CFontIconHandler::m_szFontExtDll[];

//
// Initialize the font icon handler object.  This is the object created
// to implement IExtractIcon.  Internally, it creates a type-specific
// handler to handle font file type-specific issues.
//
CFontIconHandler::CFontIconHandler(
    VOID
    ) : m_cRef(0),
        m_pHandler(NULL)
{
    m_szFileName[0] = TEXT('\0');
    //
    // Save the path to FONTEXT.DLL to return in GetIconLocation.
    // This is a static string that should only be initialized once.
    //
    if (TEXT('\0') == m_szFontExtDll[0])
    {
        HINSTANCE hModule = GetModuleHandle(TEXT("FONTEXT.DLL"));
        if (NULL != hModule)
        {
            GetModuleFileName(hModule, m_szFontExtDll, ARRAYSIZE(m_szFontExtDll));
        }
    }

    //
    // Keep DLL in memory as long as this object needs it.
    // Must be done at the end of the ctor in case something in the ctor throws
    // an exception.  The dtor is not called on a partially constructed
    // object.
    //
    InterlockedIncrement(&g_cRefThisDll);
}

CFontIconHandler::~CFontIconHandler(
    VOID
    )
{
    delete m_pHandler;
    //
    // DLL no longer required for this object.
    //
    InterlockedDecrement(&g_cRefThisDll);
}


STDMETHODIMP 
CFontIconHandler::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    HRESULT hResult = NO_ERROR;

    if (NULL != ppvOut)
    {
        *ppvOut = NULL;

        //
        // Explicit casts required because we use multiple inheritance.
        //
        if (IID_IUnknown == riid || IID_IExtractIconW == riid)
        {
            *ppvOut = static_cast<IExtractIconW *>(this);
        }
        else if (IID_IExtractIconA == riid)
        {
            *ppvOut = static_cast<IExtractIconA *>(this);
        }
        else if (IID_IPersistFile == riid)
        {
            *ppvOut = static_cast<IPersistFile *>(this);
        }

        if (NULL == *ppvOut)
            hResult = E_NOINTERFACE;
        else
            ((LPUNKNOWN)*ppvOut)->AddRef();
    }
    else
        hResult = E_POINTER;

    return hResult;
}


STDMETHODIMP_(ULONG) 
CFontIconHandler::AddRef(
    VOID
    )
{
    ULONG ulReturn = m_cRef + 1;

    InterlockedIncrement(&m_cRef);

    return ulReturn;
}


STDMETHODIMP_(ULONG) 
CFontIconHandler::Release(
    VOID
    )
{
    ULONG ulReturn = m_cRef - 1;

    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}


//
// Implementation of IPersist::GetClassID
//
STDMETHODIMP 
CFontIconHandler::GetClassID(
    CLSID *pClassID
    )
{
    *pClassID = CLSID_FontExt;
    return S_OK;
}


//
// Implementation of IPersistFile::IsDirty
//
STDMETHODIMP 
CFontIconHandler::IsDirty(
    VOID
    )
{
    return E_NOTIMPL;
}

//
//
// Implementation of IPersistFile::Load
//
// This is called by the shell before IExtractIcon::GetIconLocation.
// It gives the extension a chance to save the file name.
//
STDMETHODIMP 
CFontIconHandler::Load(
    LPCOLESTR pszFileName,
    DWORD dwMode            // unused.
    )
{
    HRESULT hr = NOERROR;
    //
    // Save the name of the font file so that the IExtractIcon
    // functions know what file to work with.
    //
#ifdef UNICODE
    lstrcpyn(m_szFileName, pszFileName, ARRAYSIZE(m_szFileName));
#else
    WideCharToMultiByte(CP_ACP, 
                        0, 
                        pszFileName, 
                        -1, 
                        m_szFileName, 
                        ARRAYSIZE(m_szFileName), 
                        NULL, NULL);
#endif
    //
    // Delete any existing type-specific handler.
    //
    delete m_pHandler;
    m_pHandler = NULL;
 
    //
    // Create a new type-specific handler.
    //
    if (NULL == (m_pHandler = IconHandler::Create(m_szFileName)))
        hr = E_FAIL;

    return hr;
}


//
// Implementation of IPersistFile::Save
//
STDMETHODIMP 
CFontIconHandler::Save(
    LPCOLESTR pszFileName,
    BOOL fRemember
    )
{
    return E_NOTIMPL;
}


//
// Implementation of IPersistFile::SaveCompleted
//
STDMETHODIMP 
CFontIconHandler::SaveCompleted(
    LPCOLESTR pszFileName
    )
{
    return E_NOTIMPL;
}


//
// Implementation of IPersistFile::GetCurFile
//
STDMETHODIMP 
CFontIconHandler::GetCurFile(
    LPOLESTR *ppszFileName
    )
{
    return E_NOTIMPL;
}


//
// Implementation of IExtractIconW::Extract
//
STDMETHODIMP 
CFontIconHandler::Extract(
    LPCWSTR pszFileNameW,   // unused
    UINT niconIndex,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize          // unused
    )
{
    HICON hiconLarge;
    HICON hiconSmall;

    HRESULT hr = GetIcons(niconIndex, &hiconLarge, &hiconSmall);
    if (SUCCEEDED(hr))
    {
        if (NULL != phiconLarge)
            *phiconLarge = CopyIcon(hiconLarge);
        if (NULL != phiconSmall)
            *phiconSmall = CopyIcon(hiconSmall);
    }

    return SUCCEEDED(hr) ? NO_ERROR     // Use these icons.
                         : S_FALSE;     // Caller must load icons.
}



//
// Implementation of IExtractIconW::GetIconLocation
//
STDMETHODIMP 
CFontIconHandler::GetIconLocation(
    UINT uFlags,        // unused
    LPWSTR pszIconFileW,
    UINT cchMax,
    int *piIndex,
    UINT *pwFlags
    )
{
    HRESULT hr      = S_FALSE;
    INT iIconIndex  = GetIconIndex();

    if (-1 != iIconIndex)
    {
        //
        // This is a special case for internal font folder use.
        // Normally, the shell always gives us a pointer to a destination
        // for the path to FONTEXT.DLL.  Since we also use this icon
        // handler in the font folder itself, that code only needs to know
        // the icon index (it already knows the icon is in fontext.dll).
        // This test allows the font folder code to pass NULL and skip
        // the unnecessary string copy.
        // 
        if (NULL != pszIconFileW)
        {
#ifdef UNICODE
            lstrcpynW(pszIconFileW, m_szFontExtDll, cchMax);
#else
            MultiByteToWideChar(CP_ACP,
                                0,
                                m_szFontExtDll,
                                -1,
                                pszIconFileW,
                                cchMax);
#endif
        }
        *pwFlags = GIL_PERINSTANCE;
        *piIndex = iIconIndex;
        hr       = S_OK;
    }

    return hr;
}


//
// Implementation of IExtractIconA::Extract
//
STDMETHODIMP 
CFontIconHandler::Extract(
    LPCSTR pszFileNameA,
    UINT niconIndex,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize          // unused
    )
{
    WCHAR szFileNameW[MAX_PATH * 2] = {0};
    MultiByteToWideChar(CP_ACP,
                        0,
                        pszFileNameA,
                        -1,
                        szFileNameW,
                        ARRAYSIZE(szFileNameW));
                            
    return Extract(szFileNameW, niconIndex, phiconLarge, phiconSmall, nIconSize);
}



//
// Implementation of IExtractIconA::GetIconLocation
//
STDMETHODIMP 
CFontIconHandler::GetIconLocation(
    UINT uFlags,        // unused
    LPSTR pszIconFileA,
    UINT cchMax,
    int *piIndex,
    UINT *pwFlags
    )
{
    //
    // Call the wide-char version then convert the result to ansi.
    //
    WCHAR szIconFileW[MAX_PATH * 2] = {0};
    HRESULT hr = GetIconLocation(uFlags, 
                                 szIconFileW, 
                                 ARRAYSIZE(szIconFileW), 
                                 piIndex, 
                                 pwFlags);
    if (SUCCEEDED(hr))
    {
        WideCharToMultiByte(CP_ACP, 
                            0,
                            szIconFileW,
                            -1,
                            pszIconFileA,
                            cchMax,
                            NULL,
                            NULL);
    }
    return hr;
}


//
// Retrieve the icon index for the font file loaded in Load().
//
INT
CFontIconHandler::GetIconIndex(
    VOID
    )
{
    INT iIconIndex = -1;
    if (NULL != m_pHandler)
    {
        //
        // Call the type-specific icon handler to get the index.
        //
        iIconIndex = m_pHandler->GetIconIndex(m_szFileName);
    }
    return iIconIndex;
}


//
// Retrieve the icon handles for a given icon index.
//
HRESULT
CFontIconHandler::GetIcons(
    UINT iIconIndex,
    HICON *phiconLarge,
    HICON *phiconSmall
    )
{
    HRESULT hr = E_FAIL;
    if (NULL != m_pHandler)
    {
        //
        // Call the type-specific icon handler to get the icons.
        //
        hr = m_pHandler->GetIcons(iIconIndex, phiconLarge, phiconSmall);
    }
    return hr;
}


//
// Create a new type-specific icon handler based on the file name extension.
//
IconHandler*
IconHandler::Create(
    LPCTSTR pszFile
    )
{
    IconHandler *pIconHandler = NULL;
    LPCTSTR pszFileExt = pszFile + lstrlen(pszFile) - 3;
    if (pszFileExt > pszFile)
    {
        //
        // Do some quick checks of the first character in the extension before
        // making a call out to lstrcmpi.  Should help perf just a bit.
        //
        bool bCreateHandler = false;
        switch(*pszFileExt)
        {
            case TEXT('t'):
            case TEXT('T'):
                bCreateHandler = (0 == lstrcmpi(pszFileExt, TEXT("TTF")) ||
                                  0 == lstrcmpi(pszFileExt, TEXT("TTC")));
                break;

            case TEXT('O'):
            case TEXT('o'):
                bCreateHandler = (0 == lstrcmpi(pszFileExt, TEXT("OTF")));
                break;

            default:
                break;
        }
        if (bCreateHandler)
        {
            //
            // Filename has either TTF, TTC or OTF extension.
            //
            DWORD dwTables = 0;
            if (TrueTypeIconHandler::GetFileTables(pszFile, &dwTables))
            {
                //
                // Only require the "open type" tables which are a proper subset
                // of the required "true type" tables.
                //
                DWORD dwReqdTables = TrueTypeIconHandler::RequiredOpenTypeTables();
                if (dwReqdTables == (dwTables & dwReqdTables))
                {
                    //
                    // File is a valid TrueType file.
                    //
                    pIconHandler = new TrueTypeIconHandler(dwTables);
                }
            }
        }
    }
    //
    // If new font types are added later, here's where you'll create
    // the handler.
    //

    return pIconHandler;
}

//-----------------------------------------------------------------------------
// TrueTypeIconHandler
//-----------------------------------------------------------------------------
//
// Initialize the OpenType icon handler.
//
TrueTypeIconHandler::TrueTypeIconHandler(
    DWORD dwTables
    ) : m_dwTables(dwTables)
{
    ZeroMemory(m_rghIcons, sizeof(m_rghIcons));
}


TrueTypeIconHandler::~TrueTypeIconHandler(
    void
    )
{
    for (int i = 0; i < ARRAYSIZE(m_rghIcons); i++)
    {
        if (NULL != m_rghIcons[i])
            DestroyIcon(m_rghIcons[i]);
    }
}


//
// Get the icon index for icons to represent a particular TrueType font
// file.  This is where all of the icon identification logic is.
//
INT 
TrueTypeIconHandler::GetIconIndex(
    LPCTSTR pszFile
    )
{
    INT iIconIndex = IDI_TTF;
    if (TABLE_CFF & m_dwTables)
    {
        iIconIndex = IDI_OTFp;
    }
    else if (TABLE_DSIG & m_dwTables)
    {
        iIconIndex = IDI_OTFt;
    }
    else if (TABLE_TTCF & m_dwTables)
    {
        iIconIndex = IDI_TTC;
    }
    return iIconIndex;
}


//
// Retrieve the large and small icons based on the icon index (ID).
//
HRESULT
TrueTypeIconHandler::GetIcons(
    UINT iIconIndex, 
    HICON *phiconLarge, 
    HICON *phiconSmall
    )
{
    HRESULT hr = NO_ERROR;
    int iSmall = -1;
    int iLarge = -1;

    switch(iIconIndex)
    {
        case IDI_TTF:
            iLarge = iICON_LARGE_TT;
            iSmall = iICON_SMALL_TT;
            break;

        case IDI_OTFt:
            iLarge = iICON_LARGE_OTt;
            iSmall = iICON_SMALL_OTt;
            break;

        case IDI_OTFp:
            iLarge = iICON_LARGE_OTp;
            iSmall = iICON_SMALL_OTp;
            break;

        case IDI_TTC:
            iLarge = iICON_LARGE_TTC;
            iSmall = iICON_SMALL_TTC;
            break;

        default:
            hr = E_FAIL;
            break;
    }

    if (-1 != iLarge)
    {
        *phiconLarge = GetIcon(iLarge);
        *phiconSmall = GetIcon(iSmall);
    }

    return hr;
}


//
// Retrieve the icon's handle.  If the icon isn't yet loaded we 
// load it here.  Once it's loaded it stays loaded until the handler
// object is destroyed.  This way we only load icons on demand.
//
HICON
TrueTypeIconHandler::GetIcon(
    int iIcon
    )
{
    HICON hicon = NULL;

    if (0 <= iIcon && ARRAYSIZE(m_rghIcons) > iIcon)
    {
        if (NULL == m_rghIcons[iIcon])
        {
            //
            // Icon hasn't been loaded yet.  Load it.
            //
            // These must be kept in the same order as the iICON_XXXXX enumeration.
            //
            static const struct
            {
                UINT idIcon;
                int  cxcyIcon;

            } rgIconInfo[] = { { IDI_TTF,     32 }, // iICON_LARGE_TT
                               { IDI_TTF,     16 }, // iICON_SMALL_TT
                               { IDI_OTFt,    32 }, // iICON_LARGE_OTt
                               { IDI_OTFt,    16 }, // iICON_SMALL_OTt
                               { IDI_OTFp,    32 }, // iICON_LARGE_OTp
                               { IDI_OTFp,    16 }, // iICON_SMALL_OTp
                               { IDI_TTC,     32 }, // iICON_LARGE_TTC
                               { IDI_TTC,     16 }  // iICON_SMALL_TTC
                             };

            m_rghIcons[iIcon] = (HICON)LoadImage(g_hInst, 
                                     MAKEINTRESOURCE(rgIconInfo[iIcon].idIcon),
                                     IMAGE_ICON,
                                     rgIconInfo[iIcon].cxcyIcon,
                                     rgIconInfo[iIcon].cxcyIcon,
                                     0);
        }
        hicon = m_rghIcons[iIcon];
    }
    return hicon;
}



//
// Provide wrapper around ReadFileTables to handle any exceptions
// in the case of trying to read an invalid font file.
//
BOOL
TrueTypeIconHandler::GetFileTables(
    LPCTSTR pszFile,
    LPDWORD pfTables
    )
{
    BOOL bResult = FALSE;
    //
    // Assumes pszFile points to a TTF or OTF file name (fully qualified).
    //
    IconHandler::MappedFile file;
    if (SUCCEEDED(file.Open(pszFile)))
    {
        __try
        {
            bResult = ReadFileTables(file, pfTables);
        }
        __except(FilterReadFileTablesException(GetExceptionCode()))
        {
            //
            // Something in reading the font file caused an exception.
            // Probably opened a file that isn't really a font file and it
            // had a bogus table count number.  This can cause us to read 
            // beyond the file mapping.  If this happens, we just set the
            // flags value to 0 indicating that we didn't find any tables 
            // in the file.
            //
            *pfTables = 0;
            DEBUGMSG((DM_ERROR, 
                      TEXT("FONTEXT: Exception occurred reading file %s"), 
                      pszFile));
        }
    }
    return bResult;
}


//
// Determine the index (ID) of the icon for a given TrueType icon file.
// This can also be used by the OpenType handler since TrueType and OpenType
// font files have the same table format.
//
// NOTE: This code does not handle LZ-compressed files like other similar
//       code in the font folder.  The reason is that this code needs to 
//       interrogate only TTF and OTF files which are not compressed.  The
//       font folder must also deal with .TT_ (compressed) files that sometimes
//       come on distribution media.  This icon handler is not required to 
//       display special icons for .TT_ files.  The performance penalty 
//       incurred by using LZxxxxx functions instead of directly mapping
//       files into memory would be significant. [brianau - 6/13/97]
//
// ************************** IMPORTANT **************************
// This function can AV if it tries to read an invalid font file.
// Therefore it is necessary to enclose any call to this function
// in a __try/__except block.
//
BOOL
TrueTypeIconHandler::ReadFileTables(
    IconHandler::MappedFile& file,
    LPDWORD pfTables
    )
{
    *pfTables = 0;

    LPBYTE pbBase = file.Base();

    TrueTypeFileHdr  *pFileHdr  = (TrueTypeFileHdr *)pbBase;
    if (TAG_TTCFILE == pFileHdr->dwVersion)
    {
        //
        // This icon handler is only interested in what icon is required.
        // Since TTC files have only one icon we don't care about any of the
        // table information.  What we have is all we need.  So basically,
        // if the file has a TTC extension and 'ttcf' is the first 4 bytes
        // in the file, we'll display a TTC icon.
        //
        *pfTables |= (TABLE_TTCF | TrueTypeIconHandler::RequiredTrueTypeTables());
    }
    else
    {
        TrueTypeTableHdr *pTableHdr = (TrueTypeTableHdr *)(pbBase + sizeof(*pFileHdr));
        INT cTables                 = SWAP2B(pFileHdr->uNumTables);

        //
        // Do a sanity check on the table count.
        // This is the same check used in bValidateTrueType (pfiles.cpp).
        //
        if ((0x7FFFF / sizeof(TrueTypeTableHdr)) > cTables)
        {
            //
            // Scan the table headers looking for identifying table tags.
            //
            for (INT i = 0; i < cTables; i++, pTableHdr++)
            {
/*
                //
                // Uncomment this to see the tags for each table.
                //
                DEBUGMSG((DM_ERROR, TEXT("Table[%d] tag = 0x%08X \"%c%c%c%c\""), 
                       i, pTableHdr->dwTag,
                       pTableHdr->dwTag  & 0x000000FF,
                       (pTableHdr->dwTag & 0x0000FF00) >> 8,
                       (pTableHdr->dwTag & 0x00FF0000) >> 16,
                       (pTableHdr->dwTag & 0xFF000000) >> 24));
*/
                switch(pTableHdr->dwTag)
                {
                    case TAG_DSIGTABLE: *pfTables |= TABLE_DSIG; break;
                    case TAG_CFFTABLE:  *pfTables |= TABLE_CFF;  break;
                    case TAG_NAMETABLE: *pfTables |= TABLE_NAME; break;
                    case TAG_CMAPTABLE: *pfTables |= TABLE_CMAP; break;
                    case TAG_HEADTABLE: *pfTables |= TABLE_HEAD; break;
                    case TAG_HHEATABLE: *pfTables |= TABLE_HHEA; break;
                    case TAG_HMTXTABLE: *pfTables |= TABLE_HMTX; break;
                    case TAG_OS2TABLE:  *pfTables |= TABLE_OS2;  break;
                    case TAG_POSTTABLE: *pfTables |= TABLE_POST; break;
                    case TAG_GLYFTABLE: *pfTables |= TABLE_GLYF; break;
                    case TAG_LOCATABLE: *pfTables |= TABLE_LOCA; break;
                    case TAG_MAXPTABLE: *pfTables |= TABLE_MAXP; break;
                    default:
                        break;
                }
            }
        }
    }
    return (0 != *pfTables);
}


//
// ReadFileTable's response to an exception depends upon the exception
// For debugger-initiated exceptions, continue the search for a handler so
// that the debugger can handle the exception.
// For all others, execute the handler code.
//
INT
TrueTypeIconHandler::FilterReadFileTablesException(
    INT nException
    )
{
    DEBUGMSG((DM_ERROR, TEXT("FONTEXT: Exception Filter: nException = 0x%08X"), nException));
    if (STATUS_SINGLE_STEP == nException ||
        STATUS_BREAKPOINT == nException)
    {
        //
        // Exception generated by debugger.  
        //
        return EXCEPTION_CONTINUE_SEARCH;
    }
    else
    {
        //
        // Exception generated by processing the mapped file.
        //
        return EXCEPTION_EXECUTE_HANDLER;
    }
}


//-----------------------------------------------------------------------------
// IconHandler::MappedFile
//
// A simple encapsulation of opening a mapped file in memory.
// The file is opened with READ access only.
// Client calls Base() to retrieve the base pointer of the mapped file.
//-----------------------------------------------------------------------------
IconHandler::MappedFile::~MappedFile(
    VOID
    )
{
    Close();
}


//
// Close the file mapping and the file.
//
VOID
IconHandler::MappedFile::Close(
    VOID
    )
{
    if (NULL != m_pbBase)
    {
        UnmapViewOfFile(m_pbBase);
        m_pbBase = NULL;
    }
    if (INVALID_HANDLE_VALUE != m_hFileMapping)
    {
        CloseHandle(m_hFileMapping);
        m_hFileMapping = INVALID_HANDLE_VALUE;
    }
    if (INVALID_HANDLE_VALUE != m_hFile)
    {
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }
}


//
// Open the file.  Caller retrieves the base pointer through the
// Base() member function.
//
HRESULT
IconHandler::MappedFile::Open(
    LPCTSTR pszFile
    )
{
    HRESULT hr = NO_ERROR;

    m_hFile = CreateFile(pszFile, 
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL);

    if (INVALID_HANDLE_VALUE != m_hFile)
    {
        if ((m_hFileMapping = CreateFileMapping(m_hFile,
                                                NULL,
                                                PAGE_READONLY,
                                                0,
                                                0,
                                                NULL)) != NULL)
        {
            m_pbBase = (LPBYTE)MapViewOfFile(m_hFileMapping,
                                             FILE_MAP_READ,
                                             0,
                                             0,
                                             0);
            if (NULL == m_pbBase)
            {
                hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NULL, GetLastError());
                DEBUGMSG((DM_ERROR, 
                          TEXT("FONTEXT: Error 0x%08X mapping view of OTF file %s"), 
                          hr, pszFile));
            }
        }
        else
        {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NULL, GetLastError());
            DEBUGMSG((DM_ERROR, 
                      TEXT("FONTEXT: Error 0x%08X creating mapping for OTF file %s"), 
                      hr, pszFile));
        }
    }
    else
    {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NULL, GetLastError());
        DEBUGMSG((DM_ERROR, 
                  TEXT("FONTEXT: Error 0x%08X opening OTF file %s"), 
                  hr, pszFile));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\fontfile.cpp ===
#include <windows.h>
#include <lzexpand.h>
#include "fontfile.h"

#ifndef ARRAYSIZE
#   define ARRAYSIZE(a)   (sizeof(a) / sizeof((a)[0]))
#endif

//
// Pure virtual base class for all font file I/O implementations.
//
class CFontFileIo
{
    public:
        CFontFileIo(LPCTSTR pszPath)
            : m_pszPath(StrDup(pszPath)) { }

        virtual ~CFontFileIo(void) { delete[] m_pszPath; }

        virtual DWORD Open(DWORD dwAccess, DWORD dwShareMode, bool bCreate) = 0;

        virtual void Close(void) = 0;

        virtual DWORD Read(LPVOID pbDest, DWORD cbDest, LPDWORD pcbRead) = 0;

        virtual DWORD Seek(LONG lDistance, DWORD dwMethod) = 0;

        virtual bool IsOpen(void) const = 0;

        virtual DWORD GetExpandedName(LPTSTR pszDest, UINT cchDest) = 0;

        virtual DWORD CopyTo(LPCTSTR pszFileTo) = 0;

    protected:
        LPTSTR m_pszPath;

    private:
        LPTSTR StrDup(LPCTSTR psz);
        //
        // Prevent copy.
        //
        CFontFileIo(const CFontFileIo& rhs);
        CFontFileIo& operator = (const CFontFileIo& rhs);
};


//
// Opens and reads font files using Win32 functions.
//
class CFontFileIoWin32 : public CFontFileIo
{
    public:
        CFontFileIoWin32(LPCTSTR pszPath)
            : CFontFileIo(pszPath),
              m_hFile(INVALID_HANDLE_VALUE) { }

        virtual ~CFontFileIoWin32(void);

        virtual DWORD Open(DWORD dwAccess, DWORD dwShareMode, bool bCreate = false);

        virtual void Close(void);

        virtual DWORD Read(LPVOID pbDest, DWORD cbDest, LPDWORD pcbRead);

        virtual DWORD Seek(LONG lDistance, DWORD dwMethod);

        virtual bool IsOpen(void) const
            { return INVALID_HANDLE_VALUE != m_hFile; }

        virtual DWORD GetExpandedName(LPTSTR pszDest, UINT cchDest);

        virtual DWORD CopyTo(LPCTSTR pszFileTo);

    private:
        HANDLE m_hFile;

        //
        // Prevent copy.
        //
        CFontFileIoWin32(const CFontFileIoWin32& rhs);
        CFontFileIoWin32& operator = (const CFontFileIoWin32& rhs);
};


//
// Opens and reads font files using LZ (compression) library functions.
//
class CFontFileIoLz : public CFontFileIo
{
    public:
        CFontFileIoLz(LPCTSTR pszPath)
            : CFontFileIo(pszPath),
              m_hFile(-1) { }

        virtual ~CFontFileIoLz(void);

        virtual DWORD Open(DWORD dwAccess, DWORD dwShareMode, bool bCreate = false);

        virtual void Close(void);

        virtual DWORD Read(LPVOID pbDest, DWORD cbDest, LPDWORD pcbRead);

        virtual DWORD Seek(LONG lDistance, DWORD dwMethod);

        virtual bool IsOpen(void) const
            { return -1 != m_hFile; }

        virtual DWORD GetExpandedName(LPTSTR pszDest, UINT cchDest);

        virtual DWORD CopyTo(LPCTSTR pszFileTo);

    private:
        int m_hFile;

        DWORD LZERR_TO_WIN32(INT err);

        //
        // Prevent copy.
        //
        CFontFileIoLz(const CFontFileIoLz& rhs);
        CFontFileIoLz& operator = (const CFontFileIoLz& rhs);
};


//-----------------------------------------------------------------------------
// CFontFileIo
//-----------------------------------------------------------------------------
//
// Helper to duplicate strings.
//
LPTSTR 
CFontFileIo::StrDup(
    LPCTSTR psz
    )
{
    LPTSTR pszNew = new TCHAR[lstrlen(psz) + 1];
    if (NULL != pszNew)
        lstrcpy(pszNew, psz);

    return pszNew;
}


//-----------------------------------------------------------------------------
// CFontFileIoWin32
//-----------------------------------------------------------------------------
//
// Ensure the file is closed on object destruction.
//
CFontFileIoWin32::~CFontFileIoWin32(
    void
    )
{ 
    Close();
}


//
// Open the file using Win32 operations.
//
DWORD
CFontFileIoWin32::Open(
    DWORD dwAccess,
    DWORD dwShareMode,
    bool bCreate
    )
{
    DWORD dwResult = ERROR_SUCCESS;

    if (NULL == m_pszPath)
    {
        //
        // Path string creation failed in ctor.
        //
        return ERROR_NOT_ENOUGH_MEMORY; 
    }
    //
    // Close existing file if open.
    //
    Close();

    m_hFile = ::CreateFile(m_pszPath,
                           dwAccess,
                           dwShareMode,
                            0,
                           bCreate ? CREATE_ALWAYS : OPEN_EXISTING,
                           0,
                           NULL);

    if (INVALID_HANDLE_VALUE == m_hFile)
    {
        dwResult = ::GetLastError();
    }
    return dwResult;
}



void
CFontFileIoWin32::Close(
    void
    )
{
    if (INVALID_HANDLE_VALUE != m_hFile)
    {
        ::CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }
}


DWORD
CFontFileIoWin32::Read(
    LPVOID pbDest, 
    DWORD cbDest, 
    LPDWORD pcbRead
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    DWORD cbRead;

    if (NULL == pcbRead)
    {
        //
        // Not performing overlapped I/O so pcbRead can't be NULL.
        // User doesn't want the byte count so use a local dummy variable.
        // 
        pcbRead = &cbRead;
    }
    if (!::ReadFile(m_hFile, pbDest, cbDest, pcbRead, NULL))
    {
        dwResult = ::GetLastError();
    }
    return dwResult;
}



DWORD
CFontFileIoWin32::Seek(
    LONG lDistance, 
    DWORD dwMethod
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    if (INVALID_SET_FILE_POINTER == ::SetFilePointer(m_hFile, lDistance, NULL, dwMethod))
    {
        dwResult = ::GetLastError();
    }
    return dwResult;
}


//
// Expanding the name of a non-LZ file is just a string copy
// of the full path.
//
DWORD 
CFontFileIoWin32::GetExpandedName(
    LPTSTR pszDest, 
    UINT cchDest
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    if (NULL != m_pszPath)
    {
        lstrcpyn(pszDest, m_pszPath, cchDest);
    }
    else
    {
        //
        // Failed to create path string in ctor.
        //
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
    }
    return dwResult;
}


//
// Copy the file to a new file using Win32 operations.
// Fail if the destination file already exists.
//
DWORD 
CFontFileIoWin32::CopyTo(
    LPCTSTR pszFileTo
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    if (NULL != m_pszPath)
    {
        if (!::CopyFile(m_pszPath, pszFileTo, TRUE))
            dwResult = ::GetLastError();
    }
    else
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
    }
    return dwResult;
}


//-----------------------------------------------------------------------------
// CFontFileIoLz
//-----------------------------------------------------------------------------
//
// Ensure file is closed on object destruction.
//
CFontFileIoLz::~CFontFileIoLz(
    void
    )
{ 
    Close();
}


//
// Open the file using LZOpen.
//
DWORD
CFontFileIoLz::Open(
    DWORD dwAccess,
    DWORD dwShareMode,
    bool bCreate
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    DWORD dwMode;
    OFSTRUCT ofs   = { 0 };

    if (NULL == m_pszPath)
        return ERROR_NOT_ENOUGH_MEMORY; 

    ofs.cBytes = sizeof(ofs);
    //
    // Close file if it's open.
    //
    Close();
    //
    // Map the Win32 access flags to the associated OFSTRUCT flags.
    //
    dwMode = OF_SHARE_EXCLUSIVE; // Assume we want exclusive access.

    if (GENERIC_READ & dwAccess)
        dwMode |= OF_READ;
    if (GENERIC_WRITE & dwAccess)
        dwMode |= OF_WRITE;
    if (0 == (FILE_SHARE_READ & dwShareMode))
        dwMode &= ~OF_SHARE_DENY_READ;
    if (0 == (FILE_SHARE_WRITE & dwShareMode))
        dwMode &= ~OF_SHARE_DENY_WRITE;

    if (bCreate)
        dwMode |= OF_CREATE;

    m_hFile = ::LZOpenFile((LPTSTR)m_pszPath, &ofs, LOWORD(dwMode));
    if (0 > m_hFile)
    {
        dwResult = LZERR_TO_WIN32(m_hFile);
    }
    return dwResult;
}


void
CFontFileIoLz::Close(
    void
    )
{
    if (-1 != m_hFile)
    {
        ::LZClose(m_hFile);
        m_hFile = -1;
    }
}



DWORD
CFontFileIoLz::Read(
    LPVOID pbDest, 
    DWORD cbDest, 
    LPDWORD pcbRead
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    INT cbRead = ::LZRead(m_hFile, (LPSTR)pbDest, (INT)cbDest);
    if (0 > cbRead)
    {
        dwResult = LZERR_TO_WIN32(cbRead);
    }
    else
    {
        if (NULL != pcbRead)
            *pcbRead = cbRead;
    }
    return dwResult;
}



DWORD
CFontFileIoLz::Seek(
    LONG lDistance, 
    DWORD dwMethod
    )
{
    //
    // LZSeek iOrigin codes match exactly with Win32
    // dwMethod codes (i.e. FILE_BEGIN == 0)
    //
    DWORD dwResult = ERROR_SUCCESS;
    LONG cbPos = ::LZSeek(m_hFile, lDistance, (INT)dwMethod);
    if (0 > cbPos)
    {
        dwResult = LZERR_TO_WIN32(cbPos);
    }
    return dwResult;
}



DWORD 
CFontFileIoLz::GetExpandedName(
    LPTSTR pszDest, 
    UINT cchDest
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    if (NULL != m_pszPath)
    {
        INT iResult = ::GetExpandedName(const_cast<TCHAR *>(m_pszPath), pszDest);
        if (0 > iResult)
            dwResult = LZERR_TO_WIN32(iResult);
    }
    else
    {
        //
        // Failed to create path string in ctor.
        //
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwResult;
}



DWORD 
CFontFileIoLz::CopyTo(
    LPCTSTR pszFileTo
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    bool bOpened   = false;          // Did we open the file?

    if (!IsOpen())
    {
        //
        // If file isn't already open, open it with READ access.
        //
        dwResult = Open(GENERIC_READ, FILE_SHARE_READ, false);
        bOpened = (ERROR_SUCCESS == dwResult);
    }

    if (ERROR_SUCCESS == dwResult)
    {
        CFontFileIoLz fileTo(pszFileTo);
        dwResult = fileTo.Open(GENERIC_WRITE, FILE_SHARE_READ, true);
        if (ERROR_SUCCESS == dwResult)
        {
            INT iResult = ::LZCopy(m_hFile, fileTo.m_hFile);
            if (0 > iResult)
                dwResult = LZERR_TO_WIN32(iResult);
        }
    }

    if (bOpened)
    {
        //
        // We opened it here.  Close it.
        //
        Close();
    }
    return dwResult;
}


//
// Convert an LZ API error code to a Win32 error code.
//
DWORD
CFontFileIoLz::LZERR_TO_WIN32(
    INT err
    )
{
    static const struct
    {
        int   lzError;
        DWORD dwError;
    } rgLzErrMap[] = {
    
         { LZERROR_BADINHANDLE,  ERROR_INVALID_HANDLE      },
         { LZERROR_BADOUTHANDLE, ERROR_INVALID_HANDLE      },              
         { LZERROR_BADVALUE,     ERROR_INVALID_PARAMETER   },
         { LZERROR_GLOBALLOC,    ERROR_NOT_ENOUGH_MEMORY   }, 
         { LZERROR_GLOBLOCK,     ERROR_LOCK_FAILED         },
         { LZERROR_READ,         ERROR_READ_FAULT          },
         { LZERROR_WRITE,        ERROR_WRITE_FAULT         } };

    for (int i = 0; i < ARRAYSIZE(rgLzErrMap); i++)
    {
        if (err == rgLzErrMap[i].lzError)
            return rgLzErrMap[i].dwError;
    }
    return DWORD(err); // FEATURE:  We should probably assert here.
}


//-----------------------------------------------------------------------------
// CFontFileIoLz
//-----------------------------------------------------------------------------
CFontFile::~CFontFile(
    void
    )
{
    delete m_pImpl; 
}


//
// This function provides the "virtual construction" for CFontFile objects.
// If the file is compressed, it creates a CFontFileIoLz object to handle
// the file I/O operations using the LZ32 library.  Otherwise it creates a 
// CFontFileIoWin32 object to handle the operations using Win32 functions.
//
DWORD
CFontFile::Open(
    LPCTSTR pszPath,
    DWORD dwAccess, 
    DWORD dwShareMode,
    bool bCreate
    )
{
    DWORD dwResult = ERROR_NOT_ENOUGH_MEMORY;

    delete m_pImpl; // Delete any existing implementation.

    m_pImpl = new CFontFileIoWin32(pszPath);
    if (NULL != m_pImpl)
    {
        bool bOpen = true;  // Do we need to call Open()?
 
        if (!bCreate)
        {
            //
            // Opening existing file.  Need to know if it's compressed or not.
            //
            dwResult = m_pImpl->Open(GENERIC_READ, FILE_SHARE_READ, false);
            if (ERROR_SUCCESS == dwResult)
            {
                if (IsCompressed())
                {
                    //
                    // File is compressed.  Destroy this io object and
                    // create one that understands LZ compression.
                    //
                    delete m_pImpl;
                    m_pImpl = new CFontFileIoLz(pszPath);
                    if (NULL == m_pImpl)
                    {
                        bOpen    = false;
                        dwResult = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                else
                {
                    //
                    // It's not compressed.
                    //
                    if (GENERIC_READ == dwAccess && FILE_SHARE_READ == dwShareMode)
                    {
                        //
                        // The access attributes are the same as for the file we 
                        // already have open.  Just use the existing object.
                        //
                        Reset();
                        bOpen = false;
                    }
                    else
                    {
                        //
                        // Access attributes aren't right.  Close the current
                        // Win32 io object and re-open it with the requested access
                        // attributes.
                        //
                        m_pImpl->Close();
                    }
                }
            }
        }
        if (bOpen)
        {
            //
            // Assumes m_pImpl is not NULL.
            //
            dwResult = m_pImpl->Open(dwAccess, dwShareMode, bCreate);
        }
    }
    return dwResult;
}


void 
CFontFile::Close(
    void
    )
{
    if (NULL != m_pImpl) 
        m_pImpl->Close(); 
}


DWORD
CFontFile::Read(
    LPVOID pbDest, 
    DWORD cbDest, 
    LPDWORD pcbRead
    )
{
    if (NULL != m_pImpl)
        return m_pImpl->Read(pbDest, cbDest, pcbRead); 

    return ERROR_INVALID_ADDRESS;
}


DWORD
CFontFile::Seek(
    UINT uDistance, 
    DWORD dwMethod
    )
{ 
    if (NULL != m_pImpl)
        return m_pImpl->Seek(uDistance, dwMethod); 

    return ERROR_INVALID_ADDRESS;
}


DWORD 
CFontFile::CopyTo(
    LPCTSTR pszFileTo
    )
{
    if (NULL != m_pImpl)
        return m_pImpl->CopyTo(pszFileTo);

    return ERROR_INVALID_ADDRESS;
}


//
// Determine if the file is compressed by reading the first 8 bytes
// of the file.  Compressed files have this fixed signature.
//
bool
CFontFile::IsCompressed(
    void
    )
{
    const BYTE rgLzSig[] = "SZDD\x88\xf0\x27\x33";
    BYTE rgSig[sizeof(rgLzSig)];
    bool bCompressed = false; // Assume it's not compressed.

    if (ERROR_SUCCESS == Read(rgSig, sizeof(rgSig)))
    {
        bCompressed = true;  // Now assume it's compressed and prove otherwise.

        for (int i = 0; i < ARRAYSIZE(rgLzSig) - 1; i++)
        {
            if (rgSig[i] != rgLzSig[i])
            {
                bCompressed = false; // Not an LZ header.  Not compressed.
                break;
            }
        }
    }
    return bCompressed;
}


//
// Retrieve the "expanded" filename for a font file.  If the font file is
// compressed, this code eventually calls into the LZ32 library's 
// GetExpandedName API.  If the file is not compressed, the full path
// (as provided) is returned.  
//
DWORD 
CFontFile::GetExpandedName(
    LPCTSTR pszFile, 
    LPTSTR pszDest, 
    UINT cchDest
    )
{
    CFontFile file;
    DWORD dwResult = file.Open(pszFile, GENERIC_READ, FILE_SHARE_READ, false);
    if (ERROR_SUCCESS == dwResult)
    {
        file.Close();
        dwResult = file.m_pImpl->GetExpandedName(pszDest, cchDest);
    }

    if (ERROR_SUCCESS != dwResult)
    {
        //
        // Failed to get expanded name.
        // Ensure output buffer is nul-terminated.
        //
        if (0 < cchDest)
            *pszDest = TEXT('\0');
    }
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\fontext.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fontext.cpp
//      Explorer Font Folder extension routines
//     Fonts Folder Shell Extension
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"

// ********************************************************
// Initialize GUIDs
//

#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <cguid.h>
#include <shlguid.h>
#include "fontext.h"
#include "panmap.h"     // the IID for the Panose Mapper.

//#undef INITGUID
#pragma data_seg()

#include "globals.h"
#include "extinit.h"
#include "fontman.h"
#include "fontview.h"
#include "cpanel.h"
#include "ui.h"
#include "dbutl.h"
#include "extricon.h"

#ifndef ARRAYSIZE
#   define ARRAYSIZE(a)  (sizeof(a) / sizeof((a)[0]))
#endif

#define GUIDSIZE  (GUIDSTR_MAX + 1)

HINSTANCE g_hInst = NULL;
LONG      g_cRefThisDll = 0; // Number of references to objects in this dll
LONG      g_cLock = 0;       // Used by the LockContainer member of CFontFolder
BOOL      g_bDBCS;           // Running in a DBCS locale ?
CRITICAL_SECTION g_csFontManager; // For acquiring font manager ptr.

class CImpIClassFactory;

// UINT g_DebugMask; //  = DM_ERROR | DM_TRACE1 | DM_MESSAGE_TRACE1 | DM_TRACE2;
UINT g_DebugMask = DM_ERROR | DM_TRACE1 | DM_MESSAGE_TRACE1 | DM_TRACE2;


#ifdef _DEBUG

#ifdef WINNT
//
// The Alpha compiler doesn't like the typecast used in the call to wvsprintf().
// Using standard variable argument mechanism.
//
#include <stdarg.h>
#endif

void DebugMessage( UINT mask, LPCTSTR pszMsg, ... )
{

    TCHAR ach[ 256 ];

#ifdef WINNT
    va_list args;
    va_start(args, pszMsg);
#endif

    if( !( mask & g_DebugMask ) ) return;

    wvsprintf( ach, pszMsg, ( (char *)(TCHAR *) &pszMsg + sizeof( TCHAR * ) ) );

#ifdef WINNT
    wvsprintf( ach, pszMsg, args);
    va_end(args);
#endif

    if( !( mask & DM_NOEOL ) ) lstrcat( ach, TEXT( "\r\n" ) );


#ifndef USE_FILE
    OutputDebugString( ach );
#else
    HANDLE hFile;
    long x;
    
    hFile = CreateFile( g_szLogFile, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,
                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

    if( INVALID_HANDLE_VALUE == hFile )
    {
       OutputDebugString( TEXT( "FontExt: Unable to open log file\r\n" ) );
       return;
    }
    
    if( 0xFFFFFFFF == SetFilePointer( hFile, 0, NULL, FILE_END ) )
    {
       OutputDebugString( TEXT( "FontExt: Unable to seek to end of log file\r\n" ) );
       return;
    }
    
    if( !WriteFile( hFile, ach, strlen( ach ), &x, NULL ) )
    {
       OutputDebugString( TEXT( "FontExt: Unable to write to log file\r\n" ) );
       return;
    }
    
    if( !CloseHandle( hFile ) )
    {
       OutputDebugString( TEXT( "FontExt: Unable to close log file\r\n" ) );
       return;
    }
#endif
}


// ******************************************************************
// Send an HRESULT to the debug output
//

void DebugHRESULT( int flags, HRESULT hResult )
{
    switch( GetScode( hResult ) )
    {
        case S_OK:          DEBUGMSG( (flags, TEXT( "S_OK" ) ) );          return;
        case S_FALSE:       DEBUGMSG( (flags, TEXT( "S_FALSE" ) ) );       return;
        case E_NOINTERFACE: DEBUGMSG( (flags, TEXT( "E_NOINTERFACE" ) ) ); return;
        case E_NOTIMPL:     DEBUGMSG( (flags, TEXT( "E_NOTIMPL" ) ) );     return;
        case E_FAIL:        DEBUGMSG( (flags, TEXT( "E_FAIL" ) ) );        return;
        case E_OUTOFMEMORY: DEBUGMSG( (flags, TEXT( "E_OUTOFMEMORY" ) ) ); return;
    } // switch

    if( SUCCEEDED( hResult ) ) 
        DEBUGMSG( (flags, TEXT( "S_unknown" ) ) );
    else if( FAILED( hResult ) ) 
        DEBUGMSG( (flags, TEXT( "E_unknown" ) ) );
    else 
        DEBUGMSG( (flags, TEXT( "No Clue" ) ) );
}


// ******************************************************************
// Print a REFIID to the debugger

void DebugREFIID( int flags, REFIID riid )
{
   if( riid == IID_IUnknown ) DEBUGMSG( (flags, TEXT( "IID_IUnknown" ) ) );
   else if( riid == IID_IShellFolder )  DEBUGMSG( (flags, TEXT( "IID_IShellFolder" ) ) );
   else if( riid == IID_IClassFactory ) DEBUGMSG( (flags, TEXT( "IID_IClassFactory" ) ) );
   else if( riid == IID_IShellView )    DEBUGMSG( (flags, TEXT( "IID_IShellView" ) ) );
   else if( riid == IID_IShellBrowser ) DEBUGMSG( (flags, TEXT( "IID_IShellBrowser" ) ) );
   else if( riid == IID_IContextMenu )  DEBUGMSG( (flags, TEXT( "IID_IContextMenu" ) ) );
   else if( riid == IID_IShellExtInit ) DEBUGMSG( (flags, TEXT( "IID_IShellExtInit" ) ) );
   else if( riid == IID_IShellPropSheetExt ) DEBUGMSG( (flags, TEXT( "IID_IShellPropSheetExt" ) ) );
   else if( riid == IID_IPersistFolder ) DEBUGMSG( (flags, TEXT( "IID_IPersistFolder" ) ) );
   else if( riid == IID_IExtractIconW )  DEBUGMSG( (flags, TEXT( "IID_IExtractIconW" ) ) );
   else if( riid == IID_IExtractIconA )  DEBUGMSG( (flags, TEXT( "IID_IExtractIconA" ) ) );
   else if( riid == IID_IDropTarget )   DEBUGMSG( (flags, TEXT( "IID_IDropTarget" ) ) );
   else if( riid == IID_IPersistFile )   DEBUGMSG( (flags, TEXT( "IID_IPersistFile" ) ) );
   //else if( riid == IID_I ) DEBUGMSG( (flags, TEXT( "IID_I" ) ) );
   else DEBUGMSG( (flags, TEXT( "No clue what interface this is" ) ) );
}
#endif   // _DEBUG


// ******************************************************************
// ******************************************************************
// DllMain

STDAPI_(BOOL) APIENTRY DllMain( HINSTANCE hDll, 
                                DWORD dwReason, 
                                LPVOID lpReserved )
{
    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
        {
            g_DebugMask = DM_ERROR | DM_TRACE1 | DM_TRACE2
                          | DM_MESSAGE_TRACE1; //  | DM_MESSAGE_TRACE2;
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: LibMain - DLL_PROCESS_ATTACH" ) ) );
            g_hInst = hDll;

            DisableThreadLibraryCalls(hDll);
            SHFusionInitializeFromModuleID(hDll, 124);
            InitializeCriticalSection(&g_csFontManager);
            
            //
            // Initialize the global g_bDBCS flag.
            //
            USHORT wLanguageId = LANGIDFROMLCID(GetThreadLocale());

            g_bDBCS = (LANG_JAPANESE == PRIMARYLANGID(wLanguageId)) ||
                      (LANG_KOREAN   == PRIMARYLANGID(wLanguageId)) ||
                      (LANG_CHINESE  == PRIMARYLANGID(wLanguageId));

            //
            // Initialize the various modules.
            //
            
            vCPPanelInit( );
            vUIMsgInit( );
            
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: LibMain - DLL_PROCESS_ATTACH" ) ) );
            break;
        }
        
        case DLL_PROCESS_DETACH:
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: LibMain - DLL_PROCESS_DETACH" ) ) );
            DeleteCriticalSection(&g_csFontManager);
            SHFusionUninitialize();
            break;
        
        case DLL_THREAD_ATTACH:
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: LibMain - DLL_THREAD_ATTACH" ) ) );
            break;
        
        case DLL_THREAD_DETACH:
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: LibMain - DLL_THREAD_DETACH" ) ) );
            break;
        
        default:
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: LibMain - DLL_something else" ) ) );
            break;
      
    } // switch
    
    return( TRUE );
}

 
// ******************************************************************
// DllCanUnloadNow

STDAPI DllCanUnloadNow( )
{
    HRESULT retval;
    
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: DllCanUnloadNow called - %d references" ),
               g_cRefThisDll ) );

    retval = ResultFromScode( (g_cRefThisDll == 0 ) && (g_cLock == 0 ) 
                               ? S_OK : S_FALSE );

    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: DllCanUnloadNow returning: %s" ),
               g_cRefThisDll ? TEXT( "S_FALSE" ) : TEXT( "S_OK" ) ) );

    return( retval );
}


// ********************************************************************

class CImpIClassFactory : public IClassFactory
{

public:
   CImpIClassFactory( ) : m_cRef( 0 )

      { g_cRefThisDll++;}
   ~CImpIClassFactory( ) { 
      DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: ~CImpIClassFactory" ) ) );
      g_cRefThisDll--; }

   //
   // *** IUnknown methods ***
   //

   STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj );
   STDMETHODIMP_(ULONG) AddRef( void );
   STDMETHODIMP_(ULONG) Release( void );
 
   //
   // *** IClassFactory methods ***
   //

   STDMETHODIMP CreateInstance( LPUNKNOWN pUnkOuter,
                                REFIID riid,
                                LPVOID FAR* ppvObject );

   STDMETHODIMP LockServer( BOOL fLock );

private:
  int m_cRef;

};

// ******************************************************************
// ******************************************************************
// DllGetClassObject

STDAPI DllGetClassObject( REFCLSID rclsid, 
                          REFIID riid, 
                          LPVOID FAR* ppvObj )
{

    // DEBUGBREAK;
    
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: DllGetClassObject called" ) ) );
    
    if( !(rclsid == CLSID_FontExt ) )
    {
       DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: Dll-GCO: Tried to create a ClassFactory for an unknown class" ) ) );
    
       return( ResultFromScode( E_FAIL ) );
    }
    
    if( !(riid == IID_IUnknown ) && !(riid == IID_IClassFactory ) )
    {
       DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: Dll-GCO: Unknown Interface requested" ) ) );
       return( ResultFromScode( E_NOINTERFACE ) );
    }
    
    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: Dll-GCO Creating a class factory for CLSID_FontExt" ) ) );
    
    *ppvObj = (LPVOID) new CImpIClassFactory;
    
    if( !*ppvObj )
    {
        DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: Dll-GCO: Out of memory" ) ) );

        return( ResultFromScode( E_OUTOFMEMORY ) );
    }
    
    ((LPUNKNOWN)*ppvObj)->AddRef( );
    
    return NOERROR;
}


HRESULT CreateViewObject( LPVOID FAR * ppvObj )
{
    HRESULT    retval;
    CFontView* prv;
    
    retval = ResultFromScode( E_OUTOFMEMORY );
    
    prv = new CFontView();

    if( !prv )
        return( retval );
    
    //
    //  AddRef the view and then Release after the QI. If QI fails,
    //  then prv with delete itself gracefully.
    //

    prv->AddRef( );

    retval = prv->QueryInterface( IID_IShellView, ppvObj );

    prv->Release( );
    
    return( retval );

}

// ***********************************************************************
// ***********************************************************************
//  CImpIClassFactory member functions
//
//  *** IUnknown methods ***
//

STDMETHODIMP CImpIClassFactory::QueryInterface( REFIID riid, 
                                                LPVOID FAR* ppvObj )
{
    *ppvObj = NULL;
    
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CImpIClassFactory::QueryInterface called" ) ) );
    
    //
    //  Any interface on this object is the object pointer
    //

    if( (riid == IID_IUnknown) || (riid == IID_IClassFactory) )
       *ppvObj = (LPVOID) this;
    
    if( *ppvObj )
    {
       ((LPUNKNOWN)*ppvObj)->AddRef( );
       return NOERROR;
    }
    
    return( ResultFromScode( E_NOINTERFACE ) );
}


STDMETHODIMP_(ULONG) CImpIClassFactory::AddRef( void )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CImpIClassFactory::AddRef called: %d->%d references" ),
              m_cRef, m_cRef + 1) );

    return( ++m_cRef );
}


STDMETHODIMP_(ULONG) CImpIClassFactory::Release( void )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CImpIClassFactory::Release called: %d->%d references" ),
              m_cRef, m_cRef - 1) );
    
    ULONG retval;
    
    retval = --m_cRef;
    
    if( !retval ) 
       delete this;

    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CImpIClassFactory Leaving. " ) ) );

    return( retval );
}
 

//
//  *** IClassFactory methods ***
//

STDMETHODIMP CImpIClassFactory::CreateInstance( LPUNKNOWN pUnkOuter,
                                                REFIID riid,
                                                LPVOID FAR* ppvObj )
{
    HRESULT   retval;
    LPUNKNOWN poUnk = NULL;
    
    
    retval = ResultFromScode( E_NOINTERFACE );
    
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CImpIClassFactory::CreateInstance called" ) ) );
    DEBUGREFIID( (DM_TRACE1, riid) );
    
    //
    //  we do not support aggregation
    //
    
    if( pUnkOuter )
       return( ResultFromScode( CLASS_E_NOAGGREGATION ) );
    

    if( riid == IID_IShellView || riid == IID_IPersistFolder )
    {
    
#if 0
        if( !g_poFontFolder )
        {
            g_poFontFolder = new CFontFolder;

            if( !g_poFontFolder )
            {
                DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: factory - no memory" ) ) );
                return( retval );
            }

            if( !g_poFontFolder->Init( ) )
            {
                DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: factory - no memory" ) ) );

                g_poFontFolder = 0;

                return( retval );
            }
        }

        //
        //  The ref count is initialized to 0 during creation, so we AddRef
        //  here and Release after CreateViewObject so it gets destroyed
        //  properly (if necessary)
        //

        g_poFontFolder->AddRef( );

        retval = g_poFontFolder->CreateViewObject( NULL, IID_IShellView, (void **)&poUnk );

        g_poFontFolder->Release( );

#else
        retval = CreateViewObject( (void **)&poUnk );
#endif
    }
    else if( riid == IID_IShellExtInit )
    {
        CShellExtInit * poExt = new CShellExtInit;

        if( !poExt || !poExt->bInit( ) )
        {
            DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: factory - no memory") ) );
            return( retval );
        }

        retval = poExt->QueryInterface( IID_IUnknown, (void **)&poUnk );
    }
    else if (riid == IID_IExtractIconW || 
             riid == IID_IExtractIconA ||
             riid == IID_IPersistFile)
    {
        CFontIconHandler *pfih = new CFontIconHandler;

        if (NULL == pfih)
        {
            DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: factory - no memory") ) );
            return (retval);
        }

        retval = pfih->QueryInterface(IID_IUnknown, (LPVOID *)&poUnk);
    }
   
    //
    //  If we got an IUnknown, then AddRef (above) before QI and then Release. 
    //  This will force the object to be deleted if QI fails.
    //
    //  This method of first querying for IUnknown then again for the
    //  actual interface of interest is unnecessary.
    //  I've left it this way just because it works and I don't want to 
    //  risk breaking something that has been coded around this weirdness.
    //  [brianau - 07/23/97]
    //

    if( poUnk )
    {
        retval = poUnk->QueryInterface( riid, ppvObj );

        // DEBUGHRESULT( (retval) );

        poUnk->Release( );
    }

    return( retval );
}


STDMETHODIMP CImpIClassFactory::LockServer( BOOL fLock )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CImpIClassFactory::LockServer called" ) ) );

    if( fLock ) 
        g_cLock++;
    else 
        g_cLock--;

    return( NOERROR );
}


HKEY OpenRegistryKey( TCHAR* szRegPath, TCHAR** ppValueName )
{
    TCHAR szCopy[ 300 ];
    int  lKey = lstrlen( szRegPath );
    int  i;
    
    lstrcpy( szCopy, szRegPath );

    for( i = 0; szCopy[ i ]; i++)
    {
        if( szCopy[ i ] == TEXT( '\\' ) )
        {
            szCopy[ i ] = TEXT( '\0' );
            *ppValueName = &szRegPath[ i+1 ];

            if( !szCopy[ i+1 ] )
            {
                DEBUGMSG( (DM_ERROR, TEXT( "REGEXT:  Value path name ended in a \\:%s" ),
                          szRegPath ) );

                return( NULL );
            }
        }
    }

    HKEY hKey;

    if( !lstrcmp( szCopy, TEXT( "HKEY_USERS" ) ) )              hKey = HKEY_USERS;
    else if( !lstrcmp( szCopy, TEXT( "HKEY_CURRENT_USER" ) ) )  hKey = HKEY_CURRENT_USER;
    else if( !lstrcmp( szCopy, TEXT( "HKEY_CLASSES_ROOT" ) ) )  hKey = HKEY_CLASSES_ROOT;
    else if( !lstrcmp( szCopy, TEXT( "HKEY_LOCAL_MACHINE" ) ) ) hKey = HKEY_LOCAL_MACHINE;
    else
    {
        DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT:  Bad root node name:%s" ), szCopy ) );
        return( NULL );
    }
    
    for( i = 0; &szRegPath[ i+1 ] != *ppValueName; i++ )
    {
        if( !szCopy[ i ] )
        {
            HKEY hKeyPrev = hKey;
            DWORD dwDisp;

            if( ERROR_SUCCESS != RegCreateKeyEx( hKeyPrev,
                                                 &szCopy[ i+1 ],
                                                 NULL,
                                                 TEXT( "" ),
                                                 NULL,
                                                 KEY_ALL_ACCESS,
                                                 NULL,
                                                 &hKey,
                                                 &dwDisp ) )
            {
                DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT:  Can't open key %s" ), &szCopy[ i+1 ]) );
                return( NULL );
            }

            if( dwDisp == REG_CREATED_NEW_KEY )
            {
                DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: Created new key:%s" ), &szCopy[ i+1 ]) );
            }

            // CRegID::CloseKey( hKeyPrev );

            RegCloseKey( hKey );
        }
    }
    
    return( hKey );
}

//
// We need a CLSID->string converter but I don't want to link to 
// ole32 to get it.  This isn't a terribly efficient implementation but
// we only call it once during DllRegServer so it doesn't need to be.
// [brianau - 2/23/99]
//
bool
GetClsidStringA(
    REFGUID clsid,
    LPSTR pszDest,
    UINT cchDest
    )
{
    bool bResult = false;
    if (cchDest >= GUIDSIZE)
    {
        wsprintfA(pszDest, 
                  "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                  clsid.Data1,
                  clsid.Data2,
                  clsid.Data3,
                  clsid.Data4[0],
                  clsid.Data4[1],
                  clsid.Data4[2],
                  clsid.Data4[3],
                  clsid.Data4[4],
                  clsid.Data4[5],
                  clsid.Data4[6],
                  clsid.Data4[7]);

        bResult = true;
    }
    return bResult;
}



HRESULT
CreateDesktopIniFile(
    void
    )
{
    //
    // Get the path for the file (%windir%\fonts\desktop.ini)
    //
    TCHAR szPath[MAX_PATH * 2];
    HRESULT hr = SHGetSpecialFolderPath(NULL, szPath, CSIDL_FONTS, FALSE) ? S_OK : E_FAIL;
    if (SUCCEEDED(hr))
    {
        PathAppend(szPath, TEXT("desktop.ini"));
        //
        // Build the file's content.  Note that it's ANSI text.
        //
        char szClsid[GUIDSIZE];

        if (GetClsidStringA(CLSID_FontExt, szClsid, ARRAYSIZE(szClsid)))
        {
            const char szFmt[] = "[.ShellClassInfo]\r\nUICLSID=%s\r\n";
            char szText[ARRAYSIZE(szClsid) + ARRAYSIZE(szFmt)];
            DWORD dwBytesWritten;

            wsprintfA(szText, szFmt, szClsid);

            //
            // Always create the file.  Attr are SYSTEM+HIDDEN.
            //
            HANDLE hFile = CreateFile(szPath,
                                      GENERIC_WRITE,
                                      FILE_SHARE_READ,
                                      NULL,
                                      CREATE_ALWAYS,
                                      FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN,
                                      NULL);

            if (INVALID_HANDLE_VALUE != hFile)
            {
                //
                // Write out the contents.
                //
                if (!WriteFile(hFile, szText, lstrlenA(szText), &dwBytesWritten, NULL))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
                CloseHandle(hFile);
            }
            else
                hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
            hr = E_UNEXPECTED;
    }
    return hr;
}


STDAPI DllRegisterServer(void)
{
    //
    // Currently, all we do is create the desktop.ini file.
    //
    return CreateDesktopIniFile();
}

STDAPI DllUnregisterServer(void)
{
    //
    // Do nothing.
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\fontlist.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fontlist.cpp
//      Explorer Font Folder extension routines
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================
#include "priv.h"
#include "globals.h"

#include "fontvect.h"
#include "fontlist.h"

#include <memory.h>     // For memcpy
#include "fontcl.h"
#include "dbutl.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

////////////////////////////////////////////////////////////////////////////

CFontList::CFontList(
   int iSize,  // Initial number of fonts
   int iVectorSize )
   :  m_pData( 0 ),
      m_iCount( 0 ),
      m_iVectorCount( 0 ),
      m_iVectorSize( iVectorSize ),
      m_iVectorBounds( 0 )
{
    if( m_iVectorSize <= 0 )
        m_iVectorSize = kDefaultVectSize;

    m_iVectorBounds = iSize / m_iVectorSize + 1;
      
}


CFontList::~CFontList( )
{
    vDeleteAll( );

    if( m_pData )
        delete [] m_pData;
}


int CFontList::bInit( )
{
    int   iRet = 0;

    ASSERT( this );

    if( m_iVectorSize && !m_iCount && m_iVectorBounds )
    {
        m_pData = new CFontVector * [ m_iVectorBounds ];

        if( m_pData )
        {
            // 
            //  Allocate one CFontVector
            //

            m_pData[ 0 ] = new CFontVector( m_iVectorSize );

            if( m_pData[ 0 ] && ( m_pData[ 0 ]->bInit( ) ) )
            {
                m_iVectorCount++;
                return 1;
            }
        }
    }

    //
    //  Error. Clean up and return.
    //

    delete this;

    return 0;
}


int CFontList::iCount( void )
{
    ASSERT( this );

    return m_iCount;
}


int CFontList::bAdd( CFontClass * t )
{
    ASSERT( this );

    if( t == ( CFontClass *) 0 )
        return 0;

    //
    //  Determine which vector to put it in.
    //

    int iVector = m_iCount / m_iVectorSize;

    //
    //  If the vector isn't valid, then make one.
    //

    if( iVector >= m_iVectorCount )
    {
        //
        //  Allocate more vector pointers if we're out.
        //

        if( m_iVectorCount >= m_iVectorBounds )
        {
            int iNewBounds = m_iVectorBounds + 5;

            CFontVector ** pNew = new CFontVector * [ iNewBounds ];

            if( !pNew )
                return 0;

            memcpy( pNew, m_pData, sizeof( CFontVector * ) * m_iVectorBounds );

            delete [] m_pData;
            m_pData = pNew;

            m_iVectorBounds = iNewBounds;
        }

        m_pData[ iVector ] = new CFontVector( m_iVectorSize );

        if( !m_pData[ iVector ] || (! m_pData[ iVector ]->bInit( ) ) )
        {
            m_pData[ iVector ] = 0;
            return 0;
        }

        m_iVectorCount++;

    }

    if(  m_pData[ iVector ]->bAdd( t ) )
    {
        t->AddRef();
        m_iCount++;
        return 1;
    }

    return 0;
}


CFontClass * CFontList::poObjectAt( int idx )
{
    ASSERT( this );

    if( idx >=0 && idx < m_iCount )
    {
        int iVector = idx / m_iVectorSize;

        int subIdx = idx % m_iVectorSize;

        return m_pData[ iVector ]->poObjectAt( subIdx );
    }

    return 0;
}


CFontClass * CFontList::poDetach( int idx )
{
    ASSERT( this );

    if( idx >=0 && idx < m_iCount )
    {
        int iVector = idx / m_iVectorSize;

        int subIdx = idx % m_iVectorSize;

        CFontClass * pID = m_pData[ iVector ]->poDetach( subIdx );

        //
        //  If this isn't the last vector, then move one out of the last
        //  and into this one.
        //

        if( iVector != ( m_iVectorCount - 1 ) )
        {
            m_pData[ iVector ]->bAdd( m_pData[ m_iVectorCount - 1 ]->poDetach( 0 ) );
        }

        //
        //  If the last vector is now empty, remove it.
        //

        if( ! m_pData[ m_iVectorCount - 1 ]->iCount( ) )
        {
            m_iVectorCount--;

            delete m_pData[ m_iVectorCount ];

#ifdef _DEBUG
            //
            //  Fill it with zero.
            //

            m_pData[ m_iVectorCount ] = 0;
#endif         
        }

        ASSERT( pID );

        if( pID )
            m_iCount--;

        return pID;
    }

    return (CFontClass *) 0;
}


void CFontList::vDetachAll( )
{
    ASSERT( this );
    
    while( m_iCount )
    {
        CFontClass *poFont = poDetach( m_iCount - 1 );
        if (NULL != poFont)
            poFont->Release();
    }
}


CFontClass * CFontList::poDetach( CFontClass * t )
{
    ASSERT( this );

    return poDetach( iFind( t ) );
}


int CFontList::bDelete( int idx )
{
    ASSERT( this );

    CFontClass * pID = poDetach( idx );

    if( pID )
    {
        pID->Release();
        return 1;
    }

    return 0;
}


int CFontList::bDelete( CFontClass * t )
{
    ASSERT( this );

    return bDelete( iFind( t ) );
}


void CFontList::vDeleteAll( )
{
    ASSERT( this );

    while( m_iCount )
        bDelete( m_iCount - 1 );
}


int CFontList::iFind( CFontClass * t )
{
    int iRet;
    
    ASSERT( this );
    
    for( int i = 0; i < m_iVectorCount; i++ )
    {
       if( ( iRet = m_pData[ i ]->iFind( t ) ) != kNotFound )
          return( i * m_iVectorSize + iRet );
    }
    
    return kNotFound;
}


//
// Call CFontClass::Release for each font contained in the list.
//
void CFontList::ReleaseAll(void)
{
    CFontClass *poFont = NULL;
    for (INT i = 0; i < m_iCount; i++)
    {
        poFont = poObjectAt(i);
        if (NULL != poFont)
            poFont->Release();
    }
}

//
// Call CFontClass::AddRef for each font contained in the list.
//
void CFontList::AddRefAll(void)
{
    CFontClass *poFont = NULL;
    for (INT i = 0; i < m_iCount; i++)
    {
        poFont = poObjectAt(i);
        if (NULL != poFont)
            poFont->AddRef();
    }
}

//
// Create a clone of the list.
// Why Clone and not a copy ctor and assignment operator?
// The font folder code in general isn't very proper C++.
// Clone() is a better match to the existing code.
//
CFontList*
CFontList::Clone(
    void
    )
{
    CFontList *pNewList = new CFontList(m_iCount, m_iVectorSize);
    if (NULL != pNewList && pNewList->bInit())
    {
        for (int i = 0; i < m_iCount; i++)
        {
            if (!pNewList->bAdd(poObjectAt(i)))
            {
                delete pNewList;
                pNewList = NULL;
                break;
            }
        }
    }
    return pNewList;
}



/**********************************************************************
 * Some things you can do with a font list.
 */

HDROP hDropFromList( CFontList * poList )
{
    HANDLE           hMem = 0;
    LPDROPFILESTRUCT lpDrop;
    DWORD            dwSize;
    int              iCount,
                     i;
    CFontClass *     poFont;
    FullPathName_t   szPath;
    LPTSTR           lpPath;
    
    //
    //  Sanity.
    //
    if( !poList )
       goto backout0;
    
    //
    //  Walk the list and find out how much space we need.
    //

    iCount = poList->iCount( );

    if( !iCount )
        goto backout0;
    
    dwSize = sizeof( DROPFILESTRUCT ) + sizeof(TCHAR);  // size + terminating extra nul

    for( i = 0; i < iCount; i++ )
    {
        poFont = poList->poObjectAt( i );

        poFont->bGetFQName( szPath, ARRAYSIZE( szPath ) );
        dwSize += ( lstrlen( szPath ) + 1 ) * sizeof( TCHAR );

        //
        // Add length of PFB file path if this font has an associated PFB.
        // Note that bGetPFB() returns FALSE if the font isn't Type1.
        //
        if (poFont->bGetPFB(szPath, ARRAYSIZE(szPath)))
            dwSize += (lstrlen(szPath) + 1) * sizeof( TCHAR );
    }
    
    //
    //  Allocate the buffer and fill it in.
    //

    hMem = GlobalAlloc( GMEM_SHARE | GHND, dwSize );

    if( !hMem )
        goto backout0;
    
    lpDrop = (LPDROPFILESTRUCT) GlobalLock( hMem );

    lpDrop->pFiles = (DWORD)(sizeof(DROPFILESTRUCT));
    lpDrop->pt.x   = 0;
    lpDrop->pt.y   = 0;
    lpDrop->fNC    = FALSE;
#ifdef UNICODE
    lpDrop->fWide  = TRUE;
#else
    lpDrop->fWide  = FALSE;
#endif

    //
    //  Fill in the path names.
    //

    lpPath = (LPTSTR) ( (LPBYTE) lpDrop + lpDrop->pFiles );

    for( i = 0; i < iCount; i++ )
    {
        poFont = poList->poObjectAt( i );
        

        poFont->bGetFQName( lpPath, ARRAYSIZE(szPath) );
        lpPath += lstrlen( lpPath ) + 1;

        //
        // Add PFB file path if font is a type 1.
        //
        if( poFont->bGetPFB(lpPath, ARRAYSIZE(szPath)))
            lpPath += ( lstrlen( lpPath ) + 1 );
    }

    *lpPath = TEXT('\0');       // Extra Nul terminate
    
    //
    //  Unlock the buffer and return it.
    //

    GlobalUnlock( hMem );
    
backout0:
    return (HDROP) hMem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\fontman.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fontman.cpp
//      Explorer Font Folder extension routines.
//      Implementation for the class: CFontManager
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-93 ElseWare Corporation.    All rights reserved.
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include <shlobjp.h>
#include <setupapi.h>

// #include "ole2.h"

#include "fontman.h"
#include "fontlist.h"
#include "fontcl.h"
#include "panmap.h"
#include "cpanel.h"
#include "strtab.h"

#include "dbutl.h"
#include "resource.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#if 1
#define ECS    EnterCriticalSection( &m_cs )
#define LCS    LeaveCriticalSection( &m_cs )
#else
#define ECS
#define LCS
#endif

#ifdef WINNT
static TCHAR s_szKey1[] = TEXT( "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts" );
static TCHAR s_szKeyFontDrivers[] = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Font Drivers");
#else
static TCHAR s_szKey1[] = TEXT( "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Fonts" );
#endif  // WINNT

static TCHAR s_szKey2[] = TEXT( "Display\\Fonts" );
static TCHAR s_szINISFonts[] = TEXT( "fonts" );


#if 1
/***************************************************************************
 * METHOD:  bKeyHasKey
 *
 * PURPOSE: Determine if the key exists in the registry.
 *
 * RETURNS: the number of bytes written into the buffer.
 *
 ***************************************************************************/

BOOL bKeyHasKey( HKEY          hk,
                 const TCHAR * pszKey,
                 TCHAR       * pszValue,
                 int           iValLen )
{
    DWORD  i;
    TCHAR  szKey[ 80 ];
    DWORD  dwKey,
           dwValue,
           dwKeyLen;
    DWORD  dwErr;
    int    iFound = 0;

    dwKeyLen = lstrlen( pszKey );

    i = 0;

    while( TRUE )
    {
        dwKey   = ARRAYSIZE( szKey );

        dwValue = iValLen * sizeof( TCHAR );

        dwErr = RegEnumValue( hk, i, szKey, &dwKey, NULL,
                              NULL, (LPBYTE)pszValue, &dwValue );

        if( dwErr == ERROR_NO_MORE_ITEMS )
            break;
        else if( dwErr == ERROR_SUCCESS )
        {
            //
            //  Null terminate it.
            //

            szKey[ dwKey ] = 0;

            //
            //  Check to see if this is the one we want.
            //

            if( dwKey == dwKeyLen )
            {
                if( ( iFound = !lstrcmpi( szKey, pszKey ) ) )
                    break;
            }
        }

        //
        //  Move on to the next one.
        //

        i++;
    }

    return (int)iFound;
}


BOOL bRegHasKey( const TCHAR * pszKey, TCHAR * pszValue = NULL, int iValLen = 0 );


BOOL bRegHasKey( const TCHAR * pszKey, TCHAR * pszValue, int iValLen )
{
    HKEY  hk;
    BOOL  bHasKey = FALSE;
    FullPathName_t szPath;

    if( !pszValue )
    {
        pszValue = szPath;
        iValLen  = ARRAYSIZE( szPath );
    }

    //
    //  Check standard 'fonts' registry list to see if font is
    //  already installed.
    //

    if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_szKey1, 0,
                                       KEY_READ, &hk ) )
    {
        bHasKey = bKeyHasKey( hk, pszKey, pszValue, iValLen );
        RegCloseKey( hk );
    }

#ifndef WINNT

    //
    // [stevecat] 7/10/95 NT does not yet support HKEY_CURRENT_CONFIG
    //                    and won't until Plug N Play fills in that
    //                    part of the registry.
    //

    if( !bHasKey )
    {
        if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_CONFIG, s_szKey2,
                                           0, KEY_READ, &hk ) )
        {
            bHasKey = bKeyHasKey( hk, pszKey, pszValue, iValLen );
            RegCloseKey( hk );
        }
    }

#endif  //  WINNT

    //
    //  If we still don't have it, try from the WIN.INI file.
    //

    if( !bHasKey )
    {
        bHasKey = (BOOL) GetProfileString( s_szINISFonts, pszKey, TEXT( "" ),
                                           pszValue,
                                           iValLen );
    }

#ifdef LATER  // WINNT

    //
    //  Check 'Type 1' registry location to see if it is already installed.
    //

    if( !bHasKey )
    {
        if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, g_szType1Key,
                                           0, KEY_READ, &hk ) )
        {
            bHasKey = bKeyHasKey( hk, pszKey, pszValue, iValLen );

            RegCloseKey( hk );
        }
    }

#endif  //  LATER  WINNT

    return bHasKey;
}
#endif


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

BOOL  WriteToRegistry( LPTSTR lpValue, LPTSTR lpData )
{
    HKEY  hk;
    LONG  lRet;


    if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_szKey1, 0,
                                       KEY_SET_VALUE, &hk ) )
    {
        if( lpData )
            lRet = RegSetValueEx( hk, lpValue, 0, REG_SZ,
                                  (const LPBYTE)lpData,
                                  (lstrlen( lpData ) + 1) * sizeof( TCHAR ) );
        else
        {
            lRet = RegDeleteValue( hk, lpValue );
        }

        RegCloseKey( hk );



#ifndef WINNT

    //
    // [stevecat] 7/10/95 NT does not yet support HKEY_CURRENT_CONFIG
    //                    and won't until Plug N Play fills in that
    //                    part of the registry.
    //

        //
        //  If we're deleting (lpData == 0 ), make sure the string is gone
        //  from the Win.ini and the other reg location.
        //

        if( !lpData && ( lRet != ERROR_SUCCESS ) )
        {
            if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_CONFIG, s_szKey2,
                                               0, KEY_SET_VALUE, &hk ) )
            {
                lRet = RegDeleteValue( hk, lpValue );
                RegCloseKey( hk );
            }

        }

#endif  //  WINNT

        return( lRet == ERROR_SUCCESS );
    }

    return FALSE;
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

CFontManager::CFontManager( )
   :  m_poFontList( 0 ),
      m_poTempList( 0 ),
      m_poPanMap( 0 ),
      m_bTriedOnce( FALSE ),
      m_bFamiliesNeverReset( TRUE ),
      m_poRemoveList( 0 ),
      m_hNotifyThread( 0 ),
      m_hReconcileThread( 0 ),
      m_hResetFamThread( 0 ),
      m_hMutexResetFamily( 0 ),
      m_hMutexInstallation( 0 ),
      m_hEventTerminateThreads(NULL)
{
    m_Notify.m_hWatch    = INVALID_HANDLE_VALUE;

    m_hMutexResetFamily = CreateMutex( NULL, FALSE, NULL );
    m_hEventResetFamily = CreateEvent( NULL, TRUE, FALSE, NULL );
    m_hMutexInstallation = CreateMutex( NULL, FALSE, NULL );
    m_hEventTerminateThreads  = CreateEvent(NULL, TRUE, FALSE, NULL);

    InitializeCriticalSection( &m_cs );
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

CFontManager::~CFontManager( )
{
    //
    // Set the "terminate-all-threads" event.
    // Any threads in this module will recognize this event and 
    // immediately terminate their processing in a normal fashion.
    //
    // The order of these "SetEvent" calls is CRITICAL.  Must 
    // set the "terminate threads" event first.
    //
    if (NULL != m_hEventTerminateThreads)
    {
        SetEvent(m_hEventTerminateThreads);
    }
    if (NULL != m_hEventResetFamily)
    {
        SetEvent(m_hEventResetFamily);
    }        
    //
    // Wait for all active threads to terminate.
    //
    HANDLE rghThreads[3];
    int cThreads = 0;
    if (NULL != m_hNotifyThread)
        rghThreads[cThreads++] = m_hNotifyThread;
    if (NULL != m_hResetFamThread)
        rghThreads[cThreads++] = m_hResetFamThread;
    if (NULL != m_hReconcileThread)
        rghThreads[cThreads++] = m_hReconcileThread;

    DWORD dwWait = WaitForMultipleObjects(cThreads, rghThreads, TRUE, INFINITE);
        
    if( m_hNotifyThread )
    {
        CloseHandle( m_hNotifyThread );
    }
    if( m_hReconcileThread )
    {
        CloseHandle( m_hReconcileThread );
    }
    if( m_hResetFamThread )
    {
        CloseHandle( m_hResetFamThread );
    }

    ECS;
    if( m_Notify.m_hWatch != INVALID_HANDLE_VALUE )
    {
        if( !FindCloseChangeNotification( m_Notify.m_hWatch ) )
        {
            DEBUGMSG( (DM_ERROR, TEXT( "CFontManager:~CFontManager FindCloseChangeNotification FAILED - error = %d Handle = 0x%x" ), GetLastError( ), m_Notify.m_hWatch ) );
        }

        DEBUGMSG( (DM_TRACE2, TEXT( "CFontManager:~CFontManager FindCloseChangeNotification called" ) ) );
    }

    if( m_poFontList )
    {
        delete m_poFontList;
        m_poFontList = 0;
    }

    if( m_poPanMap )
    {
        m_poPanMap->Release( );
    }

    if( m_poTempList )
        delete m_poTempList;

    if( m_poRemoveList )
        delete m_poRemoveList;

    LCS;

    if (NULL != m_hMutexResetFamily)
        CloseHandle( m_hMutexResetFamily );

    if (NULL != m_hEventResetFamily)
        CloseHandle( m_hEventResetFamily );

    if (NULL != m_hMutexInstallation)
        CloseHandle( m_hMutexInstallation );

    if (NULL != m_hEventTerminateThreads)
        CloseHandle(m_hEventTerminateThreads);

    DeleteCriticalSection( &m_cs );
}



//
// GetOrReleaseFontManager
//
// Used by both GetFontManager and ReleaseFontManager.  I have both functions
// calling into this single function so we can control the scope of the 
// single CFontManager ptr and reference counter to a single function.
//
// Here's the scoop:
// The font folder uses a single CFontManager object.  The original code
// created it in the extinit code, destroyed it on process detach 
// and accessed it through a global pointer.  While not the best way
// to manage a singleton, this worked for Win9x and NT4.  In NT5 fontext.dll
// now implements an icon handler.  Therefore, fontext.dll is ALWAYS
// loaded in explorer.exe and the global font manager wasn't being destroyed
// until logoff because process-detach code in explorer.exe is only invoked 
// at logoff.
// 
// I added reference counting and centralized the access to the singleton
// font manager so that it's created on demand and destroyed when the last
// client is finished with it.  I made the CFontManager ctor private to
// enforce the use of the GetFontManager API.
// I also added code so that the manager's threads are now shut down in 
// an orderly fashion.  The original implementation merely called 
// TerminateThread() in the font manager's dtor (bad).  
// 
// [brianau - 6/5/99]
//
extern CRITICAL_SECTION g_csFontManager; // defined in fontext.cpp

HRESULT GetOrReleaseFontManager(CFontManager **ppoFontManager, bool bGet)
{
    static CFontManager *pSingleton;
    static LONG cRef = 0;
    
    HRESULT hr = NOERROR;
    EnterCriticalSection(&g_csFontManager);
    if (bGet)
    {
        if (NULL == pSingleton)
        {
            //
            // No manager exists.  Create it.
            //
            pSingleton = new CFontManager();
            if (NULL != pSingleton)
            {
                if (!pSingleton->bInit())
                {
                    delete pSingleton;
                    pSingleton = NULL;
                }
            }
        }
        if (NULL != pSingleton)
        {
            *ppoFontManager = pSingleton;
            cRef++;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *ppoFontManager = NULL;
        if (0 == (--cRef))
        {
            //
            // Last reference to manager.
            // Delete it.
            //
            delete pSingleton;
            pSingleton = NULL;
        }
    }
    LeaveCriticalSection(&g_csFontManager);
    return hr;
}

HRESULT GetFontManager(CFontManager **ppoFontManager)
{
    return GetOrReleaseFontManager(ppoFontManager, true);
}

void ReleaseFontManager(CFontManager **ppoFontManager)
{
    GetOrReleaseFontManager(ppoFontManager, false);
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/
BOOL CFontManager::bInit( )
{
    //
    // Load up the font list and request to receive file system change
    // notifications so we can react to new files added to the fonts directory.
    //
    DWORD idThread;
    if ( bLoadFontList() )
    {
         FullPathName_t szPath;

         GetFontsDirectory( szPath, ARRAYSIZE( szPath ) );

#ifdef WINNT
         //
         // Is a loadable Type1 font driver installed?
         // Result can be retrieved through CFontManager::Type1FontDriverInstalled().
         //
         CheckForType1FontDriver();
#endif

         m_Notify.m_hWatch    = FindFirstChangeNotification( szPath, 0, FILE_NOTIFY_CHANGE_FILE_NAME );

         DEBUGMSG( (DM_TRACE2, TEXT( "CFontManager:bInit FindFirstChangeNotification called" ) ) );

         if( m_Notify.m_hWatch != INVALID_HANDLE_VALUE )
         {
              //
              //  Launch a Background thread to keep an eye on it.
              //

              FindNextChangeNotification( m_Notify.m_hWatch );

              DEBUGMSG( (DM_TRACE2, TEXT( "CFontManager:bInit FindNextChangeNotification called - creating Notify thread" ) ) );
              DEBUGMSG( (DM_TRACE2, TEXT( "CFontManager:bInit ChangeNotification Handle = 0x%x" ), m_Notify.m_hWatch ) );
              
              InterlockedIncrement(&g_cRefThisDll);
              m_hNotifyThread = CreateThread( NULL,
                                       0,
                                      (LPTHREAD_START_ROUTINE)dwNotifyWatchProc,
                                      (LPVOID)this,
                                       0,                  // CREATE_NO_WINDOW,
                                       &idThread);
              if (NULL == m_hNotifyThread)
              {
                  InterlockedDecrement(&g_cRefThisDll);
              }
         }
         //
         //  Launch a background process to reconcile any new font files
         //  that have been dropped in the FONTS folder.
         //  Only do this if font list is valid.  Reconciliation requires
         //  that the font list exists.
         //
         vReconcileFolder( THREAD_PRIORITY_LOWEST );
    }

    //
    //  Start a thread that resets the font family information. This thread
    //  is activated by pulsing the m_hEventResetFamily handle. It runs at
    //  the lowest priority unless the main (UI) thread is waiting on it.
    //
    InterlockedIncrement(&g_cRefThisDll);
    m_hResetFamThread = CreateThread(
                                  NULL,
                                  0,
                                  (LPTHREAD_START_ROUTINE)dwResetFamilyFlags,
                                  (LPVOID)this,
                                  0, // CREATE_NO_WINDOW,
                                  &idThread);

    if( m_hResetFamThread )
    {
        SetThreadPriority( m_hResetFamThread, THREAD_PRIORITY_LOWEST );
    }
    else
    {
        InterlockedDecrement(&g_cRefThisDll);
    }

    //
    //  Even if the notify doesn't work, return OK.
    //

    return TRUE;
}


static DWORD dwReconcileThread(LPVOID pvParams)
{
    CFontManager* pFontManager = (CFontManager *)pvParams;
    if (NULL != pFontManager)
    {
        pFontManager->vDoReconcileFolder();
    }
    InterlockedDecrement(&g_cRefThisDll);
    return 0;
}


VOID CFontManager::vReconcileFolder( int iPriority )
{
    DWORD idThread;
    
    ECS;

    //
    //  If one is running reset its priority and return.
    //

    if( m_hReconcileThread )
    {
        SetThreadPriority( m_hReconcileThread, iPriority );
        LCS;
        return;
    }

    //
    //  Always do this in the background, if possible.
    //
    InterlockedIncrement(&g_cRefThisDll);
    m_hReconcileThread = CreateThread(
                                    NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE) dwReconcileThread,
                                    (LPVOID) this,
                                    0,              // CREATE_NO_WINDOW,
                                    &idThread);
    LCS;

    //
    //  At statup we want this to idle in the backgound. Most other times it
    //  runs at normal priority.
    //

    if( m_hReconcileThread )
    {
        SetThreadPriority( m_hReconcileThread, iPriority );
    }
    else
    {
        InterlockedDecrement(&g_cRefThisDll);
        vDoReconcileFolder( );
    }
}


BOOL bValidFOTFile( LPTSTR szFull, LPTSTR szLHS, BOOL *pbTrueType, LPDWORD lpdwStatus = NULL)
{
    LPCTSTR pszExt = PathFindExtension( szFull );

    //
    // Initialize status return.
    //
    if (NULL != lpdwStatus)
       *lpdwStatus = FVS_MAKE_CODE(FVS_INVALID_STATUS, FVS_FILE_UNK);


    if( !pszExt || lstrcmpi( pszExt, TEXT( ".fot" ) ) != 0 )
    {
        if (NULL != lpdwStatus)
            *lpdwStatus = FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);

        return( FALSE );
    }

    FontDesc_t szDesc;

    WORD wType;


    if( !::bCPValidFontFile( szFull, szDesc, &wType, TRUE, lpdwStatus ) )
    {
        return( FALSE );
    }

    *pbTrueType = TRUE;

    wsprintf( szLHS, c_szDescFormat, (LPTSTR) szDesc, c_szTrueType );

    return( TRUE );
}


VOID CFontManager::vDoReconcileFolder( )
{
    HANDLE            hSearch;
    WIN32_FIND_DATA   fData;
    FullPathName_t    szPath;
    FullPathName_t    szWD;
    BOOL              bAdded = FALSE;
    BOOL              bChangeNotifyRequired = FALSE;

#define WANT_DORECONCILEFOLDER
#ifdef  WANT_DORECONCILEFOLDER

    //
    // Load the list of hidden font file names from FONT.INF.
    // This initialization is done here on the background thread
    // so we don't steal cycles from the UI.
    //
    m_HiddenFontFilesList.Initialize();

    GetFontsDirectory( szPath, ARRAYSIZE( szPath ) );

    lstrcat( szPath, TEXT( "\\*.*" ) );

    //
    //  Process each file in the directory.
    //
    //  Reasons for getting here:
    //   - File was installed and the CFontFolder needs to be updated.
    //   - File was copied into Fonts folder, but not installed.
    //

    ///////////////////////////////////////////////////////////////////
    //
    // NOTE: [brianau]
    //
    // There was a condition in the original font folder where not all
    // fonts in a set of manually-added fonts would be installed by the
    // reconciliation process.  Given the following scenario and invariants:
    //
    // Scenario:
    //    Installing a large set of fonts manually with COPY command while
    //    installing a set of fonts through the font folder interface.
    //
    // Invariants:
    //    In response to a file sys change notification, the watch thread
    //    either starts the reconcile thread (if not active) or sets its
    //    priority if already active.
    //    The reconcile loop uses the FindFirstFile/FindNextFile functions
    //    to obtain names of files in the fonts directory.  FindNextFile
    //    returns information on the next file it encounters in the
    //    directory in alphabetical name order.
    //
    // The Problem:
    //    If a font file is being added to the fonts directory while the
    //    FindFirst/FindNext loop is active and it's name is lexically
    //    "less than" the file currently being returned by FindNextFile,
    //    it will be skipped by the FindFirst/FindNext processing and
    //    will not be installed.  Since the file sys notifications arrive
    //    in rapid succession while the reconcile loop is active,  the
    //    loop is never re-started (only thread priority is set).  Therefore,
    //    these missed fonts are never added.  However, they will be
    //    installed the next time the reconcile thread is started.
    //
    // Possible solutions:
    //    Replace the reconcile loop with a single installation function
    //    that is called each time a notification is received via
    //    ReadDirectoryChanges().  ReadDirectoryChangesW() is a new NT
    //    API similar to FindFirstChangeNotification/FindNextChangeNotification
    //    except it returns detailed information about the file that
    //    triggered the change notification.  This would eliminate the
    //    need for scanning the entire directory.
    //
    //    I added the existing "hack" of repeating the loop until no more
    //    fonts can be added.  It's not as clean as the ReadDirectoryChanges()
    //    fix but it works with the existing code.  Since we're on a
    //    background thread, the user won't notice the extra iterations.
    //
    //    I think we should replace this hack with the ReadDirectoryChanges
    //    solution when possible.
    ///////////////////////////////////////////////////////////////////
    do {
        bAdded = FALSE;

        hSearch = FindFirstFile( szPath, &fData );

        if( hSearch != INVALID_HANDLE_VALUE )
        {
            GetFontsDirectory( szWD, ARRAYSIZE( szWD ) );

            //
            //  We can't use Get/SetCurrent directory because we might
            //  hose the main UI thread. Most notably the Common File
            //  Dialog.
            //
            //  GetCurrentDirectory( ARRAYSIZE( szCD ), szCD );
            //  SetCurrentDirectory( szWD );
            //
            do
            {
                //
                // poSearchFontListFile needs a valid m_poFontList.
                //
                ASSERT(NULL != m_poFontList);

                //
                // Wait for mutex so we don't have multiple threads installing
                // fonts concurrently.  Aquire and release mutex for each font.
                // This will minimize blocking time for other waiting threads.
                // Since we're on a background thread, we don't mind waiting
                // a while for the mutex (5 seconds).
                //
                if ( MUTEXWAIT_SUCCESS == dwWaitForInstallationMutex(5000) )
                {
                    //
                    // See if the Font Manager knows about this font. If not,
                    // then install it.
                    //
                    if( fData.cFileName[ 0 ] != TEXT( '.' ) &&
                         !poSearchFontListFile( fData.cFileName ) &&
                         ShouldAutoInstallFile( fData.cFileName, fData.dwFileAttributes ) )
                    {

                        FullPathName_t szFull;
                        FontDesc_t     szLHS;
                        BOOL           bTrueType;
                        WORD           wType;

                        // GetFullPathName( fData.cFileName, ARRAYSIZE( szFull ), szFull, &lpTemp );

                        lstrcpy( szFull, szWD );

                        lpCPBackSlashTerm( szFull );

                        lstrcat( szFull, fData.cFileName );

                        //
                        //  Check to see if this is a valid font file.
                        //  Don't call CPDropInstall() 'cause we don't want any UI
                        //  coming up.
                        //
                        //  bCPDropInstall( m_poFontMan, szFull );
                        //

                        if( ::bCPValidFontFile( szFull, szLHS, &wType )
                               || bValidFOTFile( szFull, szLHS, &bTrueType ) )
                        {
                            //
                            //  Make sure it's not already in the registry, possibly
                            //  from another file
                            //

                            if(wType == TYPE1_FONT)
                            {
                                //
                                //  Check registry font entries under the
                                //  Type 1 Installer
                                //

                                if( !CheckT1Install( szLHS, NULL ) )
                                {
                                    FullPathName_t szPfbFile;

                                    if( IsPSFont( szFull, (LPTSTR) NULL, (LPTSTR) NULL,
                                                  szPfbFile, (BOOL *) NULL) )
                                    {
#ifdef WINNT
                                        if (Type1FontDriverInstalled())
                                        {
                                            TCHAR szType1FontResourceName[MAX_TYPE1_FONT_RESOURCE];

                                            if (BuildType1FontResourceName(
                                                    szFull,
                                                    szPfbFile,
                                                    szType1FontResourceName,
                                                    ARRAYSIZE(szType1FontResourceName)))
                                            {
                                                AddFontResource(szType1FontResourceName);
                                            }
                                        }
#endif // WINNT
                                        if( WriteType1RegistryEntry( NULL, szLHS, szFull,
                                                                     szPfbFile, TRUE ) )
                                        {
                                            bAdded = TRUE;
                                        }
                                    }
                                }
                            }
                            else if( !bRegHasKey( szLHS ) )
                            {
                                if( AddFontResource( fData.cFileName ) )
                                {
                                    if (WriteToRegistry( szLHS, fData.cFileName ))
                                        bAdded = TRUE;
                                    else
                                        RemoveFontResource(fData.cFileName);
                                }
                            }
                        }

                        //
                        //  TODO. Should we remove the file if it isn't a font file or
                        //  shouldn't be in this directory?
                        //
                        //  [stevecat] DO NOT delete extraneous files from this dir
                        //   on WINNT because we recognize .PFM files as the main
                        //   Type 1 file but the matching .PFB file may also be present
                        //   for use by the Postscript printer driver.
                        //
                    }
                    //
                    // Let some other thread install a font.
                    // WARNING:  Don't miss this call with an early return.
                    //           (break, goto, return)
                    //
                    bReleaseInstallationMutex();
               }
               else
               {
                    //
                    // I have yet to see this thread not get the mutex.
                    // But, just in case it doesn't, give up on installing
                    // this font.
                    // Note that we don't inform the user since this is a background
                    // thread that the user isn't aware of.
                    //
               }

           } while( FindNextFile( hSearch, &fData ) );

           // SetCurrentDirectory( szCD );

           FindClose( hSearch );
        }
        //
        // We need to post a font change notification if any fonts
        // have been added.
        //
        bChangeNotifyRequired = bChangeNotifyRequired || bAdded;
    } while (TRUE == bAdded);

#endif

    //
    //  For all practical purposes, we're done.
    //

    ECS;

    if( m_hReconcileThread )
    {
        CloseHandle( m_hReconcileThread );
        m_hReconcileThread = 0;
    }

    LCS;
    
    //
    // Destroy contents of hidden files list.
    // Folder reconciliation is the only time this table is used so
    // we don't need to keep the strings in memory when they're not
    // needed.
    // It will be re-created next time vDoReconcileFolder is called.
    //
    m_HiddenFontFilesList.Destroy();

    if( bChangeNotifyRequired )
        vCPWinIniFontChange( );
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/
VOID CFontManager::ProcessRegKey( HKEY hk, BOOL bCheckDup )
{

    DWORD          i;
    int            idx;
    FontDesc_t     szValue;
    DWORD          dwValue;
    FullPathName_t szData;
    DWORD          dwData;


    for( i = 0; ; ++i )
    {
        dwValue = sizeof( szValue );
        dwData  = sizeof( szData );

        LONG lRet = RegEnumValue( hk, i, szValue, &dwValue,
                                  NULL, NULL, (LPBYTE) szData, &dwData );

        if( lRet == ERROR_MORE_DATA )
        {
            //
            //  I guess I'm just going to skip this guy.
            //  It's mostly invalid anyway
            //

            continue;
        }
        else if (lRet != ERROR_SUCCESS)
        {
            //
            //  I assume this is ERROR_NO_MORE_ITEMS
            //

            break;
        }

        if( szValue[ 0 ] )
        {

            if( bCheckDup )
            {
                if( ( idx = iSearchFontListLHS( szValue ) ) >= 0 )
                {
                    if( m_poTempList )
                    {
                        CFontClass *poFont = m_poFontList->poDetach(idx);
                        m_poTempList->bAdd(poFont);
                        poFont->Release();  // Release from m_poFontList.
                    }


                    continue;
                }
            }

            poAddToList( szValue, szData );
        }
    }
}



#ifdef WINNT
/***************************************************************************
 * METHOD:  ProcessT1RegKey
 *
 * PURPOSE: Crack REG_MULTISZ Type registry value entry and look for dups
 *
 * RETURNS:
 *
 ***************************************************************************/

VOID CFontManager::ProcessT1RegKey( HKEY hk, BOOL bCheckDup )
{
    DWORD          i = 0;
    int            idx;
    TCHAR          szValue[ PATHMAX ];
    DWORD          dwValue = ARRAYSIZE( szValue );
    TCHAR          szData[ 2 * PATHMAX + 10 ];
    DWORD          dwData = sizeof( szData );
    FullPathName_t szPfmFile;
    FullPathName_t szPfbFile;


    while( ERROR_SUCCESS == RegEnumValue( hk, i, szValue, &dwValue, NULL,
                                          NULL, (LPBYTE)szData, &dwData ) )
    {
        if( szValue[ 0 ] )
        {
            if( bCheckDup )
            {
                if( ( idx = iSearchFontListLHS( szValue ) ) >= 0 )
                {
                    if( m_poTempList )
                    {
                        CFontClass *poFont = m_poFontList->poDetach(idx);
                        m_poTempList->bAdd(poFont);
                        poFont->Release();  // Release from m_poFontList.
                    }

                    goto MoveOn;
                }
            }

            //
            //  For Type 1 font entries, extract PFM and PFB font file
            //  names for storage in the class object.
            //

            if( ::ExtractT1Files( szData, szPfmFile, szPfbFile ) )
                poAddToList( szValue, szPfmFile, szPfbFile );
        }
MoveOn:
        //
        //  Move on to the next one.
        //

        dwValue = ARRAYSIZE( szValue );
        dwData  = sizeof( szData );
        i++;
    }
}

#endif  //  WINNT

/***************************************************************************
 * METHOD:  bRefresh
 *
 * PURPOSE: Re-read the win.ini and registry to determine if fonts have
 *          been added.
 *
 *          If we're checking for dups, move them to m_poTempList as we
 *          find them. Then move them back when we're all done.
 *
 * RETURNS:
 *
 ***************************************************************************/
BOOL CFontManager::bRefresh( BOOL bCheckDup )
{
    //
    //  Load the Font List.
    //

    static BOOL  s_bInRefresh = FALSE;
    TCHAR        szFonts[] = TEXT( "FONTS" );
    PTSTR        pszItem;                          // pointer into buffer
    PATHNAME     szPath;
    HANDLE       hLocalBuf;
    PTSTR        pLocalBuf, pEnd;
    DWORD        nCount;
    int          idx;

    //
    //  Don't reenter this puppy. If we're already in here (either this thread
    //  or another) the caller won't be able to get the list until it's
    //  available in a consistent state.
    //

    if( s_bInRefresh )
        return TRUE;

    s_bInRefresh = TRUE;

    //
    //  If we're checking for dups, then allocate the temp list to put them
    //  in. If we can't allocate one, just don't use it.
    //

    if( bCheckDup && !m_poTempList )
    {
        m_poTempList = new CFontList( m_poFontList->iCount( ) );

        if( !(m_poTempList && m_poTempList->bInit( ) ) )
            m_poTempList = 0;
    }

    //
    //  Process the WIN.INI file first.
    //

    nCount = GetSection( NULL, szFonts, &hLocalBuf );

    if( !hLocalBuf )
    {
        iUIErrMemDlg(NULL);
        s_bInRefresh = FALSE;

        return FALSE;
    }

    ECS;

    pLocalBuf = (PTSTR) LocalLock( hLocalBuf );

    pEnd = pLocalBuf + nCount;

    //
    //  Add all the fonts in the list, if they haven't been added already
    //

    for( pszItem = pLocalBuf; pszItem < pEnd; pszItem += lstrlen( pszItem )+1 )
    {
        if( !*pszItem )
            continue;

        if( bCheckDup )
        {
            if( ( idx = iSearchFontListLHS( pszItem ) ) >= 0 )
            {
                if( m_poTempList )
                {
                    CFontClass *poFont = m_poFontList->poDetach(idx);
                    m_poTempList->bAdd(poFont);
                    poFont->Release(); // Release from m_poFontList.
                }
                continue;
            }
        }

        GetProfileString( szFonts, pszItem, TEXT( "" ), szPath,
                          ARRAYSIZE( szPath ) );

        //
        //  there's a RHS here
        //

        if( *szPath )
        {
            poAddToList( pszItem, szPath, NULL );
        }
    }

    LocalUnlock( hLocalBuf );

    LocalFree  (hLocalBuf );

    //
    //  Now, process the entries in the Registry. There are two locations:
    //  one that holds the display fonts and one that holds the TT fonts.
    //

    HKEY     hk;


#ifndef WINNT

    //
    // [stevecat] 7/10/95 NT does not yet support HKEY_CURRENT_CONFIG
    //                    and won't until Plug N Play fills in that
    //                    part of the registry.
    //

    if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_CONFIG, s_szKey2,
                                       0, KEY_READ, &hk ) )
    {
        ProcessRegKey( hk, bCheckDup );
        RegCloseKey( hk );
    }


    if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_szKey1, 0,
                                       KEY_READ, &hk ) )
    {
//
// [stevecat] Test code to remove font duplications in FontView list
//

#ifdef WINNT
        //
        //  Since WinNT performs .INI file mapping we must always
        //  set the "Check duplicates" flag or else we will get a
        //  double display of list view items.
        //

//
//  This doesn't seem to be working because the CheckDup code is seeing
//  the source dirs of the fonts as different if they come from Win.ini
//  verses the Registry.
//

        ProcessRegKey( hk, TRUE );

#else  //  WINNT

        ProcessRegKey( hk, bCheckDup );

#endif  //  WINNT

        RegCloseKey( hk );
    }

#endif  // ifndef WINNT


#ifdef WINNT
    //
    //  Process Type 1 fonts registry location
    //

    if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, g_szType1Key, 0,
                                       KEY_READ, &hk ) )
    {
        ProcessT1RegKey( hk, bCheckDup );
        RegCloseKey( hk );
    }
#endif  //  WINNT

    //
    //  If we put some things in m_poTempList, put them back in the main list.
    //

    if( m_poTempList )
    {
        int iCount = m_poTempList->iCount( );
        int i;

        for( i = iCount - 1; i >= 0; i-- )
        {
            CFontClass *poFont = m_poTempList->poDetach(i);
            m_poFontList->bAdd(poFont);
            poFont->Release(); // Release from m_poTempList.
        }
    }

    LCS;

    //
    //  Reset the family connections.
    //

    vResetFamilyFlags( );

    s_bInRefresh = FALSE;

    return TRUE;
}


/*************************************************************************
 * METHOD:  vToBeRemoved
 *
 * PURPOSE: Set the TBR list to poList. The font manager owns the list at
 *          this point. If there is already a TBR list, then this one is
 *          merged with the current one and deleted.
 *
 * RETURNS: Nothing.
 *************************************************************************/

void CFontManager::vToBeRemoved( CFontList * poList )
{
    int   iCount;
    int   i;

    CFontClass * poFont;

    //
    //  Quick check for valid pointer.
    //
    if( !poList )
       return;

    ECS;

    //
    //  Make sure the objects aren't in the main list. Merge into the current
    //  list, if there is one, simultaneously.
    //

    iCount = poList->iCount( );

    if( !iCount )
       goto done;

    for( i = 0; i < iCount; i++ )
    {
        poFont = poList->poObjectAt( i );

        if (NULL != m_poFontList->poDetach( poFont ))
            poFont->Release();

        if( m_poRemoveList )
            m_poRemoveList->bAdd( poFont );
    }

    if( !m_poRemoveList )
        m_poRemoveList = poList;
    else
        delete poList;

done:
    LCS;
}


/*************************************************************************
 * METHOD:  bCheckTBR( )
 *
 * PURPOSE: Check the To Be Removed list. Any files that no longer exist
 *          will be uninstalled.
 *
 * RETURNS: TRUE if something was removed.
 *************************************************************************/
BOOL  CFontManager::bCheckTBR( )
{
    int            iCount,
                   i;
    FullPathName_t szPath;
    BOOL           bRet = FALSE;
    CFontClass * poFont;

    //
    //  Quick return.
    //

    if( !m_poRemoveList )
        return bRet;

    ECS;

    //
    //  Walk the list and check for files that no longer exist and remove them.
    //

    iCount = m_poRemoveList->iCount( );
 
    for( i = iCount - 1; i >= 0; i-- )
    {
        poFont = m_poRemoveList->poObjectAt( i );

        poFont->bGetFQName( szPath, ARRAYSIZE( szPath ) );

        if( GetFileAttributes( szPath ) == 0xffffffff )
        {
            m_poRemoveList->poDetach( i );

            //
            //  Make sure it is no longer in the registry.
            //

            poFont->bRFR( );

            vDeleteFont( poFont, FALSE );

            bRet = TRUE;
       }
    }

    //
    //  If there's nothing left in here, delete the list.
    //

    if(  !m_poRemoveList->iCount( ) )
    {
        delete m_poRemoveList;
        m_poRemoveList = 0;
    }

    LCS;

    //
    //  Notify everyone that the font world has changed.
    //

    if( !m_poRemoveList )
        vCPWinIniFontChange( );

    return bRet;
}


/*************************************************************************
 * METHOD:  vUndoTBR( )
 *
 * PURPOSE: Undo the To Be Removed list. This usually happens when something
 *          has gone wrong with a delete operation.
 *
 * RETURNS: Nothing.
 *************************************************************************/

void CFontManager::vUndoTBR( )
{
    int   iCount;
    int   i;
    CFontClass *   poFont;

    //
    //  Try once more and quick return.
    //

    bCheckTBR( );

    if( !m_poRemoveList )
       return;

    ECS;

    //
    //  Put anything in the list back into the main list.
    //

    if( m_poRemoveList )
    {
        iCount = m_poRemoveList->iCount( );

        for( i = (iCount-1); i >= 0; i-- )
        {
            poFont = m_poRemoveList->poObjectAt( i );

            //
            //  If we can add the item back into GDI, do so
            //

            if( poFont->bAFR( ) )
            {
                m_poRemoveList->poDetach( i );
                m_poFontList->bAdd( poFont );
            }
        }

        //
        //  Delete the list.
        //

        if( !m_poRemoveList->iCount( ) )
        {
            delete m_poRemoveList;
            m_poRemoveList = 0;
        }
    }

    LCS;

    //
    //  Notify everyone that the font world has changed.
    //

    if( !m_poRemoveList )
        vCPWinIniFontChange( );

}


/*************************************************************************
 * METHOD:  vVerifyList( )
 *
 * PURPOSE: Validate the entries in the list.
 *
 * RETURNS: Nothing.
 *************************************************************************/

void CFontManager::vVerifyList( )
{
    int            iCount,
                   i;
    CFontList    * poList = 0;
    FullPathName_t szPath;
    CFontClass   * poFont;

    //
    //  Quick return;
    //

    if( !m_poFontList )
        return;

    ECS;

    //
    //  Walk the list and any files that don't reference valid files.
    //

    iCount = m_poFontList->iCount( );

    for( i = iCount - 1; i >= 0; i--)
    {
        poFont = m_poFontList->poObjectAt( i );

        //
        //  Only look at something that is in the FONTS folder or on the
        //  same drive( TODO ) as the Windows directory.
        //

        if( poFont->bOnSysDir( ) )
        {
            poFont->bGetFQName( szPath, ARRAYSIZE( szPath ) );

            if( GetFileAttributes( szPath ) == 0xffffffff )
            {
                //
                //  Allocate the list if necessary.
                //

                if( !poList )
                {
                    poList = new CFontList( 50 );
                    if (poList)
                    {
                        if (!poList->bInit())
                        {
                            delete poList;
                            poList = NULL;
                        }
                    }
                }
                if (!poList)
                    break;

                poList->bAdd( poFont );
                poFont = m_poFontList->poDetach( i );
                if (NULL != poFont)
                    poFont->Release();
            }
        }
    }

    //
    //  Set the list up to be removed. This will happen in a background
    //  thread.
    //

    if( poList )
       vToBeRemoved( poList );

    LCS;
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

void CFontManager::vGetFamily( CFontClass * lpFontRec, CFontList * poList )
{
    int   iCount = m_poFontList->iCount( );
    WORD  wFam   = lpFontRec->wGetFamIndex( );

    while( iCount--)
    {
       lpFontRec = m_poFontList->poObjectAt( iCount );

       if( lpFontRec && ( wFam == lpFontRec->wGetFamIndex( ) ) )
          poList->bAdd( lpFontRec );
    }
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

BOOL CFontManager::bLoadFontList( )
{
    BOOL  bRet = FALSE;

    ECS;

    if( m_poFontList )
    {
        bRet = TRUE;
        goto done;
    }

    //
    //  Allocate a list for 220 fonts (with the default bucket size) and
    //  64 directory entries.
    //

    m_poFontList = new CFontList( 220 );

    if( !m_poFontList )
    {
        goto done;
    }

    //
    //  Initialize them. The bInit() function will delete them if it fails.
    //

    if( !m_poFontList->bInit( ) )
    {
        m_poFontList = 0;
        goto done;
    }

    bRet = bRefresh( FALSE );

    //
    //  Verify the list.
    //

    vVerifyList( );

done:
    LCS;

    return bRet;
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

CFontClass * CFontManager::poAddToList( LPTSTR lpDesc,      //  Font desc
                                        LPTSTR lpPath,      //  Primary font file
                                        LPTSTR lpCompFile ) //  Companion font file
{
    BOOL         bSuccess = FALSE;
    CFontClass * poFont   = new CFontClass;


    if( !poFont )
       return 0;

    if( bSuccess = poFont->bInit( lpDesc, lpPath, lpCompFile ) )
    {
        ECS;

        bSuccess = m_poFontList->bAdd( poFont );

        LCS;

        if( !bSuccess )
            delete poFont;
    }

    if(  !bSuccess )
    {
        poFont = NULL;
    }

    return poFont;
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

CFontList * CFontManager::poLockFontList( )
{
    if( bLoadFontList( ) )
    {
       DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "CFontManager: EnterCriticalSection in poLockFontList()  " ) ) );

       ECS;

       return m_poFontList;
    }

    return 0;
}


void CFontManager::vReleaseFontList( )
{
    LCS;
    DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "CFontManager: LeaveCriticalSection in vReleaseFontList()  " ) ) );
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

int CFontManager::GetSection( LPTSTR lpFile, LPTSTR lpSection, LPHANDLE hSection )
{
    ULONG  nCount;
    ULONG  nSize;
    HANDLE hLocal, hTemp;
    TCHAR *pszSect;


    if( !(hLocal = LocalAlloc( LMEM_MOVEABLE, nSize = 8192 ) ) )
        return( 0 );

    //
    //  Now that a buffer exists, Enumerate all LHS of the section.  If the
    //  buffer overflows, reallocate it and try again.
    //

    do
    {
        pszSect = (PTSTR) LocalLock( hLocal );

        if( lpFile )
            nCount = GetPrivateProfileString( lpSection, NULL, TEXT( "" ),
                                              pszSect, nSize / sizeof( TCHAR ),
                                              lpFile );
        else
            nCount = GetProfileString( lpSection, NULL, TEXT( "" ), pszSect,
                                       nSize / sizeof( TCHAR ) );

        LocalUnlock( hLocal );

        if( nCount != ( nSize / sizeof( TCHAR ) ) - 2 )
            break;

        nSize += 4096;

        if( !(hLocal = LocalReAlloc( hTemp = hLocal, nSize, LMEM_MOVEABLE ) ) )
        {
            LocalFree( hTemp );
            return( 0 );
        }
    } while( 1 ) ;

    *hSection = hLocal;

    return( nCount );
}


/***************************************************************************
 * METHOD:  GetFontsDirectory
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

int CFontManager::GetFontsDirectory( LPTSTR lpDir, int iLen )
{
    return ::GetFontsDirectory( lpDir, iLen );
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION: CFontManager::dwWaitForInstallationMutex
//
//  DESCRIP: Block until installation mutex is available.
//           Thread input messages are handled during wait.
//
//ARGUMENTS: dwTimeout
//              Number of milliseconds to wait for mutex.
//              The default is 2,000 ( 2 seconds ).
//
//  RETURNS: MUTEXWAIT_SUCCESS  = Obtained mutex either via release or abandonment.
//           MUTEXWAIT_WMQUIT   = Received a WM_QUIT message while waiting.
//                                  Caller should automatically cancel operation.
//           MUTEXWAIT_TIMEOUT  = Wait timed out.
//                                  Caller can retry or cancel operation.
//           MUTEXWAIT_FAILED   = Wait failure.
//                                  Shouldn't happen.  Caller should retry/cancel.
//////////////////////////////////////////////////////////////////////////////
DWORD CFontManager::dwWaitForInstallationMutex(DWORD dwTimeout)
{
    DWORD dwWaitResult = 0;                 // Wait result.
    DWORD dwResult     = MUTEXWAIT_SUCCESS; // Return code.

    if (NULL != m_hMutexInstallation)
    {
        //
        // Repeat this loop until one of the following occurs:
        //    1. We aquire the installation mutex.
        //    2. Mutex is abandoned by owner thread.
        //    3. Mutex wait times out.
        //    4. Mutex wait results in error.
        //    5. Receive a WM_QUIT message while waiting.
        //
        do
        {
            //
            // Note:  Don't handle posted messages.  The folder posts an IDM_IDLE message
            //        to the font install dialog every 2 seconds for filling in the font
            //        name list.  This message will satisfy the wait and mess up the
            //        timeout processing.  The (~QS_POSTMESSAGE) prevents this.
            //
            dwWaitResult = MsgWaitForMultipleObjects(1,
                                                     &m_hMutexInstallation,
                                                     FALSE,
                                                     dwTimeout,
                                                     QS_ALLINPUT & (~QS_POSTMESSAGE));
            switch(dwWaitResult)
            {
                case WAIT_OBJECT_0 + 1:
                {
                    MSG msg ;
                    //
                    // Allow blocked thread to respond to sent messages.
                    //
                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                    {
                        if ( WM_QUIT != msg.message )
                        {
                            TranslateMessage(&msg);
                            DispatchMessage(&msg);
                        }
                        else
                        {
                            dwResult     = MUTEXWAIT_WMQUIT;
                            dwWaitResult = WAIT_FAILED;
                        }
                    }
                    break;
                }

                case WAIT_OBJECT_0:
                case WAIT_ABANDONED_0:
                    DEBUGMSG((DM_TRACE1, TEXT("Thread 0x%08x: HAS install mutex."), GetCurrentThread()));
                    dwResult = MUTEXWAIT_SUCCESS;
                    break;

                case WAIT_TIMEOUT:
                    DEBUGMSG((DM_TRACE1, TEXT("Thread 0x%08X: TIMEOUT waiting for install mutex."), GetCurrentThread()));
                    dwResult = MUTEXWAIT_TIMEOUT;
                    break;

                case WAIT_FAILED:
                default:
                    dwResult = MUTEXWAIT_FAILED;
                    break;
            }
        } while( (WAIT_OBJECT_0 + 1) == dwWaitResult );
    }
    return dwResult;
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION: CFontManager::bReleaseInstallationMutex
//
//  DESCRIP: Release ownership of the installation mutex.
//
//  RETURNS: TRUE  = Thread owned the mutex and it was released.
//           FALSE = Thread did not own the mutex or it couldn't be released.
//////////////////////////////////////////////////////////////////////////////
BOOL CFontManager::bReleaseInstallationMutex(void)
{
    BOOL bStatus = FALSE;

    if (NULL != m_hMutexInstallation)
    {
        DEBUGMSG((DM_TRACE1, TEXT("Thread 0x%08x: RELEASED install mutex."), GetCurrentThread()));
        bStatus = ReleaseMutex(m_hMutexInstallation);
    }

    return bStatus;
}


///////////////////////////////////////////////////////////////////////////////
//  NOTE: [brianau]
//
//  The following functions iSuspendNotify() and iResumeNotify() have been
//  superceded by dwWaitForInstallationMutex() and bReleaseInstallationMutex().
//  The original intent of the Suspend and Resume functions was to prevent
//  problems between the main folder thread and the folder reconciliation thread
//  installing fonts concurrently.  However, merely suspending the file system
//  notification watch thread is not sufficient to prevent concurrency problems.
//  Because of file-scope and global data used in the font folder and Type 1
//  installer code, the installation code path must be treated like a critical
//  section and guarded by a thread synchronization object such as a Mutex.
//  The functions dwWaitForInstallationMutex() and bReleaseInstallationMutex()
//  provide ownership control of this synchronization object.
//
//  The original code has been retained for documentation purposes.
//
///////////////////////////////////////////////////////////////////////////////
#if 0

int CFontManager::iSuspendNotify( )
{
    DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "CFontManager: iSuspendNotify called" ) ) );

    if( !m_iSuspendNotify )
    {
        DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "CFontManager: iSuspendNotify thread being suspended" ) ) );
        SuspendThread( m_hNotifyThread );
    }

    m_iSuspendNotify++;

    return m_iSuspendNotify;
}


int CFontManager::iResumeNotify( )
{
    DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "CFontManager: iResumeNotify called" ) ) );

    if( m_iSuspendNotify )
        m_iSuspendNotify--;

    if( !m_iSuspendNotify )
    {
        DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "CFontManager: iResumeNotify thread being resumed" ) ) );
        ResumeThread( m_hNotifyThread );
    }

    return m_iSuspendNotify;
}

#endif

//
// Wait until the family-reset mutex is available.  Also returns
// if the "terminate-threads" event is set, meaning that it's time
// to shut down the folder.
// Returns:
//    TRUE  = Obtained the mutex.  OK to proceed.
//    FALSE = Terminate-threads was signaled.  We don't necessarily
//            own the mutex.  Don't proceed.  Return asap.
//
BOOL CFontManager::bWaitOnFamilyReset( )
{
    //
    //  Set the thread to Highest priority until we get the mutex,
    //  which means the thread is done.
    //
    DWORD dwWait;
    BOOL bResult = FALSE;
    BOOL bDone = FALSE;
    HANDLE rgHandles[] = { m_hEventTerminateThreads,
                           m_hMutexResetFamily };
                           
    if( m_hResetFamThread )
        SetThreadPriority( m_hResetFamThread, THREAD_PRIORITY_HIGHEST );

    //
    // This is called on the UI thread.  Must be able to handle
    // sent thread messages.
    //
    do
    {
        dwWait = MsgWaitForMultipleObjects(ARRAYSIZE(rgHandles),
                                           rgHandles,
                                           FALSE,
                                           INFINITE,
                                           QS_ALLINPUT & (~QS_POSTMESSAGE));
                                           
        if (WAIT_OBJECT_0 + ARRAYSIZE(rgHandles) == dwWait)
        {
            MSG msg ;
            //
            // Allow blocked thread to respond to sent messages.
            //
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if ( WM_QUIT != msg.message )
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
                else
                {
                    dwWait = 0; // Rcvd WM_QUIT. Exit loop.
                }
            }
        }
        else if (0 == (dwWait - WAIT_OBJECT_0))
        {
            //
            // Terminate-threads event was set.
            //
            bDone = TRUE;
        }
        else if (1 == (dwWait - WAIT_OBJECT_0))
        {
            //
            // Got the mutex.
            //
            if( m_hResetFamThread )
                SetThreadPriority( m_hResetFamThread, THREAD_PRIORITY_LOWEST );
            
            bResult = TRUE;
            bDone   = TRUE;
        }            
    }
    while(!bDone);
    //
    // Always release the mutex before returning.
    // Even if the wait was satisfied by the "terminate" event this
    // will ensure we don't hold the mutex.  If we don't own it this call
    // will harmlessly fail.
    //
    ReleaseMutex( m_hMutexResetFamily );
    
    return bResult;
}


/***************************************************************************
 * METHOD:  dwResetFamilyFlags
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

DWORD dwResetFamilyFlags(LPVOID pvParams)
{
    CFontManager *pFontManager = (CFontManager *)pvParams;

    if (NULL != pFontManager)
    {
        BOOL bDone = FALSE;
        HANDLE rghObj[] = { pFontManager->m_hMutexResetFamily,
                            pFontManager->m_hEventResetFamily };

        while(!bDone)
        {
            //
            //  Wait for the FONTS folder to change. If we time out, then attempt
            //  to undo any deletions that might be occuring.
            //  Note that the CFontManager dtor will set both the reset-family
            //  event and the terminate-threads event.  This way we'll be sure
            //  to terminate this thread when it's time to shut down.
            //                      
            WaitForMultipleObjects(ARRAYSIZE(rghObj), 
                                   rghObj, 
                                   TRUE, 
                                   INFINITE);

            ResetEvent(pFontManager->m_hEventResetFamily);
            //
            // We got the OK to reset the family flags.  Now let's check
            // the "terminate-threads" event.  If it's set then it's time to
            // go home.
            //
            if (WAIT_OBJECT_0 == WaitForSingleObject(pFontManager->m_hEventTerminateThreads, 0))
            {
                bDone = true;
            }
            else
            {
                pFontManager->vDoResetFamilyFlags( );
            }
            //
            //  Release the mutex. The event was already reset by the
            //  PulseEvent
            //
            ReleaseMutex(pFontManager->m_hMutexResetFamily );
        }
    }

    InterlockedDecrement(&g_cRefThisDll);
    return 0;
}


/***************************************************************************
 * METHOD:  vResetFamilyFlags
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

void CFontManager::vResetFamilyFlags( )
{
    SetEvent( m_hEventResetFamily );
}


/***************************************************************************
 * METHOD:  vDoResetFamilyFlags
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

void CFontManager::vDoResetFamilyFlags( )
{
    /* static */ WORD   s_wIdx = 0;

    CFontClass * poFont;
    CFontClass * poFont2;

    if( !m_poFontList )
        return;


    ECS;

restart:
    int iCount = m_poFontList->iCount( );

    //
    //  It would be nice to walk the list and only set the values that aren't
    //  set to IDX_NULL. However, this doesn't work if the main font for
    //  a family is deleted.
    //

    for( int i = 0; i < iCount; i++ )
    {
        m_poFontList->poObjectAt( i )->vSetFamIndex( IDX_NULL );
    }

    //
    //  Release for a sec.
    //

    LCS;

    Sleep( 0 );

    ECS;

    iCount = m_poFontList->iCount( );

    for( i = 0; i < iCount; i++)
    {
        poFont = m_poFontList->poObjectAt( i );

        if( poFont->wGetFamIndex( ) == IDX_NULL )
        {
            //
            //  Set the index and get the name.
            //

            poFont->vSetFamIndex( s_wIdx );
            poFont->vSetFamilyFont( );

            //
            //  Everything up to here already has an index.
            //

            for( int j = i + 1; j < iCount; j++ )
            {
                poFont2 = m_poFontList->poObjectAt( j );

                if( poFont2->bSameFamily( poFont ) )
                {
                    poFont2->vSetFamIndex( s_wIdx );
                    poFont2->vSetNoFamilyFont( );

#ifdef WINNT
                    //
                    //  A Type1 cannot supercede as "head of the family".
                    //  If two non-Type1 fonts are competing for
                    //  "head of the family", the one with the "more regular"
                    //  style wins.  Lesser style values are "more regular".
                    //  This could be one boolean expression but I think the
                    //  nested "ifs" are more readable.
                    //
                    if ( !poFont2->bType1() )
                    {
                        if ( poFont->bType1() ||
                            (poFont2->dwStyle() < poFont->dwStyle()) )
                        {
                            poFont2->vSetFamilyFont( );
                            poFont->vSetNoFamilyFont( );

                            //
                            //  Use the new one as the main family font.
                            //
                            poFont = poFont2;
                        }
                    }
#else
                    //
                    // A smaller style value indicates a more Regular style.
                    //
                    if ( poFont2->dwStyle( ) < poFont->dwStyle( ) )
                    {
                        poFont2->vSetFamilyFont( );
                        poFont->vSetNoFamilyFont( );

                        //
                        //  Use the new one as the main family font.
                        //

                        poFont = poFont2;
                    }
#endif // WINNT
                }
            }

            s_wIdx++;

        }

        //
        //  If the main thread isn't waiting for us. Let go of the
        //  Critical_Section for a moment.
        //

        LCS;

        Sleep( 0 );

        ECS;

        //
        //  If the list has changed while we were gone, start over. We could
        //  just recurse and exit, but the combination of ECS/LCS and stack
        //  could mess us up.
        //

        if( iCount != m_poFontList->iCount( ) )
        {
            goto restart;
        }
    }

    m_bFamiliesNeverReset = FALSE;

    LCS;
}


/***************************************************************************
 * METHOD:  iSearchFontListFile
 *
 * PURPOSE: Search the list of fonts to see if the file is represented.
 *
 * RETURNS: the index or (-1)
 *
 ***************************************************************************/

int   CFontManager::iSearchFontListFile( PTSTR pszFile )
{
    //
    //  This function assumes the file is in the Fonts directory.
    //  This shortcoming will be rectified if necessary.
    //

    CFontClass* poFont = 0;
    int iCount = poLockFontList()->iCount();
    int i;
    int iRet = (-1);

    if( pszFile == NULL ) return NULL;

    for( i = 0; i < iCount; i++ )
    {
        poFont = m_poFontList->poObjectAt( i );

        if( poFont->bSameFileName( pszFile ) )
        {
            iRet = i;
            break;
        }
    }

    vReleaseFontList( );

    return iRet;
}


/***************************************************************************
 * METHOD:  poSearchFontListFile
 *
 * PURPOSE: Search the list of fonts to see if the file is represented.
 *
 * RETURNS: The object or NULL
 *
 ***************************************************************************/

CFontClass * CFontManager::poSearchFontListFile( PTSTR pszFile )
{
    return m_poFontList->poObjectAt( iSearchFontListFile( pszFile ) );
}


/***************************************************************************
 * METHOD:  ShouldAutoInstallFile
 *
 * PURPOSE: TRUE  = Install this file from reconciliation thread.
 *          FALSE = Don't install this file on reconciliation thread.
 *
 ***************************************************************************/

//
// Extensions of font files that should be excluded from auto-installation.
// This list includes AFM and INF because the reconciliation thread doesn't
// know how to build a PFM from an AFM/INF pair.  That function also displays
// a UI which we also don't want on the reconciliation thread.  To install
// a Type1 font on the reconciliation thread, the PFM and PFB files have to
// be copied to the fonts folder.
//
LPCTSTR c_pszExcludeThese[] = {TEXT("TTE"),
                               TEXT("AFM"),
                               TEXT("INF"),
                               NULL};


BOOL CFontManager::ShouldAutoInstallFile( PTSTR pszFile, DWORD dwAttribs )
{
    LPTSTR pszExt = NULL;

    //
    // If the file is hidden, don't auto install it.
    //
    if( dwAttribs & FILE_ATTRIBUTE_HIDDEN || m_HiddenFontFilesList.Exists(pszFile))
        return FALSE;

    pszExt = PathFindExtension( pszFile );

    if( pszExt && *pszExt )
    {
        pszExt++;

        for (UINT i = 0; NULL != c_pszExcludeThese[i]; i++)
        {
            if (0 == lstrcmpi(c_pszExcludeThese[i], pszExt))
            {
                //
                // If the file's extension is in the list of excluded
                // extensions, don't install it.
                //
                return FALSE;
            }
        }
    }

    return TRUE;
}


/***************************************************************************
 * METHOD:  iSearchFontListLHS
 *
 * PURPOSE: Search the list of fonts for the description.
 *
 * RETURNS: the font object or NULL.
 *
 ***************************************************************************/

int  CFontManager::iSearchFontListLHS( PTSTR pszLHS )
{
    CFontClass* poFont = 0;
    int iCount = poLockFontList()->iCount();
    int i;
    int iRet = (-1);


    if( pszLHS == NULL ) return NULL;

    for( i = 0; i < iCount; i++ )
    {
        poFont = m_poFontList->poObjectAt( i );

        if( poFont->bSameDesc( pszLHS ) )
        {
            iRet = i;
            break;
        }
    }

    vReleaseFontList( );

    return iRet;
}


/***************************************************************************
 * METHOD:  poSearchFontListLHS
 *
 * PURPOSE: Search the list of fonts for the description.
 *
 * RETURNS: the font object or NULL.
 *
 ***************************************************************************/

CFontClass * CFontManager::poSearchFontListLHS( PTSTR pszLHS )
{
    return m_poFontList->poObjectAt( iSearchFontListLHS( pszLHS ) );
}


/***************************************************************************
 * FUNCTION: iSearchFontList
 *
 * PURPOSE:  Search the FONTLIST for a face name.
 *
 * RETURNS:  index of item, or (-1)
 ***************************************************************************/

int CFontManager::iSearchFontList( PTSTR pszTarget, BOOL bExact, int iType )
{
    CFontClass* poFont = 0;
    int iCount;
    int i;

    if( pszTarget == NULL ) return( -1 );

    ECS;

    iCount = m_poFontList->iCount();

    for( i = 0; i < iCount; i++ ) {
       poFont = m_poFontList->poObjectAt( i );
       if( poFont->bSameName( pszTarget ) ) {
          LCS;
          return i;
       }
    }

    //
    //  If we didn't find a name, and bExact == FALSE, then look for anything
    //  with an overlap.
    //

    if( !bExact )
    {
        for( i = 0; i < iCount; i++ )
        {
            poFont = m_poFontList->poObjectAt( i );

            if( poFont->bNameOverlap( pszTarget ) )
            {
                if( ( iType == kSearchTT ) && !(poFont->bTrueType( ) || poFont->bOpenType( )))
                    continue;

                if( ( iType == kSearchNotTT ) && (poFont->bTrueType( ) || poFont->bOpenType( )))
                    continue;

                LCS;

                return i;
            }
        }
    }

    LCS;

    //
    //  No Match.
    //

    return( -1 );
}


/***************************************************************************
 * FUNCTION: lpDBSearchFontList
 *
 * PURPOSE:  Search the FONTLIST for a face name.
 *
 * RETURNS:  FontClass* if found, NULL if not.
 ***************************************************************************/

CFontClass* CFontManager::poSearchFontList( PTSTR pszTarget, BOOL bExact, int iType )
{
    return m_poFontList->poObjectAt( iSearchFontList( pszTarget, bExact, iType ) );
}


#if 0
/***************************************************************************
 * METHOD:  eFont
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/
typedef struct {
    HDC   hDC;
    CFontManager * poFontMan;
    WORD  wFamIdx;
    CFontList * poSrcList;
    CFontList * poDstList;
} LENUMFAM;


static int CALLBACK eFont( LPLOGFONT    lpLogFont,
                           LPTEXTMETRIC lpTextMetric,
                           int          iFontType,
                           LPARAM       lFontEnum )
{
    LENUMFAM * lef = (LENUMFAM *) lFontEnum;
    ENUMLOGFONT FAR * lpEnum = (ENUMLOGFONT FAR *) lpLogFont;
    CFontManager * poFontMan = lef->poFontMan;
    CFontClass * poFont ;

    if( iFontType == TRUETYPE_FONTTYPE )
    {
        poFont = poFontMan->poSearchFontList( (PTSTR)lpEnum->elfFullName );

//      DEBUGMSG( (DM_TRACE1, TEXT( "eFont: Couldn't find find %s" ), lpEnum->elfFullName ) );

        if( !poFont )
        {
            //
            //  We didn't get the font based on full name. Try combinining the
            //  full name and the style.
            //

            TCHAR szCombine[ LF_FULLFACESIZE + LF_FACESIZE + 1 ];

            strcpy( szCombine, (LPTSTR) lpEnum->elfFullName );
            strcat( szCombine, TEXT( " " ) );
            strcat( szCombine, (LPTSTR) lpEnum->elfStyle );

            poFont = poFontMan->poSearchFontList( szCombine );

            if( !poFont )
            {
                DEBUGMSG( (DM_TRACE1, TEXT( "eFont: Couldn't find find %s" ),
                          szCombine ) );
            }
        }
    }
    else
    {
        //
        //  In order to handle WIN.INI entries of the form:
        //    "name 8,10,12 = fontfile"
        //  We look at partial overlapping names. Exclude TT files. If
        //  the WIN.INI has been hand-edited, you're out of luck.
        //

        poFont = poFontMan->poSearchFontList( (PTSTR) lpLogFont->lfFaceName,
                                              FALSE, kSearchNotTT );

    }

    if( poFont )
    {
        poFont->vSetFamName( lpLogFont->lfFaceName );
        poFont->vSetFamIndex( lef->wFamIdx );

        poFont->m_wWeight    = (WORD) lpLogFont->lfWeight;
        poFont->m_fSymbol    = (lpLogFont->lfCharSet == SYMBOL_CHARSET );
        poFont->m_fItalic    = (lpLogFont->lfItalic != 0);
        poFont->m_fUnderline = (lpLogFont->lfUnderline != 0);
        poFont->m_fStrikeout = (lpLogFont->lfStrikeOut != 0);

        //
        //  Move this into the temp list. It will be moved back when we're
        //  done enumerating.
        //

        if( lef->poDstList && lef->poDstList->bAdd( poFont ) )
            lef->poSrcList->poDetach( poFont );
    }

    return 1;
}


/***************************************************************************
 * METHOD:  eAllFamilies
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

static int CALLBACK eAllFamilies( LPLOGFONT     lpLogFont,
                                  LPTEXTMETRIC  lpTextMetric,
                                  int           iFontType,
                                  LPARAM        lEnumFam )
{
    LENUMFAM * lef = (LENUMFAM *)lEnumFam;
    int iSearchType = ( (iFontType == TRUETYPE_FONTTYPE) ? kSearchTT : kSearchNotTT );


    //
    //  Try to set a font as the primary font for this family..
    //

    CFontClass * poFont = lef->poFontMan->poSearchFontList(
                                                        lpLogFont->lfFaceName,
                                                        FALSE, iSearchType );

    if( poFont )
        poFont->vSetFamilyFont( );

    //
    //  Enumerate all the fonts within this family.
    //

    EnumFontFamilies( lef->hDC,
                      lpLogFont->lfFaceName,
                      (FONTENUMPROC) eFont,
                      (LPARAM) lEnumFam );

    //
    //  Increment the family index counter.
    //

    lef->wFamIdx++;

    return 1;
}


/***************************************************************************
 * METHOD:  bLoadFamList
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/
BOOL CFontManager::bLoadFamList( )
{
    HWND  hWnd = GetDesktopWindow( );

    if( hWnd )
    {
        HDC   hDC = GetWindowDC( hWnd );

        if( hDC )
        {
            LENUMFAM lef;

            ECS;

            lef.hDC       = hDC;
            lef.poFontMan = this;
            lef.wFamIdx   = 1;
            lef.poSrcList = m_poFontList;
            lef.poDstList = m_poTempList;

            EnumFontFamilies( hDC, NULL, (FONTENUMPROC) eAllFamilies,
                              (LPARAM) &lef );

            ReleaseDC( hWnd, hDC );

            //
            //  If anything was moved into the temp list, move it back.
            //

            if( m_poTempList )
            {
                int iCount = m_poTempList->iCount();
                int i;

                for( i = iCount - 1; i >= 0; i-- )
                    m_poFontList->bAdd( m_poTempList->poDetach( i ) );
            }

            LCS;

            return TRUE;
        }
    }

    return FALSE;
}
#endif


/***************************************************************************
 * METHOD:  vDeleteFontList
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

void CFontManager::vDeleteFontList( CFontList * poList, BOOL bDelete )
{
    //
    //  Build up NULL delimited, NULL-terminated buffer to hand to
    //  SHFileOperations(). Any files that are links (not in the fonts
    //  directory) are not part of this -- we just remove their reference
    //  in WIN.INI
    //

    int            iCount = poList->iCount();
    FullPathName_t szPath;
    int            iBufSize = 1; // 1 for double-nul terminator.
    CFontClass *   poFont;
    int            i;


    if( !bDelete )
        goto uninstall;

    //
    //  Count the amount of memory we need. While we're at it, remove
    //  the font from GDI
    //

    for( i = 0; i < iCount; i++ )
    {
        poFont = poList->poObjectAt( i );

        if( poFont->bGetFileToDel( szPath ) )
        {
            iBufSize += lstrlen( szPath ) + 1;

            //
            // Add length of PFB file path if this font has an associated PFB
            // and that PFB is located in the fonts directory.  We don't
            // want to delete a PFB that isn't under our control.
            // Note that bGetPFB() returns FALSE if the font isn't Type1.
            //
            if (poFont->bGetPFB(szPath, ARRAYSIZE(szPath)) &&
                bFileIsInFontsDirectory(szPath))
            {
                iBufSize += lstrlen(szPath) + 1;
            }

            //
            //  If this doesn't work, we'll pick it up below because the
            //  delete failed.
            //

            poFont->bRFR( );
        }
    }

    //
    //  If all the entries were links, then there is no buffer.
    //

    if( 1 < iBufSize )
    {
        LPTSTR  lpBuf = new TCHAR[ iBufSize ];

        if( !lpBuf )
            return;

        //
        //  Fill it in.
        //

        LPTSTR lpCur = lpBuf;

        for( i = 0; i < iCount; i++ )
        {
            poFont = poList->poObjectAt( i );

            if( poFont->bGetFileToDel( lpCur ) )
            {
                lpCur += ( lstrlen( lpCur ) + 1 );

                //
                // Add path to the PFB file if there is one and if
                // that PFB is located in the fonts directory.  We don't
                // want to delete a PFB that isn't under our control.
                // Note that bGetPFB() returns FALSE if the font isn't Type1.
                //
                if (poFont->bGetPFB(szPath, ARRAYSIZE(szPath)) &&
                    bFileIsInFontsDirectory(szPath))
                {
                    lstrcpyn(lpCur, szPath, iBufSize - (size_t)(lpCur - lpBuf));
                    lpCur += (lstrlen(lpCur) + 1);
                }
            }
        }

        *lpCur = 0;

        //
        //  Do the delete.
        //

        SHFILEOPSTRUCT sFileOp =
        {
            NULL,
            FO_DELETE,
            lpBuf,
            NULL,
            FOF_ALLOWUNDO | FOF_NOCONFIRMATION,
            0,
            0
        } ;

        int iRet = SHFileOperation( &sFileOp );

        //
        //  If the operation was cancelled, determined what was done and what
        //  wasn't.
        //

        if( iRet || sFileOp.fAnyOperationsAborted )
        {
            //
            // Walk the list and determine if the file is there or not.
            //

            for( i = iCount - 1; i >= 0; i-- )
            {
               poFont = poList->poObjectAt( i );

               if( poFont->bOnSysDir( ) )
               {
                    poFont->vGetDirFN( szPath );

                    //
                    //  If the file exists then the operation didn't succeed.
                    //  Remove it from the list and AddFontResource.
                    //

                    if( GetFileAttributes( szPath ) != 0xffffffff )
                    {
                        poList->poDetach( i );
                        poFont->bAFR( );
                        poFont->Release();
                    }
                }
            }
        }
    }  // End of if( iBufSize )

uninstall:

    //
    //  Remove the fonts from the main list.
    //

    iCount = poList->iCount( );

    for( i = 0; i < iCount; i++)
    {
        poFont = poList->poObjectAt( i );
        vDeleteFont( poFont, FALSE );
    }

    //
    //  If there was something deleted, then notify apps.
    //

    if( iCount )
        vCPWinIniFontChange( );
}


/***************************************************************************
 * METHOD:  vDeleteFont
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

void CFontManager::vDeleteFont( CFontClass * lpFontRec, BOOL bRemoveFile )
{
    FontDesc_t     szLHS;

#if 0
    FullPathName_t szFile;

    //
    //  First, remove the font resource itself
    //  TODO. We need to return an error code. The font may be in use.
    //

    lpFontRec->bGetFQName( szFile, ARRAYSIZE( szFile ) );

    DWORD dwError;

    if( !RemoveFontResource( szFile ) )
    {
        TCHAR szFN[ MAX_PATH_LEN ];

        dwError = GetLastError( );

        lpFontRec->vGetFileName( szFN );

        if( !RemoveFontResource( szFN ) )
        {
            return;
        }
    }
#else

#ifdef WINNT

    if( lpFontRec->bType1( ) )
    {
        //
        //  Remove registry entries (files should have been deleted
        //  before reaching this point - in vDeleteFontList above).
        //
        //

        lpFontRec->vGetDesc( szLHS );

        DeleteT1Install( NULL, szLHS, bRemoveFile );

        goto RemoveRecord;
    }

#endif  //  WINNT


    if( !lpFontRec->bRFR( ) )
        return;

#endif

    //  Remove the entry from WIN.INI or the registry -- whereever it
    //  resides.

    lpFontRec->vGetDesc( szLHS );

    WriteProfileString( s_szINISFonts, szLHS, 0L );

    WriteToRegistry( szLHS, NULL );
    
    //
    //  Now, if we're talking about a FOT file for truetype guys, we always
    //  remove the FOT file. The corresponding TTF file is removed based on
    //  the user request. Stick the TTF file in the 'normal' file slot, the
    //  one whose deletion is conditional
    //

#if 0

    if( lpFontRec->bFOTFile( ) )
    {
        OpenFile( szFile, &ofstruct, OF_DELETE );

        lpFontRec->vGetTTFDirFN( szFile );
    }

#endif

RemoveRecord:

    ECS;

    //
    //  Remove the record from the list.
    //

    if( !m_poFontList->bDelete( lpFontRec ) )
        lpFontRec->Release();

    LCS;
}


/***************************************************************************
 * METHOD:  vDeleteFontFamily
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

void CFontManager::vDeleteFontFamily( CFontClass * lpFontRec, BOOL bRemoveFile )
{
    int   iCount = m_poFontList->iCount( );
    WORD  wFam = lpFontRec->wGetFamIndex( );

    while( iCount--)
    {
       lpFontRec = m_poFontList->poObjectAt( iCount );

       if( lpFontRec && ( wFam == lpFontRec->wGetFamIndex( ) ) )
          vDeleteFont( lpFontRec, bRemoveFile );
    }
}


/***************************************************************************
 * METHOD:  iCompare
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

int CFontManager::iCompare( CFontClass * pFont1,
                            CFontClass * pFont2,
                            CFontClass * pOrigin )
{
   USHORT   nDiff1,
            nDiff2;

   // DEBUGMSG( (DM_TRACE1,TEXT( "FontMan: iCompare" ) ) );

   nDiff1 = nDiff( pOrigin, pFont1 );
   nDiff2 = nDiff( pOrigin, pFont2 );

   return(  ( (int)(ULONG) nDiff1 ) - ((int)(ULONG) nDiff2 ) );
}


/***************************************************************************
 * METHOD:  nDiff
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

USHORT CFontManager::nDiff( CFontClass * pFont1, CFontClass * pFont2 )
{
   IPANOSEMapper * m_poMap;
   USHORT   nRet = (USHORT)(-1);

   // DEBUGMSG( (DM_TRACE1,TEXT( "nDiff        " ) ) );

   if( SUCCEEDED( GetPanMapper( &m_poMap ) ) ) {
      BYTE * lpPan1 = pFont1->lpBasePANOSE( );
      BYTE * lpPan2 = pFont2->lpBasePANOSE( );

      nRet = m_poMap->unPANMatchFonts( lpPan1,
                        PANOSE_LEN,
                        lpPan2,
                        PANOSE_LEN,
                        *lpPan1 );

      m_poMap->Release( );
   }

   return nRet;
}

// -----------------------------------------------------------------------
// GetPanoseClass
//
// Return the class of the Panose Mapper. If we expose this in the
// registery, we can just alter this function and everything still
// works correctly.
//
//------------------------------------------------------------------------

CLSID GetPanoseClass( )
{
   return CLSID_PANOSEMapper;
}

/***************************************************************************
 * METHOD:  GetPanMapper
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/
HRESULT CFontManager::GetPanMapper( IPANOSEMapper ** ppMapper )
{
    HRESULT   hr = ResultFromScode( E_NOINTERFACE );


    *ppMapper = NULL;

    ECS;

    if( !m_poPanMap && !m_bTriedOnce )
    {
        m_bTriedOnce = TRUE;

        DEBUGMSG( (DM_TRACE1,TEXT( "GetPanMapper calling GetPanoseClass()" ) ) );

        CLSID clsid = GetPanoseClass( );

        DEBUGMSG( (DM_TRACE1,TEXT( "GetPanMapper calling CoCreateInstance" ) ) );

        DEBUGMSG( (DM_TRACE1, TEXT( "Initializing OLE" ) ) );

#if 0
        hr = CoInitialize( NULL );

        if( FAILED( hr ) )
        {
            LCS;
            return( hr );
        }
#endif

        DEBUGMSG( (DM_TRACE1, TEXT( "Calling CoCreateInstance" ) ) );
#if 0
        hr = CoCreateInstance( clsid,
                               NULL,
                               (DWORD) CLSCTX_INPROC_SERVER,
                               IID_IPANOSEMapper,
                               (LPVOID *) &m_poPanMap );
#endif
        hr = SHCoCreateInstance( NULL,
                                 &clsid,
                                 NULL,
                                 IID_IPANOSEMapper,
                                 (LPVOID *) &m_poPanMap );

        if( FAILED( hr ) )
        {
#if 0
            CoUninitialize( );
#endif
            DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: CFontMan::GetPan() Failed  %d" ),
                        hr) );

            // DEBUGBREAK;
        }

        //
        //  We have the mapper. Relax the threshold so we
        //  can get values for sorting.
        //

        else
            m_poPanMap->vPANRelaxThreshold( );
    }

    //
    //  AddRef for the caller. (This will make the count > 1 )
    //  We Release( ) on delete.
    //

    if( m_poPanMap )
    {
        // DEBUGMSG( (DM_TRACE1, TEXT( "GetPanMapper calling m_poPanMap->AddRef()" ) ) );

        m_poPanMap->AddRef( );

        *ppMapper = m_poPanMap;
        hr = NOERROR;
    }

    LCS;

    return hr;
}


//
// Build a hash table of font file names contained in the
// "HiddenFontFiles" section of %windir%\FONT.INF.  This identifies
// those font files that are to be always hidden, and therefore
// excluded from installation via the folder reconciliation thread.
//
DWORD CFontManager::HiddenFilesList::Initialize(void)
{
    DWORD dwNamesLoaded = 0;

    //
    // If already initialized, destroy current contents.
    //
    if (IsInitialized())
        Destroy();

    //
    // Initialize hash table with 101 buckets and
    // make it case insensitive.
    // There are currently 140 entries in the HiddenFontFiles
    // section of FONT.INF.
    //
    if (StringTable::Initialize(101,       // Hash bucket count.
                                FALSE,     // Case insensitive.
                                FALSE))    // No duplicates.
    {
        HANDLE hInf = INVALID_HANDLE_VALUE;

        hInf = SetupOpenInfFile(TEXT("FONT.INF"), NULL, INF_STYLE_WIN4, NULL);

        if (INVALID_HANDLE_VALUE != hInf)
        {
            INFCONTEXT Context;

            if(SetupFindFirstLine(hInf, TEXT("HiddenFontFiles"), NULL, &Context))
            {
                TCHAR szFileName[MAX_PATH];
                DWORD dwReqdSize = 0;

                do
                {
                    if(SetupGetStringField(&Context,
                                           0,
                                           szFileName,
                                           ARRAYSIZE(szFileName),
                                           &dwReqdSize))
                    {
                        if (Add(szFileName))
                            dwNamesLoaded++;
                    }
                } while(SetupFindNextLine(&Context, &Context));
            }
            SetupCloseInfFile(hInf);
        }
    }
    return dwNamesLoaded;
}


#ifdef WINNT
//
// Determine if a Type1 font driver is loaded.
// This code was taken from \ntuser\client\fntsweep.c
// Originally written by BodinD.
//
BOOL CFontManager::CheckForType1FontDriver(void)
{
    LONG       lRet;
    WCHAR      awcClass[MAX_PATH] = L"";
    DWORD      cwcClassName = MAX_PATH;
    DWORD      cSubKeys;
    DWORD      cjMaxSubKey;
    DWORD      cwcMaxClass;
    DWORD      cValues = 0;
    DWORD      cwcMaxValueName;
    DWORD      cjMaxValueData;
    DWORD      cjSecurityDescriptor;

    HKEY       hkey = NULL;
    FILETIME   ftLastWriteTime;

    BOOL bRet = FALSE;

    // open the font drivers key and check if there are any entries, if so
    // return true. If that is the case we will call AddFontResourceW on
    // Type 1 fonts at boot time, right after user had logged on
    // PostScript printer drivers are not initialized at this time yet,
    // it is safe to do it at this time.

    lRet = RegOpenKeyExW(HKEY_LOCAL_MACHINE,        // Root key
                         s_szKeyFontDrivers,        // Subkey to open
                         0L,                        // Reserved
                         KEY_READ,                  // SAM
                         &hkey);                    // return handle

    if (lRet == ERROR_SUCCESS)
    {
        // get the number of entries in the [Fonts] section

        lRet = RegQueryInfoKeyW(
                   hkey,
                   awcClass,              // "" on return
                   &cwcClassName,         // 0 on return
                   NULL,
                   &cSubKeys,             // 0 on return
                   &cjMaxSubKey,          // 0 on return
                   &cwcMaxClass,          // 0 on return
                   &cValues,              // == cExternalDrivers
                   &cwcMaxValueName,      // longest value name
                   &cjMaxValueData,       // longest value data
                   &cjSecurityDescriptor, // security descriptor,
                   &ftLastWriteTime
                   );

        if ((lRet == ERROR_SUCCESS) && cValues)
        {
            bRet = TRUE;
        }

        RegCloseKey(hkey);
    }
    return (m_bType1FontDriverInstalled = bRet);
}

#endif // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\fsnotify.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fsnotify.cpp
//      Explorer Font Folder extension routines
//     Routines to watch the Fonts directory and handle change notifications.
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#if defined(__FCN__)

#include "fsnotify.h"
#include "fontman.h"

#include "dbutl.h"

#ifdef DEBUG
int iCount = 0;
#endif  // DEBUG

#define ARRAYSIZE(a)  (sizeof(a) / sizeof((a)[0]))

//------------------------------------------------------------------------
// FUNCTION:   dwNotifyWatchProc
//
// PURPOSE:    Watch a directory and notify the CFontManager when something
//             has changed.
//------------------------------------------------------------------------
DWORD dwNotifyWatchProc( LPVOID pvParams )
{
    DWORD dwRet;
    BOOL  bFileChange = FALSE;
    BOOL bDone = FALSE;
    CFontManager *pFontManager = (CFontManager *)pvParams;

    DEBUGMSG( (DM_TRACE2, TEXT( "dwNotifyWatchProc called" ) ) );
    
    if (NULL == pFontManager)
        return (DWORD)-1;

    HANDLE rgHandles[] = { pFontManager->m_hEventTerminateThreads,
                           pFontManager->m_Notify.m_hWatch };
    while(!bDone)
    {
        //
        //  Wait for the FONTS folder to change. If we time out, then attempt
        //  to undo any deletions that might be occuring.
        //                      
        dwRet = WaitForMultipleObjects(ARRAYSIZE(rgHandles), 
                                       rgHandles, 
                                       FALSE, 
                                       1500);

        if (WAIT_TIMEOUT == dwRet)
        {
            // DEBUGMSG( (DM_TRACE2, TEXT( "dwNotifyWatchProc: main loop - Timeout from WaitForSingleObject - iteration %d" ), ++iCount ) );

            if( !pFontManager->bCheckTBR( ) )
                pFontManager->vUndoTBR( );
        
            //
            //  Go through the fonts directory and make sure it's in a
            //  stable condition.
            //

            if( bFileChange )
            {
                bFileChange = FALSE;
                pFontManager->vReconcileFolder( THREAD_PRIORITY_NORMAL );
            }
        }
        else switch(dwRet - WAIT_OBJECT_0)
        {
            case 0:
                //
                // "Terminate-threads" event was set.  Time to go home.
                //
                bDone = true;
                break;
                
            case 1:
                //
                //  Things be happenin'. We could call bCheckTBR() at this
                //  point, but we might as well wait for a time out and do
                //  it all at once. Doing nothing just causes us to wait 
                //  another 1.5 secs; i.e. reset the timeout.
                //
                bFileChange = TRUE;

                //
                //  Since an event came in, reset the Change Notification to
                //  watch it some more.  This call should NOT be done during
                //  the TIMEOUT because it causes another change packet under
                //  WinNT and an undesireable race condition under Win 95.
                //  (Note:  The extra change packets under WinNT are allocated
                //   out of Non-paged pool memory and excessive requests can
                //   use up the processes non-paged pool memory quota, and
                //   then the fun really begins with the app.)  [stevecat]
                //
        
                if( !FindNextChangeNotification(pFontManager->m_Notify.m_hWatch))
                {
                    DEBUGMSG( (DM_ERROR, TEXT( "dwNotifyWatchProc: FindNextChangeNotification FAILED - error = %d" ), GetLastError( ) ) );
                }
        
                DEBUGMSG( (DM_TRACE2, TEXT( "dwNotifyWatchProc: FindNextChangeNotification called - handle = 0x%x" ), pFontManager->m_Notify.m_hWatch));
        
                //
                // Wait 'til next 1.5 second timeout to do anything.
                //
                break;
                
            default:
                    break;
        }
    }
    InterlockedDecrement(&g_cRefThisDll);    
    return 0;
}

#endif   // __FCN__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\lstrfns.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// lstrfns.cpp
//      Explorer Font Folder extension routines
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright  1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//    MODULE:        lstrfns.c
//
//    PURPOSE:    Specialized string manipulation functions
//
//    PLATFORMS:    Chicago
//
//    FUNCTIONS:
//
//    Private Functions: these are near calls
//      ChrCmp      - Case sensitive character comparison for DBCS
//      ChrCmpI     - Case insensitive character comparison for DBCS
//      StrEndN     - Find the end of a string, but no more than n bytes
//      ReverseScan - Find last occurrence of a byte in a string
//
//    Public functions: these will be near calls if compiled small
//    model, far calls otherwise.
//      StrChr     - Find first occurrence of character in string
//      StrChrI    - Find first occurrence of character in string, case insensitive
//      StrRChr    - Find last occurrence of character in string
//      StrRChrI   - Find last occurrence of character in string, case insensitive
//      StrNCmp    - Compare n characters
//      StrNCmpI   - Compare n characters, case insensitive
//      StrNCpy    - Copy n characters
//      StrCmpN    - Compare n bytes
//      StrCmpNI   - Compare n bytes, case insensitive
//      StrCpyN    - Copy up to n bytes, don't end in LeadByte for DB char
//      StrStr     - Search for substring
//      StrStrI    - Search for substring case insensitive
//      StrRStr    - Reverse search for substring
//      StrRStrI   - Reverse search for substring case insensitive
//
//    SPECIAL INSTRUCTIONS: N/A
//
//***************************************************************************
// $lgb$
// 1.0     7-Mar-94 eric Initial revision.
// $lge$
//*************************************************************************** 
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"

// #include "incall.h"

#define ALL
//
//  Define STATIC in the makefile to get these two symbols
//

#ifndef STATIC
#define STATIC static
#endif

//
//  Define DBCS if you want the actual functions called
//

#ifndef DBCS
#define DBCS
#endif

#ifdef DBCS

#define FASTCALL PASCAL

#else

#define FASTCALL _fastcall
#define IsDBCSLeadByte(x) ((x), FALSE)

#endif

//
//  Use all case sensitive functions; define INSENS also to get all fns
//

#ifdef ALL

#define CHR
#define CMP
#define CPY
#define STR
#define NCHARS

#endif

#include "lstrfns.h"

//
//  This is so we can compare offsets if we know the segments are equal
//

//#define OFFSET(x) (LOWORD((DWORD)(x)))


//
//  I'm cheating here to make some functions a little faster;
//  we won't have to push a word on the stack every time
//

STATIC WORD gwMatch;


#if defined(CHR) || defined(STR)
// 
//  ChrCmp -  Case sensitive character comparison for DBCS
//  Assumes   w1, gwMatch are characters to be compared
//  Return    FALSE if they match, TRUE if no match
//

STATIC BOOL NEAR PASCAL ChrCmp( WORD w1 )
{
    //
    //  Most of the time this won't match, so test it first for speed.
    //

    if( LOBYTE( w1 ) == LOBYTE( gwMatch ) )
    {
        if( IsDBCSLeadByte( LOBYTE( w1 ) ) )
        {
            return( w1 != gwMatch );
        }
        return FALSE;
    }
    return TRUE;
}


#if defined(INSENS)

// 
//  ChrCmpI - Case insensitive character comparison for DBCS
//  Assumes   w1, gwMatch are characters to be compared;
//            HIBYTE of gwMatch is 0 if not a DBC
//  Return    FALSE if match, TRUE if not
//

STATIC BOOL NEAR PASCAL ChrCmpI( WORD w1 )
{
    TCHAR sz1[ 3 ], sz2[ 3 ];

    if( IsDBCSLeadByte( sz1[ 0 ] = LOBYTE( w1 ) ) )
    {
        sz1[ 1 ] = HIBYTE( w1 );
        sz1[ 2 ] = TEXT( '\0' );
    }
    else
        sz1[ 1 ] = TEXT( '\0' );

    *(WORD *)sz2 = gwMatch;

    sz2[ 2 ] = TEXT( '\0' );

    return( lstrcmpi( sz1, sz2 ) );
}
#endif

#endif


#if defined(CMP) || defined(CPY) || defined(STR)

// 
//  StrEndN - Find the end of a string, but no more than n bytes
//  Assumes   lpStart points to start of null terminated string
//            nBufSize is the maximum length
//  returns ptr to just after the last byte to be included
//

STATIC LPTSTR NEAR PASCAL StrEndN( LPTSTR lpStart, UINT nBufSize )
{
    LPTSTR lpEnd;

    for( lpEnd = lpStart + nBufSize;
         *lpStart && OFFSET( lpStart ) < OFFSET( lpEnd );
        lpStart = CharNext( lpStart ) )
    {
        //
        //  just getting to the end of the string
        //

        continue;
    }

    if( OFFSET( lpStart ) > OFFSET( lpEnd ) )
    {
        //
        // We can only get here if the last byte before lpEnd was a lead byte
        //

        lpStart -= 2;
    }

    return( lpStart );
}

#endif


#if defined(STR)

// 
//  ReverseScan - Find last occurrence of a byte in a string
//  Assumes   lpSource points to first byte to check (end of the string)
//            wLen is the number of bytes to check
//            bMatch is the byte to match
//  returns ptr to the last occurrence of ch in str, NULL if not found.
//

STATIC LPTSTR NEAR PASCAL ReverseScan( LPTSTR lpSource, UINT wLen, TCHAR bMatch )
{

    UINT    cbT     = lstrlen( lpSource );
    LPTSTR  lpszRet = NULL;

    if( cbT )
    {
        cbT = min( cbT, wLen );

        while( cbT-- && !lpszRet )
        {
            if( *lpSource == bMatch )
            {
                lpszRet = lpSource;
            }
            else
            {
                lpSource--;
            }
        }
    }

    return lpszRet;
}

#endif


#if defined(CHR) || defined(STR)

// 
//  StrChr - Find first occurrence of character in string
//  Assumes   lpStart points to start of null terminated string
//            wMatch  is the character to match
//  returns ptr to the first occurrence of ch in str, NULL if not found.
//

LPTSTR PASCAL StrChr( LPTSTR lpStart, WORD wMatch )
{
    gwMatch = wMatch;

    for(  ; *lpStart; lpStart = CharNext( lpStart ) )
    {
        if( !ChrCmp( *(LPWORD)lpStart ) )
            return( lpStart );
    }

    return( NULL );
}


//
//  StrRChr - Find last occurrence of character in string
//  Assumes   lpStart points to start of string
//            lpEnd   points to end of string (NOT included in search)
//            wMatch  is the character to match
//  returns ptr to the last occurrence of ch in str, NULL if not found.
//

LPTSTR PASCAL StrRChr( LPTSTR lpStart, LPTSTR lpEnd, WORD wMatch )
{
    LPTSTR lpFound = NULL;

    if( !lpEnd )
        lpEnd = lpStart + lstrlen( lpStart );

    gwMatch = wMatch;

    for(  ; OFFSET( lpStart ) < OFFSET( lpEnd ); lpStart = CharNext( lpStart ) )
    {
        if( !ChrCmp( *(LPWORD)lpStart ) )
            lpFound = lpStart;
    }

    return( lpFound );
}


#if defined(INSENS)

// 
//  StrChrI - Find first occurrence of character in string, case insensitive
//  Assumes   lpStart points to start of null terminated string
//            wMatch  is the character to match
//  returns ptr to the first occurrence of ch in str, NULL if not found.
//

LPTSTR PASCAL StrChrI( LPTSTR lpStart, WORD wMatch )
{
    gwMatch = IsDBCSLeadByte( LOBYTE( wMatch ) ) ? wMatch : LOBYTE( wMatch );

    for(  ; *lpStart; lpStart = CharNext( lpStart ) )
    {
        if( !ChrCmpI( *(LPWORD)lpStart ) )
            return( lpStart );
    }

    return( NULL );
}


// 
//  StrRChrI - Find last occurrence of character in string, case insensitive
//  Assumes   lpStart points to start of string
//            lpEnd   points to end of string (NOT included in search)
//            wMatch  is the character to match
//  returns ptr to the last occurrence of ch in str, NULL if not found.
//

LPTSTR PASCAL StrRChrI( LPTSTR lpStart, LPTSTR lpEnd, WORD wMatch )
{
    LPTSTR lpFound = NULL;

    if( !lpEnd )
        lpEnd = lpStart + lstrlen( lpStart );

    gwMatch = IsDBCSLeadByte( LOBYTE( wMatch ) ) ? wMatch : LOBYTE( wMatch );

    for(  ; OFFSET( lpStart ) < OFFSET( lpEnd ); lpStart = CharNext( lpStart ) )
    {
        if( !ChrCmpI( *(LPWORD) lpStart ) )
            lpFound = lpStart;
    }

    return( lpFound );
}

#endif

#endif


#if defined(CMP)

//
//  StrCmpN      - Compare n bytes
//
//  returns   See lstrcmp return values.
//

short PASCAL StrCmpN( LPTSTR lpStr1, LPTSTR lpStr2, short nChar )
{
    TCHAR  cHold1, cHold2;
    short  i;
    LPTSTR lpEnd1, lpEnd2;
    
    cHold1 = *(lpEnd1 = StrEndN( lpStr1, nChar ) );

    cHold2 = *(lpEnd2 = StrEndN( lpStr2, nChar ) );

    *lpEnd1 = *lpEnd2 = TEXT( '\0' );

    i = lstrcmp( lpStr1, lpStr2 );

    *lpEnd1 = cHold1;

    *lpEnd2 = cHold2;

    return( i );
}


#if defined(INSENS)

//
//  StrCmpNI     - Compare n bytes, case insensitive
//
//  returns   See lstrcmpi return values.
//

short PASCAL StrCmpNI( LPTSTR lpStr1, LPTSTR lpStr2, short nChar )
{
    TCHAR  cHold1, cHold2;
    short  i;
    LPTSTR lpEnd1, lpEnd2;
    
    cHold1 = *(lpEnd1 = StrEndN( lpStr1, nChar ) );

    cHold2 = *(lpEnd2 = StrEndN( lpStr2, nChar ) );

    *lpEnd1 = *lpEnd2 = TEXT( '\0' );

    i = lstrcmpi( lpStr1, lpStr2 );

    *lpEnd1 = cHold1;

    *lpEnd2 = cHold2;

    return( i );
}

#endif

#endif


#if defined(CPY)

//
//  StrCpyN      - Copy up to N bytes, don't end in LeadByte for DB char
//
//  Assumes   lpDest points to buffer of nBufSize bytes (including NULL)
//            lpSource points to string to be copied.
//  returns   Number of bytes copied, NOT including NULL
//

UINT PASCAL StrCpyN( LPTSTR lpDest, LPTSTR lpSource, short nBufSize )
{
    LPTSTR lpEnd;
    TCHAR cHold;

    if( nBufSize < 0 )
        return( nBufSize );

    lpEnd = StrEndN( lpSource, nBufSize );

    cHold = *lpEnd;

    *lpEnd = TEXT( '\0' );

    lstrcpy( lpDest, lpSource );

    *lpEnd = cHold;

    return( lpEnd - lpSource );
}

#endif


#if defined(NCHARS)

#if defined(CMP)

#if 0    // Not used

//
//  StrNCmp      - Compare n characters
//
//  returns   See lstrcmp return values.
//

short PASCAL StrNCmp( LPTSTR lpStr1, LPTSTR lpStr2, short nChar )
{
    TCHAR  cHold1, cHold2;
    short  i;
    LPTSTR lpsz1 = lpStr1, lpsz2 = lpStr2;
    
    for( i = 0; i < nChar; i++ )
    {
        //
        //  If we hit the end of either string before the given number
        //  of bytes, just return the comparison
        //

        if( !*lpsz1 || !*lpsz2 )
            return( lstrcmp( lpStr1, lpStr2 ) );

        lpsz1 = CharNext( lpsz1 );
        lpsz2 = CharNext( lpsz2 );
    }

    cHold1 = *lpsz1;
    cHold2 = *lpsz2;

    *lpsz1 = *lpsz2 = TEXT( '\0' );

    i = lstrcmp( lpStr1, lpStr2 );

    *lpsz1 = cHold1;
    *lpsz2 = cHold2;

    return( i );
}

#endif    // Not used


#if defined(INSENS)

//
//  StrNCmpI     - Compare n characters, case insensitive
//
//  returns   See lstrcmpi return values.
//

short PASCAL StrNCmpI( LPTSTR lpStr1, LPTSTR lpStr2, short nChar )
{
    TCHAR  cHold1, cHold2;
    short  i;
    LPTSTR lpsz1 = lpStr1, lpsz2 = lpStr2;

    for( i = 0; i < nChar; i++ )
    {
        //
        //  If we hit the end of either string before the given number
        //  of bytes, just return the comparison
        //

        if( !*lpsz1 || !*lpsz2 )
            return( lstrcmpi( lpStr1, lpStr2 ) );

        lpsz1 = CharNext( lpsz1 );
        lpsz2 = CharNext( lpsz2 );
    }

    cHold1 = *lpsz1;
    cHold2 = *lpsz2;

    *lpsz1 = *lpsz2 = TEXT( '\0' );

    i = lstrcmpi( lpStr1, lpStr2 );

    *lpsz1 = cHold1;
    *lpsz2 = cHold2;

    return( i );
}
#endif
#endif


#if defined(CPY)

#if 0    // #defined as lstrcpyn

//
//  StrNCpy      - Copy n characters
//
//  returns   Actual number of characters copied
//

short PASCAL StrNCpy( LPTSTR lpDest, LPTSTR lpSource, short nChar )
{
    TCHAR  cHold;
    short  i;
    LPTSTR lpch = lpSource;
    
    if( nChar < 0 )
        return( nChar );
    
    for( i = 0; i < nChar; i++ )
    {
        if( !*lpch )
            break;

        lpch = CharNext( lpch );
    }

    cHold = *lpch;

    *lpch = TEXT( '\0' );

    lstrcpy( lpDest, lpSource );

    *lpch = cHold;

    return( i );
}

#endif    // #defined as lstrcpyn

#endif

#endif


#if defined(STR)

//
//  StrStr      - Search for first occurrence of a substring
//
//  Assumes   lpSource points to source string
//            lpSrch points to string to search for
//  returns   first occurrence of string if successful; NULL otherwise
//

LPTSTR PASCAL StrStr( LPTSTR lpFirst, LPTSTR lpSrch )
{
    WORD wLen;
    WORD wMatch;
    
    wLen = lstrlen( lpSrch );

    wMatch = *(LPWORD)lpSrch;
    
    for(  ; (lpFirst = StrChr( lpFirst, wMatch ) )
              && StrCmpN( lpFirst, lpSrch, wLen );
              lpFirst = CharNext( lpFirst ) )
    {
        //
        //  continue until we hit the end of the string or get a match
        //
        continue;
    }
    
    return( lpFirst );
}


//
//  StrRStr      - Search for last occurrence of a substring
//
//  Assumes   lpSource points to the null terminated source string
//            lpLast points to where to search from in the source string
//            lpLast is not included in the search
//            lpSrch points to string to search for
//  returns   last occurrence of string if successful; NULL otherwise
//

LPTSTR PASCAL StrRStr( LPTSTR lpSource, LPTSTR lpLast, LPTSTR lpSrch )
{
    WORD  wLen;
    TCHAR bMatch;
    
    wLen = lstrlen( lpSrch );

    bMatch = *lpSrch;
    
    if( !lpLast )
        lpLast = lpSource + lstrlen( lpSource );
    
    do
    {
        //
        //  Return NULL if we hit the exact beginning of the string
        //

        if( lpLast == lpSource )
            return( NULL );
    
        --lpLast;
    
        //
        // Break if we hit the beginning of the string
        //

        if( !(lpLast = ReverseScan( lpLast, OFFSET( lpLast )-OFFSET( lpSource )+1,
                                    bMatch ) ) )
            break;
    
        //
        //  Break if we found the string, and its first byte is not a tail byte
        //

        if( !StrCmpN( lpLast, lpSrch, wLen ) &&
            (lpLast == StrEndN( lpSource, OFFSET( lpLast )-OFFSET( lpSource ) ) ) )
            break;

    } while( 1 ) ;
    
    return( lpLast );
}


#if defined(INSENS)

//
//  StrStrI   - Search for first occurrence of a substring, case insensitive
//
//  Assumes   lpFirst points to source string
//            lpSrch points to string to search for
//  returns   first occurrence of string if successful; NULL otherwise
//

LPTSTR PASCAL StrStrI( LPTSTR lpFirst, LPTSTR lpSrch )
{
    WORD wLen;
    WORD wMatch;

    wLen = lstrlen( lpSrch );

    wMatch = *(LPWORD)lpSrch;

    for(  ; (lpFirst = StrChrI( lpFirst, wMatch ) )
             && StrCmpNI( lpFirst, lpSrch, wLen );
            lpFirst = CharNext( lpFirst ) )
    {
        //
        //  continue until we hit the end of the string or get a match
        //

        continue;
    }

    return( lpFirst );
}


//
//  StrRStrI      - Search for last occurrence of a substring
//
//  Assumes   lpSource points to the null terminated source string
//            lpLast points to where to search from in the source string
//            lpLast is not included in the search
//            lpSrch points to string to search for
//  returns   last occurrence of string if successful; NULL otherwise
//

LPTSTR PASCAL StrRStrI( LPTSTR lpSource, LPTSTR lpLast, LPTSTR lpSrch )
{
    LPTSTR lpFound = NULL, lpEnd;
    TCHAR cHold;


    if( !lpLast )
        lpLast = lpSource + lstrlen( lpSource );

    if( lpSource >= lpLast || *lpSrch == 0 )
        return NULL;

    lpEnd = StrEndN( lpLast, lstrlen( lpSrch )-1 );

    cHold = *lpEnd;

    *lpEnd = 0;

    while( ( lpSource = StrStrI( lpSource, lpSrch ) ) &&
            OFFSET( lpSource ) < OFFSET( lpLast ) )
    {
        lpFound = lpSource;
        lpSource = CharNext( lpSource );
    }

    *lpEnd = cHold;

    return lpFound;
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\pfiles.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// pfiles.cpp
//      Explorer Font Folder extension routines
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include "resource.h"
#include "cpanel.h"
#include "fontcl.h"        // Just for PANOSEBytesClass
// #include "fontinfo.h"
#include "pnewexe.h"
#include "lstrfns.h"

#include "dbutl.h"
#include "t1.h"
#include "fontfile.h"


#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifdef WINNT

#ifdef __cplusplus
extern "C" {
#endif

//
// [stevecat]   This used to reside in "wingdip.h" (included with <winp.h>)
//  6/29/95     but I have taken it out because of C++ name-mangling problems
//              with that header file that are not going to be fixed because
//              this file is going to change significantly (according to
//              EricK) when we switch over to Kernel mode GDI/User.
//
//
//#include <stddef.h>     //  Needed for winp.h
//#include <winp.h>       //  For private GDI entry point:  GetFontResourceInfo
//
//#undef SWAPL            //  The SWAPL macro in wingdip.h clashes with mine
//

// Private Control Panel entry point to enumerate fonts by file.

#define GFRI_NUMFONTS       0L
#define GFRI_DESCRIPTION    1L
#define GFRI_LOGFONTS       2L
#define GFRI_ISTRUETYPE     3L
#define GFRI_TTFILENAME     4L
#define GFRI_ISREMOVED      5L
#define GFRI_FONTMETRICS    6L

extern BOOL WINAPI GetFontResourceInfoW( LPWSTR  lpPathname,
                                         LPDWORD lpBytes,
                                         LPVOID  lpBuffer,
                                         DWORD   iType );

#ifdef __cplusplus
}
#endif

#endif


//-------------------------------------------------------------------
// this needs to go in a header. Probably pnewexe.h
//

#pragma pack(1)
typedef struct
{
    WORD    fontOrdinal;
    WORD    dfVersion;
    DWORD   dfSize;
    char    dfCopyright[ COPYRIGHT_LEN ];
    WORD    dfType;
    WORD    dfPoints;
    WORD    dfVertRes;
    WORD    dfHorzRes;
    WORD    dfAscent;
    WORD    dfIntLeading;
    WORD    dfExtLeading;
    BYTE    dfItalic;
    BYTE    dfUnderline;
    BYTE    dfStrikeOut;
    WORD    dfWeight;
    BYTE    dfCharSet;
    WORD    dfPixWidth;
    WORD    dfPixHeight;
    BYTE    dfPitchAndFamily;
    WORD    dfAvgWidth;
    WORD    dfMaxWidth;
    BYTE    dfFirstChar;
    BYTE    dfLastChar;
    BYTE    dfDefaultChar;
    BYTE    dfBreakChar;
    WORD    dfWidthBytes;
    DWORD   dfDevice;
    DWORD   dfFace;
    DWORD   dfReserved;
    char    szDeviceName[ 1 ];

} FONTENTRY, FAR *LPFONTENTRY;
#pragma pack()

//-------------------------------------------------------------------

TCHAR c_szTrueType[] = TEXT( "TrueType" );
TCHAR c_szOpenType[] = TEXT( "OpenType" );
TCHAR c_szDotOTF[]   = TEXT( ".OTF" );

#define M_INTEGERTYPE( wType )   (wType & 0x8000)
#define M_FONTDIRTYPE( wType )   ((wType & 0x7fff) == 7)

#define SWAP2B(p) (((unsigned short) ((p)[ 0 ]) << 8) | (p)[ 1 ])
#define SWAP4B(p) (SWAP2B((p)+2) | ((SWAP2B(p) + 0L) << 16))
#define SWAPW(x)  ((WORD)SWAP2B((unsigned char FAR *)(&x)))
#define SWAPL(x)  ((unsigned long)SWAP4B((unsigned char FAR *)(&x)))

#define Mac2Ansi(a)    a    // do this right later!

//
//  Platform and language we'll be looking for in the OS2 tables
//  The NAMEID_xxx are the ids of the name records we'll be hunting for.
//

#define DEFAULTPOINTS      14

#define LANG_US_ENG        0x0904        // US (1033) (in mac order)
// #define LANG_SHIFTJIS      0x1104        // SHIFTJIS

//
//  name ids.
//

#define COPYRIGHT_ID    0x0000
#define FAMILY_ID       0x0100
#define SUBFAMILY_ID    0x0200
#define PLATFORM_MS     0x0300        // in mac order
#define FACENAME_ID     0x0400        // in mac order
#define VERSION_ID      0x0500
#define POSTSCRIPT_ID   0x0600
#define TRADEMARK_ID    0x0700

#define ENCODEID_UNICODE   0x0100
#define ENCODEID_SHIFTJIS  0x0200
#define ENCODEID_PRC       0x0300
#define ENCODEID_BIG5      0x0400
#define ENCODEID_WANGSUNG  0x0500
#define ENCODEID_JOHAB     0x0600


#define NAMEID_COPYRIGHT    0
#define NAMEID_VERSION      5
#define NAMEID_TRADEMARK    7

#define TAG_CHARTOINDEXMAP   0x70616d63      //  'cmap'
#define TAG_FONTHEADER       0x64616568      //  'head'
#define TAG_NAMINGTABLE      0x656d616e      //  'name'
#define TAG_OS2TABLE         0x322f534f      //  'os_2'
#define TAG_DSIG             0x47495344      //  'DSIG'
#define TAG_CFF              0x20464643      //  'CFF'
#define SFNT_MAGIC           0xf53C0F5f


//
// Enumeration of bit mask values enables us to identify a set of TrueType
// tables in a single DWORD.  The total set of possible tables is open-ended
// as the TrueType specification is extensible.  This enumeration is merely
// a subset that is useful in the font folder.
//
enum TrueTypeTables {
    TT_TABLE_CMAP  = 0x00000001,
    TT_TABLE_HEAD  = 0x00000002,
    TT_TABLE_NAME  = 0x00000004,
    TT_TABLE_OS2   = 0x00000008,
    TT_TABLE_DSIG  = 0x00000010,
    TT_TABLE_CFF   = 0x00000020
                    };

//
//  The TTF structure as used here:
//  The TABLERECORD's the highest level.  It contains
//     sfnt_NameTable entries which in turn consist of
//     sfnt_NameRecord entries
//

typedef struct {
        WORD    id_Specific;
        WORD    id_Platform;
        WORD    id_Language;
} IDBlock_t;

//
//  A little macro for turning an array of 4 chars into dwords.
//

#define M_MAKETAG(a,b,c,d)   ((((((((DWORD) (a) ) << 8)  \
                             | (DWORD) (b) ) << 8)  \
                             | (DWORD) (c) ) << 8)  \
                             | (DWORD) (d) )

#define TAG_TTCF     M_MAKETAG('f', 'c', 't', 't' )

//
//  True type file structures
//

typedef struct ttc_hdr_tag {
   DWORD dwTag;
   DWORD dwVersion;
   DWORD dwDirCount;
} ttc_hdr;

typedef struct tt_hdr_tag {
  DWORD dwVersion;
  WORD  uNumTables;
  WORD  uSearchRange;
  WORD  uEntrySelector;
  WORD  uRangeShift;
} tt_hdr;

typedef struct tttag_tag {
  DWORD dwTag;
  DWORD dwCheckSum;
  DWORD dwOffset;
  DWORD dwLength;
} tttag;

typedef struct tt_head_tag {
  DWORD dwVersion;
  DWORD dwRevision;
  DWORD dwChecksum;
  DWORD dwMagic;
  WORD  wFlags;
  WORD  wUnitsPerEm;
  DWORD dwCreated1;
  DWORD dwCreated2;
  DWORD dwModified1;
  DWORD dwModified2;
  WORD  wXMin;
  WORD  wYMin;
  WORD  wXMax;
  WORD  wYMax;
  WORD  wStyle;
  WORD  wMinReadableSize;
  short iDirectionHint;
  short iIndexToLocFormat;
  short iGlyphDataFormat;
} tt_head;

typedef struct {
     WORD     wPlatformID;
     WORD     wSpecificID;
     DWORD    wOffset;
} sfnt_platformEntry;

typedef struct {
    WORD    wVersion;
    WORD    wNumTables;
    // sfnt_platformEntry platform[ 1 ];   // platform[ numTables ]
} sfnt_char2IndexDir;

typedef struct {
    WORD    wPlatformID;
    WORD    wSpecificID;
    WORD    wLanguageID;
    WORD    wNameID;
    WORD    wLength;
    WORD    wOffset;
} sfnt_NameRecord, *sfnt_pNameRecord, FAR* sfnt_lpNameRecord;

typedef struct {
    WORD    wFormat;
    WORD    wCntRecords;
    WORD    wOffsetString;
/*  sfnt_NameRecord[ count ]  */
} sfnt_NameTable, *sfnt_pNameTable, FAR* sfnt_lpNameTable;


extern "C" {
    void FAR PASCAL UnicodeToAnsi( LPWORD lpwName, LPSTR szName );
}

static void NEAR PASCAL FillName( LPTSTR            szName,
                                  sfnt_lpNameRecord pNameRecord,
                                  WORD              igi,
                                  LPBYTE            pStringByte );

static BOOL  NEAR PASCAL bGetName( CFontFile&    file,
                                   tttag         *pTTTag,
                                   IDBlock_t     &ID_Block,
                                   LPTSTR         szName,
                                   LPFONTDESCINFO lpFDI = NULL );

static BOOL  NEAR PASCAL bFindNameThing( sfnt_pNameTable pNames,
                                         IDBlock_t      &ID_Block,
                                         WORD            NameID,
                                         LPTSTR          szName );

static VOID  NEAR PASCAL vReadCountedString( CFontFile& file, LPSTR lpStr, int iLen );



/***************************************************************************
 * Start of Public functions
 ***************************************************************************/

#ifdef WINNT

//
// Wrapper around GetFontResourceInfo(GFRI_DESCRIPTION) to handle
// the dynamic buffer sizing required.  With some TTC fonts, the
// description can get very long.
//
BOOL
GetFontResourceDescription(
    LPTSTR pszFile,
    LPTSTR *ppszDesc
    )
{
    *ppszDesc = NULL;

    //
    // First call the GDI API once to get the required buffer size.
    //
    BYTE bDummy;
    DWORD dwBufSize = 0;
    if (GetFontResourceInfoW(pszFile, &dwBufSize, &bDummy, GFRI_DESCRIPTION))
    {
        if (0 < dwBufSize)
        {
            *ppszDesc = (LPTSTR)LocalAlloc(LPTR, dwBufSize);
            if (NULL != *ppszDesc)
            {
                if (GetFontResourceInfoW(pszFile, &dwBufSize, *ppszDesc, GFRI_DESCRIPTION))
                {
                    return TRUE;
                }
                LocalFree(*ppszDesc);
                *ppszDesc = NULL;
            }
        }
    }
    return FALSE;
}



/////////////////////////////////////////////////////////////////////////////
//
// ValidFontFile
//
// in:
//    lpszFile       file name to validate
// out:
//    lpszDesc       on succes name of TT file or description from exehdr
//    lpiFontType    set to a value based on Font type 1 == TT, 2 == Type1
//    lpdwStatus     Set to status of validation functions.
//                   Query to determine why font is invalid.
//                   The following list contains the possible status
//                   values.  See fvscodes.h for details.
//
//                   FVS_SUCCESS
//                   FVS_INVALID_FONTFILE
//                   FVS_INVALID_ARG
//                   FVS_INSUFFICIENT_BUF
//                   FVS_FILE_IO_ERR
//                   FVS_EXCEPTION
//
// NOTE: Assumes that lpszDesc is of size DESCMAX
//
// returns:
//    TRUE success, FALSE failure
//
/////////////////////////////////////////////////////////////////////////////

BOOL bCPValidFontFile( LPTSTR    lpszFile,
                       LPTSTR    lpszDesc,
                       WORD FAR *lpwFontType,
                       BOOL      bFOTOK,
                       LPDWORD   lpdwStatus )
{
    BOOL          result;
    DWORD         dwBufSize;
    FONTDESCINFO  File;
    BOOL          bTrueType = FALSE;
    TCHAR         szDesc[ DESCMAX ];
    WORD          wType = NOT_TT_OR_T1;
    LPTSTR        lpTemp;
    DWORD         dwStatus = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
    DWORD         dwTrueTypeTables = 0;


    //
    // Initialize status return.
    //
    if (NULL != lpdwStatus)
       *lpdwStatus = FVS_MAKE_CODE(FVS_INVALID_STATUS, FVS_FILE_UNK);

    //
    //  Set up the FDI depending on what the caller wanted.
    //

    File.dwFlags = FDI_NONE;

    if( lpszDesc )
    {
        *lpszDesc = (TCHAR) 0;
        File.dwFlags = FDI_DESC;
    }

    if( lpwFontType )
        *lpwFontType = NOT_TT_OR_T1;

    GetFullPathName( lpszFile,
                     PATHMAX,
                     File.szFile,
                     &lpTemp );

    if( bIsTrueType( &File, &dwTrueTypeTables, &dwStatus ) )
    {
        LPCTSTR pszDecoration = c_szTrueType;
        WORD    wFontType     = TRUETYPE_FONT;
        //
        // If the font has a CFF table, we append (OpenType) name decoration.
        //
        if (TT_TABLE_CFF & dwTrueTypeTables)
        {
            pszDecoration = c_szOpenType;
            wFontType     = OPENTYPE_FONT;
        }
        if( lpwFontType )
            *lpwFontType = wFontType;

        if( lpszDesc )
            wsprintf( lpszDesc, c_szDescFormat, File.szDesc, pszDecoration );

        if (NULL != lpdwStatus)
            *lpdwStatus = dwStatus;

        return TRUE;
    }
    else
    {
        //
        // Return FALSE if bIsTrueType failed for any reason other than
        // FVS_INVALID_FONTFILE.
        //
        if (FVS_STATUS(dwStatus) != FVS_INVALID_FONTFILE)
        {
            if (NULL != lpdwStatus)
                *lpdwStatus = dwStatus;

            return FALSE;
        }
    }


    if( ::IsPSFont( File.szFile, szDesc, (LPTSTR) NULL, (LPTSTR) NULL,
                    (BOOL *) NULL, &dwStatus ))
    {
        if( lpwFontType )
            *lpwFontType = TYPE1_FONT;

        if( lpszDesc )
            lstrcpy( lpszDesc, szDesc );

        if (NULL != lpdwStatus)
            *lpdwStatus = dwStatus;

        return TRUE;
    }
    else
    {
        //
        // Return FALSE if IsPSFont failed for any reason other than
        // FVS_INVALID_FONTFILE.
        //
        if (FVS_STATUS(dwStatus) != FVS_INVALID_FONTFILE)
        {
            if (NULL != lpdwStatus)
                *lpdwStatus = dwStatus;

            return FALSE;
        }
    }

    result = FALSE;

    if( AddFontResource( File.szFile ) )
    {
        //
        //  At this point it is a valid font file of some sort
        //  (like a .FON file); however, we are still looking for
        //  more validation using GetFontResourceInfoW call.
        //
        //  See if this is a TrueType font file
        //

        dwBufSize = sizeof( BOOL );

        result = GetFontResourceInfoW( File.szFile,
                                       &dwBufSize,
                                       &bTrueType,
                                       GFRI_ISTRUETYPE );

        if( bTrueType && lpwFontType )
            *lpwFontType = TRUETYPE_FONT;

        if( result )
        {
            if (NULL != lpszDesc)
            {
                LPWSTR pszResDesc;
                result = GetFontResourceDescription(File.szFile, &pszResDesc);
                if (result)
                {
                    vCPStripBlanks(pszResDesc);
                    if (bTrueType)
                    {
                        wsprintf(lpszDesc, c_szDescFormat, pszResDesc, c_szTrueType);
                    }
                    else
                    {
                        lstrcpy(lpszDesc, pszResDesc);
                    }
                    LocalFree(pszResDesc);
                    pszResDesc = NULL;
                }
            }
        }
        RemoveFontResource( File.szFile );
    }

    //
    // At this point, "result" indicates status of the FontResource tests.
    // If we've made it this far, this function just reports SUCCESS or INVALID_FONTFILE.
    //
    if (NULL != lpdwStatus)
        *lpdwStatus = (result ? FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK) :
                                FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK));

    return( result );


    bFOTOK;
}


         

#else  //  WINNT

//
// NOTE for NON-NT programmers.
// The argument lpdwStatus has been added to the function definition
// so that it will build with the changes made to the prototype.
// However, the argument is ignored in this NON-NT version of
// the function body.
//

BOOL FAR PASCAL bCPValidFontFile( LPCTSTR    lpszFile,
                                  LPTSTR     lpszDesc,
                                  BOOL FAR  *lpbTrueType,
                                  BOOL       bFOTOK,
                                  LPDWORD    lpdwStatus )
{
    FONTDESCINFO  File;
    LPTSTR        lpCh;
    BOOL          bTrueType = FALSE;
    BOOL          bValid = FALSE;
    DWORD         dwTrueTypeTables = 0;

    //
    //  Set up the FDI depending on what the caller wanted.
    //

    File.dwFlags = FDI_NONE;

    if( lpszDesc )
        File.dwFlags = FDI_DESC;

    //
    //  TODO: change this when windows gets fixed.
    //

#if 0
    lstrcpy( File.szFile, lpszFile );
#else
    {
        LPTSTR   lpTemp;

        GetFullPathName( lpszFile,
                         PATHMAX,
                         File.szFile,
                         &lpTemp );
    }
#endif

    //
    //  If we identify this as a new-type EXE file, we want to find
    //  the description portion within. For a valid file, the description
    //  should start with FONTRES, then some junk, then a colon, followed
    //  by the description we're going to use.
    //

    //
    // NOTE for NON-NT programmers.
    // The argument lpdwStatus has been added to the function call so that
    // it will compile with the modified bIsTrueType prototype.
    // See similar note at top of function.
    //
    if( bIsTrueType( &File, &dwTrueTypeTables, lpdwStatus ) )
    {
        bTrueType = TRUE;
        bValid    = TRUE;
    }
    else if( bIsNewExe( &File ) )
    {
        TCHAR cSave = File.szDesc[ 7 ];

        //
        //  This does not require DBCS
        //

        File.szDesc[ 7 ] = TEXT( '\0' );

        bValid = !lstrcmp( File.szDesc, TEXT( "FONTRES" ) );

        File.szDesc[ 7 ] = cSave;
    }

    //
    //  Prepare returns (if the caller is interested)
    //

    if( lpszDesc )
    {
        *lpszDesc = (TCHAR) 0;

        if( bTrueType )
            wsprintf( lpszDesc, c_szDescFormat, (LPTSTR) File.szDesc, (LPTSTR)c_szTrueType );
        else if( bValid )
        {
            if( bFOTOK )
            {
                lpCh = StrStr( File.szDesc + 7, TEXT( ":" ) );
            }
            else
            {
                lpCh = StrStr( File.szDesc + 8, TEXT( ":" ) );
            }

            //
            //  The lstrcpy call must be inside the if check because
            //  lpCh could be 0 from the StrStr call.
            //

            if( lpCh )
            {
                vCPStripBlanks( ++lpCh );
                lstrcpy( lpszDesc, lpCh );
            }
        }

        if( *lpszDesc == 0 )
            bValid = FALSE;
    }

    if( lpbTrueType )
        *lpbTrueType = bTrueType;

    return bValid;
}


#endif  //  WINNT




/***************************************************************************
 * End of public interfaces
 ***************************************************************************/

///////////////////////////////////////////////////////////////////////////////
// Determine if a True Type font file (.TTF) was converted from a Type1 font.
//
// The string "Converter: Windows Type 1 Installer" is stored in a TrueType file
// in the the version info section of the "name" block to indicate that
// the font was converted from a Type1 font.  This function reads this version
// info string from the caller-provided name block and determines if it matches
// the Type1 converter signature.
//
// Note that in the UNICODE section of the file, the converter signature
// string is stored in Big Endian byte order.  However, since bFindNameThing
// handles byte ordering and returns a TEXT string, we can just compare strings.
//
// WARNING:  Refererence \ntgdi\fondrv\tt\ttfd\fdfon.c for the actual
//           byte string that is written by GDI to the file upon conversion.
//
///////////////////////////////////////////////////////////////////////////////
BOOL NEAR PASCAL bIsConvertedTrueType(sfnt_pNameTable pNames, IDBlock_t& ID_Block)
{
    BOOL bStatus = FALSE;
    static TCHAR szTTFConverterSignature[] = TEXT("Converter: Windows Type 1 Installer");
    static UINT cchTTFConverterSignature   = ARRAYSIZE(szTTFConverterSignature);

    if (NULL != pNames)
    {
        FontDesc_t szVersionInfo;
        if( bFindNameThing( pNames, ID_Block, VERSION_ID, szVersionInfo ) )
        {
            //
            // Got version info string from "name" block.
            // Truncate to proper length for comparison with signature and compare.
            //
            szVersionInfo[cchTTFConverterSignature - 1] = TEXT('\0');
            bStatus = lstrcmp(szVersionInfo, szTTFConverterSignature) == 0;
        }
    }
    return bStatus;
}



BOOL NEAR PASCAL bGetName( CFontFile& file,
                           tttag *pTTTag,
                           IDBlock_t& ID_Block,
                           LPTSTR lpszName,
                           LPFONTDESCINFO lpFDI )
{
    sfnt_pNameTable pNames;
    WORD            size;
    TCHAR           szSubFamily[ 64 ];

    IDBlock_t       ID_DefBlock = ID_Block;


    ID_DefBlock.id_Language = (ID_DefBlock.id_Platform == PLATFORM_MS)
                                                         ? LANG_US_ENG : 0;

    size = (WORD) SWAPL( pTTTag->dwLength );

    *lpszName = 0;

    pNames = (sfnt_pNameTable) LocalAlloc( LPTR, size );

    if( pNames )
    {
        if (ERROR_SUCCESS == file.Read(pNames, size))
        {
            //
            //  The logic for what name to find:
            //  If font file was converted from a Type1 font
            //     1) POSTCRIPT_ID in current language
            //  else
            //     1) FACENAME_ID in current language.
            //  2) FAMILY and SUBFAMILY in current language.
            //  3) FACENAME_ID in default language.
            //
            // If the TrueType font was converted from a Type1 font, we want
            // to use the "postscript" form of the font description so that
            // it matches the description returned by IsPSFont() when invoked
            // on the "parent" Type1 file.  These descriptions are used as registry
            // keys in the "Fonts" and "Type1Fonts" sections and must match.
            //
            if (bIsConvertedTrueType(pNames, ID_Block) &&
                bFindNameThing(pNames, ID_Block, POSTSCRIPT_ID, lpszName))
            {
               //
               // Replace all dashes with spaces (same as .PFM/.INF file reader code)
               //
               for (LPTSTR pc = lpszName; *pc; pc++)
                 if (*pc == TEXT('-'))
                    *pc = TEXT(' ');
            }
            else if( bFindNameThing( pNames, ID_Block, FACENAME_ID, lpszName ) )
               ;
            else if( bFindNameThing( pNames, ID_Block, SUBFAMILY_ID, szSubFamily )
                 && (bFindNameThing( pNames, ID_Block,    FAMILY_ID, lpszName )
                 ||  bFindNameThing( pNames, ID_DefBlock, FAMILY_ID, lpszName ) ) )
            {
                lstrcat( lpszName, TEXT( " " ) );
                lstrcat( lpszName, szSubFamily );
            }
            else( bFindNameThing( pNames, ID_DefBlock, FACENAME_ID, lpszName ) )
                ;

            //
            //  Get the names for the font description if requested.
            //

            if( lpFDI )
            {
                if( lpFDI->dwFlags & FDI_FAMILY )
                {
                    lpFDI->szFamily[ 0 ] = 0;

                    if( !bFindNameThing( pNames, ID_Block, FAMILY_ID,
                                         lpFDI->szFamily ) )
                        bFindNameThing( pNames, ID_DefBlock, FAMILY_ID,
                                        lpFDI->szFamily );
                }

                if( lpFDI->dwFlags & FDI_VTC )
                {
                    TCHAR  szTemp[ 256 ];

                    lpFDI->lpszVersion   = 0;
                    lpFDI->lpszTrademark = 0;
                    lpFDI->lpszCopyright = 0;


                    if( bFindNameThing( pNames, ID_Block, VERSION_ID, szTemp ) ||
                       bFindNameThing( pNames, ID_DefBlock, VERSION_ID, szTemp ) )
                    {
                        lpFDI->lpszVersion = new TCHAR[ lstrlen( szTemp ) + 1 ];

                        if( lpFDI->lpszVersion )
                            lstrcpy( lpFDI->lpszVersion, szTemp );
                    }

                    if( bFindNameThing( pNames, ID_Block, COPYRIGHT_ID, szTemp ) ||
                       bFindNameThing( pNames, ID_DefBlock, COPYRIGHT_ID, szTemp ) )
                    {
                        lpFDI->lpszCopyright = new TCHAR[ lstrlen( szTemp ) + 1 ];

                        if( lpFDI->lpszCopyright )
                            lstrcpy( lpFDI->lpszCopyright, szTemp );
                    }

                    if( bFindNameThing( pNames, ID_Block, TRADEMARK_ID, szTemp ) ||
                       bFindNameThing( pNames, ID_DefBlock, TRADEMARK_ID, szTemp ) )
                    {
                        lpFDI->lpszTrademark = new TCHAR[ lstrlen( szTemp ) + 1 ];

                        if( lpFDI->lpszTrademark )
                            lstrcpy( lpFDI->lpszTrademark, szTemp );
                    }
                }

            }
        }
        LocalFree( (HANDLE)pNames );
   }

   return *lpszName != 0;
}


void NEAR PASCAL FillName( LPTSTR            szName,
                           sfnt_lpNameRecord pNameRecord, // unsigned PlatformID,
                           WORD              igi,
                           LPBYTE            pStringByte )
{
    WORD    i;
    WORD    wName[ 64 ];
    BOOL    bUsedDefault;
    LPSTR   lpSrc;
    LPTSTR  lpDest;
    LPSTR   lpByteStr;

    WORD UNALIGNED *pStringWord;


    if( pNameRecord->wPlatformID == PLATFORM_MS )
    {
        //
        //  wName now contains the flipped bytes.
        //  Decode depending on the way the string was encoded.
        //
        //  Rules:
        //     Encodind ID=1 (Unicode)
        //        Unicode
        //
        //     Encoding ID=2 (ShiftJIS)
        //        Unicode
        //
        //     Encoding ID=3 (PRC GB2312)
        //        Uses two bytes per character and GB2312 encoding. Single byte
        //        characters need null padding for leading byte.
        //
        //     Encoding ID=4 (Big 5)
        //        Uses two bytes per character and Big 5 encoding. Single byte
        //        characters need null padding for leading byte.
        //
        //     Encoding ID=5 (Wangsung)
        //        Uses two bytes per character and Wangsung encoding. Single byte
        //        characters need null padding for leading byte.
        //
        //     Encoding ID=6 (Johab)
        //        Uses two bytes per character and Johab encoding. Single byte
        //        characters need null padding for leading byte.
        //

        switch( pNameRecord->wSpecificID )
        {
        case ENCODEID_PRC:
        case ENCODEID_BIG5:
        case ENCODEID_WANGSUNG:
        case ENCODEID_JOHAB:
            if (g_bDBCS)
            {
                lpSrc = (LPSTR)pStringByte;

                lpByteStr = (LPSTR)wName;

                for( i = 0; i < igi; i++ )
                {
                    if( IsDBCSLeadByte( *lpSrc ) )
                    {
                        *lpByteStr++ = (CHAR) *lpSrc++;
                        i++;
                    }
                    else if( !*lpSrc )
                    {
                        lpSrc++;
                        i++;
                    }

                    *lpByteStr++ = *lpSrc++;
                }

                *lpByteStr = (BYTE) 0;

#ifdef UNICODE
                MultiByteToWideChar(CP_ACP,0,(LPSTR)wName,-1,szName,64);
#else
                lstrcpy(szName,(LPSTR)wName);
#endif // UNICODE

            }
            else // !g_bDBCS
            {
                lpSrc  = (LPSTR)pStringByte;

                lpDest = szName;

                for( i = 0; i < igi; i++ )
                {
                    if( IsDBCSLeadByte( *lpSrc ) )
                    {
                        *lpDest++ = (TCHAR) *lpSrc++;
                        i++;
                    }
                    else if( !*lpSrc )
                    {
                        lpSrc++;
                        i++;
                    }

                    *lpDest++ = (TCHAR) *lpSrc++;
                }

                *lpDest = (TCHAR) 0;
            }

            break;


         default:
            if( igi >= sizeof( wName ) )
                igi = sizeof( wName ) - sizeof( wName[ 0 ] );

            igi /= sizeof( wName[ 0 ] );

            pStringWord = (PWORD) pStringByte;

            WORD wLen = igi;

#ifdef UNICODE

            wName[ igi ] = 0;

            szName[ igi ] = TEXT( '\0' );

            while( igi--)
            {
                wName[ igi ] = SWAPW( pStringWord[ igi ] );

                szName[ igi ] = wName[ igi ];
            }

#else

            while( igi--)
                wName[ igi ] = SWAPW( pStringWord[ igi ] );

            int iRet = WideCharToMultiByte( CP_ACP,
                                            0,          // WC_SEPCHARS,
                                            wName,
                                            wLen,       // -1,
                                            szName,
                                            2 * (wLen + 1),
                                            NULL,
                                            &bUsedDefault );
            szName[ iRet ] = 0;

#endif  // UNICODE

        }  // End of switch( )

    }
    else
    {
        //
        //  Mac font
        //

        szName[ igi ] = (TCHAR) 0;

        while( igi--)
            szName[ igi ] = Mac2Ansi( pStringByte[ igi ] );
    }
}



DWORD GetFontDefaultLangID( )
{
    //
    //  set it initally to illegal value
    //

    static DWORD dwLangID = 0xffffffff;


    //
    //  Only do this once
    //

    if( dwLangID == 0xffffffff )
    {
        //
        //  Default to English
        //

        DWORD dwTemp = 0x00000409;

#ifdef WINNT

        TCHAR   szModName[ PATHMAX ];
        DWORD   dwSize, dwHandle;
        LPVOID  lpvBuf;


        if( GetModuleFileName( g_hInst, szModName, PATHMAX ) )
        {
            if( dwSize = GetFileVersionInfoSize( szModName, &dwHandle ) )
            {
                if( lpvBuf = (LPVOID) LocalAlloc( LPTR, dwSize ) )
                {
                    if( GetFileVersionInfo( szModName, dwHandle, dwSize, lpvBuf ) )
                    {
                        struct
                        {
                            WORD wLang;
                            WORD wCodePage;
                        } *lpTrans;

                        UINT uSize;

                        if( VerQueryValue( lpvBuf,
                                           TEXT( "\\VarFileInfo\\Translation" ),
                                           (LPVOID *) &lpTrans,
                                           &uSize )
                            && uSize >= sizeof( *lpTrans ) )
                        {
                            dwTemp = lpTrans->wLang;
                        }
                    }
                    LocalFree( (HLOCAL) lpvBuf );
                }
            }
        }

#else

        HRSRC hrsVer = FindResource( g_hInst, (LPTSTR) VS_VERSION_INFO,
                                     RT_VERSION );

        if( hrsVer )
        {
            HGLOBAL hVer = LoadResource( g_hInst, hrsVer );

            if( hVer )
            {
                LPVOID lpVer = LockResource( hVer );

                if( lpVer )
                {
                    struct
                    {
                        WORD wLang;
                        WORD wCodePage;
                    } *lpTrans;

                    UINT uSize;

                    if( VerQueryValue( lpVer,
                                       TEXT( "\\VarFileInfo\\Translation" ),
                                       (LPVOID *) &lpTrans,
                                       &uSize )
                        && uSize >= sizeof( *lpTrans ) )
                    {
                        dwTemp = lpTrans->wLang;
                    }

                    UnlockResource( hVer );
                }

                FreeResource( hVer );
            }
        }

#endif  //  WINNT

        //
        //  Use dwTemp so this is re-entrant (if not efficient)
        //

        dwLangID = dwTemp;
    }

    return( dwLangID );
}

///////////////////////////////////////////////////////////////////////////////
//
//  bValidateTrueType
//
//  The following list contains the possible status values
//  written to lpdwStatus. See fvscodes.h for details.
//
//  FVS_SUCCESS
//  FVS_INVALID_FONTFILE
//  FVS_MEM_ALLOC_ERR
//
///////////////////////////////////////////////////////////////////////////////
BOOL bValidateTrueType( CFontFile& file,
                        DWORD dwOffset,
                        LPFONTDESCINFO lpFile,
                        DWORD *pdwTableTags,
                        LPDWORD lpdwStatus )
{
    struct cmap_thing {
        sfnt_char2IndexDir    DirCmap;
        sfnt_platformEntry    Plat[ 2 ];
    } Cmap;

    tt_hdr     TTHeader;
    tt_head    TTFontHeader;

    IDBlock_t  ID_Block;
    tttag*     pTags;

    sfnt_platformEntry FAR* lpPlat;

    short      i, nTables;
    DWORD      dwSize;
    unsigned   cTables, ncTables;
    BOOL       result = FALSE;
    //
    // Most errors from this function are "header" errors.
    // Therefore, we default to this type of error code.
    //
    DWORD      dwStatus = FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);

    //
    // Initialize return status value.
    //
    if (NULL != lpdwStatus)
        *lpdwStatus = FVS_MAKE_CODE(FVS_INVALID_STATUS, FVS_FILE_UNK);

    //
    //  Init the ID block.
    //

    ID_Block.id_Platform = (WORD) -1;

    WORD wLangID = (WORD) GetFontDefaultLangID( );

    ID_Block.id_Language = SWAPW( wLangID );   // SWAPW( info.nLanguageID );

    //
    //  Load the TTF directory header.
    //
    file.Seek(dwOffset, FILE_BEGIN);

    if (ERROR_SUCCESS != file.Read(&TTHeader, sizeof(TTHeader)))
        goto IsTrueType_closefile;

    //
    //  If number of tables is so large that LocalAlloc fails, then the font
    //  will be blown off.
    //

    if( ( nTables = SWAPW( TTHeader.uNumTables ) ) > 0x7fff / sizeof( tttag ) )
    {
        DEBUGMSG( ( DM_ERROR, TEXT( "bIsTrueType: header too large." ) ) );
        goto IsTrueType_closefile;
    }

    i = nTables * sizeof( tttag );

    if( !(pTags = (tttag *) LocalAlloc( LPTR, i ) ) )
    {
        DEBUGMSG( ( DM_ERROR, TEXT( "bIsTrueType( ): LocalAlloc failed." ) ) );
        dwStatus = FVS_MAKE_CODE(FVS_MEM_ALLOC_ERR, FVS_FILE_UNK);
        goto IsTrueType_closefile;
    }

    if (ERROR_SUCCESS != file.Read(pTags, i))
    {
        DEBUGMSG( ( DM_ERROR, TEXT( "bIsTrueType(): File READ failure" ) ) );
        goto FailAndFree;
    }

    //
    //  the tables are in sorted order, so we should find 'cmap'
    //  before 'head', then 'name'
    //

    //  first we find the cmap table so we can find out what PlatformID
    //  this font uses
    //

    for( i = 0; i < nTables; i++ )
    {
        if( pTags[ i ].dwTag == TAG_CHARTOINDEXMAP )
        {
            //
            //  get platform stuff
            //
            file.Seek(SWAPL(pTags[ i ].dwOffset), FILE_BEGIN);

            if (ERROR_SUCCESS != file.Read(&Cmap, sizeof(Cmap), &dwSize))
                break;
            else if( ( ncTables = SWAPW( Cmap.DirCmap.wNumTables ) ) == 1 )
            {
                if( dwSize < sizeof( Cmap )-sizeof( Cmap.Plat[ 1 ] ) )
                    break;
            }

            for( cTables = 0; cTables < ncTables; cTables++ )
            {
                //
                //  we read 2 platform entries at a time
                //

                if( cTables >= 2 && !(cTables & 1 ) )
                {
                    dwSize = ncTables-cTables>1 ? sizeof( Cmap.Plat )
                                                : sizeof( Cmap.Plat[ 0 ]);

                    if (ERROR_SUCCESS != file.Read(Cmap.Plat, dwSize))
                        break;
                }

                lpPlat = &Cmap.Plat[ cTables & 01 ];

                //
                //  Unicode: get this and exit
                //

                if( lpPlat->wPlatformID == PLATFORM_MS )
                {
                    DEBUGMSG( (DM_TRACE1, TEXT( "--- PlatformID is PLATFORM_MS" ) ) );

                    ID_Block.id_Platform = lpPlat->wPlatformID;
                    ID_Block.id_Specific = lpPlat->wSpecificID;
                    break;
                }

                //
                //  Mac: get it, hope the Unicode platform will come
                //

                if( lpPlat->wPlatformID == 0x100 && lpPlat->wSpecificID == 0 )
                {
                    ID_Block.id_Platform = lpPlat->wPlatformID;
                    ID_Block.id_Specific = lpPlat->wSpecificID;
                }
            }
            break; // found continue below
        }
    }

    if( ID_Block.id_Platform == (WORD)-1 )
    {
        DEBUGMSG( ( DM_ERROR, TEXT( "bIsTrueType( ): No platform id" ) ) );
        goto FailAndFree;
    }

    //
    //  we found 'cmap' with the PlatformID now look for 'head'
    //  then 'name'

    while( ++i < nTables )
    {
        if( pTags[ i ].dwTag == TAG_FONTHEADER )
        {
            file.Seek(SWAPL( pTags[ i ].dwOffset ), FILE_BEGIN);

            if (ERROR_SUCCESS != file.Read(&TTFontHeader, sizeof(TTFontHeader))
                || TTFontHeader.dwMagic != SFNT_MAGIC )
            {
                DEBUGMSG( (DM_ERROR, TEXT( "WRONG MAGIC! : %x" ), TTFontHeader.dwMagic ) );
                goto FailAndFree;
            }
            break;
        }
    }

    //
    //  At this point, the function is successful. If the caller wants a
    //  description and can't get it, return false (see next block).
    //

    result = TRUE;

    //
    //  Retrieve the font name (description) and family name if they were
    //  requested.
    //

    if( lpFile->dwFlags & (FDI_DESC | FDI_FAMILY ) )
    {
        while( ++i < nTables )
        {
            if( pTags[ i ].dwTag == TAG_NAMINGTABLE )
            {
                file.Seek(SWAPL( pTags[ i ].dwOffset ), FILE_BEGIN);
                result = bGetName( file, &pTags[ i ], ID_Block, lpFile->szDesc,
                                   lpFile );

                break;
            }
       }
    }

    //
    //  if requested, get the style and PANOSE information.
    //

    if( lpFile->dwFlags & (FDI_STYLE | FDI_PANOSE ) )
    {
        for( i = 0; i < nTables; i++ )
        {
            if( pTags[ i ].dwTag == TAG_OS2TABLE )
            {

#define WEIGHT_OFFSET   4
#define PAN_OFFSET      32
#define SEL_OFFSET      62

                DWORD dwStart = SWAPL( pTags[ i ].dwOffset );

                if( lpFile->dwFlags & FDI_PANOSE )
                {
                    file.Seek(dwStart + PAN_OFFSET, FILE_BEGIN);
                    file.Read(lpFile->jPanose, PANOSE_LEN);
                }

                if( lpFile->dwFlags & FDI_STYLE )
                {
                    WORD  wTemp;

                    file.Seek(dwStart + WEIGHT_OFFSET, FILE_BEGIN);
                    file.Read(&wTemp, sizeof(wTemp));

                    lpFile->wWeight = SWAPW( wTemp );

                    file.Seek(dwStart + SEL_OFFSET, FILE_BEGIN);
                    file.Read(&wTemp, sizeof(wTemp));

                    wTemp = SWAPW( wTemp );

                    lpFile->dwStyle  = (wTemp & 0x0001) ? FDI_S_ITALIC
                                                        : FDI_S_REGULAR;

                    lpFile->dwStyle |= (wTemp & 0x0020) ? FDI_S_BOLD : 0;
                }
                break;
            }
        }
    }

    if (NULL != pdwTableTags)
    {
        //
        // Caller want's to know exactly what tables the font contains.
        // Would prefer to do this in one of the earlier loops but they
        // all have early exits.  This is the only reliable way to get the
        // table info.  It's merely comparing DWORDs so it's very fast.
        //
        *pdwTableTags = 0;
        for (int i = 0; i < nTables; i++)
        {
            switch(pTags[i].dwTag)
            {
                case TAG_CHARTOINDEXMAP:  *pdwTableTags |= TT_TABLE_CMAP; break;
                case TAG_FONTHEADER:      *pdwTableTags |= TT_TABLE_HEAD; break;
                case TAG_NAMINGTABLE:     *pdwTableTags |= TT_TABLE_NAME; break;
                case TAG_OS2TABLE:        *pdwTableTags |= TT_TABLE_OS2;  break;
                case TAG_DSIG:            *pdwTableTags |= TT_TABLE_DSIG; break;
                case TAG_CFF:             *pdwTableTags |= TT_TABLE_CFF;  break;
                default:
                    break;
            }
        }
    }

FailAndFree:

    LocalFree( (HANDLE) pTags );

IsTrueType_closefile:

    //
    // If successful, update verification status for success.
    // Otherwise, leave at assigned error code.
    //
    if (NULL != lpdwStatus)
        *lpdwStatus = (result ? FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK) : dwStatus);

    return result;
}


///////////////////////////////////////////////////////////////////////////////
//
//  bIsTrueType
//
//  The following list contains the possible status values
//  written to lpdwStatus. See fvscodes.h for details.
//
//  FVS_SUCCESS
//  FVS_INVALID_FONTFILE
//  FVS_MEM_ALLOC_ERR
//  FVS_FILE_OPEN_ERR
//  FVS_INSUFFICIENT_BUF
//
///////////////////////////////////////////////////////////////////////////////
BOOL NEAR PASCAL bIsTrueType( LPFONTDESCINFO lpFile, DWORD *pdwTableTags, LPDWORD lpdwStatus )
{
    ttc_hdr     TTCHeader;
    CFontFile   file;
    DWORD       i;
    BOOL        result = FALSE;
    DWORD       *pdwDirectory = 0;
    FontDesc_t  szFontDesc;
    TCHAR       szConcat[ 32 ];


    DEBUGMSG( (DM_TRACE1, TEXT( "bIsTrueType() checking file %s" ), lpFile->szFile ) );

    if (ERROR_SUCCESS != file.Open(lpFile->szFile, GENERIC_READ, FILE_SHARE_READ))
    {
        if (NULL != lpdwStatus)
            *lpdwStatus = FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_UNK);

        return( FALSE );
    }

    //
    // If any of this code causes return of FALSE,
    // we return INVALID_FONTFILE unless indicated otherwise by
    // explicitely setting the return code.
    //
    if (NULL != lpdwStatus)
        *lpdwStatus = FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);

    if(ERROR_SUCCESS != file.Read(&TTCHeader, sizeof(TTCHeader)))
        goto IsTrueType_closefile;

    //
    //  Check for a TTC file.
    //

    if( TTCHeader.dwTag == TAG_TTCF )
    {
       if( !LoadString( g_hInst, IDS_TTC_CONCAT, szConcat, ARRAYSIZE( szConcat ) ) )
            lstrcpy( szConcat, TEXT( " & " ) );

       TTCHeader.dwDirCount  = SWAPL( TTCHeader.dwDirCount );

       //
       //  Load in the first directory, for now.
       //

       if( !TTCHeader.dwDirCount )
            goto IsTrueType_closefile;

       pdwDirectory = new DWORD [ TTCHeader.dwDirCount ];

       if( !pdwDirectory )
            goto IsTrueType_closefile;

       file.Seek(sizeof(TTCHeader), FILE_BEGIN);

       DWORD dwBytesToRead = sizeof( DWORD ) * TTCHeader.dwDirCount;

       if(ERROR_SUCCESS != file.Read(pdwDirectory, dwBytesToRead))
            goto IsTrueType_closefile;
    }
    else
    {
        TTCHeader.dwDirCount = 1;

        pdwDirectory = new DWORD [ 1 ];

        if( !pdwDirectory )
            goto IsTrueType_closefile;

        *pdwDirectory = 0;
    }

    //
    //  For each TrueType directory, process it.
    //

    szFontDesc[ 0 ] = 0;

    for( i = 0; i < TTCHeader.dwDirCount; i++ )
    {
        //
        //  Save of the description of the previous font.
        //

        if( i && ( lpFile->dwFlags & FDI_DESC ) )
        {
           vCPStripBlanks(lpFile->szDesc);
           if( ( lstrlen( szFontDesc ) + lstrlen( lpFile->szDesc )
                 + lstrlen( szConcat ) + 1 ) > ARRAYSIZE( szFontDesc ) )
           {
                if (NULL != lpdwStatus)
                    *lpdwStatus = FVS_MAKE_CODE(FVS_INSUFFICIENT_BUF, FVS_FILE_UNK);

                //
                // This is a coding error.  Complain about it.
                //
                ASSERT(FALSE);
                goto IsTrueType_closefile;
           }

           lstrcat( szFontDesc, lpFile->szDesc );

           lstrcat( szFontDesc, szConcat );
        }

        if( !bValidateTrueType( file, SWAPL( *(pdwDirectory + i ) ), lpFile, pdwTableTags, lpdwStatus ) )
            goto IsTrueType_closefile;
    }

    //
    //  If we did more than one font, then we have to add the name of the
    //  last one to the list.
    //

    if( TTCHeader.dwDirCount > 1 )
    {
        if( lpFile->dwFlags & FDI_DESC )
        {
            vCPStripBlanks(lpFile->szDesc);
            if( ( lstrlen( szFontDesc ) + lstrlen( lpFile->szDesc )
                  + lstrlen( szConcat ) + 1 ) > ARRAYSIZE( szFontDesc ) )
                goto IsTrueType_closefile;

          lstrcat( szFontDesc, lpFile->szDesc );

          lstrcpy( lpFile->szDesc, szFontDesc );
        }
    }

    result = TRUE;

IsTrueType_closefile:

    if( pdwDirectory )
        delete [] pdwDirectory;

    DEBUGMSG( (DM_TRACE1, TEXT( "bIsTrueType() returning %d" ), result ) );

    //
    // If successful, update verification status.
    // Otherwise, leave at assigned error code.
    //
    if ((NULL != lpdwStatus) && result)
        *lpdwStatus = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);

    return result;
}



void NEAR PASCAL vReadCountedString( CFontFile& file, LPSTR lpString, int iLen )
{
    char cBytes;

    file.Read(&cBytes, 1);

    //
    //  Limit check 6 August 1990    clarkc
    //

    cBytes = __min( cBytes, iLen-1 );

    file.Read(lpString, cBytes);

    *(lpString + cBytes) = 0;
}


BOOL bReadNewExeInfo( CFontFile& file,
                      struct new_exe * pne,
                      long             lHeaderOffset,
                      LPFONTDESCINFO   lpFile )
{
    LONG  lResTable = pne->ne_rsrctab + lHeaderOffset;
    BOOL  bRet = FALSE;
    WORD  wShiftCount;

    struct rsrc_typeinfo rt;
    struct rsrc_nameinfo ri;

    LPFONTENTRY pfe;


    //
    //  Fix up the lpFile in case we bail early.
    //

    lpFile->lpszVersion = lpFile->lpszCopyright = lpFile->lpszTrademark = 0;

    //
    //  Move to the beginning of the resource table.
    //

    file.Seek(lResTable, FILE_BEGIN);

    //
    //  Read the shift count.
    //
    if(ERROR_SUCCESS != file.Read(&wShiftCount, 2))
        goto backout;

    //
    //  Quick validity check.
    //

    if( wShiftCount > 12 )
        goto backout;

    //
    //  Read the resources until we hit the FONTDIR
    //

    while( TRUE )
    {
        memset( &rt, 0, sizeof( rt ) );

        if(ERROR_SUCCESS != file.Read(&rt, sizeof(rt)))
            goto backout;

        if( rt.rt_id == 0 )
            break;

        if( M_INTEGERTYPE( rt.rt_id ) && M_FONTDIRTYPE( rt.rt_id ) )
        {
            //
            //  Read one resinfo record. We don't need all of them. The
            //  style and name of all should be the same.
            //

            if (ERROR_SUCCESS != file.Read(&ri, sizeof(ri)))
                goto backout;


            LONG lOffset = ( (LONG) ri.rn_offset ) << wShiftCount;
            LONG lSize   = ( (LONG) ri.rn_length ) << wShiftCount;

            //
            //  Allocate memory for the resource.
            //

            LPSTR lpMem = new char [ lSize ];


            if( !lpMem )
                goto backout;

            file.Seek(lOffset, FILE_BEGIN);

            LPSTR lpTMem = lpMem;

            while( lSize )
            {
                WORD wSize;

                if( lSize >= 32767 )
                   wSize = 32767;
                else
                   wSize = (WORD) lSize;

                if (ERROR_SUCCESS != file.Read(lpTMem, wSize))
                {
                   delete lpMem;
                   goto backout;
                }

                lSize -= wSize;
                lpTMem += wSize;
            }

            //
            //  The first word is the font count and the rest is a chunk of
            //  font entries.
            //

            int nFonts = (int)*( (unsigned short *) lpMem );

            pfe = (LPFONTENTRY) (lpMem + sizeof( WORD ) );

            if( lpFile->dwFlags & FDI_STYLE )
            {
               lpFile->dwStyle = (pfe->dfItalic ) ? FDI_S_ITALIC : FDI_S_REGULAR;

               lpFile->wWeight = pfe->dfWeight;
            }

            if( lpFile->dwFlags & FDI_FAMILY )
            {
                LPSTR lpFace;
                LPSTR lpDev = pfe->szDeviceName;

                lpFace = lpDev + lstrlenA( lpDev ) + 1;

#ifdef UNICODE
                MultiByteToWideChar( CP_ACP, 0, lpFace, -1,
                                     lpFile->szFamily, PATHMAX );

#else

                strcpy( lpFile->szFamily, lpFace );

#endif  //  UNICODE
            }

            if( lpFile->dwFlags & FDI_VTC )
            {
                //
                //  No version or trademark. Get the copyright.
                //

                lpFile->lpszCopyright = new TCHAR[ COPYRIGHT_LEN ];

#ifdef UNICODE
                if( lpFile->lpszCopyright )
                    MultiByteToWideChar( CP_ACP, 0, pfe->dfCopyright, -1,
                                         lpFile->lpszCopyright, COPYRIGHT_LEN );

#else
                if( lpFile->lpszCopyright )
                    strcpy( lpFile->lpszCopyright, pfe->dfCopyright );

#endif  //  UNICODE
            }

            bRet = TRUE;
            delete lpMem;

            //
            //  We got one, get out of here.
            //

            break;
        }
    }

backout:
    return bRet;
}

BOOL NEAR PASCAL bIsNewExe( LPFONTDESCINFO lpFile )
{
    BOOL     bValid = FALSE;
    long     lNewHeader;
    CFontFile file;

    struct exe_hdr oeHeader;
    struct new_exe neHeader;


    if (ERROR_SUCCESS == file.Open(lpFile->szFile, GENERIC_READ, FILE_SHARE_READ))
    {
        file.Read(&oeHeader, sizeof(oeHeader));

        if( oeHeader.e_magic == EMAGIC && oeHeader.e_lfanew )
            lNewHeader = oeHeader.e_lfanew;
        else
            lNewHeader = 0L;

        file.Seek(lNewHeader, FILE_BEGIN);

        file.Read(&neHeader, sizeof(neHeader));

        if( neHeader.ne_magic == NEMAGIC )
        {
            //
            // seek to the description, and read it
            //
            file.Seek(neHeader.ne_nrestab, FILE_BEGIN);

#ifdef UNICODE
            char szTemp[ DESCMAX ];

            vReadCountedString( file, szTemp, DESCMAX );

            MultiByteToWideChar( CP_ACP, 0, szTemp, -1,
                                     lpFile->szDesc, DESCMAX );

#else

            vReadCountedString( fh, lpFile->szDesc, sizeof( lpFile->szDesc ) );

#endif  //  UNICODE

            bValid = TRUE;

            //
            //  If requested, get family and style information.
            //

            if( lpFile->dwFlags & (FDI_FAMILY | FDI_STYLE | FDI_VTC ) )
            {
                bValid = bReadNewExeInfo( file, &neHeader, lNewHeader, lpFile );
            }
        }
    }

    return bValid;
}


//
//  find a TT name matching the platform specific and language from
//  the name table
//
//  in:
//     pNames        name table to search
//     PlatformID    search for this
//     SpecificID    and this
//     uLanguageID    and this
//     NameID        this is the name type
//
//  out:
//     szName        name if found
//
//  returns:
//     TRUE    name found, szName contains the name
//     FALSE    name not found, szName is NULL
//

BOOL NEAR PASCAL bFindNameThing( sfnt_pNameTable pNames, IDBlock_t &ID_Block,
                                 WORD NameID, LPTSTR szName )
{
    sfnt_lpNameRecord pNameRecord;

    sfnt_lpNameRecord pFoundRecord = NULL;

    int     cNames;
    LPBYTE  pStringArea;
    WORD    wWantLang = SWAPW( ID_Block.id_Language );


    szName[ 0 ] = 0;

    //
    //  Verify that this, indeed, is a name thing. The format should be zero.
    //

    if( pNames->wFormat )
        return FALSE;

    cNames = SWAPW( pNames->wCntRecords );

    pNameRecord = (sfnt_pNameRecord)( (LPBYTE) pNames + sizeof( sfnt_NameTable ) );

    for( ; cNames--; pNameRecord++ )
    {
        if( pNameRecord->wPlatformID == ID_Block.id_Platform &&
            pNameRecord->wSpecificID == ID_Block.id_Specific &&
            pNameRecord->wNameID     == NameID )
        {
            //
            //  Check the language matches
            //

            WORD wFoundLang = SWAPW( pNameRecord->wLanguageID );

            if( PRIMARYLANGID( wFoundLang ) != PRIMARYLANGID( wWantLang ) )
            {
                continue;
            }

            pFoundRecord = pNameRecord;

            //
            //  Check the locale matches too
            //

            if( pNameRecord->wLanguageID == ID_Block.id_Language )
            {
                break;
            }
        }
    }

    if( pFoundRecord )
    {
        pNameRecord = pFoundRecord;

        pStringArea  = (LPBYTE) pNames;
        pStringArea += SWAPW( pNames->wOffsetString );
        pStringArea += SWAPW( pNameRecord->wOffset );

        FillName( szName, pNameRecord, //->wPlatformID,
                  SWAPW( pNameRecord->wLength ), pStringArea );

        return TRUE;
    }

    DEBUGMSG( (DM_ERROR, TEXT( "bFindNameThing(): ERROR!" ) ) );
    DEBUGMSG( (DM_ERROR, TEXT( "--- Platform: %x  Specific: %x   Language: %x" ),
            ID_Block.id_Platform, ID_Block.id_Specific, ID_Block.id_Language) );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\instfls.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// instfls.cpp
//      Explorer Font Folder extension routines
//    This file holds all the code for installing any kind of file.
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include "lstrfns.h"
#include "ui.h"
#include "cpanel.h"
#include "resource.h"

#include "dbutl.h"

#ifdef DEBUG
// Disk Space Check
//#define DISKCHK
#endif

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

/*****************************************************/
/******************** Globals ************************/
/*****************************************************/

extern FullPathName_t  s_szSharedDir;
extern TCHAR           szDirOfSrc[ PATHMAX ];  // For installing

LPTSTR    pszWinDir = s_szSharedDir;
LPTSTR    pszSysDir = s_szSharedDir;

UINT  s_wBrowseDoneMsg;

TCHAR szTestOpen[] = TEXT( "a:a" );
TCHAR szDisks[]    = TEXT( "Disks" );
TCHAR szOEMDisks[] = TEXT( "OEMDisks" );
TCHAR szNull[]     = TEXT( "" );

HWND  ghwndFontDlg;

/* extern */

TCHAR szDrv[ PATHMAX ];

extern TCHAR szSetupInfPath[];
extern TCHAR szSetupDir[];

#ifdef JAPAN
extern HWND ghWndPro;
#endif


/*****************************************************/
/******************** Defines ************************/
/*****************************************************/


#define RECOVERABLEERROR (VIF_SRCOLD | VIF_DIFFLANG | VIF_DIFFCODEPG | VIF_DIFFTYPE)
#define UNRECOVERABLEERROR (VIF_FILEINUSE | VIF_OUTOFSPACE | VIF_CANNOTCREATE | VIF_CANNOTDELETE | VIF_CANNOTRENAME | VIF_OUTOFMEMORY | VIF_CANNOTREADDST)
#define READONLY (1)


/*****************************************************/
/******************** Functions **********************/
/*****************************************************/


/* Fill in the lpName string with the name of the disk specified
 * in the lpDisk string.  This name is retrieved from the [disks]
 * or [oemdisks] section of setup.inf.
 * Returns: TRUE if name was found, FALSE otherwise
 * Assumes: lpName buffer is at least PATHMAX bytes
 */

BOOL NEAR PASCAL GetInstDiskName( LPTSTR lpDisk, LPTSTR lpName, UINT cchName )
{
    if( GetPrivateProfileString( szDisks, lpDisk, szNull, lpName,
                                 cchName, szSetupInfPath ) )
      return( TRUE );

    return( GetPrivateProfileString( szOEMDisks, lpDisk, szNull, lpName,
                                     cchName, szSetupInfPath ) != 0 );
}


BOOL FAR PASCAL IsDriveReady( LPTSTR lpszPath )
{
    OFSTRUCT ofstruct;
    BOOL bReady;
//  MSG msg;


    szTestOpen[ 0 ] = lpszPath[ 0 ];
    szTestOpen[ 1 ] = lpszPath[ 1 ];

#ifdef WINNT

    bReady = MyOpenFile( szTestOpen[ 1 ] == TEXT( ':' )
                            ? szTestOpen
                            : szTestOpen + 2,
                            NULL,
                            OF_PARSE ) != (HANDLE) INVALID_HANDLE_VALUE;

    if( bReady )
        bReady = MyOpenFile( lpszPath, NULL, OF_EXIST )
                        != (HANDLE) INVALID_HANDLE_VALUE;

#else

    bReady = OpenFile( !IsDBCSLeadByte( szTestOpen[ 0 ] )
                        && szTestOpen[ 1 ] == TEXT( ':' )
                            ? szTestOpen
                            : szTestOpen + 2,
                            &ofstruct,
                            OF_PARSE ) != -1;

    if( bReady )
        bReady = OpenFile( lpszPath, &ofstruct, OF_EXIST ) != -1;

#endif  //  WINNT

#if 0
    //
    //  Repaint our window if necessary, and let everybody else do the same
    //

    while( PeekMessage( &msg, NULL, WM_PAINT, WM_PAINT, PM_REMOVE ) )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
#endif

    return( bReady );
}


//
//  Hooks into common dialog to show only directories
//

UINT_PTR CALLBACK AddFileHookProc( HWND hDlg, UINT iMessage,
                               WPARAM wParam, LPARAM lParam )
{
    HWND hTemp;

    switch( iMessage )
    {
        case WM_INITDIALOG:
        {
            TCHAR szTemp[ 200 ];

            GetDlgItemText( ((LPOPENFILENAME)lParam)->hwndOwner, IDRETRY,
                            szTemp, ARRAYSIZE( szTemp ) );
            SetDlgItemText( hDlg, ctlLast+1, szTemp );

            goto PostMyMessage;
        }

        case WM_COMMAND:
            switch( wParam )
            {
                case lst2:
                case cmb2:
                case IDOK:
PostMyMessage:
                  PostMessage( hDlg, WM_COMMAND, ctlLast+2, 0L );
                  break;

                case pshHelp:
                    //
                    //  Enable this if a decision is made to add the help
                    //  information.
                    //
                    // WinHelp( hWnd, TEXT( "WINDOWS.HLP" ), HELP_CONTEXT,
                    //          IDH_WINDOWS_FONTS_BROWSE_31HELP );
                    //

                    return TRUE;
                    break;

                case ctlLast+2:
                    if( SendMessage( hTemp = GetDlgItem( hDlg, lst1 ),
                                     LB_GETCOUNT, 0, 0L ) )
                    {
                        SendMessage( hTemp, LB_SETCURSEL, 0, 0L );

                        SendMessage( hDlg, WM_COMMAND, lst1,
                                     MAKELONG( hTemp, LBN_SELCHANGE ) );
                        break;
                    }

                    SetDlgItemText( hDlg, edt1, szDrv );
                    break;
            }

            break;

        default:
            if( iMessage == s_wBrowseDoneMsg )
            {
                OFSTRUCT of;
                int fh;

                if( ( fh = LZOpenFile( szDrv, &of, OF_READ ) ) == -1 )
                {
                    iUIMsgExclaim(hDlg, IDSI_FMT_FILEFNF, (LPTSTR)szDrv );

                    //
                    //  return TRUE so commdlg does not exit
                    //
                    return( TRUE );
                }

                LZClose( fh );
            }
            break;
    }

    return FALSE;  // commdlg, do your thing
}


short nDisk=TEXT( 'A' );


VOID NEAR PASCAL FormatAddFilePrompt( LPTSTR szStr2 )
{
    TCHAR  szString[ 256 ], szStr3[ 200 ];
    LPTSTR pszStart, pszEnd;

    //
    //  Set the prompt to specify the disk
    //

    if( nDisk && GetInstDiskName( (LPTSTR)&nDisk, szStr3, ARRAYSIZE(szStr3) )
          && (pszStart = StrChr( szStr3, TEXT( '"' ) ) )
          && (pszEnd = StrChr( ++pszStart, TEXT( '"' ) ) ) )
    {
        *pszEnd = TEXT( '\0' );

        LoadString( g_hInst, INSTALLIT, szString, ARRAYSIZE( szString ) );

        // wsprintf( szStr2, szString, (LPTSTR)pszStart, (LPTSTR)szDrv );

        LPTSTR args [ 2 ] = { pszStart, szDrv };

        FormatMessage( FORMAT_MESSAGE_FROM_STRING
                       | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       szString,
                       0,
                       0,
                       szStr2,
                       256,
                       (va_list *) args
                       );
    }
    else
    {
        LoadString( g_hInst, INSTALLIT + 1, szString, ARRAYSIZE( szString ) );
        wsprintf( szStr2, szString, (LPTSTR)szDrv );
    }
}


INT_PTR CALLBACK AddFileDlg( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    RECT rc;

    switch( message )
    {
    case WM_INITDIALOG:
        GetWindowRect( hDlg,&rc );

        SetWindowPos( hDlg,NULL,
                (GetSystemMetrics( SM_CXSCREEN ) - (rc.right - rc.left) ) / 2,
                (GetSystemMetrics( SM_CYSCREEN ) - (rc.bottom - rc.top) ) / 3,
                0, 0, SWP_NOSIZE | SWP_NOACTIVATE );

        SetDlgItemText( hDlg, IDRETRY,  (LPTSTR)lParam );

        SendDlgItemMessage( hDlg, COLOR_SAVE, EM_LIMITTEXT, PATHMAX - 20, 0L );

        SetDlgItemText( hDlg, COLOR_SAVE, szDirOfSrc );

        SendDlgItemMessage( hDlg, COLOR_SAVE, EM_SETSEL, 0, 0x7FFF0000 );

        if (g_bDBCS)
        {
            if( ghwndFontDlg )
            {
                TCHAR szString[ 64 ];

                LoadString( g_hInst, INSTALLIT + 2, szString, ARRAYSIZE( szString ) );

                SetWindowText( hDlg, szString );
            }
        }
        return( TRUE );

    case WM_COMMAND:
        switch( wParam )
        {
        case IDOK:
            GetDlgItemText( hDlg, COLOR_SAVE,  szDirOfSrc, PATHMAX );

            vCPStripBlanks( szDirOfSrc );

            lpCPBackSlashTerm( szDirOfSrc );

        case IDCANCEL:
            EndDialog( hDlg, wParam == IDOK );

            return( TRUE );

        case IDD_BROWSE:
            {
                OPENFILENAME OpenFileName;
                TCHAR szPath[ PATHMAX ];
                TCHAR szFilter[ 20 ];

                // DWORD dwSave;

                int temp;
                LPTSTR lpTemp;

                szFilter[ 0 ] = TEXT( 'a' );
                szFilter[ 1 ] = TEXT( '\0' );

                lstrcpy( szFilter+2, szDrv );

                if( !(lpTemp = StrChr( szFilter+2, TEXT( '.' ) ) ) )
                   lpTemp = szFilter+2+lstrlen( szFilter+2 );

                lstrcpy( lpTemp, TEXT( ".*" ) );

                *szPath = TEXT( '\0' );

                GetDlgItemText( hDlg, COLOR_SAVE, szDirOfSrc, PATHMAX );

                //
                //  Save context. TODO: fix. EMR
                //  dwSave = dwContext;
                //  dwContext = IDH_DLG_BROWSE;
                //

                OpenFileName.lStructSize = sizeof( OPENFILENAME );
                OpenFileName.hwndOwner = hDlg;
                OpenFileName.hInstance = g_hInst;
                OpenFileName.lpstrFilter = szFilter;
                OpenFileName.lpstrCustomFilter = NULL;
                OpenFileName.nMaxCustFilter = 0;
                OpenFileName.nFilterIndex = 1;
                OpenFileName.lpstrFile = (LPTSTR) szPath;
                OpenFileName.nMaxFile = ARRAYSIZE( szPath );
                OpenFileName.lpstrInitialDir = (LPTSTR) szDirOfSrc;
                OpenFileName.lpstrTitle = NULL;
                OpenFileName.Flags = OFN_HIDEREADONLY | OFN_ENABLEHOOK |
                                     OFN_ENABLETEMPLATE |
                                     /* OFN_SHOWHELP | */ OFN_NOCHANGEDIR;
                OpenFileName.lCustData = MAKELONG( hDlg, 0 );
                OpenFileName.lpfnHook = AddFileHookProc;
                OpenFileName.lpTemplateName =(LPTSTR)MAKEINTRESOURCE( DLG_BROWSE );
                OpenFileName.nFileOffset = 0;
                OpenFileName.nFileExtension = 0;
                OpenFileName.lpstrDefExt = NULL;
                OpenFileName.lpstrFileTitle = NULL;

                temp = GetOpenFileName( &OpenFileName );

                //
                //  Restore context.
                //  TODO: FIX  -EMR
                //  dwContext = dwSave;
                //

                //
                //  force buttons to repaint
                //

                UpdateWindow( hDlg );

                if( temp )
                {
                    szPath[ OpenFileName.nFileOffset ] = TEXT( '\0' );

                    SetDlgItemText( hDlg, COLOR_SAVE, szPath );
                }
#ifdef DEBUG
                else
                {
                    wsprintf( szPath, TEXT( "Commdlg error = 0x%04x" ),
                              temp = LOWORD( CommDlgExtendedError( ) ) );

                    if( temp )
                        MessageBox( hDlg, szPath, TEXT( "Control" ),
                                   MB_SETFOREGROUND|MB_OK|MB_ICONINFORMATION );
                }
#endif

                break;
            }

#if 0 // EMR TODO fix
        case IDD_HELP:
              goto DoHelp;
#endif
        }
        break;

    default:

#if 0    // EMR: TODO
        if( message == wHelpMessage )
        {
DoHelp:
            CPHelp( hDlg );
            return TRUE;
        }
        else
#endif
            return FALSE;

    }

    //
    //  Didn't process a message
    //

    return( FALSE );
}


/* This copies a string up to a given char (not including the char)
 * into another string, up to a maximum number of chars
 * Notice that wMax includes the terminating NULL, while StrCpyN
 * does not
 */

LPTSTR FAR PASCAL CpyToChr( LPTSTR lpDest, LPTSTR lpSrc, TCHAR cChr, int iMax )
{
    LPTSTR lpch;
    int    len;

    lpch = StrChr( lpSrc, cChr );

    if( lpch )
        len = (int)(lpch - lpSrc);
    else
        len = lstrlen( lpSrc );

    iMax--;

    if( len > iMax )
        len = iMax;

//     StrCpyN( lpDest, lpSrc, len );

    lstrcpyn( lpDest, lpSrc, len + 1 );

    return lpSrc + lstrlen( lpDest );
}


/* Parse a string like '5:hppcl.drv,' into the disk and the driver
 * *nDsk gets the 5, and pszDriver gets "hppcl.drv"
 * It is assumed that the ONE byte before the ':' identifies
 * the disk, and is in '0'-'9' or 'A'-'Z'
 */

VOID FAR PASCAL GetDiskAndFile( LPTSTR pszInf,
                                short /* int */ FAR *nDsk,
                                LPTSTR pszDriver,
                                WORD wSize )
{
    LPTSTR pszTmp;

    //
    //  Determine the disk on which to find the file; note if a comma comes
    //  before a colon, there is no disk specified
    //

    if( !(pszTmp = StrChr( pszInf+1, TEXT( ':' ) ) )
        || StrRChr( pszInf+1, pszTmp, TEXT( ',' ) ) )
    {
        *nDsk = 0;
    }
    else
    {
        pszInf = pszTmp + 1;
        *nDsk  = *(pszTmp - 1 );
    }

    //
    //  Get the driver name and terminate at the TEXT( ',' )
    //

    CpyToChr( pszDriver, pszInf, TEXT( ',' ), wSize );
}


/* This attempts to set the attributes of a file; dx is set to 0
 * if the call was successful, -1 otherwise.  ax gets the attributes,
 * or the DOS error.
 */

DWORD NEAR PASCAL GetSetFileAttr( LPTSTR lpFileName, DWORD dwAttr )
{
    if( dwAttr != 0xffffffff )
        SetFileAttributes( lpFileName, dwAttr );

    return GetFileAttributes( lpFileName );
}

#ifdef DISKCHK

BOOL NEAR PASCAL DebugGetDiskSpace( )
{
    WORD wAvailCluster;
    WORD wBytePerSector;
    WORD wSectorPerCluster;
    LONG lFreeSize;
    unsigned int iRet;
    TCHAR szDev[ 80 ];
    TCHAR szSysDir[ 128 ];
    int nDrive;

    GetSystemDirectory( (LPTSTR) szSysDir, 127 );
    nDrive = (int)( (unsigned int)szSysDir[ 0 ] - (unsigned int)TEXT( 'A' )
                                                + (unsigned int)1 );

_asm{
    mov dl,nDrive
    mov ah,36h
    int 21h

    cmp ax,0FFFFh
    je DFend

    mov wAvailCluster,bx
    mov wBytePerSector,ax
    mov wSectorPerCluster,cx

DFend:
    mov iRet,ax
}

    if( iRet!=-1 )
    {
        lFreeSize = (LONG)wAvailCluster * (LONG)wBytePerSector * (LONG)wSectorPerCluster;

        wsprintf( (LPTSTR)szDev,TEXT( "DiskFreeSize is %ld\r\n" ),lFreeSize );

        OutputDebugString( (LPTSTR)szDev );
    }
    else
        OutputDebugString( (LPTSTR)TEXT( "Get Free Size Error!\r\n" ) );
}

#else

#define DebugGetDiskSpace( ) NULL

#endif

//
// Returns: Number of files installed.
//          0xFFFFFFFF = Operation aborted by user.
//

DWORD FAR PASCAL InstallFiles( HWND hwnd,
                               LPTSTR FAR *pszFiles,
                               int nCount,
                               INSTALL_PROC lpfnNewFile,
                               WORD wIFFlags )
{
    SHFILEOPSTRUCT fop;
    FullPathName_t szWinDir;
    TCHAR          szTmpFile[MAX_PATH];
    DWORD          dwInstalledCount = 0;
    TCHAR          szFile[MAX_PATH];
    int            i;
    int            nPass;
    BOOL           bFileExists = FALSE;
    int            iSHFileOpResult = 0;
    UINT OldErrorMode;

    //
    //  Initialize. Set the fop struct to copy the files into
    //  the fonts directory.
    //

    if( !GetFontsDirectory( szWinDir, ARRAYSIZE( szWinDir ) ) )
        goto backout;

    //
    // SHFileOperation requires that the source and destination file
    // lists be double-nul terminated.
    //
    szWinDir[lstrlen(szWinDir) + 1] = TEXT('\0');

    memset( &fop, 0, sizeof( fop ) );

    fop.hwnd   = hwnd;
    fop.wFunc  = FO_COPY;
    fop.pTo    = szWinDir;
    fop.fFlags = FOF_NOCONFIRMATION;

    for( i = 0; i < nCount; i++)
    {
        //
        // Which disk and file are we on?
        //

        GetDiskAndFile( pszFiles[ i ], &nDisk, szFile, ARRAYSIZE( szFile ) );

        vCPStripBlanks( szFile );

        if( !nDisk )
        {
            LPTSTR pszEnd;

            if( !GetInstDiskName( (LPTSTR) &nDisk, szDirOfSrc, ARRAYSIZE(szDirOfSrc) )
                 || !(pszEnd = StrChr( szDirOfSrc, TEXT( ',' ) ) ) )
                goto backout;

            *pszEnd = 0;
            vCPStripBlanks( szDirOfSrc );

#if 0
            //
            //  TEXT( "." ) is special, and means there is no default dir.
            //

            if( *(WORD *)szDirOfSrc == TEXT( '.' ) )
            {
                //
                //  TODO. What do we do with this?
                //
                continue;
            }
#endif
        }

        CharUpper( szFile );

        *szTmpFile = 0;

        //
        //  Need to check DriveReady before attempting to install the file.
        //

        nPass = 0;

        do
        {
            OldErrorMode = SetErrorMode( 1 );

            lstrcpy( szTmpFile, szDirOfSrc );

            lpCPBackSlashTerm( szTmpFile );

            lstrcat( szTmpFile, szFile );

            bFileExists = IsDriveReady( szTmpFile );

            SetErrorMode( OldErrorMode );

            if( !bFileExists )
            {
                BOOL bUserPressedOk = FALSE;

                GetDiskAndFile( pszFiles[ i ], &nDisk,szDrv,80 );

                CharUpper( szDrv );

                //
                //  Query the user for the disk. This has to succeed or
                //  we bail.
                //

                FormatAddFilePrompt( szTmpFile );

                //
                //  EMR TODO fix help id.
                //

                bUserPressedOk = DoDialogBoxParam( DLG_INSTALL,
                                        hwnd,
                                        AddFileDlg,
                                        0              /* IDH_DLG_INSERT_DISK */,
                                        (LPARAM) (LPTSTR) szTmpFile );
                if( !bUserPressedOk )
                {
                    //
                    // User pressed "Cancel"
                    //
                    dwInstalledCount = (DWORD)-1;
                    goto backout;
                }
            }
        } while( !bFileExists  );

        //
        //  Copy the file
        //

        memset( szTmpFile, 0, sizeof( szTmpFile ) );

        lstrcpy( szTmpFile, szDirOfSrc );

        lpCPBackSlashTerm( szTmpFile );

        lstrcat( szTmpFile, szFile );

        //
        // SHFileOperation requires that the source and destination file
        // lists be double-nul terminated.
        //
        szTmpFile[lstrlen(szTmpFile) + 1] = TEXT('\0');
        fop.pFrom = szTmpFile;

        if( ( iSHFileOpResult = SHFileOperation( &fop ) ) || fop.fAnyOperationsAborted )
        {
            //
            // If operation was aborted or cancelled.
            //
            if( fop.fAnyOperationsAborted ||
              ( iSHFileOpResult == 0x75 /* DE_OPCANCELLED */) )
            {
                dwInstalledCount = (DWORD)-1;
            }
            goto backout;
        }
        else
        {
            dwInstalledCount++;  // Success!
        }
    }

backout:

    //
    //  If we cancelled, remove any of the files that we may have installed.
    //

    if( (DWORD)(-1) == dwInstalledCount)
    {
        for( int j = 0; j <= i; j++)
        {
            //
            // Which disk and file are we on?
            //

            GetDiskAndFile( pszFiles[ j ], &nDisk, szFile, ARRAYSIZE( szFile ) );
            vCPStripBlanks( szFile );

            vCPDeleteFromSharedDir( szFile );
       }
    }

    return dwInstalledCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\fontview.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fontview.cpp
//      Explorer Font Folder extension routines.
//      Implementation for the CFontView class.
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================


#include "priv.h"
#include "globals.h"
#include "fonthelp.h"
#include "fontview.h"
#include "fontman.h"
#include "fontcl.h"
#include "fontlist.h"
#include "cpanel.h"
#include "resource.h"
#include "ui.h"
#include "dbutl.h"
#include "extricon.h"


#include <sys\stat.h>
#include <time.h>
#include <htmlhelp.h>


#ifdef __cplusplus
extern "C" {
#endif

//
// APPCOMPAT:  Hack to avoid duplicate-macro error.  platform.h (included by shlobjp.h)
//          also defines a PATH_SEPARATOR macro (as does wingdip.h).  None of the
//          code in fontview.cpp uses this macro.  Once the name conflict is
//          removed from the headers, we can remove this undefinition hack.
//          [brianau - 3/6/98]
//
#ifdef PATH_SEPARATOR
#   undef PATH_SEPARATOR
#endif
#include <wingdip.h>

#ifdef __cplusplus
}
#endif

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define BOOLIFY(expr)   (!!(expr))

#define FFCOL_DEFAULT -1
#define FFCOL_NAME 0
#define FFCOL_PANOSE 1
#define FFCOL_FILENAME 1
#define FFCOL_SIZE 2
#define FFCOL_MODIFIED 3
#define FFCOL_ATTRIBUTES 4

#define WID_LISTVIEW 2

#ifdef TOOLTIP_FONTSAMPLE
const INT FONT_SAMPLE_PT_SIZE = 16;
#endif

//
// Message for shell change notifications.
// Same value as WM_DSV_FSNOTIFY.
//
#define WM_SHELL_CHANGE_NOTIFY (WM_USER + 0xA0)

UINT const cDeadMenu = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
UINT const cLiveMenu = MF_BYCOMMAND | MF_ENABLED;

UINT const kMinPointSize = 8;

#ifdef USE_OWNERDRAW

const int kBaseViewStyle = WS_CHILD | WS_VISIBLE | WS_TABSTOP | LVS_AUTOARRANGE | LVS_OWNERDRAWFIXED;

#else

const int kBaseViewStyle = WS_CHILD | WS_VISIBLE | WS_TABSTOP | LVS_AUTOARRANGE;

#endif


TCHAR* g_szViewClass = TEXT( "FONTEXT_View" );

//
// List of file attribute bit values.  The order (with respect
// to meaning) must match that of the characters in g_szAttributeChars[].
//
const DWORD g_adwAttributeBits[] = {
                                    FILE_ATTRIBUTE_READONLY,
                                    FILE_ATTRIBUTE_HIDDEN,
                                    FILE_ATTRIBUTE_SYSTEM,
                                    FILE_ATTRIBUTE_ARCHIVE,
                                    FILE_ATTRIBUTE_COMPRESSED
                                   };

#define NUM_ATTRIB_CHARS  ARRAYSIZE(g_adwAttributeBits)

//
// Buffer for characters that represent attributes in Details View attributes
// column.  Must provide room for 1 character for each bit and a NUL.  The current 5
// represent Read-only, Hidden, System, Archive, and Compressed in that order.
// This can't be const because we overwrite it using LoadString.
//
TCHAR g_szAttributeChars[NUM_ATTRIB_CHARS + 1] = { 0 } ;


#ifdef WINNT
#   define ALT_TEXT_COLOR   // NT uses alternate color for compressed files.
#endif

#ifdef ALT_TEXT_COLOR
//
// Things associated with "alternate" color for compressed files in folder.
//
#include <regstr.h>

COLORREF g_crAltColor      = RGB(0,0,255);     // Color defaults to blue.
HKEY g_hkcuExplorer        = NULL;
TCHAR const c_szAltColor[] = TEXT("AltColor"); // Reg loc for setting.

#endif // ALT_TEXT_COLOR



#pragma data_seg(".text", "CODE")
const static DWORD rgOptionPropPageHelpIDs[] =
{
    IDC_TTONLY, IDH_FONTS_TRUETYPE_ON_COMPUTER,
    0,0
};

#pragma data_seg()


//***   IsBackSpace -- is key a Backspace
BOOL IsBackSpace(LPMSG pMsg)
{
    return pMsg && (pMsg->message == WM_KEYDOWN) && (pMsg->wParam == VK_BACK);
}

//***   IsVK_TABCycler -- is key a TAB-equivalent
// ENTRY/EXIT
//  dir     0 if not a TAB, non-0 if a TAB
// NOTES
//  NYI: -1 for shift+tab, 1 for tab
//
int IsVK_TABCycler(MSG *pMsg)
{
    if (!pMsg)
        return 0;

    if (pMsg->message != WM_KEYDOWN)
        return 0;
    if (! (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6))
        return 0;

    return (GetKeyState(VK_SHIFT) < 0) ? -1 : 1;
}


// ***********************************************************************
// ***********************************************************************
// ***********************************************************************

extern HRESULT MyReleaseStgMedium( LPSTGMEDIUM pmedium );


//
// Call CFontClass::Release() for each font object contained in the ListView.
//
void CFontView::ReleaseFontObjects(void)
{
    int iCount = ListView_GetItemCount(m_hwndList);
    LV_ITEM lvi;
    CFontClass *pFont = NULL;

    lvi.mask       = LVIF_PARAM;
    lvi.iSubItem   = 0;
    lvi.state      = 0;
    lvi.stateMask  = 0;
    lvi.pszText    = NULL;
    lvi.cchTextMax = 0;
    lvi.iImage     = 0;

    for (int i = 0; i < iCount; i++)
    {
        lvi.iItem = i;

        if (ListView_GetItem(m_hwndList, &lvi))
        {
            pFont = (CFontClass *)lvi.lParam;
            if (NULL != pFont)
                pFont->Release();
        }
    }
}


//
//  This function emulates OleSetClipboard().
//

STDAPI FFSetClipboard( LPDATAOBJECT pdtobj )
{
    HRESULT hres = NOERROR;

    if( OpenClipboard( NULL ) )    // associate it with current task.
    {
        EmptyClipboard( );

        if( pdtobj )
        {
            //
            //  Support WIN3.1 style clipboard : Just put the file name of
            //  the first item as "FileName".
            //

            FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            STGMEDIUM medium;

            hres = pdtobj->GetData( &fmte, &medium );

            if( SUCCEEDED( hres ) )
            {
                if( !SetClipboardData( CF_HDROP, medium.hGlobal ) )
                    MyReleaseStgMedium( &medium );

                fmte.cfFormat = CFontData::s_CFPreferredDropEffect;
                hres = pdtobj->GetData(&fmte, &medium);
                if (SUCCEEDED(hres))
                {
                    if (!SetClipboardData(CFontData::s_CFPreferredDropEffect, medium.hGlobal))
                        MyReleaseStgMedium(&medium);
                }
            }
        }
        CloseClipboard( );
    }
    else
    {
        hres = ResultFromScode( CLIPBRD_E_CANT_OPEN );
    }

    return hres;
}


// ***********************************************************************
//  Structures used to manipulate the view of the list.
//

typedef struct _COLUMN_ENTRY {
                UINT     m_iID;         //  String
                UINT     m_iWidth;      //  width of column
                UINT     m_iFormat;
} COLUMN_ENTRY;


COLUMN_ENTRY PanoseColumns[] = { { IDS_PAN_COL1, 20, LVCFMT_LEFT},
                                 { IDS_PAN_COL2, 30, LVCFMT_LEFT} };

#define PAN_COL_COUNT  (sizeof( PanoseColumns ) / sizeof( COLUMN_ENTRY ) )

COLUMN_ENTRY FileColumns[] = { { IDS_FILE_COL1, 20, LVCFMT_LEFT},
                               { IDS_FILE_COL2, 14, LVCFMT_LEFT},
                               { IDS_FILE_COL3,  6, LVCFMT_RIGHT},
                               { IDS_FILE_COL4, 15, LVCFMT_LEFT},
                               { IDS_FILE_COL5, 10, LVCFMT_RIGHT}};


const TCHAR c_szM[] = TEXT( "M" );

//
//  the width of an M
//

int g_cxM = 0;


#define FILE_COL_COUNT  (sizeof( FileColumns ) / sizeof( COLUMN_ENTRY ) )



// ***********************************************************************
//  Forward Declarations.
//

void  MergeFileMenu( HMENU hmenu, HMENU hmenuMerge );
void  MergeEditMenu( HMENU hmenu, HMENU hmenuMerge );
void  MergeViewMenu( HMENU hmenu, HMENU hmenuMerge );
void  MergeHelpMenu( HMENU hmenu, HMENU hmenuMerge );
HMENU GetMenuFromID( HMENU hmMain, UINT uID );
void  SetListColumns( HWND hWnd, UINT iCount, COLUMN_ENTRY * lpCol );


// ***********************************************************************
//  Local Functions
//

static ::HFONT hCreateFont( HDC hDC, int iPoints, const TCHAR FAR* lpFace )
{
    int FPoints = -MulDiv( iPoints, GetDeviceCaps( hDC, LOGPIXELSY ), 72 );

    return ::CreateFont( FPoints, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, lpFace );
}


UINT WSFromViewMode( UINT uMode, HWND hWnd = 0 );

UINT WSFromViewMode( UINT uMode, HWND hWnd )
{
    UINT  ws;

    if( hWnd )
        ws = GetWindowLong( hWnd, GWL_STYLE ) & ~LVS_TYPEMASK;
    else
        ws = kBaseViewStyle;

    switch( uMode )
    {
        default: // case IDM_VIEW_ICON:
            ws |= LVS_ICON;
            break;

        case IDM_VIEW_LIST:
            ws |= LVS_LIST;
            break;

        case IDM_VIEW_PANOSE:
            ws |= LVS_REPORT;
            break;
        case IDM_VIEW_DETAILS:
            ws |= LVS_REPORT;
            break;
    }

    return ws;
}


// ***********************************************************************
// ***********************************************************************
// ***********************************************************************


class CEnumFormatEtc : public IEnumFORMATETC
    {
    private:
        ULONG           m_cRef;         //Object reference count
        LPUNKNOWN       m_pUnkRef;      //For reference counting
        ULONG           m_iCur;         //Current element.
        ULONG           m_cfe;          //Number of FORMATETCs in us
        LPFORMATETC     m_prgfe;        //Source of FORMATETCs

    public:
        CEnumFormatEtc( LPUNKNOWN, ULONG, LPFORMATETC );
        ~CEnumFormatEtc( void );

        //IUnknown members that delegate to m_pUnkRef.
        STDMETHODIMP         QueryInterface( REFIID, VOID ** );
        STDMETHODIMP_(ULONG) AddRef( void );
        STDMETHODIMP_(ULONG) Release( void );

        //IEnumFORMATETC members
        STDMETHODIMP Next( ULONG, LPFORMATETC, ULONG FAR * );
        STDMETHODIMP Skip( ULONG );
        STDMETHODIMP Reset( void );
        STDMETHODIMP Clone( IEnumFORMATETC FAR * FAR * );
    };



typedef CEnumFormatEtc FAR *LPCEnumFormatEtc;


/*
 * CEnumFormatEtc::CEnumFormatEtc
 * CEnumFormatEtc::~CEnumFormatEtc
 *
 * Parameters (Constructor):
 *  pUnkRef         LPUNKNOWN to use for reference counting.
 *  cFE             ULONG number of FORMATETCs in pFE
 *  prgFE           LPFORMATETC to the array to enumerate.
 */

CEnumFormatEtc::CEnumFormatEtc( LPUNKNOWN pUnkRef, ULONG cFE, LPFORMATETC prgFE )
{
    UINT        i;

    m_cRef    = 0;
    m_pUnkRef = pUnkRef;

    m_iCur  = 0;
    m_cfe   = cFE;
    m_prgfe = new FORMATETC[ (UINT)cFE ];

    if( NULL != m_prgfe )
    {
        for( i = 0; i < cFE; i++ )
            m_prgfe[ i ] = prgFE[ i ];
    }

    return;
}


CEnumFormatEtc::~CEnumFormatEtc( void )
{
    if( NULL != m_prgfe )
        delete [] m_prgfe;

    return;
}


/*
 * CEnumFormatEtc::QueryInterface
 * CEnumFormatEtc::AddRef
 * CEnumFormatEtc::Release
 *
 * Purpose:
 *  IUnknown members for CEnumFormatEtc object.  For QueryInterface
 *  we only return out own interfaces and not those of the data
 *  object.  However, since enumerating formats only makes sense
 *  when the data object is around, we insure that it stays as
 *  long as we stay by calling an outer IUnknown for AddRef
 *  and Release.  But since we are not controlled by the lifetime
 *  of the outer object, we still keep our own reference count in
 *  order to free ourselves.
 */

STDMETHODIMP CEnumFormatEtc::QueryInterface( REFIID riid, VOID ** ppv )
{
    *ppv = NULL;

    //
    //  Enumerators are separate objects, not the data object, so
    //  we only need to support out IUnknown and IEnumFORMATETC
    //  interfaces here with no concern for aggregation.
    //

    if( IsEqualIID( riid, IID_IUnknown )
        || IsEqualIID( riid, IID_IEnumFORMATETC ) )
        *ppv = (LPVOID)this;

    //
    //  AddRef any interface we'll return.
    //

    if( NULL!=*ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef( );

        return NOERROR;
    }

    return ResultFromScode( E_NOINTERFACE );
}


STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef( void )
{
    ++m_cRef;

    m_pUnkRef->AddRef( );

    return m_cRef;
}

STDMETHODIMP_(ULONG) CEnumFormatEtc::Release( void )
{
    ULONG       cRefT;

    cRefT=--m_cRef;

    m_pUnkRef->Release( );

    if( 0L == m_cRef )
        delete this;

    return cRefT;
}


/*
 * CEnumFormatEtc::Next
 *
 * Purpose:
 *  Returns the next element in the enumeration.
 *
 * Parameters:
 *  cFE             ULONG number of FORMATETCs to return.
 *  pFE             LPFORMATETC in which to store the returned
 *                  structures.
 *  pulFE           ULONG FAR * in which to return how many we
 *                  enumerated.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, S_FALSE otherwise,
 */

STDMETHODIMP CEnumFormatEtc::Next( ULONG cFE, LPFORMATETC pFE, ULONG FAR *pulFE )
{
    ULONG   cReturn = 0L;

    if( NULL == m_prgfe )
        return ResultFromScode( S_FALSE );

    if( NULL != pulFE )
        *pulFE = 0L;

    if( NULL == pFE || m_iCur >= m_cfe )
        return ResultFromScode( S_FALSE );

    while( m_iCur < m_cfe && cFE > 0 )
    {
        *pFE++ = m_prgfe[ m_iCur++ ];

        cReturn++;

        cFE--;
    }

    if( NULL!=pulFE )
        *pulFE = cReturn;

    return NOERROR;
}


/*
 * CEnumFormatEtc::Skip
 *
 * Purpose:
 *  Skips the next n elements in the enumeration.
 *
 * Parameters:
 *  cSkip           ULONG number of elements to skip.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, S_FALSE if we could not
 *                  skip the requested number.
 */

STDMETHODIMP CEnumFormatEtc::Skip( ULONG cSkip )
{
    if( ( (m_iCur + cSkip) >= m_cfe ) || NULL == m_prgfe )
        return ResultFromScode( S_FALSE );

    m_iCur += cSkip;
    return NOERROR;
}


/*
 * CEnumFormatEtc::Reset
 *
 * Purpose:
 *  Resets the current element index in the enumeration to zero.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR
 */

STDMETHODIMP CEnumFormatEtc::Reset( void )
{
    m_iCur = 0;
    return NOERROR;
}


/*
 * CEnumFormatEtc::Clone
 *
 * Purpose:
 *  Returns another IEnumFORMATETC with the same state as ourselves.
 *
 * Parameters:
 *  ppEnum          LPENUMFORMATETC FAR * in which to return the
 *                  new object.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CEnumFormatEtc::Clone( LPENUMFORMATETC FAR *ppEnum )
{
    LPCEnumFormatEtc    pNew;

    *ppEnum = NULL;

    //
    //  Create the clone
    //

    pNew = new CEnumFormatEtc( m_pUnkRef, m_cfe, m_prgfe );

    if( NULL == pNew )
        return ResultFromScode( E_OUTOFMEMORY );

    pNew->AddRef( );
    pNew->m_iCur = m_iCur;

    *ppEnum = pNew;
    return NOERROR;
}

// ***********************************************************************
// ***********************************************************************
// CFontData members
//

//
// NOTE:  Our preferred drop effect is ALWAYS DROPEFFECT_COPY.
//        The font folder doesn't support the "cut" operation; never has.
//        [brianau - 10/28/98]
//
CLIPFORMAT CFontData::s_CFPerformedDropEffect = 0; // Performed Drop Effect CF atom.
CLIPFORMAT CFontData::s_CFPreferredDropEffect = 0;
CLIPFORMAT CFontData::s_CFLogicalPerformedDropEffect = 0;


CFontData::CFontData( )
   :  m_cRef( 0 ),
      m_poList( 0 ),
      m_dwPerformedDropEffect(DROPEFFECT_NONE),
      m_dwPreferredDropEffect(DROPEFFECT_COPY),
      m_dwLogicalPerformedDropEffect(DROPEFFECT_NONE)
{
    //
    // Get the atom for the "performed effect" clipboard format.
    // This CF has already been added by the shell.  We're just getting the atom.
    //
    if (0 == s_CFPerformedDropEffect)
    {
        s_CFPerformedDropEffect = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PERFORMEDDROPEFFECT);
        s_CFPreferredDropEffect = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
        s_CFLogicalPerformedDropEffect = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_LOGICALPERFORMEDDROPEFFECT);
    }
}


CFontData::~CFontData( )
{
    if( m_poList )
    {
        m_poList->vDetachAll( );
        delete m_poList;
    }
}


CFontList * CFontData::poDetachList( )
{
    CFontList * poList = m_poList;

    m_poList = 0;
    return poList;
}


CFontList *CFontData::poCloneList(void)
{
    return m_poList ? m_poList->Clone() : NULL;
}
    


BOOL CFontData::bInit( CFontList * poList )
{
    m_poList = poList;

    return TRUE;
}


//
// *** IUnknown methods ***
//

HRESULT CFontData::QueryInterface( REFIID riid, LPVOID * ppvObj )
{
    *ppvObj = NULL;

    if( riid == IID_IUnknown )
        *ppvObj = (IUnknown*)( IDataObject* ) this;

    if( riid == IID_IDataObject )
        *ppvObj = (IDataObject* ) this;


    if( *ppvObj )
    {
        ((LPUNKNOWN)*ppvObj)->AddRef( );
        return NOERROR;
    }

    return( ResultFromScode( E_NOINTERFACE ) );
}


ULONG  CFontData::AddRef( void )
{
    return( ++m_cRef );
}

ULONG CFontData::Release( void )
{
    ULONG retval;

    retval = --m_cRef;

    if( !retval )
    {
        delete this;
    }

    return( retval );
}


//
// **** IDataObject ****
//

HRESULT CFontData::GetData( FORMATETC *pfe, STGMEDIUM *ps )
{
    if( !( DVASPECT_CONTENT & pfe->dwAspect ) )
        return ResultFromScode( DATA_E_FORMATETC );

    if( ( pfe->cfFormat == CF_HDROP ) && ( pfe->tymed & TYMED_HGLOBAL ) )
    {
        ps->hGlobal = hDropFromList( m_poList );

        if( ps->hGlobal )
        {
            ps->tymed          = TYMED_HGLOBAL;
            ps->pUnkForRelease = NULL;

            return NOERROR;
        }
    }
    else if ((pfe->cfFormat == s_CFPerformedDropEffect) && (pfe->tymed & TYMED_HGLOBAL))
    {
        //
        // The shell called SetData during a previous drag/drop and we stored
        // the performed drop effect in m_dwPerformedDropEffect.  Now, someone
        // is asking for that effect value.
        // Internally, the font folder just calls GetPerformedDropEffect().
        // This GetData code was added so that we complement SetData.
        //
        ps->hGlobal = (HGLOBAL)LocalAlloc(LPTR, sizeof(DWORD));

        if (NULL != ps->hGlobal)
        {
            *((LPDWORD)ps->hGlobal) = m_dwPerformedDropEffect;
            ps->tymed               = TYMED_HGLOBAL;
            ps->pUnkForRelease      = NULL;
            return NOERROR;
        }
        else
            return ResultFromScode(E_UNEXPECTED);
    }
    else if ((pfe->cfFormat == s_CFLogicalPerformedDropEffect) && (pfe->tymed & TYMED_HGLOBAL))
    {
        ps->hGlobal = (HGLOBAL)LocalAlloc(LPTR, sizeof(DWORD));

        if (NULL != ps->hGlobal)
        {
            *((LPDWORD)ps->hGlobal) = m_dwLogicalPerformedDropEffect;
            ps->tymed               = TYMED_HGLOBAL;
            ps->pUnkForRelease      = NULL;
            return NOERROR;
        }
        else
            return ResultFromScode(E_UNEXPECTED);
    }
    else if ((pfe->cfFormat == s_CFPreferredDropEffect) && (pfe->tymed & TYMED_HGLOBAL))
    {
        ps->hGlobal = (HGLOBAL)LocalAlloc(LPTR, sizeof(DWORD));

        if (NULL != ps->hGlobal)
        {
            *((LPDWORD)ps->hGlobal) = m_dwPreferredDropEffect;
            ps->tymed               = TYMED_HGLOBAL;
            ps->pUnkForRelease      = NULL;

            return NOERROR;
        }
        else
            return ResultFromScode(E_UNEXPECTED);
    }
    return ResultFromScode( DATA_E_FORMATETC );
}



HRESULT CFontData::GetDataHere( FORMATETC *pformatetc, STGMEDIUM *pmedium )
{
    return ResultFromScode( E_NOTIMPL );
}


HRESULT CFontData::QueryGetData( FORMATETC *pfe )
{
    HRESULT  hRet = ResultFromScode( S_FALSE );

    //
    //  Check the aspects we support.
    //

    if( !( DVASPECT_CONTENT & pfe->dwAspect ) )
        return ResultFromScode( DATA_E_FORMATETC );

    if (TYMED_HGLOBAL != pfe->tymed)
        return ResultFromScode( DV_E_TYMED );

    if( pfe->cfFormat == CF_HDROP ||
        pfe->cfFormat == s_CFPreferredDropEffect ||
        pfe->cfFormat == s_CFPerformedDropEffect ||
        pfe->cfFormat == s_CFLogicalPerformedDropEffect)
    {
        hRet = NOERROR ;
    }

    return hRet;
}


HRESULT CFontData::GetCanonicalFormatEtc( FORMATETC *pfeIn, FORMATETC *pfeOut )
{
    *pfeOut = *pfeIn;

    pfeOut->ptd = NULL;

    return ResultFromScode( DATA_S_SAMEFORMATETC );
}


HRESULT CFontData::SetData( FORMATETC *pformatetc,
                            STGMEDIUM *pmedium,
                            BOOL fRelease )
{
    HRESULT hr = DATA_E_FORMATETC;

    if ((pformatetc->cfFormat == s_CFPerformedDropEffect) &&
        (pformatetc->tymed & TYMED_HGLOBAL))
    {
        //
        // The shell has called to tell us what the performed
        // drop effect was from the drag/drop operation.  We save
        // the drop effect so we can provide it when someone asks
        // for it through GetData or GetPerformedDropEffect.
        //
        LPDWORD pdw = (LPDWORD)GlobalLock(pmedium->hGlobal);

        if (NULL != pdw)
        {
            m_dwPerformedDropEffect = *pdw;
            GlobalUnlock(pmedium->hGlobal);
            hr = NOERROR;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
        if (fRelease)
            ReleaseStgMedium(pmedium);
    }
    else if ((pformatetc->cfFormat == s_CFLogicalPerformedDropEffect) &&
             (pformatetc->tymed & TYMED_HGLOBAL))
    {
        //
        // The shell has called to tell us what the logical performed
        // drop effect was from the drag/drop operation.  We save
        // the drop effect so we can provide it when someone asks
        // for it through GetData or GetPerformedDropEffect.
        //
        LPDWORD pdw = (LPDWORD)GlobalLock(pmedium->hGlobal);

        if (NULL != pdw)
        {
            m_dwLogicalPerformedDropEffect = *pdw;
            GlobalUnlock(pmedium->hGlobal);
            hr = NOERROR;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
        if (fRelease)
            ReleaseStgMedium(pmedium);
    }
    return hr;
}


HRESULT CFontData::ReleaseStgMedium(LPSTGMEDIUM pmedium)
{
    if (pmedium->pUnkForRelease)
    {
        pmedium->pUnkForRelease->Release();
    }
    else
    {
        switch(pmedium->tymed)
        {
        case TYMED_HGLOBAL:
            GlobalFree(pmedium->hGlobal);
            break;

        case TYMED_ISTORAGE: // depends on pstm/pstg overlap in union
        case TYMED_ISTREAM:
            pmedium->pstm->Release();
            break;

        default:
            ASSERT(0);  // unknown type
        }
    }

    return S_OK;
}


HRESULT CFontData::EnumFormatEtc( DWORD dwDirection, IEnumFORMATETC **ppEnum )
{
    FORMATETC feGet[] = {{ CF_HDROP,                NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
                         { s_CFPreferredDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
                         { s_CFPerformedDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
                         { s_CFLogicalPerformedDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }
                        };

    FORMATETC feSet[] = {{ s_CFPerformedDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
                         { s_CFLogicalPerformedDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }
                        };

    FORMATETC *pfe = NULL;
    INT cfe = 0;

    *ppEnum = NULL;

    switch(dwDirection)
    {
        case DATADIR_GET:
            pfe = feGet;
            cfe = ARRAYSIZE(feGet);
            break;

        case DATADIR_SET:
            pfe = feSet;
            cfe = ARRAYSIZE(feSet);
            break;

        default:
            break;
    }

    if (0 < cfe)
    {
        *ppEnum = new CEnumFormatEtc(this, cfe, pfe);
    }

    if( *ppEnum )
    {
        (*ppEnum)->AddRef( );

        return NOERROR;
    }
    else
        return ResultFromScode( E_FAIL );
}


HRESULT CFontData::DAdvise( FORMATETC  *pformatetc,
                            DWORD advf,
                            IAdviseSink *pAdvSink,
                            DWORD *pdwConnection )
{
    return ResultFromScode( E_NOTIMPL );
}


HRESULT CFontData::DUnadvise( DWORD dwConnection )
{
    return ResultFromScode( E_NOTIMPL );
}


HRESULT CFontData::EnumDAdvise( IEnumSTATDATA **ppenumAdvise )
{
    return ResultFromScode( E_NOTIMPL );
}


BOOL CFontData::bRFR( )
{
    if( m_poList )
    {
        int iCount = m_poList->iCount( );

        for( int i = 0; i < iCount; i++ )
            m_poList->poObjectAt( i )->bRFR( );

        return TRUE;
    }

    return FALSE;
}


BOOL CFontData::bAFR( )
{
    if( m_poList )
    {
        int iCount = m_poList->iCount( );

        for( int i = 0; i < iCount; i++ )
            m_poList->poObjectAt( i )->bAFR( );

        return TRUE;
    }

    return FALSE;
}


// ***********************************************************************
// ***********************************************************************
// CFontView members
//


CFontView::CFontView(void)
{
    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: CFontView object constructed" ) ) );

    m_cRef          = 0;
    m_poFontManager = NULL;
    m_bFamilyOnly   = FALSE;
    m_poPanose      = NULL;

    m_hwndView   = NULL;
    m_hwndList   = NULL;
    m_hwndText   = NULL;
    m_hwndCombo  = NULL;
    m_hwndParent = NULL;

    m_hwndNextClip = NULL;

    m_hImageList      = NULL;
    m_hImageListSmall = NULL;

    m_hmenuCur       = NULL;
    m_psb            = NULL;
    m_uState         = SVUIA_DEACTIVATE;
    m_idViewMode     = IDM_VIEW_ICON;
    m_iViewClickMode = CLICKMODE_DOUBLE;
    m_ViewModeReturn = FVM_ICON;
    m_fFolderFlags   = FWF_AUTOARRANGE;
    m_bDragSource    = FALSE;
    m_iSortColumn    = FFCOL_DEFAULT;
    m_iSortLast      = FFCOL_DEFAULT;
    m_bSortAscending = TRUE;
    m_bUIActivated   = FALSE;
    m_pdtobjHdrop    = NULL;
    m_bResizing      = FALSE;

    m_dwDateFormat   = 0;

    m_uSHChangeNotifyID = 0;

#ifdef TOOLTIP_FONTSAMPLE
    m_hwndToolTip          = NULL;
    m_bShowPreviewToolTip  = FALSE;
    m_iTTLastHit           = -1;
    m_hfontSample          = NULL;

    //
    // Load up the sample text for non-symbol fonts.
    //
    TCHAR szSample[MAX_PATH];
    LoadString(g_hInst, IDS_FONTSAMPLE_TEXT, szSample, ARRAYSIZE(szSample));
    m_pszSampleText = new TCHAR[lstrlen(szSample) + 1];
    if (NULL != m_pszSampleText)
        lstrcpy(m_pszSampleText, szSample);

    //
    // Load up the sample text for symbol fonts.
    //
    LoadString(g_hInst, IDS_FONTSAMPLE_SYMBOLS, szSample, ARRAYSIZE(szSample));
    m_pszSampleSymbols = new TCHAR[lstrlen(szSample) + 1];
    if (NULL != m_pszSampleSymbols)
        lstrcpy(m_pszSampleSymbols, szSample);

#endif

#ifdef ALT_TEXT_COLOR
    m_bShowCompColor = FALSE;
#endif // ALT_TEXT_COLOR
    m_bShowHiddenFonts = FALSE;
    g_cRefThisDll++;
}


CFontView::~CFontView( )
{
   //
   //  These are destroyed by the ListView
   //  if( m_hImageList) ImageList_Destroy( m_hImageList );
   //  if( m_hImageListSmall ) ImageList_Destroy( m_hImageListSmall );
   //

#ifdef TOOLTIP_FONTSAMPLE
    if (NULL != m_hfontSample)
    {
        DeleteObject(m_hfontSample);
        m_hfontSample = NULL;
    }
    delete[] m_pszSampleText;
    delete[] m_pszSampleSymbols;

#endif


    if (NULL != m_poFontManager)
        ReleaseFontManager(&m_poFontManager);

    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: CFontView object blasted out of creation" ) ) );
    g_cRefThisDll--;
}


//
// Build a text string containing characters that represent attributes of a file.
// The attribute characters are assigned as follows:
// (R)eadonly, (H)idden, (S)ystem, (A)rchive, (C)ompressed.
//
LPTSTR CFontView::BuildAttributeString(DWORD dwAttributes, LPTSTR pszString, UINT nChars)
{
    if (NULL != pszString)
    {
        int j = 0;

        if (nChars > NUM_ATTRIB_CHARS)
        {
            int i = 0;

            for (i = 0, j = 0; i < NUM_ATTRIB_CHARS; i++)
                if (dwAttributes & g_adwAttributeBits[i])
                    *(pszString + (j++)) = g_szAttributeChars[i];

        }
        *(pszString + j) = TEXT('\0');
    }

    return pszString;
}


//
// Compare two font objects based upon the character-string representation of their
// file's attributes.
// Returns: -1 = *pFontA is "less than" *pFontB.
//           0 = *pFontA is "equal to" *pFontB.
//           1 = *pFontA is "greater than" *pFontB.
//
int CFontView::CompareByFileAttributes(CFontClass *pFontA, CFontClass *pFontB)
{
    int iResult = 0; // Assume equal

    DWORD mask = FILE_ATTRIBUTE_READONLY  |
                 FILE_ATTRIBUTE_HIDDEN    |
                 FILE_ATTRIBUTE_SYSTEM    |
                 FILE_ATTRIBUTE_ARCHIVE   |
                 FILE_ATTRIBUTE_COMPRESSED;

    if (NULL != pFontA && NULL != pFontB)
    {
        //
        // Calculate value of desired bits in attribute DWORD.
        //
        DWORD dwAttribA = pFontA->dwGetFileAttributes() & mask;
        DWORD dwAttribB = pFontB->dwGetFileAttributes() & mask;

        if (dwAttribA != dwAttribB)
        {
            //
            // If the values are not equal,
            // sort alphabetically based on string representation.
            //
            int diff = 0;
            TCHAR szAttribA[NUM_ATTRIB_CHARS + 1];
            TCHAR szAttribB[NUM_ATTRIB_CHARS + 1];

            //
            // Create attribute string for objects A and B.
            //
            BuildAttributeString(dwAttribA, szAttribA, ARRAYSIZE(szAttribA));
            BuildAttributeString(dwAttribB, szAttribB, ARRAYSIZE(szAttribB));

            //
            // Compare attribute strings and determine difference.
            //
            diff = lstrcmp(szAttribA, szAttribB);

            if (diff > 0)
               iResult = 1;
            if (diff < 0)
               iResult = -1;
        }
    }
    return iResult;
}


int CALLBACK iCompare( LPARAM p1, LPARAM p2, LPARAM p3 )
{
    return( ( (CFontView *)p3)->Compare( (CFontClass *)p1, (CFontClass *)p2) );
}

int CFontView::Compare( CFontClass * pFont1, CFontClass * pFont2 )
{
    //
    //  Sorting by name:
    //     If variations are hidden, then sort by family name.
    //     If not, sort by name. The view doesn't matter.
    //
    //  Sorting by Panose:
    //     If the current selected font doesn't have Panose information,
    //     just sort by name. If neither the compare items has PANOSE
    //     info, just sort by name. If only one has PANOSE, return it.
    //     If both have PANOSE, invoke the mapper to get a comparison.
    //

    int iRet = 0;
    bool bNoNegateResult = false;
    UINT viewMode = m_idViewMode;
    TCHAR szFont1[ MAX_NAME_LEN ];
    TCHAR szFont2[ MAX_NAME_LEN ];

    if( viewMode == IDM_VIEW_PANOSE )
    {
        if( (m_iSortColumn == FFCOL_DEFAULT ||
             m_iSortColumn == FFCOL_PANOSE ) )
        {
            BOOL bPan1 = pFont1->bHavePANOSE( );
            BOOL bPan2 = pFont2->bHavePANOSE( );

            //
            //  If neither has a PAN number, just sort by name.
            //

            if( !( bPan1 || bPan2 ) )
            {
                goto CompareNames;
            }
            else
            {
                if( !m_poPanose )
                {
                    if( bPan1 )
                        iRet = -1;
                    else
                        iRet = 1;

                    goto ReturnCompareResult;
                }

                else if(  !(bPan1 && bPan2 ) )
                {
                    //
                    //  We have m_poPanose, but do we have the others?
                    //
                    if( bPan1 )
                        iRet = -1;
                    if( bPan2 )
                        iRet = 1;
                    //
                    // This flag keeps the "No Panose Information" items
                    // always at the bottom of the view.
                    //
                    bNoNegateResult = true;
                    goto ReturnCompareResult;
                }
            }
        }
        else
        {
            goto CompareNames;
        }
    }

    switch( viewMode )
    {
    default:
        switch( m_iSortColumn )
        {
        case FFCOL_DEFAULT:
        case FFCOL_NAME:
CompareNames:
            if( m_bFamilyOnly )
            {
                pFont1->vGetFamName( szFont1 );
                pFont2->vGetFamName( szFont2 );
            }
            else
            {
                pFont1->vGetName( szFont1 );
                pFont2->vGetName( szFont2 );
            }
            iRet = lstrcmpi( szFont1, szFont2 );
            //
            // Use font type for secondary ordering.
            //
            if (0 == iRet)
            {
                iRet = pFont1->iFontType() - pFont2->iFontType();
                //
                // Force non-zero results to -1 or 1.
                //
                if (0 != iRet)
                    iRet = ((iRet < 0) ? -1 : 1);
            }
            break;

        case FFCOL_FILENAME:
            pFont1->vGetFileName( szFont1 );
            pFont2->vGetFileName( szFont2 );
            iRet = lstrcmpi( szFont1, szFont2 );
            break;

        case FFCOL_SIZE:
            iRet = pFont1->dCalcFileSize( ) - pFont2->dCalcFileSize( );
            if( iRet == 0 )
                goto CompareNames;
            break;

        case FFCOL_MODIFIED:
        {
            FILETIME ft1;
            FILETIME ft2;
            BOOL b1, b2;

            b1 = pFont1->GetFileTime( &ft1 );
            b2 = pFont2->GetFileTime( &ft2 );

            if( b1 && b2 )
            {
                if( ft1.dwHighDateTime == ft2.dwHighDateTime )
                {
                    if( ft1.dwLowDateTime > ft2.dwLowDateTime )
                        iRet = -1;
                    else if( ft1.dwLowDateTime < ft2.dwLowDateTime )
                        iRet = 1;
                    else
                        goto CompareNames;
                }
                else if( ft1.dwHighDateTime > ft2.dwHighDateTime )
                {
                    iRet = -1;
                }
                else
                    iRet = 1;
            }
            else if( !b1 && !b2 )
            {
                goto CompareNames;
            }
            else if( b1 )
            {
                iRet = -1;
            }
            else
                iRet = 1;

            break;
        }

        case FFCOL_ATTRIBUTES:
            iRet = CompareByFileAttributes(pFont1, pFont2);
            if (0 == iRet)
                goto CompareNames;
            break;

        }
        break;

    case IDM_VIEW_PANOSE:
        //
        // At this point, we are guaranteed that all three fonts
        // have PANOSE information.
        // The primary key for sorting is the "range" that the
        // difference between each font's panose number and the
        // panose number of the font currently selected in the dropdown
        // combo box falls within.  It's this range that determines the
        // text displayed next to the font in the listview
        // entry (see CFontView::OnNotify).  If two fonts fall into
        // the same range, we use the font face name as the secondary
        // sort key.  This was not done in Win9x or NT4 but I think
        // it's a helpful feature.  Otherwise, the items within a given
        // range are not sorted. [brianau - 3/24/98]
        //
        {
            //
            // Get the difference in panose number between each of the
            // comparison fonts and the font selected in the dropdown combo
            // (m_poPanose).
            //
            int nDiff1 = m_poFontManager->nDiff(m_poPanose, pFont1);
            int nDiff2 = m_poFontManager->nDiff(m_poPanose, pFont2);
            bool bCompareByName = false;

            //
            // Use a filter approach to determine if the two fonts are in
            // the same range (i.e. "similar to", "very similar to" etc.)
            // If they are, we'll sort on font face name to ensure ordering
            // within the ranges.
            //
            if (nDiff1 < 100)
            {
                if (nDiff2 < 100)
                {
                    //
                    // Both diffs < 100.
                    //
                    if (nDiff1 < 30)
                    {
                        if (nDiff2 < 30)
                        {
                            //
                            // Both diffs < 30.
                            //
                            bCompareByName = true;
                        }
                    }
                    else if (nDiff2 >= 30)
                    {
                        //
                        // Both diffs are between 30 and 99 inclusive.
                        //
                        bCompareByName = true;
                    }
                }
            }
            else if (nDiff2 >= 100)
            {
                //
                // Both diffs >= 100.
                //
                bCompareByName = true;
            }
            if (bCompareByName)
            {
                goto CompareNames;
            }
            else
            {
                //
                // Diffs aren't in the same range so sort
                // based on the difference between the two fonts.
                //
                iRet = nDiff1 - nDiff2;
            }
        }

        break;
    }


ReturnCompareResult:

    if (!m_bSortAscending && !bNoNegateResult)
    {
        //
        // Sort descending.  Invert comparison result.
        //
        iRet *= -1;
    }
    return iRet;
}



int CFontView::RegisterWindowClass( )
{
    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: CFontView::RegisterWindowClass" ) ) );
    WNDCLASS wndclass;

    //
    //  If the class was already regestered return success
    //

    if( GetClassInfo( g_hInst, g_szViewClass, &wndclass ) )
    {
       DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: CFontView - class already regestered" ) ) );
       return( 1 );
    }

    wndclass.style         = CS_PARENTDC | CS_DBLCLKS;
    wndclass.lpfnWndProc   = FontViewWndProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = DLGWINDOWEXTRA;

    wndclass.hInstance     = g_hInst;
    wndclass.hIcon         = NULL;
    wndclass.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wndclass.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wndclass.lpszMenuName  = NULL;
    wndclass.lpszClassName = g_szViewClass;

    return( RegisterClass( &wndclass ) );
}


void CFontView::SortObjects( )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "CFontView::SortObjects called" ) ) );
    // DEBUGBREAK;

    ListView_SortItems( m_hwndList, iCompare, ( LPARAM)this );

    DEBUGMSG( (DM_TRACE1, TEXT( "CFontView::SortObjects done" ) ) );
}

void CFontView::FillObjects( )
{
    HCURSOR hCurs;
    SHELLSTATE ss;
    DWORD fShellState = SSF_SHOWALLOBJECTS;

    hCurs = SetCursor( LoadCursor( NULL, IDC_WAIT ) );

#ifdef ALT_TEXT_COLOR
    //
    // Retrieve the "Show compressed files in alternate color" shell setting.
    // Do this here so we respond to the user changing this setting in View-Options.
    //
    fShellState |= SSF_SHOWCOMPCOLOR;
#endif // ALT_TEXT_COLOR

    SHGetSetSettings(&ss, fShellState, FALSE);
    m_bShowHiddenFonts = ss.fShowAllObjects;

#ifdef ALT_TEXT_COLOR
    m_bShowCompColor = ss.fShowCompColor;
#endif

    if( m_bFamilyOnly )
    {
        if (!m_poFontManager->bWaitOnFamilyReset( ))
        {
            //
            // Got a "terminate" signal while waiting on the
            // family reset thread.  Don't continue.
            //
            return;
        }
    }

    CFontList * poList = m_poFontManager->poLockFontList( );

    //
    //  The current selection.
    //

    CFontList * poSel;

    SendMessage( m_hwndList, WM_SETREDRAW, FALSE, 0 );

    //
    //  Save the current selection, if any, off.
    //
    if( FAILED( GetFontList( &poSel, SVGIO_SELECTION ) ) )
        poSel = 0;

    //
    // Call CFontClass::Release for all font objects contained in the ListView.
    //
    ReleaseFontObjects();

    ListView_DeleteAllItems( m_hwndList );

    m_iHidden = 0;

    if( poList )
    {
        int iCount = poList->iCount( );
        CFontClass * poFont;

        //
        //  Tell the ListView how many objects we have.
        //
        ListView_SetItemCount( m_hwndList, iCount );

        DEBUGMSG( (DM_TRACE1, TEXT( "FillObjects..." ) ) );

        for( int i = 0; i < iCount; i++)
        {
            poFont = poList->poObjectAt( i );
            if (m_bShowHiddenFonts || 0 == (FILE_ATTRIBUTE_HIDDEN & poFont->dwGetFileAttributes()))
            {
                if( !m_bFamilyOnly || poFont->bFamilyFont( ) )
                    AddObject( poFont );
                else
                    m_iHidden++;
            }
        }

        DEBUGMSG( (DM_TRACE1, TEXT( "   ...donE\n" ) ) );

        m_poFontManager->vReleaseFontList( );
    }

    SortObjects( );

    //
    //  Reselect the items that were selected before.
    //

    UINT  nState;

    if(poSel)
    {
        if (poSel->iCount())
        {
            int iCount = poSel->iCount( );
            int i;
            int idx;
            LV_FINDINFO lvf;

            lvf.flags = LVFI_PARAM;

            for( i = 0; i < iCount; i++ )
            {
                lvf.lParam = (LPARAM) poSel->poObjectAt( i );
                if( ( idx = ListView_FindItem( m_hwndList, -1, &lvf ) ) > (-1) )
                {
                    nState = ListView_GetItemState( m_hwndList, idx, LVIS_SELECTED );
                    nState |= LVIS_SELECTED;

                    ListView_SetItemState( m_hwndList, idx, nState, LVIS_SELECTED );

                    if( !i )
                        ListView_EnsureVisible( m_hwndList, idx, TRUE );
                }
            }

            poSel->vDetachAll( );
        }
        delete poSel;
    }
    else
    {
        ListView_SetItemState( m_hwndList, 0, LVIS_FOCUSED, LVIS_FOCUSED );
    }

    SendMessage( m_hwndList, WM_SETREDRAW, TRUE, 0 );

    int ciParts[] = {-1};

    LRESULT lRet;

    m_psb->SendControlMsg( FCW_STATUS, SB_SETPARTS,
                           sizeof( ciParts )/sizeof( ciParts[ 0 ] ),
                           (LPARAM)ciParts, &lRet );

    UpdateSelectedCount( );

    SetCursor( hCurs );
}


int CFontView::AddObject( CFontClass * poFont )
{
    LV_ITEM item;

    // DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT:AddObject" ) ) );
    // DEBUGBREAK;


#ifdef _DEBUG
    if( !poFont )
    {
        DEBUGMSG( ( DM_ERROR, TEXT( "AddObject() -- poFont is NULL!" ) ) );
        DEBUGBREAK;
    }
#endif

    poFont->AddRef();  // ListView will hold a pointer.

    item.mask     = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    item.iItem    = 0x7fff;     // add at end
    item.iSubItem = 0;

    item.iImage  = ItemImageIndex(poFont);
    item.pszText = LPSTR_TEXTCALLBACK;
    item.lParam  = (LPARAM) poFont;

    //
    //  If the file isn't in the fonts dir, make it look like a link.
    //
    item.state     = 0;
    item.stateMask = LVIS_OVERLAYMASK;

    if( !poFont->bOnSysDir( ) )
        item.state |= INDEXTOOVERLAYMASK( 1 );

    return( ListView_InsertItem( m_hwndList, &item ) );
}


HRESULT  CFontView::GetUIObjectFromItem( REFIID riid,
                                         LPVOID FAR *ppobj,
                                         UINT nItem )
{
#if 0
    return( ResultFromScode( E_NOTIMPL ) );
#else
    CFontData * poData;
    CFontList * poList;

    HRESULT  hr = GetFontList( &poList, nItem );

    *ppobj = 0;

    if( SUCCEEDED( hr ) )
    {
       poData = new CFontData;

       if( poData && poData->bInit( poList ) )
       {
          poData->AddRef( );
          hr = poData->QueryInterface( riid, ppobj );
          poData->Release( );
       }
       else
       {
           delete poList;
       }
    }

    return hr;
#endif
}

LRESULT CFontView::BeginDragDrop( NM_LISTVIEW FAR * lpn )
{
    LPDATAOBJECT   pdtobj;
    POINT          ptOffset = lpn->ptAction;
    DWORD          dwEffect = DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK;
    CFontList *    poList   = 0;


    //
    //  Store the fact that we started in our window.
    //

    m_bDragSource = TRUE;

    //
    //  Save the anchor point.
    //
       // todo

    //
    //  Get the screen point.
    //

    ClientToScreen( m_hwndList, &ptOffset );


    if(SUCCEEDED(GetUIObjectFromItem(IID_IDataObject,
                                     (void **)&pdtobj,
                                     SVGIO_SELECTION)))
    {
        IDragSourceHelper* pDragSource;
        HRESULT hr = SHCoCreateInstance(NULL,
                                        &CLSID_DragDropHelper,
                                        NULL,
                                        IID_IDragSourceHelper,
                                        (void **)&pDragSource);
        if (SUCCEEDED(hr))
        {
            hr = pDragSource->InitializeFromWindow(m_hwndList, &ptOffset, pdtobj);
            pDragSource->Release();
            
            if (SUCCEEDED(hr))
            {
                CFontData *pFontData = (CFontData *)pdtobj;
                //
                //  If we're going to allow a move, then we have to remove the font
                //  from GDI. Otherwise the move will fail 'cause GDI has the
                //  the file open/locked.
                //
                pFontData->bRFR( );
                pFontData->SetPreferredDropEffect(DROPEFFECT_MOVE);
                pFontData->SetPerformedDropEffect(DROPEFFECT_NONE);
                pFontData->SetLogicalPerformedDropEffect(DROPEFFECT_NONE);

                SHDoDragDrop( m_hwndView, pdtobj, NULL, dwEffect, &dwEffect );

                if( DROPEFFECT_MOVE == pFontData->GetLogicalPerformedDropEffect())
                {
                    m_poFontManager->vToBeRemoved(pFontData->poCloneList());
                }
                else
                {
                    pFontData->bAFR( );
                }
            }
       }

       DAD_SetDragImage( NULL, NULL );
       pdtobj->Release( );
    }

    m_bDragSource = FALSE;

    return 0;
}



int CFontView::OnActivate( UINT uState )
{
    if( m_uState != uState )
    {
        HMENU hMenu;

        OnDeactivate( );

        hMenu = CreateMenu( );

        if( hMenu )
        {
            HMENU hMergeMenu;
            OLEMENUGROUPWIDTHS mwidth = { { 0, 0, 0, 0, 0, 0 } };

            m_hmenuCur = hMenu;
            m_psb->InsertMenusSB( hMenu, &mwidth );

            if( uState == SVUIA_ACTIVATE_FOCUS )
            {
                hMergeMenu = LoadMenu( g_hInst,
                                       MAKEINTRESOURCE( MENU_DEFSHELLVIEW ) );

                if( hMergeMenu )
                {
                      MergeFileMenu( hMenu, GetSubMenu( hMergeMenu, 0 ) );
                      MergeEditMenu( hMenu, GetSubMenu( hMergeMenu, 1 ) );
                      MergeViewMenu( hMenu, GetSubMenu( hMergeMenu, 2 ) );
                      MergeHelpMenu( hMenu, GetSubMenu( hMergeMenu, 3 ) );
                      DestroyMenu( hMergeMenu );
                }
            }
            else
            {
                //
                //  SVUIA_ACTIVATE_NOFOCUS
                //

                hMergeMenu = LoadMenu( g_hInst,
                                       MAKEINTRESOURCE( MENU_DEFSHELLVIEW ) );

                if( hMergeMenu )
                {
                   MergeFileMenu( hMenu, GetSubMenu( hMergeMenu, 0 ) );
                   MergeEditMenu( hMenu, GetSubMenu( hMergeMenu, 1 ) );
                   MergeViewMenu( hMenu, GetSubMenu( hMergeMenu, 2 ) );
                   MergeHelpMenu( hMenu, GetSubMenu( hMergeMenu, 3 ) );
                   DestroyMenu( hMergeMenu );
                }
            }
            BOOL bRemovePreviewMenuItem = (CLICKMODE_DOUBLE == m_iViewClickMode);

#ifndef TOOLTIP_FONTSAMPLE
            bRemovePreviewMenuItem = TRUE;
#endif

            if (bRemovePreviewMenuItem)
            {
                //
                // If Tooltip font samples are not in the build, or if
                // the view is in double-click (std windows) mode, we need
                // to remove the "Preview" item from the "View" menu.
                //
                HMENU hmenuView = GetSubMenu(hMenu, 2);
                if (NULL != hmenuView)
                    DeleteMenu(hmenuView, IDM_VIEW_PREVIEW, MF_BYCOMMAND);
            }

            m_psb->SetMenuSB( hMenu, NULL, m_hwndView );
        }

        m_uState = uState;
    }

    return( 1 );
}


int CFontView::OnDeactivate( )
{
    if( m_uState != SVUIA_DEACTIVATE )
    {
        m_psb->SetMenuSB( NULL, NULL, NULL );
        m_psb->RemoveMenusSB( m_hmenuCur );

        DestroyMenu( m_hmenuCur );

        m_hmenuCur = NULL;
        m_uState = SVUIA_DEACTIVATE;
    }

    return( 1 );
}


int CFontView::MergeToolbar( )
{
    static TBBUTTON tbButtons[] = {
       {0,    IDM_VIEW_ICON,    TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0, -1 /* IDS_TB_FONTS */ },
       {1,    IDM_VIEW_LIST,    TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0, -1 /* IDS_TB_FAMILY */ },
       {2,    IDM_VIEW_PANOSE,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0, -1 /* IDS_TB_FAMILY */ },
       {3,    IDM_VIEW_DETAILS, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0, -1 /* IDS_TB_PANOSE */ },
#ifdef USE_OWNERDRAW
       {0,    0,               0,                  TBSTYLE_SEP,    0,  0 },
       {4,    IDM_VIEW_ACTUAL, TBSTATE_ENABLED,    TBSTYLE_CHECK,  0, -1 /* IDS_TB_IN_FONT */ },
       {0,    0,                0,                 TBSTYLE_SEP,    0,  0 },
       {5,    IDM_POINT_UP,    TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, -1 /* IDS_TB_POINT_UP */ },
       {6,    IDM_POINT_DOWN,  TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, -1 /* IDS_TB_POINT_DOWN */ },
#endif
     };

#define BUTTONCOUNT (sizeof( tbButtons ) / sizeof( TBBUTTON ) )


    //
    //  Add the bitmaps to the cabinet's toolbar (when do we remove them?)
    //


    TBADDBITMAP tbad;

    tbad.hInst = g_hInst;
    tbad.nID   = IDB_TOOLICONS;

    m_psb->SendControlMsg( FCW_TOOLBAR, TB_ADDBITMAP, 7,
                           (LPARAM) &tbad, (LRESULT*) &m_iFirstBitmap );

    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: CFontView::MergeToolbar iFirstBitmap = %d" ),
              m_iFirstBitmap ) );

    //
    //  set the buttons' bitmap indexes then add them to the toolbar
    //

    int i, iSepCount;

    for( i = 0, iSepCount = 0; i < BUTTONCOUNT; i++ )
    {
        if( tbButtons[ i ].fsStyle != TBSTYLE_SEP )
            tbButtons[ i ].iBitmap = i + m_iFirstBitmap - iSepCount;
        else
            iSepCount++;
    }

    m_psb->SetToolbarItems( tbButtons, BUTTONCOUNT, /* FCT_ADDTOEND */ FCT_MERGE );

    return( 1 );
}


#define MAX_FONTSIGNATURE         16   // length of font signature string

INT_PTR CALLBACK CFontView::FontViewDlgProc( HWND hWnd,
                                             UINT message,
                                             WPARAM wParam,
                                             LPARAM lParam )
{
    switch( message )
    {
    case WM_INITDIALOG:
        {
        DEBUGMSG( (DM_MESSAGE_TRACE1,
                  TEXT( "FONTEXT: FontViewWndProc WM_INITDIALOG" ) ) );


       CFontView* prv = (CFontView*)lParam;

#ifdef _DEBUG

        if( !prv )
        {
            DEBUGMSG( (DM_ERROR,TEXT( "FONTEXT: WM_CREATE: Invalid prv" ) ) );
            DEBUGBREAK;
        }
#endif

        SetWindowLongPtr( hWnd, DWLP_USER, (LONG_PTR) prv );

        prv->m_hwndView = hWnd;
        prv->m_hwndList = CreateWindowEx(
                                   WS_EX_CLIENTEDGE,
                                   WC_LISTVIEW, TEXT( "A List View" ),
                                   WSFromViewMode( prv->m_idViewMode ),
                                   0, 0, 50, 50,
                                   hWnd, (HMENU) WID_LISTVIEW, g_hInst, NULL );


        if( !prv->m_hwndList )
        {
           DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: ListView CreateWindowEx failed" ) ) );
           return( 0 );
        }

        prv->m_dwDateFormat = FDTF_DEFAULT;

        WORD  wLCIDFontSignature[MAX_FONTSIGNATURE];
        //
        // Let's verify this is a RTL (BiDi) locale. call GetLocaleInfo with
        // LOCALE_FONTSIGNATURE which always gives back 16 WORDs.
        //
        if( GetLocaleInfo( GetUserDefaultLCID() ,
                         LOCALE_FONTSIGNATURE ,
                         (LPTSTR) &wLCIDFontSignature ,
                         ARRAYSIZE(wLCIDFontSignature)) )
        {
            // Let's verify the bits we have a BiDi UI locale
            // see \windows\winnls\data\other\locale.txt                          ****
            // FONTSIGNATURE          \x60af\x8000\x3848\x1000\x0008\x0000\x0000\x0800\x0040\x0000\x0000\x2000\x0040\x0000\x0000\x2008
            // if this locale is BiDi UI the 8h word will be 0x0800 else it will be 0x0000 and it does not have any #define name.

            if( wLCIDFontSignature[7] & 0x0800 )
            {
                //Get the real list view windows ExStyle.
                DWORD dwLVExStyle = GetWindowLong(prv->m_hwndList, GWL_EXSTYLE);
                if ((BOOLIFY(dwLVExStyle & WS_EX_RTLREADING)) != (BOOLIFY(dwLVExStyle & WS_EX_LAYOUTRTL)))
                    prv->m_dwDateFormat |= FDTF_RTLDATE;
                else
                    prv->m_dwDateFormat |= FDTF_LTRDATE;
            }
         }

        //
        // Set the listview click mode to conform to the user's preference settings
        // in the shell.  Can be either CLICKMODE_SINGLE or CLICKMODE_DOUBLE.
        //
        prv->SetListviewClickMode();

        prv->m_hAccel = LoadAccelerators( g_hInst, MAKEINTRESOURCE( ACCEL_DEF ) );

        //
        //  Create the ComboBox
        //

        prv->m_hwndCombo = GetDlgItem( hWnd, ID_CB_PANOSE );

        //
        //  Remember the default size of the combo. We won't resize it to
        //  anything bigger than this.

        {
            RECT r;

            GetClientRect( prv->m_hwndCombo, &r );
            prv->m_nComboWid = r.right - r.left;
        }

        //
        //  Create the Text description for the combo box
        //

        prv->m_hwndText = GetDlgItem( hWnd, ID_TXT_SIM );

        int IDC_NUMITEMS (IDI_LASTFONTICON - IDI_FIRSTFONTICON + 1);

        UINT uFlags = ILC_MASK | ILC_COLOR32;

        if ( GetWindowLongPtr(prv->m_hwndList , GWL_EXSTYLE) & WS_EX_LAYOUTRTL )
        {
             uFlags |= ILC_MIRROR;
        }
        
        prv->m_hImageList = ImageList_Create( 32, 32, uFlags, IDC_NUMITEMS, 0 );
        prv->m_hImageListSmall = ImageList_Create( 16, 16, uFlags, IDC_NUMITEMS, 0 );

        //
        //  Load our icons.
        //

        HICON hIcon;
        HICON hIconSmall;
        UINT  i;

        for(  i = IDI_FIRSTFONTICON; i <= IDI_LASTFONTICON; i++ )
        {
            hIcon = (HICON) LoadImage( g_hInst, MAKEINTRESOURCE( i ),
                                       IMAGE_ICON, 0, 0,
                                       LR_DEFAULTCOLOR | LR_DEFAULTSIZE );
            if( hIcon )
            {
               ImageList_AddIcon( prv->m_hImageList, hIcon );

               hIconSmall = (HICON) LoadImage( g_hInst, MAKEINTRESOURCE( i ),
                                               IMAGE_ICON, 16, 16,
                                               LR_DEFAULTCOLOR );

               if( hIconSmall )
               {
                    ImageList_AddIcon( prv->m_hImageListSmall, hIconSmall );
                    DestroyIcon( hIconSmall );
               }

               DestroyIcon( hIcon );
            }
        }

        //
        //  Extract the link icon from SHELL32.DLL
        //

        ExtractIconEx( TEXT( "SHELL32.DLL" ), IDI_X_LINK - 1, &hIcon,
                       &hIconSmall, 1 );

        if( hIcon )
        {
            ImageList_AddIcon( prv->m_hImageList, hIcon );
            DestroyIcon( hIcon );

            if( hIconSmall )
            {
                ImageList_AddIcon( prv->m_hImageListSmall, hIconSmall );
                DestroyIcon( hIconSmall );
            }
            IDC_NUMITEMS++;  // Add 1 for "link" icon.
        }

        //
        //  Specify the overlay images.
        //

        ImageList_SetOverlayImage( prv->m_hImageList, IDC_NUMITEMS - 1, 1 );
        ImageList_SetOverlayImage( prv->m_hImageListSmall, IDC_NUMITEMS - 1, 1 );

        ListView_SetImageList( prv->m_hwndList, prv->m_hImageList, LVSIL_NORMAL );
        ListView_SetImageList( prv->m_hwndList, prv->m_hImageListSmall, LVSIL_SMALL );

        ListView_SetExtendedListViewStyleEx(prv->m_hwndList, 
                                            LVS_EX_LABELTIP, 
                                            LVS_EX_LABELTIP);

#undef IDC_NUMITEMS

        DEBUGMSG( (DM_MESSAGE_TRACE1, TEXT( "FONTEXT: FontViewWndProc WM_INITDIALOG" ) ) );

        //
        //  We need to retrieve more information if we are in details or
        //  panose view.
        //

        if( prv->m_idViewMode == IDM_VIEW_PANOSE )
        {
            prv->vLoadCombo( );
            SetListColumns( prv->m_hwndList, PAN_COL_COUNT, PanoseColumns );
            prv->UpdatePanColumn( );
        }
        else if( prv->m_idViewMode == IDM_VIEW_DETAILS )
        {
            SetListColumns( prv->m_hwndList, FILE_COL_COUNT, FileColumns );
        }

#ifdef TOOLTIP_FONTSAMPLE
        //
        // Create and initialize the tooltip window.
        //
        prv->CreateToolTipWindow();

#endif // TOOLTIP_FONTSAMPLE

        //
        // Register with the shell for file-attribute change notifications.
        //
        SHChangeNotifyEntry fsne;
        fsne.pidl        = NULL;
        fsne.fRecursive  = FALSE;

        prv->m_uSHChangeNotifyID = SHChangeNotifyRegister(prv->m_hwndView,
                                                          SHCNRF_NewDelivery | SHCNRF_ShellLevel,
                                                          SHCNE_UPDATEIMAGE | SHCNE_DISKEVENTS,
                                                          WM_SHELL_CHANGE_NOTIFY,
                                                          1,
                                                          &fsne);

        SetWindowPos(prv->m_hwndCombo,
                     prv->m_hwndList,
                     0, 0, 0, 0,
                     SWP_NOSIZE |
                     SWP_NOMOVE);

        //
        //  Return 0 so SetFocus() doesn't get called.
        //

        return( 0 );
        }
        break;

    default:
        break;
    }

    return( 0 );
}


LRESULT CALLBACK CFontView::FontViewWndProc( HWND hWnd,
                                             UINT message,
                                             WPARAM wParam,
                                             LPARAM lParam )
{
    DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "FONTEXT: FontViewWndProc Called m=0x%x wp=0x%x lp=0x%x" ),
              message, wParam, lParam) );

    CFontView* prv = (CFontView*) GetWindowLongPtr( hWnd, DWLP_USER );

    //
    //  'prv' won't be valid for any messages that comes before WM_CREATE
    //

    if( prv )
        return( prv->ProcessMessage( hWnd, message, wParam, lParam ) );
    else
        return( DefDlgProc( hWnd, message, wParam, lParam ) );

    return( 0 );
}


typedef struct {
   UINT  nMenuID;
   UINT  nStatusID;
} MENU_STATUS;


const MENU_STATUS MenuStatusMap[] = {
   {IDM_FILE_SAMPLE     , IDST_FILE_SAMPLE    },
   {IDM_FILE_PRINT      , IDST_FILE_PRINT     },
   {IDM_FILE_INSTALL    , IDST_FILE_INSTALL   },
   {IDM_FILE_LINK       , IDST_FILE_LINK      },
   {IDM_FILE_DEL        , IDST_FILE_DEL       },
   {IDM_FILE_RENAME     , IDST_FILE_RENAME    },
   {IDM_FILE_PROPERTIES , IDST_FILE_PROPERTIES},

   {IDM_EDIT_SELECTALL   , IDST_EDIT_SELECTALL    },
   {IDM_EDIT_SELECTINVERT, IDST_EDIT_SELECTINVERT },
   {IDM_EDIT_CUT         , IDST_EDIT_CUT          },
   {IDM_EDIT_COPY        , IDST_EDIT_COPY         },
   {IDM_EDIT_PASTE       , IDST_EDIT_PASTE        },
   {IDM_EDIT_UNDO        , IDST_EDIT_UNDO         },

   {IDM_VIEW_ICON       , IDST_VIEW_ICON    },
   {IDM_VIEW_LIST       , IDST_VIEW_LIST    },
   {IDM_VIEW_PANOSE     , IDST_VIEW_PANOSE  },
   {IDM_VIEW_DETAILS    , IDST_VIEW_DETAILS },

   {IDM_VIEW_VARIATIONS , IDST_VIEW_VARIATIONS },
   {IDM_VIEW_PREVIEW    , IDST_VIEW_PREVIEW },

   {IDM_HELP_TOPIC      , IDST_HELP_TOPICS },

   // THIS MUST BE LAST !!!!!!
   //
   {IDX_NULL, 0}

};


//
//  This is to put messages in the status bar
//

int CFontView::OnMenuSelect( HWND hWnd,
                             UINT nID,      // Menu item or Popup menu id
                             UINT nFlags,   // Menu flags
                             HMENU hMenu )  // HANDLE of menu clicked.
{
    UINT  nStat = IDX_NULL;

    //
    //  Is the menu closing? i.e. the user pressed escape.
    //

    if( (LOWORD( nFlags ) == 0xffff ) && (hMenu == 0 ) )
    {
            StatusPop( );
            return( 0 );
    }

    //
    //  What to do if this is a popup?
    //

    if( !(nFlags & MF_POPUP ) )
    {
        const MENU_STATUS * pms = MenuStatusMap;

        //
        //  Walk the id to status map
        //

        for(  ; pms->nMenuID != IDX_NULL; pms++ )
        {
            if( pms->nMenuID == nID )
            {
               nStat = pms->nStatusID;
               break;
            }
        }
    }

    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: OnMenuSelect: MenuID: %d   StatusID: %d" ),
               nID, nStat) );

    if( nStat == IDX_NULL )
    {
       StatusClear( );
    }
    else
    {
       StatusPush( nStat );
    }

    return( 0 );
}


inline int InRange( UINT id, UINT idFirst, UINT idLast )
{
    return( (id-idFirst) <= (idLast-idFirst) );
}


int CFontView::OnCommand( HWND hWnd,
                          UINT message,
                          WPARAM wParam,
                          LPARAM lParam )
{
    DEBUGMSG( (DM_MESSAGE_TRACE1, TEXT( "FONTEXT: CFontView::OnCommand Called m=0x%x wp=0x%x lp=0x%x" ),
             message, wParam, lParam) );

    HMENU hMenu = m_hmenuCur;
    UINT uID = GET_WM_COMMAND_ID( wParam, lParam );


    switch( uID )
    {
    case IDM_FILE_DEL:
        OnCmdDelete( );
        break;

    case IDM_EDIT_CUT:
    case IDM_EDIT_COPY:
        OnCmdCutCopy( uID );
        break;

    case IDM_EDIT_PASTE:
        OnCmdPaste( );
        break;

    case ID_CB_PANOSE:
        switch( GET_WM_COMMAND_CMD( wParam, lParam ) )
        {
        case CBN_SELCHANGE:
            {
            DEBUGMSG( (DM_TRACE1,TEXT( "CBN_SELCHANGE" ) ) );

            int iSlot = (int)::SendMessage( m_hwndCombo,  CB_GETCURSEL, 0, 0 );

            if( iSlot != CB_ERR )
                m_poPanose = (CFontClass *)::SendMessage( m_hwndCombo,
                                                          CB_GETITEMDATA,
                                                          iSlot,
                                                          0 );
            else
                m_poPanose = NULL;

            if (FFCOL_PANOSE != m_iSortColumn)
            {
                m_bSortAscending = TRUE;
                m_iSortColumn    = FFCOL_PANOSE;
            }

            SortObjects( );
            m_iSortLast = FFCOL_PANOSE;

            UpdatePanColumn( );

            }
            break;

         default:
            return 0;
         }
         break;

    case IDM_FILE_PROPERTIES:
        OnCmdProperties( );
        break;

    case IDM_EDIT_SELECTALL:
    case IDM_EDIT_SELECTINVERT:
        vToggleSelection( uID == IDM_EDIT_SELECTALL );
        break;

    case IDM_VIEW_VARIATIONS:
        m_bFamilyOnly = !m_bFamilyOnly;

        if ( m_bFamilyOnly &&
            m_poFontManager &&
            m_poFontManager->bFamiliesNeverReset() )
        {
            m_poFontManager->vResetFamilyFlags();
        }

        FillObjects( );

        break;

#ifdef TOOLTIP_FONTSAMPLE

    case IDM_VIEW_PREVIEW:
        m_bShowPreviewToolTip = !m_bShowPreviewToolTip;
        SendMessage(m_hwndToolTip, TTM_ACTIVATE, m_bShowPreviewToolTip, 0);
        break;

#endif // TOOLTIP_FONTSAMPLE

    case IDM_VIEW_ICON:
        m_ViewModeReturn = FVM_ICON;
        goto DoSetViewMode;

    case IDM_VIEW_LIST:
        m_ViewModeReturn = FVM_LIST;
        goto DoSetViewMode;

    case IDM_VIEW_DETAILS:
    case IDM_VIEW_PANOSE:
        m_ViewModeReturn = FVM_DETAILS;
        goto DoSetViewMode;

DoSetViewMode:
        SetViewMode( (UINT)wParam );
        break;

    case IDM_FILE_SAMPLE:
        OpenCurrent( );
        break;

    case IDM_FILE_PRINT:
        PrintCurrent( );
        break;

    case IDM_FILE_INSTALL:
//        if( bCPAddFonts( m_hwndParent ) )
        if( bCPAddFonts( m_hwndView ) )
        {
            vCPWinIniFontChange( );
        }
        break;

    case IDM_POPUP_MOVE:
        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: OnCommand: IDM_POPUP_MOVE" ) ) );
        m_dwEffect = DROPEFFECT_MOVE;
        break;

    case IDM_POPUP_COPY:
        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: OnCommand: IDM_POPUP_COPY" ) ) );
        m_dwEffect = DROPEFFECT_COPY;
        break;

    case IDM_POPUP_LINK:
        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: OnCommand: IDM_POPUP_LINK" ) ) );
        m_dwEffect = DROPEFFECT_LINK;
        break;

    case IDCANCEL:
    case IDM_POPUP_CANCEL:
        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: OnCommand: IDM_POPUP_CANCEL" ) ) );
        m_dwEffect = DROPEFFECT_NONE;
        break;

    case IDM_HELP_TOPIC:
        OnHelpTopics(m_hwndView);
        return 0;
    }

    return( 1L );

}

void
CFontView::OnHelpTopics(
    HWND hWnd
    )
{
    if (!IsOS(OS_ANYSERVER))
    {
        //
        // If not on server, launch Help & Support to the proper topic.
        //
        SHELLEXECUTEINFOW sei = {0};
        sei.cbSize = sizeof(sei);
        sei.lpFile = L"hcp://services/subsite?node=Unmapped/Control_Panel&select=Unmapped/Control_Panel/Appearance_and_Themes/Fonts";
        sei.hwnd   = m_hwndView;
        sei.nShow  = SW_NORMAL;
        ShellExecuteExW(&sei);
    }
    else
    {
        typedef HWND (WINAPI * PFNHTMLHELPA)(HWND, LPCSTR, UINT, ULONG_PTR);
        
        //
        // We're on server.  Launch winhelp.
        //
        HINSTANCE hmodHHCtrlOcx = LoadLibrary(TEXT("hhctrl.ocx"));
        if (NULL != hmodHHCtrlOcx)
        {
            PFNHTMLHELPA pfnHelp = (PFNHTMLHELPA)GetProcAddress(hmodHHCtrlOcx, "HtmlHelpA");
            if (NULL != pfnHelp)
            {
                const char szHtmlHelpFileA[]  = "FONTS.CHM > windefault";
                const char szHtmlHelpTopicA[] = "windows_fonts_overview.htm";

                (*pfnHelp)(hWnd,
                           szHtmlHelpFileA,
                           HH_DISPLAY_TOPIC,
                           (DWORD_PTR)szHtmlHelpTopicA);
            }
            FreeLibrary(hmodHHCtrlOcx);
        }
    }
}


//
// This code was taken from shell32's defview.
//
void
CFontView::UpdateUnderlines(
    void
    )
{
    DWORD cb;
    DWORD dwUnderline = ICON_IE;
    DWORD dwExStyle;

    //
    // Read the icon underline settings.
    //
    cb = sizeof(dwUnderline);
    SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                    TEXT("IconUnderline"),
                    NULL,
                    &dwUnderline,
                    &cb,
                    FALSE,
                    &dwUnderline,
                    cb);

    //
    // If it says to use the IE link settings, read them in.
    //
    if (dwUnderline == ICON_IE)
    {
        dwUnderline = ICON_YES;

        TCHAR szUnderline[8];
        cb = sizeof(szUnderline);
        SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                        TEXT("Anchor Underline"),
                        NULL,
                        szUnderline,
                        &cb,
                        FALSE,
                        szUnderline,
                        cb);

        //
        // Convert the string to an ICON_ value.
        //
        if (!lstrcmpi(szUnderline, TEXT("hover")))
            dwUnderline = ICON_HOVER;
        else if (!lstrcmpi(szUnderline, TEXT("no")))
            dwUnderline = ICON_NO;
        else
            dwUnderline = ICON_YES;
    }

    //
    // Convert the ICON_ value into an LVS_EX value.
    //
    switch (dwUnderline)
    {
        case ICON_NO:
            dwExStyle = 0;
            break;

        case ICON_HOVER:
            dwExStyle = LVS_EX_UNDERLINEHOT;
            break;

        case ICON_YES:
            dwExStyle = LVS_EX_UNDERLINEHOT | LVS_EX_UNDERLINECOLD;
            break;
    }

    //
    // Set the new LVS_EX_UNDERLINE flags.
    //
    ListView_SetExtendedListViewStyleEx(m_hwndList,
                                        LVS_EX_UNDERLINEHOT |
                                        LVS_EX_UNDERLINECOLD,
                                        dwExStyle);
}


//
// Set the proper listview "click mode" depending upon the user's
// preferences in the shell.
// Returns: New click mode. CLICKMODE_SINGLE or CLICKMODE_DOUBLE.
//
CFontView::CLICKMODE
CFontView::SetListviewClickMode(
    VOID
    )
{
    SHELLSTATE ss;
    DWORD dwStyle;
    BOOL bSingleClick;

    //
    // Get the current double-click setting in the shell (user pref).
    //
    SHGetSetSettings(&ss, SSF_WIN95CLASSIC | SSF_DOUBLECLICKINWEBVIEW, FALSE);

    //
    // Get the current listview style bits.
    //
    dwStyle = ListView_GetExtendedListViewStyle(m_hwndList);

    //
    // We get single-click if user wants no web view or single-click in web view.
    // SINGLECLICK = WEBVIEW && !DBLCLICKINWEBVIEW
    //
    bSingleClick = !ss.fWin95Classic && !ss.fDoubleClickInWebView;

    if (bSingleClick)
    {
        if (0 == (dwStyle & LVS_EX_ONECLICKACTIVATE))
        {
            //
            // User wants single click but list is double click..
            // Set listview to single-click mode.
            //
            ListView_SetExtendedListViewStyleEx(m_hwndList,
                                               LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE,
                                               LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE);
        }
    }
    else if (dwStyle & LVS_EX_ONECLICKACTIVATE)
    {
        //
        // Turn off preview tooltips.
        //
        m_bShowPreviewToolTip = FALSE;
        SendMessage(m_hwndToolTip, TTM_ACTIVATE, m_bShowPreviewToolTip, 0);

        //
        // User wants double click but list is single click.
        // Set listview to double click mode.
        //
        ListView_SetExtendedListViewStyleEx(m_hwndList,
                                           LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE,
                                           0);
    }
    m_iViewClickMode = bSingleClick ? CLICKMODE_SINGLE : CLICKMODE_DOUBLE;

    UpdateUnderlines();

    return m_iViewClickMode;
}


void CFontView::UpdateSelectedCount( )
{
    int iCount;
    int iTemplate;
    TCHAR szText[ 128 ];
    TCHAR szStatus[ 128 ];

    iCount = (int) SendMessage( m_hwndList, LVM_GETSELECTEDCOUNT, 0, 0 );

    iTemplate = IDS_SELECTED_FONT_COUNT;

    if( !iCount )
    {
        iCount = (int) SendMessage( m_hwndList, LVM_GETITEMCOUNT, 0, 0 );
        iTemplate = IDS_TOTAL_FONT_COUNT;

        if( m_iHidden )
        {
            iTemplate = IDS_TOTAL_AND_HIDDEN_FONT_COUNT;
        }
    }

    LoadString( g_hInst, iTemplate, szText, ARRAYSIZE( szText ) );

    wsprintf( szStatus, szText, iCount, m_iHidden );

    HWND hwndStatus;

    m_psb->GetControlWindow( FCW_STATUS, &hwndStatus );

    SendMessage( hwndStatus, SB_SETTEXT, 0, (LPARAM) szStatus );
}


//
// Update a font object in the font view following a shell change notification.
// This picks up the color change (if desired by user) and the change to the
// attributes column in details view.
//
void CFontView::UpdateFontViewObject(CFontClass *pFont)
{
    if (NULL != pFont)
    {
        int i = 0;
        LV_FINDINFO lvfi;
        lvfi.flags    = LVFI_PARAM;
        lvfi.psz      = NULL;
        lvfi.lParam   = (LPARAM)pFont;

        //
        // Get the list view index for the object and redraw it.
        //
        i = ListView_FindItem(m_hwndList, -1, &lvfi);
        if (-1 != i)
        {
            ListView_RedrawItems(m_hwndList, i, i);
        }
    }
}


//
// Handles a shell change notification.
// If the path passed in the notification is the path to a font file in the folder,
// the function invalidates the font's cached file attributes and updates the
// object's visual appearance.
//
int CFontView::OnShellChangeNotify(WPARAM wParam, LPARAM lParam)
{
    LPSHChangeNotificationLock pshcnl;
    LPITEMIDLIST *ppidl = NULL;
    LONG lEvent = 0;

    pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);
        
    if (NULL != pshcnl && NULL != ppidl && NULL != *ppidl)
    {
        LPITEMIDLIST pidlPath = *ppidl;

        TCHAR szPath[MAX_PATH];
        LPTSTR pszFileName = NULL;

        if (SHGetPathFromIDList(pidlPath, szPath))
        {
            pszFileName = PathFindFileName(szPath);
            CFontClass *pFont = m_poFontManager->poSearchFontListFile(pszFileName);

            if (NULL != pFont)
            {
                //
                // This event applies to a font object.
                // Invalidate the font object's cached file attributes.
                // Update the font object's visual appearance.
                //
                pFont->InvalidateFileAttributes();
                UpdateFontViewObject(pFont);
            }
        }
        SHChangeNotification_Unlock(pshcnl);
    }
    return (int)lParam;
}


//
// Handle custom draw notification from list view.
// This is where we tell the list view to draw the item in
// normal (uncompressed) or alternate (compressed) color.
// Note this is for NT only.  Non-NT tells the listview
// control to use the default color.
//
int CFontView::OnCustomDrawNotify(LPNMHDR lpn)
{

#ifdef ALT_TEXT_COLOR

    LPNMLVCUSTOMDRAW lpCD = (LPNMLVCUSTOMDRAW)lpn;

    if (WID_LISTVIEW == lpn->idFrom)
    {
        switch (lpCD->nmcd.dwDrawStage)
        {
            case CDDS_PREPAINT:
                return m_bShowCompColor ? CDRF_NOTIFYITEMDRAW : CDRF_DODEFAULT;

            case CDDS_ITEMPREPAINT:
                {
                    CFontClass * poFont = (CFontClass *)( lpCD->nmcd.lItemlParam );
                    if (NULL != poFont)
                    {
                        if (DWORD(-1) != poFont->dwGetFileAttributes() &&
                            poFont->dwGetFileAttributes() & FILE_ATTRIBUTE_COMPRESSED)
                        {
                            lpCD->clrText = g_crAltColor;
                        }
                    }
                    return CDRF_DODEFAULT;
                }
        }
    }
#endif // ALT_TEXT_COLOR

    return CDRF_DODEFAULT;
}



int CFontView::OnNotify( LPNMHDR lpn )
{
    NM_LISTVIEW FAR * pnmv = (NM_LISTVIEW FAR *) lpn;

    // DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT - WM_NOTIFY with code: %d(%x)" ), ((NMHDR*)lParam)->code, ((NMHDR*)lParam)->code ) );

    switch( lpn->code )
    {
    case TBN_BEGINDRAG:
        OnMenuSelect( 0, ((LPTBNOTIFY) lpn)->iItem, 0, 0 );
        break;

    case TBN_ENDDRAG:
        StatusPop( );
        break;

    case NM_CUSTOMDRAW:
        return OnCustomDrawNotify(lpn);

    case LVN_ITEMACTIVATE:
        OnLVN_ItemActivate((LPNMITEMACTIVATE)lpn);
        break;

    case LVN_BEGINDRAG:
    case LVN_BEGINRDRAG:
        BeginDragDrop( pnmv );
        break;

#ifdef TOOLTIP_FONTSAMPLE

    case LVN_HOTTRACK:
        LV_OnHoverNotify((LPNMLISTVIEW)lpn);
        break;

#endif // TOOLTIP_FONTSAMPLE


    case LVN_GETINFOTIP:
        LV_OnGetInfoTip((LPNMLVGETINFOTIP)lpn);
        break;        

    case LVN_GETDISPINFO:
        {
        LV_DISPINFO FAR *pnmv = (LV_DISPINFO FAR *) lpn;
        CFontClass * poFont = (CFontClass *)( pnmv->item.lParam );
        UINT mask = pnmv->item.mask;

        //
        // DEBUGMSG( (DM_MESSAGE_TRACE1, TEXT( "FONTEXT: LVN_GETDISPINFO for item %d, subitem %d" ),
        //      pnmv->item.iItem, pnmv->item.iSubItem) );

        if( mask & LVIF_TEXT )
        {
            // DEBUGMSG( (DM_MESSAGE_TRACE1, TEXT( "   Wants text information" ) ) );

            static TCHAR szText[ 64 ];

            //
            //  The text we get depends on the view we are currently in.
            //

            switch( m_idViewMode )
            {
            default:
            // case IDM_VIEW_ICON:
            // case IDM_VIEW_LIST:
                if( m_bFamilyOnly )
                    poFont->vGetFamName( szText );
                else
                    poFont->vGetName( szText );
                break;

            case IDM_VIEW_PANOSE:
                switch( pnmv->item.iSubItem )
                {
                default:
                // case 0:
                    if( m_bFamilyOnly )
                        poFont->vGetFamName( szText );
                    else
                        poFont->vGetName( szText );
                    break;

                case 1:  // Panose match info.
                    if( !m_poPanose )
                        szText[ 0 ] =0;
                    else if( !poFont->bHavePANOSE( ) )
                    {
                        LoadString( g_hInst, IDS_NO_PAN_INFO, szText,
                                    ARRAYSIZE( szText ) );
                    }
                    else
                    {
                        USHORT nDiff = m_poFontManager->nDiff( m_poPanose,
                                                               poFont );

                        if( nDiff < 30 )
                            LoadString( g_hInst, IDS_PAN_VERY_SIMILAR, szText,
                                        ARRAYSIZE( szText ) );
                        else if( nDiff < 100 )
                            LoadString( g_hInst, IDS_PAN_SIMILAR, szText,
                                        ARRAYSIZE( szText ) );
                        else
                            LoadString( g_hInst, IDS_PAN_NOT_SIMILAR, szText,
                                        ARRAYSIZE( szText ) );
                    }
                    break;
                }
                break;

            case IDM_VIEW_DETAILS:
                switch( pnmv->item.iSubItem )
                {
                default:
                case 0:
                    poFont->vGetName( szText );
                    break;

                case 1:
                    poFont->vGetFileName( szText );
                    break;

                case 2:  // Size
                    {
                    TCHAR szFmt[ 64 ];

                    LoadString( g_hInst, IDS_FMT_FILEK, szFmt,
                                ARRAYSIZE( szFmt ) );

                    wsprintf( szText, szFmt, poFont->dCalcFileSize( ) );
                    }
                    break;

                case 3:  // Modification date and time.
                    {
                        FILETIME ft;
                        DWORD dwFormat = m_dwDateFormat;

                        szText[ 0 ] = 0;

                        if( poFont->GetFileTime( &ft ) )
                        {
                            SHFormatDateTime(&ft, &dwFormat, szText, ARRAYSIZE(szText));
                        }
                    }
                    break;

                case 4:  // File attributes.
                    BuildAttributeString(poFont->dwGetFileAttributes(),
                                         szText,
                                         ARRAYSIZE(szText));
                    break;

                }
                break;
            }  // switch

            lstrcpyn(pnmv->item.pszText, szText, pnmv->item.cchTextMax);
        } // LVIF_TEXT
        } // LVN_GETDISPINFO
        break;


    case LVN_ITEMCHANGED:
        if( pnmv->uChanged & LVIF_STATE &&
            ( (pnmv->uNewState ^ pnmv->uOldState) & LVIS_SELECTED) )
        {
            UpdateSelectedCount( );
        }
        break;


    case LVN_COLUMNCLICK:
    {
        //
        //  start and stops busy cursor
        //

        WaitCursor cWaiter;

        m_iSortColumn = pnmv->iSubItem;
        if (m_iSortColumn != m_iSortLast)
        {
            //
            // Selected new column.  Reset sort order.
            //
            m_bSortAscending = TRUE;
        }
        else
        {
            //
            // Column selected for a second time. Invert the sort order.
            //
            m_bSortAscending = !m_bSortAscending;
        }

        SortObjects( );

        m_iSortLast = m_iSortColumn;

        break;
    }

    case TTN_NEEDTEXT:
         if( lpn->idFrom >= IDM_VIEW_ICON && lpn->idFrom <= IDM_VIEW_DETAILS )
         {
            //
            //  Query for some text to display for the toolbar.
            //

            LPTOOLTIPTEXT lpt = (LPTOOLTIPTEXT)lpn;

            lpt->lpszText = (LPTSTR) MAKEINTRESOURCE( IDS_VIEW_ICON
                                                      + lpn->idFrom
                                                      - IDM_VIEW_ICON );
            lpt->hinst = g_hInst;
        }
        break;

    case NM_SETFOCUS:
        //
        //   We should call IShellBrowser::OnViewWindowActive() before
        //   calling its InsertMenus().
        //

        m_psb->OnViewWindowActive( this );

        //
        // Only call OnActivate() if UIActivate() has been called.
        // If OnActivate() is called before UIActivate(), the menus
        // are merged before IShellView is properly activated.
        // This results in missing menu items.
        //
        if (m_bUIActivated)
            OnActivate( SVUIA_ACTIVATE_FOCUS );

        break;

    } // switch( notify code )

    return( 0 );
}


void
CFontView::LV_OnGetInfoTip(
    LPNMLVGETINFOTIP lpnm
    )
{
    LVITEM item;

    item.iItem    = lpnm->iItem;
    item.iSubItem = 0;
    item.mask     = LVIF_PARAM;
    if (ListView_GetItem(m_hwndList, &item) && 0 != item.lParam)
    {
        NMLVDISPINFO lvdi;
        ZeroMemory(&lvdi, sizeof(lvdi));

        lvdi.hdr.code        = LVN_GETDISPINFO;
        lvdi.hdr.hwndFrom    = m_hwndList;
        lvdi.item.iItem      = lpnm->iItem;
        lvdi.item.iSubItem   = lpnm->iSubItem;
        lvdi.item.mask       = LVIF_TEXT;
        lvdi.item.pszText    = lpnm->pszText;
        lvdi.item.cchTextMax = lpnm->cchTextMax;
        lvdi.item.lParam     = item.lParam;
        OnNotify((LPNMHDR)&lvdi);
    }
}    



//
// Handle an item in the listview being clicked with the mouse.
//
VOID
CFontView::OnLVN_ItemActivate(
    LPNMITEMACTIVATE pnma
    )
{
    if (LVKF_ALT & pnma->uKeyFlags)
    {
        //
        // ALT+Click --> Properties page.
        // Click (dbl or single) dependent on user's settings.
        //
        OnCmdProperties();
    }
    else
    {
        //
        // Opening a font invokes the font viewer.
        //
        OpenCurrent();
    }
}


//
// Determine which icon represents a font.
//
INT
CFontView::ItemImageIndex(
    CFontClass *poFont
    )
{
    //
    // All indexes are offsets in the imagelist.
    // Default to an FON file.
    //
    INT iImage = IDI_FON - IDI_FIRSTFONTICON;

    //
    // First check for TTC because TTC is also TrueType.
    //
    if(poFont->bTTC())
    {
        iImage = IDI_TTC - IDI_FIRSTFONTICON;
    }
    else if (poFont->bOpenType() || poFont->bTrueType())
    {
        //
        // Use our IExtractIcon icon handler to determine
        // which icon to display for the TrueType or OpenType font.
        //
        // FEATURE:  The problem with this is that it opens the
        //          font files for a second time.  Font files
        //          are opened for identification when they're
        //          first loaded into the folder.  Ideally, we would
        //          identify the appropriate icon at that point.
        //          I don't want to mess with that code right now.
        //          This code path will result in exactly the same icon
        //          used by the shell so this will ensure consistency.
        //          [brianau - 6/13/97]
        //
        TCHAR szFileName[MAX_PATH];
        poFont->bGetFQName(szFileName, ARRAYSIZE(szFileName));

        iImage = IDI_TTF;
        if (SUCCEEDED(m_IconHandler.Load(szFileName, 0)))
        {
            UINT uFlags = 0;
            m_IconHandler.GetIconLocation(GIL_FORSHELL,
                                          L"", // Force call to wide-char version.
                                          0,
                                          &iImage,
                                          &uFlags);
        }
        ASSERT(IDI_OTFp == iImage ||
               IDI_OTFt == iImage ||
               IDI_TTF  == iImage);

        iImage -= IDI_FIRSTFONTICON;
    }
    else if(poFont->bType1())
    {
        iImage = IDI_T1 - IDI_FIRSTFONTICON;
    }

    return iImage;
}



void CFontView::OnDropFiles( HDROP hDrop, DWORD dwEffect )
{
    FullPathName_t szFile;
    BOOL           bAdded = FALSE;

    //
    //  Starts and stops busy cursor
    //

    WaitCursor    cWaiter;
    UINT cnt = ::DragQueryFile( hDrop, (UINT)-1, NULL, 0 );

    for( UINT i = 0; i < cnt; )
    {
        ::DragQueryFile( hDrop, i, szFile, ARRAYSIZE( szFile ) );

        StatusPush( szFile );

        switch( CPDropInstall( m_hwndView,
                               szFile,
                               dwEffect,
                               NULL,
                               (int) (cnt - ++i) ) )
        {
        case CPDI_SUCCESS:
            bAdded = TRUE;
            break;

        case CPDI_FAIL:
            break;

        case CPDI_CANCEL:
            i = cnt; // leave the loop;
            break;
        }

        StatusPop( );
    }

    ::DragFinish( hDrop );

    if( bAdded )
    {
        vCPWinIniFontChange( );
    }

}


void CFontView::UpdateMenuItems( HMENU hMenu )
{
    CheckMenuRadioItem( hMenu,
                        IDM_VIEW_ICON,
                        IDM_VIEW_DETAILS,
                        m_idViewMode,
                        MF_BYCOMMAND );

    //
    //  Enable and disable those items based on selection.
    //

    UINT nFlag = ((iCurrentSelection( ) > 0 ) ? cLiveMenu : cDeadMenu );


    EnableMenuItem( hMenu, IDM_FILE_SAMPLE    , nFlag );
    EnableMenuItem( hMenu, IDM_FILE_PRINT     , nFlag );
    EnableMenuItem( hMenu, IDM_FILE_DEL       , nFlag );
    EnableMenuItem( hMenu, IDM_FILE_PROPERTIES, nFlag );
    EnableMenuItem( hMenu, IDM_EDIT_COPY      , nFlag );

    //
    //  If there is a file with a format on the clipboard that we can
    //  understand, then enable the menu.
    //

    nFlag = ((IsClipboardFormatAvailable( CF_HDROP ) ) ? cLiveMenu : cDeadMenu );

    EnableMenuItem( hMenu, IDM_EDIT_PASTE     , nFlag );

    //
    //  Are we hiding the variations of a font?
    //
    CheckMenuItem( hMenu, IDM_VIEW_VARIATIONS, m_bFamilyOnly ? MF_CHECKED
                                                             : MF_UNCHECKED );

#ifdef TOOLTIP_FONTSAMPLE
    CheckMenuItem(hMenu, IDM_VIEW_PREVIEW, m_bShowPreviewToolTip ? MF_CHECKED
                                                                 : MF_UNCHECKED );
#endif

}


void CFontView::UpdateToolbar( )
{
    LRESULT    lRet;

    m_psb->SendControlMsg( FCW_TOOLBAR, TB_CHECKBUTTON,
                           m_idViewMode, MAKELONG( TRUE, 0 ), &lRet );

}


HRESULT CFontView::GetFontList( CFontList **ppoList, UINT nItem )
{
    BOOL        bDeleteFam = m_bFamilyOnly;
    CFontClass* lpFontRec;
    LV_ITEM     Item;

    *ppoList = 0;

    if( nItem != SVGIO_SELECTION )
    {
        return ResultFromScode( E_FAIL );
    }

    //
    //  Build up a list of the fonts to be deleted
    //

    CFontList * poList = new CFontList( 10, 10 );

    if( !poList || !poList->bInit( ) )
    {
        return ResultFromScode( E_FAIL );
    }

    //
    //  Save it.
    //

    *ppoList = poList;

    //
    //  Start at the beginning.
    //

    int i = -1;

    UINT  nFlags = LVNI_SELECTED | LVNI_ALL;

    Item.mask = LVIF_PARAM;

    while( ( i = ListView_GetNextItem( m_hwndList, i, nFlags ) ) != -1 )
    {
        Item.iItem = i;
        Item.iSubItem = 0;

        ListView_GetItem( m_hwndList, &Item );

        lpFontRec = ( CFontClass *)Item.lParam;

        //
        //  If this font represents a whole family, then delete the whole
        //  family.
        //

        if( m_bFamilyOnly )
            m_poFontManager->vGetFamily( lpFontRec, poList );
        else
            poList->bAdd( lpFontRec );

    }  //  End of loop on selected fonts.

    return NOERROR;
}


void CFontView::OnCmdPaste( )
{
    //
    //  associate it with current task
    //

    if( OpenClipboard( NULL ) )
    {
        HGLOBAL hmem = GetClipboardData( CF_HDROP );

        if( hmem )
        {
            //
            // There is a CF_HDROP. Create CIDLData from it.
            //

            UINT  cb    = (UINT)GlobalSize( hmem );
            HDROP hdrop = (HDROP) GlobalAlloc( GPTR, cb );

            if( hdrop )
            {
                hmemcpy( (LPVOID)hdrop, GlobalLock( hmem ), cb );

                GlobalUnlock( hmem );

                OnDropFiles( hdrop, DROPEFFECT_COPY );

                //
                //  We already free this in OnDropFiles, so don't free again
                //
                //  GlobalFree( hdrop );
                //
            }
        }
        CloseClipboard( );
    }
}


void CFontView::OnCmdCutCopy( UINT nID )
{
    LPDATAOBJECT   pdtobj;


    if( SUCCEEDED( GetUIObjectFromItem( IID_IDataObject,
                                        (void **) &pdtobj,
                                        SVGIO_SELECTION ) ) )
    {
        FFSetClipboard( pdtobj );

        pdtobj->Release( );
    }
}


void CFontView::OnCmdDelete( )
{
    BOOL        bDeleteFile = FALSE;
    BOOL        bSomeDel    = FALSE;
    CFontList * poList;


    if( !SUCCEEDED( GetFontList( &poList, SVGIO_SELECTION ) ) )
    {
        iUIErrMemDlg(m_hwndList);
        return;
    }

    //
    //  Update our view and notify other apps of font changes.
    //

    if( poList->iCount( ) )
    {
        //
        //  warn first so that canceling out now won't nuke all the fonts
        //  you have selected in
        //
        if( iUIMsgBox( m_hwndList, IDSI_FMT_DELETECONFIRM, IDS_MSG_CAPTION,
                       MB_YESNO | MB_ICONEXCLAMATION, NULL ) == IDYES )
        {
           m_poFontManager->vDeleteFontList( poList );
//         vCPWinIniFontChange( );
        }
    }

    //
    //  empty the font list. They are all deleted anyway.
    //

    poList->vDetachAll( );
    delete poList;
}


void CFontView::OnCmdProperties( )
{
#if 1 // def EMR
    CFontClass*    poFont;
    BOOL           bDeleteFam  = m_bFamilyOnly;
    BOOL           bDeleteFile = FALSE;
    BOOL           bSomeDel    = FALSE;
    BOOL           bYesAll     = FALSE;

    FullPathName_t szFile;

    LV_ITEM          Item;
    SHELLEXECUTEINFO se;

    static TCHAR  szCmd[] = TEXT( "Properties" );

    //
    //  Start at the beginning.
    //

    int i = -1;

    UINT  nFlags = LVNI_SELECTED | LVNI_ALL;


    Item.mask = LVIF_PARAM;

    while( ( i = ListView_GetNextItem( m_hwndList, i, nFlags ) ) != -1 )
    {
        Item.iItem    = i;
        Item.iSubItem = 0;

        ListView_GetItem( m_hwndList, &Item );

        poFont = (CFontClass *) Item.lParam;

        poFont->vGetDirFN( szFile );

        // SHObjectProperties( m_hwndParent, SHOP_FILEPATH, szFile, NULL );

        memset( &se, 0, sizeof( se ) );

        se.cbSize = sizeof( se );
        se.fMask  = SEE_MASK_INVOKEIDLIST;
        se.hwnd   = m_hwndView;
        se.lpVerb = szCmd;
        se.lpFile = szFile;
        se.nShow  = 1;

        ShellExecuteEx( &se );
    }
#endif
}


void CFontView::OldDAD_DropTargetLeaveAndReleaseData(void)
{
    DragLeave();

    if (NULL != m_pdtobjHdrop)
    {
        m_pdtobjHdrop->Release();
        m_pdtobjHdrop = NULL;
    }
}


//
// CFontView::OldDAD_HandleMessages
//
// This function handles all messages associated with Win3.1-style drag-and-drop operations.
// The code was copied from a similar implementation in DEFVIEWX.C.  Minor changes have been
// made to create CFontView member functions and to produce the correct drag-and-drop
// behavior for the font folder.
//
LRESULT CFontView::OldDAD_HandleMessages(UINT message, WPARAM wParam, const DROPSTRUCT *lpds)
{
    DWORD dwAllowedDADEffect = DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK;

    //
    // We don't need to do this hack if NT defined POINT as typedef POINTL.
    //
    union {
        POINT ptScreen;
        POINTL ptlScreen;
    } drop;

    ASSERT(SIZEOF(drop.ptScreen)==SIZEOF(drop.ptlScreen));

    if (NULL != lpds)   // Notes: lpds is NULL, if uMsg is WM_DROPFILES.
    {
        drop.ptScreen = lpds->ptDrop;
        ClientToScreen(GetViewWindow(), &drop.ptScreen);
    }

    switch (message)
    {
        case WM_DRAGSELECT:

            //
            // WM_DRAGSELECT is sent to a sink whenever an new object is dragged inside of it.
            // wParam: TRUE if the sink is being entered, FALSE if it's being exited.
            //
            if (wParam)
            {
                if (NULL != m_pdtobjHdrop)
                {
                    //
                    // can happen if old target fails to generate drag leave properly
                    //
                    OldDAD_DropTargetLeaveAndReleaseData();
                }

                if (SUCCEEDED(CIDLData_CreateFromIDArray(NULL, 0, NULL, &m_pdtobjHdrop)))
                {
                    //
                    // promise the CF_HDROP by setting a NULL handle
                    // indicating that this dataobject will have an hdrop at Drop() time
                    //
                    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                    STGMEDIUM medium;

                    medium.tymed          = TYMED_HGLOBAL;
                    medium.hGlobal        = (HGLOBAL)NULL;
                    medium.pUnkForRelease = NULL;

                    m_pdtobjHdrop->SetData(&fmte, &medium, TRUE);

                    DWORD dwMouseKey = MK_LBUTTON;
                    if (GetAsyncKeyState(VK_SHIFT) & 0x80000000)
                        dwMouseKey |= MK_SHIFT;

                    DragEnter(m_pdtobjHdrop, dwMouseKey, drop.ptlScreen, &dwAllowedDADEffect);
                    m_dwOldDADEffect = dwAllowedDADEffect;
                }
            }
            else
            {
                OldDAD_DropTargetLeaveAndReleaseData();
            }
            break;

        case WM_DRAGMOVE:
            //
            // WM_DRAGMOVE is sent to a sink as the object is being dragged within it.
            // wParam: Unused
            //
            if (NULL != m_pdtobjHdrop)
            {
                DWORD dwMouseKey = MK_LBUTTON;
                if (GetAsyncKeyState(VK_SHIFT) & 0x80000000)
                    dwMouseKey |= MK_SHIFT;

                DragOver(dwMouseKey, drop.ptlScreen, &dwAllowedDADEffect);
                m_dwOldDADEffect = dwAllowedDADEffect;
            }
            break;

        case WM_QUERYDROPOBJECT:

            switch (lpds->wFmt)
            {
                case DOF_SHELLDATA:
                case DOF_DIRECTORY:
                case DOF_DOCUMENT:
                case DOF_MULTIPLE:
                case DOF_EXECUTABLE:
                    //
                    // assume all targets can accept HDROP if we don't have the data object yet
                    // we will accept the drop
                    //
                    return TRUE;
            }
            return FALSE;           // don't accept

        case WM_DROPOBJECT:
            if (NULL == m_pdtobjHdrop)
                return FALSE;

            //
            // Check the format of dragged object.
            //
            switch (lpds->wFmt)
            {
                case DOF_EXECUTABLE:
                case DOF_DOCUMENT:
                case DOF_DIRECTORY:
                case DOF_MULTIPLE:
                case DOF_PROGMAN:
                case DOF_SHELLDATA:
                    //
                    // We need to unlock this window if this drag&drop is originated
                    // from the shell itself.
                    //
                    DAD_DragLeave();

                    //
                    // The source is Win 3.1 app (probably FileMan), request HDROP.
                    // Send us a WM_DROPFILES with HDROP
                    //
                    return DO_DROPFILE;
            }
            break;

        case WM_DROPFILES:
            OnDropFiles((HDROP)wParam, m_dwOldDADEffect);
            break;
    }

    return 0;   // Unknown format. Don't drop any
}


void FocusOnSomething(HWND hwndLV)
{
    INT iFocus;

    iFocus = ListView_GetNextItem(hwndLV, -1, LVNI_FOCUSED);
    if (-1 == iFocus)
        iFocus = 0;

    ListView_SetItemState(hwndLV, iFocus, LVIS_FOCUSED, LVIS_FOCUSED);
}


LRESULT CFontView::ProcessMessage( HWND hWnd,
                                   UINT message,
                                   WPARAM wParam,
                                   LPARAM lParam )
{
    DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "FONTEXT: CFontView::ProcMess Called m=0x%x wp=0x%x lp=0x%x" ),
              message, wParam, lParam ) );

    switch( message )
    {

    //
    // Desktop properties applet sends a WM_WININICHANGE when
    // the icon font is changed.  Just send the message on to the list view control.
    // This causes the list view to update using the new font.
    //
#ifdef WINNT
    case WM_WININICHANGE:
#else
    case WM_SETTINGCHANGE:
#endif
        //
        // Only handle this if the "section" is not "fonts".
        // I know this sounds weird but this is to prevent a double update
        // because vCPWinIniFontChange sends a WM_WININICHANGE and a
        // WM_FONTCHANGE whenever fonts are added or deleted to/from the folder.
        // In the WM_WININICHANGE, it sets the section string to "fonts".  We
        // use this to determine that the message came from vCPWinIniFontChange.
        //
        if (0 != lstrcmp((LPCTSTR)lParam, TEXT("fonts")))
        {
            SendMessage( m_hwndList, message, wParam, lParam );

            if (0 == lstrcmp((LPCTSTR)lParam, TEXT("intl")))
            {
                if (IDM_VIEW_DETAILS == m_idViewMode)
                {
                    //
                    // We're in "details" mode and the user might have just
                    // changed the date format.  Update the listview.  This is
                    // how the shell's defview handles this.
                    //
                    InvalidateRect(m_hwndList, NULL, TRUE);
                }
            }            
        }
        
        //
        // When changing from single to double-click mode, the shell broadcasts a WM_SETTINGCHANGE.
        //
        SetListviewClickMode();
        {
            //
            // If we received WM_SETTINGCHANGE because the user changed listview click mode,
            // we want to update the "View" menu to either add or remove the "Preview"
            // menu item.  Deactivating the view and restoring it to it's previous mode
            // does the trick.
            //
            UINT uState = m_uState;
            OnDeactivate();
            OnActivate(uState);
        }
        return 0;

    case WM_FONTCHANGE:
        //
        //  Make sure the FontManager gets refreshed before we draw the
        //  window.
        //
        {
            WaitCursor oWait;
            m_poFontManager->bRefresh( TRUE );
        }
        Refresh( );
        break;


    case WM_INITMENUPOPUP:
        UpdateMenuItems( m_hmenuCur );
        break;

    //
    // Handle drops from Win3.1 (File Manager) apps the same as the shell
    // does in defviewx.c (with a few font folder-specific mods).
    //
    case WM_DROPOBJECT:
    case WM_QUERYDROPOBJECT:
    case WM_DRAGLOOP:
    case WM_DRAGSELECT:
    case WM_DRAGMOVE:
    case WM_DROPFILES:
        return OldDAD_HandleMessages(message, wParam, (const DROPSTRUCT *)lParam);

    case WM_DESTROY:
        {
        m_bUIActivated = FALSE;
        //
        //  Remove ourself from the Clipboard chain.
        //

        ChangeClipboardChain( hWnd, m_hwndNextClip );

        //
        // Call CFontClass::Release() for each font contained in the ListView.
        //
        ReleaseFontObjects();

        return( 1 );
        }


    case WM_CHANGECBCHAIN:
        //
        //  If the next window is closing, repair the chain.
        //

        if( (HWND) wParam == m_hwndNextClip )
            m_hwndNextClip = (HWND) lParam;

        //
        //  Otherwise, pass the message to the next link.
        //

        else if( m_hwndNextClip != NULL )
            SendMessage( m_hwndNextClip, message, wParam, lParam );

        break;

    case WM_DRAWCLIPBOARD:
        //
        //  Notify the next viewer in the chain.
        //

        if( m_hwndNextClip )
            SendMessage( m_hwndNextClip, message, wParam, lParam );

        //
        //  Unhook ourself from the clipboard chain.
        //

        ChangeClipboardChain( hWnd, m_hwndNextClip );
        m_hwndNextClip = NULL;

        break;


    case WM_CONTEXTMENU:
    {
        UINT  nMenu;

        nMenu = (iCurrentSelection( ) > 0 ) ? IDM_POPUPS : IDM_POPUP_NOITEM;

        //
        //  Pop up the context menu.
        //

        HMENU hMenu = LoadMenu( g_hInst, MAKEINTRESOURCE( nMenu ) );

        if( hMenu )
        {
            HMENU hPopup = GetSubMenu( hMenu, 0 );

            if(  hPopup )
            {
                //
                //  Bold the Open menuitem.
                //

                if( nMenu == IDM_POPUPS )
                {
                    MENUITEMINFO iInfo;

                    iInfo.cbSize = sizeof( iInfo );
                    iInfo.fMask = MIIM_STATE;

                    if( GetMenuItemInfo( hMenu, IDM_FILE_SAMPLE, FALSE, &iInfo ) )
                    {
                       iInfo.fState |= MFS_DEFAULT;
                       SetMenuItemInfo( hMenu, IDM_FILE_SAMPLE, FALSE , &iInfo );
                    }
                }
                else
                {
                    UINT nFlag = ( (IsClipboardFormatAvailable( CF_HDROP ) )
                                                    ? cLiveMenu : cDeadMenu );

                    EnableMenuItem( hMenu, IDM_EDIT_PASTE, nFlag );

                    CheckMenuRadioItem(hMenu,
                                       IDM_VIEW_ICON,
                                       IDM_VIEW_DETAILS,
                                       m_idViewMode,
                                       MF_BYCOMMAND);
                }

                DWORD    dwPoint = (DWORD)lParam;

                //
                //  now get the popup positiong:
                //

                if( dwPoint == (DWORD) -1 )
                {
                    POINT pt;
                    int iItem;

                    //
                    //  keyboard...
                    //  Find the selected item
                    //

                    iItem = ListView_GetNextItem( m_hwndList, -1, LVNI_SELECTED );

                    if( iItem != -1 )
                    {
                        RECT rc;
                        int iItemFocus = ListView_GetNextItem( m_hwndList,
                                            -1, LVNI_FOCUSED | LVNI_SELECTED );

                        if( iItemFocus == -1 )
                            iItemFocus = iItem;

                        //
                        //  Note that LV_GetItemRect returns it in client
                        //  coordinate!
                        //

                        ListView_GetItemRect( m_hwndList, iItemFocus,
                                              &rc, LVIR_ICON );

                        pt.x = ( rc.left+rc.right ) / 2;
                        pt.y = ( rc.top+rc.bottom ) / 2;
                    }
                    else
                    {
                        pt.x = pt.y = 0;
                    }

                    MapWindowPoints( m_hwndList, HWND_DESKTOP, &pt, 1 );

                    dwPoint = MAKELONG( pt.x, pt.y );
                }


                TrackPopupMenuEx( hPopup,
                            TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                            GET_X_LPARAM( dwPoint ),  // x pos
                            GET_Y_LPARAM( dwPoint ),  // y pos.
                            m_hwndView,
                            NULL );
            }
            DestroyMenu( hMenu );
        }
    }
    break;

    case WM_COMMAND:
       if( !(GET_WM_COMMAND_ID( wParam, lParam ) > FCIDM_SHVIEWLAST ) )
            return( OnCommand( hWnd, message, wParam, lParam ) );
       break;

    case WM_MENUSELECT:
        return( OnMenuSelect( hWnd, (UINT)LOWORD( wParam ),
                (UINT)HIWORD( wParam ), (HMENU)lParam ) );

#ifdef USE_OWNERDRAW
    case WM_MEASUREITEM:
        SetDimensions( );
        return( OnMeasureItem( (LPMEASUREITEMSTRUCT)lParam ) );

    case WM_DRAWITEM:
        return( OnDrawItem( (LPDRAWITEMSTRUCT)lParam ) );
#endif

    case WM_SETFOCUS:
        if( !m_hwndView )
            //
            //  Ignore if we are destroying hwndView.
            //
            break;

        if( m_hwndList )
        {
            //
            //  pass this to the listview
            //
            SetFocus( m_hwndList );
            UpdateSelectedCount();
            FocusOnSomething(m_hwndList);
        }

        break;

    case WM_SIZE:
        {
        DEBUGMSG( (DM_MESSAGE_TRACE1, TEXT( "FONTEXT: CFontView::ProcessMessage WM_SIZE" ) ) );

        if( wParam != SIZEICONIC )
        {
            //
            // Resize the view.
            // Set "resizing" flag so we know to intercept WM_ERASEBKGND.
            // Helps eliminate flashing of the window during resize.
            //
            m_bResizing = TRUE;
            vShapeView( );
            m_bResizing = FALSE;
        }

        return( 1 );

        }


    case WM_ERASEBKGND:
        if (m_bResizing)
        {
            //
            // Resizing the window.
            // Eat WM_ERASEBKGND so the dialog surface behind the listview
            // isn't repainted.  This helps eliminate flashing of the window during
            // resizing.
            //
            return 1;
        }
        else
        {
            return DefDlgProc(hWnd, message, wParam, lParam);
        }

    case WM_NOTIFY:
        return OnNotify( (LPNMHDR) lParam );

    case WM_SHELL_CHANGE_NOTIFY:
        return OnShellChangeNotify( wParam, lParam );

    default:
        return( DefDlgProc( hWnd, message, wParam, lParam ) );
    } // switch( message )

    return( 0 );
}


BOOL CFontView::OpenCurrent( )
{
    LV_ITEM  Item;

    //
    //  Start at the beginning.
    //

    int  i = -1;
    UINT nFlags = LVNI_SELECTED | LVNI_ALL;


    Item.mask = LVIF_PARAM;

    GetAsyncKeyState( VK_ESCAPE );

    while( ( i = ListView_GetNextItem( m_hwndList, i, nFlags ) ) != -1 )
    {
        if( GetAsyncKeyState( VK_ESCAPE ) & 0x01 )
        {
            break;
        }

        Item.iItem = i;
        Item.iSubItem = 0;

        if( ListView_GetItem( m_hwndList, &Item ) )
        {
            CFontClass * poFont = (CFontClass *)Item.lParam;

            if( !ViewValue( poFont ) )
                return FALSE;
        }
    }
    return TRUE;;
}


BOOL CFontView::PrintCurrent( )
{
    LV_ITEM  Item;
    CFontClass * poFont;

    //
    //  Start at the beginning.
    //

    int i = -1;
    UINT  nFlags = LVNI_SELECTED | LVNI_ALL;


    Item.mask = LVIF_PARAM;

    GetAsyncKeyState( VK_ESCAPE );

    while( ( i = ListView_GetNextItem( m_hwndList, i, nFlags ) ) != -1 )
    {
        if( GetAsyncKeyState( VK_ESCAPE ) & 0x01 )
        {
            break;
        }

        Item.iItem = i;
        Item.iSubItem = 0;

        if( ListView_GetItem( m_hwndList, &Item ) )
        {
            poFont = (CFontClass *)Item.lParam;

            if( !PrintValue( poFont ) )
                return FALSE;
        }
    }

    return TRUE;
}

BOOL CFontView::ViewValue( CFontClass * poFont )
{
    FullPathName_t szFile;
    HINSTANCE      hInst;


    poFont->vGetDirFN( szFile );

    DEBUGMSG( (DM_TRACE1, TEXT( "   Browsing object: %s" ), szFile ) );

    hInst = ShellExecute( m_hwndView, NULL, szFile, szFile, NULL, 1 );

    if( ( (INT_PTR)hInst ) > 32 )
        return TRUE;

    DEBUGMSG( (DM_ERROR, TEXT( "ViewValue failed on %s, %d" ), szFile, hInst) );

    return FALSE;
}


BOOL CFontView::PrintValue( CFontClass * poFont )
{
    FullPathName_t szFile;
    HINSTANCE      hInst;


    poFont->vGetDirFN( szFile );

    DEBUGMSG( (DM_TRACE1, TEXT( "   Browsing object: %s" ), szFile) );

    hInst = ShellExecute( m_hwndView, TEXT( "print" ), szFile, szFile, NULL, 1 );

    if( ( (INT_PTR)hInst ) > 32 )
        return TRUE;

    DEBUGMSG( ( DM_ERROR, TEXT( "ViewValue failed on %s, %d" ), szFile, hInst ) );

    return FALSE;
}


void CFontView::UpdatePanColumn( )
{

    LV_COLUMN  lvc;
    TCHAR      szFmt[ MAX_NAME_LEN ];
    TCHAR      szText[ MAX_NAME_LEN ];


    if( m_idViewMode != IDM_VIEW_PANOSE )
        return;

    if( LoadString( g_hInst, IDS_PAN_COL2, szFmt, ARRAYSIZE( szFmt ) ) )
    {
        TCHAR szName[ MAX_NAME_LEN ];

        if( m_poPanose )
            m_poPanose->vGetName( szName );
        else
            szName[ 0 ] = 0;

        wsprintf( szText, szFmt, szName );
    }
    else
        szText[ 0 ] = 0;

    lvc.mask     = LVCF_TEXT | LVCF_SUBITEM;
    lvc.pszText  = szText;
    lvc.iSubItem = 1;

    ListView_SetColumn( m_hwndList, 1, &lvc );
}


void CFontView::vToggleSelection( BOOL bSelectAll )
{
    //
    //  Start at the beginning.
    //

    int i = -1;

    UINT  nFlags = LVNI_ALL;
    UINT  nState = LVIS_SELECTED;


    while( ( i = ListView_GetNextItem( m_hwndList, i, nFlags ) ) != -1 )
    {
        if( !bSelectAll )
        {
            nState = ListView_GetItemState( m_hwndList, i, LVIS_SELECTED );
            nState = nState ^ LVIS_SELECTED;
        }

        ListView_SetItemState( m_hwndList, i , nState, LVIS_SELECTED );
    }
}


int  CFontView::iCurrentSelection( )
{
    return (int) ListView_GetSelectedCount( m_hwndList );
}


void CFontView::SetViewMode( UINT uMode )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: SetViewMode %d" ), uMode) );

    if( uMode != m_idViewMode )
    {
        UINT  ws = WSFromViewMode( uMode, m_hwndList );

        m_idViewMode = uMode;

        switch( uMode )
        {
        default: // case IDM_VIEW_ICON:
            break;


        case IDM_VIEW_PANOSE:
            //
            //  Make sure the combo box is loaded with the names.
            //
            vLoadCombo( );

            SetListColumns( m_hwndList, PAN_COL_COUNT, PanoseColumns );

            //
            //  The second column contains format text that we can put the
            //  current font name into.
            //

            UpdatePanColumn( );

            break;


         case IDM_VIEW_DETAILS:
            SetListColumns( m_hwndList, FILE_COL_COUNT, FileColumns );
            break;
        }

        ULONG ulOld = SetWindowLong( m_hwndList, GWL_STYLE, ws );

        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: SetviewMode from %x to %x" ), ulOld, ws) );

        vShapeView( );

        SortObjects( );

        InvalidateRect( m_hwndList, NULL, TRUE );

        UpdateWindow( m_hwndList );

        UpdateToolbar( );
    }
}


void CFontView::vShapeView( )
{
    RECT  rc;
    BOOL  bPanoseView = m_idViewMode == IDM_VIEW_PANOSE;
    int   nCmdShow    = bPanoseView ? SW_SHOW : SW_HIDE;

    //
    // Hide or show panose controls depending on view mode.
    //
    ShowWindow( m_hwndCombo, nCmdShow );
    ShowWindow( m_hwndText, nCmdShow );

    //
    // Get size of dialog (view) so we can size the listview control.
    //
    GetClientRect( m_hwndView, &rc );

    if (bPanoseView)
    {
        //
        // Panose view adds the "List by similarity" combo box
        // and text.  Adjust the top of the listview control to be
        // adjacent to the bottom of the combo box area.
        //
        RECT  rCombo;
        GetWindowRect( m_hwndCombo, &rCombo );
        ScreenToClient( m_hwndView, (LPPOINT)&rCombo );
        ScreenToClient( m_hwndView, ((LPPOINT)&rCombo) + 1 );
        rc.top = rCombo.bottom + 6;
    }

    //
    // Resize the list view control.
    //
    MoveWindow( m_hwndList, rc.left, rc.top, rc.right-rc.left,
                rc.bottom-rc.top, TRUE );
}


void CFontView::vLoadCombo( )
{
    int            iAdd;
    FONTNAME     szName;
    FONTNAME     szSelName;
    CFontClass*    lpFontRec;
    CFontList * poFontList = m_poFontManager->poLockFontList( );
    int            iCount = poFontList->iCount( );
    int            iOldSel;

    //
    //  Reset the Panose origin.
    //

    m_poPanose = NULL;

#ifdef _DEBUG
    szName[ ARRAYSIZE( szName ) - 1 ] = 0;
    szSelName[ ARRAYSIZE( szSelName ) - 1 ] = 0;
#endif

    iOldSel = (int)::SendMessage( m_hwndCombo, CB_GETCURSEL, 0, 0 );

    if( iOldSel != CB_ERR )
        ::SendMessage( m_hwndCombo, CB_GETLBTEXT, iOldSel, (LPARAM)szSelName );

        ::SendMessage( m_hwndCombo, CB_RESETCONTENT, 0, 0 );

    for( int i = 0; i < iCount; ++i )
    {
        lpFontRec = poFontList->poObjectAt( i );

        if( lpFontRec->bLTDAndPANOSE( ) )
        {
            lpFontRec->vGetName( szName );
            iAdd = (int)::SendMessage( m_hwndCombo, CB_ADDSTRING, 0,
                                       (LPARAM)szName );

            ::SendMessage( m_hwndCombo, CB_SETITEMDATA, iAdd,
                           (LPARAM)lpFontRec );
        }
    }

    if( iOldSel == CB_ERR )
    {
        iOldSel = 0;
        ::SendMessage( m_hwndCombo, CB_GETLBTEXT, iOldSel, (LPARAM)szSelName );
    }

    if( iOldSel != CB_ERR )
    {
        i = (int)::SendMessage( m_hwndCombo, CB_FINDSTRINGEXACT,
                           (WPARAM) -1, (LPARAM) szSelName );

        if( i != CB_ERR )
        {
            m_poPanose = (CFontClass *)::SendMessage( m_hwndCombo,
                                                      CB_GETITEMDATA, i, 0 );
        }
        ::SendMessage( m_hwndCombo, CB_SETCURSEL, i, 0 );
    }

    m_poFontManager->vReleaseFontList( );

    ASSERT( szName[ ARRAYSIZE( szName ) - 1 ] == 0 );
    ASSERT( szSelName[ ARRAYSIZE( szSelName ) - 1 ] == 0 );
}


STDMETHODIMP CFontView::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
    *ppvObj = NULL;

    DEBUGMSG( (DM_NOEOL | DM_TRACE1,
             TEXT( "FONTEXT: CFontView::QueryInterface called for " ) ) );
    //
    //  Dump out the riid
    //

    DEBUGREFIID( (DM_TRACE1, riid) );

    if( riid == IID_IUnknown )
       *ppvObj = (IUnknown*)( IShellView*)this;

    if( riid == IID_IShellView )
       *ppvObj = (IShellView*) this;

    if( riid == IID_IDropTarget )
       *ppvObj = (IDropTarget*) this;

    if( riid == IID_IPersistFolder )
       *ppvObj = (IPersistFolder*) this;

    if( *ppvObj )
    {
       ((LPUNKNOWN)*ppvObj)->AddRef( );
       return NOERROR;
    }

    return( ResultFromScode( E_NOINTERFACE ) );
}


STDMETHODIMP_(ULONG) CFontView::AddRef( void )
{
   DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::AddRef called: %d->%d references" ),
              m_cRef, m_cRef + 1) );

   return( ++m_cRef );
}


STDMETHODIMP_(ULONG) CFontView::Release( void )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::Release called: %d->%d references" ),
             m_cRef, m_cRef - 1) );

    ULONG retval;


    retval = --m_cRef;

    if( !retval )
    {
        DestroyViewWindow( );
        delete this;
    }

    return( retval );
}


//
// *** IOleWindow methods ***
//

STDMETHODIMP CFontView::GetWindow( HWND FAR * lphwnd )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::GetWindow called" ) ) );

    *lphwnd = m_hwndView;
    return S_OK;
}


STDMETHODIMP CFontView::ContextSensitiveHelp( BOOL fEnterMode )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::ContextSensitiveHelp called" ) ) );

    return( ResultFromScode( E_NOTIMPL ) );
}


//
// *** IShellView methods ***
//
STDMETHODIMP CFontView::TranslateAccelerator( LPMSG msg )
{
    DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "FONTEXT: CFontView::TranslateAccelerator called" ) ) );
    DEBUGMSG( (DM_MESSAGE_TRACE2,
       TEXT( "FONTEXT:        hwnd=0x%x, message=0x%x, wParam=0x%x, lParam=0x%lx," ),
       msg->hwnd, msg->message, msg->wParam, msg->lParam) );
    DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "FONTEXT:         time=0x%x, pt=?" ),
             msg->time) );


    BOOL fIsVK_TABCycler = IsVK_TABCycler(msg);
    BOOL fIsBackSpace = IsBackSpace(msg);

    if (GetFocus() == m_hwndList)
    {
        if (::TranslateAccelerator(m_hwndView, (HACCEL) m_hAccel, msg))
        {
            // we know we have a normal view, therefore this is
            // the right translate accelerator to use, otherwise the
            // common dialogs will fail to get any accelerated keys.
            return S_OK;
        }
        else if (WM_KEYDOWN == msg->message || WM_SYSKEYDOWN == msg->message)
        {
            // MSHTML eats these keys for frameset scrolling, but we
            // want to get them to our wndproc . . . translate 'em ourself
            //
            switch (msg->wParam)
            {
            case VK_LEFT:
            case VK_RIGHT:
                // only go through here if alt is not down.
                // don't intercept all alt combinations because
                // alt-enter means something (open up property sheet)
                // this is for alt-left/right compat with IE
                // remark: when debugging, if put break point at if statement, function will not work.
                if (GetAsyncKeyState(VK_MENU) < 0)
                    break;
                // fall through
                
            case VK_UP:
            case VK_DOWN:
            case VK_HOME:
            case VK_END:
            case VK_PRIOR:
            case VK_NEXT:
            case VK_RETURN:
            case VK_F10:
                TranslateMessage(msg);
                DispatchMessage(msg);
                return S_OK;
            }
        }

        // suwatch: If this message is neither VK_TABCycler nor Backspace, try send it to ShellBrowser first.
        if (!fIsVK_TABCycler && !fIsBackSpace)
        {
            if (S_OK == m_psb->TranslateAcceleratorSB(msg, 0))
                return S_OK;
        }
    }

    // suwatch: Backspace and all Alt key combination will be handled by default.
    // Backspace will navigate up the tree.
    // We assume all Alt key combo will be handled by default.
    if (fIsBackSpace || GetKeyState(VK_MENU) < 0)
    {
        return S_FALSE;
    }

    //
    //  If the view has the combo box showing, make sure it gets processed
    //  correctly.
    //
    if( m_idViewMode == IDM_VIEW_PANOSE )
    {
        if( msg->message == WM_KEYFIRST || msg->message == WM_KEYDOWN )
        {

            TCHAR ch = GET_WM_CHARTOITEM_CHAR( msg->wParam, msg->lParam );

            if( ch == VK_TAB && GetFocus( ) == m_hwndCombo )
            {
                return S_FALSE;
            }
        }

        //
        // Handle accelerator translations for Panose view mode.
        //
        if( m_hAccel &&  ::TranslateAccelerator( m_hwndView, (HACCEL) m_hAccel, msg ) )
        {
            return S_OK;
        }

        //
        //  This will handle Alt+L and TAB for all other cases.
        //
        if( IsDialogMessage( m_hwndView, msg ) )
        {
            return S_OK;
        }
    }
    //
    //  If the combo box isn't visible, the processing is easier.
    //
    else if( GetFocus( ) != m_hwndList )
    {
        if( IsDialogMessage( m_hwndView, msg ) )
            return S_OK;
    }

    if( m_hAccel &&  ::TranslateAccelerator( m_hwndView, (HACCEL) m_hAccel, msg ) )
        return S_OK;



        
    return S_FALSE;
}


STDMETHODIMP CFontView::EnableModeless( BOOL fEnable )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::EnableModless called" ) ) );
    return( ResultFromScode( E_NOTIMPL ) );
}


STDMETHODIMP CFontView::UIActivate( UINT uState )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::UIActivate called, uState = %d" ), uState) );

    if( uState != SVUIA_DEACTIVATE )
    {
        OnActivate( uState );
        m_bUIActivated = TRUE;
    }
    else
        OnDeactivate( );

    return NOERROR;
}


STDMETHODIMP CFontView::Refresh( )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::Refresh start" ) ) );

    FillObjects( );

    if( m_idViewMode == IDM_VIEW_PANOSE )
        vLoadCombo( );

    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::Refresh Done" ) ) );

    return( NOERROR );
}


STDMETHODIMP CFontView::CreateViewWindow( IShellView FAR* lpPrevView,
                                          LPCFOLDERSETTINGS lpfs,
                                          IShellBrowser FAR* psb,
                                          RECT FAR* prcView,
                                          HWND FAR* phWnd )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::CreateViewWindow called" ) ) );

    //
    //  Should check lpPrevView for validity
    //

    if( !RegisterWindowClass( ) )
    {
        DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: CFontView - Unable to register window class" ) ) );

        // return( ResultFromScode( E_FAIL ) );
    }

    if (FAILED(GetFontManager(&m_poFontManager)))
    {
        return E_FAIL;
    }

    //
    //  Save off the browser and retrieve our settings before we draw
    //  the window.
    //

    m_psb = psb;

    GetSavedViewState( );

    psb->GetWindow( &m_hwndParent );

    //
    // Load the attribute character string.
    //
    if (TEXT('\0') == g_szAttributeChars[0])
    {
        LoadString(g_hInst,
                   IDS_ATTRIB_CHARS,
                   g_szAttributeChars,
                   ARRAYSIZE(g_szAttributeChars));
    }

#ifdef ALT_TEXT_COLOR
    //
    // Fetch the alternate color (for compression) if supplied.
    //
    {
        //
        // If not open, open key to explorer settings.
        //
        if (NULL == g_hkcuExplorer)
            RegOpenKeyEx(HKEY_CURRENT_USER,
                         REGSTR_PATH_EXPLORER,
                         0,
                         KEY_READ,
                         &g_hkcuExplorer);

        if (NULL != g_hkcuExplorer)
        {
            DWORD cbData = sizeof(COLORREF);
            DWORD dwType;
            RegQueryValueEx(g_hkcuExplorer,
                            c_szAltColor,
                            NULL,
                            &dwType,
                            (LPBYTE)&g_crAltColor,
                            &cbData);
        }
    }
#endif // ALT_TEXT_COLOR

    //
    //  Set the view mode. Never inherit the Panose view. Force the user
    //  to set it.
    //

    if( lpfs )
    {
        switch( lpfs->ViewMode )
        {
        default:
        case FVM_ICON:
            m_idViewMode = IDM_VIEW_ICON;
            break;

        case FVM_SMALLICON:
        case FVM_LIST:
            m_idViewMode = IDM_VIEW_LIST;
            break;

        case FVM_DETAILS:
            m_idViewMode = IDM_VIEW_DETAILS;
            break;
        }

        //
        //  don't save this if ViewMode is 0 (default)
        //

        if( lpfs->ViewMode )
            m_ViewModeReturn = lpfs->ViewMode;

        m_fFolderFlags = lpfs->fFlags;
    }

    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: CFontView::CVW view window rect=(%d,%d,%d,%d)" ),
             prcView->left, prcView->top, prcView->right, prcView->bottom) );

    if( !(m_hwndView = CreateDialogParam( g_hInst,
                                          MAKEINTRESOURCE( ID_DLG_MAIN ),
                                          m_hwndParent,
                                          FontViewDlgProc,
                                          (LPARAM) this ) ) )

    {
        DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: CFontView::CVW CreateWindow failed" ) ) );
        return( ResultFromScode( E_FAIL ) );
    }

    DragAcceptFiles( m_hwndView, TRUE );

    SHRegisterDragDrop( m_hwndView, (LPDROPTARGET)this );

    *phWnd = m_hwndView;

    //
    //  If using a dialog, we need to resize correctly.
    //

    MoveWindow( m_hwndView,
                prcView->left, prcView->top,
                prcView->right - prcView->left,
                prcView->bottom - prcView->top,
                TRUE );

    //
    // Re-read the registry in case new fonts were added while we were away.
    // If we don't do this, any fonts (without files in the fonts directory)
    // added to the registry aren't displayed in the folder list view.
    //
    m_poFontManager->bRefresh( TRUE );

    FillObjects( );

    // SortObjects( );


    ShowWindow( m_hwndView, SW_SHOW );

    // UpdateWindow( m_hwndView );

    //
    //  The BrowserWindow will invalidate us and force a redraw, so
    //  don't do it now.
    //
    //  ValidateRect( m_hwndView, NULL );

    MergeToolbar( );
    UpdateToolbar( );

    return( NOERROR );
}


STDMETHODIMP CFontView::DestroyViewWindow( )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::DestroyViewWindow called" ) ) );

    if( m_hwndView )
    {
        if (0 != m_uSHChangeNotifyID)
            SHChangeNotifyDeregister(m_uSHChangeNotifyID);

        DragAcceptFiles( m_hwndView, FALSE );

        SHRevokeDragDrop( m_hwndView );

        DestroyWindow( m_hwndView );

#ifdef ALT_TEXT_COLOR

        if (NULL != g_hkcuExplorer)
        {
            RegCloseKey(g_hkcuExplorer);
            g_hkcuExplorer = NULL;
        }

#endif // ALT_TEXT_COLOR

        m_hwndView = NULL;
    }

#ifdef TOOLTIP_FONTSAMPLE

    if (NULL != m_hwndToolTip)
    {
        DestroyWindow(m_hwndToolTip);
        m_hwndToolTip = NULL;
    }
#endif // TOOLTIP_FONTSAMPLE

    return( NOERROR );
}



#ifdef TOOLTIP_FONTSAMPLE


VOID
CFontView::LV_OnHoverNotify(
    LPNMLISTVIEW pnmlv
    )
{
    INT iHit = pnmlv->iItem;

    if (m_bShowPreviewToolTip)
    {
        if (iHit != m_iTTLastHit)
        {
            if (-1 == iHit)
            {
                //
                // Hit nowhere.  Deactivate the tooltip.
                //
                SendMessage(m_hwndToolTip, TTM_ACTIVATE, FALSE, 0);
            }
            else
            {
                //
                // Hit on an item.  Set the tooltip font, text and activate
                // the tooltip.  The tooltip is deactivated while the new
                // font and text are loaded so we don't see an incomplete
                // sample.
                //
                SendMessage(m_hwndToolTip, TTM_ACTIVATE, FALSE, 0);
                UpdateFontSample(iHit);
                if (NULL != m_hfontSample)
                {
                    //
                    // If we were able to load the font and create a sample
                    // for display, display the sample in the tooltip window.
                    //
                    SendMessage(m_hwndToolTip, WM_SETFONT, (WPARAM)m_hfontSample, (LPARAM)FALSE);
                    SendMessage(m_hwndToolTip, TTM_ACTIVATE, TRUE, 0);
                }
            }
            //
            // Need to fake out the tooltip window into thinking that the mouse
            // is over a new tool.  Since we have only one tooltip window,
            // the entire listview object is considered a single tool.  If we don't
            // send this message, the tooltip thinks the mouse is always over
            // the "tool" so we never get a new tooltip when we navigate between
            // items in the listview.
            //
            SendMessage(m_hwndToolTip, WM_MOUSEMOVE, 0, 0);
            m_iTTLastHit = iHit;
        }
    }
}


//
// Update the sample font and text to be displayed in the tooltip window
// for a given item in the listview.
//
VOID
CFontView::UpdateFontSample(
    INT iItem
    )
{
    LV_ITEM item;

    if (NULL != m_hfontSample)
    {
        //
        // Delete a previous font.
        //
        DeleteObject(m_hfontSample);
        m_hfontSample = NULL;
    }

    ZeroMemory(&item, sizeof(item));

    item.iItem    = iItem;
    item.iSubItem = 0;
    item.mask     = LVIF_PARAM;

    //
    // Get the current listview item.
    //
    if (ListView_GetItem(m_hwndList, &item))
    {
        CFontClass *pFont = (CFontClass *)item.lParam;
        TCHAR szFontPath[(MAX_PATH * 2) + 1];           // "PathPFM|PathPFB"

        //
        // Get the font file's full path name.
        //
        if (pFont->bGetFQName(szFontPath, ARRAYSIZE(szFontPath)))
        {
            //
            // If font is a Type1 with an associated PFB,
            // create the "XXXXXX.PFM|XXXXXX.PFB" concatenation to give to
            // GDI.
            //
            LPTSTR pszFontPathPfb = (LPTSTR)szFontPath + lstrlen(szFontPath);

            if (pFont->bGetPFB(pszFontPathPfb + 1, ARRAYSIZE(szFontPath) - (UINT)(pszFontPathPfb - szFontPath) - 1))
            {
                *pszFontPathPfb = TEXT('|');
            }

            INT nFonts;
            DWORD cb = sizeof(nFonts);
            //
            // Get number of fonts in font file so we can size the LOGFONT buffer.
            //
            if (GetFontResourceInfoW(szFontPath, &cb, &nFonts, GFRI_NUMFONTS))
            {
                cb = sizeof(LOGFONT) * nFonts;
                LPLOGFONT plf = (LPLOGFONT)LocalAlloc(LPTR, cb);
                if (NULL != plf)
                {
                    //
                    // Read in the LOGFONT data for the font(s).
                    //
                    if (GetFontResourceInfoW((LPTSTR)szFontPath, &cb, plf, GFRI_LOGFONTS))
                    {
                        //
                        // Create the sample font.
                        //
                        HDC hdc = GetDC(m_hwndList);

                        plf->lfHeight = -MulDiv(FONT_SAMPLE_PT_SIZE,
                                                GetDeviceCaps(hdc, LOGPIXELSY),
                                                72);
                        plf->lfWidth = 0;

                        ReleaseDC(m_hwndList, hdc);

                        m_hfontSample = CreateFontIndirect(plf);

                        //
                        // Update the tip text.
                        // We display a different sample for symbol fonts.
                        //
                        TOOLINFO ti;
                        ti.cbSize      = sizeof(TOOLINFO);
                        ti.uFlags      = TTF_IDISHWND | TTF_SUBCLASS;
                        ti.hwnd        = m_hwndView;
                        ti.hinst       = g_hInst;
                        ti.uId         = (UINT_PTR)m_hwndList;
                        ti.lpszText    = SYMBOL_CHARSET == plf->lfCharSet ? m_pszSampleSymbols
                                                                          : m_pszSampleText;

                        SendMessage(m_hwndToolTip, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);
                    }
                    LocalFree(plf);
                }
            }
        }
    }
    //
    // Note:  m_hfontSample can be NULL on return if the font couldn't be loaded.
    //        In such cases, the caller should not display the sample tooltip.
    //
}


BOOL
CFontView::CreateToolTipWindow(
    VOID
    )
{
    BOOL bResult = FALSE;

    m_hwndToolTip = CreateWindowEx(0,
                                   TOOLTIPS_CLASS,
                                   (LPTSTR)NULL,
                                   0,
                                   CW_USEDEFAULT,
                                   CW_USEDEFAULT,
                                   CW_USEDEFAULT,
                                   CW_USEDEFAULT,
                                   m_hwndList,
                                   (HMENU)NULL,
                                   g_hInst,
                                   NULL);

    if (NULL != m_hwndToolTip)
    {
        TOOLINFO ti;

        //
        // Set tooltip timing parameter so that it pops up when the
        // item is hover selected.
        //
        SendMessage(m_hwndToolTip,
                    TTM_SETDELAYTIME,
                    TTDT_AUTOMATIC,
                    (LPARAM)ListView_GetHoverTime(m_hwndList));

        ti.cbSize      = sizeof(TOOLINFO);
        ti.uFlags      = TTF_IDISHWND | TTF_SUBCLASS;
        ti.hwnd        = m_hwndView;
        ti.hinst       = g_hInst;
        ti.uId         = (UINT_PTR)m_hwndList;
        ti.lpszText    = NULL;

        bResult = (BOOL)SendMessage(m_hwndToolTip,
                                    TTM_ADDTOOL,
                                    0,
                                    (LPARAM)&ti);

        //
        // Activate/Deactivate the tooltip based on the user's current
        // preference.
        //
        SendMessage(m_hwndToolTip, TTM_ACTIVATE, m_bShowPreviewToolTip, 0);
    }

    return bResult;
}

#endif // TOOLTIP_FONTSAMPLE



STDMETHODIMP CFontView::GetCurrentInfo( LPFOLDERSETTINGS lpfs )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::GetCurrentInfo called" ) ) );

    // *lpfs = m_fs;

    if( lpfs )
    {
        lpfs->ViewMode = m_ViewModeReturn;
        lpfs->fFlags = m_fFolderFlags;
    }

    return( NOERROR );
}


static const TCHAR *c_szTTOnly = TEXT( "TTOnly" );

INT_PTR CALLBACK CFontView::OptionsDlgProc( HWND hDlg,
                                            UINT message,
                                            WPARAM wParam,
                                            LPARAM lParam )
{
    switch( message )
    {

    case WM_INITDIALOG:
      {
        int fWasSet = (GetProfileInt( c_szTrueType, c_szTTOnly, 0 ) ? 1 : 0 );

        CheckDlgButton( hDlg, IDC_TTONLY, fWasSet );

        SetWindowLongPtr( hDlg, DWLP_USER, 0 );

        break;
      }

    case WM_COMMAND:
      {
        UINT uID = GET_WM_COMMAND_ID( wParam, lParam );

        if( uID == IDC_TTONLY &&
            GET_WM_COMMAND_CMD( wParam, lParam ) == BN_CLICKED )
        {
            SendMessage( GetParent( hDlg ), PSM_CHANGED, (WPARAM) hDlg, 0L );
        }
        break;
      }

    case WM_NOTIFY:
        switch( ( (NMHDR*)lParam)->code )
        {
        case PSN_APPLY:
          {
            int fSet = IsDlgButtonChecked( hDlg, IDC_TTONLY ) ? 1 : 0;

            int fWasSet = (GetProfileInt( c_szTrueType, c_szTTOnly, 0 ) ? 1 : 0 );

            if( fSet != fWasSet )
            {
                WriteProfileString( c_szTrueType, c_szTTOnly,
                                    fSet ? TEXT( "1" ) : TEXT( "0" ) );
                SetWindowLongPtr( hDlg, DWLP_USER, TRUE );
            }
            break;
          }
        }

        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
        break;

    case WM_DESTROY:
      {
        LONG_PTR fReboot = GetWindowLongPtr( hDlg, DWLP_USER );

        if( fReboot )
        {
            RestartDialogEx(hDlg, 
                            NULL, 
                            EWX_REBOOT, 
                            SHTDN_REASON_FLAG_PLANNED | 
                            SHTDN_REASON_MAJOR_OPERATINGSYSTEM | 
                            SHTDN_REASON_MINOR_RECONFIG);
        }
        break;
      }

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                    HELP_WM_HELP, (DWORD_PTR)(LPTSTR) rgOptionPropPageHelpIDs);
        break;

    case WM_CONTEXTMENU:
        if (0 != GetDlgCtrlID((HWND)wParam))
        {
            WinHelp((HWND)wParam,
                    NULL,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)((LPTSTR)rgOptionPropPageHelpIDs));
        }
        break;
    }
    return 0;
}


STDMETHODIMP CFontView::AddPropertySheetPages( DWORD dwReserved,
                                               LPFNADDPROPSHEETPAGE lpfn,
                                               LPARAM lparam )
{
    HPROPSHEETPAGE hpage;
    PROPSHEETPAGE psp;

    psp.dwSize      = sizeof( psp );
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = g_hInst;
    psp.pszTemplate = MAKEINTRESOURCE( ID_DLG_OPTIONS );
    psp.pfnDlgProc  = OptionsDlgProc;
    psp.lParam      = 0;

    hpage = CreatePropertySheetPage( &psp );

    if( hpage )
        lpfn( hpage, lparam );

    return( NOERROR );
}


STDMETHODIMP CFontView::GetSavedViewState( void )
{
    HRESULT  hr;
    LPSTREAM pstm;
    ULONG    ulLen = 0;
    ULONG    ulDataLen = sizeof(m_idViewMode);

    ULARGE_INTEGER libCurPos;
    ULARGE_INTEGER libEndPos;
    LARGE_INTEGER  dlibMove = {0, 0};

#ifdef TOOLTIP_FONTSAMPLE
    ulDataLen += sizeof(m_bShowPreviewToolTip);
#endif


    hr = m_psb->GetViewStateStream( STGM_READ, &pstm );

    if( FAILED( hr ) )
        goto backout0;

    pstm->Seek( dlibMove, STREAM_SEEK_CUR, &libCurPos );
    pstm->Seek( dlibMove, STREAM_SEEK_END, &libEndPos );

    ulLen = libEndPos.LowPart - libCurPos.LowPart;

    if(ulLen >= ulDataLen)
    {
        pstm->Seek( *(LARGE_INTEGER *)&libCurPos, STREAM_SEEK_SET, NULL );
        pstm->Read( &m_idViewMode, sizeof( m_idViewMode ), NULL );
#ifdef TOOLTIP_FONTSAMPLE
        pstm->Read( &m_bShowPreviewToolTip, sizeof(m_bShowPreviewToolTip), NULL);
#endif
    }

    pstm->Release( );

backout0:
    return hr;

}


STDMETHODIMP CFontView::SaveViewState( void )
{
    HRESULT  hr;
    LPSTREAM pstm;
    ULARGE_INTEGER libMove = {0,0};
    ULONG ulWrite;
    ULONG ulDataLen = sizeof(m_idViewMode);

    //
    //  Get a stream to work with
    //
    hr = m_psb->GetViewStateStream( STGM_WRITE, &pstm );

    if( FAILED( hr ) )
       goto backout0;

#ifdef TOOLTIP_FONTSAMPLE
    ulDataLen += sizeof(m_bShowPreviewToolTip);
#endif

    //
    //  The stream is at the begining of our data, I think. So write it in
    //  order.
    //
    hr = pstm->Write( &m_idViewMode, sizeof( m_idViewMode ), &ulWrite );
#ifdef TOOLTIP_FONTSAMPLE
    hr = pstm->Write( &m_bShowPreviewToolTip, sizeof(m_bShowPreviewToolTip), &ulWrite);
#endif
    if( FAILED( hr ) )
       goto backout1;

    libMove.LowPart = ulDataLen;

    pstm->SetSize( libMove );

    //
    //  Release the stream.
    //

backout1:

    pstm->Release( );

backout0:

    return hr;
}


STDMETHODIMP CFontView::SelectItem( LPCITEMIDLIST lpvID, UINT uFlags )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::SelectItem called" ) ) );

    return( ResultFromScode( E_NOTIMPL ) );
}

STDMETHODIMP CFontView::GetItemObject( UINT uItem, REFIID riid, LPVOID *ppv )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::SelectItem called" ) ) );

    return( ResultFromScode( E_NOTIMPL ) );
}


//------------------------------------------------------------------------
// IDropTarget Methods.
//
//

STDMETHODIMP CFontView::DragEnter( IDataObject __RPC_FAR *pDataObj,
                                   DWORD grfKeyState,
                                   POINTL pt,
                                   DWORD __RPC_FAR *pdwEffect )
{
    m_grfKeyState = grfKeyState;
    m_dwEffect = DROPEFFECT_NONE;

    //
    //  TODO: We need to know the type of file and where it's coming from
    //  to determine what kind of operation can be done. Replace the TRUE
    //  with something more accurate.
    //

    if( TRUE )
    {
        m_dwEffect = DROPEFFECT_COPY;

        if( grfKeyState & MK_SHIFT )
            m_dwEffect = DROPEFFECT_MOVE;

        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::DragEnter called" ) ) );

        if( m_hwndView )
        {
            RECT rc;
            POINT pti;

            GetWindowRect( m_hwndParent, &rc );


            //
            // If the font folder window is RTL mirrored, then the client
            // coordinate are measured from the visual right edge. [samera]
            //
            if (GetWindowLong(m_hwndParent, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
                pti.x = rc.right-pt.x;
            else
                pti.x = pt.x-rc.left;
            pti.y = pt.y-rc.top;
            DAD_DragEnterEx2( m_hwndParent, pti, pDataObj );
        }
    }

    *pdwEffect &= m_dwEffect;

    return NOERROR;
}


STDMETHODIMP CFontView::DragOver( DWORD grfKeyState,
                                  POINTL pt,
                                  DWORD __RPC_FAR *pdwEffect )
{
    m_grfKeyState = grfKeyState;

    if( m_dwEffect != DROPEFFECT_NONE )
    {
       m_dwEffect = DROPEFFECT_COPY;

       if( grfKeyState & MK_SHIFT )
          m_dwEffect = DROPEFFECT_MOVE;

        POINT ptt;
        RECT rc;

        GetWindowRect( m_hwndParent, &rc );

        //
        // If the font folder window is RTL mirrored, then the client
        // coordinate are measured from the visual right edge. [samera]
        //
        if (GetWindowLong(m_hwndParent, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
            ptt.x = rc.right-pt.x;
        else
            ptt.x = pt.x-rc.left;
        ptt.y = pt.y-rc.top;

        DAD_DragMove( ptt );
    }

    *pdwEffect &= m_dwEffect;

    return NOERROR;
}


STDMETHODIMP CFontView::DragLeave( void )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::DragLeave called" ) ) );

    if( m_dwEffect != DROPEFFECT_NONE && m_hwndView )
    {
        DAD_DragLeave( );
    }

    return NOERROR;
}


//
//  APPCOMPAT: The TrackPopupMenu does not work, if the hwnd does not have
//   the input focus. We believe this is a bug in USER, but ...
//

BOOL _TrackPopupMenuEx( HMENU hmenu,
                        UINT wFlags,
                        int x,
                        int y,
                     //    int wReserved,
                        HWND hwndOwner,
                        LPCRECT lprc )
{
    int iRet = FALSE;

    HWND hwndDummy = CreateWindow( TEXT( "Static" ), NULL,
                                   0, x, y, 1, 1, HWND_DESKTOP,
                                   NULL, g_hInst, NULL );

    if( hwndDummy )
    {
        //
        //  to restore
        //

        HWND hwndPrev = GetForegroundWindow( );

        SetForegroundWindow( hwndDummy );
        SetFocus( hwndDummy );

        iRet = TrackPopupMenu( hmenu, wFlags, x, y, 0, hwndDummy, lprc );

        //
        //  We MUST unlock the destination window before changing its Z-order.
        //
        //  DAD_DragLeave( );

        if( iRet && ( iRet != IDCANCEL ) )
        {
            //
            //  non-cancel item is selected. Make the hwndOwner foreground.
            //

            SetForegroundWindow( hwndOwner );
            SetFocus( hwndOwner );
        }
        else
        {
            //
            //  The user canceled the menu.
            //  Restore the previous foreground window
            //   (before destroying hwndDummy).
            //

            if( hwndPrev )
            {
                SetForegroundWindow( hwndPrev );
            }
        }

        DestroyWindow( hwndDummy );
    }

    return iRet;
}


STDMETHODIMP CFontView::Drop( IDataObject __RPC_FAR *pDataObj,
                              DWORD grfKeyState,
                              POINTL pt,
                              DWORD __RPC_FAR *pdwEffect )
{
    HRESULT  hr = NOERROR;


    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::DragEnter called" ) ) );

    if( m_dwEffect != DROPEFFECT_NONE )
    {
       DAD_DragLeave( );

       //
       //  If this is us sourcing the drag, just bail. We may want to save the
       //  points of the icons.
       //

       if( m_bDragSource )
            goto done;

       //
       //  If this is a right-mouse drag, then ask the user what we should
       //  do. Otherwise, just do what is in m_dwEffect.
       //

       if( m_grfKeyState & MK_RBUTTON )
       {
            //
            //  Pop up the context menu.
            //

            HMENU hMenu = LoadMenu( g_hInst,
                                    MAKEINTRESOURCE( IDM_POPUP_DRAGDROP ) );

            if( hMenu )
            {
                HMENU hPopup = GetSubMenu( hMenu, 0 );

                if( hPopup )
                {
                    //
                    //  Bold the Open menuitem.
                    //

                    MENUITEMINFO iInfo;

                    ZeroMemory(&iInfo, sizeof(iInfo));
                    iInfo.cbSize = sizeof( iInfo );
                    iInfo.fMask  = MIIM_STATE;

                    if( GetMenuItemInfo( hMenu, IDM_POPUP_COPY, FALSE, &iInfo ) )
                    {
                        iInfo.fState |= MFS_DEFAULT;
                        SetMenuItemInfo( hMenu, IDM_POPUP_COPY, FALSE , &iInfo );
                    }

                    UINT idCmd = _TrackPopupMenuEx( hPopup,
                                                    TPM_RETURNCMD
                                                    | TPM_LEFTALIGN
                                                    | TPM_LEFTBUTTON
                                                    | TPM_RIGHTBUTTON,
                                                    pt.x,              // x pos
                                                    pt.y,              // y pos.
                                                    m_hwndView,
                                                    NULL );

                    switch( idCmd )
                    {
                    case IDM_POPUP_MOVE:
                       DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: IDM_POPUP_MOVE" ) ) );

                       m_dwEffect = DROPEFFECT_MOVE;
                       break;

                    case IDM_POPUP_COPY:
                       DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: IDM_POPUP_COPY" ) ) );

                       m_dwEffect = DROPEFFECT_COPY;
                       break;

                    case IDM_POPUP_LINK:
                       DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: IDM_POPUP_LINK" ) ) );

                       m_dwEffect = DROPEFFECT_LINK;
                       break;

                    default:
                    // case IDM_POPUP_CANCEL:
                       DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: IDM_POPUP_CANCEL" ) ) );

                       m_dwEffect = DROPEFFECT_NONE;
                       break;
                    }
                }
                DestroyMenu( hMenu );
            }

            //
            //  The right mouse context menu may have cancelled.
            //

            if( m_dwEffect == DROPEFFECT_NONE )
                goto done;
        }

        //
        //  Do the operation. What we do with the source depends on
        //  m_dwEffect.
        //

        InstallDataObject( pDataObj, m_dwEffect, m_hwndView, this );
    }


done:
   return hr;
}


void MergeHelpMenu( HMENU hmenu, HMENU hmenuMerge )
{
    HMENU hmenuHelp = GetMenuFromID( hmenu, FCIDM_MENU_HELP );

    if ( hmenuHelp )
        Shell_MergeMenus( hmenuHelp, hmenuMerge, 0, 0, (UINT) -1, MM_ADDSEPARATOR );
}


void MergeFileMenu( HMENU hmenu, HMENU hmenuMerge )
{
    HMENU hmenuView = GetMenuFromID( hmenu, FCIDM_MENU_FILE );

    if( hmenuView )
        Shell_MergeMenus( hmenuView, hmenuMerge, 0, 0, (UINT) -1, MM_ADDSEPARATOR );
}


void MergeEditMenu( HMENU hmenu, HMENU hmenuMerge )
{
    HMENU hmenuView = GetMenuFromID( hmenu, FCIDM_MENU_EDIT );

    if( hmenuView )
        Shell_MergeMenus( hmenuView, hmenuMerge, 0, 0, (UINT) -1, 0 );
}


void MergeViewMenu( HMENU hmenu, HMENU hmenuMerge )
{
    HMENU hmenuView = GetMenuFromID( hmenu, FCIDM_MENU_VIEW );


    if( hmenuView )
    {
        int index;

        //
        //  Find the last separator in the view menu.
        //

        for( index = GetMenuItemCount( hmenuView ) - 1; index >= 0; index-- )
        {
            UINT mf = GetMenuState( hmenuView, (UINT)index, MF_BYPOSITION );

            if( mf & MF_SEPARATOR )
            {
                //
                //  merge it right above the separator.
                //
                break;
            }
        }

        //
        //  Add the separator above (in addition to existing one if any).
        //

        InsertMenu( hmenuView, index, MF_BYPOSITION | MF_SEPARATOR, 0, NULL );

        //
        //  Then merge our menu between two separators
        //  (or right below if only one).
        //

        if( index != -1 ) index++;

        Shell_MergeMenus( hmenuView, hmenuMerge, (UINT) index, 0, (UINT) -1, 0 );
    }
}


HMENU GetMenuFromID( HMENU hmMain, UINT uID )
{
    MENUITEMINFO miiSubMenu;


    miiSubMenu.cbSize = sizeof( MENUITEMINFO );
    miiSubMenu.fMask  = MIIM_SUBMENU;

    if( !GetMenuItemInfo( hmMain, uID, FALSE, &miiSubMenu ) )
        return NULL;

    return( miiSubMenu.hSubMenu );
}


void SetListColumns( HWND hWnd, UINT iCount, COLUMN_ENTRY * lpCol )
{
    LV_COLUMN lvc;
    UINT      iCol;
    TCHAR     szText[ MAX_NAME_LEN ];     // 64

    const HWND hwndHeader = ListView_GetHeader(hWnd);
    UINT cPrevColCount    = Header_GetItemCount(hwndHeader);

    //
    //  Delete any columns that will go unused.
    //
    while (cPrevColCount > iCount)
    {
        --cPrevColCount;
        ListView_DeleteColumn(hWnd, cPrevColCount);
    }
    //
    //  Initialize the LV_COLUMN structure.
    //

    lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.pszText = szText;

    if( !g_cxM )
    {
        SIZE siz;
        HDC  hdc = GetDC( HWND_DESKTOP );

        SelectFont( hdc, FORWARD_WM_GETFONT( hWnd, SendMessage ) );

        GetTextExtentPoint( hdc, c_szM, 1, &siz );

        ReleaseDC( HWND_DESKTOP, hdc );

        g_cxM = siz.cx;
    }

    for( iCol = 0; iCol < iCount; iCol++, lpCol++ )
    {
        lvc.iSubItem = iCol;

        lvc.cx  = lpCol->m_iWidth * g_cxM;
        lvc.fmt = lpCol->m_iFormat;

        LoadString( g_hInst,
                    lpCol->m_iID,
                    szText,
                    ARRAYSIZE( szText ) );

        if (iCol < (UINT)Header_GetItemCount(hwndHeader))
        {
            //
            // Column already exists.  Just set it's data.
            //
            ListView_SetColumn(hWnd, iCol, &lvc);
        }
        else
        {
            //
            // Create a new column.
            //
            ListView_InsertColumn(hWnd, iCol, &lvc);
        }
    }
}


void CFontView::StatusPush( UINT nStatus )
{
    TCHAR szText[ 128 ];

    if( LoadString( g_hInst, nStatus, szText, ARRAYSIZE( szText ) ) )
        StatusPush( szText );
}


void CFontView::StatusPush( LPTSTR lpsz )
{
    OLECHAR szOle[ 256 ];


    if( m_psb )
    {
#ifdef UNICODE
        m_psb->SetStatusTextSB( lpsz );
#else
        MultiByteToWideChar( CP_ACP, 0, lpsz, -1, szOle, ARRAYSIZE( szOle ) );

        m_psb->SetStatusTextSB( szOle );
#endif

    }
}


void CFontView::StatusPop( )
{
    //
    //  For now, just clear the thing.
    //

    StatusClear( );
}


void CFontView::StatusClear( )
{
    if( m_psb )
    {
        m_psb->SetStatusTextSB( (LPCOLESTR) TEXT( "" ) );
        m_psb->SendControlMsg( FCW_STATUS, SB_SIMPLE, 0, 0L, NULL );
    }
}


// *** IPersist methods ***

STDMETHODIMP CFontView::GetClassID( LPCLSID lpClassID )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView/IPersistFolder ::GetClassID called" ) ) );

    return ResultFromScode( E_NOTIMPL );
}


// *** IPersistFolder methods ***

STDMETHODIMP CFontView::Initialize( LPCITEMIDLIST pidl )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView/IPersistFolder ::Initialize called" ) ) );

    HRESULT hResult = E_FAIL;
    TCHAR szPersistDataPath[MAX_PATH];

    if (SHGetPathFromIDList(pidl, szPersistDataPath))
    {
        TCHAR szFontsPath[MAX_PATH];

        ::GetFontsDirectory(szFontsPath, ARRAYSIZE(szFontsPath));

        if (0 == lstrcmpi(szFontsPath, szPersistDataPath))
        {
            //
            // Only treat this persistent storage as the font folder if
            // it is the "fonts" directory on the local machine.  Otherwise,
            // the shell should just browse it as a normal shell folder.
            //
            hResult = NO_ERROR;
        }
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\oeminf.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// oeminf.cpp
//      Explorer Font Folder extension routines.
//    Functions for manipulating OEMxxxxx.INF files.  This module is
//    shared by Windows Setup and Control Panel.  The constant
//    WINSETUP is defined when compiling for Windows Setup.
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include "dbutl.h"

#define USE_OEMINF_DEFS
#include "oeminf.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

/* BOOL RunningFromNet( void );
 *
 * Checks to see if the user is running on a network Windows installation.
 *
 * ENTRY: void
 *
 * EXIT: BOOL - TRUE if the user is running on a network Windows
 *              installation.  FALSE if not or if one of the
 *              Get...Directory() calls fails.
 *
 */
BOOL FAR PASCAL RunningFromNet( void )
{
    TCHAR  pszWindowsDir[ MAX_NET_PATH ], pszSystemDir[ MAX_NET_PATH ];
    LPTSTR pszWindowsTemp, pszSystemTemp;


    //
    //  Check the results from GetSystemWindowsDirectory() and GetSystemDirectory().
    //  If the System directory is a direct subdirectory of the Windows
    //  directory, this is not a network installation.  Otherwise it is a
    //  network installation.
    //

    if( GetSystemWindowsDirectory( pszWindowsDir, ARRAYSIZE( pszWindowsDir ) ) == 0 )
        return( FALSE );

    if( GetSystemDirectory( pszSystemDir, ARRAYSIZE( pszSystemDir ) ) == 0 )
        return( FALSE );

    pszWindowsTemp = pszWindowsDir;
    pszSystemTemp  = pszSystemDir;

    CharUpper( pszWindowsTemp );
    CharUpper( pszSystemTemp );

    while( ( *pszWindowsTemp != TEXT( '\0' ) )
           && ( *pszWindowsTemp++ == *pszSystemTemp++ ) )
       ;

    //
    //  Did the path specifications match?
    //

    if( *pszWindowsTemp == TEXT( '\0' ) )
        return( FALSE );
    else
        return( TRUE );
}


/* HANDLE ReadFileIntoBuffer( int doshSource );
 *
 * Reads up to first (64K - 1) bytes of an input file into a buffer.
 *
 * ENTRY: doshSource - DOS file handle of file open for reading
 *
 * EXIT: HANDLE - Global handle to the file buffer filled from the input
 *                file.  NULL if an error occurs.
 *
 */

HANDLE FAR PASCAL ReadFileIntoBuffer( int doshSource )
{
    LONG lLength;
    HANDLE hBuffer;
    LPTSTR lpszBuffer, lpszTemp;
    int nBytesToRead;


    //
    //  How long is the file?
    //

    if( ( lLength = _llseek( doshSource, 0L, 2 ) ) < 0L )
    {

       //
       //  Return NULL on error.
       //

       return( NULL );
    }


    //
    //  Return to the beginning of the file.
    //

    if( _llseek( doshSource, 0L, 0 ) != 0L )
        return( NULL );

    //
    //  Don't overrun the .inf buffer bound.
    //

    if( lLength > MAX_INF_COMP_LEN )
        lLength = MAX_INF_COMP_LEN;

    //
    //  Allocate storage for the file.
    //

    if( ( hBuffer = GlobalAlloc( GHND, (DWORD) lLength ) ) == NULL )
        return( NULL );

    //
    //  Lock the buffer in place.
    //

    if( ( lpszTemp = lpszBuffer = (LPTSTR) GlobalLock( hBuffer ) ) == NULL )
        return( NULL );

    //
    //  Fill the buffer from the file.
    //

    while( lLength > 0 )
    {
        nBytesToRead = (int)min( lLength, MAX_INF_READ_SIZE );

        if( _lread( doshSource, lpszTemp, nBytesToRead ) != (WORD)nBytesToRead )
        {
            GlobalUnlock( hBuffer );
            GlobalFree( hBuffer );
            return( NULL );
        }

        lLength -= (LONG)nBytesToRead;
        lpszTemp += (LONG)nBytesToRead;
    }

    //
    //  Unlock the buffer.
    //

    GlobalUnlock( hBuffer );

    //
    //  File read in successfully.
    //

    return( hBuffer );
}


/* int FilesMatch( int dosh1, int dosh2, unsigned int uLength );
 *
 * Compares two files.
 *
 * ENTRY: dosh1   - DOS file handle of first file open for reading
 *        dosh2   - DOS file handle of second file open for reading
 *        uLength - number of bytes to compare
 *
 * EXIT: int - TRUE if first (64K - 1) bytes of the files match exactly.
 *             FALSE if not.  (-1) if an error occurs.
 *
 * The buffers need not be null-terminated.  TEXT( '\0' )s are treated as just
 * another byte to compare.
 *
 */

int FAR PASCAL FilesMatch( HANDLE h1, HANDLE h2, unsigned uLength )
{
    int    nReturnCode = -1;
    LPTSTR lpsz1, lpsz2;

    if( ( lpsz1 = (LPTSTR) GlobalLock( h1 ) ) == NULL )
    {
        GlobalUnlock( h1 );
        return( nReturnCode );
    }

    if( ( lpsz2 = (LPTSTR) GlobalLock( h2 ) ) != NULL )
    {
        //
        //  See if the files match.
        //

        nReturnCode = !memcmp( lpsz1, lpsz2, uLength );
    }

    GlobalUnlock( h1 );
    GlobalUnlock( h2 );

    return( nReturnCode );
}


/* LPTSTR TruncateFileName( LPTSTR pszPathSpec );
 *
 * Finds the file name portion of a path specification.
 *
 * ENTRY: lpszPathSpec - path specification
 *
 * EXIT: LPTSTR - Pointer to file name portion of string.
 *
 */

LPTSTR FAR PASCAL TruncateFileName( LPTSTR lpszPathSpec )
{
    LPTSTR lpszStart = lpszPathSpec;

    //
    //  Find end of string.
    //

    while( *lpszPathSpec != TEXT( '\0' ) )
        lpszPathSpec = CharNext( lpszPathSpec );

    //
    //  Seek back until we find a path separator or the begining of the string.
    //

    while( !IS_PATH_SEPARATOR( *lpszPathSpec ) && lpszPathSpec != lpszStart )
        lpszPathSpec = CharPrev( lpszStart, lpszPathSpec );

    if( lpszPathSpec != lpszStart )
        lpszPathSpec = CharNext( lpszPathSpec );

    //
    //  Return pointer to file name.
    //

    return( lpszPathSpec );
}


/* int OpenFileAndGetLength( LPTSTR lpszSourceFile, PLONG plFileLength );
 *
 * Opens a file into a global buffer.  Returns a handle to the buffer and the
 * actual length of the file.
 *
 * ENTRY: lpszSourceFile - source file name
 *        plFileLength   - pointer to LONG to be filled with length of source
 *                         file
 *
 * EXIT: int           - Open DOS file handle if successful.  (-1) if
 *                       unsuccessful.
 *       *plFileLength - Filled in with length of source file if successful.
 *                       Undefined if unsuccessful.
 */

int FAR PASCAL OpenFileAndGetLength( LPTSTR lpszSourceFile,
                                     LPLONG plFileLength )
{
    int      doshSource;
    OFSTRUCT of;


#ifdef UNICODE

////////////////////////////////////////////////////////////////////
//
// NOTE [stevecat]  - Why are we munging INF files?  For now
//          just convert the filename to ASCII and use the current
//          fileio apis to munge thru the INF files.
//
////////////////////////////////////////////////////////////////////

    char    szFile[ PATHMAX ];

    WideCharToMultiByte( CP_ACP, 0, lpszSourceFile, -1, szFile,
                         PATHMAX, NULL, NULL );

    doshSource = OpenFile( szFile, &of, OF_READ );

#else

    doshSource = OpenFile( lpszSourceFile, &of, OF_READ );

#endif  //  UNICODE

    if( doshSource == -1 )
        return doshSource;

    //
    //  Keep track of the length of the new file.
    //

    if( ( *plFileLength = _llseek( doshSource, 0L, 2 ) ) < 0L )
    {
        _lclose( doshSource );
        return(-1);
    }

    return( doshSource );
}


#define INF_YES (1)
#define INF_NO  (0)
#define INF_ERR (-1)


/* int IsNewFile( LPTSTR lpszSourceFile, LPTSTR lpszDestDir );
 *
 * Checks to see if a given file already exists as a file matching a given
 * file specification.
 *
 * ENTRY: pszSourceFile - path name of the new file
 *        pszSearchSpec - target directory and file specification (may
 *                        include wildcards) to use to search for duplicates
 *                        (e.g., "c:\win\system\*.inf")
 *
 * EXIT: int - TRUE if the new file doesn't already exist as a file matching
 *             the given file specification.  FALSE if it does.  (-1) if an
 *             error occurs.
 *
 */

int FAR PASCAL IsNewFile( LPTSTR lpszSourceFile, LPTSTR lpszSearchSpec )
{
    int    nReturnCode = INF_ERR;
    int    nTargetLen, nMatchRet;
    HANDLE hFind;
    WIN32_FIND_DATA   sFind;
    LPTSTR lpszReplace;
    TCHAR  pszTargetFileName[ MAX_NET_PATH + FILEMAX ];
    int    doshSource, doshTarget;
    HANDLE hSourceBuf, hTargetBuf;
    LONG   lSourceLength, lTargetLength;


    //
    //  How much storage do we need for the destination file name?
    //

    lpszReplace = TruncateFileName( lpszSearchSpec );

    //
    // [stevecat] The following statement is evil and parochial. It
    //            will not work correctly in a UNICODE environment.
    //
    //       nTargetLen = lpszReplace - lpszSearchSpec + FILEMAX;
    //
    //  Replace with a better way to calculate string length.
    //

    nTargetLen = (LONG)(lpszReplace - lpszSearchSpec) / sizeof( TCHAR ) + FILEMAX;

    //
    //  Don't overflow the buffer.
    //

    if( nTargetLen > ARRAYSIZE( pszTargetFileName ) )
        return( INF_ERR );

    //
    //  Keep track of the start of the file name in the destination path
    //  specification.
    //

    lstrcpy( pszTargetFileName, lpszSearchSpec );

    lpszReplace = (LPTSTR)pszTargetFileName + ( lpszReplace - lpszSearchSpec );

    //
    //  Are there any files to process?
    //

    hFind = FindFirstFile( lpszSearchSpec, &sFind );


    //
    //  Only open the source file if there are any existing files to compare
    //  against.
    //

    if( hFind == INVALID_HANDLE_VALUE )
        return( INF_YES );

    if( ( doshSource = OpenFileAndGetLength( lpszSourceFile, &lSourceLength ) ) == NULL )
    {
        FindClose( hFind );
        return( INF_ERR );
    }

    hSourceBuf = ReadFileIntoBuffer( doshSource );

    _lclose( doshSource );

    if( hSourceBuf == NULL )
    {
        FindClose( hFind );
        return( INF_ERR );
    }

    //
    //  Check all the matching files.
    //

    while( hFind != INVALID_HANDLE_VALUE )
    {
        //
        //  Replace the wildcard file specification with the file name of the
        //  target file.
        //  lstrcpy( lpszReplace, fcbSearch.szName );
        //

        lstrcpy( lpszReplace, sFind.cAlternateFileName );

        //
        //  Open the target file.
        //

        if( ( doshTarget = OpenFileAndGetLength( pszTargetFileName,
                                                 &lTargetLength ) ) == NULL )
           goto IsNewFileExit;

        //
        //  Is the target file the same size as the new file?
        //

        if( lTargetLength == lSourceLength )
        {
           //
           //  Yes.  Read in the target file.
           //

           hTargetBuf = ReadFileIntoBuffer( doshTarget );

           _lclose( doshTarget );

           if( hTargetBuf == NULL )
                goto IsNewFileExit;

           //
           //  ReadFileIntoBuffer( ) has already checked to make sure the files
           //  aren't longer than (64K - 1) bytes long.
           //  Assert: lSourceLength fits in an unsigned int.
           //

           nMatchRet = FilesMatch( hSourceBuf, hTargetBuf,
                                  (unsigned int)lSourceLength );

           GlobalFree( hTargetBuf );

           if( nMatchRet == -1 )
                goto IsNewFileExit;
           else if( nMatchRet == TRUE )
           {
                lstrcpy( lpszSourceFile, pszTargetFileName );
                nReturnCode = INF_NO;
                goto IsNewFileExit;
           }
        }

        //
        //  Look for the next matching file.
        //  bFound = OEMInfDosFindNext( &fcbSearch );
        //

        if( !FindNextFile( hFind, &sFind ) )
        {
            FindClose( hFind );
            hFind = INVALID_HANDLE_VALUE;
        }
    }

    nReturnCode = INF_YES;

IsNewFileExit:

    if( hFind != INVALID_HANDLE_VALUE )
        FindClose( hFind );


    GlobalFree( hSourceBuf );

    return( nReturnCode );
}


/* PTSTR MakeUniqueFilename( PTSTR pszDirName, PTSTR pszPrefix,
 *                                 PTSTR pszExtension );
 *
 * Creates a unique filename in a directory given a prefix for the base of
 * the filename and an extension.  The prefix must be three characters long.
 * The extension may be zero to three characters long.  The extension should
 * not include a period.  E.g., prefix "oem" and extension "inf".
 *
 * pszDirName's buffer must have space for up to 13 extra characters to be
 * appended (a slash plus 8.3).
 *
 *
 * ENTRY: pszDirName   - buffer holding target directory, unique filename
 *                       will be appended
 *        pszPrefix    - three-character base filename prefix to use
 *        pszExtension - filename extension to use
 *
 * EXIT: PTSTR - Pointer to modified path specification if successful.  NULL
 *              if unsuccessful.
 *
 */

LPTSTR FAR PASCAL MakeUniqueFilename( LPTSTR lpszDirName,
                                      LPTSTR lpszPrefix,
                                      LPTSTR lpszExtension )
{
    TCHAR   szOriginalDir[ MAX_NET_PATH ];
    TCHAR   szUniqueName[ FILEMAX ];
    ULONG   ulUnique = 0UL;
    LPTSTR  lpszTemp;
    BOOL    bFoundUniqueName = FALSE;


    DEBUGMSG( (DM_TRACE1, TEXT( "MakeUniqueFilename() " ) ) );

    //
    //  Check form of arguments.
    //

    if( lstrlen( lpszPrefix ) != 3 || lstrlen( lpszExtension ) > 3 )
        return( NULL );

    //
    //  Save current directory.
    //  if( OEMInfDosCwd( szOriginalDir ) != 0 )
    //

    if( !GetCurrentDirectory( ARRAYSIZE( szOriginalDir ), szOriginalDir ) )
        return( NULL );

    //
    //  Move to target directory.
    //  if( OEMInfDosChDir( lpszDirName ) != 0 )
    //

    if( !SetCurrentDirectory( lpszDirName ) )
        return( NULL );

    //
    //  Make file specification.
    //

    lstrcpy( szUniqueName, lpszPrefix );
    lpszTemp = szUniqueName + 3;

    //
    //  Try to create a unique filename.
    //

    while( !bFoundUniqueName && ulUnique <= MAX_5_DEC_DIGITS )
    {
        //
        //  Hack together next filename to try.
        //

        wsprintf( lpszTemp, TEXT( "%lu.%s" ), ulUnique, lpszExtension );

        //
        //  Is this name being used?
        //  if( OEMInfDosFindFirst( & fcbSearch, szUniqueName, ATTR_ALL_FD ) == 0 )
        //

        if( GetFileAttributes( szUniqueName ) == 0xffffffff )
        {
            //
            //  Nope.
            //

            bFoundUniqueName = TRUE;
            break;
        }
        else
            //
            // Yes.  Keep trying.
            //

            ulUnique++;
    }

    //
    //  Have all 100,000 possibilties been exhausted?
    //

    if( !bFoundUniqueName )
        return( FALSE );

    //
    //  Add new unique filename on to end of path specification buffer.
    //

    //
    //  Check for ending slash.
    //

    lpszTemp = lpszDirName + lstrlen( lpszDirName );

    if( !IS_SLASH( *(lpszTemp - 1 ) ) && *(lpszTemp - 1 ) != TEXT( ':' ) )
       *lpszTemp++ = TEXT( '\\' );

    //
    //  Append unique filename.
    //

    lstrcpy( lpszTemp, szUniqueName );

    //
    //  Return pointer to modified buffer.
    //

    DEBUGMSG( (DM_TRACE1,TEXT( "MakeUniqueFilename returning: %s %s" ),
              lpszDirName, lpszTemp) );

    return( lpszDirName );
}


/* BOOL CopyNewOEMInfFile( PTSTR pszOEMInfPath );
 *
 * Copies a new OEMSetup.inf file into the user's Windows (network) or System
 * (non-network) directory.  Gives the new .inf file a unique name of the
 * form 'OEMxxxxx.INF'.  Only copies it in if it is really a new .inf file.
 *
 * ENTRY: pszOEMInfPath - path name of the new .inf file to be copied
 *
 * EXIT: BOOL - TRUE if the new .inf file was copied successfully or had
 *              already been added.  0 if the copy failed.
 *
 */

BOOL FAR PASCAL CopyNewOEMInfFile( LPTSTR lpszOEMInfPath )
{
    BOOL   bRunningFromNet;
    TCHAR  pszDest[ MAX_NET_PATH + FILEMAX ];
    LPTSTR pszTemp;

    //
    //  Where should we put the new .inf file?
    //

    if( bRunningFromNet = RunningFromNet( ) )
    {
        //
        //  Put new .inf file in Windows directory.
        //

        if( GetWindowsDirectory( pszDest, MAX_NET_PATH ) == 0 )
            return( FALSE );
    }
    else
    {
        //
        //  Put new .inf file in System directory.
        //

        if( GetSystemDirectory( pszDest, MAX_NET_PATH ) == 0 )
            return( FALSE );
    }

    //
    //  Make file specification for IsNewFile( ).
    //

    pszTemp = pszDest + lstrlen( pszDest );

    //
    //  N.b., we depend on pszDest not ending in a slash here.
    //

    lstrcpy( pszTemp, OEM_STAR_DOT_INF );

    //
    //  Has this .inf file already been copied to the user's Windows or System
    //  directory?
    //

    switch( IsNewFile( lpszOEMInfPath, pszDest ) )
    {
    case INF_ERR:
        return( FALSE );

    case INF_YES:
        //
        //  Trim TEXT( "\*.inf" ) off end of pszDest.
        //

        *pszTemp = TEXT( '\0' );

        // Create a unique name for the new .inf file. We could use
        // SHFileOperation() to create a unique file, but we don't want to
        // copy the file more than once -- we want IsNewFile() to only check
        // for OEMxxxx.INF files.
        //

        if( MakeUniqueFilename( pszDest, INF_PREFIX, INF_EXTENSION ) == NULL )
            return( FALSE );
//
// #if 0   [stevecat] 6/15/95 - try to use shell op part vs. alternate
#if 1
        //
        //  Copy .inf file.
        //

        SHFILEOPSTRUCT fop;

        memset( &fop, 0, sizeof( fop ) );

        //
        // Append NUL onto both path strings.
        // SHFileOperation requires a double-nul terminator.
        //
        *(lpszOEMInfPath + lstrlen(lpszOEMInfPath) + 1) = TEXT('\0');
        *(pszDest + lstrlen(pszDest) + 1) = TEXT('\0');

        fop.wFunc  = FO_COPY;
        fop.pFrom  = lpszOEMInfPath;
        fop.pTo    = pszDest;
        fop.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;

        SHFileOperation( &fop );
#else
        int  doshSource, doshDest;
        BOOL bCopied;

        if( ( doshSource = FOPEN( lpszOEMInfPath ) ) == -1 )
            return( FALSE );

        if( ( doshDest = FCREATE( pszDest ) ) == -1 )
        {
            FCLOSE( doshSource );
            return( FALSE );
        }

        //
        //  All LZERROR_ return codes are < 0.
        //

        bCopied = ( LZCopy( doshSource, doshDest ) >= 0L );

        //
        //  Close the files.
        //

        FCLOSE( doshSource );
        FCLOSE( doshDest );

        if( !bCopied )
            return( FALSE );
#endif
        //
        //  Copy the new file name back, so the calling function can use it
        //

        lstrcpy( lpszOEMInfPath, pszDest );

    default:
        break;
    }

    //
    //  New .inf file already existed or copied successfully.
    //

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\pfont.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// pfont.cpp
//     Explorer Font Folder extension routines
//     Install Fonts dialog.
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include <direct.h>
#include <shlobjp.h>

#include "commdlg.h"
#include "resource.h"
#include "ui.h"
#include "fontman.h"
#include "cpanel.h"
#include "oeminf.h"

#include "lstrfns.h"

#include "t1.h"
#include "dbutl.h"
#include "fonthelp.h"

#include "fontcl.h"
#include "fontfile.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define OF_ERR_FNF 2

#define  ID_BTN_COPYFILES  chx2
#define  ID_BTN_HELP       psh15
#define  ID_BTN_SELALL     psh16
#define  ID_LB_FONTFILES   lst1
#define  ID_LB_FONTDIRS    lst2
#define  ID_CB_FONTDISK    cmb2

#define MAX_FF_PROFILE_LEN    48

#define ffupper(c) ( (TCHAR) CharUpper( MAKEINTRESOURCE( c ) ) )

typedef  UINT (CALLBACK *HOOKER) (HWND, UINT, WPARAM, LPARAM);

#ifdef WINNT

#define IsDBCSLeadByte(x) (FALSE)

//
// Macros used to get current path from file open dialog.
// Used in FontHookProc.
// Borrowed from file open dlg code.
//
#define CHAR_BSLASH TEXT('\\')
#define CHAR_NULL   TEXT('\0')

#define DBL_BSLASH(sz) \
   (*(TCHAR *)(sz)       == CHAR_BSLASH) && \
   (*(TCHAR *)((sz) + 1) == CHAR_BSLASH)

#endif  //  WINNT


typedef struct
{  union {  DWORD ItemData;
      struct { WORD  nFileSlot;
            // BOOL  bTrueType; };   EMR: BOOL in win32 is 32 bits!
            // WORD  bTrueType; };   JSC: For NT, make it FontType for T1 support
               WORD  wFontType; };
   }; // end union
} AddITEMDATA;

//
//  WIN.INI sections
//

static TCHAR szINISTrueType[] = TEXT( "TrueType" );
static TCHAR szINISFonts[]    = TEXT( "fonts" );

//
//  WIN.INI keywords
//

static TCHAR szINIKEnable[] = TEXT( "TTEnable" );
static TCHAR szINIKOnly[]   = TEXT( "TTOnly" );

//
// Globals
//

TCHAR szDot[]  = TEXT( "." );

TCHAR szSetupDir[ PATHMAX ];  // For installing
TCHAR szDirOfSrc[ PATHMAX ];  // For installing
FullPathName_t s_szCurDir;    // Remember last directory for file open dialog.


UINT_PTR CALLBACK FontHookProc( HWND, UINT, WPARAM, LPARAM );


static VOID NEAR PASCAL ResetAtomInDescLB( HWND hLB );

BOOL NEAR PASCAL bAddSelFonts( LPTSTR lpszDir, BOOL bNoCopyJob );
BOOL NEAR PASCAL bFileFound( PTSTR  pszPath,  LPTSTR lpszFile );
BOOL NEAR PASCAL bIsCompressed( LPTSTR szFile );
BOOL NEAR PASCAL bFontInstalledNow( PTSTR  szLHS );
BOOL NEAR PASCAL bInstallFont( HWND hwndParent, LPTSTR lpszSrcPath,
                               BOOL bTrueType, PTSTR szLHS, int* iReply );
BOOL bInstallOEMFile( LPTSTR lpszDir, LPTSTR lpszDstName, LPTSTR lpszDesc,
                      WORD wFontType, WORD wCount );

BOOL NEAR PASCAL bTTEnabled( );

VOID NEAR PASCAL vEnsureInit( );
VOID NEAR PASCAL vPathOnSharedDir( LPTSTR lpszFile, LPTSTR lpszPath );
LPTSTR NEAR PASCAL lpNamePart( LPCTSTR lpszPath );

extern HWND ghwndFontDlg;

//
// We provide custom help text for only the following:
//
// 1. "Copy fonts to..." checkbox.
// 2. "Select All" push button.
// 3. "List of Fonts" listbox.
//
// All other requests for context-sensitive help text are forwarded
// to the "file open" common dialog for standard text.
//
const static DWORD rgHelpIDs[] =
{
    ID_BTN_COPYFILES, IDH_FONTS_ADD_COPY_TO_FONT_DIR,
    ID_BTN_SELALL,    IDH_FONTS_ADD_SELECTALL,
    ctlLast+1,        IDH_FONTS_ADD_FONTLIST,
    IDC_LIST_OF_FONTS,IDH_FONTS_ADD_FONTLIST,
    0,0
};


/*****************************************************************************
   AddFontsDialog - Our add-on to the commdlg font for listing the font names
*****************************************************************************/


class CWnd {
protected:
   CWnd( HWND hWnd = 0 ) : m_hWnd( hWnd ) {};

public:
   HWND  hWnd( ) { return m_hWnd; }

   void UpdateWindow( )
       { ::UpdateWindow( m_hWnd ); }

   BOOL EnableWindow( BOOL bEnable )
       { return ::EnableWindow( m_hWnd, bEnable ); }

   void SetRedraw( BOOL bRedraw = TRUE )
       { ::SendMessage( m_hWnd, WM_SETREDRAW, bRedraw, 0 ); }

   void InvalidateRect( LPCRECT lpRect, BOOL bErase )
       { ::InvalidateRect( m_hWnd, NULL, bErase ); }

   HWND GetDlgItem( int nID ) const
       { return ::GetDlgItem( m_hWnd, nID ); }


protected:
   HWND  m_hWnd;
};

class CListBox : public CWnd
{
public:
   CListBox( UINT id, HWND hParent ) : CWnd( ), m_id( id )
    {   m_hWnd = ::GetDlgItem( hParent, m_id );

        DEBUGMSG( (DM_TRACE1, TEXT( "CListBox: ctor" ) ) );

#ifdef _DEBUG
        if( !m_hWnd )
        {
            DEBUGMSG( (DM_ERROR, TEXT( "CListBox: No hWnd on id %d" ), id ) );
            // DEBUGBREAK;
        }
#endif

    }

   int GetCount( ) const
       { return (int)::SendMessage( m_hWnd, LB_GETCOUNT, 0, 0 ); }

   int GetCurSel( ) const
       { return (int)::SendMessage( m_hWnd, LB_GETCURSEL, 0, 0 ); }

   int GetSelItems( int nMaxItems, LPINT rgIndex ) const
       { return (int)::SendMessage( m_hWnd, LB_GETSELITEMS, nMaxItems, (LPARAM)rgIndex ); }

   int GetSelCount( ) const
       { return (int)::SendMessage( m_hWnd, LB_GETSELCOUNT, 0, 0 ); }

   int SetSel( int nIndex, BOOL bSelect = TRUE )
       { return (int)::SendMessage( m_hWnd, LB_SETSEL, bSelect, nIndex ); }

   int GetText( int nIndex, TCHAR FAR * lpszBuffer ) const
       { return (int)::SendMessage( m_hWnd, LB_GETTEXT, nIndex, (LPARAM)lpszBuffer ); }

   DWORD_PTR GetItemData( int nIndex ) const
       { return ::SendMessage( m_hWnd, LB_GETITEMDATA, nIndex, 0 ); }

   INT_PTR SetItemData( int nIndex, DWORD dwItemData )
       { return ::SendMessage( m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData ); }

   void ResetContent( void )
       { ::SendMessage( m_hWnd, LB_RESETCONTENT, 0, 0 ); }

   int  FindStringExact( int nIndexStart, LPCTSTR lpszFind ) const
       { return (int)::SendMessage( m_hWnd, LB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind ); }

   int  AddString( LPCTSTR lpszItem )
       { return (int)::SendMessage( m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem ); }

private:
   UINT m_id;
};


class CComboBox : public CWnd
{
public:
   CComboBox( UINT id, HWND hParent ) : CWnd( ), m_id( id )
      { m_hWnd = ::GetDlgItem( hParent, m_id );

        DEBUGMSG( (DM_TRACE1, TEXT( "CComboBox: ctor" ) ) );

        if( !m_hWnd )
        {
            DEBUGMSG( (DM_ERROR, TEXT( "CComboBox: No hWnd on id %d" ), id ) );
            // DEBUGBREAK;
        }
      }

   int GetCurSel( ) const
       { return (int)::SendMessage( m_hWnd, CB_GETCURSEL, 0, 0 ); }

private:
   UINT     m_id;
};


class AddFontsDialog : public CWnd // : public FastModalDialog
{
   public   :  // constructor only
                  AddFontsDialog ( );
                  ~AddFontsDialog( );
            void  vAddSelFonts   ( );
            void  vUpdatePctText ( );

            BOOL  bInitialize(void);

            BOOL  bAdded         ( ) {  return m_bAdded; };

            void  vStartFonts    ( ); //  {  m_nFontsToGo = -1; };

            BOOL  bStartState    ( ) {  return m_nFontsToGo == -1; };

            BOOL  bFontsDone     ( ) {  return m_nFontsToGo == 0;  };

            BOOL  bInitialFonts  ( ) { m_nFonts = pListBoxFiles()->GetCount();
                                       m_nFontsToGo = m_nFonts;
                                       return m_nFonts > 0; };

            void  vHoldComboSel  ( ) { m_nSelCombo = pGetCombo()->GetCurSel(); };

            void  vNewComboSel   ( ) { if( m_nSelCombo == -1 ) vStartFonts( );};

            void  vCloseCombo    ( ) { if( m_nSelCombo != pGetCombo( )->GetCurSel( ) )
                                           vStartFonts( );
                                       m_nSelCombo = -1; };

            CListBox * pListBoxDesc  ( )
                                 { return m_poListBoxDesc;};

            CListBox * pListBoxFiles( )
                                 { return m_poListBoxFiles; };

            //
            //  These were added to make up for no MFC
            //

            void EndDialog( int nRet ) { ::EndDialog( m_hWnd, nRet ); }

            void Attach( HWND hWnd )
                           { m_hWnd = hWnd;
                             m_poComboBox = new CComboBox( ID_CB_FONTDISK, hWnd );
                             m_poListBoxDesc = new CListBox( ID_LB_ADD, hWnd );
                             m_poListBoxFiles = new CListBox( ID_LB_FONTFILES, hWnd );}

            void Detach( ) {m_hWnd = 0;
                           if( m_poComboBox ) delete m_poComboBox;
                           if( m_poListBoxDesc ) delete m_poListBoxDesc;
                           if( m_poListBoxFiles ) delete m_poListBoxFiles; }

            void CheckDlgButton( UINT id, BOOL bCheck )
                                 { ::CheckDlgButton( m_hWnd, id, bCheck ); }

            void EndThread(void)
                { SetEvent(m_heventDestruction); }

            LONG AddRef(void);
            LONG Release(void);


   private :
            CComboBox * pGetCombo( ) { return m_poComboBox;};

   public   :  // fields
            CComboBox *    m_poComboBox;
            CListBox *     m_poListBoxFiles;
            CListBox *     m_poListBoxDesc;
            LPOPENFILENAME m_pOpen;
            BOOL           m_bAdded;
            int            m_nSelCombo;
            int            m_nFonts;
            int            m_nFontsToGo;
            HANDLE         m_hThread;
            DWORD          m_dwThreadId;
            HANDLE         m_heventDestruction; // Used to tell threads we're done.
            LONG           m_cRef;              // Instance reference counter.
};


/*****************************************************************************
   DBCS support.
*****************************************************************************/

#define TRUETYPE_SECTION      TEXT( "TrueType fonts" )
#define WIFEFONT_SECTION      TEXT( "Wife fonts" )
#define TRUETYPE_WITH_OEMINF  (WORD)0x8000
#define MAXFILE   MAX_PATH_LEN

static TCHAR szOEMSetup[] = TEXT( "oemsetup.inf" );

TCHAR szSetupInfPath[ PATHMAX ];

typedef struct tagADDFNT {
        CListBox * poListDesc;
        int     nIndex;
        int     which;
} ADDFNT, far *LPADDFNT;



/*************************************************************************
 * FUNCTION: CutOffWhite
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

VOID NEAR PASCAL CutOffWhite( LPTSTR lpLine )
{
    TCHAR  szLineBuf[ 120 ];
    LPTSTR lpBuf = szLineBuf;
    LPTSTR lpch;


    for( lpch = lpLine; *lpch; lpch = CharNext( lpch ) )
    {
        if( *lpch==TEXT( ' ' ) || *lpch == TEXT( '\t' ) )
             continue;
        else
        {
            if( IsDBCSLeadByte( *lpch ) )
            {
                *lpBuf++ = *lpch;
                *lpBuf++ = *(lpch + 1);
            }
            else
                *lpBuf++ = *lpch;
        }
    }

    *lpBuf = TEXT( '\0' );

    lstrcpy( lpLine,szLineBuf );
}


/*************************************************************************
 * FUNCTION: StrNToAtom
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

ATOM NEAR PASCAL StrNToAtom( LPTSTR lpStr, int n )
{
    TCHAR szAtom[ 80 ];

    //
    //  Take space for NULL
    //

    lstrcpyn( szAtom, lpStr, n+1 );

    //
    //  Null terminate the string
    //

    *(szAtom+n) = TEXT( '\0' );

    CutOffWhite( szAtom );

    return AddAtom( szAtom );
}


/*************************************************************************
 * FUNCTION: ResetAtomInDescLB
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

VOID NEAR PASCAL ResetAtomInDescLB( HWND hLB )
{
    int   nCount;
    DWORD dwData;


    if( nCount = (int) SendMessage( hLB, LB_GETCOUNT, 0, 0L ) )
    {
        while( nCount > 0 )
        {
            nCount--;

            SendMessage( hLB, LB_GETITEMDATA, nCount, (LPARAM) (LPVOID) &dwData );

            //
            //  Atom handle must be C000H through FFFFH
            //

            if( HIWORD( dwData ) >= 0xC000 )
                DeleteAtom( HIWORD( dwData ) );
        }
    }
}


/*************************************************************************
 * FUNCTION: GetNextFontFromInf
 *
 * PURPOSE:
 *          Get font description from Inf scanline, and set it to LB.
 *          Also set ITEMDATA that includes correct index to file listbox,
 *          and 'tag' name string of inf file.
 *
 * RETURNS:
 *
 *************************************************************************/

#define WHICH_FNT_TT    0
#define WHICH_FNT_WIFE  1

WORD FAR PASCAL GetNextFontFromInf( LPTSTR lpszLine, LPADDFNT lpFnt )
{
    TCHAR   szDescName[ 80 ];
    LPTSTR  lpch,lpDscStart;
    WORD    wRet;
    int     nItem;
    ATOM    atmTagName;

    CListBox *  poListDesc = lpFnt->poListDesc;



    //
    //  Presume failure
    //

    wRet = (WORD)-1; /* Presume failure */

    if( lpch = StrChr( lpszLine, TEXT( '=' ) ) )
    {
        //
        //  Get tag string in 'WifeFont' section
        //

        atmTagName = StrNToAtom( lpszLine, (int)(lpch-lpszLine) );

        //
        //  Get description string from right side of '='.
        //  Setup Inf functions in CPSETUP ensure the string
        //  is formatted as key=value with no space between
        //  the key and the value strings.
        //

        lpDscStart = lpch + 1;
        lstrcpyn(szDescName, lpDscStart, ARRAYSIZE(szDescName));

        if( atmTagName && lpDscStart )
        {
           AddITEMDATA OurData;


           OurData.nFileSlot = (WORD)lpFnt->nIndex;
           OurData.wFontType = (lpFnt->which == WHICH_FNT_TT )
                                    ? (atmTagName & ~TRUETYPE_WITH_OEMINF )
                                    : atmTagName;

           if( poListDesc->FindStringExact( -1, szDescName ) == LB_ERR )
           {
                nItem = poListDesc->AddString( szDescName );

                if( nItem != LB_ERR )
                    poListDesc->SetItemData( nItem, OurData.ItemData );
                else
                {
                    DeleteAtom( atmTagName );

                    DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: Error adding string %s" ),
                              szDescName ) );
                }
            }
            else
            {
                DeleteAtom( atmTagName );

                DEBUGMSG( (DM_TRACE1,TEXT( "String %s already in list" ),
                          szDescName) );
            }

            //
            //  Doesn't matter whether already exists
            //

            wRet = NULL;
        }
        else if( atmTagName )
            DeleteAtom( atmTagName );
    }

    return wRet;
}


/*************************************************************************
 * FUNCTION: FindOemInList
 *
 * PURPOSE:
 *          Scan contents of listbox, checking if that is oemsetup.inf.
 *
 * RETURNS:
 *
 *************************************************************************/

BOOL NEAR PASCAL FindOemInList( CListBox * pListFiles,
                                int nFiles,
                                LPINT pIndex,
                                LPTSTR szInfFileName )
{
    int   i;
    TCHAR szFile[ MAXFILE ];


    DEBUGMSG( (DM_TRACE1,TEXT( "FONTEXT: FindOemInList" ) ) );

    for( i = 0; i < nFiles; i++ )
    {
        if( pListFiles->GetText( i, szFile ) != LB_ERR )
        {
            if( !lstrcmpi( szFile, szOEMSetup ) )
            {
                *pIndex = i;
                lstrcpy( szInfFileName, szFile );

                //
                //  found oemsetup.inf ... return index
                //

                return TRUE;
            }
        }
        else
            //
            //  fail
            //
            return FALSE;
    }

    //
    //  not found
    //

    return FALSE;
}


/*****************************************************************************
   Module-global variables
*****************************************************************************/

static AddFontsDialog*  s_pDlgAddFonts = NULL;
static UINT s_iLBSelChange = 0;



/*************************************************************************
 * FUNCTION: AddFontsDialog
 *
 * PURPOSE: class constructor
 *
 * RETURNS:
 *
 *************************************************************************/

AddFontsDialog::AddFontsDialog( )
   : CWnd( ),
      m_bAdded( FALSE ),
      m_poListBoxFiles( 0 ),
      m_poListBoxDesc( 0 ),
      m_hThread( NULL ),
      m_heventDestruction(NULL),
      m_cRef(0)
{
   /* vSetHelpID( IDH_DLG_FONT2 ); */
    AddRef();
}


/*************************************************************************
 * FUNCTION: ~AddFontsDialog
 *
 * PURPOSE: class destructor
 *
 * RETURNS:
 *
 *************************************************************************/

AddFontsDialog::~AddFontsDialog( )
{
    if (NULL != m_heventDestruction)
        CloseHandle(m_heventDestruction);

    if (NULL != m_hThread)
        CloseHandle(m_hThread);
}

//
// AddRef and Release
//
// These functions have the same meaning as in OLE (sort of).
// When the reference count drops to 0, the object is deleted. The return
// values for each carry the same reliability caveat as their OLE counterparts.
// Note that this only works for dynamically-created objects.  If Release() is
// called for an object not created with the C++ "new" operator, the call to
// "delete" will fault.
// Because two different threads access the dialog object through a
// statically-defined pointer.  The AddRef/Release mechanism works well for
// controlling the lifetime of this object and ensuring the object is available
// for each thread.
//
LONG AddFontsDialog::AddRef(void)
{
    LONG lReturn = m_cRef + 1;

    InterlockedIncrement(&m_cRef);

    DEBUGMSG((DM_TRACE1, TEXT("AddFontsDialog::AddRef %d -> %d"), lReturn-1, lReturn));

    return lReturn;
}


LONG AddFontsDialog::Release(void)
{
    LONG lReturn = m_cRef - 1;

    DEBUGMSG((DM_TRACE1, TEXT("AddFontsDialog::Release %d -> %d"), lReturn+1, lReturn));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        DEBUGMSG((DM_TRACE1, TEXT("AddFontsDialog: Object deleted.")));
        lReturn = 0;
    }

    return lReturn;
}


/*************************************************************************
 * FUNCTION: AddFontsDialog::bInitialize
 *
 * PURPOSE:  Do any object initializations that may fail.
 *
 * RETURNS:  TRUE  = Object initialized.
 *           FALSE = Initialization failed.
 *
 *************************************************************************/

BOOL AddFontsDialog::bInitialize(void)
{
    //
    // If the destruction event object hasn't been created, create it.
    // This event object is used to tell the dialog's background thread
    // when to exit.
    //
    if (NULL == m_heventDestruction)
    {
        m_heventDestruction = CreateEvent(NULL,  // No security attrib.
                                          TRUE,  // Manual reset.
                                          FALSE, // Initially non-signaled.
                                          NULL); // Un-named.
    }

    return (NULL != m_heventDestruction);
}


/*************************************************************************
 * FUNCTION: dwThreadProc
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

DWORD dwThreadProc( AddFontsDialog * poFD )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: BG thread running" ) ) );

    if (NULL != poFD)
    {
        poFD->AddRef();

        if(NULL == poFD->hWnd())
        {
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: BG thread window is null!!!" ) ) );
            DEBUGBREAK;
        }

        if (NULL != poFD->m_heventDestruction)
        {
            while( 1 )
            {
                //
                // Tell Dialog Proc to add more items to the dialog's font listbox.
                //
                PostMessage( poFD->hWnd(), WM_COMMAND, (WPARAM)IDM_IDLE, (LPARAM)0 );

                //
                // Wait max of 2 seconds for event to signal.
                // If signaled, exit loop and end thread proc.
                //
                if (WaitForSingleObject(poFD->m_heventDestruction, 2000) == WAIT_OBJECT_0)
                    break;
            }
        }
        poFD->Release();
    }

    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: BG thread completed." ) ) );

    return 0;
}


/*************************************************************************
 * FUNCTION: vStartFonts
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

void  AddFontsDialog::vStartFonts( )
{

    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT:  ---------- vStartFonts-------" ) ) );
//   DEBUGBREAK;

    //
    //  Set the start state.
    //

    m_nFontsToGo = -1;

    //
    //  Create the background thread
    //

    if( !m_hThread )
    {
        m_hThread = CreateThread( NULL,
                                  0,
                                  (LPTHREAD_START_ROUTINE) dwThreadProc,
                                  (LPVOID) this,
                                  IDLE_PRIORITY_CLASS | CREATE_NO_WINDOW,
                                  &m_dwThreadId );
    }

#ifdef _DEBUG
    if( !m_hThread )
    {
        DEBUGMSG( (DM_ERROR, TEXT( "BG Thread not created" ) ) );
        DEBUGBREAK;
    }
#endif

}


/*************************************************************************
 * FUNCTION: vUpdatePctText
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

void  AddFontsDialog::vUpdatePctText( )
{
    int    pct;
    TCHAR  szFontsRead[ 80 ];
    TCHAR  szTemp[ 80 ] = { TEXT( '\0' ) };

    if( m_nFontsToGo > 0 )
    {
       LoadString( g_hInst, IDSI_FMT_RETRIEVE, szFontsRead, 80 );

       pct = (int) ((long) ( m_nFonts - m_nFontsToGo ) * 100 / m_nFonts );

       wsprintf( szTemp, szFontsRead, pct );
    }

    SetDlgItemText( m_hWnd, ID_SS_PCT, szTemp );
}


BOOL bRemoteDrive( LPCTSTR szDir )
{
    if( szDir[ 0 ] == TEXT( '\\' ) && szDir[ 1 ] == TEXT( '\\' ) )
    {
        //
        //  This is a UNC name
        //

        return( TRUE );
    }

    if( IsDBCSLeadByte( szDir[ 0 ]) || szDir[ 1 ] != TEXT( ':' )
            || szDir[ 2 ] != TEXT( '\\' ) )
    {
        return( FALSE );
    }

#ifndef WIN32
    switch( GetDriveType( (szCurDir[ 0 ]-TEXT( 'A' ) ) & 31 ) )
#else
    TCHAR szRoot[ 4 ];

    lstrcpyn( szRoot, szDir, 4 );

    switch( GetDriveType( szRoot ) )
#endif
    {
    case DRIVE_REMOTE:
    case DRIVE_REMOVABLE:
    case DRIVE_CDROM:
        return( TRUE );

    default:
        break;
    }

    return( FALSE );
}


/*************************************************************************
 * FUNCTION: vAddSelFonts
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

void AddFontsDialog :: vAddSelFonts( )
{
    FullPathName_t szCurDir;

    BOOL  bAddFonts  = TRUE;
    BOOL  bCopyFiles = IsDlgButtonChecked( m_hWnd, ID_BTN_COPYFILES );

#if 0
    CWnd* pFontDlg = CWnd::FromHandle( m_pOpen->hwndOwner );

    //
    // Let the main window live again, and give it focus
    //

    pFontDlg->EnableWindow( TRUE );
    pFontDlg->SetFocus( );
    ShowWindow( SW_HIDE );
    pFontDlg->UpdateWindow( );  // forces repaint of hidden area
#endif

    if (0 < GetCurrentDirectory( ARRAYSIZE( szCurDir ), szCurDir ))
    {
        lpCPBackSlashTerm( szCurDir );
   
        //
        //  If we're not going to copy the font files, but they live on a remote
        //  disk for a removeable disk, we'd better make sure the user understands
        //  the implications
        //

        if( !bCopyFiles )
        {
            if( bRemoteDrive( szCurDir ) &&
                iUIMsgYesNoExclaim(m_hWnd, IDSI_MSG_COPYCONFIRM ) != IDYES )
            {
                goto done;
            }
        }

        //
        //  Save off the current directory. bAddSelFonts( ) may change it.
        //
        TCHAR  szCWD[ MAXFILE ];
        if (0 < GetCurrentDirectory( ARRAYSIZE( szCWD ), szCWD ))
        {
            if( bAddSelFonts( szCurDir, !bCopyFiles ) )
                m_bAdded = TRUE;

            SetCurrentDirectory( szCWD );
        }
    }

    //
    //  From here, we dispose of the dialog appropriately
    //

done:
    if( m_bAdded )
    {
        ResetAtomInDescLB( s_pDlgAddFonts->pListBoxDesc()->hWnd() );

        FORWARD_WM_COMMAND( m_hWnd, IDABORT, 0, 0, PostMessage );
    }
    else
        ShowWindow( m_hWnd, SW_NORMAL );

    return;
}


extern BOOL bRegHasKey( const TCHAR * szKey, TCHAR * szVal = 0, int iValLen = 0 );


/*************************************************************************
 * FUNCTION: bFontInstalledNow
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

BOOL NEAR PASCAL bFontInstalledNow( PTSTR szLHS )
{
    return  bRegHasKey( szLHS );
}


/***************************************************************************
 * FUNCTION: vEnsureInit
 *
 * PURPOSE:  Make sure our basic module-wide initialization is complete
 *
 * RETURNS:  none
 ***************************************************************************/

VOID NEAR PASCAL vEnsureInit( )
{
    static BOOL s_bInited = FALSE;


    if( s_bInited )
        return;

//
// [stevecat] This is done at vCPPanelInit( ) time now.
//
//    ::GetFontsDirectory( s_szSharedDir, ARRAYSIZE( s_szSharedDir ) );
//
//    lpCPBackSlashTerm( s_szSharedDir );

    s_bInited = TRUE;
}


/***************************************************************************
 * FUNCTION: lpNamePart
 *
 * PURPOSE:  Return pointer to filename only part of path
 *
 * RETURNS:  Pointer to filename
 ***************************************************************************/

LPTSTR NEAR PASCAL lpNamePart( LPCTSTR lpszPath )
{
    LPCTSTR lpCh = StrRChr( lpszPath, NULL, TEXT( '\\' ) );

    if( lpCh )
        lpCh++;
    else
        lpCh = lpszPath;

    return (LPTSTR) lpCh;
}


/***************************************************************************
 * FUNCTION: vPathOnSharedDir
 *
 * PURPOSE:  Make a full path name out of the input file name and on the
 *           shared directory
 *
 * RETURNS:  none
 ***************************************************************************/

VOID NEAR PASCAL vPathOnSharedDir( LPTSTR lpszFileOnly, LPTSTR lpszPath )
{
    lstrcpy( lpszPath, s_szSharedDir );
    lstrcat( lpszPath, lpszFileOnly );
}


/***************************************************************************
 * FUNCTION:   bTTEnabled
 *
 * PURPOSE:    Determine if TrueType is enabled.  GetRasterizerCaps is
 *             supposed to tell us, but it can give eroneous results.  For
 *             instance, if SETUP.INF wasn't there when windows started (or
 *             Language is commented out of WIN.INI), the return status is
 *             bad - why???
 *             One guess - it appears that the Flags field is filled in
 *             properly regardless, but that the Language field is what's
 *             actually returned as the status, and Language defaults to 0.
 *             We'll finesse this by comfirming the size field in the
 *             structure matches what we think it should be, and only believe
 *             the flags in that  case.
 *
 * RETURNS:    BOOL - True if TrueType is enabled
 ***************************************************************************/

BOOL NEAR PASCAL bTTEnabled( )
{
    RASTERIZER_STATUS info;


    GetRasterizerCaps( &info, sizeof( info ) );

    return( info.wFlags & TT_ENABLED ) && ( info.nSize == sizeof( info ) );
}


/***************************************************************************
 * FUNCTION:   vHashToNulls
 *
 * PURPOSE:    Substitute nulls for all the hash (TEXT( '#' )) characters in the input
 *             string - we use this to help with strings that need embedded
 *             nulls but also need to be stored in resource files.
 *
 * RETURNS:    none
 ***************************************************************************/

VOID NEAR PASCAL vHashToNulls( LPTSTR lp )
{
    while( *lp )
        if( *lp == TEXT( '#' ) )
            *lp++ = NULL;
        else
            lp = CharNext( lp );
}


#ifdef WINNT

/////////////////////////////////////////////////////////////////////////////
//
// bIsCompressed
//
//  Leave this function as only ANSI because it just checks the header to
//  determine if it is a compress file or not.
//
/////////////////////////////////////////////////////////////////////////////

BOOL bIsCompressed( LPTSTR szFile )
{
    static CHAR szCmpHdr[] = "SZDD\x88\xf0'3";

    BOOL     bRet = FALSE;
    HANDLE   fh;
    CHAR     buf[ ARRAYSIZE( szCmpHdr ) ];


    if( ( fh = wCPOpenFileWithShare( szFile, NULL, OF_READ ) )
              == (HANDLE) INVALID_HANDLE_VALUE )
        return(FALSE);

    buf[ ARRAYSIZE( buf ) - 1 ] = '\0';

    if( MyByteReadFile( fh, buf, ARRAYSIZE( buf ) - 1 )
           && !lstrcmpA( buf, szCmpHdr ) )
        bRet = TRUE;

    MyCloseFile( fh );

    return( bRet );
}

#else

/***************************************************************************
 * FUNCTION:   bIsCompressed
 *
 * PURPOSE:    Determine if the input file is compressed by peaking into
 *             the header and looking for our magic string.
 *
 * RETURNS:    BOOL - True if compressed
 ***************************************************************************/

BOOL NEAR PASCAL bIsCompressed( LPTSTR szFile )
{
    static   char szMagic[] = "SZDD\x88\xf0'3";
    const    int iLast      = sizeof( szMagic ) - 1;
    char     buf[ sizeof( szMagic ) ];
    int      fh;
    OFSTRUCT of;
    BOOL     bRet = FALSE;

    if( ( fh = wCPOpenFileWithShare( szFile, &of, OF_READ ) ) != HFILE_ERROR )
    {
        buf[ iLast ] = '\0';

        if( _lread( fh, buf, iLast ) == iLast )
            if( lstrcmp( buf, szMagic ) == 0 )
                bRet = TRUE;

        _lclose( fh );
    }
    return( bRet );
}

#endif  //  WINNT


/***************************************************************************
 * FUNCTION:   vConvertExtension
 *
 * PURPOSE:    Take the input file name and replace its extension with that
 *             input
 *
 * RETURNS:    none
 ***************************************************************************/

VOID NEAR PASCAL vConvertExtension( LPTSTR lpszFile, LPTSTR lpszExt )
{
    LPTSTR lpCh;

    //
    //  Remove any extension
    //

    if( lpCh = StrChr( lpNamePart( lpszFile ), TEXT( '.' ) ) )
        *lpCh = TEXT( '\0' );

    //
    //  Old name updated now.
    //

    lstrcat( lpszFile, lpszExt );
}


#ifdef WINNT

/***************************************************************************
 * FUNCTION:   bFileFound
 *
 * PURPOSE:    Check for existance of the given file - we really want it
 *             not to exist.
 *
 * RETURNS:    BOOL - True if file exists
 ***************************************************************************/

BOOL PASCAL bFileFound( LPTSTR pszFullPath, LPTSTR lpszFileOnly )
{
    if( wCPOpenFileWithShare( pszFullPath, NULL, OF_EXIST )
            != (HANDLE) INVALID_HANDLE_VALUE )
        return TRUE;
    else
        return GetModuleHandle( lpszFileOnly ) != NULL;
}

#else

/***************************************************************************
 * FUNCTION:   bFileFound
 *
 * PURPOSE:    Check for existance of the given file - we really want it
 *             not to exist.
 *
 * RETURNS:    BOOL - True if file exists
 ***************************************************************************/

BOOL NEAR PASCAL bFileFound( PTSTR pszFullPath, LPTSTR lpszFileOnly )
{
    OFSTRUCT of;


    if( wCPOpenFileWithShare( pszFullPath, &of, OF_EXIST ) != (WORD)HFILE_ERROR )
        return TRUE;

#ifndef WIN32

    // EMR: The OFSTRUCT isn't being updated with the error code on OF_EXIST test.

    else if( of.nErrCode != OF_ERR_FNF )
        return TRUE;
#endif
    else
        return GetModuleHandle( lpszFileOnly ) != NULL;
}

#endif  //  WINNT


/////////////////////////////////////////////////////////////////////////////
//
// UniqueFilename
//
//   Guarantee a unique filename in a directory.  Do not overwrite existing
//   files.
//
/////////////////////////////////////////////////////////////////////////////

BOOL bUniqueFilename( LPTSTR lpszDst, LPTSTR lpszSrc, LPTSTR lpszDir )
{
    TCHAR   szFullPath[PATHMAX];
    LPTSTR  lpszFile, lpszSrcExt, lpszDstExt;
    WORD    digit = 0;


    lstrcpy( szFullPath, lpszDir );

    lstrcpy( lpszFile = lpCPBackSlashTerm( szFullPath ), lpszSrc );

    if( !(lpszSrcExt = _tcschr( lpszSrc, TEXT( '.' ) ) ) )
        lpszSrcExt = szDot;


    if( wCPOpenFileWithShare( szFullPath, NULL, OF_EXIST ) == INVALID_HANDLE_VALUE )
        goto AllDone;

    if( !(lpszDstExt = _tcschr( lpszFile, TEXT( '.' ) ) ) )
        lpszDstExt = lpszFile + lstrlen( lpszFile );

    while( lpszDstExt - lpszFile < 7 )
        *lpszDstExt++ = TEXT( '_' );

    do
    {
        TCHAR szTemp[ 8 ];

        wsprintf( szTemp, TEXT( "%X" ), digit++ );

        if( digit++ > 0x4000 )
            return( FALSE );

        lstrcpy( lpszFile + 8 - lstrlen( szTemp ), szTemp );
        lstrcat( lpszFile, lpszSrcExt );
    }
    while( wCPOpenFileWithShare( szFullPath, NULL, OF_EXIST ) != INVALID_HANDLE_VALUE );

AllDone:
    lstrcpy( lpszDst, lpszFile );

    return( TRUE );
}


/***************************************************************************
 * FUNCTION: bUniqueOnSharedDir
 *
 * PURPOSE:  Given the source filename, lpszSRc and the directory on which
 *           it resides, lpszDir, make a unique filename by sticking letters
 *           on the end of the name until we get a good one.
 *
 * RETURNS:  BOOL - success of attempt
 ***************************************************************************/

BOOL NEAR PASCAL bUniqueOnSharedDir( LPTSTR lpszUniq, LPTSTR lpszSrc )
{
    TCHAR           szOrigExt[ 5 ];     // Hold input file extension
    FullPathName_t szFullPath;          // Working space for unique name
    LPTSTR          lpszFileOnly;       // Points withing szFullPath
    LPTSTR          lpCh;


    //
    //  Make the full file name out of the input directory and file names.
    //  Hold pointer to where file portion begins
    //

    vPathOnSharedDir( lpszSrc, szFullPath );

    lpszFileOnly = lpNamePart( szFullPath );

    //
    //  Check the full file for existance  - if we couldn't find it, good -
    //  that's what we were shooting for.  Otherwise, make a unique name
    //

    if( bFileFound( szFullPath, lpszFileOnly ) )
    {
        //
        //  Original file not unique
        //

        //
        //  Now we're going to work on making the fake file name.  To make
        //  it easier we're going to force the name length to be at least
        //  7 characters.  We're going to mess with the name in our local
        //  scratch space, to that's where we set the pointers.  We also
        //  hold our extension so that we can shove it on as we iterate thru
        //  the name guesses.
        //

        if( lpCh = StrChr( lpszFileOnly, TEXT( '.' ) ) )
        {
            lstrcpy( szOrigExt, lpCh );

            //
            //  Chop name at extension point.
            //

            *lpCh = 0;
        }
        else
            lstrcpy( szOrigExt, TEXT( "." ) );

        while( lstrlen( lpszFileOnly ) < 7 )
            lstrcat( lpszFileOnly, TEXT( "_" ) );

        //
        //  Now we're going to try to make the names.  We'll loop through
        //  hex digits, building file names with the digit stuck in the last
        //  spot, followed by our extension.
        //

        WORD digit = 0;
        TCHAR szTemp[ 8 ];


        do
        {
            wsprintf( szTemp, TEXT( "%X" ), digit++ );

            if( digit++ > 0x4000 )
                //
                //  Give up at some point
                //

                return FALSE;

            lstrcpy( lpszFileOnly + 8 - lstrlen( szTemp ), szTemp );

            lstrcat( lpszFileOnly, szOrigExt );

        } while( bFileFound( szFullPath, lpszFileOnly ) );

    }  // Original file not unique

    //
    //  We now have a unique name, copy it to the output space
    //

    lstrcpy( lpszUniq, lpszFileOnly );

    return TRUE;
}


/***************************************************************************
 * FUNCTION: IGetExpandedName
 *
 * PURPOSE:  get the expanded name, but fill in the common extensions if
 *           it's not imbedded in the compressed file.
 *
 *  Some compressed dudes don't have the missing last character imbedded
 *  in the file.  if this is the case, we check to see if it's in the known
 *  extension list above.  If it is, we change the name ourselves
 *
 * RETURNS:  INT - same as LZ functions
 ***************************************************************************/

TCHAR *c_aKnownExtensions[] = {
    TEXT( "ttf" ),
    TEXT( "fon" ),
};


DWORD IGetExpandedName( LPTSTR lpszSrc, LPTSTR lpszDest, UINT cchDest )
{
    LPTSTR lpszDestExt;

    CFontFile file;
    DWORD dwReturn = file.GetExpandedName(lpszSrc, lpszDest, cchDest);

    lpszDestExt = PathFindExtension( lpszDest );

    if( lpszDestExt && *lpszDestExt )
    {
        lpszDestExt++;

        //
        //  is it missing the last character?
        //  assumes that if the uncompressed extension was 2 characters,
        //  it's missing one.
        //

        if( lstrlen( lpszDestExt ) == 2 )
        {
            int i;

            for( i = 0; i < ARRAYSIZE( c_aKnownExtensions ); i++ )
            {
                if( !StrCmpNI( lpszDestExt, c_aKnownExtensions[ i ], 2 ) )
                {
                    //
                    //  matches!  Take it the corresponding full extension
                    //

                    lstrcpy( lpszDestExt, c_aKnownExtensions[ i ]);

                    break;
                }
            }
        }

        //
        //  this preserves the long file name because
        //  getexpandedname always returns the short name
        //

        if( lstrlen( lpszDestExt ) <= 3 )
        {
            TCHAR szExt[ 4 ];

            //
            //  save away the extension
            //

            lstrcpy( szExt, lpszDestExt );

            //
            //  restore the long name
            //

            lstrcpy( lpszDest, lpszSrc );

            lpszDest = PathFindExtension( lpszDest );

            //
            //  blast back the new extension
            //

            if( lpszDest && *lpszDest )
            {
                lpszDest++;
                lstrcpy( lpszDest, szExt );
            }
        }
    }

    return dwReturn;

}


/***************************************************************************
 * FUNCTION:   bAddSelFonts
 *
 * PURPOSE:    Install all the fonts that are currently selected in the
 *             add dialog
 *
 * RETURNS:    BOOL - True if any fonts have been installed - not necessarily
 *             all that were requested
 ***************************************************************************/

BOOL NEAR PASCAL bAddSelFonts( LPTSTR lpszInDir,
                               BOOL   bNoCopyJob )
{
    FontDesc_t     szLHS;
    FullPathName_t szTruePath;
    FullPathName_t szSelPath;
    FullPathName_t szFontPath;
    FullPathName_t szInDirCopy;
    FILENAME       szDstFile;
    FILENAME       szSelFile;     // Filename from listbox (but Uppercase )
    BOOL           bTrueType;
    BOOL           bNoCopyFile;
    int            nSelSlot;
    AddITEMDATA    OurData;
    int            iReply = 0;
    BOOL           bOnSharedDir    = FALSE;
    BOOL           bFontsInstalled = FALSE;
    CListBox *     pListFiles      = s_pDlgAddFonts->pListBoxFiles( );
    CListBox *     pListDesc       = s_pDlgAddFonts->pListBoxDesc( );
    WaitCursor     cWaiter;          // Starts and stops busy cursor
    WORD           wCount = 0;
    int            iTotalFonts, i = 0;
    //
    // Create "saved" versions of bNoCopyFile and bOnSharedDir
    // so that the original values are used for call to InstallT1Font( )
    // in the "for each file" loop.
    // Code following the call to InstallT1Font modifies bNoCopyFile and
    // bOnSharedDir so that they are incorrect on subsequent calls to
    // InstallT1Font.
    //
    BOOL bNoCopyFileSaved  = FALSE;
    BOOL bOnSharedDirSaved = FALSE;

    BOOL bOwnInstallationMutex = FALSE;
    HWND hwndProgress = NULL;
    CFontManager *poFontManager = NULL;

    //
    //  Determine if the files are already in the shared directory
    //  (which is where they're headed).
    //

    bOnSharedDirSaved = bOnSharedDir = (lstrcmpi( lpszInDir, s_szSharedDir ) == 0);

    bNoCopyFileSaved = bNoCopyFile = (bNoCopyJob || bOnSharedDir);


    iTotalFonts = pListDesc->GetSelCount( );

    if (!iTotalFonts)
        iTotalFonts = 1;

    //
    //  Init Type1 font installation and Progress dialog
    //

    InitPSInstall( );
    hwndProgress = InitProgress( pListDesc->hWnd() );

    //
    //  We're going to loop until we can't get any more fonts from the
    //  the selection list of the description list box
    //

    while(pListDesc->GetSelItems( 1, &nSelSlot ) )
    {
        if (InstallCancelled())
            goto OperationCancelled;

        if (SUCCEEDED(GetFontManager(&poFontManager)))
        {
            //
            // Must own installation mutex to install font.
            //
            INT iUserResponse  = IDRETRY;
            DWORD dwWaitResult = CFontManager::MUTEXWAIT_SUCCESS;

            while( IDRETRY == iUserResponse &&
                   (dwWaitResult = poFontManager->dwWaitForInstallationMutex()) != CFontManager::MUTEXWAIT_SUCCESS )
            {
                if ( CFontManager::MUTEXWAIT_WMQUIT != dwWaitResult )
                    iUserResponse = iUIMsgRetryCancelExclaim(hwndProgress, IDS_INSTALL_MUTEX_WAIT_FAILED, NULL);
                else
                {
                    //
                    // Cancel if thread received WM_QUIT while waiting for mutex.
                    //
                    iUserResponse = IDCANCEL;
                }
            }
            ReleaseFontManager(&poFontManager);

            //
            // If user chose to cancel or we got a WM_QUIT msg, cancel the installation.
            //
            if ( IDCANCEL == iUserResponse )
                goto OperationCancelled;

            bOwnInstallationMutex = TRUE;
        }

        //
        //  While selected desc
        //

        //
        //  Assume we're continuing.
        //

        iReply = 0;

        //
        //  Pull out a selected font, marking as unselected (so we don't grab
        //  again), and get the font name string.
        //

        pListDesc->SetSel( nSelSlot, FALSE );

        pListDesc->GetText( nSelSlot, szLHS );

        vUIPStatusShow( IDS_FMT_FONTINS, szLHS );

        //
        //  If the current selected font is already installed, don't reinstall
        //  until the user de-installs it.  Inform the user, and drop to
        //  decision handler.
        //

        if( bFontInstalledNow( szLHS ) )
        {
            UINT uMB = (pListDesc->GetSelCount( ) )
                                ? (MB_OKCANCEL | MB_ICONEXCLAMATION )
                                : MB_OK | MB_ICONEXCLAMATION;

            iReply = iUIMsgBox( hwndProgress, IDSI_FMT_ISINSTALLED, IDS_MSG_CAPTION,
                                uMB, szLHS );
            goto ReplyPoint;
        }

        //
        //  Now we can get the corresponding font file name from the files
        //  list box (since we can get its slot).  Force to uppercase for
        //  safety.
        //

        OurData.ItemData = (DWORD)pListDesc->GetItemData( nSelSlot );

        pListFiles->GetText( OurData.nFileSlot, szSelFile );

        bTrueType = (OurData.wFontType == TRUETYPE_FONT);

        //
        //  Update the overall progress dialog
        //

        UpdateProgress (iTotalFonts, i + 1, i * 100 / iTotalFonts);

        i++;

        //
        //  Build the complete selected file path name by appending to
        //  the input directory string
        //

        lstrcpy( szSelPath, lpszInDir );

        lstrcat( szSelPath, szSelFile );

        //
        //  Save a copy of the input directory to be used from here on.
        //

        lstrcpy( szInDirCopy, lpszInDir );

        BOOL    bUpdateWinIni;
        int     ifType;


        if( (OurData.wFontType == TYPE1_FONT)
           || (OurData.wFontType == TYPE1_FONT_NC) )
        {

            bNoCopyFile  = bNoCopyFileSaved;
            bOnSharedDir = bOnSharedDirSaved;

            //
            //  szSelPath has the full source file name
            //
            //  For installations involving the conversion of the Type1
            //  font to TrueType:
            //
            //         "szSelPath" has the destination name of the
            //                     installed TrueType font file.
            //         "szLHS"     is munged to contain "(TrueType)".
            //

            switch( ::InstallT1Font( hwndProgress,
                                     !bNoCopyFile,      //  Copy TT file?
                                     !bNoCopyFile,      //  Copy PFM/PFB files?
                                     bOnSharedDir,      //  Files in Shared Dir?
                                     szSelPath,         //  IN:  PFM File & Dir
                                                        //  OUT: TTF File & Dir
                                     szLHS ) )          //  IN & OUT: Font desc
            {
            case TYPE1_INSTALL_TT_AND_MPS:
                //
                //  The PS font was converted to TrueType and a matching
                //  PostScript font is ALREADY installed.
                //
                // bDeletePSEntry = TRUE;
                //
                //  fall thru....

            case TYPE1_INSTALL_TT_AND_PS:
                //
                //  The PS font was converted to TrueType and the matching
                //  PostScript font was installed.
                //

                ifType = IF_TYPE1_TT;

                //
                //  fall thru....

            case TYPE1_INSTALL_TT_ONLY:
                //
                //
                //  The PS font was converted to TrueType and the matching
                //  PostScript font was NOT installed and a matching PS
                //  font was NOT found.
                //
                //  Setup variables to finish installation of converted
                //  TrueType font file.
                //
                //  NOTE:  In this case "ifType" already equals IF_OTHER
                //

                bUpdateWinIni =
                bTrueType = TRUE;

                goto FinishTTInstall;


            case TYPE1_INSTALL_PS_AND_MTT:
                //
                //  The PostScript font was installed and we found a matching
                //  TrueType font that was already installed.
                //
                //  fall thru....

            case TYPE1_INSTALL_PS_ONLY:
                //
                //  Only the PostScript font was installed.
                //

                bUpdateWinIni = FALSE;
                bFontsInstalled = TRUE;

                goto FinishType1Install;

            case TYPE1_INSTALL_IDYES:
            case TYPE1_INSTALL_IDOK:
            case TYPE1_INSTALL_IDNO:
                //
                //  The font was not installed, but the User wanted to
                //  continue installation.  Continue installation with
                //  the next font.
                //
                //  The font was not installed due to an error somewhere
                //  and the User pressed OK in the MessageBox
                //
                //  OR
                //
                //  The User selected NO in the InstallPSDlg routine.
                //

                bUpdateWinIni = FALSE;
                goto NextSelection;

            case TYPE1_INSTALL_IDCANCEL:
            default:
                //
                //  CANCEL and NOMEM (user already warned)
                //
                goto OperationCancelled;
            }

            //
            //  On leaving this conditional many variables must be set up
            //  correctly to proceed with installation of a TrueType font.
            //
            //  szLHS         - fontname description for listbox display
            //  ifType        - itemdata to attach to TT lbox entry
            //  szSelPath     - filename of source font
            //  bTrueType     - TRUE if Type1 file converted to TT
            //  bUpdateWinIni - FALSE if Type1 file not converted to TT
            //                  and used separatly to determine if [fonts]
            //                  section of win.ini (registry) should be
            //                  updated.
            //

FinishTTInstall:

            //
            //  Determine if TTF file to install is in 'fonts' dir
            //

            lstrcpy( szFontPath, szSelPath );


            LPTSTR lpCh = StrRChr( szFontPath, NULL, TEXT( '\\' ) );

            if( lpCh )
            {
                lpCh++;
                *lpCh = TEXT( '\0' );
            }

            bOnSharedDir = lstrcmpi( szFontPath, s_szSharedDir ) == 0;
        }

        //
        //  Start install progress for this font
        //

        ResetProgress( );
        Progress2( 0, szLHS );

        //
        //  Reading OEMSETUP.INF for WIFE/DBCS TT.
        //  if the description is from .inf file, get necessary information
        //  from oemsetup.inf file, based on the information, merge splited
        //  files into single file if exist, and for WIFE font, install font
        //  driver if necessary.
        //

        if( OurData.wFontType > (0xC000 & ~TRUETYPE_WITH_OEMINF ) )
        {
            //
            //  Got a font with oemsetup.inf.
            //

            DEBUGMSG( (DM_TRACE1, TEXT( "Calling bInstallOEMFile %s" ),
                       szSelPath ) );

            // DEBUGBREAK;

            if( !bInstallOEMFile( szInDirCopy, szSelPath, szLHS,
                                  OurData.wFontType, wCount++ ) )
                goto NextSelection;

            SetCurrentDirectory( lpszInDir );

            DEBUGMSG( (DM_TRACE1, TEXT( "--- After bInstallOEMFile() --- " ) ) );
            DEBUGMSG( (DM_TRACE1, TEXT( "lpszInDir: %s" ) , szInDirCopy) );
            DEBUGMSG( (DM_TRACE1, TEXT( "szSelPath: %s" ) , szSelPath) );
            // DEBUGBREAK;

            bOnSharedDir = TRUE;

            //
            //  Use the newly created file as the one to be installed.
            //

            lstrcpy( szSelFile, lpNamePart( szSelPath ) );

            lstrcpy( szInDirCopy, szSelPath );

            *(StrRChr( szInDirCopy, NULL, TEXT( '\\' ) ) + 1 ) = 0;

        }

        //
        //  Check if its a valid font file, telling the user the bad news if not
        //

        DWORD dwStatus;
        if( !::bCPValidFontFile( szSelPath, NULL, NULL, FALSE, &dwStatus ) )
        {
            //
            // Display message box informing user about invalid font and why
            // it is invalid.  If user selects Cancel, font installation
            // is aborted.
            //
            iReply = iUIMsgBoxInvalidFont(hwndProgress, szSelPath, szLHS, dwStatus);
            goto ReplyPoint;
        }

        //
        //  A tricky case here - if the file is compressed, it cannot be used
        //  without decompressing, which makes it hard if we're not copying the
        //  file.  Give the user the option to copy this single file, even if
        //  the job is a non-copy job.  An exception: if we've determined that
        //  the job is non-copy (because the source and destination are the
        //  same), but the user's marked it as copy, we'll do an in-place copy
        //  without telling the user what we did.
        //

        bNoCopyFile = bNoCopyJob || bOnSharedDir;

        if( bNoCopyFile && bIsCompressed( szSelPath ) )
        {
            if( bNoCopyJob )
            {
                iReply = iUIMsgYesNoExclaim(hwndProgress, IDSI_FMT_COMPRFILE, szLHS );

                if( iReply != IDYES )
                    goto ReplyPoint;
            }
            bNoCopyFile = FALSE;
        }

#ifdef WINNT

        if( bNoCopyFile && (OurData.wFontType == NOT_TT_OR_T1)
            && !bOnSharedDir )
            bNoCopyFile = FALSE;

#else

        if( bNoCopyFile && !bTrueType && !bOnSharedDir
             && ( GetModuleHandle( szSelFile ) != NULL ) )
            bNoCopyFile = FALSE;

#endif  //  WINNT

        //
        //  If we're not copying the file, just make sure the font
        //  file path is copied to szFontPath so the font can be installed
        //  in the call to bInstallFont( ).
        //

        if( bNoCopyFile )
        {
            lstrcpy(szFontPath, szSelPath);
        }
        else
        {
            //
            //  The file name might be from a compressed file, so we use LZ to
            //  get the true complete path. From this, we re-extract the name
            //  portion, which we'll use from here on as the file name.
            //
            //  If GetExpandedName() fails, try to use the original path name.
            //

            if( ERROR_SUCCESS != IGetExpandedName( szSelPath, szTruePath, ARRAYSIZE(szSelPath)))
                lstrcpy( szTruePath, szSelPath );

            lstrcpy( szDstFile, lpNamePart( szTruePath ) );

            //
            //  Use this true file name to make a unique path name on the
            //  shared directory
            //

            if( !(bUniqueOnSharedDir( szDstFile, szDstFile ) ) )
            {
                iReply = iUIMsgOkCancelExclaim(hwndProgress, IDSI_FMT_BADINSTALL,
                                                IDSI_CAP_NOCREATE, szLHS );
                goto ReplyPoint;
            }

            //
            //  Finally, we're ready to install the file.  Note that we start
            //  with the original file name and directory. Our destination is
            //  the one we've constructed, on the shared directory.
            //

            if( bCPInstallFile( hwndProgress, szInDirCopy, szSelFile, szDstFile ) )
                vPathOnSharedDir( szDstFile, szFontPath );
            else
                goto ReplyPoint;

            Progress2( 50, szLHS );
        }

        //
        //  Install the font (as opposed to the file), if successful we note
        //  that at least one font's been installed.  If there is a problem,
        //  we need to clean up whatever we did before this attempt - most
        //  notably installing above.
        //
        if( bInstallFont(hwndProgress, szFontPath, bTrueType, szLHS, &iReply ) )
            bFontsInstalled = TRUE;
        else if( !bNoCopyFile )
            vCPDeleteFromSharedDir( szDstFile );

        //
        //  If we copied a file that was in the fonts directory, then delete
        //  the source. This will happen in the case of multi-floppy installs.
        //

        if( !bNoCopyFile && bOnSharedDir )
            vCPDeleteFromSharedDir( szSelPath );

        Progress2( 100, szLHS );

        //
        //  Here's where we jump on any diagnostics.  If the user wanted us
        //  to cancel, we return immediately.
        //

ReplyPoint:
        if( iReply == IDCANCEL )
            goto OperationCancelled;


FinishType1Install:

NextSelection:

        if (SUCCEEDED(GetFontManager(&poFontManager)))
        {
            poFontManager->bReleaseInstallationMutex();
            bOwnInstallationMutex = FALSE;
            ReleaseFontManager(&poFontManager);
        }
    }  // While selected desc

    //
    //  Update the overall progress dialog - show a 100% message
    //

    UpdateProgress( iTotalFonts, iTotalFonts, 100 );

    Sleep( 1000 );

//
// Don't update progress indicator if user cancelled out of operation.
//
OperationCancelled:

    TermProgress( );
    TermPSInstall( );

    if (SUCCEEDED(GetFontManager(&poFontManager)))
    {
        if (bOwnInstallationMutex)
        {
            poFontManager->bReleaseInstallationMutex();
        }
        ReleaseFontManager(&poFontManager);
    }

    return bFontsInstalled;
}


/***************************************************************************
 * FUNCTION:   bInstallFont
 *
 * PURPOSE:    Install the font specified by the inputs.  The reply parameter
 *             specifies how, in the event of failure, the user wishes to
 *             proceeed.
 *
 * RETURNS:    BOOL - success of attempt.
 ***************************************************************************/

BOOL NEAR PASCAL bInstallFont( HWND hwndParent,
                               LPTSTR lpszSrcPath,
                               BOOL   bTrueType,
                               PTSTR  szLHS,
                               int*   iReply )
{
    LPTSTR          lpszResource;
    FullPathName_t  szFullPath;
    FullPathName_t  szFontsDir;
    LPTSTR          lpszName;
    BOOL            bSuccess = FALSE;
    BOOL            bInFontsDir = FALSE;


    //
    //  Determine if this file is in the FONTS directory.
    //

    lstrcpy( szFullPath, lpszSrcPath );

    lpszName = lpNamePart( szFullPath );

    if( lpszName == szFullPath )
    {
        bInFontsDir = TRUE;
    }
    else
    {
        *(lpszName-1) = 0;

        GetFontsDirectory( szFontsDir, ARRAYSIZE( szFontsDir ) );

        if( !lstrcmpi( szFontsDir, szFullPath ) )
        {
           bInFontsDir = TRUE;
        }
    }

    //
    //  If it is a TrueType font, the input file will be the TTF.
    //  Generate the corresponding *.FOT file
    //

    if( bInFontsDir )
        lpszResource = lpszName;
    else
        lpszResource = lpszSrcPath;


    //
    //  Add the font resource, and then add the font record to our list.
    //  If these both succeed, we've finally reached the ultimate return point.
    //

    if( AddFontResource( lpszResource ) )
    {
        CFontManager *poFontManager;
        if (SUCCEEDED(GetFontManager(&poFontManager)))
        {
            if(poFontManager->poAddToList(szLHS, lpszResource, NULL) != NULL )
            {
                // WriteProfileString( szINISFonts, szLHS, lpszResource );
                WriteToRegistry( szLHS, lpszResource );
                bSuccess = TRUE;
            }
            ReleaseFontManager(&poFontManager);
            return bSuccess;
        }
        else
        {
            //
            //  Clear if we couldn't add
            //
            RemoveFontResource( lpszResource );
        }
    }
#ifdef _DEBUG
    else
        DEBUGMSG( (DM_ERROR, TEXT( "AddFontResource failed on %s" ),
                   lpszResource ) );
#endif

    //
    //  If we've failed in the final stages, report to the user.  We also
    //  need to clean up any file we've created.
    //

    if( bInFontsDir )
        vCPDeleteFromSharedDir( lpszSrcPath );

    *iReply = iUIMsgOkCancelExclaim(hwndParent, IDSI_FMT_BADINSTALL, IDSI_CAP_NOINSTALL,
                                     szLHS );

    return bSuccess;
}


BOOL HitTestDlgItem(int x, int y, HWND hwndItem)
{
    const POINT pt = { x, y };
    RECT rc;
    GetWindowRect(hwndItem, &rc);
    return PtInRect(&rc, pt);
}


/*************************************************************************
 * FUNCTION: FontHookProc
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/
UINT_PTR CALLBACK FontHookProc( HWND hWnd,
                                UINT iMessage,
                                WPARAM wParam,
                                LPARAM lParam )
{
    switch( iMessage )
    {

    case WM_INITDIALOG:
        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: ------------ WM_INITDIALOG " ) ) );

        s_pDlgAddFonts->Attach( hWnd );

        s_pDlgAddFonts->m_pOpen = (LPOPENFILENAME) lParam;

        s_pDlgAddFonts->CheckDlgButton( ID_BTN_COPYFILES, TRUE );

        s_pDlgAddFonts->vStartFonts( );

        SetFocus( s_pDlgAddFonts->GetDlgItem( IDOK ) );
        break;

    case WM_DESTROY:
        s_pDlgAddFonts->Detach( );
        break;

    case WM_HELP:
        if (IsWindowEnabled(hWnd))
        {
            LPHELPINFO lphi = (LPHELPINFO)lParam;
            if (HELPINFO_WINDOW == lphi->iContextType)
            {
                for (int i = 0; 0 != rgHelpIDs[i]; i += 2)
                {
                    if (lphi->iCtrlId == (int)rgHelpIDs[i])
                    {
                        //
                        // Only display custom help when necessary.
                        // Otherwise, use standard "file open dlg" help.
                        //
                        WinHelp( (HWND)lphi->hItemHandle,
                                 TEXT("fonts.hlp"),
                                 HELP_WM_HELP,
                                 (DWORD_PTR)(LPVOID)rgHelpIDs);

                        return TRUE;
                    }
                }
            }
        }
        break;

    case WM_CONTEXTMENU:
         {
            const x = GET_X_LPARAM(lParam);
            const y = GET_Y_LPARAM(lParam);
            for (int i = 0; 0 != rgHelpIDs[i]; i += 2)
            {
                HWND hwndItem = GetDlgItem(hWnd, rgHelpIDs[i]);
                //
                // This hit test shouldn't be required.  For some reason
                // wParam is the HWND of the dialog whenever the user 
                // right-clicks on some of our template controls.  I can't
                // figure it out but the hit test adjusts for the problem.
                // [brianau - 6/8/99]
                // 
                if ((HWND)wParam == hwndItem || HitTestDlgItem(x, y, hwndItem))
                {
                    //
                    // Only display custom help when necessary.
                    // Otherwise, use standard "file open dlg" help.
                    //
                    WinHelp( (HWND)wParam,
                              TEXT("fonts.hlp"),
                              HELP_CONTEXTMENU,
                              (DWORD_PTR)(LPVOID)rgHelpIDs);
                              
                    return TRUE;
                }                 
            }
        }
        break;

    case WM_COMMAND:
        switch( GET_WM_COMMAND_ID( wParam, lParam ) )
        {
        //
        //  command switch
        //
        case IDM_IDLE:
            vCPFilesToDescs( );
            break;

        case ID_BTN_SELALL:
            //
            //  select all
            //
            s_pDlgAddFonts->pListBoxDesc()->SetSel( -1, TRUE );
            break;

        case ID_BTN_HELP:
            WinHelp( hWnd, TEXT( "WINDOWS.HLP>PROC4" ), HELP_CONTEXT,
                     IDH_WINDOWS_FONTS_ADDNEW_31HELP );
            break;

        case ID_LB_FONTDIRS:
            if( GET_WM_COMMAND_CMD( wParam, lParam ) == LBN_DBLCLK )
                s_pDlgAddFonts->vStartFonts( );
            break;

        case IDOK:
            if( s_pDlgAddFonts->pListBoxDesc()->GetSelCount() > 0 )
                s_pDlgAddFonts->vAddSelFonts( );
            else
                s_pDlgAddFonts->vStartFonts();

            break;

        case IDCANCEL:
        case IDABORT:
            ResetAtomInDescLB( s_pDlgAddFonts->pListBoxDesc()->hWnd() );
            s_pDlgAddFonts->EndDialog( 0 );
            break;

        case ID_LB_ADD:
            // if( HIWORD( lParam ) == LBN_DBLCLK )

            if( GET_WM_COMMAND_CMD( wParam,lParam ) == LBN_DBLCLK )
                s_pDlgAddFonts->vAddSelFonts( );
            break;

        case ID_CB_FONTDISK:
            switch( GET_WM_COMMAND_CMD( wParam, lParam ) )
            {
            //
            //  Switch on combo parameter
            //

            case CBN_DROPDOWN:
                s_pDlgAddFonts->vHoldComboSel();
                break;

            case CBN_CLOSEUP:
                s_pDlgAddFonts->vCloseCombo( );
                break;

            case CBN_SELCHANGE:
                s_pDlgAddFonts->vNewComboSel( );
                break;
           }  // Switch on combo parameter
           break;

        } // command switch
        break;

    default:
        if( iMessage == s_iLBSelChange )
        {
            switch( wParam )
            {
            case ID_CB_FONTDISK:
                switch( HIWORD( lParam ) )
                {
                case CD_LBSELCHANGE:
                    //
                    //  This catches the DriveNotReady case
                    //  This code is hit once before WM_INITDIALOG is handled.
                    //  The check for a valid hWnd prevents a DEBUGBREAK in
                    //  dwThreadProc.
                    //

                    if (NULL != s_pDlgAddFonts->hWnd())
                        s_pDlgAddFonts->vStartFonts( );
                    break;
                }
#ifdef WINNT
                //
                // Fall through...
                // We want to capture current directory list selection
                // if either directory or drive changes.
                //
            case ID_LB_FONTDIRS:
               if (HIWORD(lParam) == CD_LBSELCHANGE)
               {
                  int cch     = 0;            // Index into s_szCurDir.
                  int iDirNew = 0;            // Id of directory item open in listbox.
                  BOOL bBufOverflow = FALSE;  // Buffer overflow indicator.

                  //
                  // Build current path selected in directory list box.
                  // We save this path in s_szCurDir so that if the FileOpen dialog is closed and
                  // re-opened, it will start navigating where it last left off.
                  // This path-building code was taken from the common dialog module fileopen.c
                  // The buffer overflow protection was added.
                  //
                  iDirNew = (DWORD)SendMessage( GetDlgItem(hWnd, ID_LB_FONTDIRS), LB_GETCURSEL, 0, 0L );
                  cch = (int)SendMessage(GetDlgItem(hWnd, ID_LB_FONTDIRS), LB_GETTEXT, 0, (LPARAM)(LPTSTR)s_szCurDir);

                  if (DBL_BSLASH(s_szCurDir))
                  {
                      lstrcat(s_szCurDir, TEXT("\\"));
                      cch++;
                  }

                  for (int idir = 1; !bBufOverflow && idir <= iDirNew; ++idir)
                  {
                      TCHAR szTemp[MAX_PATH + 1]; // Temp buf for directory name.
                      int n = 0;                  // Chars in directory name.

                      n = (int)SendDlgItemMessage(
                                    hWnd,
                                    ID_LB_FONTDIRS,
                                    LB_GETTEXT,
                                    (WPARAM)idir,
                                    (LPARAM)szTemp );

                      //
                      // Check if this directory name will overflow s_szCurDir.
                      //
                      if (cch + n < ARRAYSIZE(s_szCurDir))
                      {
                          //
                          // We have enough space for this directory name.
                          // Append it to s_szCurDir, advance the buffer index and
                          // append a backslash.
                          //
                          lstrcpy(&s_szCurDir[cch], szTemp);
                          cch += n;
                          s_szCurDir[cch++] = CHAR_BSLASH;
                      }
                      else
                          bBufOverflow = TRUE;  // This will terminate the loop.
                                                // s_szCurDir will still contain
                                                // a valid path.  It will just
                                                // be shy 1 or more directories.
                  }

                  //
                  // All done.  Terminate it.
                  // Note that this wipes out the final trailing backslash.
                  //
                  if (iDirNew)
                  {
                      s_szCurDir[cch - 1] = CHAR_NULL;
                  }
               }
#endif
               break;
            }
         }
         break;
    } // message switch

    //
    //  commdlg, do your thing
    //

    return FALSE;
}


/***************************************************************************
 * FUNCTION:   vCPDeleteFromSharedDir
 *
 * PURPOSE:    Delete the input file from the shared directory - a cleanup
 *             function for our installation attempts
 *
 * RETURNS:    None
 ***************************************************************************/

VOID FAR PASCAL vCPDeleteFromSharedDir( LPTSTR lpszFileOnly )
{
    FullPathName_t szTempPath;


    vPathOnSharedDir( lpNamePart( lpszFileOnly ), szTempPath );

    DeleteFile( szTempPath );
}


/***************************************************************************
 * FUNCTION:   vCPFilesToDescs
 *
 * PURPOSE:    We're during idle here, so try to convert at least one item
 *             from the selected file list to the description list (which is
 *             the one the user can see)
 *
 * RETURNS:    None
 ***************************************************************************/

VOID FAR PASCAL vCPFilesToDescs( )
{
    TCHAR          szNoFonts[ 80 ];
    BOOL           bSomeDesc;
    int            nDescSlot;
    AddITEMDATA    OurData;
    FullPathName_t szFilePath;
    FontDesc_t     szDesc;
    CListBox*      pListDesc;
    CListBox*      pListFiles;
    MSG            msg;


    if( !s_pDlgAddFonts || !s_pDlgAddFonts->m_nFontsToGo )
        return;

    pListFiles = s_pDlgAddFonts->pListBoxFiles( );
    pListDesc  = s_pDlgAddFonts->pListBoxDesc( );

    if( s_pDlgAddFonts->bStartState( ) )
    {
        //
        //  Reset the atoms that are in here.
        //

        ResetAtomInDescLB( pListDesc->hWnd( ) );

        //
        //  Make sure our focus isn't off in some weird place - force it
        //  to our directory list
        //

        HWND hFocus = ::GetFocus( );

        int iFocusID;


        if( hFocus != NULL )
            iFocusID = ::GetDlgCtrlID( hFocus );
        else
            iFocusID = ID_LB_ADD;

        if( ( iFocusID == (ID_LB_ADD) ) || (iFocusID == (ID_SS_PCT) ) )
        {
            ::SendMessage( s_pDlgAddFonts->hWnd( ), WM_NEXTDLGCTL,
            (WPARAM)GetDlgItem( s_pDlgAddFonts->hWnd( ), ID_LB_FONTDIRS ), 1L );
        }

        pListDesc->ResetContent( );
        pListDesc->UpdateWindow( );

        s_pDlgAddFonts->vUpdatePctText( );

        if( !s_pDlgAddFonts->bInitialFonts( ) )
        {
            bSomeDesc = FALSE;
            goto Done;
        }

        pListDesc->SetRedraw( FALSE );

        //
        //  DBCS. The first time through, look for oemsetup.inf
        //

        {
        int        nFileIndex;
        WORD       wRet;
        ADDFNT     stData;
        TCHAR      szInfFile[ MAXFILE ];
        FontDesc_t szTemp;

        if( FindOemInList( pListFiles, s_pDlgAddFonts->m_nFontsToGo,
                           &nFileIndex, szInfFile ) )
        {
            //
            //  save original path to setup.inf
            //

            lstrcpy( szTemp, szSetupInfPath );

            //
            //  get dir of oemsetup.inf
            //

            GetCurrentDirectory( ARRAYSIZE( szSetupInfPath ), szSetupInfPath );

            lpCPBackSlashTerm( szSetupInfPath );
            lstrcat( szSetupInfPath, szInfFile );

            stData.poListDesc = pListDesc;
            stData.nIndex     = nFileIndex;
            stData.which      = WHICH_FNT_WIFE;

            if( ( wRet = ReadSetupInfCB( szSetupInfPath, WIFEFONT_SECTION,
                    (LPSETUPINFPROC) GetNextFontFromInf, &stData ) ) != NULL )
            {
                //
                //  didn't reach to the end of section
                //

                if( wRet == INSTALL+14 )
                    //
                    //  didn't find the section
                    //
                    goto ScanTTInf;
            }
            else
            {
ScanTTInf:
                stData.which = WHICH_FNT_TT;

                wRet = ReadSetupInfCB( szSetupInfPath, TRUETYPE_SECTION,
                                       (LPSETUPINFPROC) GetNextFontFromInf,
                                       &stData );
            }

            //
            //  reset setupinf path global
            //

            lstrcpy( szSetupInfPath,szTemp );

            if( wRet && wRet != INSTALL+14 )
            {
                //
                //  Found the section, but invalid format
                //

                bSomeDesc = FALSE;
                goto Done;
            }
        }
        } // End of DBCS section.
    }

    //
    //  We want to read at least one
    //

    goto ReadNext;

    for(  ; s_pDlgAddFonts->m_nFontsToGo; )
    {
        if( PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE ) )
            return;

ReadNext:

        s_pDlgAddFonts->m_nFontsToGo--;
        s_pDlgAddFonts->vUpdatePctText( );

        OurData.nFileSlot = (WORD)s_pDlgAddFonts->m_nFontsToGo;

        if( pListFiles->GetText( OurData.nFileSlot, szFilePath ) == LB_ERR )
            continue;

        WORD  wType;

        DEBUGMSG( (DM_TRACE1, TEXT( "Checking file: %s" ), szFilePath ) );

        if( !::bCPValidFontFile( szFilePath, szDesc, &wType ) )
        {
            DEBUGMSG( (DM_TRACE1, TEXT( "......Invalid" ) ) );
            continue;
        }

        DEBUGMSG( (DM_TRACE1, TEXT( "......Valid.   Desc: %s" ), szDesc) );

        OurData.wFontType = wType;

        //
        //  See if there's already an entry for this font name - if so, don't
        //  add it again.  If there isn't, go ahead and add, setting our
        //  item data block.
        //

        if( pListDesc->FindStringExact( -1, szDesc ) == LB_ERR )
        {
            nDescSlot = pListDesc->AddString( szDesc );

            if( nDescSlot != LB_ERR )
                pListDesc->SetItemData( nDescSlot, OurData.ItemData );
            else
            {
                DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: Error adding string %s" ),
                           szDesc ) );
                // DEBUGBREAK;
            }
        }
        else
            DEBUGMSG( (DM_TRACE1,TEXT( "String %s already in list" ), szDesc ) );

    }

    s_pDlgAddFonts->vUpdatePctText( );

    bSomeDesc = (pListDesc->GetCount( ) > 0 );

    DEBUGMSG( (DM_TRACE1,TEXT( "Count in ListDesc: %d" ), pListDesc->GetCount( ) ) );
//  DEBUGBREAK;

Done:

    if( !bSomeDesc )
    {
        //
        //  cszNoFonts.LoadString( IDSI_MSG_NOFONTS );
        //

        LoadString( g_hInst, IDSI_MSG_NOFONTS, szNoFonts, ARRAYSIZE( szNoFonts ) );

        pListDesc->AddString( szNoFonts );
    }

    //
    //  Get everything back to the correct state before exiting.
    //  We can select all if we've got at least one item in the description
    //  list box.  Likewise, we can select from the list box itself.
    //  Re-enable redrawing of the box and invalidate to force a redraw.
    //

    // s_pDlgAddFonts->GetDlgItem( ID_BTN_SELALL )->EnableWindow( bSomeDesc );

    ::EnableWindow( s_pDlgAddFonts->GetDlgItem( ID_BTN_SELALL ), bSomeDesc );

    pListDesc->EnableWindow( bSomeDesc );

    pListDesc->SetRedraw( TRUE );

    pListDesc->InvalidateRect( NULL, TRUE );

    pListDesc->UpdateWindow( );
}


/*************************************************************************
 * FUNCTION: CPDropInstall
 *
 * PURPOSE:
 *          iCount - Number of fonts left to install, NOT counting this one
 *
 *
 * RETURNS:
 *
 *************************************************************************/

int FAR PASCAL CPDropInstall( HWND hwndParent,
                              LPTSTR lpszInPath,
                              DWORD  dwEffect ,
                              LPTSTR lpszDestName,
                              int    iCount )
{
    FullPathName_t szTruePath;
    FullPathName_t szFontPath;
    FullPathName_t szSourceDir;
    FILENAME       szInFile;
    FILENAME       szDstFile;
    FontDesc_t     szLHS;
    LPTSTR         lpCh;
    int            iReply;
    WORD           wType;
    BOOL           bTrueType;
    int            iReturn = CPDI_FAIL;
    BOOL           bNoCopyFile;
    UINT           uMB = ( (iCount > 0) ? (MB_OKCANCEL | MB_ICONEXCLAMATION)
                                      : MB_OK | MB_ICONEXCLAMATION );
    DWORD          dwStatus = FVS_MAKE_CODE(FVS_INVALID_STATUS, FVS_FILE_UNK);

    static BOOL s_bInit = FALSE;
    static int  s_iTotal = 1;

    BOOL bOwnInstallationMutex = FALSE;
    HWND hwndProgress = NULL;
    CFontManager *poFontManager = NULL;

    vEnsureInit( );

    //
    //  Init Type1 font installation and Progress dialog
    //

    if( !s_bInit )
    {
        InitPSInstall( );
        hwndProgress = InitProgress( hwndParent );

        s_iTotal = ( iCount > 0 ) ? ( iCount + 1 ) : 1;

        s_bInit = TRUE;


    }

    GetFontManager(&poFontManager);
    
    //
    // Must own installation mutex to install font.
    //
    if ( NULL != poFontManager )
    {
        INT iUserResponse  = IDRETRY;
        DWORD dwWaitResult = CFontManager::MUTEXWAIT_SUCCESS;

        while( IDRETRY == iUserResponse &&
               (dwWaitResult = poFontManager->dwWaitForInstallationMutex()) != CFontManager::MUTEXWAIT_SUCCESS )
        {
            if ( CFontManager::MUTEXWAIT_WMQUIT != dwWaitResult )
                iUserResponse = iUIMsgRetryCancelExclaim(hwndProgress, IDS_INSTALL_MUTEX_WAIT_FAILED, NULL);
            else
            {
                //
                // Cancel if thread received a WM_QUIT message while waiting.
                //
                iUserResponse = IDCANCEL;
            }
        }

        //
        // If user chose to cancel or we got a WM_QUIT msg, cancel the installation.
        //
        if ( IDCANCEL == iUserResponse )
        {
            iReturn = CPDI_CANCEL;
            goto done;
        }

        bOwnInstallationMutex = TRUE;
    }


    //
    // Update the font number in the progress dialog.
    // Leave the % complete unchanged.
    //
    UpdateProgress( s_iTotal, s_iTotal - iCount,
                  (s_iTotal - iCount - 1) * 100 / s_iTotal );


    //
    //  If this is a type1 font, then convert it and install the resulting
    //  TrueType file.
    //

    // BGK - Add copy/nocopy w/compress here

    bNoCopyFile = (dwEffect == DROPEFFECT_LINK );

    if( !::bCPValidFontFile( lpszInPath, szLHS, &wType, FALSE, &dwStatus ) )
    {
        //
        // Display message informing user that font file is invalid and why.
        // Abort the installation of this font if user pressed Cancel.
        //
        lstrcpy( szFontPath, lpszInPath );
        if (iUIMsgBoxInvalidFont(hwndProgress, szFontPath, szLHS, dwStatus) == IDCANCEL)
            iReturn = CPDI_CANCEL;
    }
    else if( bFontInstalledNow( szLHS ) )
    {
        if( iUIMsgBox(hwndProgress, IDSI_FMT_ISINSTALLED, IDS_MSG_CAPTION, uMB, szLHS )
                     == IDCANCEL )
        {
            iReturn = CPDI_CANCEL;
        }

    }
    else
    {
        bTrueType = (wType == TRUETYPE_FONT);

        vUIPStatusShow( IDS_FMT_FONTINS, szLHS );

        BOOL    bUpdateWinIni;
        int     ifType;


        if( (wType == TYPE1_FONT) || (wType == TYPE1_FONT_NC) )
        {
            //
            //  For installations involving the conversion of the Type1
            //  font to TrueType:
            //
            //         "lpszInPath" has the destination name of the
            //                      installed TrueType font file.
            //         "szLHS"      is munged to contain "(TrueType)".
            //

            switch( ::InstallT1Font( hwndProgress,
                                     !bNoCopyFile,    //  Copy TT file?
                                     TRUE,            //  Copy PFM/PFB files?
                                     FALSE,           //  Files in Shared Dir?
                                     lpszInPath,      //  IN:  PFM File & Dir
                                                      //  OUT: TTF File & Dir
                                     szLHS ) )        //  IN & OUT: Font desc
            {
            case TYPE1_INSTALL_TT_AND_MPS:
                //
                //  The PS font was converted to TrueType and a matching
                //  PostScript font is ALREADY installed.
                //
                // bDeletePSEntry = TRUE;
                //
                //  fall thru....

            case TYPE1_INSTALL_TT_AND_PS:
                //
                //  The PS font was converted to TrueType and the matching
                //  PostScript font was installed.
                //

                ifType = IF_TYPE1_TT;

                //
                //  fall thru....

            case TYPE1_INSTALL_TT_ONLY:
                //
                //
                //  The PS font was converted to TrueType and the matching
                //  PostScript font was NOT installed and a matching PS
                //  font was NOT found.
                //
                //  Setup variables to finish installation of converted
                //  TrueType font file.
                //
                //  NOTE:  In this case "ifType" already equals IF_OTHER
                //

                bUpdateWinIni =
                bTrueType = TRUE;

                iReturn = CPDI_SUCCESS;

                goto FinishTTInstall;


            case TYPE1_INSTALL_PS_AND_MTT:
                //
                //  The PostScript font was installed and we found a matching
                //  TrueType font that was already installed.
                //
                //  fall thru....

            case TYPE1_INSTALL_PS_ONLY:
                //
                //  Only the PostScript font was installed.
                //

                bUpdateWinIni = FALSE;
                iReturn = CPDI_SUCCESS;

                goto done;

            case TYPE1_INSTALL_IDYES:
            case TYPE1_INSTALL_IDOK:

                bUpdateWinIni = FALSE;
                iReturn = CPDI_SUCCESS;
                goto done;

            case TYPE1_INSTALL_IDNO:
                //
                //  The font was not installed, but the User wanted to
                //  continue installation.  Continue installation with
                //  the next font.
                //
                //  The font was not installed due to an error somewhere
                //  and the User pressed OK in the MessageBox
                //
                //  OR
                //
                //  The User selected NO in the InstallPSDlg routine.
                //

                bUpdateWinIni = FALSE;
                iReturn = CPDI_FAIL;
                goto done;

            case TYPE1_INSTALL_IDCANCEL:
            default:
                iReturn = CPDI_CANCEL;
                goto done;
            }

            //
            //  On leaving this conditional many variables must be set up
            //  correctly to proceed with installation of a TrueType font.
            //
            //  szLHS         - fontname description for listbox display
            //  ifType        - itemdata to attach to TT lbox entry
            //  lpszInPath    - filename of source font
            //  bTrueType     - TRUE if Type1 file converted to TT
            //

FinishTTInstall:

            //
            //  Determine if TTF file to install is in 'fonts' dir
            //

            lstrcpy( szFontPath, lpszInPath );


            LPTSTR lpCh = StrRChr( szFontPath, NULL, TEXT( '\\' ) );

            if( lpCh )
            {
                lpCh++;
                *lpCh = TEXT( '\0' );
            }

            bNoCopyFile = lstrcmpi( szFontPath, s_szSharedDir ) == 0;
        }

        //
        //  Start install progress for this font
        //

        ResetProgress( );
        Progress2( 0, szLHS );

        //
        //  If the file is compressed, then do a copy.
        //

        if( bIsCompressed( lpszInPath ) )
        {
            dwEffect = DROPEFFECT_COPY;
            bNoCopyFile = FALSE;
        }

        if( bNoCopyFile )
        {
            //
            //  If we're not copying the file, just make sure the font
            //  file path is copied to szFontPath so the font can be installed
            //  in the call to bInstallFont( ).
            //
            lstrcpy(szFontPath, lpszInPath);
        }
        else
        {
            //
            //  Before monkeying around with the name strings, grab the source
            //  directory, including the terminating slash.  Also hold the file
            //  portion.
            //

            //
            //  Copy in name only
            //

            lstrcpy( szInFile, lpNamePart( lpszInPath ) );

            lstrcpy( szSourceDir, lpszInPath );

            //
            //  Get past any path
            //

            lpCh  = StrRChr( szSourceDir, NULL, TEXT( '\\' ) );

            lpCh++;
            *lpCh = 0;

            //
            //  Let LZ tell us what the name should have been
            //

            if( ERROR_SUCCESS != IGetExpandedName( lpszInPath, szTruePath, PATHMAX ))
            {
                //
                //  GetExpanded failed. This usually means we can't get at
                //  the file for some reason.
                //

                iUIMsgOkCancelExclaim(hwndProgress, IDSI_FMT_BADINSTALL,
                                       IDSI_CAP_NOCREATE, szLHS );
                goto done;
            }

            //
            //  Now we're going to work on making the new file name - it's
            //  file only, and we'll tweak for uniqueness
            //

            if( lpszDestName && *lpszDestName )
            {
                lstrcpy( szDstFile, lpszDestName );
            }
            else
            {
                //
                //  Copy in name only
                //

                lstrcpy( szDstFile, lpNamePart( szTruePath ) );
            }

            if( !(bUniqueOnSharedDir( szDstFile, szDstFile ) ) )
            {
                iUIMsgOkCancelExclaim(hwndProgress, IDSI_FMT_BADINSTALL,
                                       IDSI_CAP_NOCREATE, szLHS );
                goto done;
            }

            //
            //  Ready to install the file
            //

            if( iReturn = (bCPInstallFile( hwndProgress, szSourceDir, szInFile, szDstFile )
                                        ? CPDI_SUCCESS : CPDI_FAIL ) )
            {
                vPathOnSharedDir( szDstFile, szFontPath );
            }
            else
                goto done;

            Progress2( 50, szLHS );

        }

        if( bInstallFont( hwndProgress, szFontPath, bTrueType, szLHS, &iReply ) )
        {
            iReturn = CPDI_SUCCESS;

            //
            //  Attempt to remove the source file, if the operation was
            //  a MOVE.
            //
            //  EXCEPTION: If we're doing a Type1 font installation, the name
            //  in lpszInPath buffer is the path to the matching TrueType font
            //  file created. If this is the case, do not delete it.
            //
            if( (wType != TYPE1_FONT) && (wType != TYPE1_FONT_NC) &&
                (dwEffect == DROPEFFECT_MOVE) )
            {
                //
                // SHFileOperation requires that file list be double-nul
                // terminated.
                //
                *(lpszInPath + lstrlen(lpszInPath) + 1) = TEXT('\0');

                SHFILEOPSTRUCT sFileOp = { NULL,
                                           FO_DELETE,
                                           lpszInPath,
                                           NULL,
                                           FOF_SILENT | FOF_NOCONFIRMATION,
                                           0,
                                           0
                                          };

                SHFileOperation( &sFileOp );
            }

            Progress2( 100, szLHS );
        }
        else if( !bNoCopyFile )
            vCPDeleteFromSharedDir( szDstFile );
    }

done:

    //
    //  Update the overall progress dialog
    //  Only update if user didn't cancel the operation.
    //
    if (CPDI_CANCEL != iReturn)
    {
        UpdateProgress( s_iTotal, s_iTotal - iCount,
                        (s_iTotal - iCount) * 100 / s_iTotal );
    }

    //
    //  If no more fonts coming down, properly terminate Progress
    //  dialog and reset local statics.  Also, give user time to
    //  to see this on a fast system (1 sec. delay).
    //
    if (InstallCancelled())
        iReturn = CPDI_CANCEL;

    if( s_bInit && (iCount == 0 || iReturn == CPDI_CANCEL) )
    {
        Sleep( 1000 );

        TermProgress( );
        TermPSInstall( );

        s_iTotal =  1;

        s_bInit = FALSE;
    }

    //
    // Release the installation mutex if we own it.
    //
    if ( NULL != poFontManager)
    {
        if (bOwnInstallationMutex)
            poFontManager->bReleaseInstallationMutex();

        ReleaseFontManager(&poFontManager);
    }
    return iReturn;
}


/*************************************************************************
 * FUNCTION: bCPAddFonts
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

BOOL FAR PASCAL bCPAddFonts( HWND ma )
{
    FullPathName_t  szWinDir;
    FullPathName_t  szFileTemp = { TEXT( '\0' ) };
    TCHAR           cFilter[ 80 ];
    TCHAR           szFilter[ 80 ];

    //
    //  Current directory we're using
    //  Moved s_szCurDir to file-scope so that it can be updated through
    //  FontHookProc. [brianau]
    //
    //  static FullPathName_t s_szCurDir;

    static BOOL           s_bFirst = TRUE;

    //
    //  This code is NOT REENTRANT!!!!.
    //  Make sure we don't.
    //

    if( s_pDlgAddFonts )
        return FALSE;

    // DEBUGBREAK;

    vEnsureInit( );

    //
    //  We start the current directory to be the windows directory - it will
    //  later remain as where the user last set it.
    //

    if( s_bFirst )
    {
        s_bFirst = FALSE;
        GetWindowsDirectory( s_szCurDir, ARRAYSIZE( s_szCurDir ) );
    }

    //
    //  Nothing added yet!
    //

    BOOL bFontsAdded = FALSE;

    //
    //  We need to set the font filter.  If TrueType is enabled, we use a
    //  filter that includes these files.  Otherwise, a simpler filter is
    //  used.  The filter has embedded nulls, which are stored in the
    //  resource file as hashes
    //

    if( GetProfileInt( szINISTrueType, szINIKEnable,1 ) )

       LoadString( g_hInst, IDS_MSG_ALLFILTER, cFilter, ARRAYSIZE( cFilter ) );

    else

       LoadString( g_hInst, IDS_MSG_NORMALFILTER, cFilter, ARRAYSIZE( cFilter ) );


    lstrcpy( szFilter, cFilter );

    vHashToNulls( szFilter );

    //
    //  Now we'll use the common open-file dialog to present the user with
    //  some choices on fonts to add
    //

    static OPENFILENAME OpenFileName;

    memset( &OpenFileName, 0, sizeof( OpenFileName ) );

    OpenFileName.lStructSize    = sizeof( OPENFILENAME );
    OpenFileName.hwndOwner      = ma;
    OpenFileName.hInstance      = g_hInst;
    OpenFileName.lpstrFilter    = szFilter;
    OpenFileName.nFilterIndex   = 1;
    OpenFileName.lpstrFile      = szFileTemp;
    OpenFileName.nMaxFile       = ARRAYSIZE( szFileTemp );
    OpenFileName.lpstrInitialDir= s_szCurDir;

    OpenFileName.Flags          = OFN_HIDEREADONLY   | OFN_ENABLEHOOK |
                                  OFN_ENABLETEMPLATE;
    OpenFileName.lpTemplateName = MAKEINTRESOURCE( ID_DLG_FONT2 );
    OpenFileName.lpfnHook       = FontHookProc;

    //
    //  This is our companion struture, which we handle independently
    //

    s_pDlgAddFonts = new AddFontsDialog;

    if(NULL == s_pDlgAddFonts)
    {
        DEBUGMSG( (DM_ERROR, TEXT( "AddFontsDialog not created." ) ) );

        // DEBUGBREAK;
        // FEATURE: Way low on memory. MessageBox?
        return FALSE;
    }

    if (!s_pDlgAddFonts->bInitialize())
    {
        DEBUGMSG( (DM_ERROR, TEXT( "AddFontsDialog initialization failed." ) ) );
        s_pDlgAddFonts->Release();
        s_pDlgAddFonts = NULL;

        return FALSE;
    }

    s_iLBSelChange = RegisterWindowMessage( LBSELCHSTRING );

//
//  Suspension of the file system notify thread is no longer required.
//  It has been superceded by the installation mutex in CFontManager.
//  See comment in header of CFontManager::iSuspendNotify() for details.
//
//    if( poFontMan )
//        poFontMan->iSuspendNotify( );

    GetOpenFileName( &OpenFileName );

//    if( poFontMan )
//        poFontMan->iResumeNotify( );

    bFontsAdded = s_pDlgAddFonts->bAdded( );

    s_pDlgAddFonts->EndThread(); // Stop the IDM_IDLE thread.
    s_pDlgAddFonts->Release();   // Decr ref count.
    s_pDlgAddFonts = NULL;       // Static ptr no longer used.

    //
    //  save the current dir so we can restore this
    //  Modified so current directory is saved in FontHookProc.
    //
    //  GetCurrentDirectory( ARRAYSIZE( s_szCurDir ), s_szCurDir );

    //
    //  set the current dir back to windows so we don't hit the floppy
    //

    GetWindowsDirectory( szWinDir, ARRAYSIZE( szWinDir ) );

    SetCurrentDirectory( szWinDir );

    return bFontsAdded > 0;
}


/*************************************************************************
 * FUNCTION: CopyTTOutlineWithInf
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

BOOL NEAR PASCAL CopyTTOutlineWithInf( HWND hwndFontDlg,
                                       LPTSTR pszInfSection,
                                       LPTSTR szDesc,
                                       LPTSTR szSrc,
                                       LPTSTR szDst )
{
    TCHAR szTemp[ PATHMAX ];
    TCHAR szDstName[ PATHMAX ];
    BOOL bInstalled = FALSE;
    LPTSTR lpTemp ;
    LPTSTR pszFiles[ 30 ];
    UINT   nFiles;
    DWORD  dwInstallFilesResult = 0;

#ifdef PROGRESS
    TCHAR szStatus[ 64 ];
#endif

    DEBUGMSG( (DM_TRACE1, TEXT( "CopyTTOutlineWithInf()" ) ) );
    DEBUGMSG( (DM_TRACE1, TEXT( "\tszDesc: %s" ), szDesc) );
    DEBUGMSG( (DM_TRACE1, TEXT( "\tszSrc: %s" ), szSrc) );
    DEBUGMSG( (DM_TRACE1, TEXT( "\tszDst: %s" ), szDst) );
    // DEBUGBREAK;

    //
    //  Set global window handle. used in InstallFiles to determine title of
    //  AddFile dialog.
    //

    ghwndFontDlg = hwndFontDlg; // s_pDlgAddFonts->hWnd( );

    //
    //  Get destination filename from line .
    //

    if( lpTemp = StrChr( pszInfSection, TEXT( '=' ) ) )
    {
        *lpTemp = TEXT( '\0' );

        //
        //  Got left of TEXT( '=' ).
        //

        lstrcpy( szSrc, pszInfSection );

        CutOffWhite( szSrc );

        DEBUGMSG( (DM_TRACE1, TEXT( "szSrc after CutOffWhite %s" ), szSrc) );

        pszInfSection = lpTemp + 1;
    }
    else
    {
        //
        //  Bad format inf file.
        //

        DEBUGMSG( (DM_TRACE1, TEXT( "Bad Format inf file: %s" ), pszInfSection) );

        bInstalled = FALSE;

        goto NoMoreFiles;
    }

    //
    //  Assume that existing check has been already done in AddFonts( ).
    //

    //
    //  Right side of TEXT( '=' ) can be shirink without any space.
    //

    CutOffWhite( pszInfSection );

    DEBUGMSG( (DM_TRACE1, TEXT( "pSection after CutOffWhite: %s" ), pszInfSection) );

    //
    //  Build up params for InstallFiles. Now we have pLine as x:name,y:name..
    //

    for(  nFiles = 0, lpTemp = pszInfSection; nFiles < 30; )
    {
        pszFiles[ nFiles ] = lpTemp;

        DEBUGMSG( (DM_TRACE1, TEXT( "File %d: %s" ), nFiles, lpTemp) );
        // DEBUGBREAK;

        nFiles++;

        //
        //  Null terminate each file name string
        //

        if( lpTemp = StrChr( lpTemp+1,TEXT( ',' ) ) )
        {
            *lpTemp ++ = TEXT( '\0' );
        }
        else
            //
            //  Reach end of line.
            //

            break;
    }

#ifdef PROGRESS
    if( hSetup && nFiles )
    {
        ProClear( NULL );

        LoadString( hInst, IDS_WAITCOPYFONT, szStatus, ARRAYSIZE( szStatus ) );

        ProSetText( ID_STATUS1, szStatus );

        LoadString( hInst, IDS_COPYING, szStatus, ARRAYSIZE( szStatus ) );

        ProPrintf( ID_STATUS2, szStatus, (LPTSTR) szDesc );

        LoadString( hInst, IDS_FILE, szStatus, ARRAYSIZE( szStatus ) );

        ProPrintf( ID_STATUS3, szStatus, (LPTSTR) szSrc );

        ProSetBarRange( nFiles );

        ProSetBarPos( 0 );

        if ((dwInstallFilesResult = InstallFiles(hwndFontDlg, pszFiles, nFiles,
                                        SuFontCopyStatus, IFF_CHECKINI)) != nFiles)
        {
            goto NoMoreFiles;
        }
        else
        {
            ProSetBarPos( 100 );
        }
    }
    else
#endif
    if ((dwInstallFilesResult = InstallFiles(hwndFontDlg, pszFiles, nFiles,
                                             NULL, IFF_CHECKINI)) != nFiles)
    {
        goto NoMoreFiles;
    }

    lstrcpy( szDstName, s_szSharedDir );

    lpCPBackSlashTerm( szDstName );

    lstrcat( szDstName, szSrc );


    //
    //  On success, return the place we installed the file.
    //

    lstrcpy( szDst, szDstName );

    //
    //  If source file was splited into multiple files, then we build up
    //  single destination file.
    //

    if(  nFiles  )
    {
        short nDisk;

        GetDiskAndFile( pszFiles[ 0 ], &nDisk, szTemp, ARRAYSIZE( szTemp ) );

        //
        //  Even when nFiles == 1, if the a source file name (we just copied)
        //  is different from the one of destination, we must copy it to
        //  actual destination file.
        //

        if(  lstrcmpi( szSrc, szTemp )  )

#ifdef PROGRESS
        {
            if( hSetup )
            {
                LoadString( hInst, IDS_CAT, szStatus, ARRAYSIZE( szStatus ) );
                ProSetText( ID_STATUS3, szStatus );
            }
            bInstalled = fnAppendSplitFiles( pszFiles, szDstName, nFiles );
        }
#else
        bInstalled = fnAppendSplitFiles( pszFiles, szDstName, nFiles );
#endif

    }

NoMoreFiles:

    //
    // If user aborted file installation, set return value so callers will
    // know this.  Callers look for ~01 value.
    //
    if ((DWORD)(-1) == dwInstallFilesResult)
        bInstalled = ~01;

    //
    //  If we didn't create the final dest file, make sure it is deleted.
    //

    if( !bInstalled )
    {
        vCPDeleteFromSharedDir( szDstName );
    }

    ghwndFontDlg = NULL;

    return bInstalled;
}

/*************************************************************************
 * FUNCTION: CopyTTFontWithInf
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

BOOL NEAR PASCAL CopyTTFontWithInf( HWND hwndFontDlg,
                                    LPTSTR szProfile,
                                    LPTSTR szDesc,
                                    LPTSTR szSrc,
                                    LPTSTR szDst )
{
    TCHAR   szSect[ MAX_FF_PROFILE_LEN+14 ];
    LPTSTR  pszInfSection = NULL;
    LPTSTR  lpch;
    BOOL    bRet = FALSE;

    lstrcpy( szSect, szProfile );

    //
    //  'outline' section
    //

    lstrcpy( (lpch = szSect + lstrlen( szProfile ) ),
              TEXT( ".outline" ) /* szTTInfOutline */);

    DEBUGMSG( (DM_TRACE1,TEXT( "CopyTTFontWithInf" ) ) );

    DEBUGMSG( (DM_TRACE1,TEXT( "\tszProfile: %s" ), szProfile ) );

    DEBUGMSG( (DM_TRACE1,TEXT( "\tszSect: %s" ), szSect ) );
    // DEBUGBREAK;

    ReadSetupInfSection(szSetupInfPath, szSect, &pszInfSection);

    if (NULL != pszInfSection)
    {
        if ((bRet = CopyTTOutlineWithInf(hwndFontDlg, pszInfSection, szDesc, szSrc, szDst)))
        {
            if (~01 == bRet)
            {
                //
                // User abort.
                //
                DEBUGMSG( (DM_ERROR, TEXT( "CopyTTFontWithInf: Return UserAbort!" ) ) );
            }
        }
        else
        {
            //
            //  Fail at installing outline font.
            //
            DEBUGMSG( (DM_ERROR, TEXT( "CopyTTFontWithInf: Error CopyTTOutlineWithInf" ) ) );
        }
        LocalFree(pszInfSection);
    }
    else
    {
        //
        //  Maybe .inf error.
        //
        DEBUGMSG( (DM_ERROR, TEXT( "CopyTTFontWithInf: Error ReadSetUpInf" ) ) );
    }

    return bRet;
}

/*************************************************************************
 * FUNCTION: bInstallOEMFile
 *
 *   LPTSTR lpszDir,      // the directory where this thing is.
 *   LPTSTR lpszDstName,  // Full path to oemsetup.inf on entry
 *   LPTSTR lpszDesc,     // Description of font.
 *   WORD   wFontType,
 *   WORD  wCount )
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/
BOOL bInstallOEMFile( LPTSTR lpszDir,
                      LPTSTR lpszDstName,
                      LPTSTR lpszDesc,
                      WORD   wFontType,
                      WORD  wCount )
{
    FullPathName_t szSrcName;
    TCHAR          szTag[ 80 ];

    static FullPathName_t  szOemInfPath;

    TCHAR   szTemp[ PATHMAX ];
    HANDLE  hSection = NULL;


    DEBUGMSG( (DM_TRACE1, TEXT( "bInstallOEMFile( %s, %s )" ), lpszDstName,
                                                               lpszDesc) );
    //
    //  DEBUGBREAK;
    //  copy .inf file into fonts directory
    //
    // Remember the source directory.
    //

    lstrcpy( szSrcName, lpszDstName );

    if(  wCount == 0 )
    {
        //
        //  Assume all of description are from same .inf when first one is.
        //

        if( !CopyNewOEMInfFile( lpszDstName ) )
        {
            //
            //  TODO. ui message of some sort.
            //
            return FALSE;
        }

        //
        //  lpszDestName now has the new location of the oemsetup.inf file.
        //

        lstrcpy( szOemInfPath, lpszDstName );

        DEBUGMSG( (DM_TRACE1,TEXT( "szOemInfPath: %s " ), szOemInfPath ) );

        //
        //  Let InstallFiles() to prompt correct directory.
        //

        lstrcpy( szSetupDir, lpszDir );
    }

    //
    //  Build oemsetup.inf path..
    //

    lstrcpy( szTemp, szSetupInfPath );

    lstrcpy( szSetupInfPath,szOemInfPath );

    if( wFontType > 0xC000 )
    {
        DEBUGMSG( (DM_TRACE1,TEXT( "Can't do a WIFE font, yet" ) ) );
        return FALSE;

        //
        // In this case, bTrueType is atom for tag string of wifefont.
        //

        if( GetAtomName( wFontType, szTag, ARRAYSIZE( szTag ) - 1 ) )
        {
#if 0 // EMR. We don't do WIFE, yet.

            //
            //  Build driver section string..
            //

            lstrcpy( FdDesc,szTag );

            lstrcat( FdDesc,szWifeInfDrivers );

            if( !(hSection = ReadSetupInf( FdDesc ) ) )
            {
               goto InfError;
            }

            if( !AddFontDrvFromInf( hwndFontDlg,hSection ) )
                  goto InfError;

            hSection = LocalFree( hSection );

            //
            //  Build fonts section string..
            //

            lstrcpy( FfDesc,szTag );

            lstrcat( FfDesc,szWifeInfFonts );

            if( !(hSection = ReadSetupInf( FfDesc ) ) )
            {
                  goto InfError;
            }

            if( !CopyWifeFontWithInf( hwndFontDlg, hSection,
                                      NULL, szSrcName, szDstName ) )
                  goto InfError;

            hSection = LocalFree( hSection );

            //
            //  We have already this in system directory.
            //

            bInShared = TRUE;

            //
            //  Actually this is not TrueType.
            //

            bTrueType = FALSE;
#endif
        }
        else
        {
            //
            // Bad condition..maybe mem error or something like that
            //
InfError:
            if( hSection )
               LocalFree( hSection );

            //
            //  Restore setup.inf path.
            //

            lstrcpy( szSetupInfPath, szTemp );

            DEBUGMSG( (DM_TRACE1, TEXT( "Error in OEM install" ) ) );
            // DEBUGBREAK;

#if 0
            - TODO: Need an error message here.

            MyMessageBox( hwndFontDlg, INSTALL+14, INITS+1,
                          MB_OK|MB_ICONEXCLAMATION ) ;
#endif
            return FALSE;
        }
    }
    else if( GetAtomName( wFontType | TRUETYPE_WITH_OEMINF,
                          szTag, ARRAYSIZE( szTag ) - 1 ) )
    {
        BOOL bRet;

        //
        //  When 1 < bTrueType < C000, it also must be an atom for tag string,
        // but it lost 'which bit' when the value was set into listbox.
        // Treat this case as TRUETYPE.
        //

        lstrcpy( szDirOfSrc, lpszDir );

        DEBUGMSG( (DM_TRACE1, TEXT( "Calling CopyTTFontWithInf()." ) ) );
        // DEBUGBREAK;

        if( !(bRet = CopyTTFontWithInf( s_pDlgAddFonts->hWnd(), szTag,
                                        lpszDesc, szSrcName, lpszDstName ) ) )
             goto InfError;

        //
        //  Check User Abort.
        //

        if( bRet == ~01 )
            return FALSE;

        // lstrcpy( lpszDir,lpszDstName );

    }

    //
    //  Restore setup.inf path.
    //

    lstrcpy( szSetupInfPath,szTemp );


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\builder.h ===
/***
 **
 **   Module: Builder
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contains functions that will write the tables found in a
 **    TrueType font file.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

#define PREPSIZE        1000
#define MAXNOTDEFSIZE   1024


/* Referenced types. */
struct TTArg;
struct TTHandle;


/* Argument types. */
struct TTGlyph {
   struct encoding *code;

   USHORT num;
   USHORT stack;
   USHORT twilights;
   UBYTE *hints;

   Outline *paths;

   funit aw;
   funit lsb;
};

struct TTComposite {
   struct encoding *aenc;
   struct encoding *benc;
   struct encoding *cenc;
   struct encoding *oenc;
   funit dx;
   funit dy;
   funit aw;
   funit lsb;
};

typedef struct {
   ULONG a;
   ULONG b;
} longdate;

struct TTMetrics {
   struct {
      USHORT ver;
      USHORT rev;
   } version;
   longdate created;
   char *family;
   char *copyright;
   char *name;
   char *id;
   char *notice;
   char *fullname;
   char *weight;
   char *verstr;
   f16d16 angle;
   funit underline;
   funit uthick;
   USHORT macStyle;
   USHORT usWeightClass;
   USHORT usWidthClass;
   USHORT fsSelection;

   /* True Typographical metrics. */
   funit typAscender;
   funit typDescender;
   funit typLinegap;
   Point superoff;
   Point supersize;
   Point suboff;
   Point subsize;
   funit strikeoff;
   funit strikesize;
   short isFixPitched; 

   /* Windows based metrics. */
   funit winAscender;
   funit winDescender;
   UBYTE panose[10];

   /* Mac based metrics. */
   funit macLinegap;

   funit emheight;
   USHORT FirstChar;
   USHORT LastChar;
   USHORT DefaultChar;
   USHORT BreakChar;
   USHORT CharSet;
   funit *widths;
   short *cvt;
   USHORT cvt_cnt;
   struct kerning *kerns;
   USHORT kernsize;

   /* Copy of the encoding table. */
   struct encoding *Encoding;
   USHORT encSize;

   /* Hint specific information. */
   const UBYTE *prep;      /* PreProgram. */
   USHORT prep_size;
   const UBYTE *fpgm;      /* FontProgram. */
   USHORT fpgm_size;
   USHORT maxstorage;
   USHORT maxprepstack;    /* Max stack depth in pre-program. */
   USHORT maxfpgm;         /* Max number of function in the font program. */
   USHORT onepix;          /* Treshold where stems become >= 1.0 pixles. */
};


/***
** Function: InitTTOutput
**
** Description:
**   This function allocates the resources needed to
**   write a TT font file.
***/
errcode  InitTTOutput      _ARGS((IN      struct TTArg *,
                                  OUT     struct TTHandle **));

/***
** Function: CleanUpTT
**
** Description:
**   This function free's the resources used while
**   writing a TT font file.
***/
errcode  CleanUpTT         _ARGS((INOUT   struct TTHandle *,
                                  IN      struct TTArg *,
                                  IN      errcode status));

/***
** Function: PutTTNotDefGlyph
**
** Description:
**   This function adds a record for a the ".notdef" glyph to the
**   'glyf' table of the TT font file.
**   
***/
errcode  PutTTNotDefGlyph        _ARGS((INOUT   struct TTHandle *,
                                        IN      struct TTGlyph*));


/** Function: PutTTGlyph
**
** Description:
**   This function adds a record for a simple glyph to the
**   'glyf' table of the TT font file.
**   
***/
errcode  PutTTGlyph        _ARGS((INOUT   struct TTHandle *,
                                  IN      struct TTGlyph*,
											 IN		boolean fStdEncoding));


/***
** Function: PutTTOther
**
** Description:
**   This function writes the required TT tables to the
**   TT font file, except for the 'glyf' table which is
**   only completed (check sum is computed, etc.).
**   
***/
errcode  PutTTOther        _ARGS((INOUT   struct TTHandle *,
                                  INOUT   struct TTMetrics *));

/***
** Function: FreeTTGlyph
**
** Description:
**   This function will free the memory used to represent a 
**   a TrueType glyph.
**   
***/
void     FreeTTGlyph       _ARGS((INOUT   struct TTGlyph *));


/***
** Function: PutTTComposite
**
** Description:
**   
***/
errcode  PutTTComposite    _ARGS((INOUT   struct TTHandle *,
                                  OUT     struct TTComposite *));

/***
** Function: WindowsBBox
**
** Description:
**   Compute the bounding box of the characters that are
**   used in Windows character set.
***/
void     WindowsBBox       _ARGS((IN      struct TTHandle *tt,
                                  OUT     Point *bbox));

/***
** Function: MacBBox
**
** Description:
**   Compute the bounding box of the characters that are
**   used in Mac character set.
**
**   This is currently set to the global bounding box
**   (tt->bbox) of all characters in the font. This will
**   ensure that accents are not sqeezed on Mac platforms.
***/
void     MacBBox           _ARGS((IN      struct TTHandle *tt,
                                  OUT     Point *bbox));


// the name says it

void     GlobalBBox         _ARGS((IN      struct TTHandle *tt,
                                  OUT     Point *bbox));




/***
** Function: TypographicalAscender
**
** Description:
**   Compute the typographical ascender height, as ymax of
**   the letter 'b'.
***/
funit    TypographicalDescender _ARGS((IN struct TTHandle *tt));


/***
** Function: TypographicalDescender
**
** Description:
**   Compute the typographical descender height, as ymin of
**   the letter 'g'.
***/
funit    TypographicalAscender   _ARGS((IN struct TTHandle *tt));


/***
** Function: FreeTTMetrics
**
** Description:
**   This function free's the resources used to represent
**   TT specific metrics and auxiliary font information.
***/
void     FreeTTMetrics     _ARGS((INOUT struct TTMetrics *));


/***
** Function: UsePrep
**
** Description:
**   This function records the pre-program in the
**   TTMetrics record, until an appropriate time
**   when the data can be stored in the TT file.
**   
***/
void     UsePrep           _ARGS((INOUT struct TTMetrics *,
                                  IN    UBYTE *prep,
                                  IN    USHORT size));


/***
** Function: SetFPGM
**
** Description:
**   This function records the font-program in the
**   TTMetrics record, until an appropriate time
**   when the data can be stored in the TT file.
**   
***/
void     SetFPGM           _ARGS((INOUT struct TTMetrics *,
                                  IN    UBYTE *fpgm,
                                  IN    USHORT size,
                                  IN    USHORT num));

/***
** Function: GetPrep
**
** Description:
**   This function allocates needed space for the
**   pre-program.
**   
***/
UBYTE    *GetPrep          _ARGS((IN   int size));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\pinstall.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// pinstal.cpp
//      Explorer Font Folder extension routines
//     Install files into \<windows>\fonts directory
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"
#include "cpanel.h"
#include "resource.h"
#include "fontfile.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

/*****************************************************/
/******************** locals *************************/
/*****************************************************/

static DWORD NEAR PASCAL dwGetSetFileAttr( LPTSTR lpFileName, WORD wAttr );
static int   NEAR PASCAL iMsgRecoverable( HWND hwndParent, DWORD dwVIF, PTSTR pFile );

/*****************************************************/
/******************** Defines ************************/
/*****************************************************/

#define RECOVERABLEERROR    (VIF_SRCOLD     |  VIF_DIFFLANG |  \
                             VIF_DIFFCODEPG |  VIF_DIFFTYPE)

#define UNRECOVERABLEERROR (VIF_FILEINUSE    | VIF_OUTOFSPACE   | \
                            VIF_CANNOTCREATE | VIF_OUTOFMEMORY  | \
                            VIF_CANNOTRENAME | VIF_CANNOTDELETE | \
                            VIF_CANNOTREADDST)
#define READONLY (1)

#ifndef DBCS
#define IsDBCSLeadByte(x) (FALSE)
#endif

/*****************************************************/
/******************** Functions **********************/
/*****************************************************/


int NEAR PASCAL iMsgRecoverable( HWND hwndParent, DWORD dwVIF, PTSTR pszFile )
{
    // BGK - finish this one

#define NUMFLAGS 3

    TCHAR  cszErr[ NUMFLAGS ][ 128 ] = { TEXT( "" ), TEXT( "" ), TEXT( "" ) };

    static DWORD dwFlags[ NUMFLAGS ] =
                   { VIF_SRCOLD, VIF_DIFFLANG | VIF_DIFFCODEPG, VIF_DIFFTYPE };


    for( int nTemp = 0; nTemp < NUMFLAGS; ++nTemp )
        if( dwVIF & dwFlags[ nTemp ])

            // cszErr[ nTemp ].LoadString( INSTALL5+nTemp );

            LoadString( g_hInst, INSTALL5 + nTemp, cszErr[ nTemp ], 128 );

    return iUIMsgBox( hwndParent, INSTALL8, IDS_MSG_CAPTION,
                      MB_YESNOCANCEL|MB_DEFBUTTON2|MB_ICONEXCLAMATION,
                      pszFile, cszErr[ 0 ], cszErr[ 1 ], cszErr[ 2 ]);
}


DWORD FFInstallFile( DWORD   dwFlags,
                     LPCTSTR szFromName,
                     LPCTSTR szToName,
                     LPCTSTR szFromDir,
                     LPCTSTR szToDir,
                     LPCTSTR szWinDir,
                     LPTSTR  szTmpFile,
                     UINT   *puTmpLen )
{
    FullPathName_t szFrom;
    FullPathName_t szTo;

    PathCombine( szFrom, szFromDir, szFromName );
    PathCombine( szTo  , szToDir  , szToName  );

    CFontFile file;
    
    if (ERROR_SUCCESS != file.Open(szFrom, 
                                   GENERIC_READ, 
                                   FILE_SHARE_READ))
    {
        return( VIF_CANNOTREADSRC );
    }

    switch(file.CopyTo(szTo))
    {
        case ERROR_SUCCESS:
            break;

        case ERROR_WRITE_FAULT:
            return( VIF_OUTOFSPACE );

        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_LOCK_FAILED:
            return( VIF_OUTOFMEMORY );

        default:
            //
            //  Return some unknown error
            //
            return( UNRECOVERABLEERROR );
            break;
    }

    return( 0 );
}


//
//  This installs files into the system or windows directory
//
//  There is a lot of dead code here, since this is only used for installing
//  fonts now.  Oh well.
//

BOOL FAR PASCAL bCPInstallFile( HWND hwndParent, LPTSTR lpszDir, LPTSTR lpszFrom, LPTSTR lpszTo )
{
    FullPathName_t  szShareDir;
    FullPathName_t  szAttrPath;
    FILENAME        szTmpFile;
    FILENAME        szFile;
                    
    TCHAR   szClass[ 40 ];

    UINT    wClass  = ARRAYSIZE( szClass );
    UINT    wTmpLen = ARRAYSIZE( szShareDir );


    WORD    wFlags;
    UINT    wFindStatus;
    DWORD   dwInsStatus;

    BOOL    bSuccess       = FALSE;
    BOOL    bToastTempFile = FALSE;

    static    FullPathName_t s_szWinDir;

    static    BOOL  s_bFirst = TRUE;


    if( s_bFirst )
    {
        GetSystemWindowsDirectory( s_szWinDir, ARRAYSIZE( s_szWinDir ) );
        lpCPBackSlashTerm  ( s_szWinDir );
        s_bFirst = FALSE;
    }

    lstrcpy( e_szDirOfSrc, lpszDir );

    vCPStripBlanks( e_szDirOfSrc );

    //
    //  Find the file to see if it is running or currently installed.
    //

    //
    //  Interrogate the installation system to determine where we
    //  need to put the file.  We pass in szFile - the name of the
    //  file we're going to be creating.  This has no path specified.
    //  We know where we want to put the file, and therefore don't look
    //  at the recommended destination
    //

    lstrcpy( szFile, lpszTo );
    CharUpper( szFile );

    *szShareDir = 0;

    FullPathName_t szTempDir;

    GetFontsDirectory( szTempDir, ARRAYSIZE( szTempDir ) );
   
    wFindStatus = VerFindFile( VFFF_ISSHAREDFILE, szFile, NULL, szTempDir,
                                      szClass, &wClass, szShareDir, &wTmpLen );

    //
    //  Force an install in the fonts directory.
    //

    lstrcpy( szShareDir, szTempDir );

    //
    //  If the destination file's being used by windows, we can't do much.
    //  report and bug out.
    //

    if( wFindStatus & VFF_FILEINUSE )
    {
        iUIMsgInfo( hwndParent, INSTALL1, szFile );
        goto Backout;
    }

    //
    //  If the current file is in the windows directory, be sure to delete it
    //  Or else a file installed in the system dir will not be found
    //

    lpCPBackSlashTerm( szShareDir );

    if( lstrcmpi( szShareDir, s_szWinDir ) == 0 )
        wFlags = 0;
    else
        wFlags = VIFF_DONTDELETEOLD;

    lstrcpy( szFile, lpszFrom );

    CharUpper( szFile );

DoInstall:

    //
    //  input buffer should be empty
    //

    *szTmpFile = 0;

    wTmpLen = ARRAYSIZE( szTmpFile );

    dwInsStatus = FFInstallFile( wFlags, szFile, lpszTo, e_szDirOfSrc,
                                 szShareDir, s_szWinDir, szTmpFile,
                                 &wTmpLen );
    //
    //  Note if we created a temporary file, which we'll have to delete in
    //  the event of failure
    //

    bToastTempFile = ( dwInsStatus & VIF_TEMPFILE ) != 0;

    if( dwInsStatus & VIF_CANNOTREADSRC )
        iUIMsgInfo( hwndParent, INSTALL9 );

    //
    //  If the install failed because the file was write-protected, ask the
    //  user what to do.    A no means on to the next, a yes says reset our
    //  file attributes and try again
    //

    else if( dwInsStatus & VIF_WRITEPROT )
        switch( iUIMsgBox( hwndParent, INSTALL0, IDS_MSG_CAPTION,
                           MB_YESNOCANCEL | MB_DEFBUTTON2 | MB_ICONEXCLAMATION,
                           szFile ) )
        {
        case IDYES:
            lstrcpy( szAttrPath, szShareDir );

            lstrcat( szAttrPath, szFile );

            SetFileAttributes( szAttrPath, GetFileAttributes( szAttrPath ) 
                                              & ~FILE_ATTRIBUTE_READONLY );
            goto DoInstall;
        } // switch

    //
    //  If we had a recoverable error and we're not retrying ask the user
    //  what to do.    A no means go on to the next, and a yes means reset
    //  our force flag and retry.
    //

    else if( ( dwInsStatus & RECOVERABLEERROR )
               && !(wFlags & VIFF_FORCEINSTALL ) )
        switch( iMsgRecoverable( hwndParent, dwInsStatus, szFile ) )
        {
        case IDYES:
            //
            //  Try again, forcing
            //

            wFlags |= VIFF_FORCEINSTALL;
            goto DoInstall;
        }

    //
    //  These other states all need errors reported, then bug out
    //

    else if( dwInsStatus & VIF_FILEINUSE )
        iUIMsgInfo( hwndParent, INSTALL1, szFile );

    else if( dwInsStatus & VIF_OUTOFSPACE )
        iUIMsgInfo( hwndParent, INSTALL2, szFile );

    else if( dwInsStatus & VIF_OUTOFMEMORY )
        iUIMsgInfo( hwndParent, INSTALL3, szFile );

    else if( dwInsStatus & UNRECOVERABLEERROR )
        iUIMsgInfo( hwndParent, INSTALL4, szFile );

    else if( dwInsStatus )
        iUIMsgInfo( hwndParent, INSTALL9 );

    //
    //  We've reached this point because of a good status, so we don't have
    //  to delete the temporary file.
    //

    else
    {
        bToastTempFile = FALSE;
        bSuccess = TRUE;
    }

Backout:

    if( bToastTempFile )
        vCPDeleteFromSharedDir( szTmpFile );

    bToastTempFile = FALSE;

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\strtab.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Class: StringTable
//
// This class implements a simple hash table for storing text strings.
// The purpose of the table is to store strings and then verify later
// if the table contains a given string.  Since there is no data associated
// with the string, the stored strings act as both key and data.  Therefore,
// there is no requirement for string retrieval.  Only existence checks
// are required.
// The structure maintains a fixed-length array of pointers, each pointing
// to a linked list structure (List).  These lists are used to handle the
// problem of hash collisions (sometimes known as "separate chaining").
//
// Note that these classes do not contain all the stuff that is usually
// considered necessary in C++ classes.  Things like copy constructors,
// assignment operator, type conversion etc are excluded. The classes
// are very specialized for the Font Folder application and these things
// would be considered "fat".  Should this hash table class be later used 
// in a situation where these things are needed, they can be added then.
//
// The public interfaces to the table are:
//
//      Initialize  - Initialize a new string table.
//      Add         - Add a new string to a table.
//      Exists      - Determine if a string exists in a table.
//      Count       - Return the number of strings in a table.
//
// Destruction of the object automatically releases all memory associated
// with the table.
//
// BrianAu - 4/11/96
///////////////////////////////////////////////////////////////////////////////
#include "strtab.h"


//////////////////////////////////////////////////////////////////////////////
// Class "StringTable" member functions.
//////////////////////////////////////////////////////////////////////////////

//
// String table constructor.
//
StringTable::StringTable(void)
    : m_apLists(NULL),
      m_dwItemCount(0),
      m_dwHashBuckets(0),
      m_bCaseSensitive(FALSE),
      m_bAllowDuplicates(FALSE)
{
    InitializeCriticalSection(&m_cs);
}


//
// String table destructor.
//
StringTable::~StringTable(void)
{
    Destroy();
    DeleteCriticalSection(&m_cs);
}


//
// Destroy table structures.
// Deletes all memory associates with a string table.
//
void StringTable::Destroy(void)
{
    EnterCriticalSection(&m_cs);

    if (NULL != m_apLists)
    {
        for (UINT i = 0; i < m_dwHashBuckets; i++)
        {
            //
            // Delete List if one exists in this slot.
            //
            if (NULL != m_apLists[i])
                delete m_apLists[i];
        }
        //
        // Delete array of List pointers.
        //
        delete [] m_apLists;
        m_apLists = NULL;
    }

    m_bCaseSensitive   = FALSE;
    m_bAllowDuplicates = FALSE;
    m_dwItemCount      = 0;
    m_dwHashBuckets    = 0;

    LeaveCriticalSection(&m_cs);
}


//
// Determine if the table has been initialized yet.
//
BOOL StringTable::IsInitialized(void)
{
    BOOL bResult;
    EnterCriticalSection(&m_cs);

    bResult = (NULL != m_apLists);
 
    LeaveCriticalSection(&m_cs);
    return bResult;
}



//
// Initialize a StringTable object.
// Allocates and initializes the array of List pointers.
//
BOOL StringTable::Initialize(DWORD dwHashBuckets, BOOL bCaseSensitive,
                             BOOL bAllowDuplicates)
{
    BOOL bResult = FALSE;

    EnterCriticalSection(&m_cs);
    if (IsInitialized())
        Destroy();

    m_apLists = new List* [dwHashBuckets];
    if (NULL != m_apLists)
    {
        ZeroMemory(m_apLists, dwHashBuckets * sizeof(m_apLists[0]));
        m_dwHashBuckets    = dwHashBuckets;
        m_bCaseSensitive   = bCaseSensitive;
        m_bAllowDuplicates = bAllowDuplicates;
    }
    LeaveCriticalSection(&m_cs);

    return NULL != m_apLists;
}


//
// Determine if a string exists in the table.
// This is a private function for use when the hash code has already
// been calculated.
//
BOOL StringTable::Exists(DWORD dwHashCode, LPCTSTR pszText)
{
    BOOL bResult  = FALSE;

    EnterCriticalSection(&m_cs);

    if (NULL != m_apLists)
    {
        List *pList = m_apLists[dwHashCode];

        if (NULL != pList && pList->Exists(pszText))
            bResult = TRUE;
    }

    LeaveCriticalSection(&m_cs);

    return bResult;
}


//
// Determine if a string exists in the table.
//
BOOL StringTable::Exists(LPCTSTR pszText)
{
    LPTSTR pszTemp = (LPTSTR)pszText;
    BOOL bResult   = FALSE;

    if (!m_bCaseSensitive)
    {
        //
        // Convert to upper case if table is case-insensitive.
        // This creates a NEW string that must be deleted later.
        //
        pszTemp = CreateUpperCaseString(pszText);
    }

    if (NULL != pszTemp)
    {
        bResult = Exists(Hash(pszTemp), pszTemp);

        if (pszTemp != pszText)
            delete [] pszTemp;
    }

    return bResult;
}


//
// Duplicate a string converting it to upper case.
// The returned string must be deleted when you're done with it.
//
LPTSTR StringTable::CreateUpperCaseString(LPCTSTR pszText) const
{
    //
    // Convert to upper case if table is case-insensitive.
    //
    LPTSTR pszTemp = new TCHAR [lstrlen(pszText) + 1];
    if (NULL != pszTemp)
    {
        lstrcpy(pszTemp, pszText);
        CharUpper(pszTemp);
    }
    return pszTemp;
}

    
//
// Add a string to the table.
//
BOOL StringTable::Add(LPCTSTR pszText)
{
    LPTSTR pszTemp = (LPTSTR)pszText;
    BOOL bResult   = FALSE;

    if (!m_bCaseSensitive)
    {
        //
        // Convert to upper case if table is case-insensitive.
        // This creates a NEW string that must be deleted later.
        //
        pszTemp = CreateUpperCaseString(pszText);
    }

    if (NULL != pszTemp)
    {
        DWORD dwHashCode = Hash(pszTemp);

        EnterCriticalSection(&m_cs);

        if (NULL != m_apLists)
        {
            List *pList = m_apLists[dwHashCode];

            if (NULL == pList)
            {
                //
                // Create a new List object for this slot if the slot is empty.
                //
                pList = new List;
                m_apLists[dwHashCode] = pList;
            }
            if (NULL != pList)
            {
                //
                // Add the new item to the List.
                //
                if (bResult = pList->Add(pszTemp, m_bAllowDuplicates))
                {
                    m_dwItemCount++;
                    bResult = TRUE;
                }
            }
        }
        LeaveCriticalSection(&m_cs);

        //
        // Free the temp string if created for case conversion.
        //
        if (pszTemp != pszText)
            delete [] pszTemp;
    }

    return bResult;
}
    

//
// Function for calculating hash value of a string.
// If USE_PJW_HASH_ALGORITHM, the PJW algorithm is used.
// Otherwise, the function merely sums the values of all
// the characters in the string then computes the final hash
// value using modulo division with the hash table size.
// This could also be made virtual to let the caller provide
// a custom hashing function if desired.
//
DWORD StringTable::Hash(LPCTSTR pszText) const
{
    LPCTSTR p = NULL;
    DWORD dwCode = 0;

#ifdef USE_PJW_HASH_ALGORITHM
    DWORD dwTemp = 0;
#endif

    for (p = pszText; TEXT('\0') != *p; p++)
    {
#ifdef USE_PJW_HASH_ALGORITHM
        //
        // P.J. Weinberger's hashing algorithm.
        // Commonly presented in CS texts.
        // Not sure about copyright problems so this
        // isn't used now.
        //
        dwCode = (dwCode << 4) + (*p);
        if (dwTemp = dwCode & 0xF0000000)
        {
            dwCode = dwCode ^ (dwTemp >> 24);
            dwCode = dwCode ^ dwTemp;
        }
#else
        //
        // Simply add up the values of the string characters.
        // Not as sophisticated as PJW but works OK.
        // It's also much faster.
        //
        dwCode += *p;
#endif
    }

    return dwCode % m_dwHashBuckets;
}



#ifdef DEBUG

//
// Dump table contents to debug output.
//
void StringTable::DebugOut(void) const
{
    if (NULL != m_apLists)
    {
        TCHAR pszListAddr[80];

        for (UINT i = 0; i < m_dwHashBuckets; i++)
        {
            wsprintf(pszListAddr, TEXT("[%08d] 0x%08X\r\n"), i, (DWORD)m_apLists[i]);
            OutputDebugString(pszListAddr);
            if (NULL != m_apLists[i])
                m_apLists[i]->DebugOut();
        }
    }
}

#endif // DEBUG


//////////////////////////////////////////////////////////////////////////////
// Class "List" member functions.
//////////////////////////////////////////////////////////////////////////////

//
// Collision List constructor.
//
StringTable::List::List(void)
    : m_pHead(NULL),
      m_dwCount(0)
{
    // Do nothing.
}


//
// Collision List destructor.
//
StringTable::List::~List(void)
{
    Element *pNode = m_pHead;

    while(NULL != pNode)
    {
        //
        // Shift each node to the head and delete it.
        //
        m_pHead = m_pHead->m_pNext;
        delete pNode;
        pNode = m_pHead;
    }
}


//
// Add a text string to the List.
//
BOOL StringTable::List::Add(LPCTSTR pszText, BOOL bAllowDuplicates)
{
    BOOL bResult = FALSE;

    if (bAllowDuplicates || !Exists(pszText))
    {
        Element *pNewEle = new Element;

        if (NULL != pNewEle && pNewEle->Initialize(pszText))
        {
            //
            // Insert at head of list.
            //
            pNewEle->m_pNext = m_pHead;
            m_pHead = pNewEle;
            m_dwCount++;
            bResult = TRUE;
        }
    }
    return bResult;
}


//
// Determine if a text string exists in the List.
//
BOOL StringTable::List::Exists(LPCTSTR pszText) const
{
    Element Key;
    Element *pNode = NULL;

    if (Key.Initialize(pszText))
    {
        pNode = m_pHead;
        while(NULL != pNode && *pNode != Key)
            pNode = pNode->m_pNext;
    }

    return (NULL != pNode);
}


#ifdef DEBUG
//
// Dump the List contents to the debug output.
//
void StringTable::List::DebugOut(void) const
{
    Element *pNode = m_pHead;
    UINT n = 0;
    TCHAR s[80];

    OutputDebugString(TEXT("List:\r\n"));
    while(NULL != pNode)
    {
        wsprintf(s, TEXT("\tElement %d: "), n++);
        OutputDebugString(s);
        pNode->DebugOut();
        OutputDebugString(TEXT("\n"));
        pNode = pNode->m_pNext;
    }
}

#endif // DEBUG


//////////////////////////////////////////////////////////////////////////////
// Class "Element" member functions.
//////////////////////////////////////////////////////////////////////////////

//
// List element constructor.
//
StringTable::List::Element::Element(void)
    : m_pszText(NULL),
      m_pNext(NULL)
{
    // Do nothing.
}

//
// Delete a List element.
// Deletes the string buffer.
//
StringTable::List::Element::~Element(void)
{
    if (NULL != m_pszText)
        delete [] m_pszText;
}

//
// Initialize a new List element.
// Creates a new string buffer for the string and copies
// the string into it.
//
StringTable::List::Element::Initialize(LPCTSTR pszText)
{
    m_pszText = new TCHAR[lstrlen(pszText) + 1];
    if (NULL != m_pszText)
        lstrcpy(m_pszText, pszText);

    return NULL != m_pszText;
}

//
// Determine if two elements are equal.
// If the strings are lexically equal, the elements are equal.
//
inline BOOL StringTable::List::Element::operator == (const Element& ele) const
{
    return (0 == lstrcmp(m_pszText, ele.m_pszText));
}

//
// Determine if two elements are not equal.
// If the strings are lexically not equal, the elements are not equal.
//
inline BOOL StringTable::List::Element::operator != (const Element& ele) const
{
    return !(operator == (ele));
}



#ifdef DEBUG

//
// Dump contents of List element to debug output.
//
void StringTable::List::Element::DebugOut(void) const
{
    OutputDebugString(m_pszText);
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\putil.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// putil.cpp
//      Explorer Font Folder extension routines.
//      Control panel utility function.
//      Contains Control Panel memory allocation routines.
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//      15 Aug 95 SteveCat
//          Added memory allocation routines for Type 1 font support
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

// C Runtime
#include <string.h>
#include <memory.h>


#include "priv.h"
#include "globals.h"

#include <lzexpand.h>

#include "cpanel.h"
#include "dbutl.h"
#include "resource.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

//
//  local variables and constants
//

static FullPathName_t s_szSetupDir;

//
//  WIN.INI font section name
//

static TCHAR  szFonts[]  = TEXT( "fonts" );

//
//  Globally visible variables
//

FullPathName_t e_szDirOfSrc = { TEXT( '\0' ) };

FullPathName_t   s_szSharedDir;



BOOL FAR PASCAL bCPSetupFromSource( )
{
    return !lstrcmpi( e_szDirOfSrc, s_szSetupDir );
}


void FAR PASCAL vCPUpdateSourceDir( )
{
    lstrcpy( e_szDirOfSrc, s_szSetupDir );
}


void FAR PASCAL vCPWinIniFontChange( )
{
    PostMessage( HWND_BROADCAST, WM_WININICHANGE, NULL, (LPARAM)(LPTSTR)szFonts );
    PostMessage( HWND_BROADCAST, WM_FONTCHANGE,   NULL, 0L );
}


void FAR PASCAL vCPPanelInit( )
{
    s_wBrowseDoneMsg = RegisterWindowMessage( FILEOKSTRING );

    if( TRUE /* !s_hSetup && !s_hAutoInstall && !s_fDoUpgrade */)
    {
        TCHAR cDefDir[ PATHMAX ];

        LoadString( g_hInst, IDSI_MSG_DEFDIR, cDefDir, ARRAYSIZE( cDefDir ) );

        lstrcpy( s_szSetupDir, cDefDir );

        ::GetFontsDirectory( s_szSharedDir, ARRAYSIZE( s_szSharedDir ) );

        lpCPBackSlashTerm( s_szSharedDir );
    }

    vCPUpdateSourceDir( );
}


//
// Determine if a file is located in the fonts directory.
//
BOOL bFileIsInFontsDirectory(LPCTSTR lpszPath)
{
    TCHAR szTemp[MAX_PATH];
    BOOL bResult = FALSE;

    if (NULL != lpszPath)
    {
        //
        // Make a local copy.  String will be modified.
        //
        lstrcpyn(szTemp, lpszPath, ARRAYSIZE(szTemp));

        PathRemoveFileSpec(szTemp); // Strip to path part.
        PathAddBackslash(szTemp);   // Make sure it ends with backslash.

        bResult = (lstrcmpi(szTemp, s_szSharedDir) == 0);
    }
    return bResult;
}


VOID FAR PASCAL vCPStripBlanks( LPTSTR lpszString )
{
    LPTSTR lpszPosn;

    //
    //  strip leading blanks by finding the first non blank.    If this
    //  was a change, recopy the string.  BGK - Q. Why not CharNext here?
    //

    lpszPosn = lpszString;

    while( *lpszPosn == TEXT( ' ' ) )
        lpszPosn++;

    if( lpszPosn != lpszString )
        lstrcpy( lpszString, lpszPosn );

    //
    //  strip trailing blanks
    //

    if( ( lpszPosn = lpszString + lstrlen( lpszString ) ) != lpszString )
    {
        lpszPosn = CharPrev( lpszString, lpszPosn );

        while( *lpszPosn == TEXT( ' ' ) )
            lpszPosn = CharPrev( lpszString, lpszPosn );

        lpszPosn  = CharNext( lpszPosn );
        *lpszPosn = TEXT( '\0' );
    }
}


LPTSTR FAR PASCAL lpCPBackSlashTerm( LPTSTR lpszPath )
{
    LPTSTR lpszEnd = lpszPath + lstrlen( lpszPath );

    if( !*lpszPath )
        goto appendit;

    //
    //  Get the end of the source directory
    //

    if( *CharPrev( lpszPath, lpszEnd ) != TEXT( '\\' ) )
    {
appendit:
        *lpszEnd++ = TEXT( '\\' );
        *lpszEnd   = TEXT( '\0' );
    }

    return lpszEnd;
}

#ifdef WINNT

HANDLE PASCAL wCPOpenFileWithShare( LPTSTR lpszFile,
                                    LPTSTR lpszPath,
                                    WORD   wFlags )
{
    HANDLE  fHandle;


    if( ( fHandle = MyOpenFile( lpszFile, lpszPath, wFlags | OF_SHARE_DENY_NONE ) )
                  == (HANDLE) INVALID_HANDLE_VALUE )
        fHandle = MyOpenFile( lpszFile, lpszPath, wFlags );

    return fHandle;
}

#else

WORD FAR PASCAL wCPOpenFileWithShare( LPTSTR lpszFile,
                                      LPOFSTRUCT pof,
                                      WORD wFlags )
{
    int         fHandle;
    OFSTRUCT    of;

    if( !pof )
        pof = &of;

    if( ( fHandle = OpenFile( lpszFile, pof, wFlags|OF_SHARE_DENY_NONE ) )
                  == HFILE_ERROR )
        fHandle = OpenFile( lpszFile, pof, wFlags );

    return fHandle;
}

#endif  //  WINNT

//
//  This does what is necessary to bring up a dialog box
//

int FAR PASCAL DoDialogBoxParam( int nDlg, HWND hParent, DLGPROC lpProc,
                                 DWORD dwHelpContext, LPARAM dwParam )
{
#if 0 // EMR TODO FIX
    DWORD dwSave;

    dwSave = dwContext;
    dwContext = dwHelpContext;
#endif

    nDlg = (int)DialogBoxParam( g_hInst, MAKEINTRESOURCE( nDlg ), hParent,
                           lpProc, dwParam );

#if 0    // EMR TODO FIX
    dwContext = dwSave;

    if( nDlg == -1 )
        MyMessageBox( hParent, INITS, INITS+1, MB_OK );
#endif

    return( nDlg );
}


int FAR cdecl MyMessageBox (HWND hWnd, DWORD wText, DWORD wCaption, DWORD wType, ...)
{
    TCHAR   szText[ 4 * PATHMAX ], szCaption[ 2 * PATHMAX ];
    va_list parg;


    va_start( parg, wType );

    if( wText == IDS_MSG_NSFMEM /* INITS */)
        goto NoMem;

    if( !LoadString( g_hInst, wText, szCaption, ARRAYSIZE( szCaption ) ) )
        goto NoMem;

    wvsprintf( szText, szCaption, parg );

    if( !LoadString( g_hInst, wCaption, szCaption, ARRAYSIZE( szCaption ) ) )
        goto NoMem;

    wText = (DWORD) MessageBox( hWnd, szText, szCaption,
                                wType | MB_SETFOREGROUND );

    if( wText == (DWORD) -1 )
        goto NoMem;

    va_end( parg );

    return( (int) wText );


NoMem:
    va_end( parg );

    iUIErrMemDlg(hWnd);

    return( -1 );
}


//*****************************************************************
//
//   MyOpenFile()
//
//   Purpose     : To simulate the effects of OpenFile(),
//                 _lcreat and _lopen in a Uniode environment,
//                 but also to be used in non-Unicode environment
//                 as well.
//
//*****************************************************************

HANDLE MyOpenFile( LPTSTR lpszFile, TCHAR * lpszPath, DWORD fuMode )
{
    HANDLE   fh;
    DWORD    len;
    LPTSTR   lpszName;
    TCHAR    szPath[MAX_PATH];
    DWORD    accessMode  = 0;
    DWORD    shareMode   = 0;
    DWORD    createMode  = 0;
    DWORD    fileAttribs = FILE_ATTRIBUTE_NORMAL;


    if( !lpszFile )
        return( INVALID_HANDLE_VALUE );

    //
    //  fuMode of OF_EXIST is looking for the full path name if exist
    //

    if( fuMode & OF_EXIST )
    {
        len = SearchPath( NULL, lpszFile, NULL, MAX_PATH, szPath, &lpszName );

CopyPath:
        if( len )
        {
            if( lpszPath )
                lstrcpy( lpszPath, szPath );

            return( (HANDLE) 1 );
        }
        else
            return( INVALID_HANDLE_VALUE );
    }

    //
    //  fuMode of OF_PARSE is looking for the full path name by merging the
    //  current directory
    //

    if( fuMode & OF_PARSE )
    {
        len = GetFullPathName( lpszFile, MAX_PATH, szPath, &lpszName );
        goto CopyPath;
    }

    //
    //  set up all flags passed for create file.
    //
    //  file access flag

    if( fuMode & OF_WRITE )
        accessMode = GENERIC_WRITE;
    else if( fuMode & OF_READWRITE )
        accessMode = GENERIC_READ | GENERIC_WRITE;
    else
        accessMode = GENERIC_READ;

    //
    //  file sharing flag
    //

    if( fuMode & OF_SHARE_EXCLUSIVE )
        shareMode = 0;
    else if( fuMode & OF_SHARE_DENY_WRITE )
        shareMode = FILE_SHARE_READ;
    else if( fuMode & OF_SHARE_DENY_READ )
        shareMode = FILE_SHARE_WRITE;
    else
        shareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;

    //
    //  set file creation flag
    //

    if( fuMode & OF_CREATE )
        createMode = CREATE_ALWAYS;
    else
        createMode = OPEN_EXISTING;

    //
    //  call CreateFile();
    //

    fh = CreateFile( lpszFile, accessMode, shareMode,
                     NULL, createMode, fileAttribs, NULL );

    if( lpszPath )
        lstrcpy( lpszPath, lpszFile );

    return( fh );

} // end of MyOpenFile()


//*****************************************************************
//
//   MyCloseFile()
//
//   Purpose     : To simulate the effects of _lclose()
//                 in a Uniode environment.
//
//*****************************************************************

BOOL MyCloseFile( HANDLE  hFile )
{
#ifndef  WIN32
    return( !_lclose( (HFILE) hFile ) );
#else
    return( CloseHandle( hFile ) );
#endif

} // end of MyCloseFile()


//*****************************************************************
//
//   MyByteReadFile()
//
//   For Win16, will handle > 64k
//
//*****************************************************************

UINT MyByteReadFile( HANDLE  hFile, LPVOID  lpBuffer, DWORD  cbBuffer )
{
    UINT    cbRead      = (UINT)HFILE_ERROR;
    LPVOID  hpBuffer    = lpBuffer;
    DWORD   dwByteCount = cbBuffer;


#ifdef WIN32
    if (ReadFile( hFile, lpBuffer, cbBuffer, (ULONG *)&cbRead, NULL ))
        return cbRead;
    else
        return (UINT)HFILE_ERROR;
#else
    while( dwByteCount > MAX_UINT )
    {
        if( _lread( (HFILE) hFile, hpBuffer, MAX_UINT ) == MAX_UINT )
            return( (UINT)HFILE_ERROR );

        dwByteCount -= MAX_UINT;
        hpBuffer += MAX_UINT;
    }
    return( _lread( (HFILE) hFile, lpBuffer, dwBytesCount ) == dwBytesCount );
#endif

} // end of MyByteReadFile()


//*****************************************************************
//
//   MyAnsiReadFile()
//
//   Purpose     : To simulate the effects of _lread() in a Unicode
//                 environment by reading into an ANSI buffer and
//                 then converting to Uniode text.
//
//*****************************************************************

UINT MyAnsiReadFile( HANDLE  hFile,
                     UINT    uCodePage,
                     LPVOID  lpUnicode,
                     DWORD   cchUnicode)
{
    LPSTR lpAnsi  = NULL;
    UINT  cbRead  = (UINT)HFILE_ERROR;
    UINT  cbAnsi  = cchUnicode * sizeof(TCHAR);
    UINT  cchRead = 0;

    lpAnsi = (LPSTR) LocalAlloc(LPTR, cbAnsi);
    if (NULL != lpAnsi)
    {
        cbRead = MyByteReadFile( hFile, lpAnsi, cbAnsi );

        if( HFILE_ERROR != cbRead )
        {
            cchRead = MultiByteToWideChar( uCodePage,
                                           0,
                                           lpAnsi,
                                           cbRead,
                                           (LPWSTR)lpUnicode,
                                           cchUnicode);
        }
        LocalFree( lpAnsi );
    }

    return( cchRead );

} // end of MyAnsiReadFile()


//*****************************************************************
//
//   MyByteWriteFile()
//
//   For Win16, will handle > 64k
//
//*****************************************************************

UINT MyByteWriteFile( HANDLE hFile, LPVOID lpBuffer, DWORD cbBuffer )
{
    UINT    cbWritten   = (UINT)HFILE_ERROR;
    LPVOID  hpBuffer    = lpBuffer;
    DWORD   dwByteCount = cbBuffer;

#ifdef WIN32
    if (WriteFile( hFile, lpBuffer, cbBuffer, (ULONG *)&cbWritten, NULL ))
        return cbWritten;
    else
        return (UINT)HFILE_ERROR;
#else
    while( dwByteCount > MAX_UINT )
    {
        if( _lwrite( (HFILE) hFile, hpBuffer, MAX_UINT ) == MAX_UINT )
            return( (UINT)HFILE_ERROR );

        dwByteCount -= MAX_UINT;
        hpBuffer += MAX_UINT;
    }

    return( _lwrite( (HFILE) hFile, lpBuffer, dwBytesCount ) == dwBytesCount );
#endif

} // end of MyByteWriteFile()


//*****************************************************************
//
//   MyAnsiWriteFile()
//
//   Purpose     : To simulate the effects of _lwrite() in a Unicode
//                 environment by converting to ANSI buffer and
//                 writing out the ANSI text.
//
//*****************************************************************

UINT MyAnsiWriteFile( HANDLE  hFile,
                      UINT uCodePage,
                      LPVOID lpUnicode,
                      DWORD cchUnicode)
{
    LPSTR   lpAnsi    = NULL;
    UINT    cbAnsi    = 0;
    UINT    cbWritten = (UINT)HFILE_ERROR;

    //
    // Calculate byte requirement for ansi buffer.
    //
    cbAnsi = WideCharToMultiByte (uCodePage,
                                  0,
                                  (LPWSTR)lpUnicode,
                                  cchUnicode,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL);

    //
    // Allocate the ansi buffer and convert characters to ansi.
    //
    lpAnsi = (LPSTR) LocalAlloc(LPTR, cbAnsi);
    if (NULL != lpAnsi)
    {
        WideCharToMultiByte( uCodePage,
                             0,
                             (LPWSTR)lpUnicode,
                             cchUnicode,
                             lpAnsi,
                             cbAnsi,
                             NULL,
                             NULL );

        cbWritten = MyByteWriteFile( hFile, lpAnsi, cbAnsi );

        LocalFree( lpAnsi );
    }

    return( cbWritten );

} // end of MyAnsiWriteFile()


//*****************************************************************
//
//   MyFileSeek()
//
//   Purpose     : To simulate the effects of _lseek() in a Unicode
//                 environment.
//
//*****************************************************************

LONG MyFileSeek( HANDLE hFile, LONG lDistanceToMove, DWORD dwMoveMethod )
{
#ifdef WIN32
    return( SetFilePointer( hFile, lDistanceToMove, NULL, dwMoveMethod ) );
#else
    return( _llseek( (HFILE) hFile, lDistanceToMove, (int) dwMoveMethod ) );
#endif

} // end of MyFileSeek()



/////////////////////////////////////////////////////////////////////////////
//
// AllocMem
//
//
// Routine Description:
//
//     This function will allocate local memory. It will possibly allocate
//     extra memory and fill this with debugging information for the
//     debugging version.
//
// Arguments:
//
//     cb - The amount of memory to allocate
//
// Return Value:
//
//     NON-NULL - A pointer to the allocated memory
//
//     FALSE/NULL - The operation failed. Extended error status is available
//         using GetLastError.
//
/////////////////////////////////////////////////////////////////////////////

LPVOID AllocMem( DWORD cb )
{
    LPDWORD  pMem;
    DWORD    cbNew;


    cbNew = cb + 2 * sizeof( DWORD );

    if( cbNew & 3 )
        cbNew += sizeof( DWORD ) - ( cbNew & 3 );

    pMem = (LPDWORD) LocalAlloc( LPTR, cbNew );

    if( !pMem )
        return NULL;

    // memset (pMem, 0, cbNew);     // This might go later if done in NT

    *pMem = cb;

    *(LPDWORD) ( (LPBYTE) pMem + cbNew - sizeof( DWORD ) ) = 0xdeadbeef;

    return (LPVOID)( pMem + 1 );
}


/////////////////////////////////////////////////////////////////////////////
//
// FreeMem
//
//
// Routine Description:
//
//     This function will allocate local memory. It will possibly allocate
//     extra memory and fill this with debugging information for the
//     debugging version.
//
// Arguments:
//
//     pMem - Pointer to memory to free
//     cb   - size of memory block to free
//
// Return Value:
//
//     NON-NULL - Memory successfully freed
//
//     FALSE/NULL - The operation failed. Extended error status is available
//                  using GetLastError.
//
/////////////////////////////////////////////////////////////////////////////

BOOL FreeMem( LPVOID pMem, DWORD  cb )
{
    DWORD   cbNew;
    LPDWORD pNewMem;


    if( !pMem )
        return TRUE;

    pNewMem = (LPDWORD) pMem;
    pNewMem--;


#ifdef NO_COUNT_NEEDED
    if( cb == 0 )
    {
        cb = cbNew = *pNewMem;
    }
    else
    {
        cbNew = cb + 2 * sizeof( DWORD );

        if( cbNew & 3 )
            cbNew += sizeof( DWORD ) - ( cbNew & 3 );
    }
#else

    cbNew = cb + 2 * sizeof( DWORD );

    if( cbNew & 3 )
        cbNew += sizeof( DWORD ) - ( cbNew & 3 );


#endif  // NO_COUNT_NEEDED


    if( ( *pNewMem != cb ) ||
        ( *(LPDWORD) ( (LPBYTE) pNewMem + cbNew - sizeof( DWORD ) ) != 0xdeadbeef ) )
    {
        DEBUGMSG( (DM_TRACE1, TEXT("Corrupt Memory in FontFolder : %0lx\n"), pMem ) );
    }

    return ( ( (HLOCAL) pNewMem == LocalFree( (LPVOID) pNewMem ) ) );
}


LPVOID ReallocMem( LPVOID lpOldMem, DWORD cbOld, DWORD cbNew )
{
   LPVOID lpNewMem;

   lpNewMem = AllocMem( cbNew );

   if( lpOldMem )
   {
      memcpy( lpNewMem, lpOldMem, min( cbNew, cbOld ) );

      FreeMem( lpOldMem, cbOld );
   }

   return lpNewMem;
}


/////////////////////////////////////////////////////////////////////////////
//
// Routine Description:
//
//     These functions will allocate or reallocate enough local memory to
//     store the specified  string, and copy that string to the allocated
//     memory.  The FreeStr function frees memory that was initially
//     allocated by AllocStr.
//
// Arguments:
//
//     lpStr - Pointer to the string that needs to be allocated and stored
//
// Return Value:
//
//     NON-NULL - A pointer to the allocated memory containing the string
//
//     FALSE/NULL - The operation failed. Extended error status is available
//         using GetLastError.
//
/////////////////////////////////////////////////////////////////////////////

LPTSTR AllocStr( LPTSTR lpStr )
{
   LPTSTR lpMem;

   if( !lpStr )
      return NULL;

   if( lpMem = (LPTSTR) AllocMem( ( lstrlen( lpStr ) + 1 ) * sizeof( TCHAR ) ) )
      lstrcpy( lpMem, lpStr );

   return lpMem;
}


BOOL FreeStr( LPTSTR lpStr )
{
   return lpStr ? FreeMem( lpStr, ( lstrlen( lpStr ) + 1 ) * sizeof( TCHAR ) )
                : FALSE;
}


BOOL ReallocStr( LPTSTR *plpStr, LPTSTR lpStr )
{
   FreeStr( *plpStr );

   *plpStr = AllocStr( lpStr );

   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CentreWindow
//
// Purpose : Positions a window so that it is centred in its parent
//
// History:
// 12-09-91 Davidc       Created.
//
//////////////////////////////////////////////////////////////////////////////

VOID CentreWindow( HWND hwnd )
{
    RECT    rect;
    RECT    rectParent;
    HWND    hwndParent;
    LONG    dx, dy;
    LONG    dxParent, dyParent;
    LONG    Style;


    //
    //  Get window rect
    //

    GetWindowRect( hwnd, &rect );

    dx = rect.right - rect.left;
    dy = rect.bottom - rect.top;

    //
    //  Get parent rect
    //

    Style = GetWindowLong( hwnd, GWL_STYLE );

    if( (Style & WS_CHILD) == 0 )
    {
        hwndParent = GetDesktopWindow( );
    }
    else
    {
        hwndParent = GetParent( hwnd );

        if( hwndParent == NULL )
        {
            hwndParent = GetDesktopWindow( );
        }
    }

    GetWindowRect( hwndParent, &rectParent );

    dxParent = rectParent.right - rectParent.left;
    dyParent = rectParent.bottom - rectParent.top;

    //
    //  Centre the child in the parent
    //

    rect.left = ( dxParent - dx ) / 2;
    rect.top  = ( dyParent - dy ) / 3;

    //
    //  Move the child into position
    //

    SetWindowPos( hwnd, NULL, rect.left, rect.top, 0, 0,
                  SWP_NOSIZE | SWP_NOZORDER );

    SetForegroundWindow( hwnd );
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: GetFirstAncestor
//
// DESCRIP:  Locates the first ancestor of a given window.
//
//////////////////////////////////////////////////////////////////////////////
HWND GetFirstAncestor(HWND hWnd)
{
    HWND hwndAncestor = NULL;

    //
    // Find the top-level parent of the window that was passed in.
    //
    while ((hwndAncestor = GetParent(hWnd)) != NULL)
        hWnd = hwndAncestor;

    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\encoding.h ===
/***
 **
 **   Module: Encoding
 **
 **   Description:
 **      This is a module of the T1 to TT font converter. The module
 **      contains interface functions for the global encoding table,
 **      i.e. this is an abstract data type.
 **
 **   Author: Michael Jansson
 **
 **   Created: 6/13/93
 **
 ***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif


#define ENC_UNICODE   (USHORT)0   /* Unicode */
#define ENC_MSWINDOWS (USHORT)1   /* Microsoft Windows UGL sub-set encoding. */
#define ENC_STANDARD  (USHORT)2   /* Postscript Standard Encoding */
#define ENC_MACCODES  (USHORT)3   /* Mac encoding. */
#define ENC_MAXCODES  (USHORT)4

#define NOTDEFCODE (USHORT)0xffff /* 0xfffff is not a vaild code point so use
												 it for the .notdef character. */
#define NOTDEFINIT	0xffffffffL	 /* Used to init encoding arrays. */
#define NOTDEFGLYPH	(USHORT)0	 /* Glyph zero must be the notdef glyph. */
#define NULLGLYPH		(USHORT)1	 /* Glyph one must be the null glyph. */

/***
** Function: LookupNotDef
**
** Description:
**   look up a the .notdef character
***/
const struct encoding   *LookupNotDef        _ARGS((void));


/***
** Function: LookupPSName
**
** Description:
**   Do a binary search for a postscript name, and return
**   a handle that can be used to look up a the character
**   code for a specific encoding schema.
***/
struct encoding   *LookupPSName        _ARGS((IN      struct encoding *table,
                                              INOUT   USHORT size,
                                              IN      char *name));


/***
** Function: LookupCharName
**
** Description:
**   look up a the character name for a
**   specific encoding scheme.
***/
const char        *LookupCharName      _ARGS((IN      struct encoding *enc));


/***
** Function: LookupCharCode
**
** Description:
**   look up a the character code for a
**   specific encoding scheme.
***/
USHORT            LookupCharCode       _ARGS((IN      struct encoding *enc,
                                              IN      USHORT type));

/***
** Function: DecodeChar
**
** Description:
**   look up an encoding record for a character code in some
**   known encoding.
***/
const struct encoding   *DecodeChar    _ARGS((IN   struct encoding *table,
                                              IN      USHORT size,
                                              IN      USHORT type,
                                              IN      USHORT code));
/***
** Function: AllocEncodingTable
**
** Description:
**   Create a new encoding ADT.
***/
struct encoding   *AllocEncodingTable  _ARGS((IN      USHORT num));


/***
** Function: SetEncodingEntry
**
** Description:
**   Set the mapping from a glyph name to character
**   codes for various platforms.
***/
void              SetEncodingEntry     _ARGS((INOUT   struct encoding *, 
                                              IN      USHORT entry,
                                              IN      char *name,
                                              IN      USHORT max,
                                              IN      USHORT *codes));
/***
** Function: RehashEncodingTable
**
** Description:
**   Prepare an encoding ADT so that entries can be
**   located in it.
***/
void              RehashEncodingTable  _ARGS((INOUT   struct encoding *, 
                                              IN      USHORT num));


/***
** Function: FreeEncoding
**
** Description:
**   Deallocate memory associated to the encoding array.
***/
void              FreeEncoding         _ARGS((INOUT   struct encoding *,
                                              IN      USHORT num));

/***
** Function: LookupFirstEnc
**
** Description:
**   Locate the first encoding for a given glyph.
***/
const struct encoding *LookupFirstEnc(const struct encoding *encRoot,
												  const int encSize,
												  const struct encoding *encItem);


/***
** Function: LookupNextEnc
**
** Description:
**   Locate the first encoding for a given glyph.
***/
const struct encoding *LookupNextEnc(const struct encoding *encRoot,
												 const int encSize,
												 const struct encoding *encItem);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\t1.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// t1.cpp
//      Explorer Font Folder extension routines
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#include <windows.h>

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

// Application specific

#include "t1instal.h"

#include "priv.h"
#include "globals.h"
#include "fontcl.h"
#include "resource.h"
#include "ui.h"
#include "cpanel.h"
#include "fontman.h"


extern FullPathName_t  s_szSharedDir;

TCHAR c_szDescFormat[] = TEXT( "%s (%s)" );
TCHAR c_szPostScript[] = TEXT( "Type 1" );

TCHAR szFonts[] = TEXT( "fonts" );

char  g_szFontsDirA[ PATHMAX ];           //  ANSI string!

TCHAR m_szMsgBuf[ PATHMAX ];

TCHAR szTTF[ ] = TEXT(".TTF");
TCHAR szFON[ ] = TEXT(".FON");
TCHAR szPFM[ ] = TEXT(".PFM");
TCHAR szPFB[ ] = TEXT(".PFB");

typedef void (__stdcall *PROGRESSPROC)( short, void *);

#undef T1_SUPPORT

BOOL RegisterProgressClass( void );
VOID UnRegisterProgressClass( void );

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

#if defined(T1_SUPPORT)


#include "t1.h"
#include "cpanel.h"  // for bUniqueOnSharedDir()


typedef short (__stdcall *CONVERTTYPEFACEPROC) ( char *, char *, char *, PROGRESSPROC, void *);
typedef BOOL  (__stdcall *CHECKTYPE1PROC)( char *, DWORD, char *, DWORD, char *, DWORD, char *, BOOL *);
typedef short (__stdcall *CHECKCOPYRIGHTPROC)( char *, DWORD, char *);

CONVERTTYPEFACEPROC lpConvertTypefaceA = 0;
CHECKTYPE1PROC      lpCheckType1A = 0;
CHECKCOPYRIGHTPROC  lpCheckCopyrightA = 0;



// --------------------------------------------------------------------
// The Following functions support Type 1 to TrueType conversion.
// --------------------------------------------------------------------

BOOL bInitType1( )
{
    static BOOL bTriedOne = FALSE;
    static HINSTANCE g_hType1;

    if( !g_hType1 && !bTriedOne )
    {
        g_hType1 = LoadLibrary( TEXT( "T1INSTAL.DLL" ) );
        bTriedOne = TRUE;

        if( g_hType1 )
        {
            lpConvertTypefaceA = (CONVERTTYPEFACEPROC) GetProcAddress( g_hType1, "ConvertTypefaceA" );
            lpCheckType1A = (CHECKTYPE1PROC) GetProcAddress( g_hType1, "CheckType1A" );
            lpCheckCopyrightA = (CHECKCOPYRIGHTPROC) GetProcAddress( g_hType1, "CheckCopyrightA" );

            if( !lpConvertTypefaceA || !lpCheckType1A || !lpCheckCopyrightA )
                g_hType1 = FALSE;
        }
    }

    return( g_hType1 != 0 );
}


BOOL NEAR PASCAL bIsType1( LPSTR        lpFile,
                           FontDesc_t * lpDesc,
                           LPT1_INFO    lpInfo )
{
    BOOL bRet = FALSE;
    T1_INFO  t1_info;

    if( bInitType1( ) )
    {
        if( !lpInfo )
            lpInfo = &t1_info;

        bRet = (*lpCheckType1A)( lpFile,
                                 sizeof( FontDesc_t ), (char *)lpDesc,
                                 sizeof( lpInfo->pfm ), (char *)&lpInfo->pfm,
                                 sizeof( lpInfo->pfb ), (char *)&lpInfo->pfb,
                                 &lpInfo->bCreatedPFM );
    }

    return bRet;
}


BOOL NEAR PASCAL bConvertT1( LPT1_INFO lpInfo )
{
    BOOL    bRet = FALSE;
    char  szVendor[ 128 ];

    if( bInitType1( ) )
    {
        short nRet = (*lpCheckCopyrightA)( lpInfo->pfb, sizeof( szVendor ), szVendor );

        if( nRet >= 0 )
        {
            //
            //  Get a TT file name to convert it to and convert it.
            //

            if( bUniqueOnSharedDir( lpInfo->ttf, "CvtT1.ttf" ) )
            {
                bRet = (*lpConvertTypefaceA)( lpInfo->pfb, lpInfo->pfm,
                                              lpInfo->ttf, 0, 0 );
            }
        }
    }

    return bRet;
}

#endif   // T1_SUPPORT



#ifdef WINNT

//==========================================================================
//                        Local Definitions
//==========================================================================
#define GWL_PROGRESS    0
#define SET_PROGRESS    WM_USER

//  Progress Control color indices
#define PROGRESSCOLOR_FACE        0
#define PROGRESSCOLOR_ARROW       1
#define PROGRESSCOLOR_SHADOW      2
#define PROGRESSCOLOR_HIGHLIGHT   3
#define PROGRESSCOLOR_FRAME       4
#define PROGRESSCOLOR_WINDOW      5
#define PROGRESSCOLOR_BAR         6
#define PROGRESSCOLOR_TEXT        7

#define CCOLORS                   8

#define CHAR_BACKSLASH  TEXT( '\\' )
#define CHAR_COLON      TEXT( ':' )
#define CHAR_NULL       TEXT( '\0' )
#define CHAR_TRUE       TEXT( 'T' )
#define CHAR_FALSE      TEXT( 'F' )

//==========================================================================
//                       External Declarations
//==========================================================================

extern HWND  hLBoxInstalled;

//==========================================================================
//                       Local Data Declarations
//==========================================================================

BOOL bYesAll_PS = FALSE;        //  Use global state for all PS fonts
BOOL bConvertPS = TRUE;         //  Convert Type1 files to TT
BOOL bInstallPS = TRUE;         //  Install PS files
BOOL bCopyPS    = TRUE;         //  Copy PS files to Windows dir

BOOL bCancelInstall = FALSE;    // Global installation cancel

TCHAR szTrue[]  = TEXT( "T" );
TCHAR szFalse[] = TEXT( "F" );
TCHAR szHash[]  = TEXT( "#" );

BOOL bProgMsgDisplayed;         //  Used by Progress to avoid msg flicker
BOOL bProg2MsgDisplayed;        //  Used by Progress2 to avoid msg flicker

HWND hDlgProgress = NULL;

//
//  Used to determine Foreground/Backgnd colors for progress bar control
//  Global values are set at RegisterClass time
//

DWORD   rgbFG;
DWORD   rgbBG;

//  Registry location for installing PostScript printer font info

TCHAR g_szType1Key[] = TEXT( "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer\\Type 1 Fonts" );

//
//  Array of default colors, matching the order of PROGRESSCOLOR_* values.
//

DWORD rgColorPro[ CCOLORS ] = {
                         COLOR_BTNFACE,             //  PROGRESSCOLOR_FACE
                         COLOR_BTNTEXT,             //  PROGRESSCOLOR_ARROW
                         COLOR_BTNSHADOW,           //  PROGRESSCOLOR_SHADOW
                         COLOR_BTNHIGHLIGHT,        //  PROGRESSCOLOR_HIGHLIGHT
                         COLOR_WINDOWFRAME,         //  PROGRESSCOLOR_FRAME
                         COLOR_WINDOW,              //  PROGRESSCOLOR_WINDOW
                         COLOR_ACTIVECAPTION,       //  PROGRESSCOLOR_BAR
                         COLOR_CAPTIONTEXT          //  PROGRESSCOLOR_TEXT
                         };

typedef struct _T1_INSTALL_OPTIONS
{
    BOOL        bMatchingTT;
    BOOL        bOnlyPSInstalled;
    LPTSTR      szDesc;
    WORD        wFontType;
} T1_INSTALL_OPTIONS, *PT1_INSTALL_OPTIONS;

//
//  Linked-list structure used for copyright Vendors
//

typedef struct _psvendor
{
    struct _psvendor *pNext;
    LPTSTR pszCopyright;            //  Copyright string
    int    iResponse;               //  User's response to YES/NO MsgBox
} PSVENDOR;

PSVENDOR *pFirstVendor = NULL;      //  ptr to linked list for PS vendors

//==========================================================================
//                      Local Function Prototypes
//==========================================================================

BOOL CheckTTInstall( LPTSTR szDesc );
void Draw3DRect( HDC hDC, HBRUSH hBrushFace, HPEN hPenFrame, HPEN hPenHigh,
                 HPEN hPenShadow, int x1, int y1, int x2, int y2 );
INT_PTR APIENTRY InstallPSDlg( HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );
void STDCALL  Progress( short PercentDone, void* UniqueValue );
LRESULT APIENTRY ProgressBarCtlProc( HWND hTest, UINT message, WPARAM wParam, LPARAM lParam );
INT_PTR APIENTRY ProgressDlg( HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );
INT_PTR APIENTRY CopyrightNotifyDlgProc( HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );
LONG ProgressPaint( HWND hWnd, DWORD dwProgress );


//==========================================================================
//                           Functions
//==========================================================================

/////////////////////////////////////////////////////////////////////////////
//
// StripFilespec
//
//   Remove the filespec portion from a path (including the backslash).
//
/////////////////////////////////////////////////////////////////////////////

VOID StripFilespec( LPTSTR lpszPath )
{
   LPTSTR     p;

   p = lpszPath + lstrlen( lpszPath );

   while( ( *p != CHAR_BACKSLASH )  && ( *p != CHAR_COLON )  && ( p != lpszPath ) )
      p--;

   if( *p == CHAR_COLON )
      p++;

   //
   //  Don't strip backslash from root directory entry.
   //

   if( p != lpszPath )
   {
      if( ( *p == CHAR_BACKSLASH )  && ( *( p - 1 )  == CHAR_COLON ) )
         p++;
   }

   *p = CHAR_NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// StripPath
//
//   Extract only the filespec portion from a path.
//
/////////////////////////////////////////////////////////////////////////////

VOID StripPath( LPTSTR lpszPath )
{
  LPTSTR     p;


  p = lpszPath + lstrlen( lpszPath );

  while( ( *p != CHAR_BACKSLASH )  && ( *p != CHAR_COLON )  && ( p != lpszPath ) )
      p--;

  if( p != lpszPath )
      p++;

  if( p != lpszPath )
      lstrcpy( lpszPath, p );
}


/////////////////////////////////////////////////////////////////////////////
//
// AddVendorCopyright
//
//  Add a PostScript Vendor's Copyright and User response to "MAYBE" list.
//  This linked-list is used to keep track of a user's prior response to
//  message about converting this vendor's fonts to TrueType.  If a vendor
//  is not in the registry, we cannot automatically assume that the font
//  can be converted.  We must present the User with a message, asking them
//  to get permission from the vendor before converting the font to TrueType.
//
//  However, we do allow them to continue the installation and convert the
//  font to TrueType by selecting the YES button on the Message box.  This
//  routine keeps track of each vendor and the User's response for that
//  vendor.  This way we do not continually ask them about the same vendor
//  during installation of a large number of fonts.
//
//  (Insert item into linked list )
//
//
/////////////////////////////////////////////////////////////////////////////

BOOL AddVendorCopyright( LPTSTR pszCopyright, int iResponse )
{
    PSVENDOR *pVendor;          //  temp pointer to linked list


    //
    //  Make the new PSVENDOR node and add it to the linked list.
    //

    if( pFirstVendor )
    {
        pVendor = (PSVENDOR *) AllocMem( sizeof( PSVENDOR ) );

        if( pVendor )
        {
            pVendor->pNext = pFirstVendor;
            pFirstVendor = pVendor;
        }
        else
            return FALSE;
    }
    else        // First time thru
    {
        pFirstVendor = (PSVENDOR *) AllocMem( sizeof( PSVENDOR ) );

        if( pFirstVendor )
            pFirstVendor->pNext = NULL;
        else
            return FALSE;
    }

    //
    //  Save User response and Copyright string
    //

    pFirstVendor->iResponse = iResponse;

    pFirstVendor->pszCopyright = AllocStr( pszCopyright );

    //
    //  Return success.
    //

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//
// CheckVendorCopyright
//
//  Check if a Vendor Copyright is already in the "MAYBE" linked-list and
//  and return User response if it is found.
//
//  Returns:
//          IDYES  - User wants to convert typeface anyway
//          IDNO   - User does not want to convert typeface
//          -1     - Entry not found
//
/////////////////////////////////////////////////////////////////////////////

int CheckVendorCopyright( LPTSTR pszCopyright )
{
    PSVENDOR *pVendor;          // temp pointer to linked list

    //
    //  Traverse the list, testing each node for matching copyright string
    //

    pVendor = pFirstVendor;

    while( pVendor )
    {
        if( !lstrcmpi( pVendor->pszCopyright, pszCopyright ) )
            return( pVendor->iResponse );

        pVendor = pVendor->pNext;
    }

    //
    //  "Did not find matching copyright" return
    //

    return( -1 );
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CopyrightNotifyDlgProc
//
// DESCRIP:  Display the dialog informing the user about possible
//           Type1 font copyright problems.
//
// ARGS:     lParam is the address of an array of text string pointers.
//           Element 0 is the name of the font.
//           Element 1 is the name of the vendor.
//
///////////////////////////////////////////////////////////////////////////////
enum arg_nums{ARG_FONTNAME = 0, ARG_VENDORNAME};
INT_PTR APIENTRY CopyrightNotifyDlgProc( HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam )
{

    switch( nMsg )
    {
        case WM_INITDIALOG:
        {
            LPCTSTR *lpaszTextItems   = (LPCTSTR *)lParam;
            LPCTSTR lpszVendorName    = NULL;
            TCHAR szUnknownVendor[80] = { TEXT('\0') };

            ASSERT(NULL != lpaszTextItems);
            ASSERT(NULL != lpaszTextItems[ARG_FONTNAME]);
            ASSERT(NULL != lpaszTextItems[ARG_VENDORNAME]);

            //
            // Set font name string.
            //
            SetWindowText(GetDlgItem(hDlg, IDC_COPYRIGHT_FONTNAME),
                                           lpaszTextItems[ARG_FONTNAME]);

            //
            // Set vendor name string.  If name provided is blank, use a default
            // string of "Unknown Vendor Name" from string table.
            //
            if (TEXT('\0') == *lpaszTextItems[ARG_VENDORNAME])
            {
                UINT cchLoaded = 0;
                cchLoaded = LoadString(g_hInst, IDSI_UNKNOWN_VENDOR,
                                       szUnknownVendor, ARRAYSIZE(szUnknownVendor));

                ASSERT(cchLoaded > 0); // Complain if someone removed resource string.

                lpszVendorName = szUnknownVendor;
            }
            else
                lpszVendorName = lpaszTextItems[ARG_VENDORNAME];

            SetWindowText(GetDlgItem(hDlg, IDC_COPYRIGHT_VENDORNAME), lpszVendorName),
            CentreWindow( hDlg );
            break;
        }

    case WM_COMMAND:
        switch( LOWORD( wParam ) )
        {
            case IDYES:
            case IDNO:
                //
                // Dialog Proc must return IDYES or IDNO when a button
                // is selected.  This is the value stored in the Vendor Copyright
                // list.
                //
                EndDialog(hDlg, LOWORD(wParam));
                break;
            default:
                return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

//
// OkToConvertType1ToTrueType
//
// This function checks the authorization for converting a Type1
// font to it's TrueType equivalent.  Authorization information is stored
// in the registry under the section ...\Type 1 Installer\Copyrights.
//
// If authorization is GRANTED, the function returns TRUE and the font may be
// converted to TrueType.
//
// If authorization is explicitly DENIED and the user has not selected
// "Yes to All" in the Type1 options dialog, a message box is displayed
// informing the user of the denial and the function returns FALSE
//
// If no authorization information is found in the registry for this vendor,
// a dialog box is displayed warning the user about possible copyright
// violations.  The user can answer Yes to convert the font anyway or No
// to skip the conversion.  This response is stored in memory on a per-vendor
// basis so that the user won't have to respond to this same question if
// a font from this vendor is encountered again.
//
BOOL OkToConvertType1ToTrueType(LPCTSTR pszFontDesc, LPCTSTR pszPFB, HWND hwndParent)
{
    char    szCopyrightA[MAX_PATH]; // For string from Type1 (ANSI) file.
#ifdef UNICODE
    WCHAR   szCopyrightW[MAX_PATH]; // For display in UNICODE build.
    char    szPfbA[MAX_PATH];       // For arg to CheckCopyrightA (ANSI).
#endif
    LPTSTR  pszCopyright = NULL;    // Ptr to Copyright string (A or W).
    LPSTR   pszPfbA      = NULL;    // Ptr to ANSI PFB filename string.
    DWORD   dwStatus     = 0;       // Temp result variable.
    BOOL    bResult      = FALSE;   // Function return value.

    //
    //  Check convertability of this font from Type1 to TrueType.
    //
    //  Returns: SUCCESS, FAILURE, MAYBE
    //
#ifdef UNICODE
    WideCharToMultiByte(CP_ACP, 0, pszPFB, -1, szPfbA, ARRAYSIZE(szPfbA), NULL, NULL);
    pszPfbA = szPfbA;
#else
    pszPfbA = pszPFB;
#endif

    dwStatus = CheckCopyrightA(pszPfbA, ARRAYSIZE(szCopyrightA), szCopyrightA);
    if (SUCCESS == dwStatus)
    {
        bResult = TRUE;
    }
    else
    {

#ifdef UNICODE
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szCopyrightA, -1,
                                         szCopyrightW, ARRAYSIZE(szCopyrightW));
        pszCopyright = szCopyrightW;
#else
        pszCopyright = szCopyrightA;
#endif

        switch(dwStatus)
        {

            case FAILURE:

                //
                //  Put up a message box stating that this Type1 font vendor
                //  does not allow us to Convert their fonts to TT.  This will
                //  let the user know that it is not Microsoft's fault that the
                //  font is not converted to TT, but the vendor's fault.
                //
                //  NOTE:  This is only done if the User has NOT selected the
                //         YesToAll_PS install option.  Otherwise it will be very
                //         annoying to see message repeated over and over.
                //
                if (!bYesAll_PS)
                {

                    iUIMsgBox( hwndParent,
                               MYFONT + 2, IDS_MSG_CAPTION,
                               MB_OK | MB_ICONEXCLAMATION,
                               (LPTSTR)  pszCopyright,
                               (LPTSTR)  pszFontDesc );
                }
                break;

            case MAYBE:
                //
                //  Check font copyright and ask for user response if necessary
                //
                switch(CheckVendorCopyright(pszCopyright))
                {
                    case IDYES:
                        //
                        // User previously responded "Yes" for converting fonts
                        // from this vendor.  Automatic approval.
                        //
                        bResult = TRUE;
                        break;

                    case IDNO:
                        //
                        // User previously responded "No" for converting fonts
                        // from this vendor.  Automatic denial.
                        //
                        bResult = FALSE;
                        break;

                    case -1:
                    default:
                    {
                        //
                        // No previous record of having asked user about this vendor.
                        //
                        INT iResponse = IDNO;

                        //
                        // Warn user about possible copyright problems.
                        // Ask if they want to convert to TrueType anyway.
                        //
                        LPCTSTR lpszDlgTextItems[] = {pszFontDesc, pszCopyright};

                        iResponse = (INT)DialogBoxParam(g_hInst,
                                                   MAKEINTRESOURCE(DLG_COPYRIGHT_NOTIFY),
                                                   hwndParent ? hwndParent : HWND_DESKTOP,
                                                   CopyrightNotifyDlgProc,
                                                   (LPARAM)lpszDlgTextItems);
                        //
                        // Remember this response for this vendor.
                        //
                        AddVendorCopyright(pszCopyright, iResponse);

                        //
                        // Translate user response to a T/F return value.
                        //
                        bResult = (iResponse == IDYES);

                        break;
                    }
                }
                break;

            default:
                //
                //  ERROR! from routine - assume worst case
                //
                break;
        }
    }
    return bResult;
}



/////////////////////////////////////////////////////////////////////////////
//
// IsPSFont
//
//  Check validity of font file passed in and get paths to .pfm/.pfb
//  files, determine if it can be converted to TT.
//
// in:
//    lpszPfm        .pfm file name to validate
// out:
//    lpszDesc       on succes Font Name of Type1
//    lpszPfm        on succes the path to .pfm file
//    lpszPfb        on succes the path to .pfb file
//    pbCreatedPFM   on succes whether a PFM file was created or not
//                   If valid pointer on entry...
//                   *bpCreatedPFM == TRUE means check for existing PFM.
//                                    FALSE means don't check for PFM.
//    lpdwStatus     Address of caller status variable.  Use this value
//                   to determine cause of FALSE return value.
//
// NOTE: Assumes that lpszPfm and lpszPfb are of size PATHMAX & lpszDesc is
//       of size DESCMAX
//
// returns:
//    TRUE success, FALSE failure
//
// The following table lists the possible font verification status codes
// returned in *lpdwStatus along with a brief description of the cause for each.
// See fvscodes.h for numeric code value details.
//
//
//          FVS_SUCCESS
//          FVS_FILE_OPEN_ERR
//          FVS_BUILD_ERR
//          FVS_FILE_EXISTS
//          FVS_INSUFFICIENT_BUF
//          FVS_INVALID_FONTFILE
//          FVS_BAD_VERSION
//          FVS_FILE_IO_ERR
//          FVS_EXCEPTION
//
/////////////////////////////////////////////////////////////////////////////

BOOL IsPSFont( LPTSTR lpszKey,
               LPTSTR lpszDesc,         //  Optional
               LPTSTR lpszPfm,          //  Optional
               LPTSTR lpszPfb,          //  Optional
               BOOL  *pbCreatedPFM,     //  Optional
               LPDWORD lpdwStatus )     //  May be NULL
{
    BOOL    bRet = FALSE;
    TCHAR   strbuf[ PATHMAX ] ;
    BOOL    bPFM;

    //
    //  ANSI buffers for use with ANSI only API's
    //

    char    *desc, Descbuf[ PATHMAX ] ;
    char    Keybuf[ PATHMAX ] ;
    char    *pfb, Pfbbuf[ PATHMAX ] ;
    char    *pfm, Pfmbuf[ PATHMAX ] ;
    DWORD   iDesc, iPfb, iPfm;
    DWORD   dwStatus = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);

    //
    // Initialize status return.
    //
    if (NULL != lpdwStatus)
        *lpdwStatus = FVS_MAKE_CODE(FVS_INVALID_STATUS, FVS_FILE_UNK);


    if( lpszDesc )
        *lpszDesc = (TCHAR)  0;

    desc = Descbuf;
    iDesc = PATHMAX;

    pfb = Pfbbuf;
    iPfb = PATHMAX;

    if( lpszPfm )
    {
        pfm = Pfmbuf;
        iPfm = PATHMAX;
    }
    else
    {
        pfm = NULL;
        iPfm = 0;
    }

    if( pbCreatedPFM )
    {
        bPFM = *pbCreatedPFM;  // Caller says if CheckType1WithStatusA checks for dup PFM
        *pbCreatedPFM = FALSE;
    }
    else
        bPFM = TRUE;  // By default, CheckType1WithStatusA should check for dup PFM.

    WideCharToMultiByte( CP_ACP, 0, lpszKey, -1, Keybuf, PATHMAX, NULL, NULL );

    //
    //  The CheckType1WithStatusA routine accepts either a .INF or .PFM file name as
    //  the Keybuf( i.e. Key file )   input parameter.  If the input is a .INF
    //  file, a .PFM file will be created in the SYSTEM directory if (and
    //  only if) the .PFM file name parameter is non-NULL.  Otherwise, it
    //  will just check to see if a valid .INF, .AFM and .PFB file exist for
    //  the font.
    //
    //  The bPFM BOOL value is an output parameter that tells me if the routine
    //  created a .PFM file from the .INF/.AFM file for this font.  If the
    //  pfm input parameter is non-NULL, it will always receive the proper
    //  path for the .PFM file.
    //
    //  The bPFM flag is used to tell CheckType1WithStatusA if it should check for an
    //  existing PFM file.  If invoked as part of a drag-drop install, we
    //  don't want to do this check.  If from install dialog, do the check.
    //

    dwStatus = ::CheckType1WithStatusA( Keybuf, iDesc, desc, iPfm, pfm, iPfb, pfb, &bPFM, g_szFontsDirA );

    if( FVS_STATUS(dwStatus) == FVS_SUCCESS)
    {
        if( pbCreatedPFM )
            *pbCreatedPFM = bPFM;

        //
        //  Return Font description
        //

        if( lpszDesc )
        {
#ifdef UNICODE
            //
            //  Convert Descbuf to UNICODE since Type1 files are ANSI
            //
            MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, Descbuf, -1, strbuf, PATHMAX );
            vCPStripBlanks(strbuf);
            wsprintf(lpszDesc, c_szDescFormat, strbuf, c_szPostScript );
#else
            vCPStripBlanks(Descbuf);
            wsprintf(lpszDesc, c_szDescFormat, Descbuf, c_szPostScript );
#endif
        }

        //
        //  Return PFM file name
        //

        if( lpszPfm )
        {
            //
            //  Return PFM file name - convert to UNICODE since Type1 files are ANSI
            //
#ifdef UNICODE
            MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, Pfmbuf, -1, lpszPfm, PATHMAX );
#else
            lstrcpy(lpszPfm, Pfmbuf);
#endif
        }

        //
        //  Return PFB file name
        //

        if( lpszPfb )
        {
            //
            //  Return PFB file name - convert to UNICODE since Type1 files are ANSI
            //
#ifdef UNICODE
            MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, Pfbbuf, -1, lpszPfb, PATHMAX );
#else
            lstrcpy(lpszPfb, Pfbbuf);
#endif
        }

        bRet = TRUE;
    }

    //
    // Return status if user wants it.
    //
    if (NULL != lpdwStatus)
       *lpdwStatus = dwStatus;

    return bRet;
}


/////////////////////////////////////////////////////////////////////////////
//
// InitPSInstall
//
//  Initialize PostScript install routine global variables.
//
/////////////////////////////////////////////////////////////////////////////

void InitPSInstall( )
{
    CFontManager *poFontManager;
    if (SUCCEEDED(GetFontManager(&poFontManager)))
    {
        //
        //  Initialize linked list variables for "MAYBE" copyright vendor list
        //
        pFirstVendor = NULL;

        //
        //  Other installation globals
        //

        bYesAll_PS = FALSE;

        //
        // If the native ATM driver is installed, we NEVER convert from Type1 to
        // TrueType.
        //
        bConvertPS = !poFontManager->Type1FontDriverInstalled();

        bInstallPS = TRUE;
        bCopyPS    = TRUE;
        ReleaseFontManager(&poFontManager);
    }        

    return;
}


/////////////////////////////////////////////////////////////////////////////
//
// TermPSInstall
//
//  Initialize PostScript install routine global variables.
//
/////////////////////////////////////////////////////////////////////////////

void TermPSInstall( )
{

    PSVENDOR *pVendor;

    //
    //  Traverse the list, freeing list memory and strings.
    //

    pVendor = pFirstVendor;

    while( pVendor )
    {
        pFirstVendor = pVendor;
        pVendor = pVendor->pNext;

        if( pFirstVendor->pszCopyright )
            FreeStr( pFirstVendor->pszCopyright );

        FreeMem( (LPVOID)  pFirstVendor, sizeof( PSVENDOR ) );
    }

    //
    //  Reset global to be safe
    //

    pFirstVendor = NULL;

    return;
}



/////////////////////////////////////////////////////////////////////////////
//
// InstallT1Font
//
//  Install PostScript Type1 font, possibly converting the Type1 font to a
//  TrueType font in the process.  Write registry entries so the PostScript
//  printer driver can find these files either in their original source
//  directory or locally in the 'shared' or system directory.
//
/////////////////////////////////////////////////////////////////////////////

int InstallT1Font( HWND   hwndParent,
                   BOOL   bCopyTTFile,          //  Copy TT file?
                   BOOL   bCopyType1Files,      //  Copy PFM/PFB to font folder?
                   BOOL   bInSharedDir,         //  Files in Shared Directory?
                   LPTSTR szKeyName,            //  IN: PFM/INF Source File name & dir
                                                //  OUT: Destination file name
                   LPTSTR szDesc )              //  INOUT: Font description

{
    WORD   wFontType = NOT_TT_OR_T1;            //  Enumerated Font type
    int    rc, iRet;
    WORD   wMsg;
    BOOL   bCreatedPfm = FALSE;  // F = IsPSFont doesn't check for existing PFM

    TCHAR  szTemp[    PATHMAX ] ;
    TCHAR  szTemp2[   PATHMAX ] ;
    TCHAR  szPfbName[ PATHMAX ] ;
    TCHAR  szPfmName[ PATHMAX ] ;
    TCHAR  szSrcDir[  PATHMAX ] ;
    TCHAR  szDstName[ PATHMAX ] ;
    TCHAR  szTTFName[ PATHMAX ] ;
    TCHAR  *pszArg1, *pszArg2;

    T1_INSTALL_OPTIONS t1ops;

    //
    //  ASCII Buffers for use in ASCII-only api calls
    //

    char  pfb[ PATHMAX ] ;
    char  pfm[ PATHMAX ] ;
    char  ttf[ PATHMAX ] ;

    DWORD dwStatus = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);


    //////////////////////////////////////////////////////////////////////
    //
    //  Check if font is already loaded on the system
    //
    //////////////////////////////////////////////////////////////////////

    t1ops.bOnlyPSInstalled = FALSE;
    t1ops.bMatchingTT      = FALSE;

    //
    //  Check both Type1 & Fonts registry location for prior font installation
    //

    if( CheckT1Install( szDesc, NULL ) )
    {
        //
        // "Font is already loaded"
        //
        iRet = iUIMsgOkCancelExclaim( hwndParent,
                                      MYFONT + 5,
                                      IDS_MSG_CAPTION,
                                      (LPTSTR)szDesc);
        //
        // Return without deleting the PFM file.
        // Because this font is a duplicate, the PFM
        // already existed.
        //
        goto MasterExit;
    }
    else if( CheckTTInstall( szDesc ) )
    {
        t1ops.bMatchingTT = TRUE;

        if( !bYesAll_PS )
        {
            //
            // "The TrueType version of this font is already installed."
            //

            switch( iUIMsgBox( hwndParent,
                               MYFONT + 4, IDS_MSG_CAPTION,
                               MB_YESNOCANCEL | MB_ICONEXCLAMATION,
                               (LPTSTR) szDesc ) )
            {
            case IDYES:
                break;

            case IDNO:
                iRet = TYPE1_INSTALL_IDNO;
                goto InstallPSFailure;

            case IDCANCEL:
            default:
                iRet = TYPE1_INSTALL_IDCANCEL;
                goto InstallPSFailure;
            }
        }
    }

    //
    // WARNING [brianau]
    // If we're installing from a .INF/.AFM pair, this function automatically
    // creates a new .PFM file in the fonts directory, even if the .PFM file
    // already exists.  This could cause a possible file mismatch between an
    // existing .PFB and the new .PFM.
    //
    if(::IsPSFont( szKeyName, (LPTSTR) NULL, szPfmName, szPfbName,
                     &bCreatedPfm, &dwStatus ))
    {
        CFontManager *poFontManager;
        if (SUCCEEDED(GetFontManager(&poFontManager)))
        {
            wFontType = TYPE1_FONT;

            lstrcpyn(szTemp, szDesc, ARRAYSIZE(szTemp));
            RemoveDecoration(szTemp, TRUE);
            if (poFontManager->Type1FontDriverInstalled() ||
                !OkToConvertType1ToTrueType(szTemp,
                                            szPfbName,
                                            hwndParent))
            {
                wFontType = TYPE1_FONT_NC;
            }
            ReleaseFontManager(&poFontManager);
        }
    }
    else
    {
        if (iUIMsgBoxInvalidFont(hwndParent, szKeyName, szDesc, dwStatus) == IDCANCEL)
           iRet = TYPE1_INSTALL_IDCANCEL;
        else
           iRet = TYPE1_INSTALL_IDNO;
        goto InstallPSFailure;
    }

    t1ops.szDesc = szDesc;
    t1ops.wFontType = wFontType;

    //
    //  Keep a copy of source directory
    //

    lstrcpy( szSrcDir, szKeyName );

    StripFilespec( szSrcDir );

    lpCPBackSlashTerm( szSrcDir );
    //
    //  The global state of
    //
    //      bConvertPS  -  Convert Type1 files to TT
    //      bInstallPS  -  Install PS files
    //
    //  is only effective for the last time the "Install Type 1 fonts"
    //  dialog was displayed.  Check the state of these globals against
    //  what we know about the current font to determine if the dialog
    //  should be redisplayed.
    //
    //  5/31/94 [stevecat] DO NOT redisplay the dialog after "YesToAll"
    //  selected once.  Instead, display messages about 'exceptions' to
    //  their initial choices and give user the option to continue
    //  installation.
    //

    if( bYesAll_PS )
    {
        //
        //  If the PS version of this font is already installed AND the
        //  global bInstall == TRUE, then the globals are out-of-sync
        //  with this font.  Let user know and continue installation.
        //

        if( t1ops.bOnlyPSInstalled && bInstallPS )
        {
            //
            // "The Type 1 version of this font is already installed."
            //

            switch( iUIMsgBox( hwndParent,
                               MYFONT + 3, IDS_MSG_CAPTION,
                               MB_YESNOCANCEL | MB_ICONEXCLAMATION,
                               (LPTSTR) szDesc ) )
            {
            case IDYES:
                break;

            case IDNO:
                iRet = TYPE1_INSTALL_IDNO;
                goto InstallPSFailure;

            case IDCANCEL:
            default:
                iRet = TYPE1_INSTALL_IDCANCEL;
                goto InstallPSFailure;
            }
        }

        //
        //  If the matching TT font is already installed AND the global
        //  bConvertPS == TRUE, then the globals are out-of-sync with
        //  this font.  Let the user know and continue installation.
        //

        if( t1ops.bMatchingTT && bConvertPS )
        {
            //
            // "The TrueType version of this font is already installed."
            //

            switch( iUIMsgBox( hwndParent,
                               MYFONT + 4, IDS_MSG_CAPTION,
                               MB_YESNOCANCEL | MB_ICONEXCLAMATION,
                               (LPTSTR) szDesc ) )
            {
            case IDYES:
                break;

            case IDNO:
                iRet = TYPE1_INSTALL_IDNO;
                goto InstallPSFailure;

            case IDCANCEL:
            default:
                iRet = TYPE1_INSTALL_IDCANCEL;
                goto InstallPSFailure;
            }
        }
    }

    //
    //  Get user options for PostScript font installation:
    //      - TT conversion
    //      - Type1 installation
    //      - Copying Type1 files
    //
    //  State returned in globals:
    //
    //      bConvertPS  -  Convert Type1 files to TT
    //      bInstallPS  -  Install PS files
    //      bCopyPS     -  Copy PS files to Windows\System dir
    //

    //
    // The following section of commented-out code prevents the Type1 font
    // installation dialog from being displayed.  Since we're removing
    // the requirement for Type1-to-TrueType conversion from NT5, this
    // dialog is no longer necessary.  Instead of taking out all of the code
    // related to Type1-TrueType conversion, I've merely disabled this dialog
    // and automatically set the values of bConvertPS, bInstallPS and bCopyPS.
    // To do this right, the font folder needs to be re-written from scratch.
    // It's a real mess and is very fragile so I don't want to introduce subtle
    // errors or spend a lot of time partially re-writing only some of it.
    // Note that simply removing this preprocessor directive will NOT re-enable
    // TrueType to Type1 conversion.  There are other minor changes in the code
    // that support the deactivation of this feature. [brianau 5/15/97]
    //
#ifdef ENABLE_TRUETYPE_TO_TYPE1_CONVERSION

    if( !bYesAll_PS )
    {
        //
        //  Set normal cursor for new dialog
        //

        HCURSOR hCurs = SetCursor( LoadCursor( NULL, IDC_ARROW ) );


        switch( DoDialogBoxParam( DLG_INSTALL_PS, hDlgProgress, InstallPSDlg,
                                  IDH_DLG_INSTALL_PS, (LPARAM)  &t1ops ) )
        {
        case IDNO:
            //
            //  Note that we do not do HourGlass( TRUE ) , but that
            //  should be harmless, since we are either going to come
            //  right back here, or we are going to exit
            //
            return IDNO;

        case IDD_YESALL:
            bYesAll_PS = TRUE;

            //
            //  Fall thru...
            //

        case IDYES:
            //
            //  Give a warning here about installing from a non-local
            //  directory and not copying files, as necessary.
            //

            if( bInstallPS && !bCopyPS )
            {
                lstrcpy( szTemp, szPfbName );
                StripFilespec( szTemp );
                lpCPBackSlashTerm( szTemp );

                switch( GetDriveType( szTemp ) )
                {
                    case DRIVE_REMOTE:
                    case DRIVE_REMOVABLE:
                    case DRIVE_CDROM:
                    case DRIVE_RAMDISK:
                        switch( iUIMsgBox( IDSI_MSG_COPYCONFIRM, IDS_MSG_CAPTION,
                                       MB_YESNOCANCEL | MB_ICONEXCLAMATION))
                        {
                            case IDNO:
                               iRet = TYPE1_INSTALL_IDNO;
                               goto InstallPSFailure;
                            case IDCANCEL:
                               iRet = TYPE1_INSTALL_IDCANCEL;
                               goto InstallPSFailure;
                            default:
                               break;
                        }
                        break;
                }
            }
            break;

        default:
            //
            // CANCEL and NOMEM( user already warned )
            //

            iRet = TYPE1_INSTALL_IDCANCEL;
            goto InstallPSFailure;
        }

        //
        //  Reset previous cursor
        //

        SetCursor( hCurs );
    }
#endif // ENABLE_TRUETYPE_TO_TYPE1_CONVERSION

    //
    // These values were originally set in the Type1 installation dialog.
    // Now that this dialog has been disabled, we hard code the values.
    // [brianau 5/15/97]
    //
    bInstallPS = TRUE;             // Always install the font.
    bConvertPS = FALSE;            // Never convert Type1 to TrueType.
    bCopyPS    = bCopyType1Files;

    //
    // szDstName should already have the full source file name
    //
    //  Only convert the Type1 font to TT if:
    //
    //  a)  The user asked us to do it;
    //  b)  The font can be converted, AND;
    //  c)  There is not a matching TT font already installed
    //
    if( bConvertPS && ( wFontType != TYPE1_FONT_NC )  && !t1ops.bMatchingTT )
    {
        //////////////////////////////////////////////////////////////////
        // Convert Type1 files to TrueType
        //
        // Copy converted TT file, if necessary, to "fonts" directory
        //
        // NOTE: We are using the ConvertTypeface api to do the copying
        //       and it is an ASCII only api.
        //////////////////////////////////////////////////////////////////

        //
        //  Create destination name with .ttf
        //

        lstrcpy( szTemp, szPfmName );
        StripPath( szTemp );
        vConvertExtension( szTemp, szTTF );

        //
        //  Build destination file pathname based on bCopyTTFile
        //

        if( bCopyTTFile || bInSharedDir )
        {
            //
            //  Copy file to local directory
            //

            lstrcpy( szDstName, s_szSharedDir );
        }
        else
        {
            //
            //  Create converted file in source directory
            //

            lstrcpy( szDstName, szSrcDir );
        }

        //
        //  Check new filename for uniqueness
        //

        if( !(bUniqueFilename( szTemp, szTemp, szDstName ) ) )
        {
            iRet = iUIMsgOkCancelExclaim( hwndParent, IDSI_FMT_BADINSTALL,
                                          IDSI_CAP_NOCREATE, szDesc );
            goto InstallPSFailure;
        }

        lstrcat( szDstName, szTemp );

        //
        //  Save destination filename for return to caller
        //

#if 1
        lstrcpy( szTTFName, szDstName );
#else
        if( bCopyTTFile || bInSharedDir )
            lstrcpy( szTTFName, szTemp );
        else
            lstrcpy( szTTFName, szDstName );
#endif

        //
        //  We will convert and copy the Type1 font in the same api
        //

        WideCharToMultiByte( CP_ACP, 0, szPfbName, -1, pfb,
                                PATHMAX, NULL, NULL );

        WideCharToMultiByte( CP_ACP, 0, szPfmName, -1, pfm,
                                PATHMAX, NULL, NULL );

        WideCharToMultiByte( CP_ACP, 0, szDstName, -1, ttf,
                                PATHMAX, NULL, NULL );

        ResetProgress( );

        //
        //  Remove "PostScript" postfix string from description
        //

        RemoveDecoration( szDesc, TRUE );

        if( (rc = (int) ::ConvertTypefaceA( pfb, pfm, ttf,
                                            (PROGRESSPROC) Progress,
                                            (void *) szDesc ) ) < 0 )
        {
            pszArg1 = szPfmName;
            pszArg2 = szPfbName;

            switch( rc )
            {
            case ARGSTACK:
            case TTSTACK:
            case NOMEM:
                wMsg = INSTALL3;
                break;

            case NOMETRICS:
            case BADMETRICS:
            case UNSUPPORTEDFORMAT:
                //
                //  Something is wrong with the .pfm metrics file
                //

                pszArg1 = szDstName;
                pszArg2 = szPfmName;
                wMsg = MYFONT + 13;
                break;

            case BADT1HYBRID:
            case BADT1HEADER:
            case BADCHARSTRING:
            case NOCOPYRIGHT:
                //
                //  Bad .pfb input file - format, or corruption
                //

                pszArg1 = szDstName;
                pszArg2 = szPfbName;
                wMsg = MYFONT + 14;
                break;

            case BADINPUTFILE:
                //
                //  Bad input file names, or formats or file errors
                //  or file read errors
                //

                pszArg1 = szDstName;
                pszArg2 = szPfbName;
                wMsg = MYFONT + 15;
                break;

            case BADOUTPUTFILE:
                //
                //  No diskspace for copy, read-only share, etc.
                //

                pszArg1 = szDstName;
                wMsg = MYFONT + 16;
                break;

            default:
                //
                //  Cannot convert szDesc to TrueType - general failure
                //

                pszArg1 = szDstName;
                pszArg2 = szDesc;
                wMsg = MYFONT + 17;
                break;
            }

            iRet = iUIMsgBox( hwndParent, wMsg, IDS_MSG_CAPTION,
                              MB_OKCANCEL | MB_ICONEXCLAMATION,
                              pszArg1, pszArg2, szPfmName );

            goto InstallPSFailure;
        }

        //
        //  Change font description to have "TrueType" now
        //

        wsprintf( szDesc, c_szDescFormat, szDesc, c_szTrueType );
    }

    iRet = TYPE1_INSTALL_IDNO;

    if( bInstallPS && !t1ops.bOnlyPSInstalled )
    {
        //
        //  Remove "PostScript" postfix string from description
        //

        lstrcpy( szTemp2, szDesc );
        RemoveDecoration( szTemp2, TRUE );

        //
        //  Now reset per font install progress
        //

        ResetProgress( );
        Progress2( 0, szTemp2 );


        //
        //  Only copy the files if the User asked us to AND they are NOT
        //  already in the Shared directory.
        //

        if( bCopyPS && !bInSharedDir )
        {
            //
            //  Copy file progress
            //

            Progress2( 10, szTemp2 );

            /////////////////////////////////////////////////////////////////
            // COPY files to "fonts" directory
            /////////////////////////////////////////////////////////////////

            //
            //  For .inf/.afm file install::  Check .pfm pathname to see if
            //  it is the same as the destination file pathname we built.
            //  Make this check before we test/create a UniqueFilename.
            //

            //  Build Destination file pathname for .PFM file

            lstrcpy( szDstName, s_szSharedDir );
            lstrcat( szDstName, lpNamePart( szPfmName ) );

            //
            //  Check to see if the .pfm file already exists in the "fonts"
            //  directory.  If it does, then just copy the .pfb over.
            //

            if( !lstrcmpi( szPfmName, szDstName ) )
                goto CopyPfbFile;

            //
            //  Setup args for bCPInstallFile call
            //

            StripPath( szDstName );
            StripPath( szPfmName );

            if( !(bUniqueOnSharedDir( szDstName, szDstName ) ) )
            {
                iRet = iUIMsgOkCancelExclaim( hwndParent, IDSI_FMT_BADINSTALL,
                                              IDSI_CAP_NOCREATE, szDesc );
                goto InstallPSFailure;
            }

            if( !bCPInstallFile( hwndParent, szSrcDir, szPfmName, szDstName ) )
                goto InstallPSFailure;

CopyPfbFile:

            //
            //  Copying pfm file was small portion of install
            //

            Progress2( 30, szTemp2 );

            //
            //  Setup and copy .PFB file
            //
            //  Setup args for bCPInstallFile call
            //

            lstrcpy(szSrcDir, szPfbName);  // Prepare src directory name.
            StripFilespec( szSrcDir );
            lpCPBackSlashTerm( szSrcDir );

            StripPath( szPfbName );
            lstrcpy( szDstName, szPfbName );

            if( !(bUniqueOnSharedDir( szDstName, szDstName ) ) )
            {
                iRet = iUIMsgOkCancelExclaim( hwndParent, IDSI_FMT_BADINSTALL,
                                              IDSI_CAP_NOCREATE, szDesc );
                goto InstallPSFailure;
            }

            if( !bCPInstallFile( hwndParent, szSrcDir, szPfbName, szDstName ) )
                goto InstallPSFailure;
        }

        //
        //  Copying pfb file was large portion of install
        //

        Progress2( 85, szTemp2 );

        //
        //  Write registry entry to "install" font for use by the
        //  PostScript driver, but only after successfully copying
        //  files (if copy was necessary).
        //
        //  NOTE:  This routine will strip the path off of the filenames
        //         if they are in the Fonts dir.
        //

        iRet = WriteType1RegistryEntry( hwndParent, szDesc, szPfmName, szPfbName, bCopyPS );

        //
        // If the Type1 font driver is installed,
        // add the Type1 font resource to GDI.
        //
        {
            CFontManager *poFontManager;
            if (SUCCEEDED(GetFontManager(&poFontManager)))
            {
                if (poFontManager->Type1FontDriverInstalled())
                {
                    TCHAR szType1FontResourceName[MAX_TYPE1_FONT_RESOURCE];

                    if (BuildType1FontResourceName(szPfmName,
                                                   szPfbName,
                                                   szType1FontResourceName,
                                                   ARRAYSIZE(szType1FontResourceName)))
                    {
                        AddFontResource(szType1FontResourceName);
                    }
                }
                ReleaseFontManager(&poFontManager);
            }
        }

        //
        //  No need to add to internal font list here.  It is added in the calling
        //  code (bAddSelFonts or CPDropInstall).
        //

        //
        //  Final registry write completes install, except for listbox munging.
        //  Note that TrueType file install is handled separately.
        //

        Progress2( 100, szTemp2 );
    }

    //
    //  Determine correct return code based on installation options and
    //  current installed state of font.
    //

    if( bConvertPS && ( wFontType != TYPE1_FONT_NC ) )
    {
        //
        //  Handle the special case of when the matching TTF font is already
        //  installed.
        //

        if( t1ops.bMatchingTT )
            goto Type1InstallCheck;


        lstrcpy( szKeyName, szTTFName );

        if( t1ops.bOnlyPSInstalled )
        {
            //
            //  There is already a Lbox entry for the PS version of this font
            //  that needs to be deleted because the TT installation will
            //  add a new Lbox entry.
            //

            iRet = TYPE1_INSTALL_TT_AND_MPS;

            //
            //  Funnel all exits thru 1 point to check for Install Cancellation
            //

            goto MasterExit;
        }
        else if( bInstallPS )
        {
            iRet = ( iRet == IDOK )  ? TYPE1_INSTALL_TT_AND_PS : TYPE1_INSTALL_TT_ONLY;

            //
            //  Funnel all exits thru 1 point to check for Install Cancellation
            //

            goto MasterExit;
        }
        else
        {
            iRet = TYPE1_INSTALL_TT_ONLY;
            goto CheckPfmDeletion;
        }
    }


Type1InstallCheck:

#ifdef LATER
//
//  Since fonts are displayed in an Explorer (Fonts) Folder, there is not an
//  initial display listbox of "Installed" fonts to check against.  These
//  checks must be made against the registry list of installed fonts.
//
//  Also, I need to force a "Refresh" of the Folder view after installation
//  is complete of either each font or all selected fonts.   This might already
//  be being done somewhere.
//

    if( bInstallPS )
    {
        if( iRet != IDOK )
        {
            iRet = TYPE1_INSTALL_IDNO;
            goto InstallPSFailure;
        }

        iRet = TYPE1_INSTALL_IDNO;

        if( t1ops.bMatchingTT )
        {
            //
            //  If we previously found the Matching TT font for this Type1
            //  font and installed the PostScript font in this session, set
            //  the font type for the Matching TT font to IF_TYPE1_TT.
            //
            //  Also, do not add a new entry in listbox for the Type1 font.
            //
            //  Find matching  "xxxxx (TrueType)" entry and change its
            //  ItemData to IF_TYPE1_TT
            //
            //  Change font description to have "(TrueType ) " now
            //

            RemoveDecoration( szDesc, TRUE );

            wsprintf( szDesc, c_szDescFormat, szDesc, c_szTrueType );

            rc= SendMessage( hListFonts, LB_FINDSTRINGEXACT, (WPARAM )  -1,
                                                         (LONG ) szDesc );

            if( rc != LB_ERR )
            {
                SendMessage( hListFonts, LB_SETITEMDATA, rc, (LONG) IF_TYPE1_TT );

                SendMessage( hListFonts, LB_SETSEL, 1, rc );

                UpdateWindow( hListFonts );

                iRet = TYPE1_INSTALL_PS_AND_MTT;
            }
        }
        else
        {
            rc = SendMessage( hListFonts, LB_ADDSTRING, 0, (LONG)(LPTSTR) szDesc );

            //
            //  Attach font type to each listed font
            //

            if( rc != LB_ERR )
            {
                SendMessage( hListFonts, LB_SETITEMDATA, rc, IF_TYPE1 );

                SendMessage( hListFonts, LB_SETSEL, 1, rc );

                UpdateWindow( hListFonts );

                iRet = TYPE1_INSTALL_PS_ONLY;
            }
        }
    }
#else  //  LATER

    if( bInstallPS )
    {
        if( iRet != IDOK )
        {
            iRet = TYPE1_INSTALL_IDNO;
            goto InstallPSFailure;
        }

        if( t1ops.bMatchingTT )
        {
            iRet = TYPE1_INSTALL_PS_AND_MTT;
        }
        else
        {
            iRet = TYPE1_INSTALL_PS_ONLY;
        }
    }

#endif  //  LATER

    if( !bInstallPS )
        goto CheckPfmDeletion;

    //
    //  Funnel all exits thru 1 point to check for Install Cancellation
    //

    goto MasterExit;

    /////////////////////////////////////////////////////////////////////////
    //
    //  Install failure exit AND Delete extraneously created PFM file
    //
    //  NOTE:  For the installation scenario where we based installation on
    //         the .INF/.AFM file and the Type1 font was NOT installed, we
    //         need to delete the .FPM file that was created by the
    //         CheckType1WithStatusA routine in the IsPSFont routine.
    //
    /////////////////////////////////////////////////////////////////////////

InstallPSFailure:

CheckPfmDeletion:

    if( bCreatedPfm )
        DeleteFile( szPfmName );

MasterExit:

    return( InstallCancelled() ? IDCANCEL : iRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// InstallPSDlg
//
//  This dialog proc manages the Install PostScript font dialog which allows
//  the user several options for the installation, including converting the
//  file to a TrueType font.
//
//  Globals munged:
//
//      bConvertPS    -   Convert Type1 files to TT
//      bInstallPS    -   Install PS files
//      bCopyPS       -   Copy PS files to Windows dir
//
/////////////////////////////////////////////////////////////////////////////

INT_PTR APIENTRY InstallPSDlg( HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam )
{
    TCHAR  szFormat[ PATHMAX ] ;
    TCHAR  szTemp[ PATHMAX ] ;
    TCHAR  szTemp2[ PATHMAX ] ;
    int    iButtonChecked;
    WORD   wMsg;

    static HWND hwndActive = NULL;

    T1_INSTALL_OPTIONS *pt1ops;


    switch( nMsg )
    {

    case WM_INITDIALOG:

        pt1ops = (PT1_INSTALL_OPTIONS)  lParam;

        //
        //  Remove all "PostScript" or "TrueType" postfix to font name
        //

        lstrcpy( szTemp2, (LPTSTR) pt1ops->szDesc );

        RemoveDecoration( szTemp2, FALSE );

        {
            LPCTSTR args[] = { szTemp2 };

            LoadString( g_hInst, MYFONT + 7, szFormat, ARRAYSIZE( szFormat ) );
            FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          szFormat,
                          0,
                          0,
                          szTemp,
                          ARRAYSIZE(szTemp),
                          (va_list *)args);
        }

        SetWindowLongPtr( hDlg, GWL_PROGRESS, lParam );

        SetDlgItemText( hDlg, FONT_INSTALLMSG, szTemp );
        EnableWindow( hDlg, TRUE );

        //
        // If the native ATM driver is installed, the "Convert to TrueType" checkbox
        // is always disabled.
        //
        {
            CFontManager *poFontManager;
            if (SUCCEEDED(GetFontManager(&poFontManager)))
            {
                if (poFontManager->Type1FontDriverInstalled())
                    EnableWindow(GetDlgItem(hDlg, FONT_CONVERT_PS), FALSE);
                ReleaseFontManager(&poFontManager);
            }
        }

        if( pt1ops->bOnlyPSInstalled && pt1ops->bMatchingTT )
        {
            //
            // ERROR!  Both of these options should not be set at
            //         this point.  It means that the font is
            //         already installed.  This should have been
            //         handled before calling this dialog.
            //

            wMsg = MYFONT + 5;
InstallError:

            iUIMsgExclaim( hDlg, wMsg, pt1ops->szDesc );

            EndDialog( hDlg, IDNO );
            break;
        }

        if( (pt1ops->wFontType == TYPE1_FONT_NC )  && pt1ops->bOnlyPSInstalled )
        {
            //
            //  ERROR! This case is when I have detected only the PS
            //         version of font installed, and the font CANNOT
            //         be converted to TT for some reason.
            //

            wMsg = MYFONT + 8;
            goto InstallError;
        }

        /////////////////////////////////////////////////////////////////////
        //
        //  Setup user options depending on install state of font and
        //  convertibility to TT of T1 font and on previous user choices.
        //
        /////////////////////////////////////////////////////////////////////


        if( (pt1ops->wFontType == TYPE1_FONT )  && (!pt1ops->bMatchingTT ) )
        {
            //
            //  This one can be converted
            //

            CheckDlgButton( hDlg, FONT_CONVERT_PS, bConvertPS );
        }
        else
        {
            //
            //  Do not allow conversion to TT because, either the font
            //  type is TYPE1_FONT_NC( i.e. it cannot be converted )  OR
            //  the TT version of font is already installed.
            //

            CheckDlgButton( hDlg, FONT_CONVERT_PS, FALSE );
            EnableWindow( GetDlgItem( hDlg, FONT_CONVERT_PS ) , FALSE );
        }

        if( pt1ops->bOnlyPSInstalled )
        {
            //
            //  If the PostScript version of this font is already
            //  installed, then we gray out the options to re-install
            //  the PostScript version of font, but continue to allow
            //  the User to convert it to TT.
            //

            CheckDlgButton( hDlg, FONT_INSTALL_PS, 0 );

            EnableWindow( GetDlgItem( hDlg, FONT_INSTALL_PS ) , FALSE );

            CheckDlgButton( hDlg, FONT_COPY_PS, 0 );

            EnableWindow( GetDlgItem( hDlg, FONT_COPY_PS ) , FALSE );
        }
        else
        {
            //
            //  PostScript version of font is not installed.  Set
            //  state of "INSTALL" and "COPY" checkboxes based on
            //  global state of "INSTALL"
            //

            CheckDlgButton( hDlg, FONT_INSTALL_PS, bInstallPS );

            CheckDlgButton( hDlg, FONT_COPY_PS, bCopyPS );

            EnableWindow( GetDlgItem( hDlg, FONT_COPY_PS ) , bInstallPS );

        }

        //
        //  Save the modeless dlg window handle for reactivation
        //

        hwndActive = GetActiveWindow( );
        break;


    case WM_COMMAND:
        switch( LOWORD( wParam ) )
        {
        case FONT_INSTALL_PS:
            if( HIWORD( wParam )  != BN_CLICKED )
                break;

            //
            // Get state of "INSTALL" checkbox
            //

            iButtonChecked = IsDlgButtonChecked( hDlg, LOWORD( wParam ) );

            //
            // A disabled checkbox is same as "No Install" selection
            //

            if( iButtonChecked != 1 )
                iButtonChecked = 0;

            //
            //  Enable or disable "COPY" control based on state of
            //  "INSTALL" checkbox.  Also, initialize it.
            //

            EnableWindow( GetDlgItem( hDlg, FONT_COPY_PS ) , iButtonChecked );

            if( iButtonChecked )
                CheckDlgButton( hDlg, FONT_COPY_PS, bCopyPS );

            break;


        case IDD_HELP:
            goto DoHelp;

        case IDYES:
        case IDD_YESALL:
            bConvertPS =
            bInstallPS = FALSE;

            if( IsDlgButtonChecked( hDlg, FONT_CONVERT_PS )  == 1 )
                bConvertPS = TRUE;

            if( IsDlgButtonChecked( hDlg, FONT_INSTALL_PS )  == 1 )
                bInstallPS = TRUE;

            //
            //  This is checked twice because it could be disabled,
            //  in which case we leave the previous state alone.
            //

            if( IsDlgButtonChecked( hDlg, FONT_COPY_PS )  == 1 )
                bCopyPS = TRUE;

            if( IsDlgButtonChecked( hDlg, FONT_COPY_PS )  == 0 )
                bCopyPS = FALSE;

            //
            //  Fall thru...
            //

        case IDNO:
        case IDCANCEL:
            //
            //  Reset the active window to "Install Font Progress" modeless dlg
            //

            if( hwndActive )
            {
                SetActiveWindow( hwndActive );
                hwndActive = NULL;
            }

            EndDialog( hDlg, LOWORD( wParam ) );
            break;

        default:
            return FALSE;
        }
        break;

    default:
DoHelp:

#ifdef PS_HELP
//
// FIXFIX [stevecat] Enable help
        if( nMsg == wHelpMessage )
        {
DoHelp:
            CPHelp( hDlg );
            return TRUE;
        }
        else
#endif  //  PS_HELP

            return FALSE;
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//
// RemoveDecoration
//
//  Deletes the "(TrueType)" or "(PostScript)" postfix string from the end
//  of a font name.  Optionally it will also remove the trailing space.
//
//  NOTE:  This function modifies the string passed into the function.
//
/////////////////////////////////////////////////////////////////////////////

void RemoveDecoration( LPTSTR pszDesc, BOOL bDeleteTrailingSpace )
{
    LPTSTR lpch;

    //
    //  Remove any postfix strings like "(PostScript)" or "(TrueType)"
    //

    if( lpch = _tcschr( pszDesc, TEXT('(') ) )
    {
        //
        //  End string at <space> before "("
        //

        if( bDeleteTrailingSpace )
            lpch--;

        *lpch = CHAR_NULL;
    }

    return ;
}

/////////////////////////////////////////////////////////////////////////////
//
// CheckT1Install
//
//  Checks the Type1 fonts location in registry to see if this font is or
//  has been previously installed as a "PostScript" font.  Optionally, it
//  will return the data for the "szData" value if it finds a matching entry.
//
//  Assumes "szData" buffer is of least size T1_MAX_DATA.
//
/////////////////////////////////////////////////////////////////////////////

BOOL CheckT1Install( LPTSTR pszDesc, LPTSTR pszData )
{
    TCHAR  szTemp[ PATHMAX ] ;
    DWORD  dwSize;
    DWORD  dwType;
    HKEY   hkey;
    BOOL   bRet = FALSE;


    hkey = NULL;

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE,        // Root key
                      g_szType1Key,              // Subkey to open
                      0L,                        // Reserved
                      KEY_READ,                  // SAM
                      &hkey )                    // return handle
            == ERROR_SUCCESS )
    {
        //
        //  Remove any postfix strings like "PostScript" or "TrueType"
        //

        lstrcpy( szTemp, pszDesc );

        RemoveDecoration( szTemp, TRUE );

        dwSize = (DWORD)(pszData ? T1_MAX_DATA * sizeof( TCHAR ) : 0);

        if( RegQueryValueEx( hkey, szTemp, NULL, &dwType,
                             (LPBYTE)  pszData, &dwSize )
                ==  ERROR_SUCCESS )
        {
            bRet = ( dwType == REG_MULTI_SZ );
        }
        else
        {
            bRet = FALSE;
        }

        RegCloseKey( hkey );
    }

    return bRet;
}


/////////////////////////////////////////////////////////////////////////////
//
// AddSystemPath
//
//  Add "System" path to a naked file name, if no path currently exists
//  on the filename.  Assumes pszFile buffer is at least PATHMAX chars in
//  length.
//
/////////////////////////////////////////////////////////////////////////////

void AddSystemPath( LPTSTR pszFile )
{
    TCHAR  szPath[ PATHMAX ] ;

    //
    //  Add "system" path, if no path present on file
    //

    lstrcpy( szPath, pszFile );

    StripFilespec( szPath );

    if( szPath[ 0 ]  == CHAR_NULL )
    {
        lstrcpy( szPath, s_szSharedDir );
        lpCPBackSlashTerm( szPath );
        lstrcat( szPath, pszFile );
        lstrcpy( pszFile, szPath );
    }

    return ;
}

/////////////////////////////////////////////////////////////////////////////
//
// ExtractT1Files
//
//  Extracts file names from a REG_MULTI_SZ (multi-string)  array that is
//  passed into this routine.  The output strings are expected to be at
//  least PATHMAX in size.  A "" (NULL string)  indicates that a filename
//  string was not present.  This should only happen for the PFB filename
//  argument.
//
/////////////////////////////////////////////////////////////////////////////

BOOL ExtractT1Files( LPTSTR pszMulti, LPTSTR pszPfmFile, LPTSTR pszPfbFile )
{
    LPTSTR pszPfm;
    LPTSTR pszPfb;

    if( !pszMulti )
        return FALSE;

    if( ( pszMulti[ 0 ]  != CHAR_TRUE )  && ( pszMulti[ 0 ]  != CHAR_FALSE ) )
        return FALSE;

    //
    //  .Pfm file should always be present
    //

    pszPfm = pszMulti + lstrlen( pszMulti ) + 1;

    lstrcpy( pszPfmFile, pszPfm );

    //
    //  Add "system" path, if no path present on files
    //

    AddSystemPath( pszPfmFile );

    //
    //  Check to see if .pfb filename is present
    //

    if( pszMulti[ 0 ]  == CHAR_TRUE )
    {
        pszPfb = pszPfm + lstrlen( pszPfm )  + 1;
        lstrcpy( pszPfbFile, pszPfb );

        //
        //  Add "system" path, if no path present on files
        //

        AddSystemPath( pszPfbFile );
    }
    else
    {
        pszPfbFile[ 0 ]  = CHAR_NULL;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//
// DeleteT1Install
//
//  Deletes a Type1 entry from the registry and optionally the files pointed
//  to in the data strings.
//
/////////////////////////////////////////////////////////////////////////////

BOOL DeleteT1Install( HWND hwndParent, LPTSTR pszDesc, BOOL bDeleteFiles )
{
    TCHAR  szTemp[ PATHMAX ] ;
    TCHAR  szTemp2[ T1_MAX_DATA ] ;
    TCHAR  szPfmFile[ PATHMAX ] ;
    TCHAR  szPfbFile[ PATHMAX ] ;
    TCHAR  szPath[ PATHMAX ] ;
    DWORD  dwSize;
    DWORD  dwType;
    HKEY   hkey;
    BOOL   bRet = FALSE;

    hkey = NULL;

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE,        // Root key
                      g_szType1Key,              // Subkey to open
                      0L,                        // Reserved
                      (KEY_READ | KEY_WRITE),    // SAM
                      &hkey )                    // return handle
            == ERROR_SUCCESS )
    {
        //
        //  Remove any postfix strings like "PostScript" or "TrueType"
        //

        lstrcpy( szTemp, pszDesc );

        RemoveDecoration( szTemp, TRUE );

        if( bDeleteFiles )
        {
            dwSize = sizeof( szTemp2 );

            if( RegQueryValueEx( hkey, szTemp, NULL, &dwType,
                                 (LPBYTE )  szTemp2, &dwSize )
                    ==  ERROR_SUCCESS )
            {
                if( ExtractT1Files( szTemp2, szPfmFile, szPfbFile ) )
                {
                    //
                    //  Delete the files
                    //
//                    if( DelSharedFile( hDlg, szTemp, szPfbFile, szPath, TRUE ) )
//                        DelSharedFile( hDlg, szTemp, szPfmFile, szPath, FALSE );
//
                    vCPDeleteFromSharedDir( szPfbFile );
                    vCPDeleteFromSharedDir( szPfmFile );
                }
                else
                {
                    //  ERROR! Cannot get file names from string
                    goto RemoveT1Error;
                }
            }
            else
            {
                goto RemoveT1Error;
            }
        }

        if( RegDeleteValue( hkey, szTemp )  != ERROR_SUCCESS )
        {
RemoveT1Error:

            //
            //  ERROR! Put up message box
            //

            iUIMsgOkCancelExclaim( hwndParent,
                                   MYFONT + 1,
                                   IDS_MSG_CAPTION,
                                   (LPTSTR ) szTemp );

            bRet = FALSE;
        }
        else
        {
            bRet = TRUE;
        }

        RegCloseKey( hkey );
    }

    return bRet;
}


/////////////////////////////////////////////////////////////////////////////
//
// GetT1Install
//
//  Gets a Type1 entry information from the registry into the files pointed
//  to in the data strings.
//
/////////////////////////////////////////////////////////////////////////////

BOOL GetT1Install( LPTSTR pszDesc, LPTSTR pszPfmFile, LPTSTR pszPfbFile )
{
    TCHAR  szTemp2[ T1_MAX_DATA ] ;
    BOOL   bRet = FALSE;


    if( CheckT1Install( pszDesc, szTemp2 ) )
    {
        bRet = ExtractT1Files( szTemp2, pszPfmFile, pszPfbFile );
    }

    return bRet;
}


/////////////////////////////////////////////////////////////////////////////
//
// CheckTTInstall
//
//  Check FONTS location in registry to see if this font has already
//  been installed.
//
/////////////////////////////////////////////////////////////////////////////

BOOL CheckTTInstall( LPTSTR szDesc )
{
    TCHAR szTemp[ PATHMAX ] ;
    TCHAR szTemp2[ PATHMAX ] ;

    //
    //  Change description string to have TrueType instead of
    //  PostScript and then check if it is already installed.
    //

    lstrcpy( szTemp, szDesc );

    RemoveDecoration( szTemp, TRUE );

    wsprintf( szTemp, c_szDescFormat, szTemp, c_szTrueType );

    if( GetProfileString( szFonts, szTemp, szNull, szTemp2, ARRAYSIZE( szTemp2 ) ) )
        return TRUE;

    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
//
// WriteType1RegistryEntry
//
//  Create registry entry for this PostScript font by writing the path of
//  both the .PFM and .PFB files.
//
//  NOTE:  Checks global "bCopyPS" to determine if files have been copied
//         to the local shared directory.  In that case, the path info is
//         stripped from the file names passed into routine.
//
/////////////////////////////////////////////////////////////////////////////

int WriteType1RegistryEntry( HWND hwndParent,
                             LPTSTR szDesc,         // Font name description
                             LPTSTR szPfmName,      // .PFM filename
                             LPTSTR szPfbName,      // .PFB filename
                             BOOL   bInFontsDir )   // Files in fonts dir?
{
    TCHAR  szTemp[ 2*PATHMAX+6 ] ;
    TCHAR  szTemp2[ PATHMAX ] ;
    TCHAR  szClass[ PATHMAX ] ;
    DWORD  dwSize;
    DWORD  dwDisposition;
    HKEY   hkey = NULL;

    //
    //  Must have a Font description to store information in registry
    //

    if( !szDesc || !szPfmName )
        return TYPE1_INSTALL_IDNO;

    //
    //  Try to create the key if it does not exist or open existing key.
    //

    if( RegCreateKeyEx( HKEY_LOCAL_MACHINE,        // Root key
                        g_szType1Key,              // Subkey to open/create
                        0L,                        // Reserved
                        szClass,                   // Class string
                        0L,                        // Options
                        KEY_WRITE,                 // SAM
                        NULL,                      // ptr to Security struct
                        &hkey,                     // return handle
                        &dwDisposition )           // return disposition
            == ERROR_SUCCESS )
    {
        //
        //  Create REG_MULTI_SZ string to save in registry
        //
        //  X <null> [path]zzzz.pfm <null> [path]xxxxx.pfb <null><null>
        //
        //  Where X == T(rue )  if .pfb file present
        //

        lstrcpy( szTemp, szPfbName ? szTrue : szFalse );
        lstrcat( szTemp, szHash );

        if( bInFontsDir )
            StripPath( szPfmName );

        lstrcat( szTemp, szPfmName );
        lstrcat( szTemp, szHash );

        if( szPfbName )
        {
            if( bInFontsDir )
                StripPath( szPfbName );

            lstrcat( szTemp, szPfbName );
            lstrcat( szTemp, szHash );
        }

        lstrcat( szTemp, szHash );

        dwSize = lstrlen( szTemp ) * sizeof( TCHAR );

        //
        //  Now convert string to multi-string
        //

        vHashToNulls( szTemp );

        //
        //  Create Registry Value name to store info under by
        //  removing any postfix strings like "Type 1" or
        //  "TrueType" from Font description string.
        //

        lstrcpy( szTemp2, szDesc );

        RemoveDecoration( szTemp2, TRUE );

        if( RegSetValueEx( hkey, szTemp2, 0L, REG_MULTI_SZ,
                            (LPBYTE) szTemp, dwSize )
                != ERROR_SUCCESS )
        {
            goto WriteRegError;
        }

        RegCloseKey( hkey );
    }
    else
    {
WriteRegError:

        //
        //  Put up a message box error stating that the USER does
        //  not have the permission necessary to install type1
        //  fonts.
        //

        if( hkey )
            RegCloseKey( hkey );

        return( iUIMsgBox( hwndParent,
                           MYFONT + 9, IDS_MSG_CAPTION,
                           MB_OKCANCEL | MB_ICONEXCLAMATION,
                           (LPTSTR) szDesc,
                           (LPTSTR) g_szType1Key ) );
    }

    return TYPE1_INSTALL_IDOK;
}


#ifdef NOTUSED

/////////////////////////////////////////////////////////////////////////////
//
// EnumType1Fonts
//
//  List all of the Type 1 fonts installed in the registry, check for
//  TrueType installation and put Postscript-only installed fonts in
//  the "Installed Fonts" list box.
//
//  This routine assumes that the TrueType descriptions are already
//  displayed in the "Installed Fonts" listbox.
//
/////////////////////////////////////////////////////////////////////////////

BOOL EnumType1Fonts( HWND hLBox )
{
    int    i, j;
    DWORD  dwSize;
    DWORD  dwPathMax;
    DWORD  dwType;
    HKEY   hkey;
    LPTSTR pszDesc;
    LPTSTR pszFontName;
    BOOL   bRet = FALSE;


    //////////////////////////////////////////////////////////////////////
    //  Get some storage
    //////////////////////////////////////////////////////////////////////

    pszFontName =
    pszDesc     = NULL;

    dwPathMax = PATHMAX * sizeof( TCHAR );

    pszFontName = (LPTSTR) AllocMem( dwPathMax );

    pszDesc = (LPTSTR) AllocMem( dwPathMax );

    if( !pszDesc || !pszFontName )
        goto EnumType1Exit;


    //////////////////////////////////////////////////////////////////////
    //  Get list of installed Type 1 fonts
    //////////////////////////////////////////////////////////////////////

    hkey = NULL;

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE,       // Root key
                      g_szType1Key,             // Subkey to open
                      0L,                       // Reserved
                      KEY_READ,                 // SAM
                      &hkey )                   // return handle
            == ERROR_SUCCESS )
    {
        dwSize = dwPathMax;
        i = 0;

        while( RegEnumValue( hkey, i++, pszFontName, &dwSize, NULL,
                             &dwType, (LPBYTE)  NULL, NULL )
                    == ERROR_SUCCESS )
        {
            if( dwType != REG_MULTI_SZ )
                continue;

            wsprintf( pszDesc, c_szDescFormat, pszFontName, c_szPostScript );

            //
            //  Check to see if TrueType version is already installed
            //

            if( CheckTTInstall( pszDesc ) )
            {
                //
                //  Find matching  "xxxxx (TrueType)" entry and change its
                //  ItemData to IF_TYPE1_TT
                //

                wsprintf( pszDesc, c_szDescFormat, pszFontName, c_szTrueType );

                j = SendMessage( hLBox, LB_FINDSTRINGEXACT, (WPARAM)  -1,
                                                             (LONG) pszDesc );

                if( j != LB_ERR )
                    SendMessage( hLBox, LB_SETITEMDATA, j, (LONG)  IF_TYPE1_TT );

                // else
                    // ERROR! We should have found a matching LB entry for this
                    //        font based on TT name.
            }
            else
            {
                //
                //  Put Font name string in ListBox
                //

                j = SendMessage( hLBox, LB_ADDSTRING, 0, (LONG) pszDesc );

                if( j != LB_ERR )
                    SendMessage( hLBox, LB_SETITEMDATA, j, (LONG)  IF_TYPE1 );
                // else
                    // ERROR! We found an installed Type1 font but cannot show
                    //        it in listbox because of USER error.
            }

            dwSize = dwPathMax;
        }

        bRet = TRUE;

        RegCloseKey( hkey );
    }

EnumType1Exit:

    if( pszDesc )
        FreeMem( pszDesc, dwPathMax );

    if( pszFontName )
        FreeMem( pszFontName, dwPathMax );

    return bRet;
}

#endif  //  NOTUSED


/////////////////////////////////////////////////////////////////////////////
//
// InitProgress
//
//  Create and initialize the Progress dialog.  Initial state is visible.
//
/////////////////////////////////////////////////////////////////////////////

HWND InitProgress( HWND hwnd )
{
    if( NULL == hDlgProgress )
    {
        RegisterProgressClass( );

        hDlgProgress = CreateDialog( g_hInst, MAKEINTRESOURCE( DLG_PROGRESS ) ,
                                     hwnd ? hwnd :HWND_DESKTOP,
                                     ProgressDlg );
    }

    return hDlgProgress;
}


/////////////////////////////////////////////////////////////////////////////
//
// TermProgress
//
//  Remove and cleanup after the Progress dialog.
//
/////////////////////////////////////////////////////////////////////////////

void TermProgress( )
{
    if( hDlgProgress )
    {
        DestroyWindow( hDlgProgress );
        UnRegisterProgressClass( );
    }

    hDlgProgress = NULL;

    return;
}


/////////////////////////////////////////////////////////////////////////////
//
// cpProgressYield
//
//  Allow other messages including Dialog messages for Modeless dialog to be
//  processed while we are converting Type1 files to TrueType.
//
//  Since the font conversion is done on a single thread( in order to keep it
//  synchronous with installation of all fonts )  we need to provide a mechanism
//  that will allow a user to Cancel out of the operation and also allow
//  window messages, like WM_PAINT, to be processed by other Window Procedures.
//
/////////////////////////////////////////////////////////////////////////////

VOID cpProgressYield( )
{
    MSG msg;

    while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
    {
//        if( !hDlgProgress || !IsDialogMessage( hDlgProgress, &msg ) )
        if( !IsDialogMessage( hDlgProgress, &msg ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// UpdateProgress
//
//   Set the overall progress control in Progress Dialog, along with a
//   message describing installation progress.
//
/////////////////////////////////////////////////////////////////////////////

void UpdateProgress( int iTotalCount, int iFontInstalling, int iProgress )
{
    TCHAR szTemp[ 120 ] ;

    wsprintf( szTemp, m_szMsgBuf, iFontInstalling, iTotalCount );

    SetDlgItemText( hDlgProgress, ID_INSTALLMSG, szTemp );

        SendDlgItemMessage( hDlgProgress, ID_OVERALL, SET_PROGRESS,
                        (int) iProgress, 0L );

    //
    //  Process outstanding messages
    //

    cpProgressYield( );
}


/////////////////////////////////////////////////////////////////////////////
//
// ResetProgress
//
//   Clear the progress bar control and reset message to NULL
//
/////////////////////////////////////////////////////////////////////////////

void ResetProgress(  )
{
    SetDlgItemText( hDlgProgress, ID_PROGRESSMSG, szNull );

    SendDlgItemMessage( hDlgProgress, ID_BAR, SET_PROGRESS, (int) 0, 0L );

    bProgMsgDisplayed = FALSE;

    bProg2MsgDisplayed = FALSE;

    //
    //  Process outstanding messages
    //

    cpProgressYield( );
}


BOOL InstallCancelled(void)
{
    return bCancelInstall;
}


/////////////////////////////////////////////////////////////////////////////
//
// Progress
//
//   Progress function for ConvertTypefaceA - Adobe Type1 to TrueType font
//   file converter.  Put up progress in converting font and message
//   describing font being converted.
//
/////////////////////////////////////////////////////////////////////////////

void STDCALL Progress( short PercentDone, void* UniqueValue )
{
    TCHAR szTemp[ 120 ] ;
    TCHAR szTemp2[ 120 ] ;
    DWORD err = GetLastError( ); // save whatever t1instal may have set

    //
    //  UniqueValue is a pointer to the string name of the file being
    //  converted.  Only put this message up if not previously displayed.
    //

    if( !bProgMsgDisplayed )
    {
        LPCTSTR args[] = { (LPCTSTR)UniqueValue };

        LoadString( g_hInst, MYFONT + 6, szTemp2, ARRAYSIZE( szTemp2 ) );
        FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szTemp2,
                      0,
                      0,
                      szTemp,
                      ARRAYSIZE(szTemp),
                      (va_list *)args);

        SetDlgItemText( hDlgProgress, ID_PROGRESSMSG, szTemp );

        bProgMsgDisplayed = TRUE;
    }

        SendDlgItemMessage( hDlgProgress, ID_BAR, SET_PROGRESS,
                        (int) PercentDone, 0L );

    //
    //  Process outstanding messages
    //

    cpProgressYield( );

    //
    //  reset last error to whatever t1instal set it to:
    //

    SetLastError( err );
}


/////////////////////////////////////////////////////////////////////////////
//
// Progress2
//
//   Progress function for updating progress dialog controls on a per font
//   install basis.
//
/////////////////////////////////////////////////////////////////////////////

void Progress2( int PercentDone, LPTSTR pszDesc )
{
    TCHAR szTemp[ PATHMAX ] ;
    TCHAR szTemp2[ 240 ] ;

    //
    //  szDesc is a pointer to the string name of the file being installed.
    //  Only put this message up if not previously displayed.

    if( !bProg2MsgDisplayed )
    {
        LPCTSTR args[] = { pszDesc };

        LoadString( g_hInst, MYFONT + 11, szTemp2, ARRAYSIZE( szTemp2 ) );
        FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szTemp2,
                      0,
                      0,
                      szTemp,
                      ARRAYSIZE(szTemp),
                      (va_list *)args);

        SetDlgItemText( hDlgProgress, ID_PROGRESSMSG, szTemp );

        bProg2MsgDisplayed = TRUE;
    }

        SendDlgItemMessage( hDlgProgress, ID_BAR, SET_PROGRESS, (int) PercentDone, 0L );

    //
    //  Process outstanding messages
    //

    cpProgressYield( );
}


/////////////////////////////////////////////////////////////////////////////
//
// ProgressDlg
//
//  Display progress messages to user based on progress in converting
//  font files to TrueType
//
/////////////////////////////////////////////////////////////////////////////

INT_PTR APIENTRY ProgressDlg( HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam )
{

    switch( nMsg )
    {

    case WM_INITDIALOG:
        CentreWindow( hDlg );

        //
        //  Load in Progress messages
        //

        LoadString( g_hInst, MYFONT + 10, m_szMsgBuf, ARRAYSIZE( m_szMsgBuf ) );

        EnableWindow( hDlg, TRUE );
        bCancelInstall = FALSE;
        break;

    case WM_COMMAND:
        switch( LOWORD( wParam ) )
        {

        case IDOK:
        case IDCANCEL:
            bCancelInstall = ( LOWORD( wParam )  == IDCANCEL );
            //
            // Dialog is destroyed programmatically after font is installed.
            // See TermProgress( )
            //
            break;

        default:
            return FALSE;
        }
        break;

    case WM_DESTROY:
        bCancelInstall = FALSE;
        break;

    default:
        return FALSE;
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//
// ProgressBarCtlProc
//
//  Window Procedure for the Progress Bar custom control.  Handles all
//  messages like WM_PAINT just as a normal application window would.
//
/////////////////////////////////////////////////////////////////////////////

LRESULT APIENTRY ProgressBarCtlProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    DWORD dwProgress;

    dwProgress = (DWORD)GetWindowLong( hWnd, GWL_PROGRESS );

    switch( message )
    {
    case WM_CREATE:
        dwProgress = 0;

        SetWindowLong( hWnd, GWL_PROGRESS, (LONG)dwProgress );

        break;

    case SET_PROGRESS:
        SetWindowLong( hWnd, GWL_PROGRESS, (LONG) wParam );

        InvalidateRect( hWnd, NULL, FALSE );

        UpdateWindow( hWnd );

        break;


    case WM_ENABLE:
        //
        //  Force a repaint since the control will look different.
        //

        InvalidateRect( hWnd, NULL, TRUE );

        UpdateWindow( hWnd );

        break;


    case WM_PAINT:
        return ProgressPaint( hWnd, dwProgress );


    default:
        return( DefWindowProc( hWnd, message, wParam, lParam ) );

        break;
    }
    return( 0L );
}


/////////////////////////////////////////////////////////////////////////////
//
// RegisterProgressClass
//
//
/////////////////////////////////////////////////////////////////////////////

BOOL RegisterProgressClass( void )
{
    WNDCLASS wcTest;

    wcTest.lpszClassName = TEXT( "cpProgress" );
    wcTest.hInstance     = (HINSTANCE) g_hInst;
    wcTest.lpfnWndProc   = ProgressBarCtlProc;
    wcTest.hCursor       = LoadCursor( NULL, IDC_WAIT );
    wcTest.hIcon         = NULL;
    wcTest.lpszMenuName  = NULL;
    wcTest.hbrBackground = (HBRUSH) IntToPtr( rgColorPro[ PROGRESSCOLOR_WINDOW ] );
    wcTest.style         = CS_HREDRAW | CS_VREDRAW;
    wcTest.cbClsExtra    = 0;
    wcTest.cbWndExtra    = sizeof( DWORD );

    //
    //  Set Bar color to Blue and text color to white
//
// [stevecat]  Let's make these follow the window title bar color and text
//             color.  Just make the USER calls to get these colors.  This
//             will make it look better with different color schemes and the
//             Theme packs.
//
    //

//    rgbBG = RGB(   0,   0, 255 );
//    rgbFG = RGB( 255, 255, 255 );

    rgbBG = GetSysColor( rgColorPro[ PROGRESSCOLOR_BAR ] );
    rgbFG = GetSysColor( rgColorPro[ PROGRESSCOLOR_TEXT ] );

    return( RegisterClass( (LPWNDCLASS) &wcTest ) );
}


/////////////////////////////////////////////////////////////////////////////
//
// UnRegisterProgressClass
//
//
/////////////////////////////////////////////////////////////////////////////

VOID UnRegisterProgressClass( void )
{
    UnregisterClass( TEXT( "cpProgress" ), (HINSTANCE) g_hInst );
}


/////////////////////////////////////////////////////////////////////////////
//
// ProgressPaint
//
// Description:
//
//  Handles all WM_PAINT messages for the control and paints
//  the control for the progress state.
//
// Parameters:
//  hWnd            HWND Handle to the control.
//  dwProgress      DWORD Progress amount - between 1 and 100
//
// Return Value:
//  LONG            0L.
//
//
//  This is an alternate way to do the progress bar in the control.  Instead
//  of drawing a rectangle, it uses ExtTextOut to draw the opagueing rect
//  based on the percentage complete.  Clever.
//
/////////////////////////////////////////////////////////////////////////////

LONG ProgressPaint( HWND hWnd, DWORD dwProgress )
{
    PAINTSTRUCT ps;
    HDC         hDC;
    TCHAR       szTemp[ 20 ] ;
    int         dx, dy, len;
    RECT        rc1, rc2;
    SIZE        Size;


    hDC = BeginPaint( hWnd, &ps );

    GetClientRect( hWnd, &rc1 );

    FrameRect( hDC, &rc1, (HBRUSH) GetStockObject( BLACK_BRUSH ) );

    InflateRect( &rc1, -1, -1 );

    rc2 = rc1;

    dx = rc1.right;
    dy = rc1.bottom;

    if( dwProgress == 100 )
        rc1.right = rc2.left = dx;
    else
        rc1.right = rc2.left = ( dwProgress * dx / 100 ) + 1;

    //
    //  Boundary condition testing
    //

    if( rc2.left > rc2.right )
        rc2.left = rc2.right;

    len = wsprintf( szTemp, TEXT( "%3d%%" ), dwProgress );

    GetTextExtentPoint32( hDC, szTemp, len, &Size );

    SetBkColor( hDC, rgbBG );
    SetTextColor( hDC, rgbFG );

    ExtTextOut( hDC, ( dx - Size.cx ) / 2, ( dy - Size.cy ) / 2,
                ETO_OPAQUE | ETO_CLIPPED, &rc1, szTemp, len, NULL );

    SetBkColor( hDC, rgbFG );
    SetTextColor( hDC, rgbBG );

    ExtTextOut( hDC, ( dx - Size.cx ) / 2, ( dy - Size.cy ) / 2,
                ETO_OPAQUE | ETO_CLIPPED, &rc2, szTemp, len, NULL );

    EndPaint( hWnd, &ps );

    return 0L;

}

//
// Creates a resource name string suitable for calling AddFontResource for a
// Type1 font.  The resulting resource string is in the following format:
//
//      <path to pfm>|<path to pfb>
//
// Returns: TRUE  = String was created.
//          FALSE = Caller passed a NULL pointer or destination buffer is too small.
//
BOOL BuildType1FontResourceName(LPCTSTR pszPfm, LPCTSTR pszPfb, LPTSTR pszDest, DWORD cchDest)
{
    BOOL bResult = FALSE;

    if (NULL != pszDest && pszPfm != NULL && pszPfb != NULL)
    {
        *pszDest = TEXT('\0');

        //
        // Make sure dest buffer has room for both paths plus separator and term nul.
        //
        if ((lstrlen(pszPfm) + lstrlen(pszPfb) + 2) < (INT)cchDest)
        {
            wsprintf(pszDest, TEXT("%s|%s"), pszPfm, pszPfb);
            bResult = TRUE;
        }
    }
    return bResult;
}

#endif  //  WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\src\uimsg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// uimsg.cpp
//      Explorer Font Folder extension routines.
//    Message box and status box routines.
//    These routines are all vUIPStatusXXX and iUIMsgXXX
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//     $keywords: uimsg.cpp 1.3 22-Mar-94 1:26:04 PM$
//
//***************************************************************************
// $lgb$
// 1.0     7-Mar-94 eric Initial revision.
// 1.1     9-Mar-94 eric Added Mutex locks for GDI.
// 1.2    17-Mar-94 eric removed references to mutex.
// 1.3    22-Mar-94 eric Removed MFC toolbar code (it was already ifdef'd
//                       out)
// $lge$
//*************************************************************************** 
//
//  Copyright (C) 1992-1993 ElseWare Corporation.  All rights reserved.
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>

#include "resource.h"
#include "ui.h"
#include "dbutl.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

//
//  Types
//

typedef TCHAR STATTEXT[ 128 ];
typedef TCHAR MSGTEXT [ 256 ];

//
//  Globals - these are shared throughout the system for
//            debugging purposes only.
//

BOOL  g_bTrace = FALSE;
BOOL  g_bDiag  = FALSE;

static BOOL  s_bIsStatClear = FALSE;
static BOOL  s_bStatPushed  = FALSE;

// static STATTEXT s_szStatTxtStack;

#if 1

#define STRING_BUF   256
// static TCHAR  s_szStatTxtStack[ STRING_BUF ];
static TCHAR  s_szMemDiag[ STRING_BUF ];     // Text for memory limit
static TCHAR  s_szMemCaption[ STRING_BUF ];  // Caption for memory limit message

#else

static CString  s_szStatTxtStack;
static CString  s_szMemDiag;            // Text for memory limit
static CString  s_szMemCaption;         // Caption for memory limit message

#endif

// -----------------------------------------------------------------------
// -------- Remove the Status stuff. It doesn' work in the Shell ---------
// -----------------------------------------------------------------------
#if 0 
// const int kStatusPane = 0;             // Which pane to put the text in.

//
//  Module-global routines
//

void FAR PASCAL vUIPStatusPushHelp( int Status, int Help )
{ vUIPStatusPush  (Status ); };


/***************************************************************************
 * FUNCTION: vUIPStatusClear
 *
 * PURPOSE:  If not already clear, re-clear the status line.
 *
 * RETURNS:  Nothing.
 ***************************************************************************/

void FAR PASCAL vUIPStatusClear( )
{
    if( !s_bIsStatClear )
    {
        pUIPStatusGetWindow( )->SendMessage( SB_SETTEXT, 0,
                                             (LONG)(LPTSTR)TEXT( "" ) );

        pUIPStatusGetWindow( )->UpdateWindow( );

        s_bIsStatClear = TRUE;
   }
}


/***************************************************************************
 * FUNCTION: vUIPStatusPush
 *
 * PURPOSE:  Save the current status message string and then display the
 *           new one.  When 'pop' is called we will restore the current
 *           message.
 *              The 'stack' has a depth of one message.
 *
 * RETURNS:  Nothing.
 ***************************************************************************/

void FAR PASCAL vUIPStatusPush( WORD wIDStr )
{
    //
    //  If don't already have something pushed on our tiny stack, get the
    //  current status text window contents and push that.
    //

    if( !s_bStatPushed )
    {
        s_szStatTxtStack = TEXT( "" );

        pUIPStatusGetWindow( )->SendMessage( SB_GETTEXT, 0,
                            (LONG)(LPTSTR)s_szStatTxtStack.GetBuffer( 255 ) );

        s_szStatTxtStack.ReleaseBuffer( );

        s_bStatPushed = TRUE;
    }

    //
    //  Regardless of whether we actually pushed, show the input text.
    //

    vUIPStatusShow( wIDStr );
}


/***************************************************************************
 * FUNCTION: vUIPStatusPop
 *
 * PURPOSE:  Restore any previously 'push'ed status message
 *              The 'stack' has a depth of one message.
 *
 * RETURNS:  Nothing.
 ***************************************************************************/

void FAR PASCAL vUIPStatusPop( )
{
    if( s_bStatPushed )
    {
        pUIPStatusGetWindow( )->SendMessage( SB_SETTEXT, 0,
                            (LPARAM)(LPTSTR)s_szStatTxtStack.GetBuffer( 255 ) );

        s_szStatTxtStack.ReleaseBuffer( );

        pUIPStatusGetWindow( )->UpdateWindow( );

        s_bIsStatClear = FALSE;
        s_bStatPushed    = FALSE;
   }
}


/***************************************************************************
 * FUNCTION: vUIPStatusShow
 *
 * PURPOSE:  Format a string for the status box and show it.
 *
 * RETURNS:  Nothing.
 ***************************************************************************/

void FAR PASCAL vUIPStatusShow( WORD wIDStr, PTSTR wArg1, PTSTR wArg2,
                                                          PTSTR wArg3 )
{
    // CString    cMessage;

    TCHAR    cMessage[ STRING_BUF ];
    STATTEXT szStatLine;

    //
    //  No string ID means clear the box.
    //

    if( !wIDStr )
    {
        vUIPStatusClear( );
    }
    else if( !cMessage.LoadString( wIDStr ) )
    {
        //
        //  Load the message text - if this fails, clear the box
        //

        vUIPStatusClear( );
    }
    else if( _snprintf( szStatLine, sizeof( szStatLine ),
                        cMessage, wArg1, wArg2, wArg3 ) )
    {
        //
        // All okay, Format and display the message.
        //

        pUIPStatusGetWindow( )->SendMessage( SB_SETTEXT, 0,
                                             (LPARAM)(LPTSTR)szStatLine );

        pUIPStatusGetWindow( )->UpdateWindow( );
    
        s_bIsStatClear = FALSE;
   }
}
#endif

// -----------------------------------------------------------------------
// -------- Remove the Status stuff. It doesn' work in the Shell ---------
// -----------------------------------------------------------------------

//
//  Although these are used but once, we load now since they're for
//  out-of-memory diagnostics, and we probably won't be able to load
//  them when needed.
//

VOID FAR PASCAL vUIMsgInit( )
{
    // s_szMemDiag.LoadString ( IDS_MSG_NSFMEM );
    // s_szMemCaption.LoadString ( IDS_MSG_CAPTION );

    LoadString( g_hInst, IDS_MSG_NSFMEM, s_szMemDiag, ARRAYSIZE( s_szMemDiag ) );

    LoadString( g_hInst, IDS_MSG_CAPTION, s_szMemCaption, ARRAYSIZE( s_szMemDiag ) );
}

/***************************************************************************
 * FUNCTION: iUIMsgBox
 *
 * PURPOSE:  Format a string and show a message box per the caller's
 *              MB_ settings.  There are several cover routines that
 *              set this up so it may be called more simply (see the header)
 *
 * RETURNS:  The function returns the result of the message box, or zero on
 *              failure (the message box function also returns zero on failure)
 ***************************************************************************/

int FAR PASCAL iUIErrMemDlg(HWND hwndParent)
{
    MessageBox( hwndParent, s_szMemDiag, s_szMemCaption,
                MB_OK | MB_ICONHAND | MB_SYSTEMMODAL | MB_SETFOREGROUND );

    return -1;
}


int FAR PASCAL iUIMsgBox( HWND hwndParent, WORD wIDStr, WORD wCAPStr, UINT uiMBFlags,
                          LPCTSTR wArg1, LPCTSTR wArg2, LPCTSTR wArg3, LPCTSTR wArg4 )
{
    // CString    cCaption;
    // CString    cMessage;

    TCHAR   cCaption[ STRING_BUF ];
    TCHAR   cMessage[ STRING_BUF ];
    MSGTEXT szMessage;
    int     iResult = 0;

    //
    //  Load the string and the message caption.    Then format the string,
    //  being careful about length, and show the (modal) message box.
    //

    if( wIDStr == IDS_MSG_NSFMEM )
        return iUIErrMemDlg(hwndParent);

    if( LoadString( g_hInst, wIDStr, cMessage, ARRAYSIZE( cMessage ) ) )
    {
        if( !LoadString( g_hInst, wCAPStr, cCaption, ARRAYSIZE( cCaption ) ) )
            cCaption[ 0 ] = 0;

        //
        //  If we have more than one string we have to format it for
        //

        LPCTSTR  args[ 4 ] = { wArg1, wArg2, wArg3, wArg4 };

        iResult = (int)FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                      | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      cMessage,
                                      0,
                                      0,
                                      szMessage,
                                      ARRAYSIZE( szMessage ),
                                      (va_list *) args
                                      );
        if(  iResult )
        {
            iResult = MessageBox( hwndParent, szMessage, cCaption,
                                  MB_TASKMODAL | MB_SETFOREGROUND | uiMBFlags );

            if( iResult == -1 )
                return iUIErrMemDlg(hwndParent);
        }
    }

    return iResult;
}


int FAR PASCAL iUIMsgBoxWithCaption(HWND hwndParent, WORD wIDStr, WORD wCaption )
{ return iUIMsgBox(hwndParent, wIDStr, wCaption, MB_OKCANCEL | MB_ICONEXCLAMATION ); };


int FAR PASCAL iUIMsgOkCancelExclaim(HWND hwndParent, WORD wIDStr, WORD wIdCap, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, wIdCap, MB_OKCANCEL | MB_ICONEXCLAMATION, wArg );};


int FAR PASCAL iUIMsgRetryCancelExclaim(HWND hwndParent, WORD wIDStr, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, IDS_MSG_CAPTION, MB_RETRYCANCEL | MB_ICONEXCLAMATION, wArg );};


int FAR PASCAL iUIMsgYesNoExclaim(HWND hwndParent, WORD wIDStr, WORD wIdCap, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, wIdCap, MB_YESNO | MB_ICONEXCLAMATION, wArg );};


int FAR PASCAL iUIMsgYesNoExclaim(HWND hwndParent, WORD wIDStr, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, IDS_MSG_CAPTION, MB_YESNO | MB_ICONEXCLAMATION, wArg );};


int FAR PASCAL iUIMsgExclaim(HWND hwndParent, WORD wIDStr, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, IDS_MSG_CAPTION, MB_OK | MB_ICONEXCLAMATION, wArg );};


int FAR PASCAL iUIMsgBox(HWND hwndParent, WORD wIDStr, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, IDS_MSG_CAPTION, MB_OK | MB_ICONHAND, wArg ); };


int FAR PASCAL iUIMsgInfo(HWND hwndParent, WORD wIDStr, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, IDS_MSG_CAPTION, MB_OK | MB_ICONINFORMATION, wArg ); };




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: vUIMsgBoxInvalidFont
//
// DESCRIP:  Displays a simple message box for errors encountered through
//           the following font folder functions:
//
//              IsPSFont
//              bCPValidType1Font
//              bIsValidFontFile
//              bIsTrueType
//
//           Font validation occurs in many places in the font folder.
//           This function was added to consolidate validation error reporting
//           and to ensure consistency when reporting these types of errors.
//
// ARGUMENTS:
//           pszFontFile
//              Name of font file being validated.
//
//           pszFontDesc
//              Descriptive name of font being validated.
//
//           dwType1Code
//              Code returned from one of the validation functions.
//              See IsPSFont for details.
//
//           uStyle
//              Message box style.  Defaults to MB_OKCANCEL | MB_ICONEXCLAMATION
//
///////////////////////////////////////////////////////////////////////////////
//
// Map font validation status codes to message box string resources.
//
static const struct str_id_map{
    BYTE code;          // Status portion of status code.
    DWORD idStr;        // Message format string resource id.
}StrIdMap[] = {
    { FVS_INVALID_FONTFILE,   IDS_FMT_FVS_INVFONTFILE },
    { FVS_BAD_VERSION,        IDS_FMT_FVS_BADVERSION  },
    { FVS_FILE_BUILD_ERR,     IDS_FMT_FVS_FILECREATE  },
    { FVS_FILE_EXISTS,        IDS_FMT_FVS_FILEEXISTS  },
    { FVS_FILE_OPEN_ERR,      IDS_FMT_FVS_FILEOPEN    },
    { FVS_FILE_CREATE_ERR,    IDS_FMT_FVS_FILECREATE  },
    { FVS_FILE_IO_ERR,        IDS_FMT_FVS_FILEIO      },
    { FVS_INVALID_ARG,        IDS_FMT_FVS_INTERNAL    },
    { FVS_EXCEPTION,          IDS_FMT_FVS_INTERNAL    },
    { FVS_INSUFFICIENT_BUF,   IDS_FMT_FVS_INTERNAL    },
    { FVS_MEM_ALLOC_ERR,      IDS_FMT_FVS_INTERNAL    },
    { FVS_INVALID_STATUS,     IDS_FMT_FVS_INTERNAL    }};

//
// Map font validation status codes to file name extension strings.
//
static const struct file_ext_map{
   BYTE file;        // File portion of status code.
   LPTSTR pext;      // File name extension string.
}FileExtMap[] = {
   { FVS_FILE_INF, TEXT(".INF") },
   { FVS_FILE_AFM, TEXT(".AFM") },
   { FVS_FILE_PFB, TEXT(".PFB") },
   { FVS_FILE_PFM, TEXT(".PFM") },
   { FVS_FILE_TTF, TEXT(".TTF") },
   { FVS_FILE_FOT, TEXT(".FOT") }};


int iUIMsgBoxInvalidFont(HWND hwndParent, LPCTSTR pszFontFile, LPCTSTR pszFontDesc, 
                         DWORD dwStatus, UINT uStyle)
{
    TCHAR szCannotInstall[STRING_BUF];               // Message prefix.
    TCHAR szFileName[MAX_PATH + 1];                  // Local file name copy.
    TCHAR szNulString[]  = TEXT("");                 // Output when no arg used.
    LPTSTR pszArgs[2]    = { NULL, NULL };           // Message inserts.
    LPTSTR pszFileExt    = NULL;                     // Ptr to ext part of file name.
    DWORD dwMsgId        = IDS_FMT_FVS_INTERNAL;     // Message string resource id.
    UINT cchLoaded       = 0;                        // LoadString status.
    int i                = 0;                        // General loop counter.
    const DWORD dwStatusCode = FVS_STATUS(dwStatus); // Status part of code.
    const DWORD dwStatusFile = FVS_FILE(dwStatus);   // File part of code.

    ASSERT(NULL != pszFontFile);

    //
    // Check to see if status value was properly set.
    // This check relies on status codes being initialized
    // to FVS_INVALID_STATUS.
    //
    ASSERT(dwStatusCode != FVS_INVALID_STATUS);

    //
    // We don't display a message if the status is SUCCESS.
    //
    if (dwStatusCode == FVS_SUCCESS)
    {
       ASSERT(FALSE);  // Complain to developer.
       return 0;
    }

    //
    // Format the common prefix for all messages.
    //
    if ((pszFontDesc != NULL) && (pszFontDesc[0] != TEXT('\0')))
    {
        TCHAR szFmtPrefix[STRING_BUF];

        //
        // Description string is provided and is not blank.
        // Prefix is "Unable to install the "<font desc>" font."
        //
        if ((cchLoaded = LoadString(g_hInst,
                       IDS_FMT_FVS_PREFIX,
                       szFmtPrefix,
                       ARRAYSIZE(szFmtPrefix))) > 0)
        {
            //
            // WARNING: This argument array assumes that there is only ONE
            //          replaceable argument in the string IDS_FMT_FVS_PREFIX.
            //          If this resource is modified to include more embedded
            //          values, this arg array must be extended as well.
            //
            LPCTSTR FmtMsgArgs[] = { pszFontDesc };

            cchLoaded = FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      szFmtPrefix,
                                      0,
                                      0,
                                      szCannotInstall,    
                                      ARRAYSIZE(szCannotInstall),
                                      (va_list *)FmtMsgArgs);
        }
    }
    else
    {
        //
        // Description string is not provided or is blank.
        // Prefix is "Unable to install the font."
        //
        cchLoaded = LoadString(g_hInst,
                       IDSI_CAP_NOINSTALL,
                       szCannotInstall,
                       ARRAYSIZE(szCannotInstall));
    }

    //
    // Verify prefix string is loaded and formatted.
    //
    if (0 == cchLoaded)
    {
        //
        // Resource not found/loaded.
        //
        szCannotInstall[0] = TEXT('\0');  // Make sure we're terminated.
        ASSERT(FALSE);                    // Complain during development.
    }


    lstrcpy(szFileName, pszFontFile);    // Don't want to alter source string.

    int nMapSize = ARRAYSIZE(StrIdMap);
    for (i = 0; i < nMapSize; i++)
    {
        if (StrIdMap[i].code == dwStatusCode)
        {
            dwMsgId = StrIdMap[i].idStr;
            break;
        }
    }

    pszFileExt = NULL;
    if (FVS_FILE_UNK != dwStatusFile)
    {
        nMapSize = ARRAYSIZE(FileExtMap);
        for (i = 0; i < nMapSize; i++)
        {
            if (FileExtMap[i].file == dwStatusFile)
            {
                pszFileExt = FileExtMap[i].pext;
                break;
            }
        }
    }
         
    //
    // Replace the file extension if a file type was specified in status code.
    //
    if (NULL != pszFileExt)
    {
        LPTSTR pchPeriod = StrRChr(szFileName, NULL, TEXT('.'));
        if (NULL != pchPeriod)
           lstrcpy(pchPeriod, pszFileExt);
    }

    //
    // Set up the required arguments for the message format strings.
    //
    pszArgs[0] = szCannotInstall;  // All msgs use this prefix.

    switch(dwMsgId)
    {
        //
        // These don't include an embedded file name.
        //
        case IDS_FMT_FVS_FILEIO:
        case IDS_FMT_FVS_INTERNAL:
           pszArgs[1] = NULL;
           break;

        //
        // By default, each message includes a file name.
        //
        default:
           pszArgs[1] = szFileName;
           break;
    }
              

    //
    // Modify very long path names so that they fit into the message box.
    // They are formatted as "c:\dir1\dir2\dir3\...\dir8\filename.ext"
    // DrawTextEx isn't drawing on anything.  Only it's formatting capabilities are
    // being used. The DT_CALCRECT flag prevents drawing.
    //
    HWND hWnd       = GetDesktopWindow();
    HDC  hDC        = GetDC(hWnd);
    LONG iBaseUnits = GetDialogBaseUnits();
    RECT rc;
    const int MAX_PATH_DISPLAY_WD = 60; // Max characters to display in path name.
    const int MAX_PATH_DISPLAY_HT =  1; // Path name is 1 character high.

    rc.left   = 0;
    rc.top    = 0;
    rc.right  = MAX_PATH_DISPLAY_WD * LOWORD(iBaseUnits);
    rc.bottom = MAX_PATH_DISPLAY_HT * HIWORD(iBaseUnits);

    DrawTextEx(hDC, szFileName, ARRAYSIZE(szFileName), &rc,
                                DT_CALCRECT | DT_PATH_ELLIPSIS | DT_MODIFYSTRING, NULL);
    ReleaseDC(hWnd, hDC);

    //
    // Display message using standard Type 1 installer msg box.
    // Note that iUIMsgBox wants 16-bit resource ID's.
    //
    return iUIMsgBox(hwndParent, (WORD)dwMsgId, IDS_MSG_CAPTION, uStyle,
                     (pszArgs[0] ? pszArgs[0] : szNulString),
                     (pszArgs[1] ? pszArgs[1] : szNulString));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\atmpfm.c ===
/*--------------------------------------------------------------------------*/
/* WINATM version only                                                      */
/*--------------------------------------------------------------------------*/
//
//      Copyright 1990, 1991 -- Adobe Systems, Inc.
//      PostScript is a trademark of Adobe Systems, Inc.
//
// NOTICE:  All information contained herein or attendant hereto is, and
// remains, the property of Adobe Systems, Inc.  Many of the intellectual
// and technical concepts contained herein are proprietary to Adobe Systems,
// Inc. and may be covered by U.S. and Foreign Patents or Patents Pending or
// are protected as trade secrets.  Any dissemination of this information or
// reproduction of this material are strictly forbidden unless prior written
// permission is obtained from Adobe Systems, Inc.
//
/*--------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <fcntl.h>
#include <ctype.h>
#include <io.h>

#include "windows.h"
#pragma pack(1)
#include "makepfm.h"
#pragma pack(4)

#include "fvscodes.h"  // FVS_xxxxxx (font validation status) codes and macros.

#ifdef WIN30
  #define LPCSTR LPSTR
#endif

typedef LPSZ GlyphName;
extern  AFM  afm;

// bodind added these

#define str_DotINF ".INF"
#define str_DotPFM ".PFM"

/*--------------------------------------------------------------------------*/
static CHAR msgbuff[128];
static HANDLE hMemArray[258];  // #_of_glyphnames + 1_glypharray + 1_kernpairs
static INT indexMemArray = 0;
static GlyphName winEnc[] =
/*  8-27-91 yh  Added some characters for Windows 3.1 */
{   /*   0 */    "",
    /*   1 */    "",
    /*   2 */    "",
    /*   3 */    "",
    /*   4 */    "",
    /*   5 */    "",
    /*   6 */    "",
    /*   7 */    "",
    /*   8 */    "",
    /*   9 */    "",
    /*  10 */    "",
    /*  11 */    "",
    /*  12 */    "",
    /*  13 */    "",
    /*  14 */    "",
    /*  15 */    "",
    /*  16 */    "",
    /*  17 */    "",
    /*  18 */    "",
    /*  19 */    "",
    /*  20 */    "",
    /*  21 */    "",
    /*  22 */    "",
    /*  23 */    "",
    /*  24 */    "",
    /*  25 */    "",
    /*  26 */    "",
    /*  27 */    "",
    /*  28 */    "",
    /*  29 */    "",
    /*  30 */    "",
    /*  31 */    "",
    /*  32 */    "space",
    /*  33 */    "exclam",
    /*  34 */    "quotedbl",
    /*  35 */    "numbersign",
    /*  36 */    "dollar",
    /*  37 */    "percent",
    /*  38 */    "ampersand",
    /*  39 */    "quotesingle",
    /*  40 */    "parenleft",
    /*  41 */    "parenright",
    /*  42 */    "asterisk",
    /*  43 */    "plus",
    /*  44 */    "comma",
    /*  45 */    "hyphen",
    /*  46 */    "period",
    /*  47 */    "slash",
    /*  48 */    "zero",
    /*  49 */    "one",
    /*  50 */    "two",
    /*  51 */    "three",
    /*  52 */    "four",
    /*  53 */    "five",
    /*  54 */    "six",
    /*  55 */    "seven",
    /*  56 */    "eight",
    /*  57 */    "nine",
    /*  58 */    "colon",
    /*  59 */    "semicolon",
    /*  60 */    "less",
    /*  61 */    "equal",
    /*  62 */    "greater",
    /*  63 */    "question",
    /*  64 */    "at",
    /*  65 */    "A",
    /*  66 */    "B",
    /*  67 */    "C",
    /*  68 */    "D",
    /*  69 */    "E",
    /*  70 */    "F",
    /*  71 */    "G",
    /*  72 */    "H",
    /*  73 */    "I",
    /*  74 */    "J",
    /*  75 */    "K",
    /*  76 */    "L",
    /*  77 */    "M",
    /*  78 */    "N",
    /*  79 */    "O",
    /*  80 */    "P",
    /*  81 */    "Q",
    /*  82 */    "R",
    /*  83 */    "S",
    /*  84 */    "T",
    /*  85 */    "U",
    /*  86 */    "V",
    /*  87 */    "W",
    /*  88 */    "X",
    /*  89 */    "Y",
    /*  90 */    "Z",
    /*  91 */    "bracketleft",
    /*  92 */    "backslash",
    /*  93 */    "bracketright",
    /*  94 */    "asciicircum",
    /*  95 */    "underscore",
    /*  96 */    "grave",
    /*  97 */    "a",
    /*  98 */    "b",
    /*  99 */    "c",
    /* 100 */    "d",
    /* 101 */    "e",
    /* 102 */    "f",
    /* 103 */    "g",
    /* 104 */    "h",
    /* 105 */    "i",
    /* 106 */    "j",
    /* 107 */    "k",
    /* 108 */    "l",
    /* 109 */    "m",
    /* 110 */    "n",
    /* 111 */    "o",
    /* 112 */    "p",
    /* 113 */    "q",
    /* 114 */    "r",
    /* 115 */    "s",
    /* 116 */    "t",
    /* 117 */    "u",
    /* 118 */    "v",
    /* 119 */    "w",
    /* 120 */    "x",
    /* 121 */    "y",
    /* 122 */    "z",
    /* 123 */    "braceleft",
    /* 124 */    "bar",
    /* 125 */    "braceright",
    /* 126 */    "asciitilde",
    /* 127 */    "",
    /* 128 */    "",
    /* 129 */    "",
    /* 130 */    "quotesinglbase",
    /* 131 */    "florin",
    /* 132 */    "quotedblbase",
    /* 133 */    "ellipsis",
    /* 134 */    "dagger",
    /* 135 */    "daggerdbl",
    /* 136 */    "circumflex",
    /* 137 */    "perthousand",
    /* 138 */    "Scaron",
    /* 139 */    "guilsinglleft",
    /* 140 */    "OE",
    /* 141 */    "",
    /* 142 */    "",
    /* 143 */    "",
    /* 144 */    "",
    /* 145 */    "quoteleft",
    /* 146 */    "quoteright",
    /* 147 */    "quotedblleft",
    /* 148 */    "quotedblright",
    /* 149 */    "bullet",
    /* 150 */    "endash",
    /* 151 */    "emdash",
    /* 152 */    "tilde",
    /* 153 */    "trademark",
    /* 154 */    "scaron",
    /* 155 */    "guilsinglright",
    /* 156 */    "oe",
    /* 157 */    "",
    /* 158 */    "",
    /* 159 */    "Ydieresis",
    /* 160 */    "space",
    /* 161 */    "exclamdown",
    /* 162 */    "cent",
    /* 163 */    "sterling",
    /* 164 */    "currency",
    /* 165 */    "yen",
    /* 166 */    "brokenbar",
    /* 167 */    "section",
    /* 168 */    "dieresis",
    /* 169 */    "copyright",
    /* 170 */    "ordfeminine",
    /* 171 */    "guillemotleft",
    /* 172 */    "logicalnot",
    /* 173 */    "minus",
    /* 174 */    "registered",
    /* 175 */    "macron",
    /* 176 */    "degree",
    /* 177 */    "plusminus",
    /* 178 */    "twosuperior",
    /* 179 */    "threesuperior",
    /* 180 */    "acute",
    /* 181 */    "mu",
    /* 182 */    "paragraph",
    /* 183 */    "periodcentered",
    /* 184 */    "cedilla",
    /* 185 */    "onesuperior",
    /* 186 */    "ordmasculine",
    /* 187 */    "guillemotright",
    /* 188 */    "onequarter",
    /* 189 */    "onehalf",
    /* 190 */    "threequarters",
    /* 191 */    "questiondown",
    /* 192 */    "Agrave",
    /* 193 */    "Aacute",
    /* 194 */    "Acircumflex",
    /* 195 */    "Atilde",
    /* 196 */    "Adieresis",
    /* 197 */    "Aring",
    /* 198 */    "AE",
    /* 199 */    "Ccedilla",
    /* 200 */    "Egrave",
    /* 201 */    "Eacute",
    /* 202 */    "Ecircumflex",
    /* 203 */    "Edieresis",
    /* 204 */    "Igrave",
    /* 205 */    "Iacute",
    /* 206 */    "Icircumflex",
    /* 207 */    "Idieresis",
    /* 208 */    "Eth",
    /* 209 */    "Ntilde",
    /* 210 */    "Ograve",
    /* 211 */    "Oacute",
    /* 212 */    "Ocircumflex",
    /* 213 */    "Otilde",
    /* 214 */    "Odieresis",
    /* 215 */    "multiply",
    /* 216 */    "Oslash",
    /* 217 */    "Ugrave",
    /* 218 */    "Uacute",
    /* 219 */    "Ucircumflex",
    /* 220 */    "Udieresis",
    /* 221 */    "Yacute",
    /* 222 */    "Thorn",
    /* 223 */    "germandbls",
    /* 224 */    "agrave",
    /* 225 */    "aacute",
    /* 226 */    "acircumflex",
    /* 227 */    "atilde",
    /* 228 */    "adieresis",
    /* 229 */    "aring",
    /* 230 */    "ae",
    /* 231 */    "ccedilla",
    /* 232 */    "egrave",
    /* 233 */    "eacute",
    /* 234 */    "ecircumflex",
    /* 235 */    "edieresis",
    /* 236 */    "igrave",
    /* 237 */    "iacute",
    /* 238 */    "icircumflex",
    /* 239 */    "idieresis",
    /* 240 */    "eth",
    /* 241 */    "ntilde",
    /* 242 */    "ograve",
    /* 243 */    "oacute",
    /* 244 */    "ocircumflex",
    /* 245 */    "otilde",
    /* 246 */    "odieresis",
    /* 247 */    "divide",
    /* 248 */    "oslash",
    /* 249 */    "ugrave",
    /* 250 */    "uacute",
    /* 251 */    "ucircumflex",
    /* 252 */    "udieresis",
    /* 253 */    "yacute",
    /* 254 */    "thorn",
    /* 255 */    "ydieresis",
                 NULL,
};

extern CHAR encfile[MAX_PATH];
extern CHAR outfile[MAX_PATH];
extern CHAR infofile[MAX_PATH];
extern INT charset;
extern INT devType;
extern BOOL forceVariablePitch;

/*--------------------------------------------------------------------------*/
BOOL GetINFFontDescription(LPSZ, LPSZ, LPSZ);
BOOL MakePfm(LPSZ, LPSZ, LPSZ);

VOID GetFilename(LPSZ, LPSZ);
INT OpenParseFile(LPSZ);
INT OpenTargetFile(LPSZ);
VOID WriteDots(VOID);
LPVOID AllocateMem(UINT);
VOID FreeAllMem(VOID);
GlyphName *SetupGlyphArray(LPSZ);

extern short _MakePfm(VOID);          /* afm.c */
extern VOID StartParse(VOID);         /* token.c */
extern BOOL GetLine(INT);
extern VOID GetWord(CHAR *, INT);
extern BOOL GetString(CHAR *, INT);
extern INT  GetToken(INT, KEY *);

/*--------------------------------------------------------------------------*/

#ifdef ADOBE_CODE_WE_DO_NOT_USE


BOOL GetINFFontDescription(
  LPSZ    lpszInf,
  LPSZ    lpszDescription,
  LPSZ    lpszPSFontName
)
{
  INT         hfile, iToken;
  CHAR        szName[128];
  CHAR        szAngle[10];
  CHAR        szStyle[2];
  CHAR        szMods[30];
  BOOL        bAddItalic = FALSE;
  CHAR        szBold[20];
  CHAR        szItalic[20];

  static KEY infKeys[] = {
      "FontName",   TK_PSNAME,
      "MSMenuName", TK_MSMENUNAME,
      "VPStyle",    TK_VPSTYLE,
      "ItalicAngle",TK_ANGLE,
      NULL, 0
      };

  hfile = OpenParseFile( lpszInf );
  if( hfile == -1 ) return(FALSE);

  szName[0] = szStyle[0] = szMods[0] = lpszPSFontName[0] = 0;

  // bodind replaced AtmGetString by strcpy

  strcpy(szBold, "Bold");
  strcpy(szItalic, "Italic");
  //AtmGetString( RCN(STR_BOLD), szBold, sizeof(szBold) );
  //AtmGetString( RCN(STR_ITALIC), szItalic, sizeof(szItalic) );

  while( GetLine(hfile) ) {
      iToken = GetToken(hfile,infKeys);
      switch(iToken) {
          case TK_MSMENUNAME:
              GetString(szName, sizeof(szName));
              break;
          case TK_PSNAME:
              GetString(lpszPSFontName, MAX_PATH);
              break;
          case TK_ANGLE:
              GetWord(szAngle, sizeof(szAngle));
              if ( strcmp (szAngle, "0") )
                 bAddItalic = TRUE;
              break;
          case TK_VPSTYLE:
              GetString(szStyle, sizeof(szStyle));
              switch( toupper(szStyle[0]) ) {
                  case 'N': break;
                  case 'B': strcpy(szMods, szBold);    break;
                  case 'T': strcpy(szMods, szBold);
                  case 'I':
                     strcat(szMods, szItalic);
                     bAddItalic = FALSE;
                     break;
                  /* default:  break; */
                  }
              break;
          }
      }
  _lclose(hfile);

  if( !szName[0] ) return(FALSE);

  strcpy( lpszDescription, szName );
  if( szMods[0] ) {
      strcat( lpszDescription, "," );
      strcat( lpszDescription, szMods );
      if (bAddItalic)
         strcat(lpszDescription, szItalic);
      }         
  else
     {
      if (bAddItalic)
        {
        strcat (lpszDescription, "," );
        strcat (lpszDescription, szItalic);
        }
     }
  return(TRUE);
} // end of GetINFFontDescription


/*--------------------------------------------------------------------------*/
INT MakePfm(afmpath, infdir, pfmdir) /* MEF */
LPSZ afmpath, infdir, pfmdir;
{
  #define FATALERROR  2
  #define NOERROR     0

  CHAR bname[9];

  indexMemArray = 0;              /* init global */

  strcpy(afm.szFile, afmpath);
  GetFilename(afmpath, bname);
  if( infdir[strlen(infdir)-1] == '\\' )
      sprintf(infofile, "%s%s%s", infdir, bname, str_DotINF);
  else
      sprintf(infofile, "%s\\%s%s", infdir, bname, str_DotINF);
  if( pfmdir[strlen(pfmdir)-1] == '\\' )
      sprintf(outfile,  "%s%s%s", pfmdir, bname, str_DotPFM);
  else
      sprintf(outfile,  "%s\\%s%s", pfmdir, bname, str_DotPFM);

  afm.iPtSize = 12;
  encfile[0] = EOS;
  devType = POSTSCRIPT;
  if( !strcmp(_strupr(bname), "SY______") ) charset = SYMBOL_CHARSET;
  else charset = -1;
/*
 * yh 8/16/91 -- Keep forceVariablePitch to TRUE for now to be compatible
 * with bitmaps generated by Font Foundry.  ATM and device driver will
 * report different value for PitchAndFamily for monospaced fonts.
 *
 * forceVariablePitch = FALSE;
 */

  if( !_MakePfm() ) {
      return FATALERROR;
      }
  return(NOERROR);
}

#endif // ADOBE_CODE_WE_DO_NOT_USE

/*--------------------------------------------------------------------------*/
VOID GetFilename(path, name)
LPSZ path, name;
{
  LPSZ p;
  INT i;

  if( (p = strrchr(path,'\\')) == NULL )
      if( (p = strrchr(path,':') ) == NULL ) p = path;
  if( p != NULL ) p++;
  for(i=0; i<8; i++) {
      if( p[i]=='.' || p[i]==EOS ) break;
      name[i] = p[i];
      }
  name[i] = EOS;
}

/*----------------------------------------------------------------------------*/
INT OpenParseFile(lpszPath)
LPSZ lpszPath;
{
  OFSTRUCT    of;

  StartParse();
  return( OpenFile(lpszPath, &of, OF_READ) );
}

/*----------------------------------------------------------------------------*/
INT OpenTargetFile(lpszPath)
LPSZ lpszPath;
{
  OFSTRUCT    of;

  return( OpenFile(lpszPath, &of, OF_CREATE | OF_WRITE) );
}

LPVOID AllocateMem(size)
UINT size;
{
  HANDLE hmem;

  if( !(hmem=GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, size)) ) return(NULL);
  hMemArray[indexMemArray++] = hmem;
  return( GlobalLock(hmem) );
}

/*--------------------------------------------------------------------------*/
VOID FreeAllMem()
{
  INT i;

  for(i=0; i<indexMemArray; i++) {
      GlobalUnlock( hMemArray[i] );
      GlobalFree( hMemArray[i] );
      }
}

/*--------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
GlyphName *SetupGlyphArray(encFilePath)

LPSZ encFilePath;
{
  return(winEnc);
}

/*----------------------------------------------------------------------------*/



/******************************Public*Routine******************************\
*
* BOOL bGetDescFromInf(char * pszINF, DWORD cjDesc, char *pszDesc)
*
* Not same as adobe's routine, we use font name from which we weed out
* hyphes '-'
*
* History:
*  28-Apr-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bGetDescFromInf(char * pszINF, DWORD cjDesc, char *pszDesc)
{
  INT         hfile;

  static KEY akeyInf[] = {
      "FontName",   TK_PSNAME,
      NULL, 0
      };

  hfile = OpenParseFile( pszINF );
  if( hfile == -1 ) return(FALSE);

  pszDesc[0] = 0;

  while( GetLine(hfile) )
  {
    if (GetToken(hfile,akeyInf) == TK_PSNAME)
    {
       GetString(pszDesc, cjDesc);
       break;
    }
  }
  _lclose(hfile);

  if( !pszDesc[0] ) return(FALSE);

// weed out hyphens

  for ( ; *pszDesc; pszDesc++)
  {
    if (*pszDesc == '-')
        *pszDesc = ' ';
  }

  return(TRUE);

}

/******************************Public*Routine******************************\
*
* short CreatePFM(char *pszINF, char *pszAFM, char *pszPFM);
*
* slightly modified adobe's routine
*
* History:
*  28-Apr-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*           FVS_FILE_BUILD_ERR  
*
\**************************************************************************/
short CreatePFM(char *pszINF, char *pszAFM, char *pszPFM)
{
  CHAR bname[9];

  indexMemArray = 0;              /* init global */

  strcpy(afm.szFile, pszAFM);
  GetFilename(pszAFM, bname);

  strcpy (infofile, pszINF);
  strcpy (outfile, pszPFM);

  afm.iPtSize = 12;
  encfile[0] = EOS;
  devType = POSTSCRIPT;

// this is something that would have never come to my mind [bodind]

  if( !strcmp(_strupr(bname), "SY______") )
    charset = SYMBOL_CHARSET;
  else
    charset = -1;

/*
 * yh 8/16/91 -- Keep forceVariablePitch to TRUE for now to be compatible
 * with bitmaps generated by Font Foundry.  ATM and device driver will
 * report different value for PitchAndFamily for monospaced fonts.
 *
 * forceVariablePitch = FALSE;
 */

  return _MakePfm();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\fileio.h ===
/***
**
**   Module: FileIO
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      is the interface towards all low level I/O functions that are
**      are available on the current platform.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif

#define READONLY  0
#define READWRITE 1

struct ioFile;



/***
** Function: io_Close
**
** Description:
**   This function closes an open file.
***/
errcode           io_CloseFile   _ARGS((INOUT   struct ioFile *fp));


/***
** Function: io_ReadOneByte
**
** Description:
**   This function reads one byte from the current position in 
**   the given file. 
***/
USHORT FASTCALL   io_ReadOneByte _ARGS((INOUT   struct ioFile *fp));


/***
** Function: io_FileError
**
** Description:
**   This function returns the current error status of the file.
***/
boolean           io_FileError   _ARGS((INOUT   struct ioFile *fp));


/***
** Function: io_FileTell
**
** Description:
**   This function returns the current position in the file.
***/
long FASTCALL     io_FileTell    _ARGS((INOUT   struct ioFile *fp));


/***
** Function: io_RemoveFile
**
** Description:
**   This function removes an already closed file.
***/
void FASTCALL     io_RemoveFile  _ARGS((IN      char *name));


/***
** Function: io_OpenFile
**
** Description:
**   This function opens a file.
***/
struct ioFile     *io_OpenFile   _ARGS((IN      char *name,
                                        IN      int mode));


/***
** Function: io_FileSeek
**
** Description:
**   This function moves the current position in the file,
**   relative the beginning of the file.
***/
long FASTCALL     io_FileSeek    _ARGS((INOUT   struct ioFile *fp,
                                        INOUT   long where));


/***
** Function: io_WriteBytes
**
** Description:
**   This function writes a number of bytes, starting at the 
**   current position in the file.
***/
USHORT FASTCALL   io_WriteBytes  _ARGS((IN      UBYTE *,
                                        INOUT   USHORT, struct ioFile *));


/***
** Function: io_ReadBytes
**
** Description:
**   This function reades a number of bytes, starting at the 
**   current position in the file.
***/
USHORT FASTCALL   io_ReadBytes   _ARGS((INOUT   UBYTE *buf,
                                        INOUT   USHORT len,
                                        INOUT   struct ioFile *fp));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\freader.c ===
/***
**
**   Module: FReader
**
**   Description:
**    This is a module of the T1 to TT font converter. The module
**    contains functions that decodes and decrypts the data of a
**    T1 font file.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <ctype.h>
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "freader.h"
#include "pfb.h"


/***** LOCAL TYPES */
struct FontFile {

   /* Low-level I/O functions. */
   errcode (FASTCALL *fclose)(struct t1file *);
   short (FASTCALL *fgetc)(struct t1file *);
   struct t1file *(*fopen)(const char *);
   boolean (FASTCALL *fstatus)(const struct t1file *);
   struct t1file *io;

   /* Font file state. */
   enum {prolog, eexec} state;
   short nextbyte;
   USHORT r;
};


/***** CONSTANTS */
static const USHORT c1 = 52845;
static const USHORT c2 = 22719;


/***** MACROS */
#define IOGetByte(f)       ((*f->fgetc)(f->io))
#define IOError(f)         ((*f->fstatus)(f->io))
#define IOOpen(f,n)        ((*f->fopen)(n))
#define IOClose(f)         ((*f->fclose)(f->io))
#define SetNextByte(ff, b) ff->nextbyte = (b)
#define NextByte(ff)       (ff->nextbyte)
#define Eexec(ff)          (boolean)(ff->state == eexec)
#define StartEexec(ff)     ff->state = eexec



/***** STATIC FUNCTIONS */
/*-none-*/



/***** FUNCTIONS */

/***
** Function: GetByte
**
** Description:
**   Pull one byte out of the T1 font file.
***/
short FASTCALL GetByte(struct FontFile *ff)
{
   short b, nb;

   b = IOGetByte(ff);

   /* Decrypt it? */
   if (Eexec(ff))
      b = (short)Decrypt(&ff->r, (UBYTE)b);

   /* Record look-a-head */
   nb = NextByte(ff);
   SetNextByte(ff, b);

   return nb;
}



/***
** Function: GetNewLine
**
** Description:
**   Pull one whole line from the T1 font file, starting at
**   the current position.
***/
char *GetNewLine(struct FontFile *ff, char *buf, const USHORT len)
{
   short i = 0;

   /* Get string. */
   while ((buf[i] = (char)GetByte(ff))!='\n' &&
          buf[i]!='\r' && ++i<((short)len-1));

   /* Skip extra characters. */
   if (buf[i]!='\n' && buf[i]!='\r')
      while (!IOError(ff) && NextByte(ff)!='\n' && NextByte(ff)!='\r')
         (void)GetByte(ff);

   /* Terminate string. */
   buf[i] = '\0';

   /* Check for the start of the eexec section. */
   if (!strcmp(buf, "eexec"))
      StartEexec(ff);

   /* Check error condition. */
   if (IOError(ff))
      return NULL;

   return buf;
}



/***
** Function: Get_Token
**
** Description:
**   Pull one token from the T1 font file. A token 
**   is delimited by white space and various brackets.
***/
char *Get_Token(struct FontFile *ff, char *buf, const USHORT len)
{
   short i = 0;
   short nb;

   /* Skip leading blanks. */
   while (isspace(NextByte(ff)))
      (void)GetByte(ff);

   /* Get string. */
   do {
      buf[i] = (char)GetByte(ff);
      nb = NextByte(ff);
   } while (++i<((short)len-1) && !isspace(nb) && nb!='{' &&
            nb!='(' && nb!='[' && nb!='/');

   /* Skip extra characters. */
   while (!IOError(ff) && !isspace(nb) && nb!='{' &&
          nb!='(' && nb!='[' && nb!='/') {
      (void)GetByte(ff);
      nb = NextByte(ff);
   }

   /* Terminate string. */
   buf[i] = '\0';

   /* Check for the start of the eexec section. */
   if (!strcmp(buf, "eexec"))
      StartEexec(ff);

   /* Check error condition. */
   if (IOError(ff))
      return NULL;

   return buf;
}



/***
** Function: GetSeq
**
** Description:
**   Pull one sequence of bytes that are delimited by 
**   a given pair of characters, e.g. '[' and ']'.
***/
char *GetSeq(struct FontFile *ff,
             char *buf,
             const USHORT len)
{
   char d1, d2;
   short i = 0;
   short inside = 0;

   /* Skip leading blanks. */
   while (NextByte(ff)!='[' &&
          NextByte(ff)!='{' &&
          NextByte(ff)!='(' &&
          !IOError(ff))
      (void)GetByte(ff);

   /* match the bracket. */
   d1 = (char)NextByte(ff);
   if (d1=='[') 
      d2 = ']';
   else if (d1=='{')
      d2 = '}';
   else if (d1=='(')
      d2 = ')';
   else
      return NULL;


   /* Get string. */ 
   (void)GetByte(ff);
   inside=1;
   do {
      buf[i] = (char)GetByte(ff);
      if (buf[i]==d1)
         inside++;
      if (buf[i]==d2)
         inside--;
   } while (inside && ++i<((short)len-1));

   /* Terminate string. */
   buf[i] = '\0';

   /* Check error condition. */
   if (IOError(ff))
      return NULL;

   return buf;
}



/***
** Function: FRInit
**
** Description:
**   Initite the resources needed to read/decode data from
**   a T1 font file.
***/
errcode FRInit(const char *name, const enum ftype type, struct FontFile **ff)
{
   errcode status = SUCCESS;
   short b;

   if (((*ff)=(struct FontFile *)Malloc(sizeof(struct FontFile)))==NULL) {
      SetError(status = NOMEM);
   } else {

      /* Initiat the handle. */
      memset((*ff), '\0', sizeof(**ff));

      /* Initiate low-level I/O. */
      switch (type) {
         case pfb_file:
            (*ff)->fgetc = PFBGetByte;
            (*ff)->fclose = PFBFreeIOBlock;
            (*ff)->fstatus = PFBFileError;
            (*ff)->fopen = PFBAllocIOBlock;
            break;
         case mac_file:
#if MACFILEFORMAT
            (*ff)->fgetc = MACGetByte;
            (*ff)->fclose = MACFreeIOBlock;
            (*ff)->fstatus = MACFileError;
            (*ff)->fopen = MACAllocIOBlock;
            break;
#endif
         case ascii_file:
#if ASCIIFILEFORMAT
            (*ff)->fgetc = ASCIIGetByte;
            (*ff)->fclose = ASCIIFreeIOBlock;
            (*ff)->fstatus = ASCIFileError;
            (*ff)->fopen = ASCIIAllocIOBlock;
            break;
#endif
         default:
            LogError(MSG_ERROR, MSG_BADFMT, NULL);
            SetError(status = BADINPUTFILE);
            break;
      }

      (*ff)->io = NULL;
      if (((*ff)->io = IOOpen((*ff),name))==NULL) {
         SetError(status = BADINPUTFILE);
      } else {
         (*ff)->state = prolog;
         (*ff)->r = 55665;

         b=GetByte(*ff);
         SetNextByte((*ff), b);
      }
   }

   return status;
}



/***
** Function: FRCleanUp
**
** Description:
**   Free the resources used when reading/decoding data from
**   a T1 font file.
***/
errcode FRCleanUp(struct FontFile *ff)
{
   errcode status = SUCCESS;

   if (ff) {
      if (ff->io)
         status = IOClose(ff);
      Free(ff);
   }

   return status;
}



/***
** Function: Decrypt
**
** Description:
**   Decrypt a byte.
***/
UBYTE FASTCALL Decrypt(USHORT *r, const UBYTE cipher)
{
   UBYTE plain;

   plain = (UBYTE)(cipher ^ (*r>>8));
   *r = (USHORT)((cipher+*r) * c1 + c2);

   return plain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\freader.h ===
/***
**
**   Module: FReader
**
**   Description:
**    This is a module of the T1 to TT font converter. The module
**    contains functions that decodes and decrypts the data of a
**    T1 font file.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif

enum ftype {pfb_file, mac_file, ascii_file};

struct FRHandle;
struct FontFile;



/***
** Function: GetByte
**
** Description:
**   Pull one byte out of the T1 font file.
***/
short FASTCALL  GetByte     _ARGS((INOUT   struct FontFile *ff));


/***
** Function: Decrypt
**
** Description:
**   Decrypt a byte.
***/
UBYTE FASTCALL  Decrypt     _ARGS((INOUT   USHORT *r, IN UBYTE b));


/***
** Function: FRCleanUp
**
** Description:
**   Free the resources used when reading/decoding data from
**   a T1 font file.
***/
errcode         FRCleanUp   _ARGS((INOUT   struct FontFile *ff));


/***
** Function: FRInit
**
** Description:
**   Initite the resources needed to read/decode data from
**   a T1 font file.
***/
errcode         FRInit      _ARGS((IN      char *name,
				   IN      enum ftype,
				   OUT     struct  FontFile **));
/***
** Function: GetSeq
**
** Description:
**   Pull one sequence of bytes that are delimited by 
**   a given pair of characters, e.g. '[' and ']'.
***/
char            *GetSeq     _ARGS((INOUT   struct FontFile *ff,
				   OUT     char *buf,
				   IN      USHORT len));
/***
** Function: Get_Token
**
** Description:
**   Pull one token from the T1 font file. A token 
**   is delimited by white space and various brackets.
***/
char            *Get_Token   _ARGS((INOUT   struct FontFile *ff,
				   OUT     char *buf,
				   IN      USHORT len));
/***
** Function: GetNewLine
**
** Description:
**   Pull one whole line from the T1 font file, starting at
**   the current position.
***/
char            *GetNewLine    _ARGS((INOUT   struct FontFile *ff,
				   OUT     char *buf,
				   IN      USHORT len));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\fvscodes.h ===
#ifndef __FONT_VALIDATION_STATUS_CODES_H
#define __FONT_VALIDATION_STATUS_CODES_H

//
// Detailed status codes for function CheckInfWithStatusA().
// These codes were added after the initial creation of the T1 installer library.
// CheckInfA() returns TRUE/FALSE.  However, a FALSE return value was
// not sufficiently descriptive for a user interface to respond appropriately.
// The function CheckInfWithStatusA() was added to provide detailed status info.
// No new return points were added to T1 installer functions.  These codes merely
// replace the original TRUE/FALSE return values.
//
// These codes are also used in the font folder font validation functions.
//
// The code is designed to return information that identifies:
//    a) What happened.
//    b) What file the status applies to (if applicable).
//
//
// bit->  15                 7               0
//       +-+----------------+-----------------+
//       |S| Status Code    | File Type Code  |
//       +-+----------------+-----------------+
//        |
//        +--- Severity bit.
//
//             1 = Error.  A true error like file i/o, mem alloc etc.
//             0 = No error. But status may indicate invalid font file.
// 
//                 >>>>>>> NOTE <<<<<<<<
//
//   This file contains codes that are generated by the
//   T1 installer function CheckType1A and by related font folder functions.
//   Since both the T1 installer and the font folder must understand
//   these codes, the font folder must include this file.  I apologize for
//   this added coupling between the T1 installer and the font folder but
//   it is necessary for detailed status reporting [brianau].
//
#define FVS_FILE_UNK    0x00  // File unknown or "doesn't matter".
#define FVS_FILE_PFM    0x01  // PFM file
#define FVS_FILE_PFB    0x02  // PFB file
#define FVS_FILE_AFM    0x03  // AFM file
#define FVS_FILE_INF    0x04  // INF file
#define FVS_FILE_TTF    0x05  // TTF file
#define FVS_FILE_FOT    0x06  // FOT file

//
// Status codes.
//
#define FVS_SUCCESS                 0x00   // No problem!
#define FVS_INVALID_FONTFILE        0x01   // Invalid font file or file name.
#define FVS_BAD_VERSION             0x02   // File version not supported.
#define FVS_FILE_BUILD_ERR          0x03   // Error building a font file.
#define FVS_FILE_EXISTS             0x04   // File already exists.
#define FVS_FILE_OPEN_ERR           0x05   // Couldn't find/open existing file.

//
// These codes indicate true system errors.  Note use of high bit
// to indicate severity.
//
#define FVS_FILE_CREATE_ERR         0x80   // Couldn't create new file.
#define FVS_FILE_IO_ERR             0x81   // General file I/O error.
#define FVS_INVALID_ARG             0x82   // Invalid arg passed to function.
#define FVS_EXCEPTION               0x83   // Exception caught.
#define FVS_INSUFFICIENT_BUF        0x84   // Destination buf too small.
#define FVS_MEM_ALLOC_ERR           0x85   // Error allocating memory.
#define FVS_INVALID_STATUS          0x86   // For ensuring status was set.

//
// Macros for creating and parsing status codes.
//
#define FVS_MAKE_CODE(c,f)   ((WORD)(((BYTE)(c) << 8) | (BYTE)(f)))  // Build code
#define FVS_STATUS(c)        (((c) >> 8) & 0x00FF) // Get status part
#define FVS_FILE(c)          ((c) & 0x00FF)        // Get file part
#define FVS_ISERROR(c)       (((c) & 0x8000) != 0) // Severity bit == 1 ?

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\charstr.h ===
/***
 **
 **   Module: CharStr
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contain one function that interprets the commands in a T1
 **    CharString and builds a representation of the glyph for the
 **    it.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

struct Subrs {
   USHORT len;
   UBYTE *code;
};


struct T1Glyph;
struct Composite;
struct PSState;

/***
** Function: AllocPSState
**
** Description:
**   This function allocates the workspace
**   used by the t1 parser.
***/
struct PSState *AllocPSState     _ARGS((void));


/***
** Function: InitPS
**
** Description:
**   This function initiate the workspace
**   used by the t1 parser.
***/
void           InitPS            _ARGS((INOUT   struct PSState *ps));


/***
** Function: FreePSState
**
** Description:
**   This function frees the workspace
**   used by the t1 parser.
***/
void           FreePSState       _ARGS((INOUT   struct PSState *ps));


/***
** Function: ParseCharString
**
** Description:
**   This function parses a CharString and builds a
**   of the charstring glyph.
***/
errcode        ParseCharString   _ARGS((INOUT   struct T1Glyph *glyph,
                                        INOUT   struct Composite **comp,
                                        INOUT   struct PSState *ps,
                                        IN      struct Subrs *subrs,
                                        INOUT   UBYTE *code,
                                        INOUT   USHORT len));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\fwriter.c ===
/***
**
**   Module: T1Parser
**
**   Description:
**  This is a module of the T1 to TT font converter. The module
**  contains functions that is used by the Builder moduler, to
**  manage the lowlevel writing to the TT font file, as well as
**  generic check sum, table length and table offset computations.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
/*-none-*/

/* Special types and definitions. */
#include "types.h"

/* Module dependent types and prototypes. */
#include "fileio.h"
#include "fwriter.h"



/***** LOCAL TYPES */
/*-none-*/



/***** CONSTANTS */
static const char *dir[] = {
   "OS/2",
   "cmap",
   "cvt ",
   "fpgm",
   "gasp",
   "glyf",
   "head",
   "hhea",
   "hmtx",
   "kern",
   "loca",
   "maxp",
   "name",
   "post",
   "prep",
};

#define MAGIC_CHECKSUM  0xB1B0AFBA


/***** MACROS */
/*-none-*/



/***** STATIC FUNCTIONS */
/***
** Function: SumCheckSum
**
** Description:
**   This function computes the check sum of
**   a section of the output file.
***/
static ULONG SumCheckSum(OutputFile *file, long length)
{
   ULONG sum = 0;
   UBYTE tbl[32];


   /* Unwrap the loop a bit. */
   while (length>16) {
      (void)io_ReadBytes(tbl, (USHORT)16, file);
      sum += MkLong(tbl[0],  tbl[1],  tbl[2],  tbl[3]);
      sum += MkLong(tbl[4],  tbl[5],  tbl[6],  tbl[7]);
      sum += MkLong(tbl[8],  tbl[9],  tbl[10], tbl[11]);
      sum += MkLong(tbl[12], tbl[13], tbl[14], tbl[15]);
      length -= 16;
   }

   /* Do the sentinel DWORDS. */
   while (length>0) {
      (void)io_ReadBytes(tbl, (USHORT)4, file);
      sum += MkLong(tbl[0], tbl[1], tbl[2], tbl[3]);
      length -= 4;
   }

   return sum;
}



/***** FUNCTIONS */


/***
** Function: WriteLong
**
** Description:
**   This function writes a 32-bit integer in the
**   Big Endian byte order, regardless of the
**   used byte order.
***/
void WriteLong(const ULONG val, OutputFile *file)
{
   UBYTE bytes[4];

   bytes[0] = (UBYTE)((val>>24)&0xff);
   bytes[1] = (UBYTE)((val>>16)&0xff);
   bytes[2] = (UBYTE)((val>>8)&0xff);
   bytes[3] = (UBYTE)((val)&0xff);
   (void)WriteBytes(bytes, (USHORT)4, file);
}



/***
** Function: WriteShort
**
** Description:
**   This function writes a 16-bit integer in the
**   Big Endian byte order, regardless of the used
**   byte order.
***/
void WriteShort(const USHORT val, OutputFile *file)
{
   UBYTE bytes[2];

   bytes[0] = (UBYTE)((val>>8)&0xff); 
   bytes[1] = (UBYTE)((val)&0xff);
   (void)WriteBytes(bytes, (USHORT)2, file);
}



/***
** Function: WriteByte
**
** Description:
**   This function writes an 8-bit integer in the
**   Big Endian byte order, regardless of used
**   byte order.
***/
void WriteByte(const UBYTE byte, OutputFile *file)
{
   (void)WriteBytes(&byte, (USHORT)1, file);
}




/***
** Function: CompleteTable
**
** Description:
**   This function completes a TT font file table,
**   by computing the check sum and writing it, the
**   table length and table offset to the table directory
**   of the TT font file.
**
**   Please note the dependency that this function must
**   be called right after the last byte of the contents
**   of the table have been written.
***/
errcode CompleteTable(const long offset,
                      const USHORT num,
                      OutputFile *file)
{
   long end;
   long length;
   ULONG sum = 0;
   long curr;
   short i;

   /* Determine the end of the table. */
   end = FileTell(file);

   /* Write pad bytes. */
   length = end - offset;
   if (length%4)
      for (i=0; i<(4-(long)(length%4)); i++)
         WriteByte(0, file);

   /* Record end of file position. */
   curr = io_FileTell(file);

   /* Compute the check sum */
   (void)io_FileSeek(file, offset);
   sum = SumCheckSum(file, end - offset);

   /* Write table directory entry */
   (void)io_FileSeek(file, (ULONG)(12L + TBLDIRSIZE*num + 4L));
   WriteLong(sum, file);
   WriteLong((ULONG)offset, file);
   WriteLong((ULONG)length, file);

   /* Go to end of file. */
   (void)io_FileSeek(file, curr);

   return FileError(file);
}



/***
** Function: WriteChecksum
**
** Description:
**   This function completes the whole TT font file,
**   by computing the check sum of the whole file and writing
**   it at the designated place.
***/
void WriteChecksum(const long offset, OutputFile *file)
{
   long end;
   ULONG sum = 0;

   end = io_FileTell(file);
   (void)io_FileSeek(file, 0L);
   sum = SumCheckSum(file, end);
   sum = MAGIC_CHECKSUM - sum;
   (void)io_FileSeek(file, offset);
   WriteLong(sum, file);
}




/***
** Function: WriteTableHeader
**
** Description:
**   This function initiates a TT font file, by initiating 
**   a handle used when writing the tables and by writing
**   the leading table dictionary of the file.
***/
void WriteTableHeader(OutputFile *file)
{
   USHORT segcount;
   USHORT i;


   /* Count the segcount */ /*lint -e650 */
   for (segcount=0; (1UL<<(segcount+1)) <= NUMTBL; segcount++)
      continue; /*lint +e650*/

   /* Write the offset table. */
   WriteLong(0x00010000L, file);
   WriteShort((USHORT)NUMTBL, file);
   WriteShort((USHORT)((1<<segcount)*16), file);
   WriteShort(segcount, file);
   WriteShort((USHORT)(NUMTBL*16-(1<<segcount)*16), file);

   /* Write the table directory entries. */
   for (i=0; i<NUMTBL; i++) {
      (void)WriteBytes((UBYTE*)&(dir[i][0]), (USHORT)4, file);
      WriteLong(0L, file);
      WriteLong(0L, file);
      WriteLong(0L, file);
   }
}



/***
** Function: OpenOutputFile
**
** Description:
***/
OutputFile *OpenOutputFile(const  char *name)
{
   return io_OpenFile(name, READWRITE);
}



/***
** Function: CloseOutputFile
**
** Description:
***/
errcode CloseOutputFile(OutputFile *fp)
{
   return io_CloseFile(fp);
}


/***
** Function: WriteBytes
**
** Description:
***/
USHORT WriteBytes(const UBYTE *buf,
                  const USHORT len,
                  OutputFile *fp)
{
   return io_WriteBytes(buf, len, fp);
}



/***
** Function: FileError
**
** Description:
***/
boolean FileError(OutputFile *fp)
{
   return io_FileError(fp);
}



/***
** Function: FileTell
**
** Description:
***/
long FileTell(OutputFile *fp)
{
   return io_FileTell(fp);
}



/***
** Function: FileSeek
**
** Description:
***/
long FileSeek(OutputFile *fp,
              const long where)
{
   return io_FileSeek(fp, where);
}


/***
** Function: RemoveFile
**
** Description:
**  Removes an already closed output file.
***/
void RemoveFile(const char *name)
{
   io_RemoveFile(name);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\charstr.c ===
/***
 **
 **   Module: CharStr
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contain one function that interprets the commands in a T1
 **    CharString and builds a representation of the glyph for the
 **    it.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/
    

/**** INCLUDES */
/* General types and definitions. */
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "metrics.h"
#include "encoding.h"
#include "safemem.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "charstr.h"



/***** CONSTANTS */
#define MAXSTACK  24

#define BUFMARGIN    256

/* Known OtherSubr entries. */
#define HINT_END_FLEX      0
#define HINT_START_FLEX    1
#define HINT_MID_FLEX      2
#define HINT_REPLACEMENT   3


#define PSOP_HSTEM         1
#define PSOP_VSTEM         3
#define PSOP_VMOVETO       4
#define PSOP_RLINETO       5
#define PSOP_HLINETO       6
#define PSOP_VLINETO       7
#define PSOP_RRCURVETO     8
#define PSOP_CLOSEPATH     9
#define PSOP_CALLSUBR      10
#define PSOP_RETURN        11
#define PSOP_ESCAPE        12
#  define PSOP_DOTSECTION        0
#  define PSOP_VSTEM3            1
#  define PSOP_HSTEM3            2
#  define PSOP_SEAC              6
#  define PSOP_SBW               7
#  define PSOP_DIV               12
#  define PSOP_CALLOTHERSUBR     16
#  define PSOP_POP               17
#  define PSOP_SETCURRENTPOINT   33
#define PSOP_HSBW          13
#define PSOP_ENDCHAR       14
#define PSOP_RMOVETO       21
#define PSOP_HMOVETO       22
#define PSOP_VHCURVETO     30
#define PSOP_HVCURVETO     31




/***** LOCAL TYPES */
/* Referenced types. */
typedef struct PSState {
   long stack[MAXSTACK+2];
   Point *pts;
   ULONG *onoff;
   USHORT totpts;
   USHORT numpts;
   USHORT ptr;
   short hr;
   USHORT maxpts;
   USHORT flex;
   Point flexref;
	int calls;
	long otherargs[16];
	USHORT otherptr;
} PSState;



/***** MACROS */
#define AddPoint(ps, px, py) {ps->pts[ps->numpts].x = px;\
                              ps->pts[ps->numpts].y = py;\
                              ps->numpts++;}
#define CurrXPoint(ps)        ps->pts[ps->numpts-1].x
#define CurrYPoint(ps)        ps->pts[ps->numpts-1].y
#define PrevPoint(ps, index)  ps->pts[ps->numpts-1-index]

#define PushStack(v)    ps->stack[(ps->ptr)++] = (v)
#define PopStack()      ps->stack[--(ps->ptr)]




/***** STATIC FUNCTIONS */

/***
 ** Function: AddCSpline
 **
 ** Description:
 **   Record a cubic spline.
 **
 ***/
static void AddCSpline(PSState *ps,
                       const funit x1, const funit y1,
                       const funit x2, const funit y2,
                       const funit x3, const funit y3)
{
   SetOffPoint(ps->onoff, ps->numpts);
   AddPoint(ps, x1, y1);
   SetOffPoint(ps->onoff, ps->numpts);
   AddPoint(ps, x2, y2);
   SetOnPoint(ps->onoff, ps->numpts);
   AddPoint(ps, x3, y3);
}


/***
** Function: HintReplacement
**
** Description:
**   This function limits the range of points which are
**   affected by stem hints. It may be invoked by the 
**   "dotsection" and the more general hint replacement
**   mechanism found in T1 fonts.
***/
static void HintReplacement(T1Glyph *glyph, const short hr)
{
   Stem *stem;
   Stem3 *stem3;

   /* Dead stem hints?, e.g. replaced before ever used? */
   if (hr==ENDOFPATH) {
      for (stem=glyph->hints.hstems; stem; stem=stem->next)
         if (stem->i2==ENDOFPATH)
            stem->i2 = NORANGE;
      for (stem=glyph->hints.vstems; stem; stem=stem->next)
         if (stem->i2==ENDOFPATH)
            stem->i2 = NORANGE;
      for (stem3=glyph->hints.hstems3; stem3; stem3=stem3->next) {
         if (stem3->stem1.i2==ENDOFPATH) {
            stem3->stem1.i2 = NORANGE;
            stem3->stem2.i2 = NORANGE;
            stem3->stem3.i2 = NORANGE;
         }
      }
      for (stem3=glyph->hints.vstems3; stem3; stem3=stem3->next) {
         if (stem3->stem1.i2==ENDOFPATH) {
            stem3->stem1.i2 = NORANGE;
            stem3->stem2.i2 = NORANGE;
            stem3->stem3.i2 = NORANGE;
         }
      }

   /* Set the end-point for the stem hints that are replaced. */
   } else {

      for (stem=glyph->hints.hstems; stem; stem=stem->next)
         if (stem->i2==ENDOFPATH)
            stem->i2 = hr;
      for (stem=glyph->hints.vstems; stem; stem=stem->next)
         if (stem->i2==ENDOFPATH)
            stem->i2 = hr;
      for (stem3=glyph->hints.hstems3; stem3; stem3=stem3->next) {
         if (stem3->stem1.i2==ENDOFPATH) {
            stem3->stem1.i2 = hr;
            stem3->stem2.i2 = hr;
            stem3->stem3.i2 = hr;
         }
      }
      for (stem3=glyph->hints.vstems3; stem3; stem3=stem3->next) {
         if (stem3->stem1.i2==ENDOFPATH) {
            stem3->stem1.i2 = hr;
            stem3->stem2.i2 = hr;
            stem3->stem3.i2 = hr;
         }
      }
   }
}   


/***
** Function: NewFlex
**
** Description:
**   This function records a new flex hint for
**   the current glyph.
***/
static Flex *NewFlex(const Point ref,
                     const Point midpos,
                     const Point startpos,
                     const USHORT start,
                     const USHORT mid,
                     const USHORT end,
                     const funit civ)

{
   Flex *flex = NULL;

   if ((flex = Malloc(sizeof(Flex)))!=NULL) {
      flex->civ = civ;
      flex->pos = ref;
      flex->midpos = midpos;
      flex->startpos = startpos;
      flex->start = start;
      flex->mid = mid;
      flex->end = end;
   }

   return flex;
}



/***
** Function: NewStem
**
** Description:
**   This function records a new stem hint for
**   the current glyph.
***/
static Stem *NewStem(const funit offset,
                     const funit width,
                     const short hr)
{
   Stem *stem = NULL;

   if ((stem = Malloc(sizeof(Stem)))!=NULL) {
      if (width>0) {
         stem->offset = offset;
         stem->width = width;
      } else {
         stem->offset = offset+width;
         stem->width = -width;
      }
      stem->i1 = hr;
      stem->i2 = ENDOFPATH;
   }

   return stem;
}



/***
** Function: NewStem3
**
** Description:
**   This function records a new stem3 hint for the current glyph.
***/
static Stem3 *NewStem3(const funit o1, const funit w1,
                       const funit o2, const funit w2,
                       const funit o3, const funit w3,
                       const short hr)
{
   Stem3 *stem3 = NULL;

   if ((stem3 = Malloc(sizeof(Stem3)))!=NULL) {

      stem3->stem1.offset = o1;
      stem3->stem1.width = w1;
      stem3->stem1.i1 = hr;
      stem3->stem1.i2 = ENDOFPATH;

      stem3->stem2.offset = o2;
      stem3->stem2.width = w2;
      stem3->stem2.i1 = hr;
      stem3->stem2.i2 = ENDOFPATH;

      stem3->stem3.offset = o3;
      stem3->stem3.width = w3;
      stem3->stem3.i1 = hr;
      stem3->stem3.i2 = ENDOFPATH;
   }

   return stem3;
}



/***
** Function: NewPath
**
** Description:
**   This function adds a new contour to the current glyph.
***/
static errcode NewPath(T1Glyph *glyph,
                       const Point *pts,
                       ULONG *onoff,
                       const USHORT numpts)
{
   errcode status = SUCCESS;
   Outline *path;
   Outline *prev;

   /* Skip 1,2 point paths. */
   if (numpts>2) {
      if ((path=Malloc(sizeof(Outline)))==NULL) {
         SetError(status = NOMEM);
      } else {

         path->pts=Malloc(sizeof(Point)*numpts);
         path->onoff=Malloc(ONOFFSIZE(numpts));
         if (path->pts==NULL || path->onoff==NULL) {
            if (path->pts)
               Free(path->pts);
            if (path->onoff)
               Free(path->onoff);
            Free(path);
            return NOMEM;
         }

         /* Initiate the new sub-path. */
         memcpy(path->pts, pts, sizeof(Point)*numpts);
         memcpy(path->onoff, onoff, ONOFFSIZE(numpts));
         path->count = numpts;

         /* Link it in. */
         path->next = NULL;
         if (glyph->paths==NULL) {
            glyph->paths = path;
         } else {
            for (prev = glyph->paths; prev->next; prev=prev->next);
            prev->next = path;
         }
      }
   }

   return status;
}



/***** FUNCTIONS */

/***
** Function: AllocPSState
**
** Description:
**   This function allocates the workspace
**   used by the t1 parser.
***/
struct PSState *AllocPSState(void)
{
   struct PSState *ps;

   if ((ps = Malloc(sizeof(struct PSState)))!=NULL) {
      memset(ps, '\0', sizeof(struct PSState));
   }

   return ps;      
}


/***
** Function: FreePSState
**
** Description:
**   This function frees the workspace
**   used by the t1 parser.
***/
void FreePSState(struct PSState *ps)
{
   if (ps) {
      if (ps->onoff)
         Free(ps->onoff);
      if (ps->pts)
         Free(ps->pts);
   }

   Free(ps);
}


/***
** Function: InitPS
**
** Description:
**   This function initiate the workspace
**   used by the t1 parser.
***/
void InitPS(struct PSState *ps)
{
   ps->hr = 0;
   ps->totpts = 0;
   ps->ptr = 0;
	ps->calls = 0;
}


/***
** Function: ParseCharString
**
** Description:
**   This function parses a CharString and builds a
**   of the charstring glyph.
***/
errcode ParseCharString(T1Glyph *glyph,
                        struct Composite **comp,
                        PSState *ps,
                        const struct Subrs *subrs,
                        UBYTE *code,
                        USHORT len)
{
   Composite *c;
   Stem3 *stem3;
   Stem *stem;
   Flex *flex;
   long v, w;
   funit dx1, dy1, dx2, dy2, dx3, dy3;
   funit x0, y0, x1, y1, x2, y2, x3, y3;
   funit width, offset;
   funit o1, o2, o3, w1, w2, w3;
   long v1, v2, v3, v4;
   errcode status = SUCCESS;
   long subr, args;
   funit flexciv;
   char *glyph_name = NULL;
   USHORT zero[ENC_MAXCODES];
   char msg[64];
   int i;

   /* Keep track on the number of recursive calls. */
   ps->calls++;
   if (ps->calls>100) {
      LogError(MSG_ERROR, MSG_RECURSION, NULL);
      SetError(status = BADCHARSTRING);
      return status;
   }


   while (len) {
      v = *code++; len--;

      /* Check for space for the paths. */
      if (ps->numpts+4>=ps->maxpts) {
         Point *newpts;
         ULONG *newonoff;

         if ((newpts=Realloc(ps->pts,
                             sizeof(Point)*(ps->maxpts+BUFMARGIN)))==NULL)
            return NOMEM;
         else
            ps->pts = newpts;

         if ((newonoff=Realloc(ps->onoff,
                               ONOFFSIZE(ps->maxpts+BUFMARGIN)))==NULL)
            return NOMEM;
         else
            ps->onoff = newonoff;

         ps->maxpts += BUFMARGIN;
      }



      /* Decode integer. */
      if (v>=32) {
         if (v<=246)
            PushStack(v-139);
         else if (v<=250) {
            w = *code++; len--;
            PushStack((v-247)*256+w+108);
         } else if (v<=254) {
            w = *code++; len--;
            PushStack(-(v-251)*256-w-108);
         } else {
            v1 = *code++; len--;
            v2 = *code++; len--;
            v3 = *code++; len--;
            v4 = *code++; len--;
            PushStack(((v1*256+v2)*256+v3)*256+v4);
         }

         /* Decode command. */
      } else {
         switch (v) {
            case PSOP_HSTEM:
               width  = (funit)PopStack();
               offset = (funit)PopStack();
               if ((stem = NewStem(offset, width, ps->hr))==NULL)
                  return NOMEM;
               stem->next = glyph->hints.hstems;
               glyph->hints.hstems = stem;
               break;
            case PSOP_VSTEM:
               width  = (funit)PopStack();
               offset = (funit)PopStack()+glyph->lsb.x;
               if ((stem = NewStem(offset, width, (ps->hr)))==NULL)
                  return NOMEM;
               stem->next = glyph->hints.vstems;
               glyph->hints.vstems = stem;
               break;
            case PSOP_VMOVETO:
               CurrYPoint(ps) += (funit)PopStack();
               break;
            case PSOP_RLINETO:
               y1 = CurrYPoint(ps) + (funit)PopStack();
               x1 = CurrXPoint(ps) + (funit)PopStack();
               SetOnPoint(ps->onoff, ps->numpts);
               AddPoint(ps, x1, y1);
               break;
            case PSOP_HLINETO:
               x1 = CurrXPoint(ps) + (funit)PopStack();
               y1 = CurrYPoint(ps);
               SetOnPoint(ps->onoff, ps->numpts);
               AddPoint(ps, x1, y1);
               break;
            case PSOP_VLINETO:
               x1 = CurrXPoint(ps);
               y1 = CurrYPoint(ps) + (funit)PopStack();
               SetOnPoint(ps->onoff, ps->numpts);
               AddPoint(ps, x1, y1);
               break;
            case PSOP_RRCURVETO:
               dy3 = (funit)PopStack();
               dx3 = (funit)PopStack();
               dy2 = (funit)PopStack();
               dx2 = (funit)PopStack();
               dy1 = (funit)PopStack();
               dx1 = (funit)PopStack();

               x0 = CurrXPoint(ps);
               y0 = CurrYPoint(ps);
               x1 = x0 + dx1;
               y1 = y0 + dy1;
               x2 = x1 + dx2;
               y2 = y1 + dy2;
               x3 = x2 + dx3;
               y3 = y2 + dy3;

               AddCSpline(ps, x1, y1, x2, y2, x3, y3);
               break;
            case PSOP_CLOSEPATH:
               /* Add the path to the glyph. */
               if ((status = NewPath(glyph, ps->pts,
                                     ps->onoff, ps->numpts))!=SUCCESS)
                  return status;

               /* Current point = last point. */
               SetOnPoint(ps->onoff, 0);
               ps->pts[0] = ps->pts[ps->numpts-1];
               ps->totpts = (USHORT)(ps->totpts + ps->numpts);
               ps->numpts = 1;
               break;
            case PSOP_CALLSUBR:
               v = PopStack();
               if ((status = ParseCharString(glyph, comp, ps,
                                             subrs, subrs[v].code,
                                             subrs[v].len))!=SUCCESS)
                  return status;
               break;
            case PSOP_RETURN:
					ps->calls--;
               return SUCCESS;
            case PSOP_ESCAPE:
               v = *code++; len--;
               switch (v) {
                  case PSOP_DOTSECTION:
                     /* End of dot section? */
                     if (ps->numpts>1) {
                        ps->hr = (short)(ps->totpts+ps->numpts-1);
                        HintReplacement(glyph, (short)(ps->hr-1));
                     }
                     break;
                  case PSOP_VSTEM3:
                     w1 = (funit)PopStack();
                     o1 = (funit)PopStack()+glyph->lsb.x;
                     w2 = (funit)PopStack();
                     o2 = (funit)PopStack()+glyph->lsb.x;
                     w3 = (funit)PopStack();
                     o3 = (funit)PopStack()+glyph->lsb.x; 
                     if (o1>o2) {
                        SWAPINT(o1, o2);
                        SWAPINT(w1, w2);
                     }
                     if (o1>o3) {
                        SWAPINT(o1, o3);
                        SWAPINT(w1, w3);
                     }
                     if (o3<o2) {
                        SWAPINT(o2, o3);
                        SWAPINT(w2, w3);
                     }
                     if ((stem3 = NewStem3(o1, w1,
                                           o2, w2,
                                           o3, w3,
                                           ps->hr))==NULL)
                        return NOMEM;
                     stem3->next = glyph->hints.vstems3;
                     glyph->hints.vstems3 = stem3;
                     break;
                  case PSOP_HSTEM3:
                     w1 = (funit)PopStack(); o1 = (funit)PopStack();
                     w2 = (funit)PopStack(); o2 = (funit)PopStack();
                     w3 = (funit)PopStack(); o3 = (funit)PopStack(); 
                     if ((stem3 = NewStem3(o1, w1,
                                           o2, w2,
                                           o3, w3,
                                           ps->hr))==NULL)
                        return NOMEM;
                     stem3->next = glyph->hints.hstems3;
                     glyph->hints.hstems3 = stem3;
                     break;
                  case PSOP_SEAC:
                     if ((c=Malloc(sizeof(Composite)))==NULL) {
                        return NOMEM;
                     }
                     c->aw = glyph->width.x;
                     c->achar = LookupCharName(DecodeChar(NULL, (USHORT)0,
                                                          ENC_STANDARD,
                                                          (USHORT)PopStack()));
                     c->bchar = LookupCharName(DecodeChar(NULL, (USHORT)0,
                                                          ENC_STANDARD,
                                                          (USHORT)PopStack()));
                     if ((c->cchar = Strdup(glyph->name))==NULL)
                        return NOMEM;
                     c->oenc = NULL;
                     c->ady = (funit)PopStack();
                     c->adx = (funit)PopStack();
                     c->asbx = (funit)PopStack();
                     c->next = *comp;
                     *comp = c;
                     if (glyph->paths==NULL)
                        return SKIP;
                     if ((glyph->name = Malloc(strlen(c->achar)+
                                               strlen(c->bchar)+2))==NULL ||
                         (c->oenc = AllocEncodingTable((USHORT)1))==NULL) {
                        if (glyph->name)
                           Free(glyph->name);
                        if (c->oenc) 
                           Free(c->oenc);
                        return NOMEM;
                     }
                     strcpy(glyph->name, c->bchar);
                     strcat(glyph->name, c->achar);
                     memset(zero, '\0', sizeof(zero[0])*ENC_MAXCODES);
                     if ((glyph_name = Strdup(glyph->name))!=NULL)
                        SetEncodingEntry(c->oenc, (USHORT)0, glyph_name,
                                         ENC_MAXCODES, zero);
                     else
                        return NOMEM;
                     break;
                  case PSOP_SBW:
                     glyph->width.y = (funit)PopStack();
                     glyph->width.x = (funit)PopStack();
                     glyph->lsb.y = (funit)PopStack();
                     glyph->lsb.x = (funit)PopStack();
                     ps->pts[0].x = glyph->lsb.x;
                     ps->pts[0].y = glyph->lsb.y;
                     ps->numpts = 1;
                     SetOnPoint(ps->onoff, 0);
                     break;
                  case PSOP_DIV:
                     /* LogError("Floating point precision lost.\n"); */       
                     y1 = (funit)PopStack();
                     x1 = (funit)PopStack();
                     PushStack(((long)x1+(long)(y1>>1))/(long)y1);
                     break;
                  case PSOP_CALLOTHERSUBR:
                     subr = PopStack();
                     args = PopStack();

							/* Remember the arguments for future pop's. */
							for (i=0; i<args; i++) {
								ps->otherargs[i] = ps->stack[args-i-1];
							}
							ps->otherptr = 0;

                     switch (subr) {
                        case HINT_END_FLEX:
                           y0 = (funit)PopStack();
                           x0 = (funit)PopStack();
                           flexciv = (funit)PopStack();
                           ps->numpts--;
                           SetOffPoint(ps->onoff, ps->numpts-2);
                           SetOffPoint(ps->onoff, ps->numpts-3);
                           SetOffPoint(ps->onoff, ps->numpts-5);
                           SetOffPoint(ps->onoff, ps->numpts-6);
                           if ((flex = NewFlex(ps->flexref,
                                               PrevPoint(ps, 3),
                                               PrevPoint(ps, 6),
                                               (USHORT)(ps->totpts+
                                                        ps->numpts-7),
                                               (USHORT)(ps->totpts+
                                                        ps->numpts-4),
                                               (USHORT)(ps->totpts+
                                                        ps->numpts-1),
                                               flexciv))==NULL)
                              return NOMEM;
                           flex->next = glyph->hints.flex;
                           glyph->hints.flex = flex;
                           break;
                        case HINT_START_FLEX:
                           ps->flex = 1;
                           x0 = CurrXPoint(ps);
                           y0 = CurrYPoint(ps);
						   SetOnPoint(ps->onoff, ps->numpts);
                           AddPoint(ps, x0, y0);
                           break;
                        case HINT_MID_FLEX:
                           y0 = CurrYPoint(ps);
                           x0 = CurrXPoint(ps);
                           if (ps->flex==1) {
                              ps->flexref.x = x0;
                              ps->flexref.y = y0;
                              ps->flex=0;
                           } else {
							  SetOnPoint(ps->onoff, ps->numpts);
                              AddPoint(ps, x0, y0);
                           }
                           break;
                        case HINT_REPLACEMENT:
                           ps->hr = (short)(ps->totpts+ps->numpts-1);
                           HintReplacement(glyph, (short)(ps->hr-1));
                           (void)PopStack();
                           break;
                        default:
                           ps->ptr = (USHORT)(ps->ptr - args);
                           break;
                     }
                     break;
                        case PSOP_POP:
									PushStack(ps->otherargs[ps->otherptr++]);
                           break;
                        case PSOP_SETCURRENTPOINT:
                           (ps->ptr) -= 2;
                           break;
                        case 15:
                           ps->ptr-=2;
                           break;
                        default:
                           LogError(MSG_ERROR, MSG_BADESC, NULL);
                           SetError(status = BADCHARSTRING);
                           return status;
               }
               break;
            case PSOP_HSBW:
               glyph->width.x = (funit)PopStack();
               glyph->width.y = 0;
               glyph->lsb.x = (funit)PopStack();
               glyph->lsb.y = 0;
               ps->pts[0].x = glyph->lsb.x;
               ps->pts[0].y = 0;
               ps->numpts = 1;
               SetOnPoint(ps->onoff, 0);
               break;
            case PSOP_ENDCHAR:
               if (ps->numpts>1) {
                  if ((status = NewPath(glyph, ps->pts,
                                        ps->onoff, ps->numpts))!=SUCCESS)
                     return status;
               }
               return SUCCESS;
            case PSOP_RMOVETO:
               CurrYPoint(ps) += (funit)PopStack();
               CurrXPoint(ps) += (funit)PopStack();
               break;
            case PSOP_HMOVETO:
               CurrXPoint(ps) += (funit)PopStack();
               break;
            case PSOP_VHCURVETO:
               dy3 = 0;
               dx3 = (funit)PopStack();
               dy2 = (funit)PopStack();
               dx2 = (funit)PopStack();
               dy1 = (funit)PopStack();
               dx1 = 0;

               x0 = CurrXPoint(ps);
               y0 = CurrYPoint(ps);
               x1 = x0 + dx1;
               y1 = y0 + dy1;
               x2 = x1 + dx2;
               y2 = y1 + dy2;
               x3 = x2 + dx3;
               y3 = y2 + dy3;

               AddCSpline(ps, x1, y1, x2, y2, x3, y3);
               break;
            case PSOP_HVCURVETO:
               dy3 = (funit)PopStack();
               dx3 = 0;
               dy2 = (funit)PopStack();
               dx2 = (funit)PopStack();
               dy1 = 0;
               dx1 = (funit)PopStack();

               x0 = CurrXPoint(ps);
               y0 = CurrYPoint(ps);
               x1 = x0 + dx1;
               y1 = y0 + dy1;
               x2 = x1 + dx2;
               y2 = y1 + dy2;
               x3 = x2 + dx3;
               y3 = y2 + dy3;

               AddCSpline(ps, x1, y1, x2, y2, x3, y3);
               break;
            case 15:
               ps->ptr -=2;
               break;

            default:
               strcpy(msg,  "'00' (00)");
               msg[1] = (char)('0' + (v/10));
               msg[2] = (char)('0' + (v%10));
               msg[6] = (char)('0' + (ps->ptr/10));
               msg[7] = (char)('0' + (ps->ptr%10));
               LogError(MSG_ERROR, MSG_BADOP, msg);
               SetError(status = BADCHARSTRING);
               return status;
         }
      }

      /* Check number of elements on the stack. */
      if (ps->ptr>MAXSTACK)
         return BADCHARSTRING;
   }

   return SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\encoding.c ===
/***
 **
 **   Module: Encoding
 **
 **   Description:
 **      This is a module of the T1 to TT font converter. The module
 **      contains interface functions for the global encoding table,
 **      i.e. this is an abstract data type.
 **
 **   Author: Michael Jansson
 **
 **   Created: 6/13/93
 **
 ***/


/**** INCLUDES */
#include <string.h>
#include "types.h"
#include "encoding.h"
#include "safemem.h"



/***** LOCAL TYPES */
struct encoding {
   const char *name;            /* Postscript name of a glyph. */
   USHORT codes[ENC_MAXCODES];  /* Character codes for each encoding scheme. */
};


/***** CONSTANTS */
static const struct encoding StdEncoding[] = {
   {".notdef",       {0xffff, 0xffff, 0xffff, 0xffff}},
   {"A",             {0x0041, 0x0041, 0x0041, 0x0041}},
   {"AE",            {0x00c6, 0x00c6, 0x00e1, 174   }},
   {"Aacute",        {0x00c1, 0x00c1, 0xffff, 231   }},
   {"Abreve",        {0x0102, 0xffff, 0xffff, 0xffff}},
   {"Acircumflex",   {0x00c2, 0x00c2, 0xffff, 229   }},
   {"Adieresis",     {0x00c4, 0x00c4, 0xffff, 128   }},
   {"Agrave",        {0x00c0, 0x00c0, 0xffff, 203   }},
   {"Aogonek",       {0x0104, 0xffff, 0xffff, 0xffff}},
   {"Aring",         {0x00c5, 0x00c5, 0xffff, 129   }},
   {"Atilde",        {0x00c3, 0x00c3, 0xffff, 204   }},
   {"B",             {0x0042, 0x0042, 0x0042, 0x0042}},
   {"C",             {0x0043, 0x0043, 0x0043, 0x0043}},
   {"Cacute",        {0x0106, 0xffff, 0xffff, 0xffff}},
   {"Ccaron",        {0x010c, 0xffff, 0xffff, 0xffff}},
   {"Ccedilla",      {0x00c7, 0x00c7, 0xffff, 130   }},
   {"D",             {0x0044, 0x0044, 0x0044, 0x0044}},
   {"Dcaron",        {0x010e, 0xffff, 0xffff, 0xffff}},
   {"Delta",         {0x2206, 0xffff, 0xffff, 198   }},
   {"Dslash",        {0x0110, 0xffff, 0xffff, 0xffff}},
   {"E",             {0x0045, 0x0045, 0x0045, 0x0045}},
   {"Eacute",        {0x00c9, 0x00c9, 0xffff, 131   }},
   {"Ecaron",        {0x011a, 0xffff, 0xffff, 0xffff}},
   {"Ecircumflex",   {0x00ca, 0x00ca, 0xffff, 230   }},
   {"Edieresis",     {0x00cb, 0x00cb, 0xffff, 232   }},
   {"Egrave",        {0x00c8, 0x00c8, 0xffff, 233   }},
   {"Eogonek",       {0x0118, 0xffff, 0xffff, 0xffff}},
   {"Eth",           {0x00d0, 0x00d0, 0xffff, 0xffff}},
   {"F",             {0x0046, 0x0046, 0x0046, 0x0046}},
   {"G",             {0x0047, 0x0047, 0x0047, 0x0047}},
   {"Gamma",         {0x0393, 0xffff, 0xffff, 0xffff}},
   {"Gbreve",        {0x011e, 0xffff, 0xffff, 0xffff}},
   {"H",             {0x0048, 0x0048, 0x0048, 0x0048}},
   {"I",             {0x0049, 0x0049, 0x0049, 0x0049}},
   {"Iacute",        {0x00cd, 0x00cd, 0xffff, 234   }},
   {"Icircumflex",   {0x00ce, 0x00ce, 0xffff, 235   }},
   {"Idieresis",     {0x00cf, 0x00cf, 0xffff, 236   }},
   {"Idot",          {0x0130, 0xffff, 0xffff, 0xffff}},
   {"Igrave",        {0x00cc, 0x00cc, 0xffff, 237   }},
   {"J",             {0x004a, 0x004a, 0x004a, 0x004a}},
   {"K",             {0x004b, 0x004b, 0x004b, 0x004b}},
   {"L",             {0x004c, 0x004c, 0x004c, 0x004c}},
   {"Lacute",        {0x0139, 0xffff, 0xffff, 0xffff}},
   {"Lcaron",        {0x013d, 0xffff, 0xffff, 0xffff}},
   {"Ldot",          {0x013f, 0xffff, 0xffff, 0xffff}},
   {"Lslash",        {0x0141, 0xffff, 0x00e8, 0xffff}},
   {"M",             {0x004d, 0x004d, 0x004d, 0x004d}},
   {"N",             {0x004e, 0x004e, 0x004e, 0x004e}},
   {"Nacute",        {0x0143, 0xffff, 0xffff, 0xffff}},
   {"Ncaron",        {0x0147, 0xffff, 0xffff, 0xffff}},
   {"Ntilde",        {0x00d1, 0x00d1, 0xffff, 132   }},
   {"O",             {0x004f, 0x004f, 0x004f, 0x004f}},
   {"OE",            {0x0152, 0x008c, 0x00ea, 206   }},
   {"Oacute",        {0x00d3, 0x00d3, 0xffff, 238   }},
   {"Ocircumflex",   {0x00d4, 0x00d4, 0xffff, 239   }},
   {"Odblacute",     {0x0150, 0xffff, 0xffff, 0xffff}},
   {"Odieresis",     {0x00d6, 0x00d6, 0xffff, 133   }},
   {"Ograve",        {0x00d2, 0x00d2, 0xffff, 241   }},
   {"Oslash",        {0x00d8, 0x00d8, 0x00e9, 175   }},
   {"Otilde",        {0x00d5, 0x00d5, 0xffff, 205   }},
   {"P",             {0x0050, 0x0050, 0x0050, 0x0050}},
   {"Phi",           {0x03a6, 0xffff, 0xffff, 0xffff}},
   {"Q",             {0x0051, 0x0051, 0x0051, 0x0051}},
   {"R",             {0x0052, 0x0052, 0x0052, 0x0052}},
   {"Racute",        {0x0154, 0xffff, 0xffff, 0xffff}},
   {"Rcaron",        {0x0158, 0xffff, 0xffff, 0xffff}},
   {"S",             {0x0053, 0x0053, 0x0053, 0x0053}},
   {"Sacute",        {0x015a, 0xffff, 0xffff, 0xffff}},
   {"Scaron",        {0x0160, 0x008A, 0xffff, 0xffff}},
   {"Scedilla",      {0x015e, 0xffff, 0xffff, 0xffff}},
   {"T",             {0x0054, 0x0054, 0x0054, 0x0054}},
   {"Tcaron",        {0x0164, 0xffff, 0xffff, 0xffff}},
   {"Tcedilla",      {0x0162, 0xffff, 0xffff, 0xffff}},
   {"Theta",         {0x0398, 0xffff, 0xffff, 0xffff}},
   {"Thorn",         {0x00de, 0x00de, 0xffff, 0xffff}},
   {"U",             {0x0055, 0x0055, 0x0055, 0x0055}},
   {"Uacute",        {0x00da, 0x00da, 0xffff, 242   }},
   {"Ucircumflex",   {0x00db, 0x00db, 0xffff, 243   }},
   {"Udblacute",     {0x0170, 0xffff, 0xffff, 0xffff}},
   {"Udieresis",     {0x00dc, 0x00dc, 0xffff, 134   }},
   {"Ugrave",        {0x00d9, 0x00d9, 0xffff, 244   }},
   {"Uring",         {0x016e, 0xffff, 0xffff, 0xffff}},
   {"V",             {0x0056, 0x0056, 0x0056, 0x0056}},
   {"W",             {0x0057, 0x0057, 0x0057, 0x0057}},
   {"X",             {0x0058, 0x0058, 0x0058, 0x0058}},
   {"Y",             {0x0059, 0x0059, 0x0059, 0x0059}},
   {"Yacute",        {0x00dd, 0x00dd, 0xffff, 0xffff}},
   {"Ydieresis",     {0x0178, 0x009f, 0xffff, 217   }},
   {"Z",             {0x005a, 0x005a, 0x005a, 0x005a}},
   {"Zacute",        {0x0179, 0xffff, 0xffff, 0xffff}},
   {"Zcaron",        {0x017d, 0xffff, 0xffff, 0xffff}},
   {"Zdot",          {0x017b, 0xffff, 0xffff, 0xffff}},
   {"a",             {0x0061, 0x0061, 0x0061, 0x0061}},
   {"aacute",        {0x00e1, 0x00e1, 0xffff, 135   }},
   {"abreve",        {0x0103, 0xffff, 0xffff, 0xffff}},
   {"acircumflex",   {0x00e2, 0x00e2, 0xffff, 137   }},
   {"acute",         {0x00b4, 0x00b4, 0x00c2, 171   }},
   {"adieresis",     {0x00e4, 0x00e4, 0xffff, 138   }},
   {"ae",            {0x00e6, 0x00e6, 0x00f1, 190   }},
   {"agrave",        {0x00e0, 0x00e0, 0xffff, 136   }},
   {"alpha",         {0x03b1, 0xffff, 0xffff, 0xffff}},
   {"ampersand",     {0x0026, 0x0026, 0x0026, 0x0026}},
   {"aogonek",       {0x0105, 0xffff, 0xffff, 0xffff}},
   {"apple",         {0xf000, 0x000, 0xffff, 240   }},
   {"approxequal",   {0x2248, 0xffff, 0xffff, 197   }},
   {"aring",         {0x00e5, 0x00e5, 0xffff, 140   }},
   {"arrowboth",     {0x2194, 0xffff, 0xffff, 0xffff}},
   {"arrowdown",     {0x2193, 0xffff, 0xffff, 0xffff}},
   {"aroowleft",     {0x2190, 0xffff, 0xffff, 0xffff}},
   {"arrowright",    {0x2192, 0xffff, 0xffff, 0xffff}},
   {"arrowup",       {0x2191, 0xffff, 0xffff, 0xffff}},
   {"arrowupdn",     {0x2195, 0xffff, 0xffff, 0xffff}},
   {"arrowupdnbse",  {0x21a8, 0xffff, 0xffff, 0xffff}},
   {"asciicircum",   {0x005e, 0x005e, 0x005e, 0x005e}},
   {"asciitilde",    {0x007e, 0x007e, 0x007e, 0x007e}},
   {"asterisk",      {0x002a, 0x002a, 0x002a, 0x002a}},
   {"at",            {0x0040, 0x0040, 0x0040, 0x0040}},
   {"atilde",        {0x00e3, 0x00e3, 0xffff, 139   }},
   {"b",             {0x0062, 0x0062, 0x0062, 0x0062}},
   {"backslash",     {0x005c, 0x005c, 0x005c, 0x005c}},
   {"bar",           {0x007c, 0x007c, 0x007c, 0x007c}},
   {"block",         {0x2588, 0xffff, 0xffff, 0xffff}},
   {"braceleft",     {0x007b, 0x007b, 0x007b, 0x007b}},
   {"braceright",    {0x007d, 0x007d, 0x007d, 0x007d}},
   {"bracketleft",   {0x005b, 0x005b, 0x005b, 0x005b}},
   {"bracketright",  {0x005d, 0x005d, 0x005d, 0x005d}},
   {"breve",         {0x02d8, 0xffff, 0x00c6, 249   }},
   {"brokenbar",     {0x00a6, 0x00a6, 0xffff, 0xffff}},
   {"bullet",        {0x2022, 0x0095, 0x00b7, 165   }},
   {"c",             {0x0063, 0x0063, 0x0063, 0x0063}},
   {"cacute",        {0x0107, 0xffff, 0xffff, 0xffff}},
   {"caron",         {0x02c7, 0xffff, 0x00cf, 255   }},
   {"ccaron",        {0x010d, 0xffff, 0xffff, 0xffff}},
   {"ccedilla",      {0x00e7, 0x00e7, 0xffff, 141   }},
   {"cedilla",       {0x00b8, 0x00b8, 0x00cb, 252   }},
   {"cent",          {0x00a2, 0x00a2, 0x00a2, 162   }},
   {"circle",        {0x25cb, 0xffff, 0xffff, 0xffff}},
   {"circumflex",    {0x02c6, 0x0088, 0x00c3, 246   }},
   {"club",          {0x2663, 0xffff, 0xffff, 0xffff}},
   {"colon",         {0x003a, 0x003a, 0x003a, 0x003a}},
   {"comma",         {0x002c, 0x002c, 0x002c, 0x002c}},
   {"copyright",     {0x00a9, 0x00a9, 0xffff, 169   }},
   {"currency",      {0x00a4, 0x00a4, 0x00a8, 219   }},
   {"d",             {0x0064, 0x0064, 0x0064, 0x0064}},
   {"dagger",        {0x2020, 0x0086, 0x00b2, 160   }},
   {"daggerdbl",     {0x2021, 0x0087, 0x00b3, 224   }},
   {"dcaron",        {0x010f, 0xffff, 0xffff, 0xffff}},
   {"degree",        {0x00b0, 0x00b0, 0xffff, 161   }},
   {"delta",         {0x03b4, 0xffff, 0xffff, 0xffff}},
   {"diamond",       {0x2666, 0xffff, 0xffff, 0xffff}},
   {"dieresis",      {0x00a8, 0x00a8, 0x00c8, 172   }},
   {"divide",        {0x00f7, 0x00f7, 0xffff, 214   }},
   {"dkshade",       {0x2593, 0xffff, 0xffff, 0xffff}},
   {"dmacron",       {0x0111, 0xffff, 0xffff, 0xffff}},
   {"dnblock",       {0x2584, 0xffff, 0xffff, 0xffff}},
   {"dollar",        {0x0024, 0x0024, 0x0024, 0x0024}},
   {"dotaccent",     {0x02d9, 0xffff, 0x00c7, 250   }},
   {"dotlessi",      {0x0131, 0xffff, 0x00f5, 245   }},
   {"e",             {0x0065, 0x0065, 0x0065, 0x0065}},
   {"eacute",        {0x00e9, 0x00e9, 0xffff, 142   }},
   {"ecaron",        {0x011b, 0xffff, 0xffff, 0xffff}},
   {"ecircumflex",   {0x00ea, 0x00ea, 0xffff, 144   }},
   {"edieresis",     {0x00eb, 0x00eb, 0xffff, 145   }},
   {"egrave",        {0x00e8, 0x00e8, 0xffff, 143   }},
   {"eight",         {0x0038, 0x0038, 0x0038, 0x0038}},
   {"ellipsis",      {0x2026, 0x0085, 0x00bc, 201   }},
   {"emdash",        {0x2014, 0x0097, 0x00d0, 209   }},
   {"endash",        {0x2013, 0x0096, 0x00b1, 208   }},
   {"eogonek",       {0x0119, 0xffff, 0xffff, 0xffff}},
   {"epsilon",       {0x03b4, 0xffff, 0xffff, 0xffff}},
   {"equal",         {0x003d, 0x003d, 0x003d, 0x003d}},
   {"equivalence",   {0x2261, 0xffff, 0xffff, 0xffff}},
   {"eth",           {0x00f0, 0x00f0, 0xffff, 0xffff}},
   {"exclam",        {0x0021, 0x0021, 0x0021, 0x0021}},
   {"exclamdbl",     {0x203c, 0xffff, 0xffff, 0xffff}},
   {"exclamdown",    {0x00a1, 0x00a1, 0x00a1, 193   }},
   {"f",             {0x0066, 0x0066, 0x0066, 0x0066}},
   {"female",        {0x2640, 0xffff, 0xffff, 0xffff}},
   {"fi",            {0xf001, 0xffff, 0x00ae, 222   }},
   {"filledbox",     {0x25a0, 0xffff, 0xffff, 0xffff}},
   {"filledrect",    {0x25ac, 0xffff, 0xffff, 0xffff}},
   {"five",          {0x0035, 0x0035, 0x0035, 0x0035}},
   {"fl",            {0xf002, 0xffff, 0x00af, 223   }},
   {"florin",        {0x0192, 0x0083, 0x00a6, 196   }},
   {"four",          {0x0034, 0x0034, 0x0034, 0x0034}},
   {"fraction",      {0x2215, 0xffff, 0x00a4, 218   }},
   {"franc",         {0x20a3, 0xffff, 0xffff, 0xffff}},
   {"g",             {0x0067, 0x0067, 0x0067, 0x0067}},
   {"gbreve",        {0x011f, 0xffff, 0xffff, 0xffff}},
   {"germandbls",    {0x00df, 0x00df, 0x00fb, 167   }},
   {"grave",         {0x0060, 0x0060, 0x00c1, 0x0060}},
   {"greater",       {0x003e, 0x003e, 0x003e, 0x003e}},
   {"greaterequal",  {0x2265, 0xffff, 0xffff, 179   }},
   {"guillemotleft", {0x00ab, 0x00ab, 0x00ab, 199   }},
   {"guillemotright",{0x00bb, 0x00bb, 0x00bb, 200   }},
   {"guilsinglleft", {0x2039, 0x008b, 0x00ac, 220   }},
   {"guilsinglright",{0x203a, 0x009b, 0x00ad, 221   }},
   {"h",             {0x0068, 0x0068, 0x0068, 0x0068}},
   {"heart",         {0x2665, 0xffff, 0xffff, 0xffff}},
   {"house",         {0x2302, 0xffff, 0xffff, 0xffff}},
   {"hungarumlaut",  {0x02dd, 0xffff, 0x00cd, 0xffff}},
   {"hyphen",        {0x002d, 0x002d, 0x002d, 0x002d}},
   {"i",             {0x0069, 0x0069, 0x0069, 0x0069}},
   {"iacute",        {0x00ed, 0x00ed, 0xffff, 146   }},
   {"icircumflex",   {0x00ee, 0x00ee, 0xffff, 148   }},
   {"idieresis",     {0x00ef, 0x00ef, 0xffff, 149   }},
   {"igrave",        {0x00ec, 0x00ec, 0xffff, 147   }},
   {"infinity",      {0x221e, 0xffff, 0xffff, 176   }},
   {"integral",      {0x222b, 0xffff, 0xffff, 186   }},
   {"integralbt",    {0x2321, 0xffff, 0xffff, 0xffff}},
   {"integraltp",    {0x2320, 0xffff, 0xffff, 0xffff}},
   {"intersection",  {0x2229, 0xffff, 0xffff, 0xffff}},
   {"invbullet",     {0x25d8, 0xffff, 0xffff, 0xffff}},
   {"invcircle",     {0x25d9, 0xffff, 0xffff, 0xffff}},
   {"invsmileface",  {0x263b, 0xffff, 0xffff, 0xffff}},
   {"j",             {0x006a, 0x006a, 0x006a, 0x006a}},
   {"k",             {0x006b, 0x006b, 0x006b, 0x006b}},
   {"l",             {0x006c, 0x006c, 0x006c, 0x006c}},
   {"lacute",        {0x013a, 0xffff, 0xffff, 0xffff}},
   {"lcaron",        {0x013e, 0xffff, 0xffff, 0xffff}},
   {"ldot",          {0x0140, 0xffff, 0xffff, 0xffff}},
   {"less",          {0x003c, 0x003c, 0x003c, 0x003c}},
   {"lessequal",     {0x2264, 0xffff, 0xffff, 178   }},
   {"lfblock",       {0x258c, 0xffff, 0xffff, 0xffff}},
   {"logicalnot",    {0x00ac, 0x00ac, 0xffff, 194   }},
   {"lozenge",       {0x25ca, 0xffff, 0xffff, 215   }},
   {"lslash",        {0x0142, 0xffff, 0x00f8, 0xffff}},
   {"ltshade",       {0x2591, 0xffff, 0xffff, 0xffff}},
   {"m",             {0x006d, 0x006d, 0x006d, 0x006d}},
   {"macron",        {0x00af, 0xffff, 0x00c5, 248   }},
   {"male",          {0x2642, 0xffff, 0xffff, 0xffff}},
   {"middot",        {0x00b7, 0x00b7, 0xffff, 0xffff}},
   {"minus",         {0x2212, 0xffff, 0xffff, 0xffff}},
   {"mu",            {0x00b5, 0x00b5, 0xffff, 181   }},
   {"multiply",      {0x00d7, 0x00d7, 0xffff, 0xffff}},
   {"musicalnote",   {0x266a, 0xffff, 0xffff, 0xffff}},
   {"musicalnotedbl",{0x266b, 0xffff, 0xffff, 0xffff}},
   {"n",             {0x006e, 0x006e, 0x006e, 0x006e}},
   {"nacute",        {0x0144, 0xffff, 0xffff, 0xffff}},
   {"nbspace",       {0x00a0, 0x00a0, 0xffff, 0xffff}},
   {"ncaron",        {0x0148, 0xffff, 0xffff, 0xffff}},
   {"nine",          {0x0039, 0x0039, 0x0039, 0x0039}},
   {"notequal",      {0x2260, 0xffff, 0xffff, 173   }},
   {"nsuperior",     {0x207f, 0xffff, 0xffff, 0xffff}},
   {"ntilde",        {0x00f1, 0x00f1, 0xffff, 150   }},
   {"numbersign",    {0x0023, 0x0023, 0x0023, 0x0023}},
   {"o",             {0x006f, 0x006f, 0x006f, 0x006f}},
   {"oacute",        {0x00f3, 0x00f3, 0xffff, 151   }},
   {"ocircumflex",   {0x00f4, 0x00f4, 0xffff, 153   }},
   {"odblacute",     {0x0151, 0xffff, 0xffff, 0xffff}},
   {"odieresis",     {0x00f6, 0x00f6, 0xffff, 154   }},
   {"oe",            {0x0153, 0x009c, 0x00fa, 207   }},
   {"ogonek",        {0x02db, 0xffff, 0x00ce, 254   }},
   {"ograve",        {0x00f2, 0x00f2, 0xffff, 152   }},
   {"ohm",           {0x2126, 0xffff, 0xffff, 189   }},
   {"one",           {0x0031, 0x0031, 0x0031, 0x0031}},
   {"onehalf",       {0x00bd, 0x00bd, 0xffff, 0xffff}},
   {"onequarter",    {0x00bc, 0x00bc, 0xffff, 0xffff}},
   {"onesuperior",   {0x00b9, 0x00b9, 0xffff, 0xffff}},
   {"ordfeminine",   {0x00aa, 0x00aa, 0x00e3, 187   }},
   {"ordmasculine",  {0x00ba, 0x00ba, 0x00eb, 188   }},
   {"orthogonal",    {0x221f, 0xffff, 0xffff, 0xffff}},
   {"oslash",        {0x00f8, 0x00f8, 0x00f9, 191   }},
   {"otilde",        {0x00f5, 0x00f5, 0xffff, 155   }},
   {"overscore",     {0x00af, 0x00af, 0xffff, 0xffff}},
   {"p",             {0x0070, 0x0070, 0x0070, 0x0070}},
   {"paragraph",     {0x00b6, 0x00b6, 0x00b6, 166   }},
   {"parenleft",     {0x0028, 0x0028, 0x0028, 0x0028}},
   {"parenright",    {0x0029, 0x0029, 0x0029, 0x0029}},
   {"partialdiff",   {0x2202, 0xffff, 0xffff, 182   }},
   {"percent",       {0x0025, 0x0025, 0x0025, 0x0025}},
   {"period",        {0x002e, 0x002e, 0x002e, 0x002e}},
   {"periodcentered",{0x2219, 0xffff, 0x00b4, 225   }},
   {"perthousand",   {0x2030, 0x0089, 0x00bd, 228   }},
   {"peseta",        {0x20a7, 0xffff, 0xffff, 0xffff}},
   {"phi",           {0x03c6, 0xffff, 0xffff, 0xffff}},
   {"pi",            {0x03c0, 0xffff, 0xffff, 185   }},
   {"plus",          {0x002b, 0x002b, 0x002b, 0x002b}},
   {"plusminus",     {0x00b1, 0x00b1, 0xffff, 177   }},
   {"product",       {0x220f, 0xffff, 0xffff, 184   }},
   {"q",             {0x0071, 0x0071, 0x0071, 0x0071}},
   {"question",      {0x003f, 0x003f, 0x003f, 0x003f}},
   {"questiondown",  {0x00bf, 0x00bf, 0x00bf, 192   }},
   {"quotedbl",      {0x0022, 0x0022, 0x0022, 0x0022}},
   {"quotedblbase",  {0x201e, 0x0084, 0x00b9, 227   }},
   {"quotedblleft",  {0x201c, 0x0093, 0x00aa, 210   }},
   {"quotedblright", {0x201d, 0x0094, 0x00ba, 211   }},
   {"quoteleft",     {0x2018, 0x0091, 0x0060, 212   }},
   {"quoteright",    {0x2019, 0x0092, 0x0027, 213   }},
   {"quotesinglbase",{0x201a, 0x0082, 0x00b8, 226   }},
   {"quotesingle",   {0x0027, 0x0027, 0x00a9, 0x0027}},
   {"r",             {0x0072, 0x0072, 0x0072, 0x0072}},
   {"racute",        {0x0155, 0xffff, 0xffff, 0xffff}},
   {"radical",       {0x221a, 0xffff, 0xffff, 195   }},
   {"rcaron",        {0x0159, 0xffff, 0xffff, 0xffff}},
   {"registered",    {0x00ae, 0x00ae, 0xffff, 168   }},
   {"revlogicalnot", {0x2310, 0xffff, 0xffff, 0xffff}},
   {"ring",          {0x02da, 0xffff, 0x00ca, 251   }},
   {"rtblock",       {0x2590, 0xffff, 0xffff, 0xffff}},
   {"s",             {0x0073, 0x0073, 0x0073, 0x0073}},
   {"sacute",        {0x015b, 0xffff, 0xffff, 0xffff}},
   {"scaron",        {0x0161, 0x009a, 0xffff, 0xffff}},
   {"scedilla",      {0x015f, 0xffff, 0xffff, 0xffff}},
   {"section",       {0x00a7, 0x00a7, 0x00a7, 164   }},
   {"semicolon",     {0x003b, 0x003b, 0x003b, 0x003b}},
   {"seven",         {0x0037, 0x0037, 0x0037, 0x0037}},
   {"sfthyphen",     {0x00ad, 0x00ad, 0xffff, 0xffff}},
   {"shade",         {0x2592, 0xffff, 0xffff, 0xffff}},
   {"sigma",         {0x03c3, 0xffff, 0xffff, 0xffff}},
   {"six",           {0x0036, 0x0036, 0x0036, 0x0036}},
   {"slash",         {0x002f, 0x002f, 0x002f, 0x002f}},
   {"smileface",     {0x263a, 0xffff, 0xffff, 0xffff}},
   {"space",         {0x0020, 0x0020, 0x0020, 0x0020}},
   {"spade",         {0x2660, 0xffff, 0xffff, 0xffff}},
   {"sterling",      {0x00a3, 0x00a3, 0x00a3, 163   }},
   {"summation",     {0x2211, 0xffff, 0xffff, 183   }},
   {"sun",           {0x263c, 0xffff, 0xffff, 0xffff}},
   {"t",             {0x0074, 0x0074, 0x0074, 0x0074}},
   {"tau",           {0x03c4, 0xffff, 0xffff, 0xffff}},
   {"tcaron",        {0x0165, 0xffff, 0xffff, 0xffff}},
   {"tcedilla",      {0x0163, 0xffff, 0xffff, 0xffff}},
   {"thorn",         {0x00fe, 0x00fe, 0xffff, 0xffff}},
   {"three",         {0x0033, 0x0033, 0x0033, 0x0033}},
   {"threequarters", {0x00be, 0x00be, 0xffff, 0xffff}},
   {"threesuperior", {0x00b3, 0x00b3, 0xffff, 0xffff}},
   {"tilde",         {0x02dc, 0x0098, 0x00c4, 245   }},
   {"trademark",     {0x2122, 0x0099, 0xffff, 170   }},
   {"triagdn",       {0x25bc, 0xffff, 0xffff, 0xffff}},
   {"triagrt",       {0x25ba, 0xffff, 0xffff, 0xffff}},
   {"triagup",       {0x25b2, 0xffff, 0xffff, 0xffff}},
   {"traglf",        {0x25c4, 0xffff, 0xffff, 0xffff}},
   {"two",           {0x0032, 0x0032, 0x0032, 0x0032}},
   {"twosuperior",   {0x00b2, 0x00b2, 0xffff, 0xffff}},
   {"u",             {0x0075, 0x0075, 0x0075, 0x0075}},
   {"uacute",        {0x00fa, 0x00fa, 0xffff, 156   }},
   {"ucircumflex",   {0x00fb, 0x00fb, 0xffff, 158   }},
   {"udblacute",     {0x0171, 0xffff, 0xffff, 0xffff}},
   {"udieresis",     {0x00fc, 0x00fc, 0xffff, 159   }},
   {"ugrave",        {0x00f9, 0x00f9, 0xffff, 157   }},
   {"underscore",    {0x005f, 0x005f, 0x005f, 0x005f}},
   {"underscoredbl", {0x2017, 0xffff, 0xffff, 0xffff}},
   {"upblock",       {0x2580, 0xffff, 0xffff, 0xffff}},
   {"uring",         {0x016f, 0xffff, 0xffff, 0xffff}},
   {"v",             {0x0076, 0x0076, 0x0076, 0x0076}},
   {"w",             {0x0077, 0x0077, 0x0077, 0x0077}},
   {"x",             {0x0078, 0x0078, 0x0078, 0x0078}},
   {"y",             {0x0079, 0x0079, 0x0079, 0x0079}},
   {"yacute",        {0x00fd, 0x00fd, 0xffff, 0xffff}},
   {"ydieresis",     {0x00ff, 0x00ff, 0xffff, 216   }},
   {"yen",           {0x00a5, 0x00a5, 0x00a5, 180   }},
   {"z",             {0x007a, 0x007a, 0x007a, 0x007a}},
   {"zacute",        {0x017a, 0xffff, 0xffff, 0xffff}},
   {"zcaron",        {0x017e, 0xffff, 0xffff, 0xffff}},
   {"zdot",          {0x017c, 0xffff, 0xffff, 0xffff}},
   {"zero",          {0x0030, 0x0030, 0x0030, 0x0030}},
};


static const struct encoding SeacEncoding[] = {
   {"A",             {0xf041, 0x0041, 0x0041, 0x0041}},
   {"AE",            {0xf0c6, 0x00c6, 0x00e1, 174   }},
   {"B",             {0xf042, 0x0042, 0x0042, 0x0042}},
   {"C",             {0xf043, 0x0043, 0x0043, 0x0043}},
   {"D",             {0xf044, 0x0044, 0x0044, 0x0044}},
   {"E",             {0xf045, 0x0045, 0x0045, 0x0045}},
   {"F",             {0xf046, 0x0046, 0x0046, 0x0046}},
   {"G",             {0xf047, 0x0047, 0x0047, 0x0047}},
   {"H",             {0xf048, 0x0048, 0x0048, 0x0048}},
   {"I",             {0xf049, 0x0049, 0x0049, 0x0049}},
   {"J",             {0xf04a, 0x004a, 0x004a, 0x004a}},
   {"K",             {0xf04b, 0x004b, 0x004b, 0x004b}},
   {"L",             {0xf04c, 0x004c, 0x004c, 0x004c}},
   {"Lslash",        {0xf141, 0xffff, 0x00e8, 0xffff}},
   {"M",             {0xf04d, 0x004d, 0x004d, 0x004d}},
   {"N",             {0xf04e, 0x004e, 0x004e, 0x004e}},
   {"O",             {0xf04f, 0x004f, 0x004f, 0x004f}},
   {"OE",            {0xf152, 0x008c, 0x00ea, 206   }},
   {"Oslash",        {0xf0d8, 0x00d8, 0x00e9, 175   }},
   {"P",             {0xf050, 0x0050, 0x0050, 0x0050}},
   {"Q",             {0xf051, 0x0051, 0x0051, 0x0051}},
   {"R",             {0xf052, 0x0052, 0x0052, 0x0052}},
   {"S",             {0xf053, 0x0053, 0x0053, 0x0053}},
   {"T",             {0xf054, 0x0054, 0x0054, 0x0054}},
   {"U",             {0xf055, 0x0055, 0x0055, 0x0055}},
   {"V",             {0xf056, 0x0056, 0x0056, 0x0056}},
   {"W",             {0xf057, 0x0057, 0x0057, 0x0057}},
   {"X",             {0xf058, 0x0058, 0x0058, 0x0058}},
   {"Y",             {0xf059, 0x0059, 0x0059, 0x0059}},
   {"Z",             {0xf05a, 0x005a, 0x005a, 0x005a}},
   {"a",             {0xf061, 0x0061, 0x0061, 0x0061}},
   {"acute",         {0xf0b4, 0x00b4, 0x00c2, 171   }},
   {"ae",            {0xf0e6, 0x00e6, 0x00f1, 190   }},
   {"ampersand",     {0xf026, 0x0026, 0x0026, 0x0026}},
   {"asciicircum",   {0xf05e, 0x005e, 0x005e, 0x005e}},
   {"asciitilde",    {0xf07e, 0x007e, 0x007e, 0x007e}},
   {"asterisk",      {0xf02a, 0x002a, 0x002a, 0x002a}},
   {"at",            {0xf040, 0x0040, 0x0040, 0x0040}},
   {"b",             {0xf062, 0x0062, 0x0062, 0x0062}},
   {"backslash",     {0xf05c, 0x005c, 0x005c, 0x005c}},
   {"bar",           {0xf07c, 0x007c, 0x007c, 0x007c}},
   {"braceleft",     {0xf07b, 0x007b, 0x007b, 0x007b}},
   {"braceright",    {0xf07d, 0x007d, 0x007d, 0x007d}},
   {"bracketleft",   {0xf05b, 0x005b, 0x005b, 0x005b}},
   {"bracketright",  {0xf05d, 0x005d, 0x005d, 0x005d}},
   {"breve",         {0xf2d8, 0xffff, 0x00c6, 249   }},
   {"bullet",        {0x2022, 0x0095, 0x00b7, 165   }},
   {"c",             {0xf063, 0x0063, 0x0063, 0x0063}},
   {"caron",         {0xf2c7, 0xffff, 0x00cf, 255   }},
   {"cedilla",       {0xf0b8, 0x00b8, 0x00cb, 252   }},
   {"cent",          {0xf0a2, 0x00a2, 0x00a2, 162   }},
   {"circumflex",    {0xf2c6, 0x0088, 0x00c3, 246   }},
   {"colon",         {0xf03a, 0x003a, 0x003a, 0x003a}},
   {"comma",         {0xf02c, 0x002c, 0x002c, 0x002c}},
   {"currency",      {0xf0a4, 0x00a4, 0x00a8, 219   }},
   {"d",             {0xf064, 0x0064, 0x0064, 0x0064}},
   {"dagger",        {0x2020, 0x0086, 0x00b2, 160   }},
   {"daggerdbl",     {0x2021, 0x0087, 0x00b3, 224   }},
   {"dieresis",      {0xf0a8, 0x00a8, 0x00c8, 172   }},
   {"dollar",        {0xf024, 0x0024, 0x0024, 0x0024}},
   {"dotaccent",     {0xf2d9, 0xffff, 0x00c7, 250   }},
   {"dotlessi",      {0xf131, 0xffff, 0x00f5, 245   }},
   {"e",             {0xf065, 0x0065, 0x0065, 0x0065}},
   {"eight",         {0xf038, 0x0038, 0x0038, 0x0038}},
   {"ellipsis",      {0x2026, 0x0085, 0x00bc, 201   }},
   {"emdash",        {0x2014, 0x0097, 0x00d0, 209   }},
   {"endash",        {0x2013, 0x0096, 0x00b1, 208   }},
   {"equal",         {0xf03d, 0x003d, 0x003d, 0x003d}},
   {"exclam",        {0xf021, 0x0021, 0x0021, 0x0021}},
   {"exclamdown",    {0xf0a1, 0x00a1, 0x00a1, 193   }},
   {"f",             {0xf066, 0x0066, 0x0066, 0x0066}},
   {"fi",            {0xf001, 0xffff, 0x00ae, 222   }},
   {"five",          {0xf035, 0x0035, 0x0035, 0x0035}},
   {"fl",            {0xf002, 0xffff, 0x00af, 223   }},
   {"florin",        {0xf192, 0x0083, 0x00a6, 196   }},
   {"four",          {0xf034, 0x0034, 0x0034, 0x0034}},
   {"fraction",      {0x2215, 0xffff, 0x00a4, 218   }},
   {"g",             {0xf067, 0x0067, 0x0067, 0x0067}},
   {"germandbls",    {0xf0df, 0x00df, 0x00fb, 167   }},
   {"grave",         {0xf060, 0x0060, 0x00c1, 0x0060}},
   {"greater",       {0xf03e, 0x003e, 0x003e, 0x003e}},
   {"guillemotleft", {0xf0ab, 0x00ab, 0x00ab, 199   }},
   {"guillemotright",{0xf0bb, 0x00bb, 0x00bb, 200   }},
   {"guilsinglleft", {0x2039, 0x008b, 0x00ac, 220   }},
   {"guilsinglright",{0x203a, 0x009b, 0x00ad, 221   }},
   {"h",             {0xf068, 0x0068, 0x0068, 0x0068}},
   {"hungarumlaut",  {0xf2dd, 0xffff, 0x00cd, 0xffff}},
   {"hyphen",        {0xf02d, 0x002d, 0x002d, 0x002d}},
   {"i",             {0xf069, 0x0069, 0x0069, 0x0069}},
   {"j",             {0xf06a, 0x006a, 0x006a, 0x006a}},
   {"k",             {0xf06b, 0x006b, 0x006b, 0x006b}},
   {"l",             {0xf06c, 0x006c, 0x006c, 0x006c}},
   {"less",          {0xf03c, 0x003c, 0x003c, 0x003c}},
   {"lslash",        {0xf142, 0xffff, 0x00f8, 0xffff}},
   {"m",             {0xf06d, 0x006d, 0x006d, 0x006d}},
   {"macron",        {0xf0af, 0xffff, 0x00c5, 248   }},
   {"n",             {0xf06e, 0x006e, 0x006e, 0x006e}},
   {"nine",          {0xf039, 0x0039, 0x0039, 0x0039}},
   {"numbersign",    {0xf023, 0x0023, 0x0023, 0x0023}},
   {"o",             {0xf06f, 0x006f, 0x006f, 0x006f}},
   {"oe",            {0xf153, 0x009c, 0x00fa, 207   }},
   {"ogonek",        {0xf2db, 0xffff, 0x00ce, 254   }},
   {"one",           {0xf031, 0x0031, 0x0031, 0x0031}},
   {"ordfeminine",   {0xf0aa, 0x00aa, 0x00e3, 187   }},
   {"ordmasculine",  {0xf0ba, 0x00ba, 0x00eb, 188   }},
   {"oslash",        {0xf0f8, 0x00f8, 0x00f9, 191   }},
   {"p",             {0xf070, 0x0070, 0x0070, 0x0070}},
   {"paragraph",     {0xf0b6, 0x00b6, 0x00b6, 166   }},
   {"parenleft",     {0xf028, 0x0028, 0x0028, 0x0028}},
   {"parenright",    {0xf029, 0x0029, 0x0029, 0x0029}},
   {"percent",       {0xf025, 0x0025, 0x0025, 0x0025}},
   {"period",        {0xf02e, 0x002e, 0x002e, 0x002e}},
   {"periodcentered",{0x2219, 0xffff, 0x00b4, 225   }},
   {"perthousand",   {0x2030, 0x0089, 0x00bd, 228   }},
   {"plus",          {0xf02b, 0x002b, 0x002b, 0x002b}},
   {"q",             {0xf071, 0x0071, 0x0071, 0x0071}},
   {"question",      {0xf03f, 0x003f, 0x003f, 0x003f}},
   {"questiondown",  {0xf0bf, 0x00bf, 0x00bf, 192   }},
   {"quotedbl",      {0xf022, 0x0022, 0x0022, 0x0022}},
   {"quotedblbase",  {0x201e, 0x0084, 0x00b9, 227   }},
   {"quotedblleft",  {0x201c, 0x0093, 0x00aa, 210   }},
   {"quotedblright", {0x201d, 0x0094, 0x00ba, 211   }},
   {"quoteleft",     {0x2018, 0x0091, 0x0060, 212   }},
   {"quoteright",    {0x2019, 0x0092, 0x0027, 213   }},
   {"quotesinglbase",{0x201a, 0x0082, 0x00b8, 226   }},
   {"quotesingle",   {0xf027, 0x0027, 0x00a9, 0x0027}},
   {"r",             {0xf072, 0x0072, 0x0072, 0x0072}},
   {"ring",          {0xf2da, 0xffff, 0x00ca, 251   }},
   {"s",             {0xf073, 0x0073, 0x0073, 0x0073}},
   {"section",       {0xf0a7, 0x00a7, 0x00a7, 164   }},
   {"semicolon",     {0xf03b, 0x003b, 0x003b, 0x003b}},
   {"seven",         {0xf037, 0x0037, 0x0037, 0x0037}},
   {"six",           {0xf036, 0x0036, 0x0036, 0x0036}},
   {"slash",         {0xf02f, 0x002f, 0x002f, 0x002f}},
   {"space",         {0xf020, 0x0020, 0x0020, 0x0020}},
   {"sterling",      {0xf0a3, 0x00a3, 0x00a3, 163   }},
   {"t",             {0xf074, 0x0074, 0x0074, 0x0074}},
   {"three",         {0xf033, 0x0033, 0x0033, 0x0033}},
   {"tilde",         {0xf2dc, 0x0098, 0x00c4, 245   }},
   {"two",           {0xf032, 0x0032, 0x0032, 0x0032}},
   {"u",             {0xf075, 0x0075, 0x0075, 0x0075}},
   {"underscore",    {0xf05f, 0x005f, 0x005f, 0x005f}},
   {"v",             {0xf076, 0x0076, 0x0076, 0x0076}},
   {"w",             {0xf077, 0x0077, 0x0077, 0x0077}},
   {"x",             {0xf078, 0x0078, 0x0078, 0x0078}},
   {"y",             {0xf079, 0x0079, 0x0079, 0x0079}},
   {"yen",           {0xf0a5, 0x00a5, 0x00a5, 180   }},
   {"z",             {0xf07a, 0x007a, 0x007a, 0x007a}},
   {"zero",          {0xf030, 0x0030, 0x0030, 0x0030}},
};


/***** MACROS */
/*-none-*/


/***** STATIC FUNCTIONS */
/*-none-*/


/***** FUNCTIONS */

/***
** Function: AllocEncodingTable
**
** Description:
**   Create a new encoding ADT.
***/
struct encoding *AllocEncodingTable(const USHORT num)
{
   struct encoding *enc;
   if ((enc = Malloc(sizeof(struct encoding)*num))!=NULL)
      memset(enc, NOTDEFINIT, sizeof(struct encoding)*num);
   return enc;
}


/***
** Function: RehashEncodingTable
**
** Description:
**   Prepare an encoding ADT so that entries can be
**   located in it.
***/
void RehashEncodingTable(struct encoding *Encoding, const USHORT num)
{
   USHORT i;
   short j;
   struct encoding entry;

   for (i=1; i<num; i++) {
      j=(short)(i-1);
      entry = Encoding[i];
      while(j>=0 && strcmp(Encoding[j].name, entry.name)>0) {
         memcpy(&Encoding[j+1], &Encoding[j], sizeof(struct encoding));
         j--;
      }
      Encoding[j+1] = entry;
   }
}


/***
** Function: SetEncodingEntry
**
** Description:
**   Set the mapping from a glyph name to character
**   codes for various platforms.
***/
void SetEncodingEntry(struct encoding *Encoding,
                      const USHORT entry,
                      const char *name,
                      const USHORT num,
                      const USHORT *codes)
{
   USHORT i;

   Encoding[entry].name = name;
   for (i=0; i<num; i++) {
      Encoding[entry].codes[i] = codes[i];
   }
}


static int CDECL compare(const void *arg1, const void *arg2)
{
   return strcmp( *((const char **)arg1),
                  ((const struct encoding *)arg2)->name );
}


/***
** Function: LookupPSName
**
** Description:
**   Do a binary search for a postscript name, and return
**   a handle that can be used to look up a the character
**   code for a specific encoding schema.
**
**   If a custom encoding array is used and a glyph is not
**	 encoded by that array, though it is recognized by the
**   StandardEncoding array, then use the SeacEncoding.
**   This is needed in order to support bogus "seac" calls.
***/
struct encoding *LookupPSName(const struct encoding *Encoding,
                              USHORT size,
                              const char *name)
{
#ifndef BSEARCH
   struct encoding *result;
#else
   USHORT low, mid, high;
   short diff;

   /* Initiate. */
   low = 0;
   high = size;
#endif

   /* Use default encoding? */
   if (Encoding==NULL) {
      Encoding = StdEncoding;
      size = sizeof(StdEncoding)/sizeof(StdEncoding[0]);
   }

#ifndef BSEARCH
   result = (struct encoding *)bsearch((char *)&name,
                                       (char *)Encoding, size,
                                       sizeof(struct encoding),
                                       compare);
#else
   do {

	   mid = (low+high)>>1;
	   diff = (short)strcmp(Encoding[mid].name, name);

	   if (diff>0) {
		   high = (low+high)>>1;
	   } else if (diff<0) {
		   low = (short)((low+high+1)>>1);
	   } else if (diff==0) {
		   result =  &Encoding[mid];
	   }

   } while (low<high && result==NULL);
#endif


   if ((result==NULL) &&
	   (Encoding!=SeacEncoding) &&
	   (Encoding!=StdEncoding))
	   result = LookupPSName(SeacEncoding,
							 sizeof(SeacEncoding)/sizeof(SeacEncoding[0]),
							 name);

   return result;
}


/***
** Function: LookupCharCode
**
** Description:
**   look up a the character code for a
**   specific encoding scheme.
***/
USHORT LookupCharCode(const struct encoding *enc, const USHORT type)
{
   USHORT code = 0;

   if (enc)
      code = enc->codes[type];
   return code;
}


/***
** Function: LookupCharName
**
** Description:
**   look up a the character name for a
**   specific encoding scheme.
***/
const char *LookupCharName(const struct encoding *enc)
{
   return enc->name;
}


/***
** Function: LookupNotDef
**
** Description:
**   look up a the .notdef character
***/
const struct encoding *LookupNotDef(void)
{
   return &StdEncoding[0];
}



/***
** Function: DecodeChar
**
** Description:
**   look up an encoding record for a character code in some
**   known encoding.
***/
const struct encoding *DecodeChar(const struct encoding *Encoding,
                                  const USHORT max,
                                  const USHORT type,
                                  const USHORT code)
{
   const struct encoding *enc = &StdEncoding[0];
   USHORT i, high;

   /* Use default encoding? */
   if (Encoding==NULL) {
      Encoding = StdEncoding;
      high = sizeof(StdEncoding)/sizeof(StdEncoding[0]);
   } else {
      high = max;
   }

   for (i=0; i<high; i++) {
      if (Encoding[i].codes[type]==code) {
         enc = &Encoding[i];
         break;
      }
   }

   return enc;
}


/***
** Function: FreeEncoding
**
** Description:
**   Deallocate memory associated to the encoding array.
***/
void FreeEncoding(struct encoding *enc, const USHORT size)
{
   USHORT i;

   if (enc) {
      for (i=0; i<size; i++) {
         if (enc[i].name)
            Free((char *)enc[i].name);
      }
      Free(enc);
   }
}

/***
** Function: LookupFirstEnc
**
** Description:
**   Locate the first encoding for a given glyph.
***/
const struct encoding *LookupFirstEnc(
    const struct encoding *encRoot,
    const int              encSize,
    const struct encoding *encItem
)
{
	/* Back up to the first item with the same glyph name. */
	while (encItem>encRoot && !strcmp(encItem[-1].name, encItem[0].name))
		encItem--;

	return encItem;
}

/***
** Function: LookupNextEnc
**
** Description:
**   Locate the first encoding for a given glyph.
***/
const struct encoding *LookupNextEnc(
    const struct encoding *encRoot,
    const int              encSize,
    const struct encoding *encItem
)
{
	/* Back up to the first item with the same glyph name. */
	if (encItem<(&encRoot[encSize-1]) &&
		 !strcmp(encItem[0].name, encItem[1].name))
		return ++encItem;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\hints.h ===
/***
**
**   Module: Hints
**
**   Description:
**      This is a module of the T1 to TT font converter. This is a
**      sub-module of the T1 to TT data translator module. It deals
**      with hints. Any part pf the T1 font that gets translated into
** TrueType instructions is done within this module.
**
**   Author: Michael Jansson
**
**   Created: 8/24/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif



/***
** Function: ConvertHints
**
** Description:
**   This functions converts hstem, hstem3, vstem, vstem3 and flex
**   hints, as well as doing diagonal control.
***/
errcode        ConvertHints      _ARGS((INOUT   struct T1Metrics *t1m,
                                        IN      Hints *hints,
                                        IN      Outline *orgpaths,
                                        IN      Outline *paths,
                                        IN      short *sideboard,
                                        OUT     UBYTE **gpgm,
                                        OUT     USHORT *num,
                                        OUT     USHORT *stack,
                                        OUT     USHORT *twilight));

/***
** Function: BuildPreProgram
**
** Description:
**   This function builds the pre-program that will compute
**   the CVT and storage entries for the TT stem hint
**   instructions to work. 
***/
USHORT         BuildPreProgram   _ARGS((IN      struct T1Metrics *t1m,
                                        IN      WeightControl *weight,
                                        INOUT   Blues *blues,
                                        INOUT   AlignmentControl *align,
                                        INOUT   UBYTE **prep,
                                        IN      int prepsize,
                                        OUT     USHORT *maxprepstack));
/***
** Function: MatchingFamily
**
** Description:
**   Locate the family alignment zone that is closest to
**   a given alignment zone.
***/
short          MatchingFamily    _ARGS((IN      funit pos,
                                        IN      funit *family,
                                        IN      USHORT fcnt));
/***
** Function: GetRomanHints
**
** Description:
***/
const UBYTE    *GetRomanHints    _ARGS((OUT     int *size));


/***
** Function: GetSwissHints
**
** Description:
***/
const UBYTE    *GetSwissHints    _ARGS((OUT     int *size));


/***
** Function: GetFontProg
**
** Description:
**   Return the font program.
***/
const UBYTE    *GetFontProg      _ARGS((void));


/***
** Function: GetFontProgSize
**
** Description:
**   Return the size of the font program.
***/
const USHORT   GetFontProgSize   _ARGS((void));


/***
** Function: GetNumFuns
**
** Description:
**   Return the number of functions defined in
**   the font program.
***/
const USHORT   GetNumFuns        _ARGS((void));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\errors.c ===
/***
 **
 **   Module: T1Instal
 **
 **   Description:
 **      This is a Win32 DLL specific module, that implements
 **      the error logging mechanism under Win32.
 **
 **   Author: Michael Jansson
 **   Created: 12/18/93
 **
 ***/


/***** INCLUDES */
#include <windows.h>
#include "types.h"
#include "t1local.h"
#ifdef NOMSGBOX
#include <stdio.h>
#endif



/***** CONSTANTS */
/*-none-*/



/***** GLOBALS */



/***** PROTOTYPES */
extern int __cdecl sprintf(char *, const char *, ...);


/***
 ** Function: LogError
 **
 ** Description:
 **   Add another message to the error log.
 ***/
void LogError(const long type, const long id, const char *arg)
{
   char caption[256];
   char msg[256];
   WORD etype;
   HANDLE h;
   DWORD logit;
   DWORD size;
   HKEY key;
   HMODULE hInst = ModuleInstance();

   /* Map the internal envent type to EventLog type. */
   if (type==MSG_INFO)
      etype = EVENTLOG_INFORMATION_TYPE;
   else if (type==MSG_WARNING)
      etype = EVENTLOG_WARNING_TYPE;
   else
      etype = EVENTLOG_ERROR_TYPE;

   /* Access the REG data base. */
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SUBKEY_TYPE1INSTAL, 0,
                    KEY_QUERY_VALUE, &key)==ERROR_SUCCESS) { 

      size = sizeof(logit);
      if (RegQueryValueEx(key, (LPTSTR)SUBKEY_LOGFILE, NULL, 
                          NULL, (LPVOID)&logit, &size)==ERROR_SUCCESS &&
          logit!=0) {

         h = RegisterEventSource(NULL, STR_APPNAME);
         if (h!=NULL) {
            ReportEvent(h, etype, 0, id, NULL, 1, 0, (LPSTR *)&arg, NULL);
            DeregisterEventSource(h);
         }

         if (etype==EVENTLOG_WARNING_TYPE) {
            LoadString(hInst, (UINT)id, caption, sizeof(caption));
            sprintf(msg, caption, arg);
            LoadString(hInst, IDS_CAPTION, caption, sizeof(caption));
#if NOMSGBOX
            fputs("WARNING- ", stderr);
            fputs(msg, stderr);
            fputs("\n", stderr);
#else         
            MessageBox(NULL, msg, caption, INFO);
#endif
            SetLastError(0);  /* MessageBox(NULL,...) is broken */
         }
      }

      if (etype==EVENTLOG_ERROR_TYPE) {
         LoadString(hInst, (UINT)id, caption, sizeof(caption));
         sprintf(msg, caption, arg);
         LoadString(hInst, IDS_CAPTION, caption, sizeof(caption));
#if NOMSGBOX
         fputs("ERROR  - ", stderr);
         fputs(msg, stderr);
         fputs("\n", stderr);
#else         
         MessageBox(NULL, msg, caption, INFO);
#endif
         SetLastError(0); /* MessageBox(NULL,...) is broken */
      }
      RegCloseKey(key);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\metrics.h ===
#ifndef METRICS_H
#define METRICS_H



#define ONOFFSIZE(n)	((((n+7)/8)+sizeof(long)-1)/sizeof(long)*sizeof(long))
#define OnCurve(arr, n)  !((arr[(USHORT)(n)>>5]) & (ULONG)(1UL<<((USHORT)(n) % 32UL)))
#define SetOffPoint(arr, n)  arr[(unsigned)(n)/sizeof(arr[0])/8] |= \
                              1UL<<((unsigned)(n) % (sizeof(arr[0])*8))
#define SetOnPoint(arr, n)   arr[(unsigned)(n)/sizeof(arr[0])/8] &= \
                              ~(1UL<<((unsigned)(n) % (sizeof(arr[0])*8UL)))

#define USEMETRICS      0
#define DEFAULTMETRICS  1
#define F8D8            256
#define MAXSNAP         (USHORT)12
#define MAXBLUE         (USHORT)20
#define UNDEF_CVT			0
#define ENDOFPATH			-1
#define NORANGE			-2
#define ARGSIZE                 2000
#define PGMSIZE			3000
#define DEFAULTMATRIX	NULL
#define F16D16BASE		(1L<<19L)
#define F16D16HALF		(1L<<18L)
#define F16D16PPM			524




typedef int funit;
typedef struct {
	funit x;
	funit y;
} Point;

typedef struct Outline {
	struct Outline *next;	 /* Next path of the glyph. */
	USHORT count;		 /* Number of 'pts', 'onoff' and 'map'. */
	Point *pts;		 /* X/Y coordinates. */
	ULONG *onoff;		 /* On/Off curve point bit flags. */
} Outline;

typedef struct StemS {
        struct StemS *next;
        funit offset;
        funit width;
        short i1;
        short i2;
} Stem;

typedef struct Stem3S {
        struct Stem3S *next;
        Stem stem1;
        Stem stem2;
        Stem stem3;
} Stem3;

typedef struct FlexS {
   struct FlexS *next;
   funit civ;
   Point pos;
   Point midpos;
   Point startpos;
   USHORT start;
   USHORT mid;
   USHORT end;
} Flex;

typedef struct {
        Stem *vstems;
        Stem *hstems;
        Stem3 *vstems3;
        Stem3 *hstems3;
   Flex *flex;
} Hints;
        
        
typedef struct Composite {
   struct Composite *next;
   funit asbx;
   funit aw;
   funit adx;
   funit ady;
   const char *achar;
   const char *bchar;
   char *cchar;
   struct encoding *oenc;
} Composite;
   

typedef struct T1Glyph {
   char *name;

   Point lsb;
   Point width;

   Outline *paths;

   Hints hints;

} T1Glyph;
   

typedef struct StemWidth {
   funit width;
   USHORT storage;
} StemWidth;


typedef struct WeightControl {
   StemWidth *vwidths;
   USHORT cnt_vw;
   USHORT max_vw;
   StemWidth *hwidths;
   USHORT cnt_hw;
   USHORT max_hw;
   USHORT storage;
} WeightControl;

struct CVTPos {
   funit y;
   USHORT cvt;
};

typedef struct StemPos {
   struct CVTPos *pos;
   USHORT cnt;
   USHORT blue_cvt;
} StemPos;

typedef struct AlignmentControl {
   StemPos top[MAXBLUE/2];
   StemPos bottom[MAXBLUE/2];
   USHORT cvt;
} AlignmentControl;   

typedef struct Blues {
   funit bluevalues[MAXBLUE];
   USHORT blue_cnt;
   funit otherblues[MAXBLUE];
   USHORT oblue_cnt;
   funit familyblues[MAXBLUE];
   USHORT family_cvt[MAXBLUE/2];
   USHORT fblue_cnt;
   funit familyotherblues[MAXBLUE];
   USHORT familyother_cvt[MAXBLUE/2];
   USHORT foblue_cnt;
   short blueShift;      /*  /BlueShift * F8D8 */
   UBYTE blueFuzz;
   UBYTE blueScale;      /* /BlueScale * 1000 */
   AlignmentControl align;
} Blues;

struct kerning {
	UBYTE left;
	UBYTE right;
	funit delta;
};


struct T1Metrics {
   char *date;
   char *copyright;
   char *name;
   char *id;
   char *notice;
   char *fullname;
   char *weight;
   char *family;
   struct {
      USHORT ver;
      USHORT rev;
   } version;
   f16d16 angle;
   funit avgCharWidth;
   funit underline;
   funit uthick;
   funit stdhw;
   funit stdvw;
   funit defstdhw;
   funit defstdvw;
   funit stemsnaph[MAXSNAP];
   USHORT snaph_cnt;
   funit stemsnapv[MAXSNAP];
   USHORT snapv_cnt;
   UBYTE forcebold;
   UBYTE pitchfam;
   USHORT fixedPitch;
   USHORT flags;
   USHORT tmweight;
   funit ascent;
   funit descent;
   funit intLeading;
   funit extLeading;
   funit superoff;
   funit supersize;
   funit suboff;
   funit subsize;
   funit strikeoff;
   funit strikesize;
   UBYTE firstChar;
   UBYTE lastChar;
   UBYTE DefaultChar;
   UBYTE BreakChar;
   UBYTE CharSet;
   funit *widths;       /* Advance widths. */
   struct kerning *kerns;
   USHORT kernsize;
   WeightControl stems;
   Blues blues;
   funit upem;
   f16d16 *fmatrix;
   UBYTE pgm[PGMSIZE];
   short args[ARGSIZE];
   struct encoding *encoding;
   USHORT encSize;


   Composite *seac;
   Composite *used_seac;
};   



/****** MACROS */
#define GetUPEM(t1m)             (t1m->upem)
#define GetFontMatrix(t1m)       (t1m->fmatrix)
#define GetStdVW(t1m)            (t1m->stdvw)
#define GetStdHW(t1m)            (t1m->stdhw)
#define GetDefStdVW(t1m)         (t1m->defstdvw)
#define GetDefStdHW(t1m)         (t1m->defstdhw)
#define SetDefStdVW(t1m, width)  t1m->defstdvw = width
#define SetDefStdHW(t1m, width)  t1m->defstdhw = width
#define GetCodeStack(t1m)        t1m->pgm
#define GetArgStack(t1m)         t1m->args
#define GetWeight(t1m)           &(t1m->stems)
#define ForceBold(t1m)           t1m->forcebold
#define GetAlignment(t1m)        &(t1m->blues.align)
#define GetBlues(t1m)            &(t1m->blues)
#define CurrentEncoding(t1m)     t1m->encoding
#define EncodingSize(t1m)        t1m->encSize
#define Composites(t1m)          t1m->seac
#define SyntheticOblique(t1m)    (t1m->fmatrix && t1m->fmatrix[2])
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\builder.c ===
/***
 **
 **   Module: Builder
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contains functions that will write the tables found in a
 **    TrueType font file.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/



/**** INCLUDES */
/* General types and definitions. */
#include <string.h>     /* Prototype for memset */
#include <limits.h>

/* Special types and definitions. */
#include "types.h"
#include "metrics.h"
#include "safemem.h"
#include "encoding.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "titott.h"
#include "builder.h"
#include "fwriter.h"

#if DBG
#define STATIC
#else
#define STATIC static
#endif


/***** LOCAL TYPES */
struct GlyphKerning {
	USHORT left;
	USHORT right;
	funit delta;
};

struct GlyphList {
   long offset;            /* File offset of the sub-table for this glyph. */
   const struct encoding *code;  /* Encoding key (see the "Encoding" module. */
   funit aw;               /* Advance width. */
   funit lsb;              /* Left side bearing. */
   USHORT pts;             /* Total number of points in the glyph. */
   Point bbox[2];          /* Bounding box of the glyph. */
   USHORT conts;           /* Number of contours. */
};


/* MS cmap encoding sub-table. */
struct MSEncoding {
   USHORT segCount;
   USHORT *startCount;
   USHORT *endCount;
   USHORT *idOffsets;
   USHORT *gi;
   USHORT giCount;
   USHORT giMax;
};


struct TTHandle {
   OutputFile *file;
   Point bbox[2];
   struct GlyphList *pool;

   /* Accumulative 'maxp' entries. */
   USHORT count;
   USHORT maxcnt;
   USHORT maxpts;
   USHORT maxcontours;
   USHORT maxcomppts;
   USHORT maxcompcont;
   USHORT maxcompelements;
   USHORT maxstack;
   USHORT maxinstructions;
   USHORT maxtwilight;
};



/***** CONSTANTS */
#define SHORT_LOCA_MAX  65535
#define KERN_HORIZONTAL 0x0001
#define KERN_PAIR   0x0000
#define KERN_FORMAT0   0x0000

#define GASP_GRIDFIT    0x0001
#define GASP_DOGRAY     0x0002

#define PLT_MAC         (USHORT)1
#define PLT_MS          (USHORT)3

#define ENC_ROMAN       (USHORT)0

// for platform id = 3 cmap table, symbol font or ugl

#define ENC_SYMBOL      (USHORT)0
#define ENC_UGL         (USHORT)1

#define LAN_MS_US       (USHORT)0x0409
#define LAN_MAC_US      (USHORT)0

#define COPYRIGHT       (USHORT)0
#define FAMILY          (USHORT)1
#define SUBFAMILY       (USHORT)2
#define ID              (USHORT)3
#define FULLNAME        (USHORT)4
#define VERSION         (USHORT)5
#define PSNAME          (USHORT)6
#define NOTICE          (USHORT)7


/* Glyph constants. */
#define FLG_ONCURVE     0x01
#define FLG_SHORTX      0x02
#define FLG_SHORTY      0x04
#define FLG_REPEAT      0x08
#define FLG_SAMEX       0x10
#define FLG_SAMEY       0x20

#define ARGS_1_2_ARE_WORDS  0x0001
#define ARGS_ARE_XY_VALUES  0x0002
#define ROUND_XY_TO_GRID    0x0004
#define MORE_COMPONENTS     0x0020

#define GLYPHBUF     64          /* GlyphList's that are allocated each time */
#define MACSIZE      (USHORT)256 /* Length of the Mac encoding vector. */

/* Table constants. */
#define FIRSTCHAR    (USHORT)0x0020 /* First defined char. */
#define LASTCHAR     (USHORT)0xf002 /* Last defined char. */
#define MAXZONES     (USHORT)2      /* Number of zones in the font. */
#define MAXIDEFS     (USHORT)0      /* Number of idefs in the fpgm. */
#define MAXDEPTH     (USHORT)1      /* Number of recursions in composits. */
#define FM_READONLY  (USHORT)2      /* fsType Read Only. */
#define NO_CLASS     (USHORT)0      /* 0 = No class id for the font. */
#define OS2VERSION   (USHORT)0      /* Version of the OS/2 table. */
#define CARET_RISE   (USHORT)1      /* Vertical caret slope rise. */
#define CARET_RUN    (USHORT)0      /* Vertical caret slope run. */
#define RESERVED0    (USHORT)0
#define MAGICCOOKIE  0x5F0F3CF5L    /* Magic cookie. */
#define BASELINEY    (USHORT)0x0001 /* Baseline at y==0 */
#define LOWPPEM      (USHORT)8      /* Lowest PPEM size. */
#define ROMAN        (USHORT)2      /* Direction = left,right&neutrals.*/
#define GLYPH_FORMAT (USHORT)0      /* Current glyphs format. */
#define VERSION0     (USHORT)0      /* Version zero of a table. */
#define NUM_CMAPS    (USHORT)2      /* Number of cmap sub-tables. */
#define SEGMENT_MAP  (USHORT)4      /* MS segment mapping of cmap table. */
#define PAD0         (USHORT)0      /* Padding byte. */
#define MAX_PPEM_SIZE     (USHORT)65535  /* Maximum PPEM size in GASP table. */

/* LOCA constants */
#define SHORTOFFSETS 0
#define LONGOFFSETS  1


/* Weighted average character width. */
STATIC const long Weights[] = {
   64,
   14,
   27,
   35,
   100,
   20,
   14,
   42,
   63,
   3,
   6,
   35,
   20,
   56,
   56,
   17,
   4,
   49,
   56,
   71,
   31,
   10,
   18,
   3,
   18,
   2
};

/***** MACROS */
#define LONGVERSION(v,r)      ((((long)v)<<16L) | (long)r)


/***** STATIC FUNCTIONS */

/***
** Function: SearchRange
**
** Description:
**   Compute the search range key for the CMAP subtable
**   for Windows.
***/
STATIC USHORT SearchRange(const USHORT cnt)
{
   USHORT i;

   i = 0;
   while ((1u<<i) <= cnt) {
      i++;
   }

   return (USHORT)(1<<i);
}



/***
** Function: EntrySelector
**
** Description:
**   Compute the entry selector key for the CMAP subtable
**   for Windows.
***/
STATIC USHORT EntrySelector(const USHORT cnt)
{
   USHORT i;

   i = 0;
   while ((1u<<(i+1)) <= cnt) {
      i++;
   }

   return i;
}



/***
** Function: RangeShift
**
** Description:
**   Compute the range shift key for the CMAP subtable
**   for Windows.
***/
STATIC USHORT RangeShift(const USHORT cnt)
{
   return (USHORT)(2*cnt - SearchRange(cnt));
}



/***
 ** Function: PutGASP
 **
 ** Description:
 **   This function writes the optional 'GASP' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutGASP(OutputFile *file,
		      const USHORT treshold)
{
   long offset;

   offset = FileTell(file);

   WriteShort(VERSION0, file);
   WriteShort(3, file);

   /* First range 0 - 8 : GRIDFIT */
   WriteShort(8, file);
   WriteShort(GASP_DOGRAY, file);

   /* Second range 8 - onpix : GRIDFIT */
   WriteShort(treshold, file);
   WriteShort(GASP_GRIDFIT, file);

   /* Third range onpix - inf. : GRIDFIT | GRAYSCALE */
   WriteShort(MAX_PPEM_SIZE, file);
   WriteShort(GASP_GRIDFIT | GASP_DOGRAY, file);

   return CompleteTable(offset, TBL_GASP, file);
}


/***
** Function: cmpKern
**
** Description:
**
***/
STATIC int CDECL cmpKern(const void *a1, const void *a2)
{
   const struct GlyphKerning *k1 = a1;
   const struct GlyphKerning *k2 = a2;
   ULONG first;
   ULONG second;

   first = ((k1->left)<<16L) + k1->right;
   second = ((k2->left)<<16L) + k2->right;

   return (int)(first - second);
}


/***
 ** Function: StdEncToGlyphIndex
 **
 ** Description:
 **   This function maps an StdEncoding character code to a
 **   glyph index.
 **
 ***/
USHORT StdEncToGlyphIndex(const struct GlyphList *pool,
						  const USHORT count,
						  const USHORT code)
{
	USHORT i;

	for (i=0; i<count; i++) {
            if (LookupCharCode(pool[i].code, ENC_MSWINDOWS) == code)
                 return i;
	}

	return 0;
}


/***
 ** Function: PutKERN
 **
 ** Description:
 **   This function writes the optional 'KERN' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutKERN(OutputFile *file,
					   struct kerning *charkerns,
					   const USHORT kernsize,
					   const struct GlyphList *pool,
					   const USHORT count)
{
   struct GlyphKerning *kerns;
   long offset;
   unsigned i;
   USHORT cnt;

   if ((kerns = malloc(sizeof(struct GlyphKerning)*kernsize))==NULL)
	   return FAILURE;

   /* Translate the kerning from char codes to glyph index. */
   for (i=0, cnt=0; i<kernsize; i++) {
           if ((kerns[cnt].left  = StdEncToGlyphIndex(pool, count, charkerns[i].left))!=0 &&
               (kerns[cnt].right = StdEncToGlyphIndex(pool, count, charkerns[i].right))!=0)
           {
		   kerns[cnt].delta = charkerns[i].delta;
		   cnt++;
	   }
   }
   /* Sort the kerning pairs. */
   qsort((void *)kerns, cnt, sizeof(struct GlyphKerning), cmpKern);


   offset = FileTell(file);

   WriteShort(VERSION0, file);
   WriteShort(1, file);

   /* First sub-table header. */
   WriteShort(VERSION0, file);
   WriteShort((USHORT)(2+2+2+ 2+2+2+2+ cnt*(2+2+2)), file);
   WriteShort(KERN_HORIZONTAL | KERN_PAIR | KERN_FORMAT0, file);

   /* First sub-table, format 0 */
   WriteShort(cnt, file);
   WriteShort(SearchRange(cnt), file);
   WriteShort(EntrySelector(cnt), file);
   WriteShort(RangeShift(cnt), file);
   for (i=0; i<cnt; i++) {
      WriteShort((USHORT)kerns[i].left, file);
      WriteShort((USHORT)kerns[i].right, file);
      WriteShort((USHORT)kerns[i].delta, file);
   }

   free(kerns);

   return CompleteTable(offset, TBL_KERN, file);
}


/***
 ** Function: PutCVT
 **
 ** Description:
 **   This function writes the optional 'cvt' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutCVT(OutputFile *file,
		      const short *ppgm,
		      const USHORT num)
{
   USHORT i;
   long offset;

   offset = FileTell(file);

   for (i=0; i<num; i++)
      WriteShort((USHORT)ppgm[i], file);

   return CompleteTable(offset, TBL_CVT, file);
}



/***
 ** Function: PutPREP
 **
 ** Description:
 **   This function writes the optional 'prep' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutPREP(OutputFile *file,
		       const UBYTE *prep,
		       const USHORT num)
{
   long offset;

   offset = FileTell(file);

   (void)WriteBytes(prep, num, file);

   return CompleteTable(offset, TBL_PREP, file);
}



/***
 ** Function: PutFPGM
 **
 ** Description:
 **   This function writes the optional 'fpgm' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutFPGM(OutputFile *file,
		       const UBYTE *fpgm,
		       const USHORT num)
{
   long offset;

   offset = FileTell(file);

   (void)WriteBytes(fpgm, num, file);

   return CompleteTable(offset, TBL_FPGM, file);
}



/***
 ** Function: PutPOST
 **
 ** Description:
 **   This function writes the required 'post' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutPOST(OutputFile *file,
		       struct GlyphList *pool,
		       USHORT count,
		       struct TTMetrics *ttm)
{
   const char *str;
   long offset;
   USHORT i;

   offset = FileTell(file);
   WriteLong(LONGVERSION(2, 0), file);
   WriteLong((ULONG)ttm->angle, file);
   WriteShort((USHORT)ttm->underline, file);
   WriteShort((USHORT)ttm->uthick, file);
   WriteLong((ULONG)ttm->isFixPitched, file);
   WriteLong(0L, file);
   WriteLong(0L, file);
   WriteLong(0L, file);
   WriteLong(0L, file);

   /* Write the character codes. */
   WriteShort(count, file);
   for (i=0; i<count; i++) {
      if (pool[i].code)
	 WriteShort(LookupCharCode(pool[i].code, ENC_MACCODES), file);
      else
	 WriteShort((USHORT)0, file);
   }

   /* Write the character names. */
   for (i=0; i<count; i++) {
      if (pool[i].code) {
	 str = LookupCharName(pool[i].code);
	 WriteByte((UBYTE)strlen(str), file);
	 (void)WriteBytes((UBYTE*)str, (USHORT)strlen(str), file);
      }
   }

   return CompleteTable(offset, TBL_POST, file);
}



/***
 ** Function: PutMAXP
 **
 ** Description:
 **   This function writes the required 'maxp' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutMAXP(struct TTHandle *tt,
		       const USHORT maxstorage,
		       const USHORT maxprepstack,
		       const USHORT maxfuns)
{
   long offset;

   offset = FileTell(tt->file);
   WriteLong(LONGVERSION(1, 0), tt->file);
   WriteShort(tt->count, tt->file);
   WriteShort(tt->maxpts, tt->file);
   WriteShort(tt->maxcontours, tt->file);
   WriteShort(tt->maxcomppts, tt->file);
   WriteShort(tt->maxcompcont, tt->file);
   WriteShort(MAXZONES, tt->file);
   WriteShort(tt->maxtwilight, tt->file);
   WriteShort(maxstorage, tt->file);
   WriteShort(maxfuns, tt->file);
   WriteShort(MAXIDEFS, tt->file);
   WriteShort((USHORT)MAX(tt->maxstack, maxprepstack), tt->file);
   WriteShort(tt->maxinstructions, tt->file);
   WriteShort(tt->maxcompelements, tt->file);
   WriteShort(MAXDEPTH, tt->file);
   return CompleteTable(offset, TBL_MAXP, tt->file);
}



/***
 ** Function: PutOS2
 **
 ** Description:
 **   This function writes the required 'OS/2' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutOS2(OutputFile *file,
		      const struct GlyphList *pool,
		      const USHORT count,
		      const struct TTMetrics *ttm)
{
   long offset;
   long aw;
   USHORT i;

   offset = FileTell(file);

   /* Compute some font metrics. */
   aw = 0;

   /* Do a weighted average? */
   if (ttm->Encoding==NULL) {
      for (i=0; i<count; i++) {
	 short letter = (short)LookupCharCode(pool[i].code, ENC_MACCODES);
	 if (letter==' ') {
	    aw = aw + 166L * pool[i].aw;
	 } else if ((letter>='a' && letter <= 'z')) {
	    aw = aw + pool[i].aw * Weights[letter - 'a'];
	 }
      }
      aw /= 1000;
   } else {
      for (i=0; i<count; i++) {
	 aw += pool[i].aw;
      }
      aw = aw / count;
   }

   WriteShort(OS2VERSION, file);
   WriteShort((USHORT)aw, file);
   WriteShort(ttm->usWeightClass, file);
   WriteShort(ttm->usWidthClass, file);
   WriteShort(FM_READONLY, file);
   WriteShort((USHORT)ttm->subsize.x, file);
   WriteShort((USHORT)ttm->subsize.y, file);
   WriteShort((USHORT)ttm->suboff.x, file);
   WriteShort((USHORT)ttm->suboff.y, file);
   WriteShort((USHORT)ttm->supersize.x, file);
   WriteShort((USHORT)ttm->supersize.y, file);
   WriteShort((USHORT)ttm->superoff.x, file);
   WriteShort((USHORT)ttm->superoff.y, file);
   WriteShort((USHORT)ttm->strikesize, file);
   WriteShort((USHORT)ttm->strikeoff, file);
   WriteShort(NO_CLASS, file);

   /* Panose */
   WriteBytes(ttm->panose, (USHORT)10, file);

   /* Char range. */
   WriteLong(0L, file);
   WriteLong(0L, file);
   WriteLong(0L, file);
   WriteLong(0L, file);

   /* Vend ID. */
   WriteLong(0L, file);

   WriteShort(ttm->fsSelection, file);
   WriteShort(FIRSTCHAR, file);
   WriteShort(LASTCHAR, file);
   WriteShort((USHORT)ttm->typAscender, file);
   WriteShort((USHORT)ttm->typDescender, file);
   WriteShort((USHORT)ttm->typLinegap, file);
   WriteShort((USHORT)ttm->winAscender, file);
   WriteShort((USHORT)ttm->winDescender, file);

   return CompleteTable(offset, TBL_OS2, file);
}



/***
 ** Function: PutLOCA
 **
 ** Description:
 **   This function writes the required 'loca' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutLOCA(OutputFile *file,
		       const struct GlyphList *pool,
		       const USHORT count,
		       short *format)
{
   long offset;
   USHORT i;

   offset = FileTell(file);

   /* Check for offset size format. */
   for (i=0, (*format) = SHORTOFFSETS; i<=count &&
			 (*format)==SHORTOFFSETS; i++) {
      if (pool[i].offset/2>SHORT_LOCA_MAX)
	 (*format) = LONGOFFSETS;
   }

   if ((*format)==LONGOFFSETS)
      for (i=0; i<=count; i++)
	 WriteLong((ULONG)pool[i].offset, file);
   else
      for (i=0; i<=count; i++)
	 WriteShort((USHORT)(pool[i].offset/2), file);

   return CompleteTable(offset, TBL_LOCA, file);
}



/***
 ** Function: PutHMTX
 **
 ** Description:
 **   This function writes the required 'hmtx' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutHMTX(OutputFile *file,
		       const struct GlyphList *pool,
		       const USHORT count,
		       const funit *widths,
		       const USHORT first,
                       const USHORT last,
                       const  struct encoding *enc)

{
   long offset;
   USHORT std;
   USHORT i;
   USHORT usEnc = (USHORT) (enc? ENC_MACCODES : ENC_UNICODE);

   offset = FileTell(file);

   if (widths) {
      for (i=0; i<count; i++) {
	 if (pool[i].code) {
            std = LookupCharCode(pool[i].code, usEnc);
	 } else {
	    std = NOTDEFGLYPH;
	 }
	 if (std>=first && std<=last)
	    WriteShort((USHORT)widths[std-first], file);
	 else
	    WriteShort((USHORT)pool[i].aw, file);
	 WriteShort((USHORT)pool[i].lsb, file);
      }
   } else {
      for (i=0; i<count; i++) {
	 WriteShort((USHORT)pool[i].aw, file);
	 WriteShort((USHORT)pool[i].lsb, file);
      }
   }
   return CompleteTable(offset, TBL_HMTX, file);
}



/***
 ** Function: PutHHEA
 **
 ** Description:
 **   This function writes the required 'HHEA' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutHHEA(OutputFile *file,
		       const struct GlyphList *pool,
		       const USHORT count,
		       const Point bbox[2],
                       const funit linegap,
                       const struct TTMetrics *ttm
)
{
   funit awmin, awmax, xmax, lsb;
   long offset;
   USHORT i;

   offset = FileTell(file);

   /* Compute some font metrics. */
   awmax = SHRT_MIN;
   awmin = SHRT_MAX;
   xmax = SHRT_MIN;
   lsb = SHRT_MAX;
   for (i=0; i<count; i++) {
      funit rsb = pool[i].aw - pool[i].lsb -
		  (pool[i].bbox[1].x - pool[i].bbox[0].x);
      funit ext = pool[i].lsb +
		  (pool[i].bbox[1].x - pool[i].bbox[0].x);
      if (ext>xmax)
	 xmax = ext;
      if (rsb<awmin)
	 awmin = rsb;
      if (pool[i].aw>awmax)
	 awmax = pool[i].aw;
      if (pool[i].lsb<lsb)
	 lsb = pool[i].lsb;
   }


   WriteLong(LONGVERSION(1, 0), file);
   WriteShort((USHORT)bbox[1].y, file);
   WriteShort((USHORT)bbox[0].y, file);
   WriteShort((USHORT)linegap, file);
   WriteShort((USHORT)awmax, file);
   WriteShort((USHORT)lsb, file);
   WriteShort((USHORT)awmin, file);
   WriteShort((USHORT)xmax, file);
   WriteShort(CARET_RISE, file);
   WriteShort(CARET_RUN, file);
   WriteShort((USHORT)(ttm->FirstChar   << 8), file);
   WriteShort((USHORT)(ttm->LastChar    << 8), file);
   WriteShort((USHORT)(ttm->DefaultChar << 8), file);
   WriteShort((USHORT)(ttm->BreakChar   << 8), file);
   WriteShort((USHORT)(ttm->CharSet     << 8), file);
   WriteShort(RESERVED0, file);
   WriteShort(count, file);
   return CompleteTable(offset, TBL_HHEA, file);
}



/***
** Function: PutHEAD
**
** Description:
**   This function writes the required 'head' table to the
**   TT font file.
**
***/
STATIC errcode PutHEAD(OutputFile *file,
		       const Point bbox[2],
		       const struct TTMetrics *ttm,
		       const short loca,
		       long *csum)
{
   long offset;

   offset = FileTell(file);

   WriteLong(LONGVERSION(1, 0), file);
   WriteShort(ttm->version.ver, file);
   WriteShort(ttm->version.rev, file);
   (*csum) = (long)FileTell(file);
   WriteLong(0L, file);
   WriteLong(MAGICCOOKIE, file);
   WriteShort(BASELINEY, file);
   WriteShort((USHORT)ttm->emheight, file);
   WriteLong(ttm->created.a, file);WriteLong(ttm->created.b, file);
   WriteLong(ttm->created.a, file);WriteLong(ttm->created.b, file);
   WriteShort((USHORT)bbox[0].x, file);
   WriteShort((USHORT)bbox[0].y, file);
   WriteShort((USHORT)bbox[1].x, file);
   WriteShort((USHORT)bbox[1].y, file);
   WriteShort((USHORT)ttm->macStyle, file);
   WriteShort(LOWPPEM, file);
   WriteShort(ROMAN, file);
   WriteShort((USHORT)loca, file);
   WriteShort(GLYPH_FORMAT, file);

   return CompleteTable(offset, TBL_HEAD, file);
}



/***
** Function: WriteNameEntry
**
** Description:
**   This function writes an entry in the NAME table
**   header for one string.
**
***/
STATIC USHORT WriteNameEntry(OutputFile *file,
			     const USHORT platform,
			     const USHORT encoding,
			     const USHORT language,
			     const USHORT nameid,
			     const char *str,
			     const USHORT off)
{
   USHORT len;

   if (str) {
      len = (USHORT)strlen(str);
      switch (platform) {
	 case PLT_MS:
	    len *= 2;
	    break;
	 case PLT_MAC:
	    len *= 1;
	    break;
	 default:
	    LogError(MSG_WARNING, MSG_PLATFORM, NULL);
	    len *= 1;
	    break;
      }
      WriteShort(platform, file);
      WriteShort(encoding, file);
      WriteShort(language, file);
      WriteShort(nameid, file);
      WriteShort(len, file);
      WriteShort(off, file);
   } else {
      len = 0;
   }

   return len;
}



/***
** Function: WriteNameString
**
** Description:
**   This function write the textual data of a string
**   to the NAME table, according to the platform and
**   encoding schema.
**
***/
STATIC void WriteNameString(OutputFile *file,
			    const USHORT platform,
			    const char *str)
{
   USHORT i;

   if (str) {
      switch (platform) {
	 default:
	 case PLT_MAC:
	    (void)WriteBytes((UBYTE *)str, (USHORT)strlen(str), file);
	    break;
	 case PLT_MS:
	    for (i=0; i<strlen(str); i++)
	       WriteShort(LookupCharCode(DecodeChar(NULL,
						    (short)0,
						    ENC_STANDARD,
						    (USHORT)(UBYTE)str[i]),
					 ENC_UNICODE),
			  file);
	    break;
      }
   }
}



/***
** Function: PutNAME
**
** Description:
**   This function writes the required 'name' table to the
**   TT font file.
**
***/



STATIC errcode PutNAME(OutputFile *file, const struct TTMetrics *ttm)
{
   USHORT stroff = 0;
   USHORT count = 0;
   USHORT encId = ttm->Encoding ? ENC_SYMBOL : ENC_UGL;
   ULONG offset;
   char *id;
   char *pszStyle = NULL;

   if (ttm->usWeightClass < 500)
   {
      if (ttm->angle == 0)
      {
         pszStyle = "Regular";
      }
      else
      {
         pszStyle = "Italic";
      }
   }
   else
   {
      if (ttm->angle == 0)
      {
         pszStyle = "Bold";
      }
      else
      {
         pszStyle = "Bold Italic";
      }
   }

   /* Count the number of names. */
   if (ttm->copyright)
      count++;
   if (ttm->family)
      count++;
   if (pszStyle)
      count++;
   if (ttm->id) {
      count++;
      id = ttm->id;
   } else {
      id = ttm->name;
      count++;
   }
   if (ttm->fullname)
      count++;
   if (ttm->verstr)
      count++;
   if (ttm->name)
      count++;
   if (ttm->notice)
      count++;
   count *= 2;


   /* Write the name table. */
   offset = (ULONG)FileTell(file);
   WriteShort(VERSION0, file);
   WriteShort(count, file);
   WriteShort((USHORT)(6+count*12), file);

   /* Mac names */
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, COPYRIGHT,
		    ttm->copyright, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, FAMILY,
		    ttm->family, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, SUBFAMILY,
                    pszStyle, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, ID,
		    id, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, FULLNAME,
		    ttm->fullname, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, VERSION,
		    ttm->verstr, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, PSNAME,
		    ttm->name, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, NOTICE,
		    ttm->notice, stroff));

   /* MS names */
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, COPYRIGHT,
		    ttm->copyright, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, FAMILY,
		    ttm->family, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, SUBFAMILY,
                    pszStyle, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, ID,
		    id, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, FULLNAME,
		    ttm->fullname, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, VERSION,
		    ttm->verstr, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, PSNAME,
		    ttm->name, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, NOTICE,
		    ttm->notice, stroff));

   WriteNameString(file, PLT_MAC, ttm->copyright);
   WriteNameString(file, PLT_MAC, ttm->family);
   WriteNameString(file, PLT_MAC, pszStyle);
   WriteNameString(file, PLT_MAC, id);
   WriteNameString(file, PLT_MAC, ttm->fullname);
   WriteNameString(file, PLT_MAC, ttm->verstr);
   WriteNameString(file, PLT_MAC, ttm->name);
   WriteNameString(file, PLT_MAC, ttm->notice);

   WriteNameString(file, PLT_MS, ttm->copyright);
   WriteNameString(file, PLT_MS, ttm->family);
   WriteNameString(file, PLT_MS, pszStyle);
   WriteNameString(file, PLT_MS, id);
   WriteNameString(file, PLT_MS, ttm->fullname);
   WriteNameString(file, PLT_MS, ttm->verstr);
   WriteNameString(file, PLT_MS, ttm->name);
   WriteNameString(file, PLT_MS, ttm->notice);

   return CompleteTable((long)offset, TBL_NAME, file);
}



/***
** Function: BoundingBox
**
** Description:
**   Extend an already initialized rectangle (two points)
**   so that it encolses a number of coordinates.
***/
STATIC void BoundingBox(Point bbox[2],
			const Point *pts,
			const USHORT cnt)
{
   USHORT i;

   for (i=0; i<cnt; i++) {
      if (bbox[0].x > pts[i].x)
	 bbox[0].x = pts[i].x;
      if (bbox[1].x < pts[i].x)
	 bbox[1].x = pts[i].x;
      if (bbox[0].y > pts[i].y)
	 bbox[0].y = pts[i].y;
      if (bbox[1].y < pts[i].y)
	 bbox[1].y = pts[i].y;
   }
}



/***
** Function: RecordGlyph
**
** Description:
**   Record information about glyph record of the glyf table.
***/
STATIC errcode RecordGlyph(struct TTHandle *tt,
			   const struct encoding *code,
			   const Point *bbox,
			   const funit aw,
			   const USHORT pts,
			   const USHORT conts)
{
   errcode status;
   USHORT i;

   i = tt->count;

   /* Make sure that there is enough memory in the pool. */
   if (tt->count+1>=tt->maxcnt) {
      struct GlyphList *gl;

      if ((gl = Realloc(tt->pool,
			(size_t)(tt->maxcnt+GLYPHBUF)*
			sizeof(struct GlyphList)))==NULL) {
	 SetError(status=NOMEM);
	 return status;
      } else {
	 tt->maxcnt += GLYPHBUF;
	 tt->pool = gl;
      }
   }

   /* Record metrics. */
   tt->count++;
   tt->pool[i].pts = pts;
   tt->pool[i].conts = conts;
   tt->pool[i].lsb = bbox[0].x;
   tt->pool[i].aw = aw;
   tt->pool[i].bbox[0] = bbox[0];
   tt->pool[i].bbox[1] = bbox[1];
   tt->pool[i].code = code;
   tt->pool[i].offset = FileTell(tt->file) - 12L - (long)TBLDIRSIZE*NUMTBL;

   /* Update the global bounding box. */
   BoundingBox(tt->bbox, bbox, (short)2);

   /* Update maxp. */
   if (conts>tt->maxcontours)
      tt->maxcontours = conts;
   if (pts>tt->maxpts)
      tt->maxpts = pts;

   return SUCCESS;
}



/***
** Function: BuildMacCMAP
**
** Description:
**   Compute the CMAP subtable for the Mac.
***/
STATIC void BuildMacCMAP(const struct GlyphList *pool,
                         const USHORT count,
                         UBYTE *ascii2gi,
                         const struct encoding *encRoot,
                         const int encSize)
{
   const struct encoding *notdef = LookupNotDef();
   USHORT code;
   UBYTE i;

   /* Initiate the ascii to glyph-index array. Glyph 0 is the "notdef"
		character, so any unassigned character will be mapped to "notdef". */
   memset(ascii2gi, NOTDEFGLYPH, (unsigned int)MACSIZE);

   /* Build the ascii to glyph-index array. */
   if (encRoot==NULL)
   {
      for (i=2; i<MIN(255,count); i++)
      {
         if (pool[i].code!=NULL)
         {
            /* i = glyph index, Lookup..() = character code.
            Map glyph i only if it is a valid Mac character. */
            if (pool[i].code!=NULL &&
                (code = LookupCharCode(pool[i].code,ENC_MACCODES))!=NOTDEFCODE)
               ascii2gi[code] = i;
         }
      }
   }
   else
   {
      for (i=2; i<MIN(255,count); i++)
      {
         if (pool[i].code!=NULL && pool[i].code!=notdef)
         {
            const struct encoding *encGlyph;
            encGlyph = LookupFirstEnc(encRoot, encSize, pool[i].code);
            do
            {
               if ((code = LookupCharCode(encGlyph, ENC_MACCODES))!=NOTDEFCODE)
                  ascii2gi[code] = i;
            } while (encGlyph = LookupNextEnc(encRoot, encSize, encGlyph));
         }
      }
   }

   /* Constant Mac glyph/encoding mapping for standard encoded fonts */

   if (encRoot==NULL)
   {
      /* Missing glyphs. */
      for (i=1; i<=31; i++)
              ascii2gi[i] = NOTDEFGLYPH;
      ascii2gi[127] = NOTDEFGLYPH;

      /* Null glyphs. */
      ascii2gi[0] = 1;
      ascii2gi[8] = 1;
      ascii2gi[13] = 1;
      ascii2gi[29] = 1;

      /* No countours + positive advance width. */
      ascii2gi[9] = ascii2gi[32];
      ascii2gi[13] = ascii2gi[32];
      ascii2gi[202] = ascii2gi[32];
   }
}



/***
** Function: FreeMSEncoding
**
** Description:
**   Free resourses used while computing the CMAP subtable
**   for Windows.
***/
STATIC void FreeMSEncoding(struct MSEncoding *ms)
{
   if (ms->startCount)
      Free(ms->startCount);

   if (ms->gi)
      Free(ms->gi);
}



/***
** Function: BuildMSCMAP
**
** Description:
**   Compute the CMAP subtable for Windows.
***/
STATIC errcode BuildMSCMAP(const struct GlyphList *pool,
const  USHORT           count,
struct MSEncoding      *ms,
const  struct encoding *encRoot,
const  int              encSize
)
{
   USHORT *twobyte = NULL;
   USHORT idOffset;
   USHORT code, max;
   USHORT i, j, k, big, n;

   /* Get the range of the UGL characters. */
   max = 0;
   big = 0;

   if (encRoot==NULL)
   {
      for (i=2; i<count; i++)
      {
         if (pool[i].code!=NULL)
         {
            if ((code = LookupCharCode(pool[i].code, ENC_UNICODE))!=NOTDEFCODE)
            {
               if (code<=0xff)
               {
                  if (code>max)
                     max = code;
               }
               else
               {
                  big++;
               }
            }
         }
      }
   }
   else
   /* A non-standard encoded font, i.e. a fonts with an explicit
      encoding array may reference the same glyph more than once,
           though each glyph only refers to one encoding item. We have to
           enumerate through all code point for each glyph in this case.
   */
   {
      for (i=2; i<count; i++)
      {
         if (pool[i].code!=NULL)
         {
            const struct encoding *encGlyph = LookupFirstEnc(encRoot,
                                                             encSize,pool[i].code);
            do
            {
               if ((code = LookupCharCode(encGlyph, ENC_MACCODES))!=NOTDEFCODE)
               {
                  if (code>max)
                     max = code;
               }

            } while (encGlyph = LookupNextEnc(encRoot, encSize, encGlyph));
         }
      }
   }

   max++;
   max = (USHORT)(max + big);
   if ((ms->gi = Malloc(sizeof(USHORT)*max))==NULL) {
      return NOMEM;
   }
   memset(ms->gi, NOTDEFGLYPH, max*sizeof(USHORT));

   if (big && (twobyte = Malloc(sizeof(USHORT)*big))==NULL) {
      Free(ms->gi);
      ms->gi = NULL;
      return NOMEM;
   }
	
   j = 0;
   if (encRoot==NULL)
   {
      /* Glyph zero and Glyp one are the "notdef" and the "null" glyph,
              and are not encoded here, so skip the first two glyph.
      */
      for (i=2; i<count; i++)
      {
         code = LookupCharCode(pool[i].code, ENC_UNICODE);
         if (pool[i].code && code!=NOTDEFCODE)
         {
            if (code<=0xff)
            {
               ms->gi[code] = i;
            }
            else
            {
               for (k=0; k<j; k++)
                  if (twobyte[k]>code)
                     break;
               for (n=j; n>k; n--)
               {
                  twobyte[n] = twobyte[n-1];
                  ms->gi[max-big+n] = ms->gi[max-big+n-1];
               }
               twobyte[k] = code;
               ms->gi[max-big+k] = i;
               j++;
            }
         }
      }
   }
   else
   {
      for (i=2; i<count; i++)
      {
         const struct encoding *encGlyph;

         if (pool[i].code)
         {
            encGlyph = LookupFirstEnc(encRoot, encSize, pool[i].code);
            do
            {
               if ((code = LookupCharCode(encGlyph, ENC_MACCODES))!=NOTDEFCODE)
               {
                  ms->gi[code] = i;
               }
            } while (encGlyph = LookupNextEnc(encRoot, encSize, encGlyph));
         }
      }
   }

   /* Count the segments. */
   ms->segCount=(USHORT)(2+big);
   for (i=0; i<max-big-1; i++) {
      if (ms->gi[i]!=NOTDEFGLYPH && ms->gi[i+1]==NOTDEFGLYPH) {
	 ms->segCount++;
      }
   }

   ms->startCount = Malloc(3 * (sizeof(USHORT)*ms->segCount));

   if (ms->startCount==NULL) {
      if (twobyte)
	 Free(twobyte);
      FreeMSEncoding(ms);
      return NOMEM;
   }

   ms->endCount =  (USHORT *)((char *)ms->startCount + sizeof(USHORT)*ms->segCount);
   ms->idOffsets = (USHORT *)((char *)ms->endCount +  sizeof(USHORT)*ms->segCount);

   /* i=UGL index, j=segment index, k=glyph index. */
   for (i=0, j=0, k=0; i<max-big; i++) {
      if (ms->gi[i]!=NOTDEFGLYPH) {
	 if (i==0 || (ms->gi[i-1]==NOTDEFGLYPH)) {
	    ms->startCount[j] = i;
	    ms->idOffsets[j] = (USHORT)((ms->segCount-j+k)*2);
	 }
	 if ((i==max-1-big) || (ms->gi[i+1]==NOTDEFGLYPH)) {
	    ms->endCount[j] = i;
	    j++;
	 }
	 k++;
      }
   }

   /* Segment for the double byte characters. */
   idOffset = (USHORT)((ms->segCount-j+k)*2);
   for (i=0; i<big; i++) {
      ms->startCount[j] = twobyte[i];
      ms->idOffsets[j] = idOffset;
      ms->endCount[j] = twobyte[i];
      k++;
      j++;
   }

   ms->giCount = k;
   ms->giMax = max;

   /* Sentinel segments. */
   ms->startCount[ms->segCount-1] = 0xffff;
   ms->endCount[ms->segCount-1] = 0xffff;
   ms->idOffsets[ms->segCount-1] = 0;

   if (twobyte)
      Free(twobyte);

   return SUCCESS;
}



/***
** Function: PutCMAP
**
** Description:
**   This function writes the required 'cmap' table to the
**   TT font file.
***/
STATIC errcode PutCMAP(
struct TTHandle *tt,
UBYTE *ascii2gi,
const struct encoding *enc,
const int encSize)
{
   struct MSEncoding ms;
   long end, offset;
   errcode status = SUCCESS;
   USHORT i;
   USHORT usBias = (USHORT)(enc ? 0xf000 : 0); // bias for the first glyph

   /* Build Mac encoding table. */
   BuildMacCMAP(tt->pool, tt->count, ascii2gi, enc, encSize);


   /* Build MS encoding table. */
   if ((status = BuildMSCMAP(tt->pool, tt->count, &ms, enc, encSize))!=SUCCESS)
      return status;

   offset = FileTell(tt->file);

   /* Write cmap table. */
   WriteShort(VERSION0, tt->file);
   WriteShort(NUM_CMAPS, tt->file);

   /*== CMAP table directory ==*/
   WriteShort(PLT_MAC, tt->file);
   WriteShort(ENC_ROMAN, tt->file);
   WriteLong(0L, tt->file);
   WriteShort(PLT_MS, tt->file);
   WriteShort((USHORT)(enc ? ENC_SYMBOL : ENC_UGL), tt->file);
   WriteLong(0L, tt->file);

   /* Standard apple encoding. */
   end = FileTell(tt->file);
   (void)FileSeek(tt->file, offset+8);
   WriteLong((ULONG)(end-offset), tt->file);
   (void)FileSeek(tt->file, end);
   WriteShort((USHORT)0, tt->file);
   WriteShort((USHORT)(2+2+2+MACSIZE), tt->file);
   WriteShort((USHORT)0, tt->file);
   (void)WriteBytes(ascii2gi, MACSIZE, tt->file);

   /* Long word align the subtable. */
   end = FileTell(tt->file);
   if ((end-offset)%4)
      for (i=0; (short)i<(4-((end-offset)%4)); i++)
	 WriteByte(0, tt->file);


   /* MS delta encoding. */
   end = FileTell(tt->file);
   (void)FileSeek(tt->file, offset+16);
   WriteLong((ULONG)(end-offset), tt->file);
   (void)FileSeek(tt->file, end);

   /* format */
   WriteShort(SEGMENT_MAP, tt->file);
   /* length */
   WriteShort((USHORT)(16+ms.segCount*(2+2+2+2)+ms.giCount*2), tt->file);
   /* version */
   WriteShort(VERSION0, tt->file);
   /* 2*segCount */
   WriteShort((USHORT)(ms.segCount*2), tt->file);
   /* searchRange */
   WriteShort(SearchRange(ms.segCount), tt->file);
   /* entrySelector */
   WriteShort(EntrySelector(ms.segCount), tt->file);
   /* rangeShift */
   WriteShort(RangeShift(ms.segCount), tt->file);

   /* endCount */

   for (i=0; i<ms.segCount; i++)
      WriteShort((USHORT)(ms.endCount[i] | usBias), tt->file);

   WriteShort(PAD0, tt->file);

   /* startCount */
   for (i=0; i<ms.segCount; i++)
      WriteShort((USHORT)(ms.startCount[i] | usBias), tt->file);

   /* idDelta */
   for (i=0; i<ms.segCount; i++)
      WriteShort(PAD0, tt->file);

   /* rangeOffsets */
   for (i=0; i<ms.segCount; i++)
      WriteShort(ms.idOffsets[i], tt->file);

   for (i=0; i<ms.giMax; i++)
      if (ms.gi[i]!=NOTDEFGLYPH)
	 WriteShort(ms.gi[i], tt->file);


   /* Free resources. */
   FreeMSEncoding(&ms);

   return CompleteTable(offset, TBL_CMAP, tt->file);
}




/***** FUNCTIONS */


/***
** Function: TypographicalAscender
**
** Description:
**   Compute the typographical ascender height, as ymax of
**   the letter 'b'.
***/
funit TypographicalAscender(const struct TTHandle *tt)
{
   USHORT i;
   funit height = 0;

   for (i=0; (i<tt->count) && height==0; i++) {
      if (tt->pool[i].code &&
	  !strcmp(LookupCharName(tt->pool[i].code), "b"))
	 height = tt->pool[i].bbox[1].y;
   }

   return height;
}



/***
** Function: TypographicalDescender
**
** Description:
**   Compute the typographical descender height, as ymin of
**   the letter 'g'.
***/
funit TypographicalDescender(const struct TTHandle *tt)
{
   USHORT i;
   funit height = 0;

   for (i=0; i<tt->count && height==0; i++) {
      if (tt->pool[i].code &&
	  !strcmp(LookupCharName(tt->pool[i].code), "g"))
	 height = tt->pool[i].bbox[0].y;
   }

   return height;
}



/***
** Function: WindowsBBox
**
** Description:
**   Compute the bounding box of the characters that are
**   used in Windows character set.
***/


#ifdef NOT_NEEDED_ON_NT


void WindowsBBox(const struct TTHandle *tt, Point *bbox)
{
   USHORT i;
   funit height = 0;

   bbox[0].x = bbox[0].y = SHRT_MAX;
   bbox[1].x = bbox[1].y = SHRT_MIN;
   for (i=0; i<tt->count && height==0; i++) {
      if (tt->pool[i].code && LookupCharCode(tt->pool[i].code,
					     ENC_MSWINDOWS)) {
	 BoundingBox(bbox, tt->pool[i].bbox, (USHORT)2);
      }
   }
}

#endif

/***
** Function: MacBBox
**
** Description:
**   Compute the bounding box of the characters that are
**   used in Mac character set.
**
**   This is currently set to the global bounding box
**   (tt->bbox) of all characters in the font. This will
**   ensure that accents are not sqeezed on Mac platforms.
***/
void MacBBox(const struct TTHandle *tt, Point *bbox)
{
   bbox[0] = tt->bbox[0];
   bbox[1] = tt->bbox[1];
}


void GlobalBBox(const struct TTHandle *tt, Point *bbox)
{
   bbox[0] = tt->bbox[0];
   bbox[1] = tt->bbox[1];
}







/***
** Function: InitTTOutput
**
** Description:
**   This function allocates the resources needed to
**   write a TT font file.
***/
errcode InitTTOutput(const struct TTArg *arg, struct TTHandle **tt)
{
   errcode status = SUCCESS;

   /* Allocate resources. */
   if (((*tt)=Malloc(sizeof(struct TTHandle)))==NULL) {
      SetError(status = NOMEM);
   } else {

      /* Initiate. */
      memset((*tt), '\0', sizeof(**tt));

      /* Open the file. */
      if (((*tt)->file=OpenOutputFile(arg->name))==NULL) {
	 SetError(status = BADOUTPUTFILE);
      } else {

	 /* Allocate space for glyph records. */
	 if (((*tt)->pool
	      = Malloc(sizeof(struct GlyphList)*GLYPHBUF))==NULL) {
	    SetError(status = NOMEM);
	 } else {

	    /* Initiate. */
	    (*tt)->bbox[0].x = (*tt)->bbox[0].y = SHRT_MAX;
	    (*tt)->bbox[1].x = (*tt)->bbox[1].y = SHRT_MIN;
	    (*tt)->count = 0;
	    (*tt)->maxcnt = GLYPHBUF;
	    (*tt)->maxcontours = 0;
	    (*tt)->maxpts = 0;
	    (*tt)->maxcompelements = 0;
	    (*tt)->maxtwilight = 0;

	    /* Write header. */
	    WriteTableHeader((*tt)->file);

	    /* Check error condition. */
	    if (FileError((*tt)->file))
	       status = BADOUTPUTFILE;
	 }
      }
   }

   return status;
}



/***
** Function: FreeTTMetrics
**
** Description:
**   This function free's the resources used to represent
**   TT specific metrics and auxiliary font information.
***/
void FreeTTMetrics(struct TTMetrics *ttm)
{
   if (ttm->verstr)
      Free(ttm->verstr);
   if (ttm->cvt)
      Free(ttm->cvt);
   if (ttm->widths)
      Free(ttm->widths);
   if (ttm->prep)
      Free((UBYTE *)ttm->prep);
}



/***
** Function: CleanUpTT
**
** Description:
**   This function free's the resources used while
**   writing a TT font file.
***/
errcode CleanUpTT(struct TTHandle *tt,
		  const struct TTArg *ttarg,
		  const errcode status)
{
   errcode rc = SUCCESS;

   if (tt) {
      if (tt->file)
	 rc = CloseOutputFile(tt->file);

      /* Nuke the output file? */
      if (status!=SUCCESS || rc!=SUCCESS)
	 RemoveFile(ttarg->name);

      if (tt->pool)
	 Free(tt->pool);
      Free(tt);
   }

   return rc;
}



/***
** Function: FreeTTGlyph
**
** Description:
**   This function will free the memory used to represent a
**   a TrueType glyph.
**
***/
void FreeTTGlyph(struct TTGlyph *glyph)
{
   Outline *path = NULL;

   /* Free the memory. */
   if (glyph) {
      while (glyph->paths) {
	 path = glyph->paths->next;
	 Free(glyph->paths->pts);
	 Free(glyph->paths->onoff);
	 Free(glyph->paths);
	 glyph->paths = path;
      }
      if (glyph->hints)
	 Free(glyph->hints);
      Free(glyph);
   }
}



/***
** Function: PutTTNotDefGlyph
**
** Description:
**   This function adds a record for a the ".notdef" glyph to the
**   'glyf' table of the TT font file.
**
***/
errcode PutTTNotDefGlyph(struct TTHandle *tt, const struct TTGlyph *glyph)
{
   struct TTGlyph ttg;
   long end = FileTell(tt->file);
   errcode status = SUCCESS;
   USHORT oldcount = tt->count;
   Outline *path;
   int conts = 0;
   int size = 0;
   int cnt = 0;


   /* Determine if there is enough room. */
   for (path=glyph->paths; path; path=path->next) {
      cnt += path->count;
      conts += 1;
   }
   size = cnt * sizeof(Point) +     /* coordinates */
	  conts * sizeof(short) +   /* end points */
	  glyph->num +              /* instructions */
	  cnt * sizeof(char) * 2;   /* flag bytes */

   ttg = *glyph;
   if (size > MAXNOTDEFSIZE) {
      ttg.num = 0;
      ttg.stack = 0;
      ttg.twilights = 0;
      ttg.hints = NULL;
      if (size - glyph->num > MAXNOTDEFSIZE) {
	 ttg.paths = NULL;
      }
   }


   /* Move back to glyph #0, i.e. the missing glyph. */
   tt->count = 0;
   (void)FileSeek(tt->file,
						tt->pool[NOTDEFGLYPH].offset+12L+(long)TBLDIRSIZE*NUMTBL);
   status = PutTTGlyph(tt, &ttg, FALSE);
   tt->count = oldcount;
   (void)FileSeek(tt->file, end);

   /* Missing outline? */
   if (ttg.paths==NULL)
      tt->pool[NOTDEFGLYPH].offset = tt->pool[NULLGLYPH].offset;

   return status;
}


/***
** Function: PutTTGlyph
**
** Description:
**   This function adds a record for a simple glyph to the
**   'glyf' table of the TT font file.
**
***/
errcode PutTTGlyph(struct TTHandle *tt, const struct TTGlyph *glyph,
						 const boolean fStdEncoding)
{
   errcode status = SUCCESS;
   UBYTE flag, prev, cnt;
   USHORT i, c, n = 0;
   Outline *path;
   Point bbox[2];
   funit x, y;


   if (glyph!=NULL) {

#ifdef DOT
      /* Replace the '.' character. */
      if (LookupCharCode(glyph->code, ENC_STANDARD)==0x2e) {
         STATIC struct TTGlyph marker;
         STATIC Outline box;
         STATIC ULONG onoff[1];
         STATIC Point pts[4];
         STATIC UBYTE xleading[] = {
	    0x00,
	    0xb9, 0, 3, 0, 0,
	    0x38,    /* SHPIX[], 4, 640 */
	 };


	 marker = *glyph;
	 glyph = &marker;
	 marker.paths = &box;
	 marker.num = sizeof(xleading);
	 marker.hints = xleading;
	 box.next = NULL;
	 box.count = 4;
	 box.onoff = &onoff[0];
	 onoff[0] = 0;
	 box.pts = pts;
	 pts[0].x = 200; pts[0].y = 1400;
	 pts[1].x = 600; pts[1].y = 1400;
	 pts[2].x = 600; pts[2].y = 1800;
	 pts[3].x = 200; pts[3].y = 1800;
      }
#endif

      /* Update maxp */
      if (glyph->num>tt->maxinstructions)
	 tt->maxinstructions = glyph->num;
      if (glyph->stack>tt->maxstack)
	 tt->maxstack = glyph->stack;
      if (glyph->twilights>tt->maxtwilight)
	 tt->maxtwilight = glyph->twilights;

      if (glyph->paths==NULL) {
	 bbox[0].x = bbox[1].x = glyph->lsb;
	 bbox[0].y = bbox[1].y = 0;

	 status=RecordGlyph(tt, glyph->code, bbox,
			    glyph->aw, (USHORT)0, (USHORT)0);
      } else {

	 /* Compute header information. */
	 bbox[0].x = bbox[0].y = SHRT_MAX;
	 bbox[1].x = bbox[1].y = SHRT_MIN;
	 for (c=0, path=glyph->paths; path; path=path->next, c++) {
	    BoundingBox(bbox, path->pts, path->count);
	    n = (USHORT)(n + path->count);
	 }

	 /* Record loca and cmap info. */
	 if ((status=RecordGlyph(tt, glyph->code, bbox,
				 glyph->aw, n, c))==SUCCESS) {

	    /* Write number of contours. */
	    WriteShort(c, tt->file);

	    /* Write bounding box. */
	    if (c) {
	       WriteShort((USHORT)bbox[0].x, tt->file);
	       WriteShort((USHORT)bbox[0].y, tt->file);
	       WriteShort((USHORT)bbox[1].x, tt->file);
	       WriteShort((USHORT)bbox[1].y, tt->file);
	    } else {
	       WriteShort(PAD0, tt->file);
	       WriteShort(PAD0, tt->file);
	       WriteShort(PAD0, tt->file);
	       WriteShort(PAD0, tt->file);
	    }

	    /* Write endPts */
	    for (c=0, path=glyph->paths; path; path=path->next) {
	       c = (USHORT)(c + path->count);
	       WriteShort((short)(c-1), tt->file);
	    }

	    /* Write instruction length. */
	    WriteShort(glyph->num, tt->file);

	    /* Write instruction. */
	    (void)WriteBytes(glyph->hints, glyph->num, tt->file);


	    /* Write the flags. */
	    x=0; y=0;
	    prev = 255;
	    cnt = 0;
	    for (path=glyph->paths; path; path=path->next) {
	       for (i=0; i<path->count; i++) {
		  flag = 0;
		  if (OnCurve(path->onoff, i))
		     flag |= FLG_ONCURVE;

		  if (path->pts[i].x==x) {
		     flag |= FLG_SAMEX;
		  } else if (ABS(path->pts[i].x - x) <= 255) {
		     flag |= FLG_SHORTX;
		     if (path->pts[i].x > x)
			flag |= FLG_SAMEX;
		  }

		  if (path->pts[i].y==y) {
		     flag |= FLG_SAMEY;
		  } else if (ABS(path->pts[i].y - y) <= 255) {
		     flag |= FLG_SHORTY;
		     if (path->pts[i].y > y)
			flag |= FLG_SAMEY;
		  }

		  x = path->pts[i].x;
		  y = path->pts[i].y;
		  if (prev!=255) {
		     if (prev!=flag) {
			if (cnt) {
			   prev |= FLG_REPEAT;
			   WriteByte(prev, tt->file);
			   WriteByte(cnt, tt->file);
			} else {
			   WriteByte(prev, tt->file);
			}
			cnt = 0;
		     } else {
			cnt ++;
		     }
		  }
		  prev = flag;
	       }
	    }
	    if (cnt) {
	       prev |= FLG_REPEAT;
	       WriteByte(prev, tt->file);
	       WriteByte(cnt, tt->file);
	    } else {
	       WriteByte(prev, tt->file);
	    }


	    /* Write the x's */
	    x = 0;
	    for (path=glyph->paths; path; path=path->next) {
	       for (i=0; i<path->count; i++) {
		  if (path->pts[i].x != x) {
		     funit dx = path->pts[i].x - x;
		     if (ABS(dx)<=255) {
			WriteByte((UBYTE)ABS(dx), tt->file);
		     } else {
			WriteShort((USHORT)dx, tt->file);
		     }
		  }
		  x = path->pts[i].x;
	       }
	    }

	    /* Write the y's */
	    y = 0;
	    for (path=glyph->paths; path; path=path->next) {
	       for (i=0; i<path->count; i++) {
		  if (path->pts[i].y != y) {
		     funit dy = path->pts[i].y - y;
		     if (ABS(dy)<=255) {
			WriteByte((UBYTE)ABS(dy), tt->file);
		     } else {
			WriteShort((USHORT)dy, tt->file);
		     }
		  }
		  y = path->pts[i].y;
	       }
	    }


	    /* Word align the glyph entry. */
	    if (FileTell(tt->file) & 1)
	       WriteByte(0, tt->file);

	    /* Poll the file status. */
	    if (FileError(tt->file))
	       status = FAILURE;
	 }
      }


      /* Check for aliases. */
		if (fStdEncoding)
		{
			if (LookupCharCode(glyph->code, ENC_UNICODE)==0x20) {
				struct TTGlyph nobreak;

				nobreak = *glyph;
				nobreak.code = LookupPSName(NULL, 0, "nbspace");
				PutTTGlyph(tt, &nobreak, FALSE);
			}
			if (LookupCharCode(glyph->code, ENC_UNICODE)==0x2d) {
				struct TTGlyph sfthyphen;

				sfthyphen = *glyph;
				sfthyphen.code = LookupPSName(NULL, 0, "sfthyphen");
				PutTTGlyph(tt, &sfthyphen, FALSE);
			}
		}
   }

   return status;
}




/***
** Function: PutTTOther
**
** Description:
**   This function writes the required TT tables to the
**   TT font file, except for the 'glyf' table which is
**   only completed (check sum is computed, etc.).
**
***/
errcode PutTTOther(struct TTHandle *tt, struct TTMetrics *ttm)
{
   long offset = TBLDIRSIZE*NUMTBL+12;
   errcode status = SUCCESS;
   UBYTE ascii2gi[MACSIZE];
   errcode err = SUCCESS;
   short locafmt = 0;
   long csum = 0;


   /*==GLYF===*/
   tt->pool[tt->count].offset = FileTell(tt->file) - offset;
   err = CompleteTable(offset, TBL_GLYF, tt->file);


   /*==CMAP===*/
   if (err==SUCCESS)
      err = PutCMAP(tt, ascii2gi, ttm->Encoding, ttm->encSize);


   /*==LOCA===*/
   if (err==SUCCESS)
      err = PutLOCA(tt->file, tt->pool, tt->count, &locafmt);


   /*==HEAD===*/
   if (err==SUCCESS)
      err = PutHEAD(tt->file, tt->bbox, ttm, locafmt, &csum);


   /*==HHEA===*/
   if (err==SUCCESS)
      err = PutHHEA(tt->file, tt->pool, tt->count,
                    tt->bbox, ttm->macLinegap, ttm);


   /*==HMTX===*/
   if (err==SUCCESS)
      err = PutHMTX(tt->file, tt->pool, tt->count,
                    ttm->widths, ttm->FirstChar, ttm->LastChar,ttm->Encoding);


   /*==OS/2===*/
   if (err==SUCCESS)
      err = PutOS2(tt->file, tt->pool, tt->count, ttm);


   /*==MAXP===*/
   if (err==SUCCESS)
      err = PutMAXP(tt, ttm->maxstorage, ttm->maxprepstack, ttm->maxfpgm);


   /*==Name===*/
   if (err==SUCCESS)
      err = PutNAME(tt->file, ttm);


   /*==POST===*/
   if (err==SUCCESS)
      err = PutPOST(tt->file, tt->pool, tt->count, ttm);

   /*==PREP===*/
   if (err==SUCCESS)
      err = PutPREP(tt->file,
		    ttm->prep, ttm->prep_size);

   /*==FPGM===*/
   if (err==SUCCESS)
      err = PutFPGM(tt->file,
		    ttm->fpgm, ttm->fpgm_size);

   /*==CVT===*/
   if (err==SUCCESS)
      err = PutCVT(tt->file, ttm->cvt, ttm->cvt_cnt);


   /*==GASP==*/
   if (err==SUCCESS)
      err = PutGASP(tt->file, ttm->onepix);


   if (ttm->kerns && (err==SUCCESS))
      err = PutKERN(tt->file, ttm->kerns, ttm->kernsize, tt->pool, tt->count);


   /*=====*/
   /* Compute check sum. */
   if (err==SUCCESS) {
      WriteChecksum(csum, tt->file);
      if (FileError(tt->file))
	 err = BADOUTPUTFILE;
   }


   if (err != SUCCESS)
      SetError(status = err);

   return status;
}




/***
** Function: PutTTComposite
**
** Description:
**
***/
errcode PutTTComposite(struct TTHandle *tt, struct TTComposite *comp)
{
   errcode status;
   Point bbox[2], pts[2];
   USHORT ai=0, bi=0, oi=0;
   USHORT n,c;

   /* Convert the encoding handles to glyph indices. */
   while (ai<tt->count && comp->aenc!=tt->pool[ai].code)
      ai++;
   while (bi<tt->count && comp->benc!=tt->pool[bi].code)
      bi++;
   if (comp->oenc) {
      while (oi<tt->count && comp->oenc!=tt->pool[oi].code)
	 oi++;
   }

   /* Update the bounding box. */
   comp->dx += tt->pool[bi].bbox[0].x - tt->pool[ai].bbox[0].x;
   bbox[0] = tt->pool[bi].bbox[0]; bbox[1] = tt->pool[bi].bbox[1];
   pts[0] = tt->pool[ai].bbox[0]; pts[1] = tt->pool[ai].bbox[1];
   pts[0].x += comp->dx; pts[1].x += comp->dx;
   pts[0].y += comp->dy; pts[1].y += comp->dy;
   BoundingBox(bbox, pts, (USHORT)2);
   bbox[0].x = tt->pool[bi].bbox[0].x; bbox[1].x = tt->pool[bi].bbox[1].x;
   if (comp->oenc)
      BoundingBox(bbox, tt->pool[oi].bbox, (USHORT)2);

   if ((status=RecordGlyph(tt, comp->cenc, bbox,
			   comp->aw, (USHORT)0, (USHORT)0))==FAILURE)
      return status;

   /* Update max composite points/contours/elements. */
   n = (USHORT)(tt->pool[bi].pts + tt->pool[ai].pts);
   c = (USHORT)(tt->pool[bi].conts + tt->pool[ai].conts);
   if (n>tt->maxcomppts)
      tt->maxcomppts = n;
   if (c>tt->maxcompcont)
      tt->maxcompcont = c;
   if (comp->oenc)
      tt->maxcompelements = 3;
   else if (tt->maxcompelements<2)
      tt->maxcompelements = 2;


   /* Write number of contours. */
   WriteShort((USHORT)-1, tt->file);

   /* Write bounding box. */
   WriteShort((USHORT)bbox[0].x, tt->file);
   WriteShort((USHORT)bbox[0].y, tt->file);
   WriteShort((USHORT)bbox[1].x, tt->file);
   WriteShort((USHORT)bbox[1].y, tt->file);

   /* Write flags. */
   WriteShort((USHORT)(MORE_COMPONENTS |
		       ARGS_ARE_XY_VALUES |
		       ROUND_XY_TO_GRID),
	      tt->file);

   /* Write base glyph index. */
   WriteShort(bi, tt->file);
   WriteByte(0, tt->file);
   WriteByte(0, tt->file);

   if (comp->oenc) {
      WriteShort((USHORT)(MORE_COMPONENTS |
			  ARGS_ARE_XY_VALUES |
			  ROUND_XY_TO_GRID),
		 tt->file);
      WriteShort(oi, tt->file);
      WriteByte(0, tt->file);
      WriteByte(0, tt->file);
   }

   WriteShort((USHORT)(ARGS_1_2_ARE_WORDS |
		       ARGS_ARE_XY_VALUES |
		       ROUND_XY_TO_GRID),
	      tt->file);
   WriteShort(ai, tt->file);
   WriteShort((USHORT)comp->dx, tt->file);
   WriteShort((USHORT)comp->dy, tt->file);

   /* Word align the glyph entry. */
   if (FileTell(tt->file) & 1)
      WriteByte(0, tt->file);

   if (FileError(tt->file))
      return FAILURE;
   return SUCCESS;
}




/***
** Function: GetPrep
**
** Description:
**   This function allocates needed space for the
**   pre-program.
**
***/
UBYTE *GetPrep(const int size)
{
   return Malloc((size_t)size);
}


/***
** Function: UsePrep
**
** Description:
**   This function records the pre-program in the
**   TTMetrics record, until an appropriate time
**   when the data can be stored in the TT file.
**
***/
void UsePrep(struct TTMetrics *ttm,
	     const UBYTE *prep,
	     const USHORT prep_size)
{
   ttm->prep = (UBYTE *)prep;
   ttm->prep_size = prep_size;
}

/***
** Function: SetFPGM
**
** Description:
**   This function records the font-program in the
**   TTMetrics record, until an appropriate time
**   when the data can be stored in the TT file.
**
***/
void SetFPGM(struct TTMetrics *ttm,
	     const UBYTE *fpgm,
	     const USHORT fpgm_size,
	     const USHORT num)
{
   ttm->fpgm = fpgm;
   ttm->fpgm_size = fpgm_size;
   ttm->maxfpgm = num;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\mreader.c ===
/***
**
**   Module: MReader
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font metrics file, by parsing
**      the data/commands found in PFM and AFM files.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"

/* Module dependent types and prototypes. */
#include "pfm.h"



/***** CONSTANTS */
/*-none-*/



/***** LOCAL TYPES */
enum MType {t1_afm, t1_pfm, t1_unknown};



/***** MACROS */
/*-none-*/


/***** STATIC FUNCTIONS */

/***
** Function: MetricsType
**
** Description:
**   This function determines the type of the
**   metrics file that is associated to the 
**   main Adobe Type 1 outline file. 
***/
static enum MType MetricsType(const char *metrics)
{
   enum MType type;

   if (metrics==NULL || strlen(metrics)<5)
      type = t1_unknown;
   else if (!_strnicmp(&metrics[strlen(metrics)-3], "AFM", 3))
      type = t1_afm;
   else if (!_strnicmp(&metrics[strlen(metrics)-3], "PFM", 3))
      type = t1_pfm;
   else
      type = t1_unknown;

   return type;
}

/***** FUNCTIONS */

/***
** Function: ReadFontMetrics
**
** Description:
**  Read a font metrics file that associated to a type 1 font.
***/
errcode ReadFontMetrics(const char *metrics, struct T1Metrics *t1m)
{
   errcode status = SUCCESS;

   switch(MetricsType(metrics)) {
      case t1_pfm:
         status = ReadPFMMetrics(metrics, t1m);
         break;
      case t1_afm:
         /* status = ReadAFMMetrics(metrics, t1m); */
         break;
      case t1_unknown:
      default:
         status = BADMETRICS;
         break;
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\mreader.h ===
/***
**
**   Module: MReader
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font metrics file, by parsing
**      the data/commands found in PFM and AFM files.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif



/***
** Function: ReadFontMetrics
**
** Description:
**  Read a font metrics file that associated to a type 1 font.
***/
errcode   ReadFontMetrics   _ARGS((IN   char *metrics,
                                   OUT  struct T1Metrics *t1m));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\pfb.c ===
/***
**
**   Module: PFB
**
**   Description:
**        This is a module of the T1 to TT font converter. The module
**        contains functions that manages the "printer binary file" file
**        format (Adobe Type 1 for MS-Windows).
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <ctype.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"

/* Module dependent types and prototypes. */
#include "fileio.h"



/***** LOCAL TYPES */
struct t1file {
   struct ioFile *file;
   enum blocktype {none=0, ascii, encoded} type;
   long size;
   long curr;
};



/***** CONSTANTS */
/*-none-*/



/***** MACROS */
#define HEXDIGIT(c)  (((c)>='a') ? ((c) - 'a' + 10) : ((c) - '0')) 
#define HEX(c1,c2)   (HEXDIGIT(c1)*16+HEXDIGIT(c2))



/***** STATIC FUNCTIONS */
/*-none-*/



/***** FUNCTIONS */

/***
** Function: PFBAllocIOBlock
**
** Description:
**   Initiate an I/O stream for a PFB font file.
***/
struct t1file *PFBAllocIOBlock(const char *name)
{
   struct t1file *pfb;

   if ((pfb=Malloc(sizeof(struct t1file)))!=NULL) {

      if ((pfb->file = io_OpenFile(name, READONLY))==NULL) {
         Free(pfb);
         pfb = NULL;
      } else {
         pfb->type = none;
         pfb->size = 0;
         pfb->curr = 0;
      }
   }

   return pfb;
}


/***
** Function: PFBFreeIOBlock
**
** Description:
**   Free an I/O stream for a PFB font file.
***/
errcode FASTCALL PFBFreeIOBlock(struct t1file *pfb)
{
   errcode status = SUCCESS;

   status = io_CloseFile(pfb->file);
   Free(pfb);

   return status;
}


/***
** Function: PFBFileError
**
** Description:
**   Check if an I/O stream is ok.
***/
boolean FASTCALL PFBFileError(const struct t1file *pfb)
{
   return io_FileError(pfb->file);
}


/***
** Function: PFBGetByte
**
** Description:
**   Pull one byte from the opened PFB font file.
**   Please note that this function does not check
**   if it succeedes it reading a byte or not. It is
**   up to the calling module to manage the  error
**   checkes by using the FileError() function when
**   appropriate.
**
***/
short FASTCALL PFBGetByte(struct t1file *pfb)
{
   short b, c1, c2;

   /* Enter a new PFB block? */
   if (pfb->curr>=pfb->size) {
      UBYTE type[2];
      UBYTE size[4];

      type[0]=(UBYTE)io_ReadOneByte(pfb->file);
      type[1]=(UBYTE)io_ReadOneByte(pfb->file);

      size[0]=(UBYTE)io_ReadOneByte(pfb->file);
      size[1]=(UBYTE)io_ReadOneByte(pfb->file);
      size[2]=(UBYTE)io_ReadOneByte(pfb->file);
      size[3]=(UBYTE)io_ReadOneByte(pfb->file);

      pfb->curr = 0;
      pfb->size = (long)MkLong(size[3], size[2], size[1], size[0]);
      pfb->type = ((type[0]==0x80 && (type[1]==0x01 ||
                                      type[1]==0x02)) ? ascii : encoded);
   }


   /* Read a byte. */
   switch (pfb->type) {
      case ascii:
         b = (short)io_ReadOneByte(pfb->file);
         pfb->curr++;
         break;
      case encoded:
         c1 = (short)tolower(io_ReadOneByte(pfb->file));
         c2 = (short)tolower(io_ReadOneByte(pfb->file));
         b = (short)HEX(c1, c2);
         pfb->curr += 2;
         break;
      case none:
      default:
         b = (short)-1;
         break;
   }

   return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\pfb.h ===
/***
**
**   Module: PFB
**
**   Description:
**        This is a module of the T1 to TT font converter. The module
**        contains functions that manages the "printer binary file" file
**        format (Adobe Type 1 for MS-Windows).
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASCALL
#  endif
#endif

struct t1file;

/***
** Function: PFBAllocIOBlock
**
** Description:
**   Initiate an I/O stream for a PFB font file.
***/
struct t1file     *PFBAllocIOBlock  _ARGS((IN      char *name));


/***
** Function: PFBFreeIOBlock
**
** Description:
**   Free an I/O stream for a PFB font file.
***/
errcode FASTCALL  PFBFreeIOBlock    _ARGS((INOUT   struct t1file *io));


/***
** Function: PFBFileError
**
** Description:
**   Check if an I/O stream is ok.
***/
boolean FASTCALL  PFBFileError      _ARGS((IN      struct t1file *io));

/***
** Function: PFBGetByte
**
** Description:
**   Pull one byte from the opened PFB font file.
**   Please note that this function does not check
**   if it succeedes it reading a byte or not. It is
**   up to the calling module to manage the  error
**   checkes by using the FileError() function when
**   appropriate.
**
***/
short FASTCALL    PFBGetByte        _ARGS((INOUT   struct t1file *io));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\pfm.h ===
/***
**
**   Module: PFM
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font metrics file, by parsing
**      the data/commands found in a PFM file.
**
**      Please note the all data stored in a PFM file is represented
**      in the little-endian order.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

struct T1Metrics;


/***
** Function: ReadPFMMetrics
**
** Description:
**   This function parses a Printer Font Metrics
**   (*.pfm) file. 
***/
errcode  ReadPFMMetrics    _ARGS((IN      char *metrics,
                                  OUT     struct T1Metrics *t1m));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\safemem.h ===
/* Prototypes for "safe" (but slow) malloc/free routines to be used
 * in development of Large model Windows applications.
 *
 * lenoxb  5/28/93
 */

#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif



/***********
 ** Debug version of memory management functions.
 **
 */

#if TRACEMEM

void* SafeMalloc        _ARGS((INOUT   size_t,
                               INOUT   char *,
                               INOUT   short));
void* SafeReAlloc       _ARGS((INOUT   void*,
                               INOUT   size_t,
                               INOUT   char *,
                               INOUT   short));
void  SafeFree          _ARGS((INOUT   void*));
void  SafeListMemLeak   _ARGS((INOUT   void));
char* SafeStrdup        _ARGS((IN      char*,
                               INOUT   char *,
                               INOUT   short));

#define Malloc(size)          SafeMalloc(size, __FILE__, __LINE__)
#define Realloc(ptr, size)    SafeReAlloc(ptr, size, __FILE__, __LINE__)
#define Free(ptr)             SafeFree(ptr)
#define Strdup(ptr)           SafeStrdup(ptr, __FILE__, __LINE__)
#define ListMemLeak           SafeListMemLeak




#else
/***********
 ** Run-time version of memory management functions.
 **
 */


/*#include <stddef.h>*/
#include <stdlib.h>

#define Malloc(size)       malloc(size)
#define Realloc(ptr,size)  realloc(ptr, (size_t)(size))
#define Free               free
#define Strdup             _strdup
#define ListMemLeak()      ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\hints.c ===
/***
**
**   Module: Hints
**
**   Description:
**      This is a module of the T1 to TT font converter. This is a
**      sub-module of the T1 to TT data translator module. It deals
**      with hints. Any part pf the T1 font that gets translated into
** TrueType instructions is done within this module.
**
**   Author: Michael Jansson
**
**   Created: 8/24/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <limits.h>
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "trig.h"
#include "types.h"
#include "safemem.h"
#include "metrics.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "trans.h"
#include "hints.h"
#include "ttprog.h"



/***** CONSTANTS */
#define VERSION_SELECTOR 1    /* GetInfo[] selector for version number. */
#define VERSION_1_5     33    /* Version 1.5 of Windows TrueType rasterizer. */
#define STEMSNAPARGS    6     /* Number of args of the CreateStem TTFUN. */

#ifdef SYMETRICAL_REDUCTION
#define MIN_REDUCTION   4     /* Min reduction of the diag. cntrl. */
#endif
#define REDUCTION_C1    10    /* Min reduction, second method. */

#define STACKINC        500   /* Stack increment for arg-stack + prep. */

#define TARGSIZE        100   /* Size of temporary argument stack. */
#define TTFLEXSIZE      9     /* Largest size of a flex, w/o the points. */

#define TMP_TWILIGHTS         2
#define TWILIGHTS_PER_STEM    4

#define LEFTSTEM        1
#define RIGHTSTEM       2

#define SECONDPAIR      2

#define MAXRANGE        15

#define MAXEXTR         60       /* Max num of IP buckets. */

#define UNDEF           -1

#define STDV_CVT  1
#define STDH_CVT  2
#define SNAPV_CVT(v)       (v+3)
#define SNAPH_CVT(t1m, v)  (t1m->snapv_cnt+3+v)


/* External leading hint programs. */
static const UBYTE roman_hints[] = {
   /* Magic cookie. */
   op_pushb1 + 4, 66, 3, 8, 2, 16,
   op_clear,

   op_svcta | SUBOP_Y,
   op_pushb1, 3,

   /* Push 2pnt, in sub-pels. */
   op_mppem,
   op_mps,
   op_div,
   op_pushb1, 128,
   op_mul,

   /* Push InternalLeading, in sub-pels. */
   op_pushb1+1, 2, 1,
   op_md,
   op_sub,

   /* Push MAX(2pnt - i-leading, 0) */
   op_pushb1, 0,
   op_max,

   /* Add the external leading to the Ascent height. */
   op_shpix,
};
static const UBYTE swiss_hints[] = {
   /* Magic cookie. */
   op_pushb1 + 4, 66, 3, 8, 2, 16,
   op_clear,

   op_svcta | SUBOP_Y,
   op_pushb1, 3,

   /* 0<=height<=12.5 */
   op_mps,
   op_pushw1, HIBYTE(800), LOBYTE(800),   /* 12.5 pnt */
   op_gt,
   op_if,

   /* Push 2pnt, in sub-pels. */
   op_mppem,
   op_mps,
   op_div,
   op_pushb1, 128,
   op_mul,

   op_else,

   /* 12.5 < height <= 13.5 */
   op_mps,
   op_pushw1, HIBYTE(864), LOBYTE(864),   /* 13.5 pnt */
   op_gt,
   op_if,

   /* Push 3pnt, in sub-pels. */
   op_mppem, op_pushb1, 1, op_div,
   op_mps,
   op_div,
   op_pushb1, 192,
   op_mul,

   op_else,

   /* Push 4pnt, in sub-pels. */
   op_mppem, op_pushb1, 1, op_div,
   op_mps,
   op_div,
   op_pushw1, HIBYTE(256), /* LOBYTE(256) */ 0,
   op_mul,

   op_eif,

   op_eif,

   /* Push InternalLeading, in sub-pels. */
   op_pushb1+1, 2, 1,
   op_md,
   op_sub,
   op_dup,

   /* Push MAX(?pnt - i-leading, 0) */
   op_pushb1, 0,
   op_max,

   /* Add the external leading to the Ascent height. */
   op_shpix,

};


/* Pre-program. */
static const UBYTE PrepProg[] = {
   op_pushw1, 0x01, 0xff, op_scanctrl,

   op_pushb1, 1, op_rcvt,
   op_pushb1, 128,
   op_lt,
   op_if,

   op_pushb1 + 1, 4, 0, op_scantype, op_scantype,

   op_else,

   op_pushb1 + 1, 5, 1, op_scantype, op_scantype,

   op_eif,
};


/***** LOCAL TYPES */
/* Used for associating points to stems. */
typedef struct {
   short from;
   short to; 
} Range;


/* Zone bucket - Used for grid fitting a stem that may have
been divided into several stem instructions due to hint replacement. */
typedef struct TTStem { 
   funit side1;
   funit side2;
   short rp1;
   short rp2;
   short ref;
   enum aligntype align;
   Range range[MAXRANGE];
   short cnt;
} TTStem;




/***** MACROS */

/* General macros. */
#define Trans3X     TransX
#define TransRX     TransY

#define CLOSETO(v1, v2, eps)   (ABS((v1)-(v2))<=eps)

#define CHECK_ARGSIZE(args, ta, num, asize)   /* Check argument stack. */ \
/*lint -e571 -e644 */if (((ta)+(int)(num))>(asize)) { \
   short *newarg = NULL;\
   if ((newarg = Realloc(args, sizeof(short)*(USHORT)(ta+num+STACKINC)))==NULL) { \
      Free(args); \
      LogError(MSG_ERROR, MSG_NOMEM, NULL);\
      return 0;\
   } else {\
      args = newarg;\
      asize = (short)(ta+num+STACKINC);\
/*line +e571 +e644 */   }\
}
#define CHECK_PREPSIZE(prep, tp, num, psize)   /* Check prep size. */ \
if (((tp)+(num))>(psize)) { \
   UBYTE *newprep = NULL;\
   if ((newprep = Realloc(prep, tp+num+STACKINC))==NULL) { \
      Free(prep); \
      LogError(MSG_ERROR, MSG_NOMEM, NULL);\
      return 0;\
   } else {\
      prep = newprep;\
      psize = (short)(tp+num+STACKINC);\
   }\
}



/***** STATIC FUNCTIONS */



/***
** Function: ConvertFlex
**
** Description:
**   Convert a T1 flex hint into a TrueType IP[] 
**   intruction sequence that will reduce a flex
**   that is flatter than a given height.
***/
static errcode ConvertFlex(const struct T1Metrics *t1m,
                           const Flex *flexRoot,
                           const short *ttpnts,
                           UBYTE *pgm,
                           short *pc,
                           short *args,
                           short *pcd,
                           short *marg)
{
   errcode status = SUCCESS;
   int cis, last_cis = UNDEF;
   char dir, last_dir = 0;
   short targ[TARGSIZE];
   funit height, diff;
   const Flex *flex;
   short ta = 0;
   int num = 0;


   /* Return to the glyph zone. */
   if (flexRoot) {
      pgm[(*pc)++] = op_szps;
      args[(*pcd)++] = 1;
   }

   for (flex=flexRoot; flex; flex=flex->next) {

      /* Points lost in ConvertOutline? */
      if (ttpnts[flex->start]==UNDEF ||
          ttpnts[flex->mid]==UNDEF ||
          ttpnts[flex->end]==UNDEF) {
         LogError(MSG_WARNING, MSG_FLEX, NULL);
         continue;
      }

      /* Vertical or horizontal flex? */
      if (ABS(flex->midpos.x-flex->pos.x) <
          ABS(flex->midpos.y-flex->pos.y)) {
         dir = SUBOP_Y;
         height = TransY(t1m, (funit)(flex->startpos.y - flex->pos.y));
         diff = TransY(t1m, (funit)(flex->midpos.y - flex->startpos.y));
      } else {
         dir = SUBOP_X;
         height = TransX(t1m, (funit)(flex->startpos.x - flex->pos.x));
         diff = TransX(t1m, (funit)(flex->midpos.x - flex->startpos.x));
      }

      /* Skip flex without depth. */
      if (diff==0)
         continue;

      cis = (int)((long)flex->civ * (long)GetUPEM(t1m) / 100 / ABS(diff));

      if (cis!=last_cis || dir!=last_dir ||
          (ta+TTFLEXSIZE+(ttpnts[flex->end]-ttpnts[flex->start]))>=TARGSIZE) {
         if (last_cis!=UNDEF) {
            AssembleArgs(targ, ta, pgm, pc);
            while(num--)
               pgm[(*pc)++] = op_call;
            pgm[(*pc)++] = op_eif;
            ta = 0;
         }
         pgm[(*pc)++] = (UBYTE)(op_svcta | dir);
         pgm[(*pc)++] = op_mppem;
         pgm[(*pc)++] = op_gt;
         pgm[(*pc)++] = op_if;
         args[(*pcd)++] = (short)(cis+1);
         num = 0;
      }

      status = EmitFlex(targ, &ta, height,
                        ttpnts[flex->start],
                        ttpnts[flex->mid],
                        ttpnts[flex->end]);

      last_dir = dir;
      last_cis = cis;
      num++;

      if (status!=SUCCESS) {
         SetError(status = TTSTACK);
         break;
      }
   }
   if (num) {
      AssembleArgs(targ, ta, pgm, pc);
      while(num--)
         pgm[(*pc)++] = op_call;
      pgm[(*pc)++] = op_eif;
   }

   if ((*marg)<2)
      (*marg) = 2;

   return status;
}



/***
** Function: GetSnapV
**
** Description:
**   Return the closest snap width entry.
***/
static short GetSnapV(const struct T1Metrics *t1m, const funit width)
{
   USHORT dist = SHRT_MAX;
   USHORT j = 0;
   USHORT i;

   for (i=0; i<t1m->snapv_cnt; i++) {
      if (ABS(width-t1m->stemsnapv[i])<(short)dist) {
         dist = (USHORT)ABS(width-t1m->stemsnapv[i]);
         j = i;
      }
   }

   if (dist==SHRT_MAX)
      return UNDEF;

   return (short)j;
}





/***
** Function: GetSnapH
**
** Description:
**   Return the closest snap width entry.
***/
static short GetSnapH(const struct T1Metrics *t1m, const funit width)
{
   USHORT dist = SHRT_MAX;
   USHORT j = 0;
   USHORT i;

   for (i=0; i<t1m->snaph_cnt; i++) {
      if (ABS(width-t1m->stemsnaph[i])<(short)dist) {
         dist = (USHORT)ABS(width-t1m->stemsnaph[i]);
         j = i;
      }
   }

   if (dist==SHRT_MAX)
      return UNDEF;

   return (short)j;
}




/***
** Function: PosX
**
** Description:
**   This is a call-back function used by
**   Interpolate.
***/
static funit PosX(const Point pnt)
{
   return pnt.x;
}



/***
** Function: PosY
**
** Description:
**   This is a call-back function used by
**   Interpolate.
***/
static funit PosY(const Point pnt)
{
   return pnt.y;
}



/***
** Function: InRange
**
** Description:
**   This is function determines if a point is
**   within range of a hint zone.
***/
static boolean InRange(const short pnt, const Range *range, const short cnt)
{
   short k;

   for (k=0; k<cnt; k++) {
      if ((range[k].from<=pnt) &&
          (range[k].to>=pnt || range[k].to==ENDOFPATH))
         break;
   }

   return (boolean)(k != cnt);
}


/***
** Function: BoundingStems
**
** Description:
**   Determines what stems are located to the
**   left and to the right of a point on the
**   outline, given its position.
**   
***/
static short BoundingStems(short pnt, const short max_pnt,
                           const funit pos, const TTStem *stems,
                           const short cnt,
                           short *left, short *right)
{
   funit min, max;
   short i;

   max = SHRT_MAX;
   min = 1-SHRT_MAX;
   (*right) = UNDEF;
   (*left) = UNDEF;
   do {
      for (i=0; i<cnt; i++) {
         /* Is stem to the left and defined for the point? */
         if ((stems[i].side1<=pos) &&
             (stems[i].side1>min) &&
             InRange(pnt, stems[i].range, stems[i].cnt)) {
            min = stems[i].side1;
            (*left) = (short)i;
         }

         /* Is stem to the right and defined for the point. */
         if ((stems[i].side2>=pos) &&
             (stems[i].side2<max) &&
             InRange(pnt, stems[i].range, stems[i].cnt)) {
            max = stems[i].side2;
            (*right) = (short)i;
         }
      }

   /* Advance to the next point on the outline if we did not find stems. */
   } while (((*left)==UNDEF) && ((*right)==UNDEF) && (++pnt<(short)max_pnt));

   return pnt;
}




/***
** Function: EndOfRegion
**
** Description:
**   Determine what is the closest point, after the
**   given point, for a new hint replacement.
**   
***/
static short EndOfRegion(const short pnt, const TTStem *stem)
{
   short k;

   for (k=0; k<stem->cnt; k++) {
      if ((stem->range[k].from<=pnt) &&
          (stem->range[k].to>=pnt || stem->range[k].to==ENDOFPATH))
         break;
   }

   return (short)((k==stem->cnt || stem->range[k].to==ENDOFPATH)
                  ? SHRT_MAX : stem->range[k].to);
}




/***
** Function: AddToBucket
**
** Description:
**   This function will add a point, that
**   is located between two stems, into a
**   bucket that represents an interpolation
**   zone.
***/
static short AddToBucket(Extremas *extr,
                         short xcnt,
                         const short pnt,
                         const funit left,
                         const funit right,
                         const TTStem *stems)
{
   short rp1, rp2;
   short tmp, j;

   /* Pick the reference points (which are located in the twilight zone). */
   if (left!=UNDEF)
      rp1 = stems[left].rp2;
   else
      rp1 = UNDEF;
   if (right!=UNDEF)
      rp2 = stems[right].rp1;
   else
      rp2 = UNDEF;

   /* Normalize the reference points. */
   tmp = rp1;
   rp1 = (short)MIN(rp1, rp2);
   rp2 = (short)MAX(tmp, rp2);

   /* Create/Fill IP bucket. */
   for (j=0; j<xcnt; j++) 
      if (extr[j].rp1==rp1 && extr[j].rp2==rp2 && extr[j].n<MAXPTS)
         break;
   if (j==xcnt) {
      if (xcnt<MAXEXTR) {
         extr[xcnt].rp1 = rp1;
         extr[xcnt].rp2 = rp2;
         extr[xcnt].n = 0;
         xcnt++;
      } else {
         LogError(MSG_WARNING, MSG_EXTREME1, NULL);
      }
   }

   /* Add the point to the bucket. */
   if (j<MAXEXTR && extr[j].n<MAXPTS &&
       (extr[j].pts[extr[j].n] = pnt)!=UNDEF)
      extr[j].n++;

   return xcnt;
}


/***
** Function: AddSidePntToBucket
**
** Description:
**   Same as AddToBucket, but the points are
**   known to reside exactly on the side of
**   a stem, and should be controled by one
**   reference point alone. This is only needed
**   for sheared fonts, where controling side
**   point w.r.t. two reference poins leads
**   to problems.
***/
static short AddSidePntToBucket(Extremas *extr,
                                short xcnt,
                                const short pnt,
                                const short rp)
{
   short j;

   /* Create/Fill IP bucket. */
   for (j=0; j<xcnt; j++) 
      if (extr[j].rp1==rp && extr[j].rp2==UNDEF && extr[j].n<MAXPTS)
         break;
   if (j==xcnt) {
      if (xcnt<MAXEXTR) {
         extr[xcnt].rp1 = rp;
         extr[xcnt].rp2 = UNDEF;
         extr[xcnt].n = 0;
         xcnt++;
      } else {
         LogError(MSG_WARNING, MSG_EXTREME1, NULL);
      }
   }

   /* Add the point to the bucket. */
   if (j<MAXEXTR && extr[j].n<MAXPTS &&
       (extr[j].pts[extr[j].n] = pnt)!=UNDEF)
      extr[j].n++;

   return xcnt;
}





/***
** Function: PickSides
**
** Description:
**   Select the position of the left and
**   right side boundry of a point, given
**   the stem to the left and right of the
**   current point on the outline.
***/
static void PickSides(short left, short right,
                      funit *left_side,
                      funit *right_side,
                      TTStem *stems)
{
   if (left!=right) {
      if (left!=UNDEF)
         (*left_side) = stems[left].side2;
      else
         (*left_side) = 1-SHRT_MAX/2;
      if (right!=UNDEF)
         (*right_side) = stems[right].side1;
      else
         (*right_side) = SHRT_MAX/2;
   } else {
      (*left_side) = stems[left].side1;
      (*right_side) = stems[right].side2;
   }
}   





/***
** Function: PickSequence
**
** Description:
**   Determine at what point the current
**   hint sequence is ending.
***/
static short PickSequence(short left, short right, short pnt, TTStem *stems)
{
   short left_end;
   short right_end; 
   short new_seq;

   if (left!=UNDEF && right!=UNDEF) {
      left_end = EndOfRegion(pnt, &stems[left]);
      right_end = EndOfRegion(pnt, &stems[right]);
      new_seq = (short)MIN(left_end, right_end);
   } else if (left!=UNDEF) {
      left_end = EndOfRegion(pnt, &stems[left]);
      new_seq = left_end;
   } else {
      right_end = EndOfRegion(pnt, &stems[right]);
      new_seq = right_end;
   }

   return new_seq;
}



/***
** Function: CollectPoints
**
** Description:
**   This function will go through the points
**   that are local extremas and interpolate
**   them w.r.t. the enclosing stem sides.
**   The non-extreme points are handled with
**   an IUP[] instruction when this is done.
***/
static short CollectPoints(const Outline *orgpaths,
                           const short *ttpnts,
                           TTStem *stems,
                           short cnt,
                           Extremas *extr,
                           funit (*Position)(const Point))
{
   const Outline *path;
   short xcnt = 0;
   short i,tot;
   short prev_stem;
   funit pos;
   short left, right;
   funit left_side, right_side;
   funit max, min;
   short max_pnt, min_pnt;
   short new_seq, n;
   short prev_pnt;
   funit prev_pos;
   short first;
   short pnt = UNDEF;


   tot = 0;
   for (path=orgpaths; path; path=path->next) {
      first = BoundingStems(tot,
                            (short)(tot+(short)path->count),
                            Position(path->pts[0]),
                            stems, cnt, &left, &right);
      if (first==tot+(short)path->count) {
         tot = (short)(tot + path->count);
         continue;
      }

      new_seq = PickSequence(left, right, tot, stems);
      PickSides(left, right, &left_side, &right_side, stems);
      max = 1-SHRT_MAX/2;
      min_pnt = UNDEF;
      max_pnt = UNDEF;
      min = SHRT_MAX/2;
      prev_pnt = FALSE;
      prev_pos = UNDEF;
      prev_stem = UNDEF;
      for (i = (short)(first-tot); i<(short)path->count; i++) {
         if (OnCurve(path->onoff, i)) {
            pos = Position(path->pts[i]);
            n = (short)(i+tot);

            /* Have we crossed over a stem side. */
            if ((prev_stem!=RIGHTSTEM && pos<=left_side && max_pnt!=UNDEF) ||
                (prev_stem!=LEFTSTEM && pos>=right_side && min_pnt!=UNDEF)) {

               if (prev_stem!=RIGHTSTEM && max_pnt!=UNDEF) {
                  pnt = max_pnt;
                  prev_pos = max;

               } else if (prev_stem!=LEFTSTEM && min_pnt!=UNDEF) {
                  pnt = min_pnt;
                  prev_pos = min;
               }

               xcnt = AddToBucket(extr, xcnt, ttpnts[pnt], left, right, stems);

               max = 1-SHRT_MAX/2;
               min = SHRT_MAX/2;
               max_pnt = UNDEF;
               min_pnt = UNDEF;
               prev_pnt = TRUE;
            }

            /* Crossing the side of a stem. */
            if ((pos>=right_side) || (pos<=left_side)) {
               if (pos<left_side)
                  prev_stem = RIGHTSTEM;
               else
                  prev_stem = LEFTSTEM;
            }

            /* Change left/right stem sides? */
            if ((n>new_seq) || (pos>=right_side) || (pos<=left_side)) {
               first = BoundingStems(n,
                                     (short)(path->count+tot),
                                     pos, stems, cnt,
                                     &left, &right);
               if (left==UNDEF && right==UNDEF)
                  break;

               i = (short)(i + first - n);
               new_seq = PickSequence(left, right, n, stems);
               PickSides(left, right, &left_side, &right_side, stems);
               max = 1-SHRT_MAX/2;
               min = SHRT_MAX/2;
               max_pnt = UNDEF;
               min_pnt = UNDEF;
            }

            /* Is the point on the side of the stem? */
            if (CLOSETO(pos,left_side,2) || CLOSETO(pos,right_side,2)) {
               if (!prev_pnt || !CLOSETO(prev_pos, pos, 2)) {
                  if (CLOSETO(pos, right_side, 2) ||
                      CLOSETO(pos, left_side, 2)) {
                     pnt = (short)n;
                     prev_pos = pos;

                  } else if (prev_stem!=RIGHTSTEM && max_pnt!=UNDEF) {
                     pnt = max_pnt;
                     prev_pos = max;
                     max_pnt = UNDEF;

                  } else if (prev_stem!=LEFTSTEM && min_pnt!=UNDEF) {
                     pnt = min_pnt;
                     prev_pos = min;
                     min_pnt = UNDEF;
                  }

                  xcnt = AddToBucket(extr, xcnt, ttpnts[pnt],
                                     left, right, stems);
               }

               prev_pnt = TRUE;
               prev_pos = pos;
            } else {
               prev_pnt = FALSE;

               /* New extremum candidate? */
               if (pos>max) {
                  max = pos;
                  max_pnt = (short)n;
               }
               if (pos<min) {
                  min = pos;
                  min_pnt = (short)n;
               }
            }
         }
      }


      if (left!=UNDEF || right!=UNDEF) {
         if (max_pnt!=UNDEF) {
            xcnt = AddToBucket(extr, xcnt, ttpnts[max_pnt],
                               left, right, stems);
         }
         if (min_pnt!=UNDEF && min!=max) {
            xcnt = AddToBucket(extr, xcnt, ttpnts[min_pnt],
                               left, right, stems);
         }
      }

      tot = (short)(tot + path->count);
   }


   return xcnt;
}



/***
** Function: CollectObliquePoints
**
** Description:
**   This function performs the same task as
**   the "CollectPoint" function, with the
**   exception that the outline is known to
**   be sheared. Some of the logics 
**   is changed, bacause the IUP[] instruction
**   and some IP instruction will not behave
**   the same as in a non-sheared font.
**   This differance applies only to vertical
**   stems (hints resulting in horizontal motion of
**   of points).
***/
static short CollectObliquePoints(const Outline *orgpaths,
                                  const short *ttpnts,
                                  TTStem *stems,
                                  short cnt,
                                  Extremas *extr,
                                  funit (*Position)(const Point))
{
   const Outline *path;
   short xcnt = 0;
   short i,tot;
   short prev_stem;
   funit pos;
   short left, right;
   funit left_side, right_side;
   funit max, min;
   short max_pnt, min_pnt;
   short new_seq, n;
   short first;
   short pnt = UNDEF;


   tot = 0;
   for (path=orgpaths; path; path=path->next) {
      first = BoundingStems(tot,
                            (short)(tot+path->count),
                            Position(path->pts[0]),
                            stems, cnt, &left, &right);
      if (first==tot+(short)path->count) {
         tot = (short)(tot + path->count);
         continue;
      }

      new_seq = PickSequence(left, right, tot, stems);
      PickSides(left, right, &left_side, &right_side, stems);
      max = 1-SHRT_MAX/2;
      min_pnt = UNDEF;
      max_pnt = UNDEF;
      min = SHRT_MAX/2;
      prev_stem = UNDEF;
      for (i = (short)(first-tot); i<(short)path->count; i++) {
         if (OnCurve(path->onoff, i)) {
            pos = Position(path->pts[i]);
            n = (short)(i+tot);

            /* Have we crossed over a stem side. */
            if ((prev_stem!=RIGHTSTEM && pos<=left_side && max_pnt!=UNDEF) ||
                (prev_stem!=LEFTSTEM && pos>=right_side && min_pnt!=UNDEF)) {

               if (prev_stem!=RIGHTSTEM && max_pnt!=UNDEF) {
                  pnt = max_pnt;

               } else if (prev_stem!=LEFTSTEM && min_pnt!=UNDEF) {
                  pnt = min_pnt;
               }

               max = 1-SHRT_MAX/2;
               min = SHRT_MAX/2;
               max_pnt = UNDEF;
               min_pnt = UNDEF;
            }

            /* Crossing the side of a stem. */
            if ((pos>=right_side) || (pos<=left_side)) {
               if (pos<left_side)
                  prev_stem = RIGHTSTEM;
               else
                  prev_stem = LEFTSTEM;
            }

            /* Change left/right stem sides? */
            if ((n>new_seq) || (pos>=right_side) || (pos<=left_side)) {
               first = BoundingStems(n,
                                     (short)(path->count+tot),
                                     pos, stems, cnt,
                                     &left, &right);
               if (left==UNDEF && right==UNDEF)
                  break;

               i = (short)(i + first - n);
               new_seq = PickSequence(left, right, n, stems);
               PickSides(left, right, &left_side, &right_side, stems);
               max = 1-SHRT_MAX/2;
               min = SHRT_MAX/2;
               max_pnt = UNDEF;
               min_pnt = UNDEF;
            }

            /* Is the point on the side of the stem? */
            if (CLOSETO(pos,left_side,2) || CLOSETO(pos,right_side,2)) {
               if (CLOSETO(pos, right_side, 2)) {
                  pnt = (short)n;
                  if (stems[right].side1==right_side)
                     xcnt = AddSidePntToBucket(extr, xcnt, ttpnts[pnt],
                                               stems[right].rp1);
                  else
                     xcnt = AddSidePntToBucket(extr, xcnt, ttpnts[pnt],
                                               stems[right].rp2);

               } else if (CLOSETO(pos, left_side, 2)) {
                  pnt = (short)n;
                  if (stems[left].side1==left_side)
                     xcnt = AddSidePntToBucket(extr, xcnt, ttpnts[pnt],
                                               stems[left].rp1);
                  else
                     xcnt = AddSidePntToBucket(extr, xcnt, ttpnts[pnt],
                                               stems[left].rp2);

               } else if (prev_stem!=RIGHTSTEM && max_pnt!=UNDEF) {
                  pnt = max_pnt;
                  max_pnt = UNDEF;

               } else if (prev_stem!=LEFTSTEM && min_pnt!=UNDEF) {
                  pnt = min_pnt;
                  min_pnt = UNDEF;

               }

            } else {

               /* New extremum candidate? */
               if (pos>max) {
                  max = pos;
                  max_pnt = (short)n;
               }
               if (pos<min) {
                  min = pos;
                  min_pnt = (short)n;
               }
            }
         }
      }


      if (left!=UNDEF || right!=UNDEF) {
         if (max_pnt!=UNDEF) {
         }
         if (min_pnt!=UNDEF && min!=max) {
         }
      }

      tot = (short)(tot + path->count);
   }


   return xcnt;
}



/***
** Function: AddRange
**
** Description:
**   This function adds a point range to
**   a stem bucket.
***/
static void AddRange(TTStem *stem, const short i1, const short i2)
{
   short i;

   /* Check if a prior range can be extended. */
   if (i2!=ENDOFPATH) {
      for (i=0; i<stem->cnt; i++) {
         if (stem->range[i].from == i2+1)
            break;
      }
   } else {
      i = stem->cnt;
   }

   if (i==stem->cnt) {
      if (stem->cnt<MAXRANGE) {
         stem->range[stem->cnt].from = i1;
         stem->range[stem->cnt].to = i2;
         stem->cnt++;
      } else {
         LogError(MSG_WARNING, MSG_REPLC, NULL); 
      }
   } else {
      stem->range[i].from = i1;
   }

}


/***
** Function: CreateStemBuckets
**
** Description:
**   This function will create stem buckets.
**   Several duplicated T1 stem instructions
**   may be mapped to the same bucket.
***/
static short CreateStemBuckets(Stem *stemRoot,
                               Stem3 *stem3Root,
                               TTStem **result)
{
   Stem3 *stem3, *stm3;
   Stem *stem, *stm;
   TTStem *stems = NULL;
   short i, j;
   short cnt;
   short tzpnt = TMPPNT1+1;


   /* Count the stems. */
   cnt = 0;
   (*result) = NULL;
   for (stem3=stem3Root; stem3; stem3=stem3->next) {

      /* Skip obsolete stems. */
      if (stem3->stem1.i2 == NORANGE)
         continue;

      /* Look for a duplicate. */
      for (stm3=stem3Root; stm3!=stem3; stm3=stm3->next) {
         if (stm3->stem1.offset==stem3->stem1.offset &&
             stm3->stem2.offset==stem3->stem2.offset &&
             stm3->stem3.offset==stem3->stem3.offset)
            break;
      }

      /* Count this stem if it is not a duplicate. */
      if (stm3==stem3)
         cnt = (short)(cnt + 3);
   }
   for (stem=stemRoot; stem; stem=stem->next) {

      /* Skip obsolete stems. */
      if (stem->i2 == NORANGE)
         continue;

      /* Look for a duplicate. */
      for (stm=stemRoot; stm!=stem; stm=stm->next) {
         if (stm->offset==stem->offset && stm->width==stem->width)
            break;
      }

      /* Don't count this stem if it is a duplicate. */
      if (stm==stem)
         cnt++;
   }



   /* Initiate them. */
   if (cnt) {
      if ((stems = Malloc(sizeof(TTStem)*(USHORT)cnt))==NULL) {
         errcode status;
         SetError(status=NOMEM);
         return status;
      }

      i = (short)(cnt-1);

      /* Initiate the buckets for the stem3s */
      for (stem3=stem3Root; stem3; stem3=stem3->next) {

         /* Skip obsolete stems. */
         if (stem3->stem1.i2 == NORANGE)
            continue;

         /* Skip if bucket exist for this stem already. */
         for (j=(short)(i+1); j<cnt; j++) {
            if (stems[j].side1==stem3->stem1.offset &&
                stems[j].side2==(stem3->stem1.offset+stem3->stem1.width))
               break;
         }

         if (j==cnt) { 

            /* The rightmost stem is positioned w.r.t. to the middle. */
            stems[i].side1 = stem3->stem1.offset;
            stems[i].side2 = stem3->stem1.width + stem3->stem1.offset;
            stems[i].align = at_relative2;
            stems[i].ref = (short)(i-2);
            stems[i].rp1 = tzpnt++;
            stems[i].rp2 = tzpnt++;
            stems[i].cnt = 1;
            stems[i].range[0].from = stem3->stem1.i1;
            stems[i].range[0].to = stem3->stem1.i2;
            tzpnt+=2;
            i--;

            /* The leftmost stem is positioned w.r.t. to the middle. */
            stems[i].side1 = stem3->stem3.offset;
            stems[i].side2 = stem3->stem3.width + stem3->stem3.offset;
            stems[i].align = at_relative1;
            stems[i].ref = (short)(i-1);
            stems[i].rp1 = tzpnt++;
            stems[i].rp2 = tzpnt++;
            stems[i].cnt = 1;
            stems[i].range[0].from = stem3->stem1.i1;
            stems[i].range[0].to = stem3->stem1.i2;
            tzpnt+=2;
            i--;

            /* The middle stem is centered. */
            stems[i].side1 = stem3->stem2.offset;
            stems[i].side2 = stem3->stem2.width + stem3->stem2.offset;
            stems[i].align = at_centered;
            stems[i].rp1 = tzpnt++;
            stems[i].rp2 = tzpnt++;
            stems[i].cnt = 1;
            stems[i].range[0].from = stem3->stem1.i1;
            stems[i].range[0].to = stem3->stem1.i2;
            tzpnt+=2;
            i--;
         } else {
            AddRange(&stems[j-0], stem3->stem1.i1, stem3->stem1.i2);
            AddRange(&stems[j-1], stem3->stem3.i1, stem3->stem3.i2);
            AddRange(&stems[j-2], stem3->stem2.i1, stem3->stem2.i2);
         }
      }      

      /* Initiate the buckets for the stems. */
      for (stem=stemRoot; stem; stem=stem->next) {

         /* Skip obsolete stems. */
         if (stem->i2 == NORANGE)
            continue;

         /* Skip if bucket exist for this stem already. */
         for (j=(short)(i+1); j<(short)cnt; j++) {
            if (stems[j].side1==stem->offset &&
                stems[j].side2==(stem->offset+stem->width))
               break;
         }

         /* Initiate new bucket:
         Plain vstems and hstems are centered by default. Some
         hstems may be top- or bottom-aligen at a latter point.
         Some stems may be positioned w.r.t. another vstem if
         they overlapp and the RELATIVESTEMS compiler flag is
         turned on. */
         if (j==cnt) {
            stems[i].side1 = stem->offset;
            stems[i].side2 = stem->width + stem->offset;
            stems[i].align = at_centered;
            stems[i].rp1 = tzpnt++;
            stems[i].rp2 = tzpnt++;
            stems[i].cnt = 1;
            stems[i].range[0].from = stem->i1;
            stems[i].range[0].to = stem->i2;
            tzpnt+=2;
            i--;
         } else {
            AddRange(&stems[j], stem->i1, stem->i2);
         }
      }

      /* This happens if two stems are defined for the same
      hint replacement region and the same position, which
      is an Adobe Type 1 font error (broken font). The
      converter will recover by ignoring redundant stems. */
      if (i!=-1) {
         /* LogError(MSG_STEM3); */
         for (j=0; j<=i; j++) {
            stems[j].cnt = 0;
         }
      }
   }

   (*result) = stems;

   return (short)cnt;
}


/***
** Function: ResolveRelativeStem
**
** Description:
**   This function decides if two stems should
**   be aligned side1->side1, side2->side2, 
**   side1->side2 or side2->side1.
**   Stem are positition in relation to each
**   other for two reasons: They overlapp, they
**   are aligned side by side or they are
**   members of a stem3 hint.
***/
static void ResolveRelativeStem(TTStem *ref, TTStem *cur)
{
   /* SIDE1->SIDE2 */
   if (cur->side1==ref->side2) {
      cur->ref = ref->rp2;
      cur->align = at_relative1;


      /* SIDE1->SIDE2 */
   } else if (cur->side2==ref->side1) {
      cur->ref = ref->rp1;
      cur->align = at_relative2;


      /* SIDE1->SIDE1 */
   } else if ((cur->side1>ref->side1) &&
              ((cur->side1-ref->side1+10)>=
               (cur->side2-ref->side2))) {
      cur->ref = ref->rp1;
      cur->align = at_relative1;


      /* SIDE2->SIDE2 */
   } else {
      cur->ref = ref->rp2;
      cur->align = at_relative2;
   }
}



/***
** Function: ConvertVStems
**
** Description:
**   This function translate vstem and vstem3 to TT instructions.
***/
static errcode ConvertVStems(struct T1Metrics *t1m,
                             const Hints *hints,
                             const Outline *orgpaths,
                             const short *ttpnts,
                             UBYTE *pgm,
                             short *pc_ptr,
                             short *args,
                             short *pcd_ptr,
                             USHORT *twilight_ptr)
{
   Extremas extr[MAXEXTR];
   short xcnt = 0;
   errcode status = SUCCESS;
   short pc = *pc_ptr;
   short pcd = *pcd_ptr;
   TTStem *stems = NULL;
   short i;
   short cnt;


   /* Create the buckets. */
   if ((cnt = CreateStemBuckets(hints->vstems,
                                hints->vstems3,
                                &(stems)))==NOMEM) {
      status = NOMEM;
   } else {

      /* Update Max num of twilight points. */
      if ((cnt*TWILIGHTS_PER_STEM+TMP_TWILIGHTS) > (long)(*twilight_ptr))
         (*twilight_ptr) = (USHORT)(cnt * TWILIGHTS_PER_STEM + TMP_TWILIGHTS);

      if (cnt && stems) {

#if RELATIVESTEMS
         /* Do counter- and overlappning stem control? */
         for (i=0; i<cnt; i++) {
            short j;

            if (stems[i].align==at_centered) {
               funit prox = (funit)(ABS(MAX(100,
                                            stems[i].side2 -
                                            stems[i].side1)));
               funit prox2;
               prox2 = (funit)(prox/2);
               for (j=0; j<i; j++) {
                  if (stems[j].cnt &&
                      !((stems[i].side1 - (funit)prox > stems[j].side2) ||
                        (stems[i].side2 + (funit)prox < stems[j].side1)) &&
                      (ABS(stems[i].side2-stems[i].side1-
                           (stems[j].side2-stems[j].side1)) < prox2 ||
                       (short)(stems[i].side1 > stems[j].side2) !=
                       (short)(stems[i].side2 < stems[j].side1)))
                     break;
               }
               if (i!=j) {
                  if (stems[j].side1 < stems[i].side1)
                     stems[i].align = at_relative1;
                  else
                     stems[i].align = at_relative2;
                  stems[i].ref = j;
               }
            }
         }
#endif

         /** Vertical stem hints */
         EmitVerticalStems(pgm, &pc, args, &pcd);

         /* Handle sheared fonts by settin the projection
         vector to the italic angle. The TT instructions for
         the T1 hints can handle any projection vector. */
         if (t1m->fmatrix!=DEFAULTMATRIX && GetFontMatrix(t1m)[2]!=0) {
            Point pt;

            pt.x = 0; pt.y = 1000;
            TransAllPoints(t1m, &pt, (short)1, GetFontMatrix(t1m));
            SetProjection(pgm, &pc, args, &pcd, pt.x, pt.y);
         }

         /* Convert the buckets into instructions. */
         for (i=0; i<cnt; i++) {
            if (stems[i].cnt==0)
               continue;

            /* Resolve relative stems */
            if ((stems[i].align == at_relative1 ||
                 stems[i].align == at_relative2) &&
                stems[i].ref != UNDEF)
               ResolveRelativeStem(&stems[stems[i].ref], &stems[i]);

            /* Emit the instructions. */
            status = EmitVStem(pgm, &pc, args, &pcd, t1m,
                               ABS(stems[i].side2 - stems[i].side1),
                               TransRX(t1m, stems[i].side1),
                               TransRX(t1m, stems[i].side2),
                               Trans3X(t1m, stems[i].side1),
                               Trans3X(t1m, stems[i].side2),
                               (short)MIN(stems[i].rp1, stems[i].rp2),
                               stems[i].align,
                               stems[i].ref);

            if (status!=SUCCESS)
               break;
         }

         /* Collect extremas residing within and between stem sides. */
         if (SyntheticOblique(t1m)) {
            xcnt = CollectObliquePoints(orgpaths, ttpnts,
                                        stems, cnt, extr, PosX);
         } else {
            xcnt = CollectPoints(orgpaths, ttpnts,  stems, cnt,
                                 extr, PosX);
         }

         /* Do the 3% scaling */
         ScaleDown3(extr, xcnt, pgm, &pc, args, &pcd);

         /* Switch over to GLYPHZONE */
         pgm[pc++] = op_szp2;
         args[pcd++] = 1;

         /* Interpolate the local extremas. */
         EmitIP(extr, xcnt, pgm, &pc, args, &pcd, (short)SECONDPAIR);

         /* Interpolate/Shift the rest. */
         pgm[pc++] = op_iup | SUBOP_X;


         /* Free used resources */
         if (stems)
            Free(stems);
      }
   }

   *pc_ptr = pc;
   *pcd_ptr = pcd;

   return status;
}



/***
** Function: ResolveBlueHStem3
**
** Description:
**   This function attemts to resolves a conflict between
**   a hstem3 that has one of its stems in an alignment zone,
**   if there is such a conflict.
***/
static short ResolveBlueHStem3(TTStem *stems,
                               const short cnt,
                               const short k)
{
   short ref = stems[k].ref;
   TTStem tmp;
   short i;

   /* The parent stem of a hstem3 must be first in the 'stems' array,
   i.e. the order of the stems is important.  The children stems may
   therefore have to be swaped with the parten to enforce this condition. */

   if ((stems[k].align==at_relative1 ||
        stems[k].align==at_relative2) &&
       (stems[ref].align!=at_relative1 &&
        stems[ref].align!=at_relative2 &&
        stems[ref].align!=at_side1 &&
        stems[ref].align!=at_side2)) {
      tmp = stems[k];
      stems[k] = stems[ref];
      stems[k].align = at_relative1;
      stems[k].ref = ref;
      stems[ref] = tmp;
      for (i=0; i<cnt; i++) {
         if (i!=k && i!=ref &&
             (stems[i].align==at_relative1 ||
              stems[i].align==at_relative2) &&
             stems[i].ref == ref) {
            stems[i].ref = (short)k;
            if (i<k) {
               tmp = stems[k];
               stems[k] = stems[i];
               stems[i] = tmp;
            }
            break;
         }
      }

   } else {
      ref = k;
   }

   return ref;
}



/***
** Function: ConvertHStems
**
** Description:
**   This function converts hstem and hstem3 T1 instructions.
***/
static errcode ConvertHStems(struct T1Metrics *t1m,
                             const Hints *hints,
                             const Outline *orgpaths,
                             const short *ttpnts,
                             UBYTE *pgm,
                             short *pc_ptr,
                             short *args,
                             short *pcd_ptr,
                             USHORT *twilight_ptr)
{
   Extremas extr[MAXEXTR];
   short xcnt = 0;
   errcode status = SUCCESS;
   short pc = *pc_ptr;
   short pcd = *pcd_ptr;
   TTStem *stems = NULL;
   short i, k;
   short cnt;
   short cvt;

   /* Create the stem buckets. */
   cnt = CreateStemBuckets(hints->hstems, hints->hstems3, &(stems));
   if (cnt==NOMEM)
      return NOMEM;

   /* Update Max num of twilight points. */
   if ((USHORT)(cnt*TWILIGHTS_PER_STEM+TMP_TWILIGHTS) > (*twilight_ptr))
      (*twilight_ptr) = (USHORT)(cnt * TWILIGHTS_PER_STEM + TMP_TWILIGHTS);

#if RELATIVESTEMS
   /* Do counter- and overlappning stem control? */
   for (i=0; i<cnt; i++) {
      short j;

      if (stems[i].align==at_centered) {
         funit prox = (funit)(ABS(MAX(100, stems[i].side2 - stems[i].side1)));
         funit prox2;
         prox2 = (funit)(prox/2);
         for (j=0; j<i; j++) {
            if (stems[j].cnt &&
                !((stems[i].side1 - (funit)prox > stems[j].side2) ||
                  (stems[i].side2 + (funit)prox < stems[j].side1)) &&
                (ABS(stems[i].side2-stems[i].side1-
                     (stems[j].side2-stems[j].side1)) < prox2 ||
                 (short)(stems[i].side1 > stems[j].side2) !=
                 (short)(stems[i].side2 < stems[j].side1)))
               break;
         }
         if (i!=j) {
            if (stems[j].side1 < stems[i].side1)
               stems[i].align = at_relative1;
            else
               stems[i].align = at_relative2;
            stems[i].ref = j;
         }
      }
   }
#endif

   /* Do alignment control. */
   for (i=0; i<cnt; i++) {
      if ((cvt=GetBottomPos(GetBlues(t1m),
                            GetAlignment(t1m),
                            stems[i].side1))!=UNDEF) {
         k = ResolveBlueHStem3(stems, cnt, i);
         stems[k].ref = cvt;
         stems[k].align = at_side1;
      } else if ((cvt=GetTopPos(GetBlues(t1m),
                                GetAlignment(t1m),
                                stems[i].side2))!=UNDEF) {
         k = ResolveBlueHStem3(stems, cnt, i);
         stems[k].ref = cvt;
         stems[k].align = at_side2;
      } 
   }


   if (cnt && stems) {

      /** Horizontal stem hints */
      EmitHorizontalStems(pgm, &pc, args, &pcd);

      /* Convert the buckets into instructions. */
      for (i=0; i<cnt; i++) {

         if (stems[i].cnt==0)
            continue;

         /* Resolve relative stems */
         if ((stems[i].align == at_relative1 ||
              stems[i].align == at_relative2) &&
             stems[i].ref != UNDEF)
            ResolveRelativeStem(&stems[stems[i].ref], &stems[i]);

         /* Emit the instructions. */
         status = EmitHStem(pgm, &pc, args, &pcd, t1m,
                            stems[i].side2 - stems[i].side1,
                            TransY(t1m, stems[i].side1),
                            TransY(t1m, stems[i].side2),
                            (short)MIN(stems[i].rp1, stems[i].rp2),
                            stems[i].align,
                            stems[i].ref);

         if (status!=SUCCESS)
            break;
      }


      /* Interpolate extremas residing within and between stem sides. */
      xcnt = CollectPoints(orgpaths, ttpnts, stems, cnt, extr, PosY);

      /* Switch over to GLYPHZONE */
      pgm[pc++] = op_szp2;
      args[pcd++] = 1;

      /* Interpolate the local extremas. */
      EmitIP(extr, xcnt, pgm, &pc, args, &pcd, (short)0);

      /* Interpoalte/Shift the rest. */
      pgm[pc++] = op_iup | SUBOP_Y;

      /* Free used resources */
      if (stems)
         Free(stems);
   }

   *pcd_ptr = pcd;
   *pc_ptr = pc;

   return status;
}


/***** FUNCTIONS */

/***
** Function: GetRomanHints
**
** Description:
***/
const UBYTE *GetRomanHints(int *size)
{
   (*size) = sizeof(roman_hints);

   return roman_hints;
}


/***
** Function: GetSwissHints
**
** Description:
***/
const UBYTE *GetSwissHints(int *size)
{
   (*size) = sizeof(swiss_hints);

   return swiss_hints;
}


/***
** Function: MatchingFamily
**
** Description:
**   Locate the family alignment zone that is closest to
**   a given alignment zone.
***/
short MatchingFamily(const funit pos,
                     const funit *family,
                     const USHORT fcnt)
{
   funit min_dist = SHRT_MAX;
   short k = UNDEF;
   USHORT j;

   /* Look for the closest family blue. */
   for (j=0; j<fcnt; j+=2) {
      if (ABS(family[j] - pos) < min_dist) {
         k = (short)j;
         min_dist = ABS(family[j] - pos);
      }
   }

   return k;
}




/***
** Function: ConvertHints
**
** Description:
**   This functions converts hstem, hstem3, vstem, vstem3 and flex
**   hints, as well as doing diagonal control.
***/
errcode ConvertHints(struct T1Metrics *t1m,
                     const Hints *hints,
                     const Outline *orgpaths,
                     const Outline *paths,
                     const short *ttpnts,
                     UBYTE **gpgm,
                     USHORT *num,
                     USHORT *stack,
                     USHORT *twilight)
{
   errcode status = SUCCESS;
   UBYTE *pgm = NULL;
   short *args = NULL;
   short pc = 0;
   short pcd = 0;
   short cnt = 0;
   short narg = 0;
   short marg = 0;

   /* Access resources. */
   pgm=GetCodeStack(t1m);
   args=GetArgStack(t1m);


   /* Convert the vertical stem hints. */
   if (status==SUCCESS)
      status = ConvertVStems(t1m, hints, orgpaths, ttpnts,
                             pgm, &pc, args, &pcd, twilight);
   /* Convert the horizontal stem hints. */
   if (status==SUCCESS)
      status = ConvertHStems(t1m, hints, orgpaths, ttpnts,
                             pgm, &pc, args, &pcd, twilight);

   /* Convert flex hints. */
   if (status==SUCCESS)
      status = ConvertFlex(t1m, hints->flex, ttpnts,
                           pgm, &pc, args, &pcd, &marg);

   /********************
   * Adjust diagonals 
   * Do not reduce if dominant vertical stem width is more than 
   * 2.0 pels at 11PPEm and above. This occurs when:
   * 1) StdVW > 187 
   * 2) StdVW < 100 and ForceBold = TRUE
   **/
   if ((ForceBold(t1m)==1 && GetStdVW(t1m)>100 && GetStdVW(t1m)<187) ||
       (ForceBold(t1m)==0 && GetStdVW(t1m)<187))
      narg = ReduceDiagonals(paths, pgm, &pc, args, &pcd);
   if (narg>marg)
      marg = narg;

   if (pc>PGMSIZE) {
      SetError(status = TTSTACK);
   }
   if (pcd>ARGSIZE) {
      SetError(status = ARGSTACK);
   }

   /* Allocate the gpgm */
   (*gpgm) = NULL;
   (*num) = 0;
   (*stack) = 0;
   if (status==SUCCESS) {
      if (pc) {
         if (((*gpgm) = Malloc((USHORT)(pc+pcd*3)))==NULL) {
            SetError(status = NOMEM);
         } else {
            /* Assemble the arguments for the instructions */
            cnt = 0;
            AssembleArgs(args, pcd, (*gpgm), &cnt);
            memcpy(&(*gpgm)[cnt], pgm, (USHORT)pc);
            (*num) = (USHORT)(cnt + pc);
            (*stack) = (USHORT)(pcd + marg);
         }
      }
   }


   return status;
}



/***
** Function: BuildPreProgram
**
** Description:
**   This function builds the pre-program that will compute
**   the CVT and storage entries for the TT stem hint
**   instructions to work. 
***/
USHORT BuildPreProgram(const struct T1Metrics *t1m,
                       const WeightControl *weight,
                       Blues *blues,
                       AlignmentControl *align,
                       UBYTE **glob_prep,
                       const int prepsize,
                       USHORT *maxstack)
{
   UBYTE *prep = (*glob_prep);
   short *args = NULL;
   short ta, tp = 0;
   USHORT i, j;
   long shift;
   funit stdvw, stdhw;
   short cis;
   funit std_width;
   USHORT std_tres;
   funit min_dist;
   short k;
   short argsize = ARGSIZE;
   short psize = (short)prepsize;

   /* Allocate work space. */
   if ((args=Malloc(sizeof(args[0])*(USHORT)argsize))==NULL) {
      LogError(MSG_ERROR, MSG_NOMEM, NULL);
   } else {

      /* Copy the standard pre-program. */
      memcpy(prep, PrepProg, sizeof(PrepProg));
      tp = sizeof(PrepProg);
      (*maxstack) = 0;

      /**********
      * Compute Blue values.
      */

      prep[tp++] = op_pushb1; prep[tp++] = blues->blueScale;
      prep[tp++] = op_mppem;
      prep[tp++] = op_lt;
      prep[tp++] = op_if;
      prep[tp++] = op_pushb1;
      prep[tp++] = ONEPIXEL;
      prep[tp++] = op_smd;
      prep[tp++] = op_pushb1;
      prep[tp++] = TWILIGHT;
      prep[tp++] = op_szps;
      prep[tp++] = op_svcta | SUBOP_Y;
      prep[tp++] = op_rtg;


      /***********************/
      /*** ABOVE BlueScale ***/
      /***********************/

      /* Align the top zones. */
      for (i=0; i<blues->blue_cnt/2; i++) { 
         min_dist = SHRT_MAX;
         k = UNDEF;

         /*** Copy the FamilyBlue entries to the BlueValues if */
         /*** below the Family cut in size.         */
         if (blues->fblue_cnt>0) {

            /* Do the cut in on FamilyBlue/BlueValue. */
            k = MatchingFamily(blues->bluevalues[i*2],
                               blues->familyblues,
                               blues->fblue_cnt);
            min_dist = ABS(blues->bluevalues[i*2] - blues->familyblues[k]);

            /* Always FamilyBlue? */
            if (min_dist) { 
               cis = (short)(GetUPEM(t1m) / TransY(t1m, min_dist));
               tp = (short)FamilyCutIn(prep, (USHORT)tp, cis);
            }

            /* Allocate a cvt if this family has not been used before. */
            if (blues->family_cvt[k/2]==UNDEF_CVT) {
               blues->family_cvt[k/2] = align->cvt;
               align->cvt += 2;
            }

            ta = 2;
            CHECK_ARGSIZE(args, ta, align->top[i].cnt, argsize);
            for (j=0; j<align->top[i].cnt; j++) {
               args[ta++] = (short)align->top[i].pos[j].cvt;
            }
            CHECK_PREPSIZE(prep, tp, 2*ta+10, psize);
            tp = (short)CopyFamilyBlue(prep, tp, args, ta);
            if ((ta+2)>(int)(*maxstack))
               (*maxstack) = (USHORT)(ta+2);

            /* Set up the zone. */
            tp = (short)SetZone(prep, (USHORT)tp,
            (short)(blues->family_cvt[k/2]));

            if (min_dist>0)
               prep[tp++] = op_else;
         }


         /*** Set up the zone. */
         CHECK_PREPSIZE(prep, tp, STACKINC, psize);
         tp = (short)SetZone(prep, (USHORT)tp,
              (short)(align->top[i].blue_cvt));
         if (k!=UNDEF && min_dist) {
            prep[tp++] = op_eif;
         }


         /*** Round and enforce overshoot. */
         ta = 2;
         CHECK_ARGSIZE(args, ta, align->top[i].cnt, argsize);
         for (j=0; j<align->top[i].cnt; j++) {
            if ((align->top[i].pos[j].y -
                 blues->bluevalues[i*2])*F8D8 > blues->blueShift) {
               args[ta++] = (short)align->top[i].pos[j].cvt;
            }
         } 
         if (ta>2) {
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)AlignOvershoot(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)ta;
         }

         ta = 2;
         CHECK_ARGSIZE(args, ta, align->top[i].cnt, argsize);
         for (j=0; j<align->top[i].cnt; j++) {
            if ((align->top[i].pos[j].y -
                 blues->bluevalues[i*2])*F8D8 <= blues->blueShift) {
               args[ta++] = (short)align->top[i].pos[j].cvt;
            }
         } 
         if (ta>2) {
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)AlignFlat(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)(ta+2);
         }
      }



      /* Align the bottom zones. */
      for (i=0; i<blues->oblue_cnt/2; i++) { 
         min_dist = SHRT_MAX;
         k = UNDEF;

         /*** Copy the FamilyBlue entries to the BlueValues if */
         /*** below the Family cut in size.         */
         if (blues->foblue_cnt>0) {

            /* Do the cut in on FamilyBlue/BlueValue. */
            k = MatchingFamily(blues->otherblues[i*2],
                               blues->familyotherblues,
                               blues->foblue_cnt);
            min_dist = ABS(blues->otherblues[i*2] -
                           blues->familyotherblues[k]);

            /* Always FamilyBlue? */
            if (min_dist) { 
               cis = (short)(GetUPEM(t1m) / TransY(t1m, min_dist));
               tp = (short)FamilyCutIn(prep, (USHORT)tp, cis);
            }

            /* Allocate a cvt if this family has not been used before. */
            if (blues->familyother_cvt[k/2]==UNDEF_CVT) {
               blues->familyother_cvt[k/2] = align->cvt++;
            }

            ta = 2;
            CHECK_ARGSIZE(args, ta, align->bottom[i].cnt, argsize);
            for (j=0; j<align->bottom[i].cnt; j++) {
               args[ta++] = (short)align->bottom[i].pos[j].cvt;
            }
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)CopyFamilyBlue(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)ta;


            /* Set up the zone. */
            tp = (short)SetZone(prep, (USHORT)tp,
            (short)blues->familyother_cvt[k/2]);

            if (min_dist>0)
               prep[tp++] = op_else;
         }


         /*** Set up the zone. */
         tp = (short)SetZone(prep, (USHORT)tp,
              (short)align->bottom[i].blue_cvt);
         if (k!=UNDEF && min_dist) {
            prep[tp++] = op_eif;
         }


         /*** Round and enforce overshoot. */
         ta = 2;
         CHECK_ARGSIZE(args, ta, align->bottom[i].cnt, argsize);
         for (j=0; j<align->bottom[i].cnt; j++) {
            if ((align->bottom[i].pos[j].y -
                 blues->otherblues[i*2+1])*F8D8 > blues->blueShift) {
               args[ta++] = (short)align->bottom[i].pos[j].cvt;
            }
         } 
         if (ta>2) {
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)AlignOvershoot(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)ta;
         }

         ta = 2;
         CHECK_ARGSIZE(args, ta, align->bottom[i].cnt, argsize);
         for (j=0; j<align->bottom[i].cnt; j++) {
            if ((align->bottom[i].pos[j].y -
                 blues->otherblues[i*2+1])*F8D8 <= blues->blueShift) {
               args[ta++] = (short)align->bottom[i].pos[j].cvt;
            }
         } 
         if (ta>2) {
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)AlignFlat(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)(ta+2);
         }
      }




      /***********************/
      /*** BELOW BlueScale ***/
      /***********************/
      prep[tp++] = op_else;

      /*** Align the top zones. */

      for (i=0; i<blues->blue_cnt/2; i++) { 

         /* Initiate */
         min_dist = SHRT_MAX;
         k = UNDEF;

         /* switch between blues and family blues. */
         if (blues->fblue_cnt) {

            /* Look for the closest family blue. */
            k = MatchingFamily(blues->bluevalues[i*2],
                               blues->familyblues,
                               blues->fblue_cnt);
            min_dist = ABS(blues->bluevalues[i*2] - blues->familyblues[k]);

            /* Copy/Round the family overshoot position to the zone. */
            if (min_dist) {
               cis = (short)(GetUPEM(t1m) / TransY(t1m, (funit)min_dist));
               tp = (short)FamilyCutIn(prep, (USHORT)tp, cis);
               ta = 2;
               CHECK_ARGSIZE(args, ta, align->top[i].cnt*2, argsize);
               for (j=0; j<align->top[i].cnt; j++) {
                  args[ta++] = (short)(blues->family_cvt[k/2] + 1);
                  args[ta++] = (short)(align->top[i].pos[j].cvt);
               }
               CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
               tp = (short)CopyZone(prep, tp, args, ta);
               if (ta>(short)(*maxstack))
                  (*maxstack) = (USHORT)(ta+2);


               prep[tp++] = op_else;
            }
         }

         /* Copy/Round the blue overshoot position to the zone position. */
         ta = 2;
         CHECK_ARGSIZE(args, ta, align->top[i].cnt*2, argsize);
         for (j=0; j<align->top[i].cnt; j++) {
            args[ta++] = (short)(align->top[i].blue_cvt + 1);
            args[ta++] = (short)(align->top[i].pos[j].cvt);
         }
         CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
         tp = (short)CopyZone(prep, tp, args, ta);
         if (ta>(short)(*maxstack))
            (*maxstack) = (USHORT)ta;

         if (k!=UNDEF && min_dist>0)
            prep[tp++] = op_eif;
      }


      /*** Align the bottom zones. */
      for (i=0; i<blues->oblue_cnt/2; i++) { 

         /* Initiate. */
         min_dist = SHRT_MAX;
         k = UNDEF;

         /* switch between blues and family blues. */
         if (blues->foblue_cnt) {

            /* Look for the closest family blue. */
            k = MatchingFamily(blues->otherblues[i*2],
                               blues->familyotherblues,
                               blues->foblue_cnt);
            min_dist = ABS(blues->otherblues[i*2] -
                           blues->familyotherblues[k]);

            /* Copy/Round the family overshoot position to the zone. */
            if (min_dist) {
               cis = (short)(GetUPEM(t1m) / TransY(t1m, (funit)min_dist));
               tp = (short)FamilyCutIn(prep, (USHORT)tp, cis);
               ta = 2;
               CHECK_ARGSIZE(args, ta, align->bottom[i].cnt*2, argsize);
               for (j=0; j<align->bottom[i].cnt; j++) {
                  args[ta++] = (short)(blues->familyother_cvt[k/2]);
                  args[ta++] = (short)(align->bottom[i].pos[j].cvt);
               }
               CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
               tp = (short)CopyZone(prep, tp, args, ta);
               if (ta>(short)(*maxstack))
                  (*maxstack) = (USHORT)ta;

               prep[tp++] = op_else;
            }
         }

         /* Copy/Round the blue overshoot position to the zone position. */
         ta = 2;
         CHECK_ARGSIZE(args, ta, align->bottom[i].cnt*2, argsize);
         for (j=0; j<align->bottom[i].cnt; j++) {
            args[ta++] = (short)(align->bottom[i].blue_cvt);
            args[ta++] = (short)(align->bottom[i].pos[j].cvt);
         }
         CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
         tp = (short)CopyZone(prep, tp, args, ta);
         if (ta>(short)(*maxstack))
            (*maxstack) = (USHORT)ta;

         if (k!=UNDEF && min_dist>0)
            prep[tp++] = op_eif;
      }


      /* EIF[] MMPEM<BlueScale */
      prep[tp++] = op_eif;


      prep[tp++] = op_pushb1;
      prep[tp++] = 64;
      prep[tp++] = op_smd;


      /**************************************/
      /***      STEM WEIGHT CONTROL       ***/
      /**************************************/

      /****** ForceBold ***/
      if (ForceBold(t1m)) {
         prep[tp++] = op_pushb1+2;
         prep[tp++] = STDV_CVT;
         prep[tp++] = ONEPIXEL*3/4;
         prep[tp++] = STDV_CVT;
         prep[tp++] = op_rcvt;
         prep[tp++] = op_max;
         prep[tp++] = op_wcvtp;
      }


      /******
      * Compute width of horizontal stems. 
      */
      prep[tp++] = op_rtdg;
      prep[tp++] = op_svcta | SUBOP_Y;
      if ((std_width = GetStdHW(t1m))==0)
         std_width = GetDefStdHW(t1m);
      std_width = TransY(t1m, std_width);
      std_tres = (USHORT)(GetUPEM(t1m) * 2 / std_width);
      ta = 0;
      CHECK_ARGSIZE(args, ta, STEMSNAPARGS*weight->cnt_hw, argsize);
      for (i=0; i<weight->cnt_hw; i++) { 
         funit width = TransY(t1m, weight->hwidths[i].width);
         short snap = GetSnapH(t1m, weight->hwidths[i].width);
         USHORT storage = weight->hwidths[i].storage;
         USHORT snap_ci, std_ci;
         short snap_cvt;

         std_ci = CutInSize(width, std_width, std_tres, GetUPEM(t1m));
         if (snap!=UNDEF) {
            snap_ci = CutInSize(width, TransY(t1m, t1m->stemsnaph[snap]),
                                std_tres, GetUPEM(t1m));
            snap_cvt = (short)SNAPH_CVT(t1m, snap);
            ta = (short)SnapStemArgs(args, (USHORT)ta,
                 width, STDH_CVT, (USHORT)snap_cvt,
                 std_ci, snap_ci, storage);
         } else {
            ta = (short)StdStemArgs(args, (USHORT)ta, width, STDH_CVT,
                std_ci, storage);
         }
      } 
      if (ta+2>(short)(*maxstack))   /* Args + loopcnt + fun_num */
         (*maxstack) = (USHORT)(ta+2);
      CHECK_PREPSIZE(prep, tp, ta*2+2, psize);
      AssembleArgs(args, ta, prep, &tp);
      if (t1m->snaph_cnt)
         tp = (short)CreateSnapStems(prep, (USHORT)tp, (short)weight->cnt_hw);
      else
         tp = (short)CreateStdStems(prep, (USHORT)tp,  (short)weight->cnt_hw);


      /******
      * Compute width of vertical stems. 
      */
      prep[tp++] = op_svcta | SUBOP_X;
      if ((std_width = GetStdVW(t1m))==0)
         std_width = GetDefStdVW(t1m);
      std_width = TransX(t1m, std_width);
      std_tres = (USHORT)(GetUPEM(t1m) * 2 / std_width);
      ta = 0;
      CHECK_ARGSIZE(args, ta, STEMSNAPARGS*weight->cnt_vw, argsize);
      for (i=0; i<weight->cnt_vw; i++) { 
         funit width = TransX(t1m, weight->vwidths[i].width);
         short storage = (short)weight->vwidths[i].storage;
         short snap = GetSnapV(t1m, weight->vwidths[i].width);
         USHORT snap_ci, std_ci;
         short snap_cvt;

         std_ci = CutInSize(width, std_width, std_tres, GetUPEM(t1m));
         if (snap!=UNDEF) {
            snap_ci = CutInSize(width, TransX(t1m, t1m->stemsnapv[snap]),
                                std_tres, GetUPEM(t1m));
            snap_cvt = (short)SNAPV_CVT(snap);
            ta = (short)SnapStemArgs(args, (USHORT)ta,
                              width, STDV_CVT, (USHORT)snap_cvt,
                              std_ci, snap_ci, (USHORT)storage);
         } else {
            ta = (short)StdStemArgs(args, (USHORT)ta, width,
                STDV_CVT, std_ci, (USHORT)storage);
         }
      } 
      if (ta+2>(short)(*maxstack))
         (*maxstack) = (USHORT)(ta+2);
      CHECK_PREPSIZE(prep, tp, ta*2+2, psize);
      AssembleArgs(args, ta, prep, &tp);
      if (t1m->snapv_cnt)
         tp = (short)CreateSnapStems(prep, (USHORT)tp, (short)weight->cnt_vw);
      else
         tp = (short)CreateStdStems(prep, (USHORT)tp, (short)weight->cnt_vw);



      prep[tp++] = op_rtg;


      /******
      * Compute diagonal control parameters.
      */
      CHECK_PREPSIZE(prep, tp, STACKINC, psize);
      if ((stdvw = GetStdVW(t1m))==0)
         stdvw = GetDefStdVW(t1m);
      if ((stdhw = GetStdHW(t1m))==0)
         stdhw = GetDefStdHW(t1m);
      if (stdvw && stdhw) {
         cis = (short)(MAX((GetUPEM(t1m) + GetUPEM(t1m)/2) / std_width, 1));
#ifdef SYMETRICAL_REDUCTION
         shift = (long)GetUPEM(t1m);
#else
         shift = (long)GetUPEM(t1m)*(long)MIN(stdvw,stdhw)/
                 (long)MAX(stdvw, stdhw)/2L+(long)GetUPEM(t1m)/2L;
#endif
      } else if (stdvw || stdhw) {
         cis = (short)(1548 / MAX(stdvw, stdhw) + 1);
         shift = (long)GetUPEM(t1m)/2;
      } else {
         cis = 41;
         shift = GetUPEM(t1m)/4;
      }

      prep[tp++] = op_pushb1; prep[tp++] = STORAGE_DIAG;
      prep[tp++] = op_pushb1; prep[tp++] = STDV_CVT;
      prep[tp++] = op_rcvt;
      prep[tp++] = op_pushb1; prep[tp++] = (UBYTE)48;
      prep[tp++] = op_lt;
      prep[tp++] = op_if;

#ifdef SYMETRICAL_REDUCTION
      /* Compute the reduction. */
      shift = (short)(shift/(long)cis/4);
      prep[tp++] = op_npushw;
      prep[tp++] = 2;
      prep[tp++] = (UBYTE)TMPCVT;
      prep[tp++] = 0;
      prep[tp++] = HIBYTE(shift);
      prep[tp++] = LOBYTE(shift);
      prep[tp++] = op_wcvtf;
      prep[tp++] = op_pushb1; prep[tp++] = (UBYTE)TMPCVT;
      prep[tp++] = op_rcvt;
      prep[tp++] = op_pushb1; prep[tp++] = MIN_REDUCTION;
      prep[tp++] = op_add;
#else
      /* Compute the reduction. */
      shift = (short)(shift/(long)cis/2);
      prep[tp++] = op_npushw;
      prep[tp++] = 2;
      prep[tp++] = (UBYTE)TMPCVT;
      prep[tp++] = 0;
      prep[tp++] = HIBYTE(shift);
      prep[tp++] = LOBYTE(shift);
      prep[tp++] = op_wcvtf;
      prep[tp++] = op_pushb1; prep[tp++] = (UBYTE)TMPCVT;
      prep[tp++] = op_rcvt;
      prep[tp++] = op_pushb1; prep[tp++] = REDUCTION_C1;
      prep[tp++] = op_max;
#endif

      prep[tp++] = op_else;
      prep[tp++] = op_pushb1; prep[tp++] = 0;
      prep[tp++] = op_eif;

      prep[tp++] = op_pushb1 + 1;
      prep[tp++] = VERSION_1_5;
      prep[tp++] = VERSION_SELECTOR;
      prep[tp++] = op_getinfo;
      prep[tp++] = op_gt;
      prep[tp++] = op_if;
      prep[tp++] = op_pushb1;
      prep[tp++] = 8;
      prep[tp++] = op_mul;
      prep[tp++] = op_eif;

      prep[tp++] = op_ws;

      Free(args);
   } 

   (*glob_prep) = prep;                             
   return (USHORT)tp;
}




/***
** Function: GetFontProg
**
** Description:
**   Return the font program.
***/
const UBYTE *GetFontProg(void)
{
   return tt_GetFontProg();
}


/***
** Function: GetFontProgSize
**
** Description:
**   Return the size of the font program.
***/
const USHORT GetFontProgSize(void)
{
   return tt_GetFontProgSize();
}


/***
** Function: GetNumFuns
**
** Description:
**   Return the number of functions defined in
**   the font program.
***/
const USHORT GetNumFuns(void)
{
   return tt_GetNumFuns();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\makepfm.c ===
//---------------------------------------------------------------------------
// makepfm.c
//---------------------------------------------------------------------------
// Create PFM file for Rev-3 fonts
//---------------------------------------------------------------------------
//
//      Copyright 1990, 1991 -- Adobe Systems, Inc.
//      PostScript is a trademark of Adobe Systems, Inc.
//
// NOTICE:  All information contained herein or attendant hereto is, and
// remains, the property of Adobe Systems, Inc.  Many of the intellectual
// and technical concepts contained herein are proprietary to Adobe Systems,
// Inc. and may be covered by U.S. and Foreign Patents or Patents Pending or
// are protected as trade secrets.  Any dissemination of this information or
// reproduction of this material are strictly forbidden unless prior written
// permission is obtained from Adobe Systems, Inc.
//
//---------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <ctype.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "windows.h"
#pragma pack(1)
#include "makepfm.h"
#pragma pack(4)

#include "fvscodes.h"  // FVS_xxxxxx (font validation status) codes and macros.

#ifdef WIN30
  #define LPCSTR LPSTR
#endif


#define WINATM 1
#if !WINATM
LPSZ stringtable[] = {
"MAKEPFM utility version %s released on %s.\n",
"Copyright (C) 1989-91, Adobe Systems Inc. All Rights Reserved.\n\n",
"Usage: makepfm [options] AFMfile\n",
"  -h n   - set device to PCL (n=1 for 1 byte typeface, 2 for 2 byte).\n",
"  -p n   - integral point size - only for PCL.\n",
"  -c str - PCL symbol set (9U for WinAnsi for example) - only for PCL.\n",
"  -d     - set orientation to landscape - only for PCL.\n",
"  -e str - encoding file.\n",
"  -o str - output file.\n",
"  -i str - fontinfo file.\n",
"  -l str - optional log file - defaults to \"user.log\".\n",
"  -f str - take input parameters from file instead of command line.\n",
"  -w     - display warning messages.\n",
"  -s n   - force dfCharSet to n.\n",
"Unrecognized command-line option: '%s'\n",
"Unable to open: %s\n",
"Too many track kerning data. Ignoring after %d.\n",
"Unexpected end of file - expected: %s\n",
"Expected: %s - current line: %s\n",
"Parsing character metrics - current line: %s\n",
"Parsing %s.\n",
"Missing \"MSFamily\" value\n",
"Can't create: %s\n",
"Disk is full...\n",
"Memory allocation\n",
"encoding file",
"Creating font metrics ( %s )",
"Finished.\n",
NULL
};
#endif

AFM afm = { 0 };
static ETM etm;
static PFM pfm;
static PFMEXT pfmext;
static DRIVERINFO d;

typedef LPSZ GlyphName;

/* CHAR rgbBuffer[2048]; The file buffer */
CHAR rgbBuffer[8704] = "";   /* increased to handle an additional 512 bytes of width info */
static INT cbBuffer;         /* The number of bytes in the buffer */
static LPSZ pbBuffer;        /* Ptr to current location in buffer */
static CHAR rgbLine[160];    /* The current line of text being processed */
static LPSZ szLine;          /* Ptr to the current location in the line */
static BOOL fEOF = FALSE;
static BOOL fUnGetLine = FALSE;

/*----------------------------------------------------------------------------*/
static LPSZ notdef = "";

#define IBULLET     0x095   /* 87-1-15 sec (was 1) */
#define ISPACE      0x20
#define IWINSPACE   0xA0

static BOOL parseError;
static float sf;             /* scale factor for converting to display widths */

/* flags type of PFM to build POSTSCRIPT vs PCL */
INT devType = POSTSCRIPT;

PCLINFO pclinfo = { PORTRAIT, WINANSI_SET, epsymGENERIC8, 0, 0, 2, 0, NULL };
static SHORT fiCapHeight;
static GlyphName *glyphArray;
extern GlyphName *SetupGlyphArray(LPSZ) ;
INT charset = -1;
static BOOL forceVariablePitch = TRUE;

/* names, pointers, and handles for output, log and data files */
CHAR encfile[FNAMEMAX] = "";
CHAR outfile[FNAMEMAX] = "";
CHAR infofile[FNAMEMAX] = "";

static INT fhIn;

#define TK_STARTKERNDATA      2
#define TK_STARTKERNPAIRS     3
#define TK_KPX                4
#define TK_ENDKERNPAIRS       5
#define TK_ENDKERNDATA        6
#define TK_FONTNAME           7
#define TK_WEIGHT             8
#define TK_ITALICANGLE        9
#define TK_ISFIXEDPITCH       10
#define TK_UNDERLINEPOSITION  11
#define TK_UNDERLINETHICKNESS 12
#define TK_FONTBBOX           13
#define TK_CAPHEIGHT          14
#define TK_XHEIGHT            15
#define TK_DESCENDER          16
#define TK_ASCENDER           17
#define TK_STARTCHARMETRICS   18
#define TK_ENDCHARMETRICS     19
#define TK_ENDFONTMETRICS     20
#define TK_STARTFONTMETRICS   21
#define TK_STARTTRACKKERN     22
#define TK_TRACKKERN          23
#define TK_ENDTRACKKERN       24

static KEY afmKeys[] = {
    "FontBBox",           TK_FONTBBOX,
    "StartFontMetrics",   TK_STARTFONTMETRICS,
    "FontName",           TK_FONTNAME,
    "Weight",             TK_WEIGHT,
    "ItalicAngle",        TK_ITALICANGLE,
    "IsFixedPitch",       TK_ISFIXEDPITCH,
    "UnderlinePosition",  TK_UNDERLINEPOSITION,
    "UnderlineThickness", TK_UNDERLINETHICKNESS,
    "CapHeight",          TK_CAPHEIGHT,
    "XHeight",            TK_XHEIGHT,
    "Descender",          TK_DESCENDER,
    "Ascender",           TK_ASCENDER,
    "StartCharMetrics",   TK_STARTCHARMETRICS,
    "EndCharMetrics",     TK_ENDCHARMETRICS,
    "StartKernData",      TK_STARTKERNDATA,
    "StartKernPairs",     TK_STARTKERNPAIRS,
    "KPX",                TK_KPX,
    "EndKernPairs",       TK_ENDKERNPAIRS,
    "EndKernData",        TK_ENDKERNDATA,
    "EndFontMetrics",     TK_ENDFONTMETRICS,
    "StartTrackKern",     TK_STARTTRACKKERN,
    "TrackKern",          TK_TRACKKERN,
    "EndTrackKern",       TK_ENDTRACKKERN,
    NULL,                 0
    };

#define CVTTOSCR(i)  (INT)(((float)(i) * sf) + 0.5)
#define DRIVERINFO_VERSION      (1)

/*----------------------------------------------------------------------------*/
VOID KxSort(KX *, KX *);
INT GetCharCode(LPSZ,  GlyphName *);
VOID ParseKernPairs(INT);
VOID ParseTrackKern(INT);
VOID ParseKernData(INT);
VOID ParseFontName(VOID);
VOID ParseMSFields(VOID);
VOID ParseCharMetrics(BOOL);
VOID ParseCharBox(BBOX *);
LPSZ ParseCharName(VOID);
INT ParseCharWidth(VOID);
INT ParseCharCode(VOID);
VOID ParseBoundingBox(BOOL);
VOID ParsePitchType(VOID);
VOID InitAfm(VOID);
short _MakePfm(VOID);
BOOL ReadFontInfo(INT);
VOID GetCharMetrics(INT, CM *);
VOID SetCharMetrics(INT, CM *);
VOID GetSmallCM(INT, CM *);
VOID SetFractionMetrics(INT, INT, INT, INT);
VOID FixCharWidths(VOID);
VOID SetAfm(VOID);
VOID SetAvgWidth(VOID);
VOID SetMaxWidth(VOID);

/*----------------------------------------------------------------------------*/
VOID ResetBuffer(VOID);
VOID PutByte(SHORT);
VOID PutRgb(LPSZ, INT);
VOID PutWord(SHORT);
VOID PutLong(long);
VOID SetDf(INT);
VOID PutString(LPSZ);
VOID PutDeviceName(LPSZ);
VOID PutFaceName(VOID);
BOOL MakeDf(BOOL, SHORT, LPSZ);
VOID PutPairKernTable(SHORT);
VOID PutTrackKernTable(SHORT);
VOID PutExtentOrWidthTable(INT);
BOOL WritePfm(LPSZ);

/*----------------------------------------------------------------------------*/
VOID SetDriverInfo(VOID);
VOID PutDriverInfo(INT);
LPSZ GetEscapeSequence(VOID);

/*----------------------------------------------------------------------------*/
VOID AfmToEtm(BOOL);
VOID PutEtm(BOOL);

/*----------------------------------------------------------------------------*/
VOID StartParse(VOID);
BOOL szIsEqual(LPSZ, LPSZ);
VOID szMove(LPSZ, LPSZ, INT);
BOOL GetBuffer(INT);
VOID UnGetLine(VOID);
BOOL GetLine(INT);
BOOL _GetLine(INT);
VOID EatWhite(VOID);
VOID GetWord(LPSZ, INT);
BOOL GetString(LPSZ, INT);
BOOL GetNumber(SHORT *);
BOOL GetFloat(float *, SHORT *);
INT MapToken(LPSZ, KEY *);
INT GetToken(INT, KEY *);

/*----------------------------------------------------------------------------*/
GlyphName *AllocateGlyphArray(INT);
VOID PutGlyphName(GlyphName *, INT, LPSZ);

/*----------------------------------------------------------------------------*/
#if DEBUG_MODE
VOID DumpAfm(VOID);
VOID DumpKernPairs(VOID);
VOID DumpKernTracks(VOID);
VOID DumpCharMetrics(VOID);
VOID DumpPfmHeader(VOID);
VOID DumpCharWidths(VOID);
VOID DumpPfmExtension(VOID);
VOID DumpDriverInfo(VOID);
VOID DumpEtm(VOID);
#endif

/*----------------------------------------------------------------------------*/
extern INT  OpenParseFile(LPSZ);                 /* main.c */
extern INT  OpenTargetFile(LPSZ);
// extern VOID cdecl PostWarning(LPCSTR,  ...);
// extern VOID cdecl PostError(LPCSTR, ...);
extern LPVOID AllocateMem(UINT);
extern VOID FreeAllMem(VOID);
extern VOID WriteDots(VOID);
extern GlyphName *SetupGlyphArray(LPSZ);
#if !WINATM
extern GlyphName *NewGlyphArray(INT);
extern LPSZ ReadLine(FILE *, LPSZ, INT);
extern LPSZ FirstTokenOnLine(FILE *, LPSZ, INT);
extern LPSZ Token(INT);
extern VOID ParseError(VOID);
#endif

/*----------------------------------------------------------------------------*/
/***************************************************************
* Name: KxSort()
* Action: Sort the pair kerning data using the quicksort algorithm.
******************************************************************/
VOID KxSort(pkx1, pkx2)
KX *pkx1;
KX *pkx2;
{
  static WORD iPivot;
  INT iKernAmount;
  KX *pkx1T;
  KX *pkx2T;

  if (pkx1>=pkx2) return;

  iPivot = pkx1->iKey;;
  iKernAmount = pkx1->iKernAmount;
  pkx1T = pkx1;
  pkx2T = pkx2;

  while (pkx1T < pkx2T)
    {
    while (pkx1T < pkx2T)
      {
      if (pkx2T->iKey < iPivot)
        {
        pkx1T->iKey = pkx2T->iKey;
        pkx1T->iKernAmount = pkx2T->iKernAmount;
        ++pkx1T;
        break;
        }
      else
        --pkx2T;
      }
    while (pkx1T < pkx2T)
      {
      if (pkx1T->iKey > iPivot)
        {
        pkx2T->iKey = pkx1T->iKey;
        pkx2T->iKernAmount = pkx1T->iKernAmount;
        --pkx2T;
        break;
        }
      else
        ++pkx1T;
      }
    }
  pkx2T->iKey = iPivot;
  pkx2T->iKernAmount = (SHORT)iKernAmount;
  ++pkx2T;
  if ((pkx1T - pkx1) < (pkx2 - pkx2T))
    {
    KxSort(pkx1, pkx1T);
    KxSort(pkx2T, pkx2);
    }
  else
    {
    KxSort(pkx2T, pkx2);
    KxSort(pkx1, pkx1T);
    }
}

/******************************************************************
* Name: GetCharCode(glyphname, glypharray)
* Action: Lookup glyphname in glypharray & return index.
********************************************************************/
INT GetCharCode(glyphname, glypharray)

LPSZ glyphname;
GlyphName *glypharray;
{
  register INT i;

  if ( STRCMP(glyphname, "") != 0 )
      for(i=0; glypharray[i]!=NULL; i++)
          if ( STRCMP(glypharray[i], glyphname) == 0 ) return(i);
  /* printf("GetCharCode: Undefined character = %s\n", glyphname); */
  return(-1);
}

/******************************************************************
* Name: ParseKernPairs()
* Action: Parse the pairwise kerning data.
********************************************************************/
VOID ParseKernPairs(pcl)
INT pcl;
{
  UINT iCh1, iCh2;
  KP *pkp;
  INT iToken;
  WORD cPairs, i;
  SHORT iKernAmount;
  CHAR szWord[80];

  GetNumber(&cPairs);
  if( cPairs == 0 )
      return;

  pkp = &afm.kp;
  pkp->cPairs = 0;
  pkp->rgPairs = (PKX) AllocateMem( (UINT) (sizeof(KX) * cPairs) );
  if( pkp->rgPairs == NULL ) {
      ; // PostError(str(MSG_PFM_BAD_MALLOC));
      parseError = TRUE;
      return;
      }

  for (i = 0; i < cPairs; ++i) {
      if( !GetLine(fhIn) ) break;
      if( GetToken(fhIn, afmKeys) != TK_KPX ) {
          UnGetLine();
          break;
          }
      GetWord(szWord, sizeof(szWord));
      iCh1 = (UINT)GetCharCode(szWord, glyphArray);
      GetWord(szWord, sizeof(szWord));
      iCh2 = (UINT)GetCharCode(szWord, glyphArray);
      GetNumber(&iKernAmount);

      /* no kern pairs for unencoded characters or miniscule kern amounts */
      if( (iCh1 == -1 || iCh2 == -1) || (pcl && CVTTOSCR(iKernAmount) == 0) )
          continue;

      pkp->rgPairs[pkp->cPairs].iKey = iCh2 << 8 | iCh1;
      pkp->rgPairs[pkp->cPairs++].iKernAmount =
                                       (pcl) ? CVTTOSCR(iKernAmount) : iKernAmount;
      }

  GetLine(fhIn);
  iToken = GetToken(fhIn, afmKeys);
  if( iToken == TK_EOF )
      ; // PostWarning(str(MSG_PFM_BAD_EOF), "EndKernPairs");
  else if( iToken != TK_ENDKERNPAIRS ) {
      ; // PostError(str(MSG_PFM_BAD_TOKEN), "EndKernPairs", rgbLine);
      parseError = TRUE;
      }
  KxSort(&afm.kp.rgPairs[0], &afm.kp.rgPairs[afm.kp.cPairs - 1]);
}

/******************************************************************
* Name: ParseTrackKern()
* Action: Parse the track kerning data.
********************************************************************/
VOID ParseTrackKern(pcl)
INT pcl;
{
  float one;
  INT i;
  KT *pkt;
  INT iToken;

  one = (float) 1;
  pkt = &afm.kt;
  GetNumber(&pkt->cTracks);
  if( pkt->cTracks > MAXTRACKS) ; // PostWarning(str(MSG_PFM_BAD_TRACK), MAXTRACKS);

  for (i = 0; i < pkt->cTracks; ++i) {
    if( !GetLine(fhIn) ) {
        ; // PostError(str(MSG_PFM_BAD_EOF), "EndTrackKern");
        parseError = TRUE;
        return;
        }
    if( GetToken(fhIn, afmKeys) != TK_TRACKKERN ) {
        ; // PostError(str(MSG_PFM_BAD_TOKEN), "EndTrackKern", rgbLine);
        parseError = TRUE;
        return;
        }
    if( i < MAXTRACKS) {
        GetNumber(&pkt->rgTracks[i].iDegree);
        GetFloat(&one, &pkt->rgTracks[i].iPtMin);
        (pcl) ? GetFloat(&sf, &pkt->rgTracks[i].iKernMin) :
                GetFloat(&one, &pkt->rgTracks[i].iKernMin);
        GetFloat(&one, &pkt->rgTracks[i].iPtMax);
        (pcl) ? GetFloat(&sf, &pkt->rgTracks[i].iKernMax) :
                GetFloat(&one, &pkt->rgTracks[i].iKernMax);
        }
    }

  GetLine(fhIn);
  iToken = GetToken(fhIn, afmKeys);
  if( iToken == TK_EOF ) {
    ; // PostError(str(MSG_PFM_BAD_EOF), "EndTrackKern");
    parseError = TRUE;
    }
  else if( iToken != TK_ENDTRACKKERN ) {
    ; // PostError(str(MSG_PFM_BAD_TOKEN), "EndTrackKern", rgbLine);
    parseError = TRUE;
    }
}

/********************************************************
* Name: ParseKernData()
* Action: Start processing the kerning data.
*************************************************************/
VOID ParseKernData(pcl)
INT pcl;
{
  INT iToken;
  do {
    if ( !GetLine(fhIn) ) {
        ; // PostError(str(MSG_PFM_BAD_EOF), "EndKernData");
        parseError = TRUE;
        }
    iToken = GetToken(fhIn, afmKeys);
    if( iToken == TK_STARTKERNPAIRS ) ParseKernPairs(pcl);
    else if( iToken == TK_STARTTRACKKERN ) ParseTrackKern(pcl);
    } while( iToken != TK_ENDKERNDATA);
}

/***********************************************************
* Name: ParseFontName()
* Action: Move the font name from the input buffer into the afm
*    structure.
**************************************************************/
VOID ParseFontName()
{
  EatWhite();
  szMove(afm.szFont, szLine, sizeof(afm.szFont));
}

/**************************************************************
* Name: ParseCharMetrics()
* Action: Parse the character metrics entry in the input file
*   and set the width and bounding box in the afm structure.
*****************************************************************/
VOID ParseCharMetrics(pcl)
BOOL pcl;
{
  SHORT cChars;
  INT i, iChar, iWidth;
  BBOX rcChar;

  if (afm.iFamily == FF_DECORATIVE)
      glyphArray = AllocateGlyphArray(255);
  else
      glyphArray = SetupGlyphArray(encfile);
  if( glyphArray == NULL ) {
      parseError = TRUE;
      return;
      }
  GetNumber(&cChars);
  for (i = 0; i < cChars; ++i) {
      if( !GetLine(fhIn) ) {
          ; // PostError(str(MSG_PFM_BAD_EOF), "EndCharMetrics");
          parseError = TRUE;
          return;
          }
      iChar = ParseCharCode();
      iWidth = ParseCharWidth();
      if( afm.iFamily == FF_DECORATIVE ) {
          if( iChar < 0 || iChar > 255 ) continue;
          PutGlyphName(glyphArray, iChar, ParseCharName());
      } else {
          iChar = GetCharCode(ParseCharName(), glyphArray);
          if( iChar == -1 ) continue;
          }
      ParseCharBox(&rcChar);
      if( parseError == TRUE ) return;

      afm.rgcm[iChar].iWidth = (pcl) ? CVTTOSCR(iWidth) : iWidth;
      afm.rgcm[iChar].rc.top = (pcl) ? CVTTOSCR(rcChar.top) : rcChar.top;
      afm.rgcm[iChar].rc.left = (pcl) ? CVTTOSCR(rcChar.left) : rcChar.left;
      afm.rgcm[iChar].rc.right = (pcl) ? CVTTOSCR(rcChar.right) : rcChar.right;
      afm.rgcm[iChar].rc.bottom = (pcl) ? CVTTOSCR(rcChar.bottom) : rcChar.bottom;
      }
  GetLine(fhIn);
  if (GetToken(fhIn, afmKeys)!=TK_ENDCHARMETRICS) {
      ; // PostError(str(MSG_PFM_BAD_TOKEN), "EndCharMetrics", rgbLine);
      parseError = TRUE;
      }
}

/***************************************************************
* Name: ParseCharBox()
* Action: Parse the character's bounding box and return its
*   dimensions in the destination rectangle.
*****************************************************************/
VOID ParseCharBox(prc)
BBOX *prc;   /* Pointer to the destination rectangle */
{
  CHAR szWord[16];

  GetWord(szWord, sizeof(szWord));
  if( szIsEqual("B", szWord) ) {
      GetNumber(&prc->left);
      GetNumber(&prc->bottom);
      GetNumber(&prc->right);
      GetNumber(&prc->top);
      }
  else {
      ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
      parseError = TRUE;
      return;
      }
  EatWhite();
  if (*szLine++ != ';') {
      ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
      parseError = TRUE;
      }
}

/*********************************************************
* Name: ParseCharName()
* Action: Parse a character's name
************************************************************/
LPSZ ParseCharName()
{
  static CHAR szWord[40];

  EatWhite();
  GetWord(szWord, sizeof(szWord));
  if (szIsEqual("N", szWord))
    GetWord(szWord, sizeof(szWord));
  else {
    ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
    parseError = TRUE;
    return(szWord);
    }
  EatWhite();
  if (*szLine++ != ';') {
    ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
    parseError = TRUE;
    }
  return(szWord);
}

/***********************************************************
* Name: ParseCharWidth()
* Action: Parse a character's width and return its numeric
*   value.
*************************************************************/
INT ParseCharWidth()
{
  SHORT iWidth;
  CHAR szWord[16];


  GetWord(szWord, sizeof(szWord));
  if (szIsEqual("WX", szWord)) {
    GetNumber(&iWidth);
    if (iWidth==0) ; // PostWarning(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
    EatWhite();
    if (*szLine++ != ';') {
        ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
        parseError = TRUE;
        }
    }
  else {
    ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
    parseError = TRUE;
    }
  return(iWidth);
}

/*****************************************************************
* Name: ParseCharCode()
* Action: Parse the ascii form of a character's code point and
*   return its numeric value.
******************************************************************/
INT ParseCharCode()
{
  SHORT iChar;
  CHAR szWord[16];

  iChar = 0;
  GetWord(szWord, sizeof(szWord));
  if (szIsEqual("C", szWord)) {
    GetNumber(&iChar);
    if (iChar==0) {
        ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
        parseError = TRUE;
        return(0);
        }
    EatWhite();
    if (*szLine++ != ';') {
        ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
        parseError = TRUE;
        }
    }
  return(iChar);
}

/****************************************************************
* Name: ParseBounding Box()
* Action: Parse a character's bounding box and return its size in
*   the afm structure.
*******************************************************************/
VOID ParseBoundingBox(pcl)
BOOL pcl;
{
  SHORT i;

  /*  8-26-91 yh  Note that values in rcBBox are not scaled for PCL either */
  GetNumber(&i);
//  afm.rcBBox.left = (pcl) ? CVTTOSCR(i) : i;
  afm.rcBBox.left = i;
  GetNumber(&i);
//  afm.rcBBox.bottom = (pcl) ? CVTTOSCR(i) : i;
  afm.rcBBox.bottom = i;
  GetNumber(&i);
//  afm.rcBBox.right = (pcl) ? CVTTOSCR(i) : i;
  afm.rcBBox.right = i;
  GetNumber(&i);
//  afm.rcBBox.top = (pcl) ? CVTTOSCR(i) : i;
  afm.rcBBox.top = i;
}

/************************************************************
* Name: ParsePitchType()
*
* Action: Parse the pitch type and set the variable pitch
*      flag in the afm structure.
*         Always set the pitch to be variable pitch for
*         our fonts in Windows
*
**********************************************************/
VOID ParsePitchType()
{
  CHAR szWord[16];

  EatWhite();
  GetWord(szWord, sizeof(szWord));
  if( !STRCMP(_strlwr(szWord), "true" ) ) {
      afm.fWasVariablePitch = FALSE;
      afm.fVariablePitch = forceVariablePitch;
      }
//  afm.fVariablePitch = TRUE;
}

/***********************************************************
* Name: InitAfm()
* Action: Initialize the afm structure.
************************************************************/
VOID InitAfm()
{
  register int i;

  afm.iFirstChar = 0x20;
  afm.iLastChar = 0x0ff;
  afm.iAvgWidth = 0;
  afm.iMaxWidth = 0;
  afm.iItalicAngle = 0;
  afm.iFamily = 0;
  afm.ulOffset = 0;
  afm.ulThick = 0;
  afm.iAscent = 0;
  afm.iDescent = 0;
  afm.fVariablePitch = TRUE;
  afm.fWasVariablePitch = TRUE;
  afm.szFont[0] = 0;
  afm.szFace[0] = 0;
  afm.iWeight = 400;
  afm.kp.cPairs = 0;
  afm.kt.cTracks = 0;
  afm.rcBBox.left = 0;
  afm.rcBBox.bottom = 0;
  afm.rcBBox.right = 0;
  afm.rcBBox.top = 0;

  for(i=0; i<256; i++ ) {
      afm.rgcm[i].rc.left = 0;
      afm.rgcm[i].rc.bottom = 0;
      afm.rgcm[i].rc.right = 0;
      afm.rgcm[i].rc.top = 0;
      afm.rgcm[i].iWidth = 0;
      }
}

/*----------------------------------------------------------------------------
** Returns: 16-bit encoded value indicating error and type of file where
**          error occurred.  (see fvscodes.h) for definitions.
**          The following table lists the "status" portion of the codes
**          returned.
**
**           FVS_SUCCESS
**           FVS_INVALID_FONTFILE
**           FVS_FILE_OPEN_ERR
**           FVS_FILE_BUILD_ERR
*/
short _MakePfm()
{
  INT hfile;
  SHORT i;
  float ten = (float) 10;
  BOOL fPrint = FALSE, fEndOfInput = FALSE, fStartInput = FALSE;
  BOOL bRes;

  // if ( devType == PCL ) sf = ((float)afm.iPtSize / 1000.0) * (300.0 / 72.0);
  InitAfm();

  if( (hfile = OpenParseFile(infofile)) == -1 ) {
      ; // PostError(str(MSG_PFM_BAD_FOPEN), infofile);
      return(FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_INF));
      }
  if( !ReadFontInfo(hfile) ) {
      CLOSE(hfile);
      ; // PostError(str(MSG_PFM_BAD_PARSE), infofile);
      return(FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_INF));
      }
  CLOSE(hfile);

  if( (fhIn = OpenParseFile(afm.szFile)) == -1 ) {
      ; // PostError(str(MSG_PFM_BAD_FOPEN), afm.szFile);
      return(FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_AFM));
      }
  parseError = FALSE;
  while (!fEndOfInput) {
      if( !GetLine(fhIn) ) break;
      switch( GetToken(fhIn, afmKeys) ) {
          case TK_STARTFONTMETRICS:
              fStartInput = TRUE;
              break;
          case TK_STARTKERNDATA:
              ParseKernData(devType == PCL);
              break;
          case TK_FONTNAME:
              ParseFontName();
              break;
          case TK_WEIGHT:
              break;
          case TK_ITALICANGLE:
              GetFloat(&ten, &afm.iItalicAngle);
              break;
          case TK_ISFIXEDPITCH:
              ParsePitchType();
              break;
          case TK_UNDERLINEPOSITION:
              GetNumber(&i);
              afm.ulOffset = (devType==POSTSCRIPT) ? abs(i) : CVTTOSCR(abs(i));
              break;
          case TK_UNDERLINETHICKNESS:
              GetNumber(&i);
              afm.ulThick = (devType == POSTSCRIPT) ? i : CVTTOSCR(i);
              break;
          case TK_FONTBBOX:
              ParseBoundingBox(devType == PCL);
              break;
          case TK_CAPHEIGHT:
              GetNumber(&i);
              if( fiCapHeight == 0 ) fiCapHeight = i;
              break;
          case TK_XHEIGHT:
              break;
          case TK_DESCENDER:
              GetNumber(&i);
              afm.iDescent = (devType == POSTSCRIPT) ? i : CVTTOSCR(i);
              break;
          case TK_ASCENDER:
              GetNumber(&i);
              if (i < 667) i = 667;
              afm.iAscent = (devType == POSTSCRIPT) ? i : CVTTOSCR(i);
              break;
          case TK_STARTCHARMETRICS:
              if (afm.iFamily == 0) {
                  ; // PostError(str(MSG_PFM_MISSING_MSFAMILY));
                  CLOSE(fhIn);
                  return(FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_AFM));
                  }
              ParseCharMetrics(devType == PCL);
              break;
          case TK_ENDFONTMETRICS:
              fEndOfInput = TRUE;
              break;
          }
      if( parseError ) {
          CLOSE(fhIn);
          return(FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_AFM));
          }
      }
  CLOSE(fhIn);
  if( !fStartInput ) {
      ; // PostError(str(MSG_PFM_BAD_EOF), "StartFontMetrics");
      return(FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_AFM));
      }
  FixCharWidths();
  SetAfm();

#if DEBUG_MODE
  DumpAfm();
  DumpKernPairs();
  DumpKernTracks();
  DumpCharMetrics();
#endif
  bRes = MakeDf(FALSE, (SHORT)devType, outfile);
  FreeAllMem();
  return(bRes ? FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK) :
                FVS_MAKE_CODE(FVS_FILE_BUILD_ERR, FVS_FILE_PFM));
}

/*----------------------------------------------------------------------------*/
BOOL ReadFontInfo(hfile)
INT hfile;
{
  INT iToken;
  CHAR szTemp[6];
  BOOL found[LAST_FI_TOKEN+1];
  static KEY infKeys[] = {
      "MSMenuName",      TK_MSMENUNAME,
      "VPStyle",         TK_VPSTYLE,
      "Pi",              TK_PI,
      "Serif",           TK_SERIF,
      "PCLStyle",        TK_PCLSTYLE,
      "PCLStrokeWeight", TK_PCLSTROKEWEIGHT,
      "PCLTypefaceID",   TK_PCLTYPEFACEID,
      "CapHeight",       TK_INF_CAPHEIGHT,
      NULL, 0
      };

  fiCapHeight = 0;
  for(iToken=0; iToken<=LAST_FI_TOKEN; iToken++) found[iToken] = FALSE;
  while( GetLine(hfile) ) {
      iToken = GetToken(hfile,infKeys);
      found[iToken] = TRUE;
      switch(iToken) {
          case TK_MSMENUNAME:
              if( !GetString(afm.szFace, sizeof(afm.szFace)) ) return(FALSE);
              break;
          case TK_VPSTYLE:
              if( !GetString(szTemp, sizeof(szTemp)) ) return(FALSE);
              switch( toupper(szTemp[0]) ) {
                  case 'N':
                  case 'I': afm.iWeight = FW_NORMAL; break;
                  case 'B':
                  case 'T': afm.iWeight = FW_BOLD; break;
                  default:  return(FALSE); break;
                  }
              break;
          case TK_PI:
              GetWord(szTemp, sizeof(szTemp));
              if( !STRCMP(_strupr(szTemp), "TRUE") )
                  afm.iFamily = FF_DECORATIVE;
              else if( STRCMP(szTemp, "FALSE") ) return(FALSE);
              break;
          case TK_SERIF:
              GetWord(szTemp, sizeof(szTemp));
              if( !STRCMP(_strupr(szTemp), "TRUE") ) {
                  if( afm.iFamily != FF_DECORATIVE ) afm.iFamily = FF_ROMAN;
                  }
              else if( !STRCMP(szTemp, "FALSE") )  {
                  if( afm.iFamily != FF_DECORATIVE ) afm.iFamily = FF_SWISS;
                  }
              else return(FALSE);
              break;
          case TK_INF_CAPHEIGHT:
              GetNumber(&fiCapHeight);
              break;
          case TK_PCLSTYLE:
              GetNumber(&pclinfo.style);
              break;
          case TK_PCLSTROKEWEIGHT:
              GetNumber(&pclinfo.strokeWeight);
              break;
          case TK_PCLTYPEFACEID:
              GetNumber((SHORT *)&pclinfo.typeface);
              if( pclinfo.typefaceLen == 1 ) pclinfo.typeface &= 0xFF;
              break;
          }
      }
  if( found[TK_MSMENUNAME] == FALSE ||
      found[TK_VPSTYLE] == FALSE ||
      found[TK_PI] == FALSE ||
      found[TK_SERIF] == FALSE ||
      found[TK_INF_CAPHEIGHT] == FALSE ) return(FALSE);
  if ( devType == PCL )
      if( found[TK_PCLSTYLE] == FALSE ||
          found[TK_PCLSTROKEWEIGHT] == FALSE ||
          found[TK_PCLTYPEFACEID] == FALSE ) return(FALSE);
  return(TRUE);
}

#if DEBUG_MODE
/*----------------------------------------------------------------------------*/
VOID DumpAfm()
{
  printf("\nAFM HEADER\n");
  printf("afm.iFirstChar: %d\n", afm.iFirstChar);
  printf("afm.iLastChar: %d\n", afm.iLastChar);
  printf("afm.iPtSize: %d\n", afm.iPtSize);
  printf("afm.iAvgWidth: %d\n", afm.iAvgWidth);
  printf("afm.iMaxWidth: %d\n", afm.iMaxWidth);
  printf("afm.iItalicAngle: %d\n", afm.iItalicAngle);
  printf("afm.iFamily: %d\n", afm.iFamily);
  printf("afm.ulOffset: %d\n", afm.ulOffset);
  printf("afm.ulThick: %d\n", afm.ulThick);
  printf("afm.iAscent: %d\n", afm.iAscent);
  printf("afm.iDescent: %d\n", afm.iDescent);
  printf("afm.fVariablePitch: %d\n", afm.fVariablePitch);
  printf("afm.szFile: %s\n", afm.szFile);
  printf("afm.szFont: %s\n", afm.szFont);
  printf("afm.szFace: %s\n", afm.szFace);
  printf("afm.iWeight: %d\n", afm.iWeight);
  printf("afm.rcBBox - top: %d left: %d right: %d bottom: %d\n",
    afm.rcBBox.top, afm.rcBBox.left, afm.rcBBox.right, afm.rcBBox.bottom);
}
/*----------------------------------------------------------------------------*/
VOID DumpKernPairs()
{
  INT indx;

  printf("\nKERN PAIRS\n");
  printf("afm.kp.cPairs: %d\n", afm.kp.cPairs);
  for (indx = 0; indx < afm.kp.cPairs; indx++)
        printf("afm.kp.rgPairs[%d] - iKey: %u iKernAmount: %d\n", indx,
          afm.kp.rgPairs[indx].iKey, afm.kp.rgPairs[indx].iKernAmount);
}
/*----------------------------------------------------------------------------*/
VOID DumpKernTracks()
{
  INT indx;

  printf("\nKERN TRACKS\n");
  printf("afm.kt.cTracks: %d\n", afm.kt.cTracks);
  for (indx = 0; indx < afm.kt.cTracks; indx++) {
        printf("track: %d iDegree: %d iPtMin: %d iKernMin: %d iPtMax: %d iKernMax: %d\n",
          indx,
          afm.kt.rgTracks[indx].iDegree,
          afm.kt.rgTracks[indx].iPtMin,
          afm.kt.rgTracks[indx].iKernMin,
          afm.kt.rgTracks[indx].iPtMax,
          afm.kt.rgTracks[indx].iKernMax);
        }

}
/*----------------------------------------------------------------------------*/
VOID DumpCharMetrics()
{
  INT indx;

  printf("\nCHARACTER METRICS\n");
  for (indx = afm.iFirstChar; indx <= afm.iLastChar; ++indx) {
    printf("indx: %d width: %d top: %d left: %d right: %d bottom: %d\n",
          indx,
          afm.rgcm[indx].iWidth,
          afm.rgcm[indx].rc.top,
          afm.rgcm[indx].rc.left,
    afm.rgcm[indx].rc.right,
          afm.rgcm[indx].rc.bottom);
        }
}
/*----------------------------------------------------------------------------*/
#endif

/******************************************************
* Name: GetCharMetrics()
* Action: Get the character metrics for a specified character.
**********************************************************/
VOID GetCharMetrics(iChar, pcm)
INT iChar;
CM *pcm;
{
  CM *pcmSrc;

  pcmSrc = &afm.rgcm[iChar];
  pcm->iWidth = pcmSrc->iWidth;
  pcm->rc.top = pcmSrc->rc.top;
  pcm->rc.left = pcmSrc->rc.left;
  pcm->rc.bottom = pcmSrc->rc.bottom;
  pcm->rc.right = pcmSrc->rc.right;
}

/*************************************************************
* Name: SetCharMetrics()
* Action: Set the character metrics for a specified character.
***************************************************************/
VOID SetCharMetrics(iChar, pcm)
INT iChar;
CM *pcm;
{
  CM *pcmDst;

  pcmDst = &afm.rgcm[iChar];
  pcmDst->iWidth = pcm->iWidth;
  pcmDst->rc.top = pcm->rc.top;
  pcmDst->rc.left = pcm->rc.left;
  pcmDst->rc.bottom = pcm->rc.bottom;
  pcmDst->rc.right = pcm->rc.right;
}

/************************************************************
* Name: GetSmallCM()
* Action: Compute the character metrics for small sized characters
*   such as superscripts.
**************************************************************/
VOID GetSmallCM(iCh, pcm)
INT iCh;
CM *pcm;
{
  GetCharMetrics(iCh, pcm);
  pcm->iWidth = pcm->iWidth / 2;
  pcm->rc.bottom = pcm->rc.top + (pcm->rc.top - pcm->rc.bottom)/2;
  pcm->rc.right = pcm->rc.left + (pcm->rc.right - pcm->rc.left)/2;
}

/*************************************************************
* Name: SetFractionMetrics()
* Action: Set the character metrics for a fractional character
*   which must be simulated.
***************************************************************/
VOID SetFractionMetrics(iChar, iTop, iBottom, pcl)
INT iChar;        /* The character code point */
INT iTop;         /* The ascii numerator character */
INT iBottom;      /* The denominator character */
INT pcl;          /* device type */
{
  INT cxBottom;   /* The width of the denominator */
  CM cm;

#define IFRACTIONBAR  167

  /* Set denominator width to 60 percent of bottom character */
  GetCharMetrics(iBottom, &cm);
  cxBottom = (INT)((long)cm.iWidth * (long)((pcl) ? CVTTOSCR(60) : 60)
        / (long)((pcl) ? CVTTOSCR(100) : 100));

  /* Set numerator width to 40 percent of top character */
  GetCharMetrics(iTop, &cm);
  cxBottom = (INT)((long)cm.iWidth * (long)((pcl) ? CVTTOSCR(40) : 40)
        / (long)((pcl) ? CVTTOSCR(100) : 100));

  cm.iWidth = iTop + iBottom + (pcl) ? CVTTOSCR(IFRACTIONBAR) : IFRACTIONBAR;
  cm.rc.right = cm.rc.left + cm.iWidth;
  SetCharMetrics(iChar, &cm);
}

/***********************************************************************
* Name: FixCharWidths()
* Action: Fix up the character widths for those characters which
*   must be simulated in the driver.
*************************************************************************/
VOID FixCharWidths()
{
  CM cm;
  CM cmSubstitute;
  INT i;

#if 0
  if (afm.iFamily == FF_DECORATIVE) {
        GetCharMetrics(ISPACE, &cmSubstitute);
    for (i = afm.iFirstChar; i <= afm.iLastChar; ++i) {
          GetCharMetrics(i, &cm);
          if (cm.iWidth == 0) {
            SetCharMetrics(i, &cmSubstitute);
                }
          }
        return;
        }

  /* this is a text font */
  GetCharMetrics(IBULLET, &cmSubstitute);
  for (i=0x07f; i<0x091; ++i) SetCharMetrics(i, &cmSubstitute);
  for (i=0x098; i<0x0a1; ++i) SetCharMetrics(i, &cmSubstitute);
#else
  /* yh 8-27-91  Added some characters for Windows 3.1. */
  if (afm.iFamily == FF_DECORATIVE)
        GetCharMetrics(ISPACE, &cmSubstitute);
  else {                                  /* WINANSI encoding */
        GetCharMetrics(ISPACE, &cm);      /* 'space' is encoded twice */
        SetCharMetrics(IWINSPACE, &cm);
        GetCharMetrics(IBULLET, &cmSubstitute);
        }
  for (i = afm.iFirstChar; i <= afm.iLastChar; ++i) {
        GetCharMetrics(i, &cm);
        if (cm.iWidth == 0)
            SetCharMetrics(i, &cmSubstitute);
        }
#endif
}

/***************************************************************
* Name: SetAfm()
* Action: Set the character metrics in the afm to their default values.
********************************************************************/
VOID SetAfm()
{
  INT i, cx;

  afm.iFirstChar = 0x0020;
  afm.iLastChar = 0x00ff;

  if( !afm.fVariablePitch ) {
    cx = afm.rgcm[afm.iFirstChar].iWidth;
    for (i=afm.iFirstChar; i<=afm.iLastChar; ++i)
        afm.rgcm[i].iWidth = (SHORT)cx;
    }
  SetAvgWidth();
  SetMaxWidth();
}

/******************************************************************
* Name: SetAvgWidth()
* Action: This routine computes the average character width
*   from the character metrics in the afm structure.
********************************************************************/
VOID SetAvgWidth()
{
  CM *rgcm;
  INT i;
  long cx;    /* The average character width */
  long cb;    /* The number of characters */

  rgcm = afm.rgcm;

  cx = 0L;
  cb = (long) (afm.iLastChar - afm.iFirstChar + 1);
  for (i=afm.iFirstChar; i<=afm.iLastChar; ++i)
    cx += (long) rgcm[i].iWidth;
  afm.iAvgWidth = (INT) (cx / cb);
}

/*****************************************************************
* Name: SetMaxWidth()
* Action: This routine computes the maximum character width from
*   the character metrics in the afm structure.
*******************************************************************/
VOID SetMaxWidth()
{
  CM *rgcm;
  INT cx;
  INT i;

  rgcm = afm.rgcm;

  cx = 0;
  for (i=afm.iFirstChar; i<=afm.iLastChar; ++i)
    if (rgcm[i].iWidth > cx) cx = rgcm[i].iWidth;
  afm.iMaxWidth = (SHORT)cx;
}
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/******************************************************************
* Name: ResetBuffer()
* Action: This function resets the output buffer.
********************************************************************/
VOID ResetBuffer()
{
  pbBuffer = rgbBuffer;
  cbBuffer = 0;
}

/****************************************************************
* Name: PutByte()
* Action: This function writes a byte to the output buffer.
******************************************************************/
VOID PutByte(iByte)
SHORT iByte;
{
  *pbBuffer++ = (BYTE) (iByte & 0x0ff);
  ++cbBuffer;
}

/****************************************************************
* Name: PutRgb()
* Action: This function writes an array of bytes to the output buffer.
******************************************************************/
VOID PutRgb(pb, cb)
LPSZ pb;
INT cb;
{
  while (--cb>=0)
  PutByte(*pb++);
}

/****************************************************************
* Name: PutWord()
* Action: This function writes a word to the output buffer.
******************************************************************/
VOID PutWord(iWord)
SHORT iWord;
{
  *pbBuffer++ = (CHAR) (iWord & 0x0ff);
  *pbBuffer++ = (CHAR) ( (iWord >> 8) & 0x0ff );
  cbBuffer += 2;
}

/****************************************************************
* Name: PutLong()
* Action: This function writes a long word to the output buffer.
******************************************************************/
VOID PutLong(lWord)
long lWord;
{
  PutWord((WORD) (lWord & 0x0ffffL));
  lWord >>= 16;
  PutWord((WORD) (lWord & 0x0ffffL));
}

/**************************************************************
* Name: SetDf()
* Action: This function sets the values in the device font structure
*         from the values in the afm structure.
*****************************************************************/
static CHAR szCopyright[] = "Copyright 1988-1991 Adobe Systems Inc.";
VOID SetDf(pcl)
INT pcl;
{
//WORD minAscent;
  WORD pixHeight;
  WORD internalLeading;
  SHORT leading;
  #ifndef FF_MASKFAMILY
    #define FF_MASKFAMILY ((BYTE) 0xF0)
  #endif
  #define MAX(a,b) ((a)>(b)?(a):(b))

  pfm.iVersion = 0x0100;        /* Version 1.00 */
  szMove(pfm.szCopyright, szCopyright, sizeof(pfm.szCopyright));
  pfm.iType = (pcl) ? PCL_FONTTYPE : PS_FONTTYPE;
  pfm.iCharSet = (charset == -1) ? (BYTE) ANSI_CHARSET : (BYTE) charset;
   /* (pcl && (afm.iFamily==FF_DECORATIVE)) ? PCL_PI_CHARSET : ANSI_CHARSET );
      Windows WRITE only displays fonts with CharSet=0 in the menu */
  pfm.iDefaultChar = (BYTE) (
       ( (afm.iFamily==FF_DECORATIVE) ? ISPACE : IBULLET ) - afm.iFirstChar );
  pfm.iBreakChar = (BYTE) (ISPACE - afm.iFirstChar);

  /* for a scalable font (i.e. PostScript) default to 80 column text */
  pfm.iPoints = (pcl) ? afm.iPtSize : 10;

  /* if we ever support other bitmapped printers we will no longer be able
  to assume that the default x and y res are 300. */
  pfm.iVertRes = 300;
  pfm.iHorizRes = 300;
  pfm.iItalic = (BYTE) ((afm.iItalicAngle != 0) ? 1 : 0);
  pfm.iWeight = afm.iWeight;
  pfm.iPitchAndFamily = (BYTE) afm.iFamily;
  pfm.iFirstChar = (BYTE) afm.iFirstChar;
  pfm.iLastChar = (BYTE) afm.iLastChar;
  pfm.iAvgWidth = afm.iAvgWidth;
  pfm.iMaxWidth = afm.iMaxWidth;
  pfm.iPixWidth = (afm.fVariablePitch) ? 0 : afm.iAvgWidth;
/* pfm.iPixHeight = afm.rcBBox.top - afm.rcBBox.bottom;
 * Changed to reduce round off error.  8-26-91 yh
 */
  pixHeight = afm.rcBBox.top - afm.rcBBox.bottom;
  pfm.iPixHeight = (pcl) ? CVTTOSCR(pixHeight) : pixHeight;
/*  pfm.iInternalLeading =
 *    (pcl) ? pfm.iPixHeight - ((afm.iPtSize * 300) / 72) : 0;
 *  Changed to match ATM.  7-31-91 yh
 *  Changed to reduce round off error.  8-26-91 yh
 */
  internalLeading = max(0, pixHeight - EM);
  pfm.iInternalLeading = (pcl) ? CVTTOSCR(internalLeading) : internalLeading;

/*  pfm.iAscent = afm.rcBBox.top;
 *  Changed to fix text alignment problem.  10-08-90 yh
 */
/*  pfm.iAscent = afm.iAscent;
 *  Changed to match ATM.  7-31-91 yh
 *  Changed to reduce round off error.  8-26-91 yh
 */
  pfm.iAscent = (pcl) ?
                CVTTOSCR(EM + afm.rcBBox.bottom) + CVTTOSCR(internalLeading) :
                EM + afm.rcBBox.bottom + internalLeading;
/* Deleted to match ATM.  yh 9-13-91
 * minAscent = (pcl) ? CVTTOSCR(667) : 667;          2/3 of EM
 * if( pfm.iAscent < minAscent ) pfm.iAscent = minAscent;
 */

/*  pfm.iExternalLeading = 196; */
/*  Changed to 0 to fix a bug in PCL landscape.  Was getting huge leading. */
  /*
   * yh 8-26-91  Changed ExternalLeading for pcl to match ATM .
   */
  if (!pcl)
      /* PostScript driver ignores this field and comes up with own
       * ExternalLeading value.
       *
       * !!! HACK ALERT !!!
       *
       * ATM needs to have ExternalLeading=0.  PFMs generated with Rev. 2
       * MAKEPFM have a bug in default & break character fields.  We had
       * encoding number instead of offsets.  ATM uses following algorithm
       * to recognize the Rev. 2 PFMs:
       *     rev2pfm = pfmRec->fmExternalLeading != 0 &&
       *               etmRec->etmStrikeOutOffset == 500 &&
       *               pfmRec->fmDefaultChar >= pfmRec->fmFirstChar;
       * So, we need to make sure that either ExternalLeading stays zero or
       * StrikeOutOffset is not 500.  With current algorithm, StrikeOutOffset
       * is very likely to be less than 500.
       *     etm.iStrikeOutOffset = fiCapHeight / 2 - (afm.ulThick / 2);
       */
      pfm.iExternalLeading = 0;
  else if (!afm.fWasVariablePitch)
      pfm.iExternalLeading = 0;
  else                               /* pcl & Variable pitch */
      {
      /* Adjust external leading such that we are compatible */
      /* with the values returned by the PostScript driver.  */
      /* Who did this code??  Microsoft?  Has to be! */
      switch (pfm.iPitchAndFamily & FF_MASKFAMILY)
        {
        case FF_ROMAN:  leading = (pfm.iVertRes + 18) / 36; //2-pnt leading
                        break;
        case FF_SWISS:  if (pfm.iPoints <= 12)
                          leading = (pfm.iVertRes + 18) / 36; //2-pnt leading
                        else if (pfm.iPoints < 14)
                          leading = (pfm.iVertRes + 12) / 24; //3-pnt leading
                        else
                          leading = (pfm.iVertRes + 9) / 18; //4-pnt leading
                        break;
        default:                /* Give 19.6% of the height for leading. */
                        leading = (short) (
                                  (long) (pfm.iPixHeight-pfm.iInternalLeading)
                                  * 196L / 1000L );
                        break;
        }

      pfm.iExternalLeading = MAX(0, (SHORT)(leading - pfm.iInternalLeading));
      }

  pfm.iWidthBytes = 0;
  if (afm.fVariablePitch) pfm.iPitchAndFamily |= 1;

  pfm.iUnderline = 0;
  pfm.iStrikeOut = 0;
  pfm.oBitsPointer = 0L;
  pfm.oBitsOffset = 0L;
}

/**********************************************************
* Name: PutString()
* Action: This function writes a null terminated string
*       to the output file.
***********************************************************/
VOID PutString(sz)
LPSZ sz;
{
  INT bCh;

  do    {
      bCh = *pbBuffer++ = *sz++;
      ++cbBuffer;
      } while( bCh );
}

/***************************************************************
* Name: PutdeviceName()
* Action: This function writes the device name to the output file.
**************************************************************/
VOID PutDeviceName(szDevice)
LPSZ szDevice;
{
  pfm.oDevice = cbBuffer;
  PutString(szDevice);
}

/***************************************************************
* Name: PutFaceName()
* Action: This function writes the font's face name to the output file.
**************************************************************/
VOID PutFaceName()
{
  pfm.oFace = cbBuffer;
  PutString(afm.szFace);
}

/**************************************************************
* Name: MakeDf()
* Action: This function writes the device font info structure
*       to the output file.
* Method: This function makes two passes over the data. On the first pass
* it collects offset data as it places data in the output buffer. On the
* second pass, it first resets the output buffer and then writes the data
* to the output buffer again with the offsets computed from pass 1.
***************************************************************/
BOOL MakeDf(fPass2, devType, outfile)
BOOL fPass2;            /* TRUE if this is the second pass */
SHORT devType;  /* 1=POSTSCRIPT 2=PCL */
LPSZ outfile;
{
  BOOL result = TRUE;
  INT iMarker;

  ResetBuffer();
  SetDf(devType == PCL);

  /* put out the PFM header structure */
  PutWord(pfm.iVersion);
  PutLong(pfm.iSize);
  PutRgb(pfm.szCopyright, 60);
  PutWord(pfm.iType);
  PutWord(pfm.iPoints);
  PutWord(pfm.iVertRes);
  PutWord(pfm.iHorizRes);
  PutWord(pfm.iAscent);
  PutWord(pfm.iInternalLeading);
  PutWord(pfm.iExternalLeading);
  PutByte(pfm.iItalic);
  PutByte(pfm.iUnderline);
  PutByte(pfm.iStrikeOut);
  PutWord(pfm.iWeight);
  PutByte(pfm.iCharSet);
  PutWord(pfm.iPixWidth);
  PutWord(pfm.iPixHeight);
  PutByte(pfm.iPitchAndFamily);
  PutWord(pfm.iAvgWidth);
  PutWord(pfm.iMaxWidth);
  PutByte(pfm.iFirstChar);
  PutByte(pfm.iLastChar);
  PutByte(pfm.iDefaultChar);
  PutByte(pfm.iBreakChar);
  PutWord(pfm.iWidthBytes);
  PutLong(pfm.oDevice);
  PutLong(pfm.oFace);
  PutLong(pfm.oBitsPointer);
  PutLong(pfm.oBitsOffset);

  /* need to determine if proportional etc. */
  if (devType == PCL) PutExtentOrWidthTable(1);

  /* put out the PFM extension structure */
  iMarker = cbBuffer;
  PutWord(pfmext.oSizeFields);
  PutLong(pfmext.oExtMetricsOffset);
  PutLong(pfmext.oExtentTable);
  PutLong(pfmext.oOriginTable);
  PutLong(pfmext.oPairKernTable);
  PutLong(pfmext.oTrackKernTable);
  PutLong(pfmext.oDriverInfo);
  PutLong(pfmext.iReserved);
  pfmext.oSizeFields = cbBuffer - iMarker;
  if (devType == POSTSCRIPT) {
    /* Put the extended text metrics table */
    pfmext.oExtMetricsOffset = cbBuffer;
    PutEtm(FALSE);

    PutDeviceName("PostScript");
    PutFaceName();
    PutDriverInfo(FALSE);

    /* Put the extent table */
    PutExtentOrWidthTable(0);

    pfmext.oOriginTable = 0;
    pfmext.iReserved = 0;
    PutPairKernTable(POSTSCRIPT);
    PutTrackKernTable(POSTSCRIPT);
    }

  if (devType == PCL) {
    PutFaceName();
    PutDeviceName("PCL/HP LaserJet");

    /* Put the extended text metrics table */
    pfmext.oExtMetricsOffset = cbBuffer;
    PutEtm(TRUE);

    PutPairKernTable(PCL);
    PutTrackKernTable(PCL);

    PutDriverInfo(TRUE);
    pfmext.oOriginTable = 0;
    pfmext.iReserved = 0;
    }

  if( !fPass2 ) {
    pfm.iSize = (long)cbBuffer;
    if( !MakeDf(TRUE, devType, outfile) ) result = FALSE;
    }
  else {
    if( !WritePfm(outfile) ) result = FALSE;
#if DEBUG_MODE
    DumpPfmHeader();
    DumpCharWidths();
    DumpPfmExtension();
#endif
    }
  return(result);
}

/*******************************************************************
* Name: PutPairKernTable(devType)
* Action: Send the pairwise kerning table to the output file.
*********************************************************************/
VOID PutPairKernTable(devType)
SHORT devType;  /* 1=POSTSCRIPT 2=PCL */
{
  WORD i;

  if( afm.kp.cPairs > 0 ) {
      pfmext.oPairKernTable = cbBuffer;
#if DEBUG_MODE
      printf("Pair Kern Table - pairs: %d\n", afm.kp.cPairs);
#endif
      if( devType == POSTSCRIPT ) PutWord(afm.kp.cPairs);
      for (i = 0; i < afm.kp.cPairs; ++i) {
          PutWord(afm.kp.rgPairs[i].iKey);
          PutWord(afm.kp.rgPairs[i].iKernAmount);
#if DEBUG_MODE
          printf("key: %x kern amount: %d\n",
          afm.kp.rgPairs[i].iKey, afm.kp.rgPairs[i].iKernAmount);
#endif
          }
      }
  else
      pfmext.oPairKernTable = 0;
}

/******************************************************************
* Name: PutTrackKernTable(devType)
* Action: Send the track kerning table to the output file.
********************************************************************/
VOID PutTrackKernTable(devType)
SHORT devType;  /* 1=POSTSCRIPT 2=PCL */
{
  INT i;

  if (afm.kt.cTracks == 0)
    {
    pfmext.oTrackKernTable = 0;
    return;
    }

  pfmext.oTrackKernTable = cbBuffer;
  if (devType == POSTSCRIPT) PutWord(afm.kt.cTracks);
  for (i=0; i<afm.kt.cTracks; ++i)
    {
    PutWord(afm.kt.rgTracks[i].iDegree);
    PutWord(afm.kt.rgTracks[i].iPtMin);
    PutWord(afm.kt.rgTracks[i].iKernMin);
    PutWord(afm.kt.rgTracks[i].iPtMax);
    PutWord(afm.kt.rgTracks[i].iKernMax);
    }
}

/***************************************************************
* Name: PutExtentTable()
* Action: Send the character extent information to the output file.
*****************************************************************/
VOID PutExtentOrWidthTable(width)
INT width; /* 0=extent 1=width */
{
  INT i;

  /* is the typeface proportional ?? */
  if (pfm.iPitchAndFamily & 1)
    {
    pfmext.oExtentTable = (width) ? 0 : cbBuffer;
    for (i = afm.iFirstChar; i <= afm.iLastChar; i++)
      PutWord(afm.rgcm[i].iWidth);
    if (width) PutWord(0);
    }
  else
    pfmext.oExtentTable = 0;
}

/***********************************************************
* Name: WritePfm()
* Action: Flush the ouput buffer to the file.  Note that this
*         function is only called after the entire pfm structure
*         has been built in the output buffer.
*************************************************************/
BOOL WritePfm(outfile)
LPSZ outfile;
{
  INT fh;

  if( (fh = OpenTargetFile(outfile) ) == -1 ) {
      ; // PostError(str(MSG_PFM_BAD_CREATE), outfile);
      return(FALSE);
      }

  if( cbBuffer > 0  )
    if( (WORD)WRITE_BLOCK(fh, rgbBuffer, cbBuffer) != (WORD)cbBuffer ) {
        CLOSE(fh);
        ; // PostError(str(MSG_PFM_DISK_FULL));
        return(FALSE);
        }
  CLOSE(fh);
  return(TRUE);
}

#if DEBUG_MODE
/*----------------------------------------------------------------------------*/
VOID DumpPfmHeader()
{
  printf("\nDUMP PFM HEADER\n");
  printf("pfm.iVersion=%d\n",pfm.iVersion);
  printf("pfm.iSize=%ld\n",pfm.iSize);
  printf("pfm.szCopyright=%s\n",pfm.szCopyright);
  printf("pfm.iType=%d\n",pfm.iType);
  printf("pfm.iPoints=%d\n",pfm.iPoints);
  printf("pfm.iVertRes=%d\n",pfm.iVertRes);
  printf("pfm.iHorizRes=%d\n",pfm.iHorizRes);
  printf("pfm.iAscent=%d\n",pfm.iAscent);
  printf("pfm.iInternalLeading=%d\n",pfm.iInternalLeading);
  printf("pfm.iExternalLeading=%d\n",pfm.iExternalLeading);
  printf("pfm.iItalic=%d\n",pfm.iItalic);
  printf("pfm.iUnderline=%d\n",pfm.iUnderline);
  printf("pfm.iStrikeOut=%d\n",pfm.iStrikeOut);
  printf("pfm.iWeight=%d\n",pfm.iWeight);
  printf("pfm.iCharSet=%d\n",pfm.iCharSet);
  printf("pfm.iPixWidth=%d\n",pfm.iPixWidth);
  printf("pfm.iPixHeight=%d\n",pfm.iPixHeight);
  printf("pfm.iPitchAndFamily=%d\n",pfm.iPitchAndFamily);
  printf("pfm.iAvgWidth=%d\n",pfm.iAvgWidth);
  printf("pfm.iMaxWidth=%d\n",pfm.iMaxWidth);
  printf("pfm.iFirstChar=%c\n",pfm.iFirstChar);
  printf("pfm.iLastChar=%c\n",pfm.iLastChar);
  printf("pfm.iDefaultChar=%d\n",pfm.iDefaultChar);
  printf("pfm.iBreakChar=%d\n",pfm.iBreakChar);
  printf("pfm.iWidthBytes=%d\n",pfm.iWidthBytes);
  printf("pfm.oDevice=%x\n",pfm.oDevice);
  printf("pfm.oFace=%x\n",pfm.oFace);
  printf("pfm.oBitsPointer=%ld\n",pfm.oBitsPointer);
  printf("pfm.oBitsOffset=%ld\n",pfm.oBitsOffset);
}
/*----------------------------------------------------------------------------*/
VOID DumpCharWidths()
{
  INT indx;

  printf("\nCHARACTER WIDTHS\n");
  for (indx = afm.iFirstChar; indx <= afm.iLastChar; indx++)
    printf("indx: %d width: %d\n", indx, afm.rgcm[indx].iWidth);
}
/*----------------------------------------------------------------------------*/
VOID DumpPfmExtension()
{
  printf("\nDUMP PFM EXTENSION\n");
  printf("pfmext.oSizeFields=%d\n",pfmext.oSizeFields);
  printf("pfmext.oExtMetricsOffset=%x\n",pfmext.oExtMetricsOffset);
  printf("pfmext.oExtentTable=%x\n",pfmext.oExtentTable);
  printf("pfmext.oOriginTable=%x\n",pfmext.oOriginTable);
  printf("pfmext.oPairKernTable=%x\n",pfmext.oPairKernTable);
  printf("pfmext.oTrackKernTable=%x\n",pfmext.oTrackKernTable);
  printf("pfmext.oDriverInfo=%x\n",pfmext.oDriverInfo);
  printf("pfm.iReserved=%x\n",pfm.iReserved);
}
#endif
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Main purpose of these structures is to set up a translation table which
allows the driver to translate the font from the character set indicated in
the dfCharset field into the printer-specific character set. */

#define AVGSIZE  (30 * 1024)

VOID SetDriverInfo()
{
  INT i;
  long sumWidth = 0L;

  for (i = afm.iFirstChar; i <= afm.iLastChar; i++)
      sumWidth = sumWidth + (long)afm.rgcm[i].iWidth;

  d.epSize = sizeof(DRIVERINFO);
  d.epVersion = DRIVERINFO_VERSION;
  d.epMemUsage = (long) ( ((sumWidth+7L) >> 3) * (long)pfm.iPixHeight + 63L );
  d.xtbl.symbolSet = pclinfo.symbolsetNum;
  d.xtbl.offset = 0L;
  d.xtbl.len = 0;
  d.xtbl.firstchar = 0;
  d.xtbl.lastchar = 0;
  pclinfo.epEscapeSequence = GetEscapeSequence();
}
/*----------------------------------------------------------------------------*/
VOID PutDriverInfo(pcl)
INT pcl;
{
  pfmext.oDriverInfo = cbBuffer;
  if (pcl) {
    SetDriverInfo();
    PutWord(d.epSize);
    PutWord(d.epVersion);
    PutLong(d.epMemUsage);
    PutLong(d.epEscape);
    PutWord((WORD)d.xtbl.symbolSet);
    PutLong(d.xtbl.offset);
    PutWord(d.xtbl.len);
    PutByte(d.xtbl.firstchar);
    PutByte(d.xtbl.lastchar);
    d.epEscape = cbBuffer;
    PutString(pclinfo.epEscapeSequence);
  } else
    PutString(afm.szFont);
}

/*--------------------------------------------------------------------------*/
LPSZ GetEscapeSequence()
{
  static char escapeStr[80];
  char fixedPitch[2], pitch[10], height[10], *cp;
  int enc;
  float size;

  size = (float) afm.iPtSize;
  if( afm.fWasVariablePitch == TRUE ) {
      STRCPY(fixedPitch, "1");
      enc = ISPACE;
      }
  else {
      STRCPY(fixedPitch, "");
      enc = afm.iFirstChar;
      }
  sprintf(pitch, "%1.3f", 300.0 / (float)afm.rgcm[enc].iWidth);
  if( cp = strchr(pitch, '.') ) cp[3] = '\0';

  sprintf(height, "%1.2f", size);

  sprintf(escapeStr, "\x01B&l%dO\x01B(%s\x01B(s%sp%sh%sv%ds%db%uT",
          pclinfo.orientation, pclinfo.symbolsetStr,
          fixedPitch, pitch, height,
          pclinfo.style, pclinfo.strokeWeight, pclinfo.typeface);
  return(escapeStr);
}

/*----------------------------------------------------------------------------*/
#if DEBUG_MODE
VOID DumpDriverInfo()
{
  printf("\nDUMP DRIVERINFO STRUCTURE\n");
  printf("d.epSize: %d\n", d.epSize);
  printf("d.epVersion: %d\n", d.epVersion);
  printf("d.epMemUsage: %ld\n", d.epMemUsage);
  printf("d.epEscape: %ld\n", d.epEscape);
  printf("d.xtbl.symbolSet: %d\n", d.xtbl.symbolSet);
  printf("d.xtbl.offset: %ld\n", d.xtbl.offset);
  printf("d.xtbl.len: %d\n", d.xtbl.len);
  printf("d.xtbl.firstchar: %d\n", d.xtbl.firstchar);
  printf("d.xtbl.lastchar: %d\n", d.xtbl.lastchar);
  printf("d.epEscapeSequence: %s\n", d.epEscapeSequence);
}
#endif

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Convert from PostScript to extended text metrics */
VOID AfmToEtm(pcl)
BOOL pcl;  /* true if this is a PCL type device */
{
  etm.iSize = 52;
  /* point size in twips */
  etm.iPointSize = afm.iPtSize * 20;
  etm.iOrientation = (pcl) ? pclinfo.orientation + 1 : 0;
  etm.iMasterHeight = (pcl) ? pfm.iPixHeight : 1000;
  etm.iMinScale = (pcl) ? etm.iMasterHeight : 3;
  etm.iMaxScale = (pcl) ? etm.iMasterHeight : 1000;

  etm.iMasterUnits = (pcl) ? etm.iMasterHeight : 1000;

  /* in general need to worry a little about what happens if these various
     glyphs are not present as in a decorative font. */

  etm.iCapHeight = afm.rgcm['H'].rc.top;
  etm.iXHeight = afm.rgcm['x'].rc.top;
  etm.iLowerCaseAscent =  afm.rgcm['d'].rc.top;
  etm.iLowerCaseDescent = - afm.rgcm['p'].rc.bottom;
  etm.iSlant = (pcl) ? afm.iItalicAngle * 10 : afm.iItalicAngle;
  etm.iSuperScript = (pcl) ? 0 : -500;
  etm.iSubScript = (pcl) ? 0 : 250;
  etm.iSuperScriptSize = (pcl) ? 0 : 500;
  etm.iSubScriptSize = (pcl) ? 0 : 500;
  etm.iUnderlineOffset = (pcl) ? 0 : afm.ulOffset;
  etm.iUnderlineWidth = (pcl) ? 1 : afm.ulThick;
  etm.iDoubleUpperUnderlineOffset = (pcl) ? 0 : afm.ulOffset / 2;
  etm.iDoubleLowerUnderlineOffset = (pcl) ? 0 : afm.ulOffset;
  etm.iDoubleUpperUnderlineWidth = (pcl) ? 1 : afm.ulThick / 2;
  etm.iDoubleLowerUnderlineWidth = (pcl) ? 1 : afm.ulThick / 2;
  etm.iStrikeOutOffset = (pcl) ? 0 : fiCapHeight / 2 - (afm.ulThick / 2);
  etm.iStrikeOutWidth = (pcl) ? 1 : afm.ulThick;
  etm.nKernPairs = afm.kp.cPairs;
  etm.nKernTracks = afm.kt.cTracks;
}
/*----------------------------------------------------------------------------*/
VOID PutEtm(pcl)
BOOL pcl;  /* true if this is a PCL type device */
{
  AfmToEtm(pcl);
  PutWord(etm.iSize);
  PutWord(etm.iPointSize);
  PutWord(etm.iOrientation);
  PutWord(etm.iMasterHeight);
  PutWord(etm.iMinScale);
  PutWord(etm.iMaxScale);
  PutWord(etm.iMasterUnits);
  PutWord(etm.iCapHeight);
  PutWord(etm.iXHeight);
  PutWord(etm.iLowerCaseAscent);
  PutWord(etm.iLowerCaseDescent);
  PutWord(etm.iSlant);
  PutWord(etm.iSuperScript);
  PutWord(etm.iSubScript);
  PutWord(etm.iSuperScriptSize);
  PutWord(etm.iSubScriptSize);
  PutWord(etm.iUnderlineOffset);
  PutWord(etm.iUnderlineWidth);
  PutWord(etm.iDoubleUpperUnderlineOffset);
  PutWord(etm.iDoubleLowerUnderlineOffset);
  PutWord(etm.iDoubleUpperUnderlineWidth);
  PutWord(etm.iDoubleLowerUnderlineWidth);
  PutWord(etm.iStrikeOutOffset);
  PutWord(etm.iStrikeOutWidth);
  PutWord(etm.nKernPairs);
  PutWord(etm.nKernTracks);
#if DEBUG_MODE
  DumpEtm();
#endif
}
/*----------------------------------------------------------------------------*/
#if DEBUG_MODE
VOID DumpEtm()
{
  printf("\nDUMP ETM STRUCTURE\n");
  printf("etm.iSize: %d\n", etm.iSize);
  printf("etm.iPointSize: %d\n", etm.iPointSize);
  printf("etm.iOrientation: %d\n", etm.iOrientation);
  printf("etm.iMasterHeight: %d\n", etm.iMasterHeight);
  printf("etm.iMinScale: %d\n", etm.iMinScale);
  printf("etm.iMaxScale: %d\n", etm.iMaxScale);
  printf("etm.iMasterUnits: %d\n", etm.iMasterUnits);
  printf("etm.iCapHeight: %d\n", etm.iCapHeight);
  printf("etm.iXHeight: %d\n", etm.iXHeight);
  printf("etm.iLowerCaseAscent: %d\n", etm.iLowerCaseAscent);
  printf("etm.iLowerCaseDescent: %d\n", etm.iLowerCaseDescent);
  printf("etm.iSlant: %d\n", etm.iSlant);
  printf("etm.iSuperScript: %d\n", etm.iSuperScript);
  printf("etm.iSubScript: %d\n", etm.iSubScript);
  printf("etm.iSuperScriptSize: %d\n", etm.iSuperScriptSize);
  printf("etm.iSubScriptSize: %d\n", etm.iSubScriptSize);
  printf("etm.iUnderlineOffset: %d\n", etm.iUnderlineOffset);
  printf("etm.iUnderlineWidth: %d\n", etm.iUnderlineWidth);
  printf("etm.iDoubleUpperUnderlineOffset: %d\n",
    etm.iDoubleUpperUnderlineOffset);
  printf("etm.iDoubleLowerUnderlineOffset: %d\n",
    etm.iDoubleLowerUnderlineOffset);
  printf("etm.iDoubleUpperUnderlineWidth: %d\n",
    etm.iDoubleUpperUnderlineWidth);
  printf("etm.iDoubleLowerUnderlineWidth: %d\n",
    etm.iDoubleLowerUnderlineWidth);
  printf("etm.iStrikeOutOffset: %d\n", etm.iStrikeOutOffset);
  printf("etm.iStrikeOutWidth: %d\n", etm.iStrikeOutWidth);
  printf("etm.nKernPairs: %d\n", etm.nKernPairs);
  printf("etm.nKernTracks: %d\n", etm.nKernTracks);
}
#endif
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/**************************************************************
* Name: StartParse()
***************************************************************/
VOID StartParse()
{
  fEOF = FALSE;
  fUnGetLine = FALSE;
  cbBuffer = 0;
}

/**************************************************************
* Name: szIsEqual()
* Action: Compare two NULL terminated strings.
* Returns: TRUE if they are equal FALSE if they are different
***************************************************************/
BOOL szIsEqual(sz1, sz2)
LPSZ sz1;
LPSZ sz2;
{
  while (*sz1 && *sz2)
      if (*sz1++ != *sz2++) return(FALSE);
  return(*sz1 == *sz2);
}

/**************************************************************
* Name: szMove()
* Action: Copy a string.  This function will copy at most the
*   number of bytes in the destination area - 1.
***************************************************************/
VOID szMove(szDst, szSrc, cbDst)
LPSZ szDst;   /* Ptr to the destination area */
LPSZ szSrc;   /* Ptr to the source area */
INT cbDst;     /* The size of the destination area */
{
  while (*szDst++ = *szSrc++)
      if (--cbDst <= 0) {
          *(szDst-1) = 0;
          break;
          }
}

/*****************************************************************
* Name: GetBuffer()
* Action: Read a new buffer full of text from the input file.
******************************************************************/
BOOL GetBuffer(hfile)
INT hfile;
{
  cbBuffer = 0;
  if (!fEOF) {
      cbBuffer = READ_BLOCK(hfile, rgbBuffer, sizeof(rgbBuffer));
      if (cbBuffer<=0) {
          cbBuffer = 0;
          fEOF = TRUE;
          }
      }
  pbBuffer = rgbBuffer;
  return(!fEOF);
}

/*****************************************************************
* Name: UnGetLine()
* Action: This routine pushes the most recent line back into the
*   input buffer.
*******************************************************************/
VOID UnGetLine()
{
  fUnGetLine = TRUE;
  szLine = rgbLine;
}

/******************************************************************
* Name: GetLine()
* Action: This routine gets the next line of text out of the
*   input buffer.  Handles both binary & text mode.
********************************************************************/
BOOL GetLine(hfile)
INT hfile;
{
  CHAR szWord[10];

  // WriteDots();
  szLine = rgbLine;
  do {                                            /* skip comment lines */
      if( !_GetLine(hfile) ) return(FALSE);
      GetWord(szWord, sizeof(szWord));
      } while( szIsEqual("Comment", szWord) );
  szLine = rgbLine;
  return(TRUE);
}

BOOL _GetLine(hfile)
INT hfile;
{
  INT cbLine;
  CHAR bCh;

  if( fUnGetLine ) {
      szLine = rgbLine;
      fUnGetLine = FALSE;
      return(TRUE);
      }

  cbLine = 0;
  szLine = rgbLine;
  *szLine = 0;
  if( !fEOF )
  {
      while( TRUE )
      {
          if ( cbBuffer <= 0 )
              if( !GetBuffer(hfile) ) return(FALSE);
          while( --cbBuffer >= 0 )
          {
              bCh = *pbBuffer++;
              if( bCh=='\n' || ++cbLine > (sizeof(rgbLine)-1) )
              {
                  *szLine = 0;
                  szLine = rgbLine;
                  EatWhite();
                  if( *szLine != 0 ) goto DONE;
                  szLine = rgbLine;
                  cbLine = 0;
                  continue;
              }
              else if( bCh >= ' ' )
              {
                *szLine++ = bCh;
              }
          }
      }
  }
  *szLine = 0;

DONE:
  szLine = rgbLine;
  return(!fEOF);
}

/****************************************************************
* Name: EatWhite()
* Action: This routine moves the input buffer pointer forward to
*   the next non-white character.
******************************************************************/
VOID EatWhite()
{
  while (*szLine && (*szLine==' ' || *szLine=='\t'))
  ++szLine;
}

/*******************************************************************
* Name: GetWord()
* Action: This routine gets the next word delimited by white space
*   from the input buffer.
*********************************************************************/
VOID GetWord(szWord, cbWord)
LPSZ szWord;   /* Ptr to the destination area */
INT cbWord;     /* The size of the destination area */
{
  CHAR bCh;

  EatWhite();
  while (--cbWord>0) {
      switch(bCh = *szLine++) {
          case 0:
          case ' ':
          case '\t': --szLine;
                     goto DONE;
          case ';':  *szWord++ = bCh;
                     goto DONE;
          default:   *szWord++ = bCh;
                     break;
          }
      }
DONE:
  *szWord = 0;
}

/*******************************************************************
* Name: GetString()
* Action: This routine gets the next word delimited by parentheses
*   from the input buffer.
*********************************************************************/
BOOL GetString(szWord, cbWord)
LPSZ szWord;   /* Ptr to the destination area */
INT   cbWord;   /* The size of the destination area */
{
  CHAR bCh;
  BOOL result = TRUE;

  EatWhite();
  if( *szLine == '(' ) szLine++;
  else result = FALSE;
  while (--cbWord>0) {
      switch(bCh = *szLine++) {
          case 0:   result = FALSE;
                    goto DONE;
          case ')': --szLine;
                    goto DONE;
          default:  *szWord++ = bCh;
                    break;
          }
      }
DONE:
  *szWord = 0;
  return(result);
}

/************************************************************
* Name: GetNumber()
* Action: This routine parses an ASCII decimal number from the
*   input file stream and returns its value.
***************************************************************/
BOOL GetNumber(piVal)
SHORT *piVal;
{
  INT iVal;
  BOOL fNegative;

  fNegative = FALSE;

  iVal = 0;
  EatWhite();

  if (*szLine=='-') {
      fNegative = TRUE;
      ++szLine;
      }

  if (*szLine<'0' || *szLine>'9') {
      *piVal = 0;
      return(FALSE);
      }

  while (*szLine>='0' && *szLine<='9')
      iVal = iVal * 10 + (*szLine++ - '0');

  if (fNegative) iVal = - iVal;
  if (*szLine==0 || *szLine==' ' || *szLine=='\t' || *szLine==';') {
      *piVal = (SHORT)iVal;
      return(TRUE);
      }
  else {
      return(FALSE);
  }
}

/******************************************************************
* Name: GetFloat()
* Action: This routine parses an ASCII floating point decimal number
*   from the input file stream and returns its value scaled
*   by a specified amount.
*********************************************************************/
BOOL GetFloat(pScale, piVal)
float *pScale;     /* The amount to scale the value by */
SHORT *piVal;
{
  float scale;
  long lVal;
  long lDivisor;
  BOOL fNegative;

  scale = *pScale;
  EatWhite();
  fNegative = FALSE;
  lVal = 0L;

  if (*szLine=='-') {
      fNegative = TRUE;
      ++szLine;
      }

  if (*szLine<'0' || *szLine>'9') {
      *piVal = 0;
      return(FALSE);
      }

  while (*szLine>='0' && *szLine<='9') lVal = lVal * 10 + (*szLine++ - '0');

  lDivisor = 1L;
  if (*szLine=='.') {
      ++szLine;
      while (*szLine>='0' && *szLine<='9') {
          lVal = lVal * 10 + (*szLine++ - '0');
          lDivisor = lDivisor * 10;
          }
      }
  lVal = (lVal * (long) scale) / lDivisor;
  if (fNegative) lVal = - lVal;
  if (*szLine==0 || *szLine==' ' || *szLine=='\t' || *szLine==';') {
      *piVal = (INT) lVal;
      return(TRUE);
      }
   else {
      return(FALSE);
   }
}

/***************************************************************
* Name: MapToken()
* Action: This routine maps an ascii key word into an integer token.
* Returns: The token value.
******************************************************************/
INT MapToken(szWord, map)
LPSZ szWord;      /* Ptr to the ascii keyword string */
KEY *map;
{
  KEY *pkey;

  pkey = map;
  while (pkey->szKey) {
      if( szIsEqual(szWord, pkey->szKey) ) return(pkey->iValue);
      ++pkey;
      }
  return(TK_UNDEFINED);
}

/*********************************************************************
* Name: GetToken()
* Action: Get the next token from the input stream.
***********************************************************************/
INT GetToken(hfile, map)
INT hfile;
KEY *map;
{
  CHAR szWord[80];

  if (*szLine==0)
      if( !GetLine(hfile) ) return(TK_EOF);
  GetWord(szWord, sizeof(szWord));
  return(MapToken(szWord, map));
}

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
GlyphName *AllocateGlyphArray(arraymax)

INT arraymax;
{
  GlyphName *p;
  INT i;

  p = (GlyphName *) AllocateMem( (UINT) (sizeof(LPSZ) * (arraymax+2)) );
  if( p == NULL ) {
      ; // PostError(str(MSG_PFM_BAD_MALLOC));
      return(NULL);
      }
  for(i=0; i<=arraymax; i++)
      p[i] = notdef;
  p[i] = NULL;
  return(p);
}

/*--------------------------------------------------------------------------*/
VOID PutGlyphName(array, index, glyph)

GlyphName *array;
INT index;
LPSZ glyph;
{
  LPSZ p;

  if ( !STRCMP(glyph, ".notdef") )
      array[index] = notdef;
  else {
      p = (LPSZ) AllocateMem((UINT) (strlen(glyph)+1));
      if ( p == NULL ) {
          ; // PostError(str(MSG_PFM_BAD_MALLOC));
          parseError = TRUE;
          return;
      }
      STRCPY(p, glyph);
      array[index] = p;
  }
}

/*--------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\makepfm.h ===
// *------------------------------------------------------------------------*
// * makepfm.h
// *------------------------------------------------------------------------*
//
//      Copyright 1990, 1991 -- Adobe Systems, Inc.
//      PostScript is a trademark of Adobe Systems, Inc.
//
// NOTICE:  All information contained herein or attendant hereto is, and
// remains, the property of Adobe Systems, Inc.  Many of the intellectual
// and technical concepts contained herein are proprietary to Adobe Systems,
// Inc. and may be covered by U.S. and Foreign Patents or Patents Pending or
// are protected as trade secrets.  Any dissemination of this information or
// reproduction of this material are strictly forbidden unless prior written
// permission is obtained from Adobe Systems, Inc.
//
//---------------------------------------------------------------------------


typedef char *LPSZ;

#define OPEN        FileOpen
#define CLOSE       _lclose
#define READ_BLOCK  _lread
#define WRITE_BLOCK _lwrite
#define STRCPY      lstrcpy
#define STRCAT      lstrcat
#define STRCMP      lstrcmp



/*--------------------------------------------------------------------------*/
#define DEBUG_MODE      0  

typedef struct {      /* A lookup table for converting strings to tokens */
  char *szKey;        /* Ptr to the string */
  int iValue;         /* The corresponding token value */
} KEY;

#define TK_UNDEFINED       0    /* tokens for ReadFontInfo */
#define TK_EOF             1
#define TK_MSMENUNAME      2
#define TK_VPSTYLE         3
#define TK_PI              4
#define TK_SERIF           5
#define TK_PCLSTYLE        6
#define TK_PCLSTROKEWEIGHT 7
#define TK_PCLTYPEFACEID   8
#define TK_INF_CAPHEIGHT   9
#define LAST_FI_TOKEN      9
#define TK_ANGLE           10   // added for ATM ( GetINFFontDescription )
#define TK_PSNAME          11   // added for ATM ( GetINFFontDescription )

/*----------------------------------------------------------------------------*/
/* EM describes the basic character cell dimension (in Adobe units) */
#define EM 1000

/*----------------------------------------------------------------------------*/
#define ANSI_CHARSET   0
#define SYMBOL_CHARSET 2
#define OEM_CHARSET    255
#define PCL_PI_CHARSET 181

#define PS_FONTTYPE    0x0081
#define PCL_FONTTYPE   0x0080

#define FW_NORMAL      400
#define FW_BOLD        700

/* GDI font families. */
#define WIN30
#ifdef WIN30
#define FF_DONTCARE   (0<<4) /* Don't care or don't know. */
#define FF_ROMAN      (1<<4) /* Variable stroke width, serifed. Times Roman, Century Schoolbook, etc. */
#define FF_SWISS      (2<<4) /* Variable stroke width, sans-serifed. Helvetica, Swiss, etc. */
#define FF_MODERN     (3<<4) /* Const stroke width, serifed or sans-serifed. Pica, Elite, Courier, etc. */
#define FF_SCRIPT     (4<<4) /* Cursive, etc. */
#define FF_DECORATIVE (5<<4) /* Old English, etc. */
#endif

typedef struct
{
  SHORT left;
  SHORT bottom;
  SHORT right;
  SHORT top;
} BBOX;

typedef struct {
  SHORT capHeight;
  SHORT xHeight;
  SHORT loAscent;        /* Lower-case ascent */
  SHORT loDescent;       /* Lower-case descent */
  SHORT ulOffset;        /* The underline offset */
  SHORT ulThick;         /* The underline thickness */
  SHORT iSlant;          /* The italic angle */
  BBOX  rcBounds;      /* The font bounding box */
} EMM;

typedef struct {
  char szFont[32];     /* The PostScript font name */
  char szFace[32];     /* The face name of the font */
  BOOL fEnumerate;     /* TRUE if the font should be enumerated */
  BOOL fItalic;        /* TRUE if this is an italic font */
  BOOL fSymbol;        /* TRUE if the font is decorative */
  SHORT iFamily;       /* The fonts family */
  WORD  iWeight;       /* TRUE if this is a bold font */
  SHORT iFirstChar;    /* The first character in the font */
  SHORT iLastChar;     /* The last character in the font */
  SHORT rgWidths[256]; /* Character widths from 0x020 to 0x0ff */
} FONT;

extern void PutByte(SHORT);
extern void PutWord(SHORT);
extern void PutLong(long);

typedef struct
{
  WORD iKey;
  SHORT iKernAmount;
} KX, *PKX;

typedef struct
{
  WORD cPairs;           /* The number of kerning pairs */
  PKX rgPairs;
} KP;

/* The info for a single kern track */
typedef struct
{
  SHORT iDegree;         /* The degree of kerning */
  SHORT iPtMin;          /* The minimum point size */
  SHORT iKernMin;        /* The minimum kern amount */
  SHORT iPtMax;          /* The maximum point size */
  SHORT iKernMax;        /* The maximum kern amount */
} TRACK;

#define MAXTRACKS 16
/* The track kerning table for a font */
typedef struct
{
  SHORT cTracks;              /* The number of kern tracks */
  TRACK rgTracks[MAXTRACKS];  /* The kern track information */
} KT;

/* Character metrics */
typedef struct
{
  BBOX rc;
  SHORT iWidth;
} CM;

typedef struct
{
  WORD  iPtSize;
  SHORT iFirstChar;
  SHORT iLastChar;
  SHORT iAvgWidth;
  SHORT iMaxWidth;
  SHORT iItalicAngle;
  SHORT iFamily;
  SHORT ulOffset;
  SHORT ulThick;
  SHORT iAscent;
  SHORT iDescent;
  BOOL fVariablePitch;
  BOOL fWasVariablePitch;
  char szFile[MAX_PATH + 4]; // +1 for nul term, +3 for alignment.
  char szFont[80];
  char szFace[80];
  SHORT iWeight;
  KP kp;
  KT kt;
  BBOX rcBBox;
  CM rgcm[256];        /* The character metrics */
} AFM;

/*----------------------------------------------------------------------------*/

typedef struct
{
  SHORT iSize;
  SHORT iPointSize;
  SHORT iOrientation;
  SHORT iMasterHeight;
  SHORT iMinScale;
  SHORT iMaxScale;
  SHORT iMasterUnits;
  SHORT iCapHeight;
  SHORT iXHeight;
  SHORT iLowerCaseAscent;
  SHORT iLowerCaseDescent;
  SHORT iSlant;
  SHORT iSuperScript;
  SHORT iSubScript;
  SHORT iSuperScriptSize;
  SHORT iSubScriptSize;
  SHORT iUnderlineOffset;
  SHORT iUnderlineWidth;
  SHORT iDoubleUpperUnderlineOffset;
  SHORT iDoubleLowerUnderlineOffset;
  SHORT iDoubleUpperUnderlineWidth;
  SHORT iDoubleLowerUnderlineWidth;
  SHORT iStrikeOutOffset;
  SHORT iStrikeOutWidth;
  WORD nKernPairs;
  WORD nKernTracks;
} ETM;

/*----------------------------------------------------------------------------*/

typedef struct
{
  WORD iVersion;
  DWORD iSize;
  CHAR szCopyright[60];
  WORD iType;
  WORD iPoints;
  WORD iVertRes;
  WORD iHorizRes;
  WORD iAscent;
  WORD iInternalLeading;
  WORD iExternalLeading;
  BYTE iItalic;
  BYTE iUnderline;
  BYTE iStrikeOut;
  WORD iWeight;
  BYTE iCharSet;
  WORD iPixWidth;
  WORD iPixHeight;
  BYTE iPitchAndFamily;
  WORD iAvgWidth;
  WORD iMaxWidth;
  BYTE iFirstChar;
  BYTE iLastChar;
  BYTE iDefaultChar;
  BYTE iBreakChar;
  WORD iWidthBytes;
  DWORD oDevice;
  DWORD oFace;
  DWORD oBitsPointer;
  DWORD oBitsOffset;
} PFM;

typedef struct
{
  WORD oSizeFields;
  DWORD oExtMetricsOffset;
  DWORD oExtentTable;
  DWORD oOriginTable;
  DWORD oPairKernTable;
  DWORD oTrackKernTable;
  DWORD oDriverInfo;
  DWORD iReserved;
} PFMEXT;

/*----------------------------------------------------------------------------*/

typedef enum    {
        epsymUserDefined,
        epsymRoman8,
        epsymKana8,
        epsymMath8,
        epsymUSASCII,
        epsymLineDraw,
        epsymMathSymbols,
        epsymUSLegal,
        epsymRomanExt,
        epsymISO_DenNor,
        epsymISO_UK,
        epsymISO_France,
        epsymISO_German,
        epsymISO_Italy,
        epsymISO_SwedFin,
        epsymISO_Spain,
        epsymGENERIC7,
        epsymGENERIC8,
        epsymECMA94
} SYMBOLSET;

typedef struct
        {
        SYMBOLSET symbolSet;            /* kind of translation table */
        DWORD offset;                           /* location of user-defined table */
        WORD len;                                       /* length (in bytes) of table */
        BYTE firstchar, lastchar;       /* table ranges from firstchar to lastchar */
        } TRANSTABLE;

typedef struct
        {
        WORD epSize;                            /* size of this data structure */
        WORD epVersion;                         /* number indicating version of struct */
        DWORD epMemUsage;                       /* amt of memory font takes up in printer */
        DWORD epEscape;                         /* pointer to escape that selects the font */
        TRANSTABLE xtbl;                        /* character set translation info */
        } DRIVERINFO;

/*----------------------------------------------------------------------------*/

#define POSTSCRIPT  (1)
#define PCL         (2)

/*----------------------------------------------------------------------------*/

typedef enum    { PORTRAIT, LANDSCAPE } ORIENTATION;

#define ASCII_SET   ("0U")
#define ROMAN8_SET  ("8U")
#define WINANSI_SET ("9U")
#define PI_SET      ("15U")

typedef struct
{
  ORIENTATION orientation;
  char symbolsetStr[4];
  SYMBOLSET symbolsetNum;
  SHORT style;
  SHORT strokeWeight;
  SHORT typefaceLen;
  WORD typeface;
  char *epEscapeSequence;       /* escape sequence that selects the font */
} PCLINFO;

/*--------------------------------------------------------------------------*/
#define EOS        '\0'
#define FNAMEMAX   (80)

/*--------------------------------------------------------------------------*/

#define BUFFLEN 80
#define MANDATORY       1
#define CookedReadMode  "r"
#define FATALEXIT  (2)



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\t1parser.h ===
/***
**
**   Module: T1Parser
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font file, by parsing
**      the data/commands found in PFB, PFM and AFM files.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif



struct T1Arg;
struct T1Info;
struct T1Glyph;
struct T1Handle;
struct T1Metrics;
struct Composite;
struct GlyphFilter;



/***
** Function: InitT1Input
**
** Description:
**   Allocate and initiate a handle for a T1 font file, including
**   extracting data from the font prolog that is needed to
**   read the glyphs, such as /FontMatrix, /Subrs and /lenIV.
***/
errcode           InitT1Input       _ARGS((IN      struct T1Arg *,
                                           OUT     struct T1Handle **,
                                           OUT     struct T1Metrics **,
                                           IN      short (*cb)(IN char *,
                                                               IN char *,
                                                               IN char *)));
/***
** Function: CleanUpT1
**
** Description:
**   Free the resources allocated for the T1 handle.
***/
errcode           CleanUpT1         _ARGS((INOUT   struct T1Handle *));


/***
** Function: ReadOtherMetrics
**
** Description:
**   Return font level information about the T1 font (mostly
**   metrics).
***/
errcode           ReadOtherMetrics  _ARGS((INOUT   struct T1Metrics *,
                                           IN      char *metrics));

/***
** Function: GetT1Glyph
**
** Description:
**   The current file position of the T1 font file must be
**   at the begining of an entry in the /CharStrings dictionary.
**   The function will decode the font commands, parse them, and
**   finally build a representation of the glyph.
***/
errcode           GetT1Glyph        _ARGS((INOUT   struct T1Handle *,
                                           OUT     struct T1Glyph *,
                                           IN      struct GlyphFilter *));
/***
** Function: FreeT1Glyph
**
** Description:
**   This function frees the memory used to represent
**   a glyph that has been translated.
***/
void              FreeT1Glyph       _ARGS((INOUT   struct T1Glyph *));


/***
** Function: GetT1Composite
**
** Description:
**   This function unlinks the first composite glyph
**   from the list of recorded composite glyphs, which
**   is returned to the caller.
***/
struct Composite  *GetT1Composite   _ARGS((INOUT   struct T1Handle *));


/***
** Function: GetT1AccentGlyph
**
** Description:
**   This function parses the charstring code associated to the
**   accent character of a composite character, if that glyph
**   is not already converted.
***/
errcode           GetT1AccentGlyph  _ARGS((INOUT   struct T1Handle *,
                                           IN      struct Composite *,
                                           OUT     struct T1Glyph *));
/***
** Function: GetT1BaseGlyph
**
** Description:
**   This function parses the charstring code associated to the
**   base character of a composite character, if that glyph
**   is not already converted.
***/
errcode           GetT1BaseGlyph    _ARGS((INOUT   struct T1Handle *,
                                           IN      struct Composite *,
                                           OUT     struct T1Glyph *));
/***
** Function: FlushWorkspace
**
** Description:
**   Free the resources allocated for the T1 handle.
***/
void              FlushWorkspace    _ARGS((INOUT   struct T1Handle *t1));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\testt1.c ===
#include <stdio.h>
#include <stdlib.h>
#include "t1instal.h"

#define DEFAULT_STR  (void*)"Converting with pfb: "
#define PFM_STR      (void*)"Converting with pfb+pfm: "
#define FULL_STR     (void*)"Converting with pfb+pfm+ttf: "

#ifdef _MSC_VER
#  define CDECL  __cdecl
#else
#  define CDECL
#endif


#ifdef PROGRESS
const void STDCALL PrintProgress(short percent, void *arg)
{
   char *str = arg;
   
   printf("\r%s%d%%  ", str, percent);
}
#else
#define PrintProgress 0L
#endif

void CDECL main(int argc, char **argv)
{
   short res;
   char buf[128];

   if (argc==2)
      res = ConvertTypeface(argv[1], 0L, 0L,
                            PrintProgress, DEFAULT_STR);
   else if (argc==3) {
      if (IsType1(argv[2], sizeof(buf), buf)) {
         printf("Converting typeface: %s\n", buf);
         res = ConvertTypeface(argv[1], argv[2], 0L,
                               PrintProgress, PFM_STR);
      } else {
         printf("Not a valid Adobe Type 1 typeface.\n");
      }
         
   } else if (argc==4) {
      if (IsType1(argv[2], sizeof(buf), buf)) {
         printf("Converting typeface: %s\n", buf);
         res = ConvertTypeface(argv[1], argv[2], argv[3],
                               PrintProgress, PFM_STR);
      } else {
         printf("Not a valid Adobe Type 1 typeface.\n");
      }
   }

   if (res!=SUCCESS)
      puts("\nConversion failed!");

   exit((int)res);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\titott.c ===
/***
 **
 **   Module: TItoTT
 **
 **   Description:
 **      This is the main module of the Postscript Type I to TrueType
 **      font converter.
 **
 **   Author: Michael Jansson
 **   Created: 5/26/93
 **
 ***/


/***** INCLUDES */
#include <string.h>
#include "types.h"
#include "safemem.h"
#include "metrics.h"
#include "titott.h"
#include "t1parser.h"
#include "builder.h"
#include "trans.h"


/***** LOCAL TYPES */
/*-none-*/


/***** CONSTANTS */
#define NOTDEFNAME  ".notdef"

static const struct TTGlyph null = {
   NULL,
   0, 0, 0, NULL,
   NULL,
   0, 0
};
static Point mpo3[] = {
   {1150, 10}, {1150, 30}, {1160, 30}, {1170, 20}, {1180, 30}, {1190, 30}, 
   {1190, 10}, {1180, 10}, {1180, 20}, {1170, 10}, {1160, 20}, {1160, 10}
};
static Point mpo2[] = {
   {60, 40}, {60, 1560}, {1160, 1560}, {1160, 40}
};
static Point mpo1[] = {
   {20, 0}, {1200, 0}, {1200, 1600}, {20, 1600}
};
static ULONG onoff[1] = {0L};
static Outline p1 = {
   NULL,
   sizeof(mpo3)/sizeof(mpo3[0]),
   &mpo3[0],
   &onoff[0]
};
static Outline p2 = {
   &p1,
   sizeof(mpo2)/sizeof(mpo2[0]),
   &mpo2[0],
   &onoff[0]
};
static Outline missingPath = {
   &p2,
   sizeof(mpo1)/sizeof(mpo1[0]),
   &mpo1[0],
   &onoff[0]
};

static struct TTGlyph missing = {
   NULL,
   MAXNOTDEFSIZE, 0, 0, NULL,
   &missingPath,
   1500, 0
};


/***** MACROS */
/*-none-*/


/***** GLOBALS */
/*-none-*/


/***** STATIC FUNCTIONS */
/*-none-*/


/**** FUNCTIONS */

/***
 ** Function: ConvertT1toTT
 **
 ** Description:
 **   Convert a T1 font into a TT font file.
 ***/
errcode ConvertT1toTT(const struct TTArg *ttArg,
                      const struct T1Arg *t1Arg,
                      const short (*check)(const char *copyright,
                                           const char *notice,
                                           const char *facename),
                      struct callProgress *cp)
{
   /* Resources */
   struct T1Handle  *t1 = NULL;
   struct TTHandle  *tt = NULL;
   struct T1Metrics *t1m = NULL;

   /* Temporary variables. */
   struct T1Glyph  glyph;
   struct TTGlyph *ttglyph;
   struct Composite *comp;
   struct TTComposite ttcomp;
   struct TTMetrics ttm;
   boolean fStdEncoding;
   boolean done;
   errcode status;

   /* Initiate variables. */
   ttglyph = NULL;
   memset(&glyph, '\0', sizeof(glyph));
   memset(&ttm, '\0', sizeof(ttm));

   /* Inititate input and output */
   if ((status = InitT1Input(t1Arg, &t1, &t1m, check))==SUCCESS &&
       (status = InitTTOutput(ttArg, &tt))==SUCCESS) {
     
      done = FALSE;

      fStdEncoding = (CurrentEncoding(t1m)==NULL);

      /* Create the missing and the null glyph. */
      if ((missing.hints = Malloc(MAXNOTDEFSIZE))==NULL) {
         status = NOMEM;
         done = TRUE;
      } else {
         memset(missing.hints, 0x22, MAXNOTDEFSIZE);
         (void)PutTTGlyph(tt, &missing, fStdEncoding);
         (void)PutTTGlyph(tt, &null, fStdEncoding);
         Free(missing.hints);
      }

      /* Convert the simple glyphs. */
      while(!done) {
         status = GetT1Glyph(t1, &glyph, t1Arg->filter);
         if (status == SUCCESS) {
            if ((status = ConvertGlyph(t1m,
                                       &glyph,
                                       &ttglyph,
                                       (int)ttArg->precision))!=SUCCESS ||
                (status = PutTTGlyph(tt, ttglyph, fStdEncoding))!=SUCCESS) {
               done = TRUE;
            } else {

               FreeTTGlyph(ttglyph);
               ttglyph=NULL;
               if (cp)
                  cp->cb((short)0, &glyph, cp->arg);
            }
         } else if (status<=FAILURE || status==DONE) {
            done = TRUE;
         } else {
            /* Handle the missing glyph ".notdef" */
            if (!strcmp(glyph.name, NOTDEFNAME)) {
               if ((status = ConvertGlyph(t1m,
                                          &glyph,
                                          &ttglyph,
                                          (int)ttArg->precision))!=SUCCESS ||
                   (status = PutTTNotDefGlyph(tt, ttglyph))!=SUCCESS) {
                  done = TRUE;
               } else {
                  FreeTTGlyph(ttglyph);
                  ttglyph=NULL;
                  if (cp)
                     cp->cb((short)0, &glyph, cp->arg);
               }
            }
         }
         FreeT1Glyph(&glyph);
      }
      
      if (status==DONE) {

         /* Convert the composite glyphs. */
         while ((comp = GetT1Composite(t1))!=NULL) {

            /* Check if the base glyph is converted */
            if ((status = GetT1BaseGlyph(t1, comp, &glyph))==SUCCESS) {
               if ((status = ConvertGlyph(t1m,
                                          &glyph,
                                          &ttglyph,
                                          (int)ttArg->precision))!=SUCCESS ||
                   (status = PutTTGlyph(tt, ttglyph, fStdEncoding))!=SUCCESS) {
                  break;
               }
               FreeTTGlyph(ttglyph);
               ttglyph=NULL;
               if (cp)
                  cp->cb((short)0, &glyph, cp->arg);
            } else if (status<=FAILURE)
               break;
            FreeT1Glyph(&glyph);

            /* Check if the base accent is converted */
            if ((status = GetT1AccentGlyph(t1, comp, &glyph))==SUCCESS) {
               if ((status = ConvertGlyph(t1m,
                                          &glyph,
                                          &ttglyph,
                                          (int)ttArg->precision))!=SUCCESS ||
                   (status = PutTTGlyph(tt, ttglyph, fStdEncoding))!=SUCCESS) {
                  break;
               }
               FreeTTGlyph(ttglyph);
               ttglyph=NULL;
               if (cp)
                  cp->cb((short)0, &glyph, cp->arg);
            } else if (status<=FAILURE)
               break;
            FreeT1Glyph(&glyph);


            /* Convert and store accented glyph. */
            if (status>=SUCCESS && 
                ((status = ConvertComposite(t1m, comp, &ttcomp))!=SUCCESS ||
                 (status = PutTTComposite(tt, &ttcomp))!=SUCCESS)) {
               break;
            }
            if (cp)
               cp->cb((short)1, &comp, cp->arg);
         }

         /* Flush out un-used work space. */
         FlushWorkspace(t1);

         /* Convert the metrics. */
         if (status==SUCCESS || status==DONE || status==SKIP) {
            if ((status = ReadOtherMetrics(t1m,
                                           t1Arg->metrics))==SUCCESS &&
                (status = ConvertMetrics(tt, t1m, &ttm,
                                         ttArg->tag))==SUCCESS) {
               if (cp)
                  cp->cb((short)2, NULL, cp->arg);
               status = PutTTOther(tt, &ttm);
            }
         }
      }
   }                               

   /* More progress. */
   if (cp)
      cp->cb((short)3, NULL, cp->arg);

   FreeTTMetrics(&ttm);
   FreeTTGlyph(ttglyph);
   FreeT1Glyph(&glyph);
   if (CleanUpTT(tt, ttArg, status)!=SUCCESS && status==SUCCESS)
      status = BADINPUTFILE;
   if (CleanUpT1(t1)!=SUCCESS && status==SUCCESS)
      status = BADINPUTFILE;

   /* All done! */
   if (cp)
      cp->cb((short)4, NULL, cp->arg);


   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\titott.h ===
/***
 **
 **   Module: TItoTT
 **
 **   Description:
 **      This is the internal interface for the Adobe Type 1 to
 **      TrueType font converter.
 **
 **   Author: Michael Jansson
 **   Created: 5/26/93
 **
 ***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

#define MAXERRORS          -14
#define NOCOPYRIGHT        -13
#define ARGSTACK           -12
#define TTSTACK            -11
#define NOMETRICS          -10
#define UNSUPPORTEDFORMAT  -9
#define BADMETRICS         -8
#define BADT1HYBRID        -7
#define BADCHARSTRING      -6
#define BADINPUTFILE       -5
#define BADOUTPUTFILE      -4
#define BADT1HEADER        -3
#define NOMEM              -2
#define FAILURE            -1
#define SUCCESS            0
#define DONE               1
#define SKIP               2

struct GlyphFilter {
   const unsigned short num;
   const char **name;
};

struct T1Arg {
   const char *name;
   const char *metrics;
   const struct GlyphFilter *filter;
   int upem;
};

struct TTArg {
   char *name;
   char *tag;
   short precision;
};

struct callProgress {
   const void (*cb)(short, void *, void *);
   void *arg;
};
   

/***
 ** Function: ConvertT1toTT
 **
 ** Description:
 **   Convert a T1 font into a TT font file.
 ***/
short ConvertT1toTT _ARGS((IN struct TTArg *ttArg,
                           IN struct T1Arg *t1Arg,
                           IN short (*check)(IN char *facename,
                                             IN char *copyright,
                                             IN char *notice),
                           INOUT struct callProgress *cp));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\fwriter.h ===
/***
**
**   Module: T1Parser
**
**   Description:
**  This is a module of the T1 to TT font converter. The module
**  contains functions that is used by the Builder moduler, to
**  manage the lowlevel writing to the TT font file, as well as
**  generic check sum, table length and table offset computations.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef FWRITER_H
#define FWRITER_H

#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif


#define TBL_OS2   (USHORT)0
#define TBL_CMAP  (USHORT)1 
#define TBL_CVT   (USHORT)2 
#define TBL_FPGM  (USHORT)3 
#define TBL_GASP  (USHORT)4 
#define TBL_GLYF  (USHORT)5
#define TBL_HEAD  (USHORT)6 	      
#define TBL_HHEA  (USHORT)7 	      
#define TBL_HMTX  (USHORT)8 	      
#define TBL_KERN	(USHORT)9 
#define TBL_LOCA  (USHORT)10			 	      
#define TBL_MAXP  (USHORT)11			 	      
#define TBL_NAME  (USHORT)12			 	      
#define TBL_POST  (USHORT)13			 	      
#define TBL_PREP  (USHORT)14			 
#define NUMTBL    15L
#define TBLDIRSIZE (4L+4L+4L+4L)

/* Referenced types. */
typedef struct ioFile OutputFile;




/***
** Function: WriteTableHeader
**
** Description:
**   This function initiates a TT font file, by initiating 
**   a handle used when writing the tables and by writing
**   the leading table dictionary of the file.
***/
void        WriteTableHeader  _ARGS((INOUT   OutputFile *file));


/***
** Function: OpenOutputFile
**
** Description:
***/
OutputFile  *OpenOutputFile   _ARGS((IN      char *name));


/***
** Function: CloseOutputFile
**
** Description:
***/
errcode     CloseOutputFile   _ARGS((INOUT   OutputFile *fp));


/***
** Function: FileError
**
** Description:
***/
boolean     FileError         _ARGS((INOUT   OutputFile *fp));


/***
** Function: FileTell
**
** Description:
***/
long        FileTell          _ARGS((INOUT   OutputFile *fp));


/***
** Function: WriteLong
**
** Description:
**   This function writes a 32-bit integer in the
**   Big Endian byte order, regardless of the
**   used byte order.
***/
void        WriteLong         _ARGS((IN      ULONG val,
                                     INOUT   OutputFile *file));

/***
** Function: WriteShort
**
** Description:
**   This function writes a 16-bit integer in the
**   Big Endian byte order, regardless of the used
**   byte order.
***/
void        WriteShort        _ARGS((IN      USHORT val,

                                     INOUT   OutputFile *file));
/***
** Function: WriteByte
**
** Description:
**   This function writes an 8-bit integer in the
**   Big Endian byte order, regardless of used
**   byte order.
***/
void        WriteByte         _ARGS((IN      UBYTE val,
                                     INOUT   OutputFile *file));

/***
** Function: WriteChecksum
**
** Description:
**   This function completes the whole TT font file,
**   by computing the check sum of the whole file and writing
**   it at the designated place.
***/
void        WriteChecksum     _ARGS((IN      long offset,
                                     INOUT   OutputFile *file));

/***
** Function: FileSeek
**
** Description:
***/
long        FileSeek          _ARGS((INOUT   OutputFile *fp,

                                     IN      long where));
/***
** Function: WriteBytes
**
** Description:
***/
USHORT      WriteBytes        _ARGS((IN      UBYTE *buf,
                                     IN      USHORT len,
                                     INOUT   OutputFile *fp));
/***
** Function: CompleteTable
**
** Description:
**   This function completes a TT font file table,
**   by computing the check sum and writing it, the
**   table length and table offset to the table directory
**   of the TT font file.
**
**   Please note the dependency that this function must
**   be called right after the last byte of the contents
**   of the table have been written.
***/
errcode     CompleteTable     _ARGS((IN      long offset,
                                     IN      USHORT num,
                                     INOUT   OutputFile *file));
/***
** Function: RemoveFile
**
** Description:
**  Removes an already closed output file.
***/
void        RemoveFile        _ARGS((IN      char *name));
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\trans.h ===
/***
**
**   Module: Trans
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      contains functions that will convert T1 specific data into
**      corresponding TT data, such as hints and font metrics.
**
**   Author: Michael Jansson
**
**   Created: 5/28/93
**
***/



#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif


struct TTMetrics;
struct T1Metrics;
struct TTHandle;
struct T1Glyph;
struct TTGlyph;
struct TTComposite;
struct Composite;


/***
** Function: ConvertComposite
**
** Description:
**   This function convertes the data associated to a T1 font seac glyph
**   into the corresponding data used in a TT font composite glyph.
**
***/
errcode FASTCALL  ConvertComposite  _ARGS((INOUT   struct T1Metrics *,
                                           IN      struct Composite *,
                                           OUT     struct TTComposite *));
/***
** Function: ConvertGlyph
**
** Description:
**   This function convertes the data associated to a T1 font glyph
**   into the corresponding data used in a TT font glyph.
***/
errcode FASTCALL  ConvertGlyph      _ARGS((INOUT   struct T1Metrics *,
                                           IN      struct T1Glyph *,
                                           OUT     struct TTGlyph **,
                                           IN      int));
/***
** Function: ConvertMetrics
**
** Description:
**
***/
errcode FASTCALL  ConvertMetrics    _ARGS((IN      struct TTHandle *,
                                           INOUT   struct T1Metrics *,
                                           OUT     struct TTMetrics *,
                                           IN      char *tag));

/***
** Function: TransX
**
** Description:
**   Translate a horizontal coordinate according to a transformation matrix.
***/
funit FASTCALL    TransX            _ARGS((IN      struct T1Metrics *t1,
                                           IN      funit x));

/***
** Function: TransY
**
** Description:
**   Translate a vertical coordinate according to a transformation matrix.
***/
funit FASTCALL    TransY            _ARGS((IN      struct T1Metrics *t1,
                                           IN      funit y));

/***
** Function: TransAllPoints
**
** Description:
**   Translate a coordinate according to a transformation matrix.
***/
void  FASTCALL    TransAllPoints    _ARGS((IN      struct T1Metrics *t1,
                                           INOUT   Point *pts,
                                           IN      USHORT cnt,
                                           IN      f16d16 *fmatrix));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\trig.c ===
/***
 **
 **   Module: Trig
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contains a look-up table for computing atan2() faster, and
 **    with less precision than that of the c run-time library.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/



#include "types.h"
#include "metrics.h"
#include "trig.h"

static const unsigned char atan_tbl[] = {
   0,
   2, 5, 7, 10, 12, 15, 17, 20, 22, 25, 27, 30, 32, 35, 38, 40, 
   43, 45, 48, 50, 53, 55, 57, 60, 62, 65, 67, 70, 72, 75, 77, 79, 
   82, 84, 87, 89, 91, 94, 96, 98, 101, 103, 105, 107, 110, 112, 114, 116, 
   119, 121, 123, 125, 127, 130, 132, 134, 136, 138, 140, 142, 144, 147, 149, 151, 
   153, 155, 157, 159, 161, 163, 165, 167, 168, 170, 172, 174, 176, 178, 180, 182, 
   183, 185, 187, 189, 191, 192, 194, 196, 198, 199, 201, 203, 204, 206, 208, 209, 
   211, 212, 214, 216, 217, 219, 220, 222, 223, 225, 226, 228, 229, 231, 232, 234, 
   235, 237, 238, 239, 241, 242, 244, 245, 246, 248, 249, 250, 252, 253, 254, 255
};


/***
** Function: Atan2
**
** Description:
**   Compute atan2()
***/
int FASTCALL Atan2(const funit dy, const funit dx)
{
   funit du, dv;
   int a = 0;

   /* Normalize the sign. */
   if (ABS(dx)>ABS(dy)) {
      du = ABS(dx);
      dv = ABS(dy);

      if (du==0) {
         a = PI4;
      } else {

         /* Normalize for the size of the table. */
         while (dv>256) {
            dv = (dv+1)>>1;
            du = (du+1)>>1;
         }
         dv = ((dv<<7)+(du>>1))/du;

         /* Lookup the angle. */
         if (dv==1) 
            a = (int)((long)PI4 * (long)ABS(dx) / (long)ABS(dy));
         if (du!=dv)
            a = (int)atan_tbl[dv];
      }

   } else {
      du = ABS(dy);
      dv = ABS(dx);

      if (du==0) {
         a = PI4;
      } else {

         /* Normalize for the size of the table. */
         while (dv>256) {
            dv = (dv+1)>>1;
            du = (du+1)>>1;
         }
         dv = ((dv<<7)+(du>>1))/du;

         /* Lookup the angle. */
         if (dv==1) 
            a = (int)((long)PI4 * (long)ABS(dy) / (long)ABS(dx));
         if (du!=dv)
            a = PI2 - (int)atan_tbl[dv];
      }
   }


   /* pick the right quadrant. */
   if (dx>0) {
      if (dy>0) {
         /* NOOP */
      } else {
         a = -a;
      }
   } else {
      if (dy>0) {
         a = PI - a;
      } else {
         a = a - PI;
      }
   }

   return a;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\t1local.h ===
#define STR_APPNAME              "Type 1 Installer"
#define SUBKEY_TYPE1INSTAL       "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer"
#define SUBKEY_TYPE1COPYRIGHTS   SUBKEY_TYPE1INSTAL "\\Copyrights"
#define SUBKEY_LOGFILE           "Log events"   



#define IDS_CAPTION	1
#define IDS_RECOGNIZE1  2
#define IDS_RECOGNIZE2  3
#define IDS_MAINMSG     4


#define ALERT				MB_OK | MB_DEFBUTTON1 | MB_ICONSTOP
#define INFO				MB_OK | MB_DEFBUTTON1 | MB_ICONEXCLAMATION
#define QUERY				MB_OKCANCEL | MB_DEFBUTTON2 | MB_ICONEXCLAMATION

HMODULE ModuleInstance(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\trig.h ===
/***
 **
 **   Module: Trig
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contains a look-up table for computing atan2() faster, and
 **    with less precision than that of the c run-time library.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/



#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif

#define PI    1024
#define PI2   512
#define PI4   256



/***
** Function: Atan2
**
** Description:
**   Compute atan2()
***/
int FASTCALL Atan2   _ARGS((IN int dy, IN int dx));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\t1instal.h ===
#if defined(__cplusplus)
extern "C" {
#endif

#include "fvscodes.h"  // FVS_xxxxxx (font validation status) codes and macros.

#define MAXERRORS          -14
#define NOCOPYRIGHT        -13
#define ARGSTACK           -12
#define TTSTACK            -11
#define NOMETRICS          -10
#define UNSUPPORTEDFORMAT  -9
#define BADMETRICS         -8
#define BADT1HYBRID        -7
#define BADCHARSTRING      -6
#define BADINPUTFILE       -5
#define BADOUTPUTFILE      -4
#define BADT1HEADER        -3
#define NOMEM              -2
#define FAILURE            -1
#define SUCCESS            0
#define DONE               1
#define SKIP               2

#define MAYBE              2

#ifdef _MSC_VER
#define STDCALL  __stdcall
#else
#define STDCALL
#endif

#ifndef UNICODE
#  define ConvertTypeface  ConvertTypefaceA
#  define IsType1          IsType1A
#endif

short STDCALL ConvertTypefaceA   (char *szPfb,
                                  char *szPfm,
                                  char *szTtf,
                                  void (STDCALL *Proc)(short,void*),
                                  void *arg);

BOOL STDCALL CheckType1A (char *pszKeyFile,
                           DWORD cjDesc,
                           char *pszDesc,
                           DWORD cjPFM,
                           char *pszPFM,
                           DWORD cjPFB,
                           char *pszPFB,
                           BOOL *pbCreatedPFM,
                           char *pszFontPath
                           );

short STDCALL CheckCopyrightA    (char *szPFB,
                                  DWORD wSize,
                                  char *szVendor);


//
// Function CheckType1WithStatusA performs the same operation as
// CheckType1A except that it returns an encoded status value
// rather than merely TRUE/FALSE.  See fvscodes.h for a description
// of the "Font Validation Status" encodings.
// Since the original CheckType1A interface is exported from T1INSTAL.DLL
// by name, it was left unchanged so that existing applications that
// might use it don't break.
//
short STDCALL CheckType1WithStatusA (char *pszKeyFile,
                                     DWORD cjDesc,
                                     char *pszDesc,
                                     DWORD cjPFM,
                                     char *pszPFM,
                                     DWORD cjPFB,
                                     char *pszPFB,
                                     BOOL *pbCreatedPFM,
                                     char *pszFontPath
                                     );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\t1instal.c ===
/***
 **
 **   Module: T1Instal
 **
 **   Description:
 **      This is the Win32 DLL (t1instal.dll) interface to the
 **      font converter. All window specific code is located in
 **      this module and the error hadler module (errors.c).
 **
 **   Author: Michael Jansson
 **   Created: 12/18/93
 **
 ***/

/***** INCLUDES */

#include "windows.h"

#include <string.h>
#include <time.h>
#include <limits.h>
#include <ctype.h>

#undef IN

#include "titott.h"
#include "types.h"
#include "t1local.h"
#include "t1instal.h"
#include "fileio.h"
#include "safemem.h"
#include "t1msg.h"

#undef UNICODE


/* The CopyrightCheck/MAYBEOK case always succeeds for now. */
#define MAYBEOK   SUCCESS


/***** LOCAL TYPES */
struct callFrame {
   const void (STDCALL *Progress)(short, void*);
   void *arg;
   int last;
   int done;
};


static short lastCP = FALSE;
static char lastVendor[256] = "Unknown.";

/***** CONSTANTS */
#define MIN_PROGRESS    3
#define DELIMITERS      " ,"
#define COPYSIGN        169
#define TRUE            1
#define FALSE           0
#define DFFACE          139
#define DFDRIVERINFO    101

#define VERSTR "Converter: Windows Type 1 Installer V1.0d.\n" \
               "Font: V"

const char version[] = "\n$VER: 1.0d\n";

#ifndef NOANSIWINMAC
const char *winmac[] = {
   "A",
   "AE",
   "Aacute",
   "Acircumflex",
   "Adieresis",
   "Agrave",
   "Aring",
   "Atilde",
   "B",
   "C",
   "Cacute",
   "Ccaron",
   "Ccedilla",
   "D",
   "Delta",
   "E",
   "Eacute",
   "Ecircumflex",
   "Edieresis",
   "Egrave",
   "Eth",
   "F",
   "G",
   "Gbreve",
   "H",
   "I",
   "Iacute",
   "Icircumflex",
   "Idieresis",
   "Idot",
   "Igrave",
   "J",
   "K",
   "L",
   "Lslash",
   "M",
   "N",
   "Ntilde",
   "O",
   "OE",
   "Oacute",
   "Ocircumflex",
   "Odieresis",
   "Ograve",
   "Oslash",
   "Otilde",
   "P",
   "Q",
   "R",
   "S",
   "Scaron",
   "Scedilla",
   "T",
   "Thorn",
   "U",
   "Uacute",
   "Ucircumflex",
   "Udieresis",
   "Ugrave",
   "V",
   "W",
   "X",
   "Y",
   "Yacute",
   "Ydieresis",
   "Z",
   "a",
   "aacute",
   "acircumflex",
   "acute",
   "adieresis",
   "ae",
   "agrave",
   "ampersand",
   "approxequal",
   "aring",
   "asciicircum",
   "asciitilde",
   "asterisk",
   "at",
   "atilde",
   "b",
   "backslash",
   "bar",
   "braceleft",
   "braceright",
   "bracketleft",
   "bracketright",
   "breve",
   "brokenbar",
   "bullet",
   "c",
   "cacute",
   "caron",
   "ccaron",
   "ccedilla",
   "cedilla",
   "cent",
   "circumflex",
   "colon",
   "comma",
   "copyright",
   "currency",
   "d",
   "dagger",
   "daggerdbl",
   "degree",
   "dieresis",
   "divide",
   "dmacron",
   "dollar",
   "dotaccent",
   "dotlessi",
   "e",
   "eacute",
   "ecircumflex",
   "edieresis",
   "egrave",
   "eight",
   "ellipsis",
   "emdash",
   "endash",
   "equal",
   "eth",
   "exclam",
   "exclamdown",
   "f",
   "fi",
   "five",
   "fl",
   "florin",
   "four",
   "fraction",
   "franc",
   "g",
   "gbreve",
   "germandbls",
   "grave",
   "greater",
   "greaterequal",
   "guillemotleft",
   "guillemotright",
   "guilsinglleft",
   "guilsinglright",
   "h",
   "hungerumlaut",
   "hyphen",
   "i",
   "iacute",
   "icircumflex",
   "idieresis",
   "igrave",
   "infinity",
   "integral",
   "j",
   "k",
   "l",
   "less",
   "lessequal",
   "logicalnot",
   "lozenge",
   "lslash",
   "m",
   "macron",
   "middot",
   "minus",
   "mu",
   "multiply",
   "n",
   "nbspace",
   "nine",
   "notequal",
   "ntilde",
   "numbersign",
   "o",
   "oacute",
   "ocircumflex",
   "odieresis",
   "oe",
   "ogonek",
   "ograve",
   "ohm",
   "one",
   "onehalf",
   "onequarter",
   "onesuperior",
   "ordfeminine",
   "ordmasculine",
   "oslash",
   "otilde",
   "overscore",
   "p",
   "paragraph",
   "parenleft",
   "parenright",
   "partialdiff",
   "percent",
   "period",
   "periodcentered",
   "perthousand",
   "pi",
   "plus",
   "plusminus",
   "product",
   "q",
   "question",
   "questiondown",
   "quotedbl",
   "quotedblbase",
   "quotedblleft",
   "quotedblright",
   "quoteleft",
   "quoteright",
   "quotesinglbase",
   "quotesingle",
   "r",
   "radical",
   "registered",
   "ring",
   "s",
   "scaron",
   "scedilla",
   "section",
   "semicolon",
   "seven",
   "sfthyphen",
   "six",
   "slash",
   "space",
   "sterling",
   "summation",
   "t",
   "thorn",
   "three",
   "threequarters",
   "threesuperior",
   "tilde",
   "trademark",
   "two",
   "twosuperior",
   "u",
   "uacute",
   "ucircumflex",
   "udieresis",
   "ugrave",
   "underscore",
   "v",
   "w",
   "x",
   "y",
   "yacute",
   "ydieresis",
   "yen",
   "z",
   "zero"
};

#define GLYPHFILTER  &win
const struct GlyphFilter win = {
   sizeof(winmac) / sizeof(winmac[0]),
   winmac
};

#else
#define GLYPHFILER (struct GlyphFilter *)0
#endif /* NOANSIWINMAC */


/***** PROTOTYPES */
extern int __cdecl sprintf(char *, const char *, ...);


/***** MACROS */

#define ReadLittleEndianDword(file,dw)  {          \
        dw  = (DWORD)io_ReadOneByte(file) ;        \
        dw |= (DWORD)io_ReadOneByte(file) << 8;    \
        dw |= (DWORD)io_ReadOneByte(file) << 16;   \
        dw |= (DWORD)io_ReadOneByte(file) << 24;   \
        }
				
#ifndef try
#define try __try
#define except __except
#endif


/***** GLOBALS */
HMODULE ModuleInstance(
    void
    )
{
    static HMODULE hInst = NULL;
    if (NULL == hInst)
        hInst = GetModuleHandle(TEXT("fontext.dll"));
    return hInst;
}


/***** STATIC FUNCTIONS */


/***
** Function: Decrypt
**
** Description:
**   Decrypt a byte.
***/
static DWORD CSum(char *str)
{
   DWORD sum = 0;

   while (*str)
      sum += *str++;

   return sum;
}


/***
** Function: Decrypt
**
** Description:
**   Decrypt a byte.
***/
static char *Encrypt(char *str, char *out)
{
   const USHORT c1 = 52845;
   const USHORT c2 = 22719;
   UBYTE cipher;
   USHORT r = 8366;
   int i;
   
   for (i=0; i<(int)strlen(str); i++) {
      cipher = (UBYTE)(str[i] ^ (r>>8));
      r = (USHORT)((cipher + r) * c1 + c2);
      out[i] = (char)((cipher & 0x3f) + ' ');

      /* Unmap 'bad' characters, that the Registry DB doesn't like. */
      if (out[i]=='=' || out[i]==' ' || out[i]=='@' || out[i]=='"')
         out[i] = 'M';
   }
   out[i] = '\0';

   return out;
}


static char *stristr(char *src, char *word)
{
	int len = strlen(word);
	char *tmp = src;

	while (*src) {
		if (!_strnicmp(src, word, len))
			break;
		src++;
	}

	return src;
}


/***
 ** Function: GetCompany
 **
 ** Description:
 **   Extract the company name out of a copyright string.
 ***/
char *GetCompany(char *buf)
{
   char *company = NULL;
   int done = FALSE;
   UBYTE *token;
   UBYTE *tmp1;
   UBYTE *tmp2;
   UBYTE *tmp3;
   UBYTE *tmp4;
   int i;

   token = buf;

   while (token && !done) {

	   /* Locate the start of the copyright string. */
	   tmp1 = stristr(token, "copyright");
	   tmp2 = stristr(token, "(c)");
	   tmp3 = stristr(token, " c ");
	   if ((tmp4 = strchr(token, COPYSIGN))==NULL)
		   tmp4 = &token[strlen(token)];
	   if (*tmp1==0 && *tmp2==0 && *tmp3==0 && *tmp4==0) {
		   token = NULL;
		   break;
	   } else if (tmp1<tmp2 && tmp1<tmp3 && tmp1<tmp4)
		   token = tmp1;
	   else if (tmp2<tmp3 && tmp2<tmp4)
		   token = tmp2;
	   else if (tmp3<tmp4)
		   token = tmp3;
	   else
		   token = tmp4;

      /* Skip the leading copyright strings/character. */
      if (token[0]==COPYSIGN && token[1]!='\0') {
         token += 2;
      } else if (!_strnicmp(token, "copyright", strlen("copyright"))) {
		  token += strlen("copyright");
	  } else {
		  token += strlen("(c)");
	  }

	  /* Skip blanks. */
	  while(*token && isspace(*token) || *token==',')
		  token++;

	  /* Another copyright word? */
	  if (!_strnicmp((char*)token, "(c)", strlen("(c)")) ||
		  !_strnicmp((char*)token, "copyright", strlen("copyright")) ||
		  token[0]==COPYSIGN)
		  continue;

      /* Skip the years. */
	  company = token;
      if (isdigit(token[0])) {
         while (isdigit(*company) || isspace(*company) ||
				ispunct(*company) || (*company)=='-')
            company++;

         if (*company=='\0')
            break;

         /* Skip strings like "by", up to the beginning of a name that */
         /* starts with an upper case letter. */         
         while (*company && (company[0]<'A' || company[0]>'Z'))
            company++;

         done = TRUE;
      } else {
         continue;
      }
   } 


   /* Did we find it? */
   if (company) {
      while (*company && isspace(*company))
         company++; 


      if (*company=='\0') {
         company=NULL;
      } else {

         /* Terminate the company name. */
         if ((token = (UBYTE*)strchr(company, '.'))!=NULL) {

            /* Period as an initial delimiter, e.g. James, A. B. ?*/
            if (token[-1]>='A' && token[-1]<='Z') {
               if (strchr((char*)&token[1], '.'))
                  token = (UBYTE*)strchr((char*)&token[1], '.');

               /* Check for "James A. Bently, " */
               else if (strchr((char*)&token[1], ',')) {
                  token = (UBYTE*)strchr((char*)&token[1], ',');
                  token[0] = '.';
               }
            }
			token[1] = '\0';
         } else {
			 /* Name ending with a ';'? */
			 if ((token = (UBYTE*)strrchr(company, ';'))) {
				 *token = '\0';
			 }
		 }

		 /* Truncate some common strings. */
		 tmp1 = stristr(company, "all rights reserved");
		 *tmp1 = '\0';

		 /* Remove trailing punctuation character. */
		 for (i=strlen(company)-1; i>0 &&
				(ispunct(company[i]) || isspace(company[i])); i--) {
			 company[i] = 0;
		 }
      }
   }      
              

   return company;
}




/**** FUNCTIONS */

/***
 ** Function: ConvertAnyway
 **
 ** Description:
 **   Ask the user if it is ok to convert. 
 ***/
static errcode ConvertAnyway(const char *vendor, const char *facename)
{
   char tmp[256];
   char msg[1024];
   errcode answer;
   HMODULE hInst = ModuleInstance();

   if (vendor==NULL || strlen(vendor)==0) {
      LoadString(hInst, IDS_RECOGNIZE1, tmp, sizeof(tmp));
      sprintf(msg, tmp, facename);
   } else {
      LoadString(hInst, IDS_RECOGNIZE2, tmp, sizeof(tmp));
      sprintf(msg, tmp, facename, vendor);
   }      
   LoadString(hInst, IDS_MAINMSG, tmp, sizeof(tmp));
   strcat(msg, tmp);
   LoadString(hInst, IDS_CAPTION, tmp, sizeof(tmp));
   answer = (errcode)MessageBox(NULL, msg, tmp, QUERY);
   SetLastError(0);

   return answer;
}



/***
 ** Function: CheckCopyright
 **
 ** Description:
 **   This is the callback function that verifies that
 **   the converted font is copyrighted by a company who
 **   has agreed to having their fonts converted by
 **   this software. These companies are registered in the
 **   registry data base.
 ***/


static errcode CheckCopyright(const char *facename,
                              const char *copyright,
                              const char *notice)
{
#ifdef NOCOPYRIGHTS
   return SKIP;
#else
   HKEY key;
   char tmp[256];
   char *company = NULL;
   char buf[1024];
   int done = FALSE;
   short result = FAILURE;
   

   /* Access the REG data base. */
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SUBKEY_TYPE1COPYRIGHTS, 0,
                    KEY_QUERY_VALUE, &key)==ERROR_SUCCESS) { 


      /* Look for the company name in the /notice string. */
      if (notice && notice[0]) {
         strcpy(buf, notice);
         company = GetCompany(buf);
      }

      /* Look in the /copyright string if the company name was not found. */
      if (company==NULL && copyright && copyright[0]) {
         strcpy(buf, copyright);
         company = GetCompany(buf);
      }


#ifdef SHOWCOPYRIGHTS
      LogError(MSG_INFO, MSG_Copyright, company);
      Encrypt(company, tmp);
      sprintf(&tmp[strlen(tmp)], "(%d)\n", CSum(tmp));
      LogError(MSG_INFO, MSG_Encoding, tmp);
#else

      /* Did not find a company name? */
      if (company==NULL &&
          ((notice==NULL || notice[0]=='\0'||
            strstr(notice, "Copyright")==NULL) &&
           (copyright==NULL || copyright[0]=='\0' ||
            strstr(copyright, "Copyright")==NULL))) {

         /* No known copyright. */
         LogError(MSG_WARNING, MSG_NOCOPYRIGHT, NULL);
         result = MAYBEOK;

      /* Strange copyright format? */
      } else if (company==NULL || company[0]=='\0') {
         if (notice || notice[0])
            LogError(MSG_WARNING, MSG_BADFORMAT, notice);
         else
            LogError(MSG_WARNING, MSG_BADFORMAT, copyright);

         result = MAYBEOK;

      /* Found copyright! */
      } else {
         DWORD size;
         DWORD csum;

         size = 4;
         if (RegQueryValueEx(key, Encrypt(company, tmp), NULL, NULL,
                             (LPBYTE)&csum, &size)==ERROR_SUCCESS) {
            
            /* A positive match -> ok to convert. */
            if (CSum(tmp)==csum) {
               LogError(MSG_INFO, MSG_COPYRIGHT, company);
               result = SUCCESS;
            } else {
               LogError(MSG_ERROR, MSG_BADCOPYRIGHT, company);
               result = SKIP;
            }
         } else {
            LogError(MSG_WARNING, MSG_BADCOPYRIGHT, company);
            result = MAYBEOK;
         }
      }               
#endif

      RegCloseKey(key);

      /* Give the user the final word. */
      if (result==FAILURE) {
         if (ConvertAnyway(company, facename)==TRUE)
            result = SUCCESS;
      }


   /* No copyright key in the registry? */
   } else {
      LogError(MSG_ERROR, MSG_NODB, NULL);
      result = FAILURE;
   }   


   return result;
#endif
}



/***
 ** Function: NTCheckCopyright
 **
 ** Description:
 **   This is the callback function that verifies that
 **   the converted font is copyrighted by a company who
 **   has agreed to having their fonts converted by
 **   this software. These companies are registered in the
 **   registry data base.
 ***/
static errcode NTCheckCopyright(const char *facename,
                                const char *copyright,
                                const char *notice)
{
   HKEY key;
   char tmp[256];
   char *company = NULL;
   char buf[1024];
   int done = FALSE;
   short result = FAILURE;
   

   /* Access the REG data base. */
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SUBKEY_TYPE1COPYRIGHTS, 0,
                    KEY_QUERY_VALUE, &key)==ERROR_SUCCESS) { 


      /* Look for the company name in the /notice string. */
      if (notice && notice[0]) {
         strcpy(buf, notice);
         company = GetCompany(buf);
      }

      /* Look in the /copyright string if the company name was not found. */
      if (company==NULL && copyright && copyright[0]) {
         strcpy(buf, copyright);
         company = GetCompany(buf);
      }

      /* Did not find a company name? */
      if (company==NULL &&
          ((notice==NULL || notice[0]=='\0'||
            strstr(notice, "Copyright")==NULL) &&
           (copyright==NULL || copyright[0]=='\0' ||
            strstr(copyright, "Copyright")==NULL))) {

         /* No known copyright. */
         result = MAYBE;

      /* Strange copyright format? */
      } else if (company==NULL || company[0]=='\0') {
         result = MAYBE;

      /* Found copyright! */
      } else {
         DWORD size;
         DWORD csum;

         /* remember for future use. */
         strncpy(lastVendor, company, 256);
         lastVendor[MIN(255, strlen(company))] = '\0';

         size = 4;
         if (RegQueryValueEx(key, Encrypt(company, tmp), NULL, NULL,
                             (LPBYTE)&csum, &size)==ERROR_SUCCESS) {
            
            /* A positive match -> ok to convert. */
            if (CSum(tmp)==csum) {
               result = SUCCESS;
            } else {
               result = FAILURE;
            }
         } else {
            result = MAYBE;
         }
      }               

      RegCloseKey(key);


   /* No copyright key in the registry? */
   } else {
      result = FAILURE;
   }   


   lastCP = result;

   return FAILURE;
}


/***
 ** Function: _Progress
 **
 ** Description:
 **   This is the internal progress callback function that 
 **   computes an percentage-done number, based on the
 **   number of converted glyphs.
 ***/
static void _Progress(short type, void *generic, void *arg)
{
   struct callFrame *f = arg;

   /* Processing glyphs or wrapping up? */
   if (type==0 || type==1) 
      f->done++;
   else
      f->done = MIN(sizeof(winmac)/sizeof(winmac[0]), f->done+10);
   
   if ((f->done-f->last)>MIN_PROGRESS) {
      f->Progress((short)(f->done*100/(sizeof(winmac)/sizeof(winmac[0]))),
                  f->arg);
      f->last = f->done;
   }
   
   UNREFERENCED_PARAMETER(type);
   UNREFERENCED_PARAMETER(generic);
   SetLastError(0L);
}
            
static BOOL ReadStringFromOffset(struct ioFile *file,
                                 const DWORD dwOffset, 
                                 char *pszString,
                                 int cLen,
                                 BOOL bStrip)
{
    BOOL result = TRUE;
    DWORD offset;

    /* Get offset to string. */
    io_FileSeek(file, dwOffset);

    /* Read the offset. */

    ReadLittleEndianDword(file, offset);

    /*  Get the string. */
    (void)io_FileSeek(file, offset);
    if (io_FileError(file) != SUCCESS) {
        result = FALSE;
    } else {
        int i;

        i=0;
        while (io_FileError(file)==SUCCESS && i<cLen) {
            pszString[i] = (UBYTE)io_ReadOneByte(file);
            if (pszString[i]=='\0')
                break;

            /* Replace all dashes with spaces. */
            if (bStrip && pszString[i]=='-')
                pszString[i]=' ';
            i++;
        }
    }

    return TRUE;
}
                                 



/**** FUNCTIONS */

/***
 ** Function: ConvertTypeFaceA
 **
 ** Description:
 **   Convert a T1 font into a TT font file. This is the
 **   simplified interface used by the Win32 DLL, with the
 **   ANSI interface.
 ***/
short STDCALL ConvertTypefaceAInternal(const char *type1,
                               const char *metrics,
                               const char *truetype,
                               const void (STDCALL *Progress)(short, void*),
                               void *arg)
{                        
   struct callFrame f;
   struct callProgress p;
   struct T1Arg t1Arg;
   struct TTArg ttArg;
   short status;


   /* Check parameters. */
   if (type1==NULL || metrics==NULL)
      return FAILURE;

   /* Set up arguments to ConvertTypefaceA() */
   t1Arg.filter = GLYPHFILTER;
   t1Arg.upem = (short)2048;
   t1Arg.name = (char *)type1;
   t1Arg.metrics = (char *)metrics;
   ttArg.precision = (short)50;
   ttArg.name = (char *)truetype;
   ttArg.tag = VERSTR;

   /* Use progress gauge */
   if (Progress) {
      LogError(MSG_INFO, MSG_STARTING, type1);

      f.Progress = Progress;
      f.done = 0;
      f.last = 0;
      f.arg = arg;
      p.arg = &f;
      p.cb = _Progress;
      status = ConvertT1toTT(&ttArg, &t1Arg, CheckCopyright, &p);
      Progress(100, arg);
   } else {
      status = ConvertT1toTT(&ttArg, &t1Arg, CheckCopyright, NULL);
   }

   
   return status;
}



short STDCALL ConvertTypefaceA(char *type1,
                               char *metrics,
                               char *truetype,
                               void (STDCALL *Progress)(short, void*),
                               void *arg)
{

    short bRet;

    try
    {
        bRet = ConvertTypefaceAInternal(type1,
                                        metrics,
                                        truetype,
                                        Progress,
                                        arg);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
    #if 0
        ASSERTGDI(
            GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR,
            "ttfd!ttfdSemLoadFontFile, strange exception code\n"
            );
    #endif

        bRet = BADINPUTFILE;

    }

    return bRet;
}


short STDCALL FindPfb (
    char *pszPFM,
    char *achPFB
);


/***
** Function: CheckPfmA
**
** Description:
**   This function determines if there is a pfm/pfb pair of
**   files that makes up an Adobe Type 1 font, and determins
**   the descriptive face name of it.
**
** Returns: 16-bit encoded value indicating error and type of file where
**          error occurred.  (see fvscodes.h) for definitions.
**          The following table lists the "status" portion of the codes
**          returned.
**
**           FVS_SUCCESS           
**           FVS_INVALID_FONTFILE  
**           FVS_FILE_OPEN_ERR   
**           FVS_INVALID_ARG
**           FVS_FILE_IO_ERR
**           FVS_BAD_VERSION
***/

short STDCALL CheckPfmA(
    char  *pszPFM,
    DWORD  cjDesc,
    char  *pszDesc,
    DWORD  cjPFB,
    char  *pszPFB
)
{
   struct ioFile *file;
   char szDriver[MAX_PATH];
   short result = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
   short ver;

   char achPFB[MAX_PATH];

   char  *psz_PFB;
   DWORD  cjPFB1;

   if (pszPFB)
   {
       psz_PFB = pszPFB;
       cjPFB1 = cjPFB;
   }
   else
   {
       psz_PFB = (char *)achPFB;
       cjPFB1 = MAX_PATH;
   }

   /* Check parameter. */
   if (pszPFM==NULL || ((strlen(pszPFM)+3) >= cjPFB1))
      return FVS_MAKE_CODE(FVS_INVALID_ARG, FVS_FILE_UNK);

   // check if pfb file exists and find the path to it:

    result = FindPfb(pszPFM, psz_PFB);
    if (FVS_STATUS(result) != FVS_SUCCESS)
        return result;

   /****
    * Locate the pszDescriptive name of the font.
    */

   if ((file = io_OpenFile(pszPFM, READONLY))==NULL)
      return FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_PFM);

   (void)io_ReadOneByte(file);     /* Skip the revision number. */
   ver = (short)io_ReadOneByte(file);

   if (ver > 3) {
      /*  ERROR - unsupported format */
      result = FVS_MAKE_CODE(FVS_BAD_VERSION, FVS_FILE_PFM);
   } else {

      /* Read the driver name. */
      if (!ReadStringFromOffset(file, DFDRIVERINFO, szDriver, 
                                    sizeof(szDriver), FALSE))
      {
          result = FVS_MAKE_CODE(FVS_FILE_IO_ERR, FVS_FILE_PFM);
      }
      /* Is it "PostScript" ? */
      else if (_stricmp(szDriver, "PostScript"))
      {
          result = FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_PFM);
      }
      /* Only get description if asked to do so. */
      else if (pszDesc && !ReadStringFromOffset(file, DFFACE, pszDesc, cjDesc, TRUE))
      {
          result = FVS_MAKE_CODE(FVS_FILE_IO_ERR, FVS_FILE_PFM);
      }
   }

   (void)io_CloseFile(file);

   return result;
}



/***
** Function: CheckCopyrightsA
**
** Description:
**   This function verifies that it is ok to convert the font. This is
**   done by faking an installation.
***/
short STDCALL CheckCopyrightAInternal(char *szPFB,
                              DWORD wSize,
                              char *szVendor)
{
   struct T1Arg t1Arg;
   struct TTArg ttArg;
   
   /* Set up arguments to ConvertTypefaceA() */
   t1Arg.metrics = NULL;
   t1Arg.upem = (short)2048;
   t1Arg.filter = GLYPHFILTER;
   t1Arg.name = szPFB;
   ttArg.precision = (short)200;
   ttArg.tag = NULL;
   ttArg.name = "NIL:";
   lastCP = FAILURE;
   strcpy(lastVendor, "");
   (void)ConvertT1toTT(&ttArg, &t1Arg, NTCheckCopyright, NULL);
   strncpy(szVendor, lastVendor, wSize);
   szVendor[MIN(wSize, strlen(lastVendor))] = '\0';
  
   return lastCP;
}


short STDCALL CheckCopyrightA(char *szPFB,
                              DWORD wSize,
                              char *szVendor)
{
    short iRet;

    try
    {
        iRet = CheckCopyrightAInternal(szPFB,wSize,szVendor);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        iRet = BADINPUTFILE;
    }
    return iRet;

}






/******************************Public*Routine******************************\
*
* short STDCALL CheckInfA (
*
* If pfm and inf files are in the same directory only pfm is recognized
* and inf file is ignored.
*
* History:
*  27-Apr-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*           FVS_FILE_BUILD_ERR  
*           FVS_FILE_EXISTS
*           FVS_INSUFFICIENT_BUF
*
\**************************************************************************/


short CreatePFM(char *pszINF, char *pszAFM, char *pszPFM);
BOOL bGetDescFromInf(char * pszINF, DWORD cjDesc, char *pszDesc);

BOOL bFileExists(char *pszFile)
{
    HFILE hf;

    if ((hf = _lopen(pszFile, OF_READ)) != -1)
    {
        _lclose(hf);
        return TRUE;
    }

    return FALSE;
}

short STDCALL CheckInfA (
    char *pszINF,
    DWORD cjDesc,
    char *pszDesc,
    DWORD cjPFM,
    char *pszPFM,
    DWORD cjPFB,
    char *pszPFB,
    BOOL *pbCreatedPFM,
    char *pszFontPath
)
{
    char achPFM[MAX_PATH];
    char achPFB[MAX_PATH];
    char achAFM[MAX_PATH];

    DWORD  cjKey;
    char *pszParent = NULL; // points to the where parent dir of the inf file is
    char *pszBare = NULL; // "bare" .inf name, initialization essential
    short result = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
    BOOL bAfmExists = FALSE;
    BOOL bPfbExists = FALSE;

    //
    // This is a real hack use of pbCreatedPFM.
    // It's the best solution with the time we have.
    //
    BOOL bCheckForExistingPFM = *pbCreatedPFM;

    *pbCreatedPFM = FALSE;

// example:
// if pszINF -> "c:\psfonts\fontinfo\foo_____.inf"
// then pszParent -> "fontinfo\foo_____.inf"

    cjKey = strlen(pszINF) + 1;

    if (cjKey < 5)          // 5 = strlen(".pfm") + 1;
        return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_INF);

// check if a pfm file exists in the SAME directory.
// Use the buffer on the stack to produce the path for the pfm file:

    strcpy(achPFM, pszINF);
    strcpy(&achPFM[cjKey - 5],".PFM");

// try to open pfm file to check if it exists:

    if (bCheckForExistingPFM && bFileExists(achPFM))
    {
    // we found the pfm file, therefore we do not report this .inf file.

        return FVS_MAKE_CODE(FVS_FILE_EXISTS, FVS_FILE_PFM);
    }

// pfm file is NOT found, go on to check if .afm and .pfb files exists:
// We will first check if .afm and .pfb files exists in the same dir as .inf

    strcpy(achAFM, pszINF);
    strcpy(&achAFM[cjKey - 5],".AFM");

    strcpy(achPFB, pszINF);
    strcpy(&achPFB[cjKey - 5],".PFB");

    bAfmExists = bFileExists(achAFM);
    bPfbExists = bFileExists(achPFB);

    if (!bAfmExists || !bPfbExists)
    {
    // we did not find the .afm and .pfb files in the same dir as .inf
    // we will check two more directories for the .afm and .pfb files
    // 1) the parent directory of the .inf file for .pfb file
    // 2) the afm subdirectory of the .inf parent directory for .afm file
    //
    // This is meant to handle the standard configuration of files produced
    // on user's hard drive by unlocking fonts from Adobe's CD or from a
    // previous installation of atm manager on this machine.
    // This configuration is as follows:
    // c:\psfonts\           *.pfb files are here
    // c:\psfonts\afm        *.afm files are here
    // c:\psfonts\fontinfo   *.inf files are here
    // c:\psfonts\pfm        *.pfm files that are created on the fly
    //                         are PUT here by atm.
    // We will instead put the files in windows\system dir where all other
    // fonts are, it may not be possible to write pmf files on the media
    // from where we are installing fonts

        pszBare = &pszINF[cjKey - 5];
        for ( ; pszBare > pszINF; pszBare--)
        {
            if ((*pszBare == '\\') || (*pszBare == ':'))
            {
                pszBare++; // found it
                break;
            }
        }

    // check if full path to .inf file was passed in or a bare
    // name itself was passed in to look for .inf file in the current dir

        if ((pszBare > pszINF) && (pszBare[-1] == '\\'))
        {
        // skip '\\' and search backwards for another '\\':

            for (pszParent = &pszBare[-2]; pszParent > pszINF; pszParent--)
            {
                if ((*pszParent == '\\') || (*pszParent == ':'))
                {
                    pszParent++; // found it
                    break;
                }
            }

        // create .pfb file name in the .inf parent directory:

            strcpy(&achPFB[pszParent - pszINF], pszBare);
            strcpy(&achPFB[strlen(achPFB) - 4], ".PFB");

        // create .afm file name in the afm subdirectory of the .inf
        // parent directory:

            strcpy(&achAFM[pszParent - pszINF], "afm\\");
            strcpy(&achAFM[pszParent - pszINF + 4], pszBare);
            strcpy(&achAFM[strlen(achAFM) - 4], ".AFM");

        }
        else if (pszBare == pszINF)
        {
        // bare name was passed in, to check for the inf file in the "." dir:

            strcpy(achPFB, "..\\");
            strcpy(&achPFB[3], pszBare);   // 3 == strlen("..\\")
            strcpy(&achPFB[strlen(achPFB) - 4], ".PFB");

            strcpy(achAFM, "..\\afm\\");
            strcpy(&achAFM[7], pszBare);   // 7 == strlen("..\\afm\\")
            strcpy(&achAFM[strlen(achAFM) - 4], ".AFM");
        }
        else
        {
            return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);
        }

   // check again if we can find the files, if not fail.

       if (!bAfmExists && !bFileExists(achAFM))
          return FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_AFM);
       if (!bPfbExists && !bFileExists(achPFB))
          return FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_PFB);
    }

// now we have paths to .inf .afm and .pfb files. Now let us see
// what the caller wants from us:

    if (pszDesc)
    {
    // we need to return description string in the buffer supplied

        if (!bGetDescFromInf(pszINF, (DWORD)cjDesc, pszDesc))
            return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_INF);
    }

// copy pfb file path out if requested

    if (pszPFB)
    {
        if ((strlen(achPFB) + 1) < cjPFB)
            strcpy(pszPFB,achPFB);
        else
            return FVS_MAKE_CODE(FVS_INSUFFICIENT_BUF, FVS_FILE_UNK); 
    }

// the caller wants a pfm file created from inf,afm files
// For now and probably for ever we will put this file in
// the %windir%\system, or %windir%\fonts for the secure system.

    if (pszPFM)
    {
        UINT cjSystemDir;
        char *pszAppendHere;  // append "bare" name here

    // copy the first directory of the font path into the buffer provided
    // It is expected that this routine will get something like
    // "c:\foo" pointing to font path

        strcpy(achPFM,pszFontPath);
        pszAppendHere = &achPFM[strlen(pszFontPath) - 1];

        if (*pszAppendHere != '\\')
        {
             pszAppendHere++;
            *pszAppendHere = '\\';
        }
        pszAppendHere++;

    // find bare name of the .inf file if we do not have already:

        if (!pszBare)
        {
            pszBare = &pszINF[cjKey - 5];
            for ( ; pszBare > pszINF; pszBare--)
            {
                if ((*pszBare == '\\') || (*pszBare == ':'))
                {
                    pszBare++; // found it
                    break;
                }
            }
        }

    // append Bare name to the %windir%system\ path

        strcpy(pszAppendHere, pszBare);

    // finally change .inf extension to .pfm extension

        strcpy(&pszAppendHere[strlen(pszAppendHere) - 4], ".PFM");

    // copy out:

        strcpy(pszPFM, achPFM);
        
        result = CreatePFM(pszINF, achAFM, pszPFM);
        *pbCreatedPFM = (FVS_STATUS(result) == FVS_SUCCESS);

        if (!(*pbCreatedPFM))
            return result;
    }

    return FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
}


/******************************Public*Routine******************************\
*
* short STDCALL CheckType1AInternal
*
* Effects: See if we are going to report this as a valid type 1 font
*
* Warnings:
*
* History:
*  29-Apr-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*           FVS_FILE_BUILD_ERR
*           FVS_INVALID_ARG
*           FVS_FILE_IO_ERR
*           FVS_BAD_VERSION
*           FVS_FILE_EXISTS
*           FVS_INSUFFICIENT_BUF
*
\**************************************************************************/


short STDCALL CheckType1AInternal (
    char *pszKeyFile,
    DWORD cjDesc,
    char *pszDesc,
    DWORD cjPFM,
    char *pszPFM,
    DWORD cjPFB,
    char *pszPFB,
    BOOL *pbCreatedPFM,
    char *pszFontPath

)
{
    DWORD  cjKey;

    *pbCreatedPFM = FALSE; // initialization is essential.

    cjKey = strlen(pszKeyFile) + 1;

    if (cjKey < 5)          // 5 = strlen(".pfm") + 1;
        return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);

    if (!_strcmpi(&pszKeyFile[cjKey - 5], ".PFM"))
    {
    // copy out pfm string when asked to do so:

        if (pszPFM && (cjKey < cjPFM))
        {
            if (cjKey < cjPFM)
                strcpy(pszPFM, pszKeyFile);
            else
                return FVS_MAKE_CODE(FVS_INSUFFICIENT_BUF, FVS_FILE_UNK);
        }

        return CheckPfmA(
                   pszKeyFile,
                   cjDesc,
                   pszDesc,
                   cjPFB,
                   pszPFB
                   );
    }
    else if (!_strcmpi(&pszKeyFile[cjKey - 5], ".INF"))
    {
        return CheckInfA (
                   pszKeyFile,
                   cjDesc,
                   pszDesc,
                   cjPFM,
                   pszPFM,
                   cjPFB,
                   pszPFB,
                   pbCreatedPFM,
                   pszFontPath
                   );
    }
    else
    {
    // this font is not our friend

        return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);
    }
}


/******************************Public*Routine******************************\
*
* CheckType1WithStatusA, try / except wrapper
*
* Effects:
*
* Warnings:
*
* History:
*  14-Jun-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*           FVS_FILE_BUILD_ERR
*           FVS_INVALID_ARG
*           FVS_FILE_IO_ERR
*           FVS_BAD_VERSION
*           FVS_FILE_EXISTS
*           FVS_INSUFFICIENT_BUF
*           FVS_EXCEPTION
*         
\**************************************************************************/

short STDCALL CheckType1WithStatusA (
    char *pszKeyFile,
    DWORD cjDesc,
    char *pszDesc,
    DWORD cjPFM,
    char *pszPFM,
    DWORD cjPFB,
    char *pszPFB,
    BOOL *pbCreatedPFM,
    char *pszFontPath
)
{
    short status;
    try
    {
        status = CheckType1AInternal (
                   pszKeyFile,
                   cjDesc,
                   pszDesc,
                   cjPFM,
                   pszPFM,
                   cjPFB,
                   pszPFB,
                   pbCreatedPFM,
                   pszFontPath);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = FVS_MAKE_CODE(FVS_EXCEPTION, FVS_FILE_UNK);
    }

    return status;
}

/******************************Public*Routine******************************\
*
* CheckType1A, try / except wrapper
*
* Effects:
*
* Warnings:
*
* History:
*  14-Jun-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL STDCALL CheckType1A (
    char *pszKeyFile,
    DWORD cjDesc,
    char *pszDesc,
    DWORD cjPFM,
    char *pszPFM,
    DWORD cjPFB,
    char *pszPFB,
    BOOL *pbCreatedPFM,
    char *pszFontPath
)
{
    short status = CheckType1WithStatusA(pszKeyFile,
                                         cjDesc,
                                         pszDesc,
                                         cjPFM,
                                         pszPFM,
                                         cjPFB,
                                         pszPFB,
                                         pbCreatedPFM,
                                         pszFontPath);

    return (FVS_STATUS(status) == FVS_SUCCESS);
}


/******************************Public*Routine******************************\
*
* FindPfb, given pfm file, see if pfb file exists in the same dir or in the
* parent directory of the pfm file
*
* History:
*  14-Jun-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*
\**************************************************************************/


short STDCALL FindPfb (
    char *pszPFM,
    char *achPFB
)
{
    DWORD  cjKey;
    char *pszParent = NULL; // points to the where parent dir of the inf file is
    char *pszBare = NULL;   // "bare" .inf name, initialization essential

// example:
// if pszPFM -> "c:\psfonts\pfm\foo_____.pfm"
// then pszParent -> "pfm\foo_____.pfm"

    cjKey = strlen(pszPFM) + 1;

    if (cjKey < 5)          // 5 = strlen(".pfm") + 1;
        return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_PFM);

// go on to check if .pfb file exists:
// We will first check .pfb file exists in the same dir as .pfm

    strcpy(achPFB, pszPFM);
    strcpy(&achPFB[cjKey - 5],".PFB");

    if (!bFileExists(achPFB))
    {
    // we did not find the .pfb file in the same dir as .pfm
    // Now check the parent directory of the .pfm file

        pszBare = &pszPFM[cjKey - 5];
        for ( ; pszBare > pszPFM; pszBare--)
        {
            if ((*pszBare == '\\') || (*pszBare == ':'))
            {
                pszBare++; // found it
                break;
            }
        }

    // check if full path to .pfm was passed in or a bare
    // name itself was passed in to look for .pfm file in the current dir

        if ((pszBare > pszPFM) && (pszBare[-1] == '\\'))
        {
        // skip '\\' and search backwards for another '\\':

            for (pszParent = &pszBare[-2]; pszParent > pszPFM; pszParent--)
            {
                if ((*pszParent == '\\') || (*pszParent == ':'))
                {
                    pszParent++; // found it
                    break;
                }
            }

        // create .pfb file name in the .pfm parent directory:

            strcpy(&achPFB[pszParent - pszPFM], pszBare);
            strcpy(&achPFB[strlen(achPFB) - 4], ".PFB");

        }
        else if (pszBare == pszPFM)
        {
        // bare name was passed in, to check for the inf file in the "." dir:

            strcpy(achPFB, "..\\");
            strcpy(&achPFB[3], pszBare);   // 3 == strlen("..\\")
            strcpy(&achPFB[strlen(achPFB) - 4], ".PFB");
        }
        else
        {
            return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_PFM); // We should never get here.
        }

   // check again if we can find the file, if not fail.

       if (!bFileExists(achPFB))
       {
           return FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_PFB);
       }
    }

// now we have paths to .pfb file in the buffer provided by the caller.

    return FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\pfm.c ===
/***
**
**   Module: PFM
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font metrics file, by parsing
**      the data/commands found in a PFM file.
**
**      Please note that all data stored in a PFM file is represented
**      in the little-endian order.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"
#include "metrics.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "fileio.h"



/***** CONSTANTS */
/*-none-*/


/***** LOCAL TYPES */
/*-none-*/


/***** MACROS */
/*-none-*/


/***** STATIC FUNCTIONS */

/***
** Function: GetNextWord
**
** Description:
**   This function pulls two bytes from a file
**   and convert them into a 16-bit integer.
***/
static short GetNextWord(struct ioFile *file)
{
   short iWord;

   iWord = (short)io_ReadOneByte(file);
   iWord |= (short)(io_ReadOneByte(file) * 256);

   return(iWord);
}


/***
** Function: GetLong
**
** Description:
**   This function pulls four bytes from a file
**   and convert them into a 32-bit integer.
***/
static long GetLong(struct ioFile *file)
{
   short low;
   short high;


   low = GetNextWord(file);
   high = GetNextWord(file);

   return (long)((long)low+((long)high * 65535L));
}



/***
** Function: ReadString
**
** Description:
**   This function pulls a null terminated
**   string from the file.
***/
static void ReadString(UBYTE *dst, int size, struct ioFile *file)
{
   int i;

   i=0;
   while (io_FileError(file)==SUCCESS && i<size) {
      dst[i] = (UBYTE)io_ReadOneByte(file);
      if (dst[i]=='\0')
         break;
      i++;
   }
}






/***** FUNCTIONS */

/***
** Function: ReadPFMMetrics
**
** Description:
**   This function parses a Printer Font Metrics
**   (*.pfm) file. 
***/
errcode ReadPFMMetrics(const char *metrics, struct T1Metrics *t1m)
{
   errcode status = SUCCESS;
   struct ioFile *file;
   UBYTE buf[256];
   long kernoffset;
   long widthoffset;
   long etmoffset;
   long faceoffset;
   short ver;
   short i;

   if (metrics==NULL || (file = io_OpenFile(metrics, READONLY))==NULL) {
      status = NOMETRICS;
   } else {

      (void)io_ReadOneByte(file);     /* Skip the revision number. */
      ver = (short)io_ReadOneByte(file);

      if (ver>3) {
         SetError(status=UNSUPPORTEDFORMAT);
      } else {

         (void)GetLong(file);        /* dfSize */

         /* Get Copyright */
         if (t1m->copyright)
            Free(t1m->copyright);
         if ((t1m->copyright = Malloc(60))==NULL) {
            SetError(status=NOMEM);
         } else {
            (void)io_ReadBytes((UBYTE *)t1m->copyright, (USHORT)60, file);

            (void)GetNextWord(file);                      /* dfType */
            (void)GetNextWord(file);                      /* dfPoints */
            (void)GetNextWord(file);                      /* dfVertRes */
            (void)GetNextWord(file);                      /* dfHorizRes */
            t1m->ascent = GetNextWord(file);              /* dfAscent */
            t1m->intLeading = GetNextWord(file);          /* dfInternalLeading */
            t1m->extLeading = GetNextWord(file);          /* dfExternalLeading */
            (void)io_ReadOneByte(file);               /* dfItalic */
            (void)io_ReadOneByte(file);               /* dfUnderline */
            (void)io_ReadOneByte(file);               /* dfStrikeOut */
            t1m->tmweight = (USHORT)GetNextWord(file);    /* dfWeight */
            t1m->CharSet = (UBYTE)io_ReadOneByte(file);   /* dfCharSet */
            (void)GetNextWord(file);                      /* dfPixWidth */
            (void)GetNextWord(file);                      /* dfPixHeight */
            t1m->pitchfam = (UBYTE)io_ReadOneByte(file);/* dfPitchAndFamily */
            t1m->avgCharWidth = GetNextWord(file);        /* dfAvgWidth */
            (void)GetNextWord(file);                      /* dfMaxWidth */
            t1m->firstChar = (UBYTE)io_ReadOneByte(file);   /* dfFirstChar */
            t1m->lastChar = (UBYTE)io_ReadOneByte(file);    /* dfLastChar */
            t1m->DefaultChar = (UBYTE)io_ReadOneByte(file); /* dfDefaultChar */
            t1m->BreakChar   = (UBYTE)io_ReadOneByte(file); /* dfBreakChar */
            (void)GetNextWord(file);                      /* dfWidthBytes */
            (void)GetLong(file);                      /* dfDevice */
	    faceoffset = GetLong(file);             /* dfFace */
            (void)GetLong(file);                      /* dfBitsPointer */
            (void)GetLong(file);                      /* dfBitsOffset */
            (void)GetNextWord(file);                      /* dfSizeFields */
            etmoffset = GetLong(file);                /* dfExtMetricsOffset */
            widthoffset = GetLong(file);              /* dfExtentTable */
            (void)GetLong(file);                      /* dfOriginTable */
            kernoffset = GetLong(file);               /* dfPairKernTable */
            (void)GetLong(file);                      /* dfTrackKernTable */
	    (void)GetLong(file);                      /* dfDriverInfo */
            (void)GetLong(file);                      /* dfReserved */

            if (io_FileError(file)!=SUCCESS) {
               SetError(status = BADMETRICS);
            }

            /* Get extended type metrics */
            (void)io_FileSeek(file, etmoffset);

            (void)GetNextWord(file);             /* etmSize */
            (void)GetNextWord(file);             /* etmPointSize */
            (void)GetNextWord(file);             /* etmOrientation */
            (void)GetNextWord(file);             /* etmMasterHeight */
            (void)GetNextWord(file);             /* etmMinScale */
            (void)GetNextWord(file);             /* etmMaxScale */
            (void)GetNextWord(file);             /* etmMasterUnits */
            (void)GetNextWord(file);             /* etmCapHeight */
            (void)GetNextWord(file);             /* etmXHeight */
            (void)GetNextWord(file);             /* etmLowerCaseAscent */
            t1m->descent = GetNextWord(file);    /* etmLowerCaseDecent */
            (void)GetNextWord(file);             /* etmSlant */
            t1m->superoff = GetNextWord(file);   /* etmSuperScript */
            t1m->suboff = GetNextWord(file);     /* etmSubScript */
            t1m->supersize = GetNextWord(file);  /* etmSuperScriptSize */
            t1m->subsize = GetNextWord(file);    /* etmSubScriptSize */
            (void)GetNextWord(file);             /* etmUnderlineOffset */
            (void)GetNextWord(file);             /* etmUnderlineWidth */
            (void)GetNextWord(file);             /* etmDoubleUpperUnderlineOffset*/
            (void)GetNextWord(file);             /* etmDoubleLowerUnderlineOffset*/
            (void)GetNextWord(file);             /* etmDoubleUpperUnderlineWidth */
            (void)GetNextWord(file);             /* etmDoubleLowerUnderlineWidth */
            t1m->strikeoff = GetNextWord(file);  /* etmStrikeOutOffset */
            t1m->strikesize = GetNextWord(file); /* etmStrikeOutWidth */
            (void)GetNextWord(file);             /* etmNKernPairs */
            (void)GetNextWord(file);             /* etmNKernTracks */

            /* Get the advance width for the characters. */
            if ((t1m->widths = Malloc(sizeof(funit)*
                                      (t1m->lastChar -
                                       t1m->firstChar + 1)))==NULL) {
               SetError(status=NOMEM);
            } else {
               (void)io_FileSeek(file, widthoffset);
               for (i=0; i<=t1m->lastChar-t1m->firstChar; i++)
                  t1m->widths[i] = GetNextWord(file);

               if (io_FileError(file)!=SUCCESS) {
                  SetError(status = BADMETRICS);
               }
            }

            /* Get the face name. */
            if ((status==SUCCESS) && faceoffset) {
               (void)io_FileSeek(file, faceoffset);
               if (t1m->family)
                  Free(t1m->family);
               ReadString(buf, sizeof(buf), file);
               if (io_FileError(file)) {
                  SetError(status = BADMETRICS);
               } else {
                  if ((t1m->family = Strdup((char*)buf))==NULL) {
                     SetError(status=NOMEM);
                  }
               }
            }

            /* Get the pair-kerning the typeface. */
            if ((status==SUCCESS) && kernoffset) {
               (void)io_FileSeek(file, kernoffset);
               t1m->kernsize = (USHORT)GetNextWord(file);
               if (io_FileError(file)!=SUCCESS) {
                  SetError(status = BADMETRICS);
               } else {
                  if ((t1m->kerns = Malloc(sizeof(struct kerning)*
                                            t1m->kernsize))==NULL) {
                     SetError(status=NOMEM);
                  } else {
                     for (i=0; i<(int)t1m->kernsize; i++) {
                        t1m->kerns[i].left = (UBYTE)io_ReadOneByte(file);
                        t1m->kerns[i].right = (UBYTE)io_ReadOneByte(file);
                        t1m->kerns[i].delta = GetNextWord(file);
                     }

                     if (io_FileError(file)!=SUCCESS) {
                        SetError(status = BADMETRICS);
                     }
                  }
               }
            }
         }
      }

      if (io_CloseFile(file)!=SUCCESS)
         status = BADMETRICS;
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\version.h ===
/* All version strings and release dates are located in this file. */

char vFoundry[] = "3.20";
char dFoundry[] = "09/15/92";

char vMakebit[] = "3.20";
char dMakebit[] = "09/15/92";  /* bc14 with newptr bug fixed in cscan.c*/

char vMakeabf[] = "3.20";
char dMakeabf[] = "09/15/92";

char vMakeljf[] = "3.20";
char dMakeljf[] = "09/15/92";

char vMakepfm[] = "3.20";
char dMakepfm[] = "09/15/92";

char vMakevfm[] = "3.20";
char dMakevfm[] = "09/15/92";

char vMakewp5[] = "3.20";
char dMakewp5[] = "09/15/92";

char vMakeword[] = "3.20";
char dMakeword[] = "09/15/92";

char vMakefon[] = "3.20";
char dMakefon[] = "09/15/92";

char vMakepfon[] = "3.20";
char dMakepfon[] = "10/02/89";

char vUpdatwin[] = "3.20";
char dUpdatwin[] = "09/15/92";

char vCheckcnf[] = "3.20";
char dCheckcnf[] = "09/15/92";



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\winio.c ===
/***
**
**   Module: FileIO
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      is the interface towards all low level I/O functions that are
**      are available on the current platform.
**      This version of the module is written specifically for Win32,
**      and is based on "memory mapped files".
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <windows.h>

#undef IN

/* Special types and definitions. */
#include "t1instal.h"
#include "types.h"
#include "safemem.h"
#include "fileio.h"

/* Module dependent types and prototypes. */
/*-none-*/


/***** LOCAL TYPES */
struct ioFile {
   HANDLE file;
   HANDLE mapping;
   LPVOID data;
   UBYTE  *ptr;
   UBYTE  *max;
   DWORD  length;
   boolean output;
};


/***** CONSTANTS */
#define FILESIZE     65535L
#define BUFSIZE      8L * 1024L
#define BADSET_ERROR 0xffffffff

/***** MACROS */
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif
#define TRY if (1)
#define EXCEPT(v) else



/***** STATIC FUNCTIONS */
/*-none-*/




/***** FUNCTIONS */

struct ioFile *io_OpenFile(const char *name, const int mode)
{
   DWORD access;
   DWORD create;
   DWORD attr;
   DWORD prot;
   DWORD lowsize;
   DWORD mapaccess;
   SECURITY_ATTRIBUTES sa;
   struct ioFile *file;

   if ((file = Malloc(sizeof(struct ioFile)))!=NULL) {
      file->file = NULL;
      file->mapping = NULL;
      file->data = NULL;
      file->ptr = NULL;
      file->length = 0;

      if (mode == READONLY) {
         access = GENERIC_READ;
         create = OPEN_EXISTING;
         attr = FILE_ATTRIBUTE_NORMAL /*FILE_FLAG_SEQUENTIAL_SCAN*/;
         prot = PAGE_READONLY;
         lowsize = 0;
         mapaccess = FILE_MAP_READ;
         file->output = FALSE;
      } else {
         access = GENERIC_READ | GENERIC_WRITE;
         create = CREATE_ALWAYS;
         attr = FILE_ATTRIBUTE_NORMAL;
         prot = PAGE_READWRITE;
         lowsize = FILESIZE;
         mapaccess = FILE_MAP_ALL_ACCESS;
         file->output = TRUE;
      }
      sa.nLength = sizeof(sa);
      sa.lpSecurityDescriptor = NULL;
      sa.bInheritHandle = FALSE;
      if ((file->file = CreateFile(name, access, 0, &sa, create,
                                   attr, NULL))==INVALID_HANDLE_VALUE) {
         (void)io_CloseFile(file);
         SetLastError(0);
         file = NULL;
      } else {
         if ((file->mapping = CreateFileMapping(file->file, NULL,
                                                prot, 0, lowsize,
                                                NULL))==INVALID_HANDLE_VALUE) {
            (void)io_CloseFile(file);
            file = NULL;
         } else {
            if ((file->data = MapViewOfFile(file->mapping,
                                            mapaccess, 0, 0, 0))==NULL) {
               (void)io_CloseFile(file);
               file = NULL;
            } else {
               file->ptr = (UBYTE *)file->data;
               file->max = file->ptr;
               file->max = file->max + GetFileSize(file->file, NULL);
            }
         }
      }
   }

   return file;
}

errcode io_CloseFile(struct ioFile *file)
{
   errcode status = SUCCESS;

   if (file==NULL || file->data==NULL || file->file==0)
      status = FAILURE;


   if (file) {
      if ((DWORD)(file->ptr - (UBYTE *)file->data)>file->length)
         file->length = (long)(file->ptr - (UBYTE *)file->data);

      if (file->data){
         UnmapViewOfFile(file->data);
         file->data = NULL;
      }

      if (file->mapping) {
         CloseHandle(file->mapping);
         file->mapping = NULL;
      }

      if (file->file) {
         if (file->output) {
            if (SetFilePointer(file->file,
                               file->length,
                               0,
                               FILE_BEGIN)==BADSET_ERROR)
               status = FAILURE;
            else if (SetEndOfFile(file->file)==FALSE)
               status = FAILURE;

         }

         CloseHandle(file->file);
         file->file = NULL;
      }

      Free(file);
   }

   return status;
}


USHORT FASTCALL io_ReadOneByte(struct ioFile *file)
{
   USHORT byte;

   if (file->ptr<=file->max) {
      byte = (USHORT)*(file->ptr++);
   } else {
      SetLastError(ERROR_READ_FAULT);
      byte = ERROR_READ_FAULT;
   }

   return byte;
}

USHORT FASTCALL io_WriteBytes(const UBYTE *buf,
                              USHORT len,
                              struct ioFile *file)
{
   if ((file->ptr+len)<=file->max) {
      memcpy(file->ptr, buf, len);
      file->ptr = file->ptr + len;
   } else if (file->data) {
      long pos = io_FileTell(file);
      long size = MAX(GetFileSize(file->file, NULL),
                      MAX(file->length, (ULONG)(file->ptr -
                                                (UBYTE *)file->data)));

      /* Get rid of the old file mapping. */
      UnmapViewOfFile(file->data);
      file->data = NULL;
      CloseHandle(file->mapping);
      file->mapping = NULL;

      /* Get a new file mapping. */
      if ((file->mapping = CreateFileMapping(file->file, NULL,
                                               PAGE_READWRITE, 0,
                                               size + BUFSIZE,
                                               NULL))==INVALID_HANDLE_VALUE) {
         SetLastError(ERROR_WRITE_FAULT);
         file->ptr = file->max;
         len = 0;
      } else if ((file->data = MapViewOfFile(file->mapping,
                                             FILE_MAP_ALL_ACCESS,
                                             0, 0, 0))==NULL) {
         SetLastError(ERROR_WRITE_FAULT);
         file->ptr = file->max;
         len = 0;
      } else {
         file->ptr = (UBYTE *)file->data;
         file->max = (UBYTE *)file->data;
         file->max = file->max + size + BUFSIZE;
         io_FileSeek(file, pos);
         io_WriteBytes(buf, len, file);
      }
   }

   return len;
}

USHORT FASTCALL io_ReadBytes(UBYTE *buf, USHORT len, struct ioFile *file)
{
   if ((file->ptr+len)<=file->max) {
      memcpy(buf, file->ptr, len);
      file->ptr = file->ptr + len;
   } else {
      SetLastError(ERROR_READ_FAULT);
      len = 0;
   }

   return len;
}

boolean io_FileError(struct ioFile *file)
{
   return (boolean)GetLastError();
}


long FASTCALL io_FileTell(struct ioFile *file)
{
   return (long)(file->ptr - (UBYTE *)file->data);
}


long FASTCALL io_FileSeek(struct ioFile *file, long where)
{
   DWORD oldpos = (DWORD)(file->ptr - (UBYTE *)file->data);

   /* Keep track of the length of the file. */
   if (oldpos>file->length)
      file->length = oldpos;

   /* Fail if file is not mapped, or if we are jumping out of bounds. */
   if (file->data && (where>=0) &&
       ((UBYTE *)file->data+where) <= file->max) {
      file->ptr = (UBYTE *)file->data;
      file->ptr = file->ptr + where;
   } else {
      SetLastError(ERROR_SEEK);
   }

   return (long)oldpos;
}


/***
** Function: FileSeek
**
** Description:
***/
void FASTCALL io_RemoveFile(const char *name)
{
   DeleteFile(name);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\t1parser.c ===
/***
**
**   Module: T1Parser
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font file, by parsing
**      the data/commands found in PFB, PFM and AFM files.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <string.h>
#include "types.h"

/* Special types and definitions. */
#include "safemem.h"
#include "encoding.h"
#include "metrics.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "titott.h"
#include "t1parser.h"
#include "charstr.h"
#include "freader.h"
#include "mreader.h"


/***** CONSTANTS */
#define ONE       (USHORT)1
#define BUFLEN    (USHORT)512

#define PS_ANGLE              "/ItalicAngle"
#define PS_ARRAY              "array"
#define PS_BEGIN              "begin"
#define PS_BLUEFUZZ           "/BlueFuzz"
#define PS_BLUESCALE          "/BlueScale"
#define PS_BLUESHIFT          "/BlueShift"
#define PS_BLUEVALUES         "/BlueValues"
#define PS_CHARSTRINGS        "/CharStrings"
#define PS_COPYRIGHT          "/Copyright"
#define PS_DATE               "%%CreationDate:"
#define PS_DUP                "dup"
#define PS_ENCODING           "/Encoding"
#define PS_END                "end"
#define PS_FAMILY             "/FamilyName"
#define PS_FAMILYBLUES        "/FamilyBlues"
#define PS_FAMILYOTHERBLUES   "/FamilyOtherBlues"
#define PS_FONTMATRIX         "/FontMatrix"
#define PS_FORCEBOLD          "/ForceBold"
#define PS_FULLNAME           "/FullName"
#define PS_HYBRID             "hires"
#define PS_ISFIXED            "/isFixedPitch"
#define PS_LENIV              "/lenIV"
#define PS_NAME               "/FontName"
#define PS_NOACCESS           "noaccess"
#define PS_NOTICE             "/Notice"
#define PS_OTHERBLUES         "/OtherBlues"
#define PS_SNAPH              "/StemSnapH"
#define PS_SNAPV              "/StemSnapV"
#define PS_STDENCODING        "StandardEncoding"
#define PS_STDVW              "/StdVW"
#define PS_STDHW              "/StdHW"
#define PS_SUBRS              "/Subrs"
#define PS_UNDERLINE          "/UnderlinePosition"
#define PS_UTHICK             "/UnderlineThickness"
#define PS_ID                 "/UniqueID"
#define PS_VERSION            "/version"
#define PS_WEIGHT             "/Weight"



/***** LOCAL TYPES */

struct T1Handle {
   struct FontFile *ff;

   struct PSState *ps;

   struct Subrs stdenc[256];

   USHORT numsubrs;
   struct Subrs *subrs;
   USHORT leniv;
   struct T1Metrics t1m;
};


/***** MACROS */
/*-none-*/


/***** PROTOTYPES */
/*-none-*/

/***** STATIC FUNCTIONS */


/***
** Function: StrToFix
**
** Description:
**   This is a "strtod" function, that converts from
**   ascii to fixpoint numbers.
***/
static long StrToFix(char *str, char **out, const long base)
{
   char *fstr;
   long num = 0, frac = 0, exp = 0;

   if (out)
      (*out) = str;

   /* Skip white space. */
   while (*str && (*str==' ' || *str=='\t'))
      str++;

   /* A number? */
   if (*str && ((*str>='0' && *str<='9') || *str=='-') || *str=='.') {

      num = atoi(str)*base;

      /* Fraction? */
      fstr = strchr(str, '.');
      if (fstr!=NULL && (strchr(str, ' ')==NULL || fstr<strchr(str, ' '))) {

         do {
            fstr++;
         } while (*fstr>='0' && *fstr<='9');

         /* Exponent? */
         if (*fstr=='E')
            exp = atoi(fstr+1);
         else
            exp = 0;

         fstr--;
         while (*fstr!='.') {
            frac += ((*fstr)-'0')*base;
            frac /= 10;
            fstr--;
         }
         if (num<0)
            num -= frac;
         else
            num += frac;

         /* Handle exponent. */
         if (exp>0) {
            do {
               num *= 10;
            } while (--exp);
         } else if (exp<0) {
            do {
               num /= 10;
            } while (++exp);
         }
      }

      /* Skip digits. */
      while (*str && ((*str>='0' && *str<='9') ||
                      *str=='.' || *str=='-' || *str=='E'))
         str++;

      if (out)
         (*out) = str;
   }

   return num;
}



/***
** Function: FreeT1Composite
**
** Description:
**   This function frees the memory used to represent
**   a composite acented T1 glyph.
***/
static void FreeT1Composite(Composite *comp)
{
   if (comp) {
      if (comp->cchar)
         Free(comp->cchar);
      Free(comp);
   }
}


/***
** Function: UseGlyph
**
** Description:
**   This function determines whether a glyph should be
**   converted or not, based on the name of the glyph
**   and a specification of the desired glyphs.
***/
static int CDECL compare(const void *arg1, const void *arg2)
{
	return strcmp( *((const char **)arg1), *((const char **)arg2) );
}
static boolean UseGlyph(const struct GlyphFilter *filter,
                        Composite *comp,
                        const char *name)
{
   boolean found = FALSE;
   char **result;

   /* Check if the glyph is explicitly specified. */
   if (filter) {

      result = (char **)bsearch((char *)&name,
                                (char *)filter->name, filter->num,
                                sizeof(char *),
                                compare);


      found = (boolean)(result!=NULL);

      /* Check if the glyph is specified indirectly through an accented */
      /* composite glyph. */
      if (!found) {
         Composite *c;

         for (c=comp; c &&
                strcmp(name, c->achar) &&
                strcmp(name, c->bchar); c = c->next);
         found = (boolean)(c!=NULL);
      }
   } else {
      found = TRUE;
   }

   return found;
}



/***
** Function: ReadFontMatrix
**
** Description:
**   Read the command sequence "/FontMatrix[%d %d %d %d]" and
**   record the transformation matrix in the T1 handle.
***/
static errcode ReadFontMatrix(struct T1Handle *t1,
                              char *str,
                              const USHORT len)
{
   errcode status=SUCCESS;
   f16d16 fmatrix[6];
   USHORT i;

   if (GetSeq(t1->ff, str, len)) {
      for (i=0; i<6; i++)
         fmatrix[i] = StrToFix(str, &str, F16D16BASE);

      /* Check if we have the default matrix. */ /*lint -e771 */
      if (fmatrix[2]!=0 ||
          fmatrix[4]!=0 ||
          fmatrix[1]!=0 ||
          fmatrix[5]!=0 ||
          fmatrix[0]!=F16D16PPM ||
          fmatrix[3]!=F16D16PPM ||
          t1->t1m.upem!=2048) {  /*lint +e771 */ /* fmatrix[] IS initialized */

          if ((t1->t1m.fmatrix = Malloc(sizeof(f16d16)*6))==NULL) {
              SetError(status = NOMEM);
          } else {
            t1->t1m.fmatrix[0] = fmatrix[0];
            t1->t1m.fmatrix[1] = fmatrix[1];
            t1->t1m.fmatrix[2] = fmatrix[2];
            t1->t1m.fmatrix[3] = fmatrix[3];
            t1->t1m.fmatrix[4] = fmatrix[4];
            t1->t1m.fmatrix[5] = fmatrix[5];
         }
      } else {
         t1->t1m.fmatrix = NULL;
      }
   } else {
      SetError(status = BADINPUTFILE);
   }

   return status;
}


/***
** Function: ReadEncodingArray
**
** Description:
**   Read the command sequence "/Encoding %d array ..." and
**   build an encoding table, or read "/Encoding StdEncoding def"
**   and used the standard encoding table.
***/
static errcode ReadEncodingArray(struct T1Handle *t1,
                                 char *str,
                                 const USHORT len)
{
   errcode status = SUCCESS;
   USHORT codes[ENC_MAXCODES];
   char *glyph_name = NULL;
   USHORT i, index;

   if (Get_Token(t1->ff, str, len)==NULL) {
      SetError(status = BADINPUTFILE);
   } else {
      if (strcmp(str, PS_STDENCODING) &&
          ((t1->t1m.encSize=(USHORT)atoi(str))!=0)) {
         if ((t1->t1m.encoding = AllocEncodingTable(t1->t1m.encSize))==NULL) {
            SetError(status = NOMEM);
         } else {

            /* Skip leading proc. */
            while (Get_Token(t1->ff, str, len) && strcmp(str, PS_DUP));

            /* Read the encoding entries: "<n> <str> put <comment>\n dup" */
            for (i=0; i<t1->t1m.encSize; i++) {

               /* Get character code. */
               (void)Get_Token(t1->ff, str, len);
               if (str[0]=='8' && str[1]=='#') {   /* Octal? */
                  index = (USHORT)atoi(&str[2]);
                  index = (USHORT)((index/10)*8 + (index%8));
               } else {
                  index = (USHORT)atoi(str);
               }

               /* Get character name. */
               (void)Get_Token(t1->ff, str, len);

               codes[ENC_MSWINDOWS] = index;
               codes[ENC_UNICODE] = index;

               if (index<256) {
                  codes[ENC_STANDARD] = index;
                  codes[ENC_MACCODES] = index;
               } else {
                  codes[ENC_STANDARD] = NOTDEFCODE;
                  codes[ENC_MACCODES] = NOTDEFCODE;
               }
               if ((glyph_name = Strdup(&str[1]))!=NULL)
                  SetEncodingEntry(t1->t1m.encoding, i,
                                   glyph_name,
                                   ENC_MAXCODES,
                                   codes);
               else {
                  status = NOMEM;
                  break;
               }
               
               (void)Get_Token(t1->ff, str, len);   /* Pop "dup" */
               (void)Get_Token(t1->ff, str, len);   /* Pop "put" or comment. */
               if (str[0]=='%') {
                  (void)GetNewLine(t1->ff, str, len);
                  (void)Get_Token(t1->ff, str, len);   /* Pop "put". */
               }

               if (strcmp(str, PS_DUP))
                  break;
            }
            t1->t1m.encSize = (USHORT)(i+1);

            /* Rehash the table. */
            RehashEncodingTable(t1->t1m.encoding, t1->t1m.encSize);
         }
      }
   }

   return status;
}


/***
** Function: ReadArray
**
** Description:
**   Read an array.
***/
static errcode ReadArray(struct T1Handle *t1,
                         char *str,
                         const USHORT len,
                         funit *array,
                         USHORT maxarr,
                         USHORT *cnt)
{
   errcode status;
   char *nxt;

   if (GetSeq(t1->ff, str, len)) {
      (*cnt)=0;
      do {
         array[(*cnt)] = (funit)(((StrToFix(str, &nxt, 4L)+8002)>>2) - 2000);
         if (nxt==str)
            break;
         str = nxt;
      } while (++(*cnt)<maxarr);
      status=SUCCESS;
   } else {
      SetError(status = BADINPUTFILE);
   }

   return status;
}



/***
** Function: ReadFontSubrs
**
** Description:
**   Read the command sequence "/Subrs %d array dup %d %d RD %x ND ...",
**   decode and decrypt the subroutines and store them in the T1
**   handle.
***/
static errcode ReadFontSubrs(struct T1Handle *t1,
                             char *str, const USHORT len)
{
   errcode status = SUCCESS;
   USHORT index,i,j;
   USHORT count = 0;
   USHORT r;
   short b;

   /* Get the number of subroutines. */
   if (Get_Token(t1->ff, str, len)==NULL) {
      SetError(status = BADINPUTFILE);
   } else {
      count = (USHORT)atoi(str);

      /* Get the "array" keyword". */
      if ((Get_Token(t1->ff, str, len)==NULL) || strcmp(str, PS_ARRAY)) {
         SetError(status = BADINPUTFILE);
      } else {
         if ((t1->subrs = Malloc((USHORT)sizeof(struct Subrs)*count))==NULL) {
            SetError(status = NOMEM);
         } else {
            memset(t1->subrs, '\0', sizeof(struct Subrs)*count);
            t1->numsubrs = count;
            for (i=0; i<count; i++) {

               if (Get_Token(t1->ff, str, len)==NULL) {  /* Get "dup" */
                  SetError(status = BADINPUTFILE);
                  break;
               }
               if (strcmp(str, PS_DUP)) {
                  SetError(status = BADT1HEADER);
                  break;
               }

               if (Get_Token(t1->ff, str, len)==NULL) { /* Get Subr index. */
                  SetError(status=BADINPUTFILE);
                  break;
               }
               index = (USHORT)atoi(str);
               if (t1->subrs[index].code) {
                  LogError(MSG_WARNING, MSG_DBLIDX, NULL);
                  Free(t1->subrs[index].code);
               }

               if (Get_Token(t1->ff, str, len)==NULL) { /* Get length. */
                  SetError(status=BADINPUTFILE);
                  break;
               }
               t1->subrs[index].len = (USHORT)(atoi(str) - t1->leniv);
               if ((t1->subrs[index].code
                    = Malloc(t1->subrs[index].len))==NULL) {
                  SetError(status = NOMEM);
                  break;
               }

               if (Get_Token(t1->ff, str, len)==NULL) { /* Get RD + space */
                  SetError(status=BADINPUTFILE);
                  break;
               }
               /* Skip space. */
               (void)GetByte(t1->ff);

               /* Skip lenIV */
               r = 4330;
               for (j=0; j<t1->leniv; j++) {
                  b=GetByte(t1->ff);
                  (void)Decrypt(&r, (UBYTE)b);
               }
               if (status!=SUCCESS)
                  break;

               /* Get code. */
               for (j=0; j<t1->subrs[index].len; j++) {
                  b=GetByte(t1->ff);
                  t1->subrs[index].code[j] = Decrypt(&r, (UBYTE)b);
               }
               if (status!=SUCCESS)
                  break;

               if (Get_Token(t1->ff, str, len)==NULL) { /* Get ND */
                  SetError(status=BADINPUTFILE);
                  break;
               }
               /* Check for non-ATM compatible equivalent to 'ND' */
               if (!strcmp(str, PS_NOACCESS)) {
                  (void)Get_Token(t1->ff, str, len);
               }

            }
         }
      }
   }

   return status;
}





/***** FUNCTIONS */


/***
** Function: FlushWorkspace
**
** Description:
**   Free the resources allocated for the T1 handle.
***/
void FlushWorkspace(struct T1Handle *t1)
{
   USHORT i;

   /* Free /Subrs */
   if (t1->subrs) {
      for (i=0; i<t1->numsubrs; i++) {
         Free(t1->subrs[i].code);
      }
      Free(t1->subrs);
   }
   t1->subrs = NULL;
}   


/***
** Function: CleanUpT1
**
** Description:
**   Free the resources allocated for the T1 handle.
***/
errcode CleanUpT1(struct T1Handle *t1)
{
   errcode status = SUCCESS;
   AlignmentControl *align;
   Composite *next;
   Blues *blues;
   USHORT i;

   if (t1) {

      /* Free the PSState */
      if (t1->ps)
         FreePSState(t1->ps);

      /* Free /Subrs */
      if (t1->subrs) {
         for (i=0; i<t1->numsubrs; i++) {
            Free(t1->subrs[i].code);
         }
         Free(t1->subrs);
      }

      /* Clean up font file reader. */
      status = FRCleanUp(t1->ff);

      /* Clean up font matrix. */
      if (t1->t1m.fmatrix)
         Free(t1->t1m.fmatrix);

      /* Clean up seac. */
      while (t1->t1m.used_seac) {
         next = t1->t1m.used_seac->next;
         FreeT1Composite(t1->t1m.used_seac);
         t1->t1m.used_seac = next;
      }
      while (t1->t1m.seac) {
         next = t1->t1m.seac->next;
         FreeT1Composite(t1->t1m.seac);
         t1->t1m.seac = next;
      }

      /* Clean up stdenc. */
      for (i=0; i<256; i++) {
         if (t1->stdenc[i].code) {
            Free(t1->stdenc[i].code);
            t1->stdenc[i].code = NULL;
            t1->stdenc[i].len = 0;
         }
      }

      /* Clean up encoding table. */
      if (t1->t1m.encoding)
         FreeEncoding(t1->t1m.encoding, t1->t1m.encSize);

      /* Free strings */
      if (t1->t1m.date)
         Free(t1->t1m.date);
      if (t1->t1m.copyright)
         Free(t1->t1m.copyright);
      if (t1->t1m.name)
         Free(t1->t1m.name);
      if (t1->t1m.id)
         Free(t1->t1m.id);
      if (t1->t1m.notice)
         Free(t1->t1m.notice);
      if (t1->t1m.fullname)
         Free(t1->t1m.fullname);
      if (t1->t1m.weight)
         Free(t1->t1m.weight);
      if (t1->t1m.family)
         Free(t1->t1m.family);
      if (t1->t1m.widths)
         Free(t1->t1m.widths);
                if (t1->t1m.kerns)
                        Free(t1->t1m.kerns);
      if (t1->t1m.stems.vwidths)
         Free(t1->t1m.stems.vwidths);
      if (t1->t1m.stems.hwidths)
         Free(t1->t1m.stems.hwidths);
      blues = &(t1->t1m.blues);
      align = &(t1->t1m.blues.align);
      for (i=0; i<blues->blue_cnt/2; i++) {
         Free(align->top[i].pos);
      }
      for (i=0; i<blues->oblue_cnt/2; i++) {
         Free(align->bottom[i].pos);
      }

      /* Free handle. */
      Free(t1);
   }

   return status;
}



/***
** Function: InitT1Input
**
** Description:
**   Allocate and initiate a handle for a T1 font file, including
**   extracting data from the font prolog that is needed to
**   read the glyphs, such as /FontMatrix, /Subrs and /lenIV.
***/
errcode InitT1Input(const struct T1Arg *arg,
                    struct T1Handle **t1ref,
                    struct T1Metrics **t1mref,
                    const short (*check)(const char *,
                                         const char *,
                                         const char *))
{
   errcode status = SUCCESS;
   struct T1Handle *t1;
   struct PSState *ps;
   Blues *blues;
   boolean hybrid = FALSE;
   struct T1Metrics *t1m = NULL;
   char str[BUFLEN];
   USHORT i;

   /* Allocate the handle. */
   if (((*t1ref)=Malloc((USHORT)sizeof(struct T1Handle)))==NULL ||
       (ps = AllocPSState())==NULL) {
      if ((*t1ref)) {
         Free((*t1ref));
         *t1ref = NULL;
      }
      SetError(status = NOMEM);
   } else {

      /* Initiate the T1 record. */
      t1 = (*t1ref);
      t1m = &t1->t1m;
      (*t1mref) = t1m;
      blues = GetBlues(t1m);
      memset(t1, '\0', sizeof(*t1));
      t1->ps = ps;
      t1->leniv = 4;
      t1m->upem = arg->upem;
      t1m->defstdhw = 70;
      t1m->defstdvw = 80;

      blues->blueScale = 39;   /* Should really be 39.625 */
      blues->blueFuzz = 1;
      blues->blueShift = 7 * F8D8;
      blues->align.cvt = 3;
      t1m->stems.storage = 15;

      /* Initiate font file reader. */
      if ((status=FRInit(arg->name, pfb_file, &t1->ff))==SUCCESS) {

         /* Read /FontMatrix and /Subrs. */
         while (status==SUCCESS) {
            if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
               SetError(status=BADINPUTFILE);

               /**** /ForceBold true def ****/
            } else if (!strcmp(str, PS_FORCEBOLD)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  if (!strcmp(str, "true") || !strcmp(str, "True"))
                     t1m->forcebold = TRUE;
                  else
                     t1m->forcebold = FALSE;
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }

               /**** /BlueFuzz 1 def ****/
            } else if (!strcmp(str, PS_BLUEFUZZ)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  blues->blueFuzz = (UBYTE)atoi(str);
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }

               /**** /BlueScale 0.043625 def ****/
            } else if (!strcmp(str, PS_BLUESCALE)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  str[5] = '\0';
                  blues->blueScale = (UBYTE)atoi(&str[2]);
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }

               /**** /BlueShift 7 def ****/
            } else if (!strcmp(str, PS_BLUESHIFT)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  blues->blueShift = (short)StrToFix(str, NULL, (long)F8D8);
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }

               /**** /Encoding StandardEncodind def ****/
            } else if (!strcmp(str, PS_ENCODING)) {
               status = ReadEncodingArray(t1, str, BUFLEN);

               /**** /StdVW [118] def ****/
            } else if (!strcmp(str, PS_STDVW)) {
               USHORT dummy;
               status = ReadArray(t1, str, BUFLEN,
                                  &t1m->stdvw, ONE, &dummy);


               /**** /StdHW [118] def ****/
            } else if (!strcmp(str, PS_STDHW)) {
               USHORT dummy;
               status = ReadArray(t1, str, BUFLEN,
                                  &t1m->stdhw, ONE, &dummy);

               /**** /StemSnapV [118 120] def ****/
            } else if (!strcmp(str, PS_SNAPV)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &t1m->stemsnapv[0],
                                  MAXSNAP, &t1m->snapv_cnt);

               /* Add space for the snap enties in the CV table. */
               if (status==SUCCESS)
                  blues->align.cvt = (USHORT)(blues->align.cvt +
                                             t1m->snapv_cnt);

               /**** /StemSnapH [118 120] def ****/
            } else if (!strcmp(str, PS_SNAPH)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &t1m->stemsnaph[0],
                                  MAXSNAP, &t1m->snaph_cnt);

               /* Add space for the snap enties in the CV table. */
               if (status==SUCCESS)
                  blues->align.cvt = (USHORT)(blues->align.cvt +
                                              t1m->snaph_cnt);

               /**** /BlueValues [-15 0] def ****/
            } else if (!strcmp(str, PS_BLUEVALUES)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &(blues->bluevalues[0]),
                                  MAXBLUE, &(blues->blue_cnt));
               if (blues->blue_cnt%2)
                  SetError(status = BADINPUTFILE);

               /**** /OtherBlues [-15 0] def ****/
            } else if (!strcmp(str, PS_OTHERBLUES)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &(blues->otherblues[0]),
                                  MAXBLUE, &(blues->oblue_cnt));
               if (blues->oblue_cnt%2)
                  SetError(status = BADINPUTFILE);

               /**** /FamilyBlues [-15 0] def ****/
            } else if (!strcmp(str, PS_FAMILYBLUES)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &(blues->familyblues[0]),
                                  MAXBLUE, &(blues->fblue_cnt));

               /**** /FamilyOtherBlues [-15 0] def ****/
            } else if (!strcmp(str, PS_FAMILYOTHERBLUES)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &(blues->familyotherblues[0]),
                                  MAXBLUE, &(blues->foblue_cnt));

               /**** /CharString ... */
            } else if (!strcmp(str, PS_CHARSTRINGS)) {
               break;

               /**** /FontMatrix [0 0.001 0 0.001 0] def ****/
            } else if (GetFontMatrix(t1m)==NULL &&
                       !strcmp(str, PS_FONTMATRIX)) {
               status = ReadFontMatrix(t1, str, BUFLEN);
            } else if (!strcmp(str, PS_SUBRS)) {
               /* Discard prior lores /Subrs. */
               FlushWorkspace(t1);

               /* Read new subrs. */
               status = ReadFontSubrs(t1,str, BUFLEN);

               /**** /lenIV 4 def ****/
            } else if (!strcmp(str, PS_LENIV)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  t1->leniv = (USHORT)atoi(str);
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }
            } else if (t1m->date==NULL && !strcmp(str, PS_DATE)) {
               if ((GetNewLine(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->date=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->copyright==NULL &&
                       !strcmp(str, PS_COPYRIGHT)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->copyright=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->name==NULL && !strcmp(str, PS_NAME)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->name=Strdup(&str[1]))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->id==NULL && !strcmp(str, PS_ID)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->id=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->version.ver==0 && !strcmp(str, PS_VERSION)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else {
                  t1m->version.ver = (USHORT)atoi(str);
                  if (strchr(str, '.'))
                     t1m->version.rev = (USHORT)atoi(strchr(str, '.')+1);
                  else
                     t1m->version.rev = 0;
               }
            } else if (t1m->notice==NULL && !strcmp(str, PS_NOTICE)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->notice=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->fullname==NULL && !strcmp(str, PS_FULLNAME)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->fullname=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->family==NULL && !strcmp(str, PS_FAMILY)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->family=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->weight==NULL && !strcmp(str, PS_WEIGHT)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->weight=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->angle==0 && !strcmp(str, PS_ANGLE)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else 
                  t1m->angle = StrToFix(str, NULL, F16D16BASE);
            } else if (t1m->underline==0 && !strcmp(str, PS_UNDERLINE)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else
                  t1m->underline = (funit)StrToFix(str, NULL, 1L);
            } else if (t1m->uthick==0 && !strcmp(str, PS_UTHICK)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else
                  t1m->uthick = (funit)StrToFix(str, NULL, 1L);
            } else if (!strcmp(str, PS_ISFIXED)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else
                  if (!strcmp(str, "true") ||
                      !strcmp(str, "True") ||
                      !strcmp(str, "TRUE"))
                     t1m->fixedPitch = TRUE;
            } else if (!strcmp(str, PS_HYBRID)) {
               hybrid = TRUE;
            }
         }

         /* Change the baseline zone into an OtherBlues[] zone. */
         if (blues->blue_cnt) {
            blues->otherblues[blues->oblue_cnt++] = blues->bluevalues[0];
            blues->otherblues[blues->oblue_cnt++] = blues->bluevalues[1];
            for (i=2; i<blues->blue_cnt; i++)
               blues->bluevalues[i-2] = blues->bluevalues[i];
            blues->blue_cnt -= 2;
         }
         if (blues->fblue_cnt) {
            blues->familyotherblues[blues->foblue_cnt++]
                  = blues->familyblues[0];
            blues->familyotherblues[blues->foblue_cnt++]
                  = blues->familyblues[1];
            for (i=2; i<blues->fblue_cnt; i++)
               blues->familyblues[i-2] = blues->familyblues[i];
            blues->fblue_cnt -= 2;
         }

         /* Allocate the space for the blue buckets. */
         for (i=0; i<blues->blue_cnt; i+=2) {
            USHORT size = (USHORT)((ABS(blues->bluevalues[i+1] -
                                        blues->bluevalues[i]) +
                                    1 + 2*blues->blueFuzz)*
                                   (USHORT)sizeof(struct CVTPos));
            if ((blues->align.top[i/2].pos = Malloc(size))==NULL) {
               SetError(status = NOMEM);
               break;
            }

            /* Make sure that first value is larger than second value. */
            if (blues->bluevalues[i] > blues->bluevalues[i+1]) {
               LogError(MSG_WARNING, MSG_INVBLUES, NULL);
               SWAPINT(blues->bluevalues[i], blues->bluevalues[i+1]);
            }
         }
         for (i=0; i<blues->oblue_cnt; i+=2) {
            USHORT size = (USHORT)((ABS(blues->otherblues[i+1] -
                                        blues->otherblues[i]) +
                                    1 + 2*blues->blueFuzz)*
                                   (USHORT)sizeof(struct CVTPos));
            if ((blues->align.bottom[i/2].pos = Malloc(size))==NULL) {
               SetError(status = NOMEM);
               break;
            }

            /* Make sure that first value is larger than second value. */
            if (blues->otherblues[i] > blues->otherblues[i+1]) {
               LogError(MSG_WARNING, MSG_INVBLUES, NULL);
               SWAPINT(blues->otherblues[i], blues->otherblues[i+1]);
            }
         }


         /* Advance to the first glyph. */
         if (status==SUCCESS) {
            while (Get_Token(t1->ff, str, BUFLEN) &&
                   strcmp(str, PS_BEGIN));

            if (strcmp(str, PS_BEGIN)) {
               SetError(status = BADT1HEADER);
            }

            /* Skip lores chars if hybrid font. */
            if (status==SUCCESS && hybrid) {
               USHORT count;

               /* Skip Charstring dictionary. */
               do {
                  /* Glyph name, or end. */
                  if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
                     SetError(status = BADINPUTFILE);
                     break;
                  }
                  if (!strcmp(str, PS_END))
                     break;

                  /* Charstring length. */
                  if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
                     SetError(status = BADINPUTFILE);
                     break;
                  }
                  count = (USHORT)(atoi(str)+1);

                  /* Delimiter. */
                  if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
                     SetError(status = BADINPUTFILE);
                     break;
                  }

                  /* Charstring */
                  for (i=0; i<count; i++)
                     (void)GetByte(t1->ff);

                  /* Delimiter */
                  if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
                     SetError(status = BADINPUTFILE);
                     break;
                  }
               } while (status==SUCCESS);

               /* Skip to the beginning of next charstring. */
               while (Get_Token(t1->ff, str, BUFLEN) &&
                      strcmp(str, PS_BEGIN));

               if (strcmp(str, PS_BEGIN)) {
                  SetError(status = BADT1HYBRID);
               }
            }
         }
      }
   }

   if ((status==SUCCESS) && t1m && check(t1m->name,
                                         t1m->copyright,
                                         t1m->notice)!=SUCCESS)
      status = NOCOPYRIGHT;

   return status;
}



/***
** Function: GetT1Glyph
**
** Description:
**   The current file position of the T1 font file must be
**   at the begining of an entry in the /CharStrings dictionary.
**   The function will decode the font commands, parse them, and
**   finally build a representation of the glyph.
***/
errcode GetT1Glyph(struct T1Handle *t1,
                   struct T1Glyph *glyph,
                   const struct GlyphFilter *filter)
{
   errcode status = SUCCESS;
   /* struct encoding *enc; */
   char  str[BUFLEN];
   UBYTE *code;
   USHORT len;
   USHORT i;
   USHORT r = 4330;   
   short b;

   /* Get glyph name or end. */
   if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
      SetError(status = BADINPUTFILE);
   } else if (!strcmp(str, PS_END)) {
      status = DONE;
   } else if (str[0]!='/') {
      SetError(status = BADCHARSTRING);
   } else {
      if ((glyph->name = Strdup(&str[1]))==NULL) {
         SetError(status = NOMEM);
      } else {

         /* Get length of charstring. */
         (void)Get_Token(t1->ff, str, BUFLEN);
         len = (USHORT)atoi(str);

         /* Get RD + space */
         (void)Get_Token(t1->ff, str, BUFLEN);
         (void)GetByte(t1->ff);

         /* Get commands. */
         if (len<BUFLEN)
            code = (UBYTE *)str;
         else
            if ((code = Malloc(len*sizeof(UBYTE)))==NULL) {
               SetError(status = NOMEM);
            }

         if (code) {
            for (i=0; i<len; i++) {
               b = GetByte(t1->ff);
               code[i] = (UBYTE)Decrypt(&r, (UBYTE)b);
            }

            /* Parse commands. */
            if (status==SUCCESS) {
               if (t1->t1m.encoding!=NULL ||
                   UseGlyph(filter, t1->t1m.seac, glyph->name)) {
                  InitPS(t1->ps);
                  status = ParseCharString(glyph,
                                           &t1->t1m.seac,
                                           t1->ps,
                                           t1->subrs,
                                           &code[t1->leniv],
                                           (USHORT)(len-t1->leniv));

                  /* Skip normal conversion for the ".notdef" glyph. */
                  if (!strcmp(glyph->name, ".notdef"))
                     status = SKIP;

               } else {
                  status = SKIP;

               /***

               Two approaches are implemented for the management of
               composite glyphs:

               1) It is up to the client to specify a GlyphFilter such
               that all 'seac' characters has their dependent base and
               accent character in the filter as well.

               2) The converter manages a list of the dependent characters,
               which are converted when found.

               Approach 2) will typically cause the converter to use more
               memory than what is available in the small memory model,
               which is why the default is to disabled it.

               ***/


#if 0

                  /* Record StandardEncoding glyphs, for 'seac' */
                  if ((enc = LookupPSName(t1->t1m.encoding,
                                          t1->t1m.encSize,
                                          glyph->name)) &&
                      (i = LookupCharCode(enc, ENC_STANDARD))!=0) {
                     if ((t1->stdenc[i].code
                          = Malloc(len-t1->leniv))==NULL) {
                        SetError(status = NOMEM);
                     } else {
                        memcpy(t1->stdenc[i].code,
                               &code[t1->leniv],
                               sizeof(UBYTE) * (len - t1->leniv));
                        t1->stdenc[i].len = len - t1->leniv;
                     }
                  }
#endif
               }

               if (code!=(UBYTE *)str)
                  Free(code);

               /* Get ND */
               (void)Get_Token(t1->ff, str, BUFLEN);
            }
         }
      }
   }


   return status;
}



/***
** Function: FreeT1Glyph
**
** Description:
**   This function frees the memory used to represent
**   a glyph that has been translated.
***/
void FreeT1Glyph(T1Glyph *glyph)
{
   Flex *flex;
   Stem *stem;
   Stem3 *stem3;


   if (glyph->name)
      Free(glyph->name);
   while (glyph->hints.vstems) {
      stem = glyph->hints.vstems->next;
      Free(glyph->hints.vstems);
      glyph->hints.vstems = stem;
   }
   while (glyph->hints.hstems) {
      stem = glyph->hints.hstems->next;
      Free(glyph->hints.hstems);
      glyph->hints.hstems = stem;
   }
   while (glyph->hints.vstems3) {
      stem3 = glyph->hints.vstems3->next;
      Free(glyph->hints.vstems3);
      glyph->hints.vstems3 = stem3;
   }
   while (glyph->hints.hstems3) {
      stem3 = glyph->hints.hstems3->next;
      Free(glyph->hints.hstems3);
      glyph->hints.hstems3 = stem3;
   }
   while (glyph->hints.flex) {
      flex = glyph->hints.flex->next;
      Free(glyph->hints.flex);
      glyph->hints.flex = flex;
   }
   while (glyph->paths) {
      Outline *path = glyph->paths;
      glyph->paths = path->next;
      if (path->count) {
         Free(path->onoff);
         Free(path->pts);
      }
      Free(path);
   }
   memset((void *)glyph, '\0', sizeof(T1Glyph));
}



/***
** Function: GetT1Composite
**
** Description:
**   This function unlinks the first composite glyph
**   from the list of recorded composite glyphs, which
**   is returned to the caller.
***/
struct Composite  *GetT1Composite(struct T1Handle *t1)
{
   struct Composite *comp;

   comp = t1->t1m.seac;
   if (comp) {
      t1->t1m.seac = comp->next;
      comp->next = t1->t1m.used_seac;
      t1->t1m.used_seac = comp;
   }

   return comp;
}



/***
** Function: GetT1BaseGlyph
**
** Description:
**   This function parses the charstring code associated to the
**   base character of a composite character, if that glyph
**   is not already converted.
***/
errcode GetT1BaseGlyph(struct T1Handle *t1,
                       const struct Composite *comp,
                       struct T1Glyph *glyph)
{
   struct encoding *enc;
   struct Subrs *subr;
   errcode status = SUCCESS;

   if ((enc = LookupPSName(t1->t1m.encoding,
                           t1->t1m.encSize,
                           comp->bchar))==NULL) {
       LogError(MSG_WARNING, MSG_BADENC, comp->bchar);
       return SKIP;
   }

   subr = &t1->stdenc[LookupCharCode(enc, ENC_STANDARD)];

   if (subr->len==0) {
      status = SKIP; /* Missing or already done. */
   } else {
      InitPS(t1->ps);
      if ((glyph->name = Strdup((char*)comp->achar))==NULL) {
         SetError(status = NOMEM);
      } else {
         status = ParseCharString(glyph,
                                  &t1->t1m.seac,
                                  t1->ps,
                                  t1->subrs,
                                  subr->code,
                                  subr->len);
      }
      Free(subr->code);
      subr->code = NULL;
      subr->len = 0;
   }
   return status;
}



/***
** Function: GetT1AccentGlyph
**
** Description:
**   This function parses the charstring code associated to the
**   accent character of a composite character, if that glyph
**   is not already converted.
***/
errcode GetT1AccentGlyph(struct T1Handle *t1,
                         const struct Composite *comp,
                         struct T1Glyph *glyph)
{
   struct encoding *enc;
   struct Subrs *subr;
   errcode status = SUCCESS;

   if ((enc = LookupPSName(t1->t1m.encoding,
                           t1->t1m.encSize,
                           comp->achar))==NULL) {
       LogError(MSG_WARNING, MSG_BADENC, comp->achar);
       return SKIP;
   }

   subr = &t1->stdenc[LookupCharCode(enc, ENC_STANDARD)];

   if (subr->len==0) {
      status = SKIP; /* Missing or already done. */
   } else {
      InitPS(t1->ps);
      if ((glyph->name = Strdup((char *)comp->achar))==NULL) {
         SetError(status = NOMEM);
      } else {
         status = ParseCharString(glyph,
                                  &t1->t1m.seac,
                                  t1->ps,
                                  t1->subrs,
                                  subr->code,
                                  subr->len);
      }
      Free(subr->code);
      subr->code = NULL;
      subr->len = 0;
   }
   return status;
}



/***
** Function: ReadOtherMetrics
**
** Description:
**   Return font level information about the T1 font (mostly
**   metrics).
***/
errcode ReadOtherMetrics(struct T1Metrics *t1m,
                         const char *metrics)
{
   errcode status = SUCCESS;

   if ((status = ReadFontMetrics(metrics, t1m))==NOMETRICS) {
      t1m->flags = DEFAULTMETRICS;
      status = SUCCESS;
   } else {
      t1m->flags = USEMETRICS;
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\trans.c ===
/***
**
**   Module: Trans
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      contains functions that will convert T1 specific data into
**      corresponding TT data, such as hints and font metrics.
**
**   Author: Michael Jansson
**
**   Created: 5/28/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"
#include "trig.h"
#include "metrics.h"
#include "encoding.h"
#include "builder.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "trans.h"
#include "hints.h"


/***** CONSTANTS */

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

#define SWISS_LEADING       0x21
#define ROMAN_LEADING       0x11

#define NOCARE_PANOSE   0
#define NO_PANOSE       1
#define COVE_PANOSE     2
#define TEXT_PANOSE     2
#define DECORATIVE_PANOSE 4
#define SCRIPT_PANOSE   3
#define SANS_PANOSE     11
#define FIXED_PANOSE    9



#define BUFMARG      64
#define CLIMIT    8
#define CLIMIT2      4

#define SUBDIVIDE 0
#define CONVERT      1

#define FW_THIN         100
#define FW_EXTRALIGHT   200
#define FW_LIGHT  300
#define FW_NORMAL 400
#define FW_MEDIUM 500
#define FW_SEMIBOLD     600
#define FW_BOLD         700
#define FW_BLACK  900

#define FWIDTH_ULTRA_CONDENSED   1
#define FWIDTH_EXTRA_CONDENSED   2
#define FWIDTH_CONDENSED         3
#define FWIDTH_SEMI_CONDENSED    4
#define FWIDTH_NORMAL            5
#define FWIDTH_SEMI_EXPANDED     6
#define FWIDTH_EXPANDED          7
#define FWIDTH_EXTRA_EXPANDED    8
#define FWIDTH_ULTRA_EXPANDED    9

#define MAC_ITALIC   0x01
#define MAC_BOLD  0x02

#define FS_ITALIC 0x01
#define FS_BOLD      0x20
#define FS_NORMAL 0x40

#define CVTSIZE     5


/***** LOCAL TYPES */
/* None */


/***** MACROS */
#define ATMSCALE(v)  (((v)*31)/32)
#define IP(v,x1,x2,x1p,x2p)   /*lint -e776 */(short)((long)(v-x1)*(long)(x2p-x1p)/(long)(x2-x1)+(long)x1p)/*lint +e776*/

#define ADDCVT(val)   ttm->cvt[ttm->cvt_cnt++] = (short)(val)

#define SGN(v)   ((v)>0 ? 1 : -1)
#define DIR(v,w)  (char)((ABS((v)-(w))<16) ? 0 : SGN((w) - (v)))


/***** PROTOTYPES */
static USHORT SplitSpline(Point *pts, ULONG *onoff,
                          int i, USHORT length,
                          const funit x0, const funit y0,
                          const funit x1, const funit y1, 
                          const funit x2, const funit y2, 
                          const funit x3, const funit y3,
                          const int delta);


/***** STATIC FUNCTIONS */

/***
** Function: LookupComposite
**
** Description:
**   
***/
static struct encoding *LookupComposite(struct Composite *comp, char *name)
{
   while (comp) {
      if (comp->oenc && !strcmp(LookupCharName(comp->oenc), name))
         return comp->oenc;
      comp=comp->next;
   }

   return NULL;
}



/***
** Function: norm
**
** Description:
**   Normalize an angle so that it falls within the
**   range ~[-pi, pi]
***/
static int norm(int a)
{
   if (a>PI)
      a -= 2*PI;
   if (a<-PI)
      a += 2*PI;

   return ABS(a)/16;
}


/***
** Function: CompareCurves
**
** Description:
**   Make a estimate of the error between a cubic
**   and a quadric curve, given four control points,
**   and suggest an action (sub-division or convertion).
***/
static boolean FASTCALL CompareCurves(const funit x0, const funit y0,
                                      const funit x1, const funit y1, 
                                      const funit x2, const funit y2, 
                                      const funit x3, const funit y3,
                                      const funit nx, const funit ny,
                                      const int delta)
{
   int a, b;



   if ((ABS(ny-y0)>CLIMIT || ABS(nx-x0)>CLIMIT) &&
       (ABS(ny-y3)>CLIMIT || ABS(nx-x3)>CLIMIT)) {

      if (y0!=y1 || x0!=x1)
         a = norm(Atan2(ny-y0, nx-x0) - Atan2(y1-y0, x1-x0))
             * (ABS(ny-y0) + ABS(nx-x0));
      else if (y0!=y2 || x2!=x0)
         a = norm(Atan2(ny-y0, nx-x0) - Atan2(y2-y0, x2-x0))
             * (ABS(ny-y0) + ABS(nx-x0));
      else
         a = 0;

      if (a>=delta)
         return SUBDIVIDE;



      if (y2!=y3 || x2!=x3)
         b = norm(Atan2(y3-ny, x3-nx) - Atan2(y3-y2, x3-x2))
             * (ABS(ny-y0) + ABS(nx-x0));
      else if (y1!=y3 || x1!=x3)
         b = norm(Atan2(y3-ny, x3-nx) - Atan2(y3-y1, x3-x1))
             * (ABS(ny-y0) + ABS(nx-x0));
      else
         b = 0;


      if (b>=delta)    /* angle too big. */
         return SUBDIVIDE;
   }

   return CONVERT;
}



/***
** Function: ConvertSpline
**
** Description:
**   This function adds a spline to the current contour, by first
**   converting it from a cubic to a quadric spline.
***/
static USHORT ConvertSpline(Point *pts, ULONG *onoff,
                            USHORT length, int i,
                            const funit x0, const funit y0,
                            const funit x1, const funit y1, 
                            const funit x2, const funit y2, 
                            const funit x3, const funit y3,
                            const int delta)
{
   funit nx, ny;
   int oi = i;
   USHORT n = 0;

   ny = (funit)(((-y0+y1+y2+((y1+y2)<<1)-y3 + 4002)/4) - (short)1000);
   nx = (funit)(((-x0+x1+x2+((x1+x2)<<1)-x3 + 4002)/4) - (short)1000);
   if (CompareCurves(x0, y0,
                     x1, y1,
                     x2, y2,
                     x3, y3,
                     nx, ny, delta)==SUBDIVIDE) {
      n = SplitSpline(pts, onoff, i, length,
                      x0, y0, x1, y1, x2, y2, x3, y3, delta);
   } else /* CONVERT */ {
      if (i>1 && !OnCurve(onoff, i-2) &&
          (short)(pts[i-1].x >= pts[i-2].x) != (short)(pts[i-1].x >= nx) &&
          (short)(pts[i-1].y >= pts[i-2].y) != (short)(pts[i-1].y >= ny) &&
          (short)(pts[i-1].x >  pts[i-2].x) != (short)(pts[i-1].x > nx) &&
          (short)(pts[i-1].y >  pts[i-2].y) != (short)(pts[i-1].y > ny) &&
          ABS(pts[i-1].x - (nx+pts[i-2].x)/2)<CLIMIT2 && 
          ABS(pts[i-1].y - (ny+pts[i-2].y)/2)<CLIMIT2) {
      }
      SetOffPoint(onoff, i);
      pts[i].y = ny;
      pts[i].x = nx;
      i++;
      SetOnPoint(onoff, i);
      pts[i].y = y3;
      pts[i].x = x3;
      i++;

      n = (USHORT)(i-oi);
   }

   return n;
}



/***
** Function: SplitSpline
**
** Description:
**   This function converts a cubic spline by first
**   creating two new cubic splines, using de Casteljau's
**   algorithm, and then adding the two new splines to the
**   current path.
***/
static USHORT SplitSpline(Point *pts, ULONG *onoff,
                          int i, USHORT length,
                          const funit x0, const funit y0,
                          const funit x1, const funit y1, 
                          const funit x2, const funit y2, 
                          const funit x3, const funit y3,
                          const int delta)
{
   funit xt, yt;
   funit nx1, ny1;
   funit nx2, ny2;
   funit nx3, ny3;
   funit nx4, ny4;
   funit nx5, ny5;
   USHORT cnt;

   xt = (funit)(((x1+x2+8001)/2)-4000);
   yt = (funit)(((y1+y2+8001)/2)-4000);
   nx1 = (funit)(((x0+x1+8001)/2)-4000);
   ny1 = (funit)(((y0+y1+8001)/2)-4000);
   nx2 = (funit)(((nx1+xt+8001)/2)-4000);
   ny2 = (funit)(((ny1+yt+8001)/2)-4000);
   nx5 = (funit)(((x2+x3+8001)/2)-4000);
   ny5 = (funit)(((y2+y3+8001)/2)-4000);
   nx4 = (funit)(((nx5+xt+8001)/2)-4000);
   ny4 = (funit)(((ny5+yt+8001)/2)-4000);
   nx3 = (funit)(((nx2+nx4+8001)/2)-4000);
   ny3 = (funit)(((ny2+ny4+8001)/2)-4000);

   cnt = ConvertSpline(pts, onoff, length, i,
                       x0, y0,
                       (funit)nx1, (funit)ny1,
                       (funit)nx2, (funit)ny2,
                       (funit)nx3, (funit)ny3,
                       delta);
   cnt = (USHORT)(cnt + ConvertSpline(pts, onoff, length, i+cnt,
                                      (funit)nx3, (funit)ny3,
                                      (funit)nx4, (funit)ny4,
                                      (funit)nx5, (funit)ny5,
                                      x3, y3,
                                      delta));

   return cnt;
}




/***
** Function: FreeOutline
**
** Description:
**   This function frees the memory allocated for one 
**   contour.
**   
***/
static void FreeOutline(Outline *path)
{
   Outline *tmp;

   while (path) {
      tmp = path;
      path=path->next;
      Free(tmp->pts);
      Free(tmp->onoff);
      Free(tmp);
   }
}



/***
** Function: ConvertOutline
**
** Description:
**   This function converts an outline by replacing the
**   cubic splines with quadric splines, and by scaling the
**   coordinates to the desired em-height.
**   
***/
static errcode ConvertOutline(const struct T1Metrics *t1m,
                              Outline *src, Outline **dst,
                              const int delta,
                              short *sideboard)
{
   errcode status = SUCCESS;
   f16d16 *fmatrix;
   Outline *path;
   ULONG *onoff = NULL;
   Point *pts = NULL;
   USHORT count;
   USHORT i,j,n;
   USHORT tot = 0;
   USHORT t1tot = 0;


   /* Get the T1 font transformation matrix. */
   fmatrix = GetFontMatrix(t1m);

   while (src) {

      /* Skip paths with less than three points. */
      if (src->count<3) {
         t1tot = (USHORT)(t1tot + src->count);
         src = src->next;
         continue;
      }

      /* Allocate the needed resources */
      count = (USHORT)((src->count+BUFMARG)&~0x0f);
      path = Malloc(sizeof(Outline));
      pts = Malloc(count*sizeof(Point));
      onoff = Malloc(ONOFFSIZE(count));
      if (path==NULL || pts==NULL || onoff==NULL) {
         if (path)
            Free(path);
         if (pts)
            Free(pts);
         if (onoff)
            Free(onoff);
         FreeOutline((*dst));
         (*dst) = NULL;
         SetError(status = NOMEM);
         break;
      }
      memset(onoff, '\0', ONOFFSIZE(count));

      /* Convert the splines. */ /*lint -e771 */
      i=0;
      j=0;
      while (i<src->count) {
         char prev = DIR(src->pts[(i-2+src->count)%src->count].y,
                         src->pts[(i-1+src->count)%src->count].y);
         char this = DIR(src->pts[(i-1+src->count)%src->count].y,
                         src->pts[i].y);

         /* Double the local extremas so that diag-cntrl will work. */
         if (prev && this && prev!=this)
            pts[j++] = src->pts[(i-1+src->count)%src->count];

         if (OnCurve(src->onoff, i)) {
            pts[j++] = src->pts[i++];
         } else {
            /* pts[j] = pts[j-1]; j++; */
            n = ConvertSpline(pts, onoff, count, (int)j,
                              src->pts[i-1].x, src->pts[i-1].y,
                              src->pts[i-0].x, src->pts[i-0].y,
                              src->pts[i+1].x, src->pts[i+1].y,
                              src->pts[i+2].x, src->pts[i+2].y,
                              delta);

            /* Enforce horizontal and vertical tangents. */
            if (OnCurve(onoff, j-1)) {
               if (src->pts[i-1].x==src->pts[i-0].x)
                  pts[j].x = (funit)((pts[j].x + pts[j-1].x)/2);
               if (src->pts[i-1].y==src->pts[i-0].y)
                  pts[j].y = (funit)((pts[j].y + pts[j-1].y)/2);
            }
            if (src->pts[i+1].x==src->pts[i+2].x)
               pts[j+n-2].x = (funit)((pts[j+n-1].x + pts[j+n-2].x)/2);
            if (src->pts[i+1].y==src->pts[i+2].y)
               pts[j+n-2].y = (funit)((pts[j+n-2].y + pts[j+n-1].y)/2);

            j = (USHORT)(j + n);
            i += 3;
         }

         /* Both a line and a curve end with an on-curve point. */
         sideboard[t1tot+i-1] = (short)(j-1+tot);

         /* Extend the pts/onoff arrays. */
         if (j+BUFMARG/2>=count) {
            Point *newpts = NULL;
            ULONG *newonoff = NULL;

            count += BUFMARG;
            newpts = Realloc(pts, count*sizeof(Point));
            newonoff = Realloc(onoff, ONOFFSIZE(count));
            if (newpts==NULL || newonoff==NULL) {
               if (newonoff)
                  Free(newonoff);
               if (newpts)
                  Free(newpts);
               /*lint -e644 */
               if (onoff)
                  Free(onoff);
               if (pts)
                  Free(pts);
               /*lint +e644 */
               FreeOutline((*dst));
               (*dst) = NULL;
               SetError(status=NOMEM);
               break;
            }
            pts = newpts;
            onoff = newonoff;
         }
      }

      if (status!=SUCCESS)
         break;

      /* Scale the points. */
      TransAllPoints(t1m, pts, j, fmatrix);

      t1tot = (USHORT)(t1tot + src->count);
      src = src->next;

      (*dst) = path;
      path->next = NULL;
      path->pts = pts;
      path->onoff = onoff;
      path->count = (USHORT)j;  /*lint +e771 */
      dst = &(path->next);

      tot = (USHORT)(tot + j);
   }

   return status;
}

#ifdef MSDOS
#pragma auto_inline(off)
#endif
static long Mul2(long a, long b, long c, long d)
{
   return a*b+c*d;
}
#ifdef MSDOS
#pragma auto_inline(on)
#endif


/***** FUNCTIONS */

/***
** Function: TransAllPoints
**
** Description:
**   Translate a coordinate according to a transformation matrix.
***/
void FASTCALL TransAllPoints(const struct T1Metrics *t1m,
                             Point *pts,
                             const USHORT cnt,
                             const f16d16 *fmatrix)
{
   if (fmatrix==NULL) {
      register Point *p;
      register int i;

      i = cnt;
      p = pts;
      while (i--) {
         p->x = (funit)((p->x<<1)+(((p->x<<1)+
                                    p->x+(p->x/16)+
                                    8224)/64) - 128);
         p++;
      }
      i = cnt;
      p = pts;
      while (i--) {
         p->y = (funit)((p->y<<1)+(((p->y<<1)+
                                    p->y+
                                    (p->y/16)+
                                    8224)/64) - 128);
         p++;
      }

   } else {
      Point *p;
      int i;
      long u,v;

      i = cnt;
      p = pts;
      while (i--) {
         v = (GetUPEM(t1m) * (Mul2(fmatrix[0], (long)p->x,
                                   fmatrix[2], (long)p->y) +
                              fmatrix[4]) + F16D16HALF) / 524288L;
         u = (GetUPEM(t1m) * (Mul2(fmatrix[1], (long)p->x,
                                   fmatrix[3], (long)p->y) +
                              fmatrix[5]) + F16D16HALF) / 524288L;
         p->x = (funit)v;
         p->y = (funit)u;
         p++;
      }
   }
}



/***
** Function: TransX
**
** Description:
**   Translate a horizontal coordinate according to a transformation matrix.
***/
funit FASTCALL TransX(const struct T1Metrics *t1m, const funit x)
{
   f16d16 *fmatrix = GetFontMatrix(t1m);
   funit pos;

   if (fmatrix) {
      pos = (funit)((GetUPEM(t1m)* ATMSCALE(fmatrix[0] * x) +
                     F16D16HALF) / F16D16BASE);
   } else {
      pos = (funit)(((int)x<<1)-((((int)x+((int)x/64)+8224)/64) - 128));
   }

   return pos;
}


/***
** Function: TransY
**
** Description:
**   Translate a vertical coordinate according to a transformation matrix.
***/
funit FASTCALL TransY(const struct T1Metrics *t1m, const funit y)
{
   f16d16 *fmatrix = GetFontMatrix(t1m);
   funit pos;

   if (fmatrix) {
      pos = (funit)((GetUPEM(t1m)*fmatrix[3] * y +
                     F16D16HALF) / F16D16BASE);
   } else {
      pos = (funit)(((int)y<<1)+((((int)y<<1)+
                                  (int)y+
                                  ((int)y/16)+
                                  8224)/64) - 128);
   }

   return pos;
}


/***
** Function: ConvertGlyph
**
** Description:
**   This function convertes the data associated to a T1 font glyph
**   into the corresponding data used in a TT font glyph.
***/
errcode FASTCALL ConvertGlyph(struct T1Metrics *t1m,
                              const struct T1Glyph *t1glyph,
                              struct TTGlyph **ttglyph,
                              const int delta)
{
   errcode status = SUCCESS;
   struct encoding *code;

   if ((code = LookupPSName(CurrentEncoding(t1m),
                            EncodingSize(t1m),
                            t1glyph->name))==NULL &&
       (code = LookupComposite(Composites(t1m), t1glyph->name))==NULL &&
       strcmp(t1glyph->name, ".notdef")) {
      LogError(MSG_INFO, MSG_BADENC, t1glyph->name);
      status = SUCCESS;
   } else {

      if (((*ttglyph) = Malloc(sizeof(struct TTGlyph)))==NULL) {
         SetError(status = NOMEM);
      } else {
         short *sideboard = NULL;
         Outline *path;
         USHORT tot;

         memset((*ttglyph), '\0', sizeof(struct TTGlyph));
         if (t1glyph->width.y!=0) {
            LogError(MSG_WARNING, MSG_BADAW, NULL);
         }
         (*ttglyph)->aw = TransY(t1m, t1glyph->width.x);
         (*ttglyph)->lsb = TransY(t1m, t1glyph->lsb.x);
         (*ttglyph)->code = code;
         (*ttglyph)->num = 0;
         (*ttglyph)->twilights = 0;

         /* Initiate the side board. */
         for (path=t1glyph->paths, tot=0; path; path=path->next)
            tot = (USHORT)(tot + path->count);
         if (tot && (sideboard = Malloc((unsigned)tot*sizeof(short)))==NULL) {
            SetError(status=NOMEM);
         } else if ((status = ConvertOutline(t1m, t1glyph->paths,
                                             &((*ttglyph)->paths),
                                             delta,
                                             sideboard))==SUCCESS)
            status = ConvertHints(t1m,
                                  &t1glyph->hints,
                                  t1glyph->paths,
                                  (*ttglyph)->paths,
                                  sideboard,
                                  &(*ttglyph)->hints,
                                  &(*ttglyph)->num,
                                  &(*ttglyph)->stack,
                                  &(*ttglyph)->twilights);

         if (sideboard)
            Free(sideboard);


         /* Pick default std widths. */
         if (t1glyph->name[0]=='l' && t1glyph->name[1]=='\0') {
            if (GetStdVW(t1m)==0 && t1glyph->hints.vstems)
               SetDefStdVW(t1m, t1glyph->hints.vstems->width);
         }
         if (t1glyph->name[0]=='z' && t1glyph->name[1]=='\0') {
            if (GetStdHW(t1m)==0) {
               if (t1glyph->hints.hstems && t1glyph->hints.hstems->width)
                  SetDefStdHW(t1m, t1glyph->hints.hstems->width);
               else if (t1glyph->hints.vstems && t1glyph->hints.vstems->width)
                  SetDefStdHW(t1m, t1glyph->hints.vstems->width);
            }
         }
      }
   } 

   return status;
}


/***
** Function: ConvertComposite
**
** Description:
**   This function convertes the data associated to a T1 font seac glyph
**   into the corresponding data used in a TT font composite glyph.
**
***/
errcode FASTCALL ConvertComposite(struct T1Metrics *t1m,
                                  const struct Composite *comp,
                                  struct TTComposite *ttcomp)
{
   Point pt;

   pt.x = comp->adx;
   pt.y = comp->ady;
   TransAllPoints(t1m, &pt, 1, GetFontMatrix(t1m));
   ttcomp->dx = pt.x + (pt.x - TransX(t1m, comp->adx));
   ttcomp->dy = pt.y;
   ttcomp->aw = TransY(t1m, comp->aw);
   ttcomp->lsb = TransY(t1m, comp->asbx);
   ttcomp->aenc = LookupPSName(CurrentEncoding(t1m),
                               EncodingSize(t1m), comp->achar);
   ttcomp->benc = LookupPSName(CurrentEncoding(t1m),
                               EncodingSize(t1m), comp->bchar);
   if ((ttcomp->cenc = LookupPSName(CurrentEncoding(t1m),
                                    EncodingSize(t1m), comp->cchar))==NULL) {
      LogError(MSG_INFO, MSG_BADENC, comp->cchar);
   }
   ttcomp->oenc = comp->oenc;

   if (ttcomp->aenc && ttcomp->benc)
      return SUCCESS;
   return SKIP;
}





/***
** Function: ConvertMetrics
**
** Description:
**
***/
errcode FASTCALL ConvertMetrics(const struct TTHandle *tt,
                                struct T1Metrics *t1m,
                                struct TTMetrics *ttm,
                                const char *tag)
{
   const AlignmentControl *align;
   const Blues *blues;
   USHORT prep_size;
   UBYTE *prep = NULL;
   errcode status = SUCCESS;
   Point bbox[2];
   funit em;
   funit PostAsc;
   USHORT i, j;


   ttm->Encoding = CurrentEncoding(t1m);
   ttm->encSize = EncodingSize(t1m);
   ttm->version.ver = t1m->version.ver;
   ttm->version.rev = t1m->version.rev;

   if ((ttm->verstr = Malloc(strlen(tag)+4+1+4+1))==NULL) {
      SetError(status = NOMEM);
   } else {
      strcpy(ttm->verstr, tag);
      (void)_itoa((int)ttm->version.ver, &ttm->verstr[strlen(ttm->verstr)], 4);
      strcat(ttm->verstr, ".");
      (void)_itoa((int)ttm->version.rev, &ttm->verstr[strlen(ttm->verstr)], 4);
      ttm->created.a = 0;
      ttm->created.b = 0;
      ttm->family = t1m->family;
      ttm->copyright = t1m->copyright;
      ttm->name = t1m->name;
      ttm->id = t1m->id;
      ttm->notice = t1m->notice;
      ttm->fullname = t1m->fullname;
      ttm->weight = t1m->weight;
      ttm->angle = t1m->angle;
      ttm->underline = TransY(t1m, t1m->underline);
      ttm->uthick = TransY(t1m, t1m->uthick);
      ttm->usWidthClass = (USHORT)(strstr(t1m->fullname, "Ultra-condensed")
                                   ? FWIDTH_ULTRA_CONDENSED :
         ((strstr(t1m->fullname, "Extra-condensed") ? FWIDTH_EXTRA_CONDENSED :
            ((strstr(t1m->fullname, "Condensed") ? FWIDTH_CONDENSED :
               ((strstr(t1m->fullname, "Semi-condensed") ? FWIDTH_SEMI_CONDENSED :
                  ((strstr(t1m->fullname, "Semi-expanded")
                    ? FWIDTH_SEMI_EXPANDED :
                     ((strstr(t1m->fullname, "Expanded")
                       ? FWIDTH_EXPANDED :
                        ((strstr(t1m->fullname, "Extra-expanded")
                          ? FWIDTH_EXTRA_EXPANDED :
                           ((strstr(t1m->fullname, "Ultra-expanded")
                             ? FWIDTH_ULTRA_EXPANDED :
                              FWIDTH_NORMAL)))))))))))))));


      /* Window based metrics. */

      // ps driver does not compute asc and desc based on the
      // windows charset. So, we will not do it either. We will
      // also use the all glyhs supported in the font.
      // Ps driver acutally trusts the values found in .pfm file.
      // These values, according to afm->pfm converter code, are computed
      // over all glyphs. However, some vendors ship buggy pfm's with
      // zero ascenders or negative descenders. If we took these values
      // literally, as ps driver does, the true type driver would
      // shave off portions of glyphs and the conversion would appear broken.
      // Pcl printing and screen output would be totally broken.
      // Turns out that for these buggy fonts ATM on win31 also
      // corrects the value from .pfm files for screen and pcl printer.
      // [bodind]


      // total bbox: [bodind], replaced WindowsBBox function:

      GlobalBBox(tt, bbox);

      ttm->winAscender = ABS(bbox[1].y);
      ttm->winDescender = ABS(bbox[0].y);


      ttm->panose[0] = NOCARE_PANOSE;
      ttm->panose[1] = NOCARE_PANOSE;
      ttm->panose[2] = NOCARE_PANOSE;
      ttm->panose[3] = NOCARE_PANOSE;
      ttm->panose[4] = NOCARE_PANOSE;
      ttm->panose[5] = NOCARE_PANOSE;
      ttm->panose[6] = NOCARE_PANOSE;
      ttm->panose[6] = NOCARE_PANOSE;
      ttm->panose[7] = NOCARE_PANOSE;
      ttm->panose[8] = NOCARE_PANOSE;
      ttm->panose[9] = NOCARE_PANOSE;
      /* Fixed pitch fonts are not given a panose by ATM. */
      if (!(t1m->fixedPitch)) {
         switch (t1m->pitchfam & 0xf0) {
            case FF_DECORATIVE:
               ttm->panose[0] = (UBYTE)DECORATIVE_PANOSE;
               ttm->panose[1] = (UBYTE)NO_PANOSE;
               break;
            case FF_ROMAN:
               ttm->panose[0] = (UBYTE)TEXT_PANOSE;
               ttm->panose[1] = (UBYTE)COVE_PANOSE;
               break;
            case FF_SWISS:
               ttm->panose[0] = (UBYTE)TEXT_PANOSE;
               ttm->panose[1] = (UBYTE)SANS_PANOSE;
               break;
            case FF_SCRIPT:
               ttm->panose[0] = (UBYTE)SCRIPT_PANOSE;
               ttm->panose[1] = (UBYTE)SANS_PANOSE;
               break;
            case FF_MODERN:
               ttm->panose[0] = (UBYTE)TEXT_PANOSE;
               ttm->panose[1] = (UBYTE)SANS_PANOSE;
               break;
         }
      } 
      ttm->isFixPitched = t1m->fixedPitch;
      ttm->panose[2] = (UBYTE)((t1m->tmweight - 500) * 12 / 900 + 6);

      /* Mac based metrics. */
      MacBBox(tt, bbox);
      ttm->macLinegap = TransY(t1m, (funit)(t1m->extLeading +
                                            (ttm->winAscender +
                                             ttm->winDescender) -
                                            (bbox[1].y-bbox[0].y)));

      /* Typographical metrics. */
      ttm->emheight = GetUPEM(t1m);
      if (t1m->flags==DEFAULTMETRICS) {
         ttm->usWeightClass = (USHORT)(strstr(t1m->fullname, "Thin") ? FW_THIN :
            ((strstr(t1m->fullname, "light") ? FW_EXTRALIGHT :
               ((strstr(t1m->fullname, "Light") ? FW_LIGHT :
                  ((strstr(t1m->fullname, "Medium") ? FW_MEDIUM :
                     ((strstr(t1m->fullname, "emi-bold") ? FW_SEMIBOLD :
                        ((strstr(t1m->fullname, "Bold") ? FW_BOLD :
                           ((strstr(t1m->fullname, "Black") ? FW_BLACK :
                              FW_NORMAL)))))))))))));
         ttm->macStyle = (USHORT)(((ttm->usWeightClass>FW_MEDIUM)?MAC_BOLD : 0) |
                         ((ttm->angle != 0) ? MAC_ITALIC : 0));
         ttm->fsSelection = (USHORT)(((ttm->angle != 0) ? FS_ITALIC : 0) |
                            ((ttm->usWeightClass > FW_MEDIUM) ? FS_BOLD : 0) |
                            ((ttm->usWeightClass==FW_NORMAL)
                                     ? FS_NORMAL : 0));
         ttm->typAscender = TypographicalAscender(tt);
         ttm->typDescender = TypographicalDescender(tt);
         em = ttm->typAscender - ttm->typDescender;
         ttm->superoff.y = (funit)(em / 2);
         ttm->superoff.x = 0;
         ttm->supersize.y = (funit)(em * 2 / 3);
         ttm->supersize.x = (funit)(em * 3 / 4);
         ttm->suboff.y = (funit)(em / 5);
         ttm->suboff.x = 0;
         ttm->subsize.y = (funit)(em * 2 / 3);
         ttm->subsize.x = (funit)(em * 3 / 4);
         ttm->strikeoff = (funit)(ttm->typAscender / 2);
         ttm->strikesize = (funit)(ttm->typAscender / 10);
      } else {
         ttm->usWeightClass = t1m->tmweight;
         ttm->macStyle = (USHORT)(((t1m->tmweight>FW_MEDIUM)?MAC_BOLD : 0) |
                         ((ttm->angle != 0) ? MAC_ITALIC : 0));
         ttm->fsSelection = (USHORT)(((ttm->angle != 0) ? FS_ITALIC : 0) |
                            ((ttm->usWeightClass > FW_MEDIUM) ? FS_BOLD : 0) |
                            ((ttm->usWeightClass==FW_NORMAL)
                                     ? FS_NORMAL : 0));
         ttm->typAscender = TransY(t1m, (funit)(t1m->ascent -
                                                t1m->intLeading));
         ttm->typDescender = (funit)(-TransY(t1m, t1m->descent)-1);
         ttm->typLinegap = TransY(t1m, (funit)(t1m->intLeading +
                                               t1m->extLeading));
         ttm->superoff.y = ABS(TransY(t1m, t1m->superoff));
         ttm->superoff.x = 0;
         ttm->supersize.y = TransY(t1m, t1m->supersize);
         ttm->supersize.x = (funit)(TransY(t1m, t1m->supersize) * 3 / 4);
         ttm->suboff.y = ABS(TransY(t1m, t1m->suboff));
         ttm->suboff.x = 0;
         ttm->subsize.y = TransY(t1m, t1m->subsize);
         ttm->subsize.x = (funit)(TransY(t1m, t1m->subsize) * 3 / 4);
         ttm->strikeoff = ABS(TransY(t1m, t1m->strikeoff));
         ttm->strikesize = TransY(t1m, t1m->strikesize);

         // Adjust usWinAscent so that internal leading matches up.
         // For fonts that do not have buggy pfm files, this adjustment
         // will do nothing, for those for which intLeading is
         // incorrectly set to zero, taking max means that the tops will not
         // be chopped off in the converted font. ttfd shaves off anything
         // that extends beyond ascender or descender. For fonts with buggy
         // pfm's, tt conversions may have bogus internal leadings, but this
         // is better than having glyph bottoms or tops shaved off. [bodind]

         PostAsc = ttm->emheight + TransY(t1m, t1m->intLeading) - ttm->winDescender;

         if (PostAsc > ttm->winAscender)
            ttm->winAscender  = PostAsc;
      }

      /* Gray-scale threshold. */
      if (GetStdVW(t1m)!=0 || GetDefStdVW(t1m)!=0) {
         ttm->onepix = (USHORT)(1 + GetUPEM(t1m)*3/2 /
                                TransY(t1m, ((GetStdVW(t1m) ?
                                              GetStdVW(t1m) :
                                              GetDefStdVW(t1m)))));
      }

      // needed in producing the correct ifimetrics for tt conversion

      ttm->DefaultChar = t1m->DefaultChar;
      ttm->BreakChar   = t1m->BreakChar;
      ttm->CharSet     = t1m->CharSet;  // essential for correct font mapping

      /* Character widths. */
      if (t1m->flags!=DEFAULTMETRICS) {
         ttm->FirstChar   = t1m->firstChar;
         ttm->LastChar    = t1m->lastChar;
         if ((ttm->widths = Malloc(sizeof(funit)*
                                   (t1m->lastChar-t1m->firstChar+1)))==NULL) {
            SetError(status = NOMEM);
         } else {
            for (i=0; i<=(unsigned)(t1m->lastChar-t1m->firstChar); i++) {
               ttm->widths[i] = TransY(t1m, t1m->widths[i]);
            }
         }
      }

      /* Pair kerning. */
      if (t1m->flags!=DEFAULTMETRICS &&
          t1m->kerns!=NULL) {
         if ((ttm->kerns = Malloc(sizeof(struct kerning)*
                                  t1m->kernsize))==NULL) {
            SetError(status = NOMEM);
         } else {
            for (i=0; i<t1m->kernsize; i++) {
               ttm->kerns[i].left = t1m->kerns[i].left;
               ttm->kerns[i].right = t1m->kerns[i].right;
               ttm->kerns[i].delta = TransY(t1m, t1m->kerns[i].delta);
            }
            ttm->kernsize = t1m->kernsize;
         }
      }

      /* Pre program. */
      if ((prep = GetPrep(PREPSIZE))!=NULL &&
          (prep_size = BuildPreProgram(t1m,
                                       GetWeight(t1m),
                                       GetBlues(t1m),
                                       GetAlignment(t1m),
                                       &prep, PREPSIZE,
                                       &(ttm->maxprepstack)))>0) {

         /* Store the pre-program. */
         UsePrep(ttm, prep, prep_size);
      }

      /* CVT entries. */
      blues = GetBlues(t1m);
      if (status!=NOMEM &&
          (ttm->cvt = Malloc(blues->align.cvt * CVTSIZE)) == NULL) {
         SetError(status = NOMEM);
      } else {
         ADDCVT(0);  /* TMPCVT */
         ADDCVT((GetStdVW(t1m)==0) ?
                TransX(t1m, GetDefStdVW(t1m))/2 :
            TransX(t1m, GetStdVW(t1m))/2);
         ADDCVT((GetStdHW(t1m)==0) ?
                TransY(t1m, GetDefStdHW(t1m))/2 :
            TransY(t1m, GetStdHW(t1m))/2);
         for (i=0; i<t1m->snapv_cnt; i++)
            ADDCVT(TransY(t1m, t1m->stemsnapv[i])/2);
         for (i=0; i<t1m->snaph_cnt; i++)
            ADDCVT(TransY(t1m, t1m->stemsnaph[i])/2);

         /* Align the top zones. */
         align = GetAlignment(t1m);
         for (i=0; i<blues->blue_cnt/2; i++) {
            /* Skip empty zones. */
            if (align->top[i].cnt==0)
               continue;
            
            ttm->cvt[align->top[i].blue_cvt]
                  = (short)TransY(t1m, blues->bluevalues[i*2]);
            ttm->cvt[align->top[i].blue_cvt+1]
                  = (short)TransY(t1m, blues->bluevalues[i*2+1]);
            for (j=0; j<align->top[i].cnt; j++) {
               funit pos;
               int k;

               /* Get the closest family. */
               k = MatchingFamily(blues->bluevalues[i*2],
                                  blues->familyblues,
                                  blues->fblue_cnt);

               /* Compute the position in the zone w.r.t. the family blues. */
               if (blues->bluevalues[i*2] != blues->bluevalues[i*2+1])
                  pos = IP(align->top[i].pos[j].y,
                           blues->bluevalues[i*2],
                           blues->bluevalues[i*2+1],
                           blues->familyblues[k],
                           blues->familyblues[k+1]);
               else
                  pos = blues->familyblues[k];

               ttm->cvt[align->top[i].pos[j].cvt]
                     = (short)TransY(t1m, align->top[i].pos[j].y);
               ttm->cvt[align->top[i].pos[j].cvt+1]
                     = (short)TransY(t1m, pos);
            }
         }

         /* Align the bottom zones. */
         for (i=0; i<blues->oblue_cnt/2; i++) {
            /* Skip empty zones. */
            if (align->bottom[i].cnt==0)
               continue;
            
            ttm->cvt[align->bottom[i].blue_cvt]
                  = (short)TransY(t1m, blues->otherblues[i*2+1]);
            for (j=0; j<align->bottom[i].cnt; j++) {
               funit pos;
               int k;

               /* Get the closest family. */
               k = MatchingFamily(blues->otherblues[i*2],
                                  blues->familyotherblues,
                                  blues->foblue_cnt);

               /* Compute the position in the zone w.r.t. the family blues. */
               if (blues->otherblues[i*2] != blues->otherblues[i*2+1])
                  pos = IP(align->bottom[i].pos[j].y,
                           blues->otherblues[i*2],
                           blues->otherblues[i*2+1],
                           blues->familyotherblues[k],
                           blues->familyotherblues[k+1]);
               else
                  pos = blues->familyotherblues[k];

               ttm->cvt[align->bottom[i].pos[j].cvt]
                     = (short)TransY(t1m, align->bottom[i].pos[j].y);
               ttm->cvt[align->bottom[i].pos[j].cvt+1]
                     = (short)TransY(t1m, pos);
            }
         }

         /* Add the family zones. */
         for (i=0; i<blues->fblue_cnt/2; i++) {
            if (blues->family_cvt[i]!=UNDEF_CVT) {
               ttm->cvt[blues->family_cvt[i]]
                     = (short)TransY(t1m, blues->familyblues[i*2]);
               ttm->cvt[blues->family_cvt[i]+1]
                     = (short)TransY(t1m, blues->familyblues[i*2+1]);
            }
         }

         /* Add the family other zones. */
         for (i=0; i<blues->foblue_cnt/2; i++) {
            if (blues->familyother_cvt[i]!=UNDEF_CVT) {
               ttm->cvt[blues->familyother_cvt[i]]
                     = (short)TransY(t1m, blues->familyotherblues[i*2+1]);
            }
         }

         ttm->cvt_cnt = blues->align.cvt;
         ttm->maxstorage = t1m->stems.storage;

         /* Store the font-program. */
         SetFPGM(ttm, GetFontProg(), GetFontProgSize(), GetNumFuns());
      }
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\types.h ===
#ifndef TYPES_H
#define TYPES_H


/***********/
/* Macros. */
#define MAX(v,w)  ((v)>=(w) ? (v) : (w))
#define MIN(v,w)  ((v)<(w) ? (v) : (w))
#define ABS(v)	  (((v)>=0) ? (v) : -(v))
#define SWAPINT(a,b)   {(a)^=(b); (b)^=(a); (a)^=(b);}
#define MkLong(c1,c2,c3,c4)	 (((ULONG)(c1)<<24L) + ((ULONG)(c2)<<16L) + \
				 ((ULONG)(c3)<<8L) + ((ULONG)(c4)))



/**************/
/* Constants. */
#define TRUE   1
#define FALSE  0



/**********/
/* Types. */
typedef short errcode;
typedef unsigned char UBYTE;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef unsigned char boolean;
typedef long f16d16;


/* Microsoft C specific stuff. */
#ifndef CDECL
#ifdef _MSC_VER
#  define CDECL  __cdecl
#else
#  define CDECL
#endif
#endif


/*** Error handling. */
void LogError(const long type, const long id, const char *arg);

#if _DEBUG
#ifdef MSDOS
int _cdecl sprintf(char *, const char *, ...);
#else
int sprintf(char *, const char *, ...);
#endif
#define SetError(c)  {char tmp[64];  (void)sprintf(tmp,\
	"Error %d at %s, line %d.\n", c, __FILE__, __LINE__); LogError(MSG_ERROR, MSG_DB, tmp);}
#else
#define SetError(c)  {c;}
#endif

/* Message types */
#define MSG_INFO     0L
#define MSG_WARNING  1L
#define MSG_ERROR    2L

	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\ttprog.c ===
/***
**
**   Module: ttprog
**
**   Description:
**      This is a module of the T1 to TT font converter. This is a
**      sub-module of Hint module. This modules deals with the 
**      the font program fo the font.
**
**   Author: Michael Jansson
**
**   Created: 8/24/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <limits.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"
#include "metrics.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
/*#include "hints.h"*/
#include "ttprog.h"



/***** MACROS */
/*-none-*/



/***** CONSTANTS */
#define MAXIP			100

#define CURVEPHASE      6

#define MAXTHINPNTS     512

#define UNDEF        -1

#define SMALL_LOWER     21L
#define SMALL_UPPER     50L
#define LARGE_LOWER     21L
#define LARGE_UPPER     21L

#define BUFSIZE         20

#define TTFUN_SET_ZONE           1 
#define TTFUN_COPY_ZONE          2 
#define TTFUN_STEM_SNAP_WIDTH    3 
#define TTFUN_STEM_STD_WIDTH     4 
#define TTFUN_SHIFT_BLUE_ZONE    5 
#define TTFUN_ALIGN_BLUE_ZONE    6 
#define TTFUN_COPY_FAMILY        7 
#define TTFUN_WRITE_STEM         8 
#define TTFUN_VERTICAL           9 
#define TTFUN_HORIZONTAL         10
#define TTFUN_VCENTER            11
#define TTFUN_HCENTER            12
#define TTFUN_RELATIVE1V         13
#define TTFUN_RELATIVE2V         14
#define TTFUN_RELATIVE1H         15
#define TTFUN_RELATIVE2H         16
#define TTFUN_SIDE1              17    
#define TTFUN_SIDE2              18
#define TTFUN_FLEX               19
#define TTFUN_SCALE3             20
#define TTFUN_SHIFT1             21
#define TTFUN_SHIFT2             22
#define TTFUN_IP1                23  
#define TTFUN_IP2                24
#define TTFUN_IPN                25
#define TTFUN_SHP1               26  
#define TTFUN_SHP2               27
#define TTFUN_SHPN               28
#define TTFUN_RANGE              29
#define TTFUN_OBLIQUE            30
#define TTFUN_NUM                31    /* 1..30 */


#define FDEF(name)            op_pushb1, name, op_fdef,
#define ENDF                  op_endf,
#define CALL(name)            op_pushb1, name, op_call
#define WCVT(name)            op_pushb1, name, op_swap, op_wcvtf
#define PUSH1(v)              op_pushb1, (v)
#define PUSH2(v1, v2)         op_pushb1+1, (v1), (v2)
#define PUSH3(v1, v2, v3)     op_pushb1+2, (v1), (v2), (v3)
#define PUSH4(v1, v2, v3, v4) op_pushb1+3, (v1), (v2), (v3), (v4)
#define PUSH5(v1,v2,v3,v4,v5) op_pushb1+4, (v1), (v2), (v3), (v4), (v5)


static const UBYTE FontProg[] = {


   
/******* SET ZONE FUNCTION
 *
 * Args: flat_pos
 *
 */
FDEF(TTFUN_SET_ZONE)
   PUSH1(TMPPNT),
   op_swap,
   op_miap,
   PUSH1(TMPPNT),
   op_mdap | SUBOP_R,
ENDF




/******* COPY ZONE FUNCTION
 *
 * Args: from_cvt, to_cvt
 *
 */
FDEF(TTFUN_COPY_ZONE)
   op_rcvt,
   op_round,
   op_wcvtp,
ENDF





/******* STEM SNAP WIDTH FUNCTION
 *
 * Args: std_ci, std_cvt, snap_ci, snap_cvt, width, storage
 *
 */
FDEF(TTFUN_STEM_SNAP_WIDTH)
   op_mppem,
   op_gteq,
   op_if,

      /* Use std */
      op_rcvt,
      op_round,
      PUSH1(ONEPIXEL/2),
      op_max,
      op_swap, op_pop, op_swap, op_pop, op_swap, op_pop,
      CALL(TTFUN_WRITE_STEM),
      
   op_else,
      op_pop,
      op_mppem,
      op_gteq,
      op_if,
   
         /* Use snap */
         op_rcvt,
         op_round,
         PUSH1(ONEPIXEL/2),
         op_max,
    op_swap,
         op_pop, 
         CALL(TTFUN_WRITE_STEM),
         
      /* Use real width. */
      op_else,
         op_pop,
         WCVT(TMPCVT),
         PUSH1(TMPCVT),
         op_rcvt,
         op_round,
         PUSH1(ONEPIXEL/2),
         op_max,
         CALL(TTFUN_WRITE_STEM),
      op_eif,
   
   op_eif,
ENDF



   

/******* STEM STD WIDTH FUNCTION
 *
 * Args: std_ci, std_cvt, width, storage
 *
 */
FDEF(TTFUN_STEM_STD_WIDTH)
   op_mppem,
   op_gteq,
   op_if,
   
      /* Use std */
      op_rcvt,
      op_round,
      PUSH1(ONEPIXEL/2),
      op_max,
      op_swap,
      op_pop,
      CALL(TTFUN_WRITE_STEM),
      
   /* Use real width. */
   op_else,
      op_pop,
      WCVT(TMPCVT),
      PUSH1(TMPCVT),
      op_rcvt,
      op_round,
      PUSH1(ONEPIXEL/2),
      op_max,
      CALL(TTFUN_WRITE_STEM),
   op_eif,
   
ENDF





/******* SHIFT BLUE ZONE FUNCTION
 *
 * Args: cvt
 *
 */
FDEF(TTFUN_SHIFT_BLUE_ZONE)
   PUSH5(TMPPNT1, TMPPNT1, TMPPNT, TMPPNT1, 5),
   op_cindex,
   op_miap,
   op_srp0,
   op_mdrp | SUBOP_mMRGR,
   op_gc,
   op_wcvtp,
ENDF





/******* ALIGN BLUE ZONE FUNCTION
 *
 * Args: cvt
 *
 */
FDEF(TTFUN_ALIGN_BLUE_ZONE)
   PUSH5(TMPPNT1, TMPPNT1, TMPPNT, TMPPNT1, 5),
   op_cindex,
   op_miap,
   op_srp0,
   op_mdrp | SUBOP_ROUND,
   op_gc,
   op_wcvtp,
ENDF





/******* COPY FAMILY FUNCTION
 *
 * Args: base_cvt
 *
 */
FDEF(TTFUN_COPY_FAMILY)
   op_dup,
   PUSH1(1),
   op_add,
   op_rcvt,
   op_wcvtp,
ENDF





/******* WRITE STEM FUNCTION
 *
 * Args: width, storage
 *
 */
FDEF(TTFUN_WRITE_STEM)
   op_dup,    /* -| width, width, storage */
   op_dup,    /* -| width, width, width, storage */
   op_add,    /* -| 2*width, width, storage, */
   op_odd,    /* -| odd/even, width, storage */
   PUSH2(1, 4),     /* -| 4, 1, odd/even, width, storage */
   op_cindex,     /* -| storage, 1, odd/even, width, storage */
   op_add,
   op_swap,   /* -| odd/even, storage+1, width, storage */
   op_ws,
   op_ws,
ENDF





/******* VERTICAL FUNCTION
 *
 * Args: -*none*-
 *
 */
FDEF(TTFUN_VERTICAL)
   op_svcta | SUBOP_X,
   PUSH1(TWILIGHT),
   op_szps,
ENDF





/******* HORIZONTAL FUNCTION
 *
 * Args: -*none*-
 *
 */
FDEF(TTFUN_HORIZONTAL)
   PUSH1(TWILIGHT),
   op_svcta,
   op_szps,
ENDF





/******* CENTER VSTEM FUNCTION
 *
 * Args: p1, p2, p3, p4, c, tz1, width
 *
 */
FDEF(TTFUN_VCENTER)

   /* Set rounding state for the center. */
   PUSH2(1, 8),
   op_cindex,
   op_add,
   op_rs,
   op_if,
       op_rthg,
   op_else,
       op_rtg,
   op_eif,

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 6),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 6),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 2, 5),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 3, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round center. */
   WCVT(TMPCVT),     /* c */
   PUSH2(TMPPNT, TMPCVT),
   op_miap| SUBOP_R,
   op_rtg,

   /* Align all points to the center. */
   op_dup, op_dup, PUSH1(1), op_add,
   op_alignrp, op_alignrp,   /* tz1, tz1+1 */


   /* Compute the width. */
   op_swap,
   op_rs,
   PUSH1(CURVEPHASE),
   op_sub,
   op_swap,


   /* -| tz1, width */
   op_dup,
   op_dup,
   op_dup,
   op_srp0,
   PUSH1(4), op_cindex,
   op_neg,     /* -| (-width/2), tz1, tz1, tz1, width */
   op_shpix,      
   PUSH1(2),
   op_add,
   op_alignrp,    /* -| tz1+2, tz1, width */


   /* Do the other side. */
   /* -| tz1, width */
   PUSH1(1),
   op_add,
   op_dup,
   op_dup,     /* -| tz1+1, tz1+1, tz1+1, width */
   op_srp0,
   op_roll,    /* -| width, tz1+1, tz1+1 */
   op_shpix,      
   PUSH1(2),
   op_add,
   op_alignrp,    /* -| tz1+3 */

   /* Done. */
ENDF






/******* CENTER HSTEM FUNCTION
 *
 * Args: p1, p2, c, tz1, width
 *
 */
FDEF(TTFUN_HCENTER)

   /* Set,rounding state for the center. */
   PUSH2(1, 6),
   op_cindex,
   op_add,
   op_rs,
   op_if,
       op_rthg,
   op_else,
       op_rtg,
   op_eif,

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round center. */
   WCVT(TMPCVT),  /* c */
   PUSH2(TMPPNT, TMPCVT),
   op_miap| SUBOP_R,
   op_rtg,

   /* Align all points to the center. */
   op_dup, op_dup, PUSH1(1), op_add,
   op_alignrp, op_alignrp,   /* tz1, tz1+1 */


   /* Compute the width. */
   op_swap,
   op_rs,
   PUSH1(CURVEPHASE),
   op_sub,
   op_swap,


   /* -| tz1, width */
   op_dup,
   PUSH1(3), op_cindex,
   op_neg,     /* -| -width, tz1, tz1, width */
   op_shpix,      

   /* Do the other side. */
   /* -| tz1, width */
   PUSH1(1),
   op_add,
   op_swap,    /* -| width, tz1+1 */
   op_shpix,      

   /* Done. */
ENDF





/******* RELATIVE1V STEM FUNCTION
 *
 * Args: p1, p2, p3, p4, ref, tz1, width
 *
 */
FDEF(TTFUN_RELATIVE1V)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 6),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 6),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 2, 5),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 3, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   /* Move/round side. */
   op_srp0,
   op_dup,
   op_mdrp | SUBOP_MmRGR,

   /* Align points on the left side. */
   op_dup, PUSH1(1), op_add, op_dup, op_dup, op_dup,
   PUSH1(1), op_add,  /* -| tz1+2, tz1+1, tz1+1, tz+1, tz, width */
   op_alignrp,
   op_alignrp,

   /* Align right side */
   op_srp0,    /* -| tz1+1, tz1, width */
   op_roll,
   op_rs,
   op_dup,
   op_add,     /* -| width*2, tz1+1, tz1 */
   op_shpix,
   PUSH1(3),
   op_add,
   op_alignrp,    /* -| tz1+3 */

ENDF





/******* RELATIVE2V STEM FUNCTION
 *
 * Args: p1, p2, p3, p4, ref, tz1, width
 *
 */
FDEF(TTFUN_RELATIVE2V)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 6),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 6),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 2, 5),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 3, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round side. */
   op_srp0,
   op_dup,
   PUSH1(1), op_add,
   op_mdrp | SUBOP_MmRGR,

   /* Align points on the left side. */
   op_dup, op_dup, op_dup, op_dup,
   PUSH1(3), op_add,  /* -| tz1+3, tz1, tz1, tz1, tz1, width */
   op_alignrp,
   op_alignrp,


   /* Align left side */
   op_srp0,    /* -| tz1, tz1, width */
   op_roll,
   op_rs,
   op_dup,
   op_add,
   op_neg,
   op_shpix,      /* -| -2*width, tz1, tz1 */
   PUSH1(2), op_add,
   op_alignrp,    /* -| tz1+2 */

ENDF





/******* RELATIVE1H STEM FUNCTION
 *
 * Args: p1, p2, ref, tz1, width
 *
 */
FDEF(TTFUN_RELATIVE1H)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   /* Move/round side. */
   op_srp0,
   op_dup,
   op_mdrp | SUBOP_MmRGR,


   /* Align all point to the lower side. */
   PUSH1(1), op_add, op_dup,
   op_alignrp,

   /* Align right side */
   op_swap,
   op_rs,
   op_dup,
   op_add,
   op_shpix,

ENDF





/******* RELATIVE2H STEM FUNCTION
 *
 * Args: p1, p2, ref, tz1, width
 *
 */
FDEF(TTFUN_RELATIVE2H)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round side. */
   op_srp0,
   op_dup,
   PUSH1(1), op_add,
   op_mdrp | SUBOP_MmRGR,

   /* Align all points to the center. */
   op_dup, op_alignrp,

   /* Align left side */
   op_swap,
   op_rs,
   op_dup,
   op_add,
   op_neg,
   op_shpix,

ENDF





/******* SIDE1 STEM FUNCTION
 *
 * Args: p1, p2, zone, tz1, width
 *
 */
FDEF(TTFUN_SIDE1)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   /* Move/round side. */
   PUSH2(TMPPNT, TMPPNT),
   op_srp0, op_swap, op_miap | SUBOP_R,

   /* Align all points to the side. */
   op_dup, PUSH1(1), op_add, op_dup, op_roll,
   op_alignrp, op_alignrp,

   /* Align first side */
   op_swap,
   op_rs,
   op_dup,
   op_add,
   PUSH1(CURVEPHASE),
   op_sub,
   op_shpix,

ENDF





/******* SIDE2 STEM FUNCTION
 *
 * Args:  p1, p2, zone, tz1, width
 *
 */
FDEF(TTFUN_SIDE2)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round side. */
   PUSH2(TMPPNT, TMPPNT),
   op_srp0, op_swap, op_miap | SUBOP_R,

   /* Align all points to the side. */
   op_dup, op_dup, PUSH1(1), op_add, 
   op_alignrp, op_alignrp,

   /* Align second side */
   op_swap,
   op_rs,
   op_dup,
   op_add,
   PUSH1(CURVEPHASE),
   op_sub,
   op_neg,
   op_shpix,

ENDF


    


/******* FLEX FUNCTION
 *
 * Args on the stack: pnt_start, pnt_mid, ref_pos, pnt_mid,
 *       pnt_start, pnt_mid, cnt, p1, p2, ....
 *
 */
FDEF(TTFUN_FLEX)
   op_srp0,
   op_alignrp,
   op_wcvtf,
   op_rcvt,
   op_shpix,
   op_srp1,
   op_srp2,
   op_sloop,
   op_ip,
ENDF





/******* SCALE3 FUNCTION
 *
 * Args: cnt, p1, p2, ... 
 *
 */
FDEF(TTFUN_SCALE3)
   PUSH4(GLYPHZONE, TMPPNT1, TMPPNT, TMPPNT1),
   op_pushw1, HIBYTE(-31), LOBYTE(-31),
   PUSH3(TMPPNT, 0, TMPPNT1),
   op_pushw1, HIBYTE(1000), LOBYTE(1000),
   op_scfs,
   op_scfs,
   op_shpix,
   op_srp1,
   op_srp2,
   op_szp2,
   op_sloop,
   op_ip,
ENDF





/******* SHIFT1 FUNCTION
 *
 * Args: cnt reduction p1 p2 ...
 *
 */
FDEF(TTFUN_SHIFT1)
   op_sloop,
   op_rs,
   op_neg,
   op_shpix,
ENDF




   
/******* SHIFT2 FUNCTION
 *
 * Args: cnt reduction p1 p2 ...
 *
 */
FDEF(TTFUN_SHIFT2)
   op_sloop,
   op_rs,
   op_shpix,
ENDF





/******* IP1 FUNCTION
 *
 * Args: rp1, rp2, p1
 *
 */
FDEF(TTFUN_IP1)
   op_srp1,
   op_srp2,
   op_ip,
ENDF





/******* IP2 FUNCTION
 *
 * Args: rp1, rp2, p1, p2
 *
 */
FDEF(TTFUN_IP2)
   op_srp1,
   op_srp2,
   op_ip,
   op_ip,
ENDF





/******* IPN FUNCTION
 *
 * Args: rp1, rp2, cnt, p1, p2
 *
 */
FDEF(TTFUN_IPN)
   op_srp1,
   op_srp2,
   op_sloop,
   op_ip,
ENDF





/******* SHP1 FUNCTION
 *
 * Args: rp, p
 *
 */
FDEF(TTFUN_SHP1)
   op_srp1,
   op_shp,
ENDF





/******* SHP2 FUNCTION
 *
 * Args: rp, p1, p2
 *
 */
FDEF(TTFUN_SHP2)
   op_srp1,
   op_shp,
   op_shp,
ENDF


    

    
/******* SHPN FUNCTION
 *
 * Args: rp, cnt, p1, p2
 *
 */
FDEF(TTFUN_SHPN)
   op_srp1,
   op_sloop,
   op_shp,
ENDF





/******* RANGE FUNCTION
 *
 * Args: p
 *
 */
FDEF(TTFUN_RANGE)
   op_dup,
   PUSH1(1),
   op_add,
ENDF




/******* RANGE FUNCTION
 *
 * Args: pos_x, pos_y,
 *
 */
FDEF(TTFUN_OBLIQUE)
   op_svcta | SUBOP_Y,
   PUSH1(TMPPNT1),
   op_swap,
   op_scfs,
   PUSH2(TMPPNT, 0),
   op_scfs,
   op_svcta | SUBOP_X,
   PUSH1(TMPPNT1),
   op_swap,
   op_scfs,
   PUSH2(TMPPNT, 0),
   op_scfs,
   PUSH2(TMPPNT, TMPPNT1),
   op_spvtl,
ENDF

};


/***** LOCAL TYPES */


/***** STATIC FUNCTIONS */

/***
** Function: GetVStemWidth
**
** Description:
**   This function allocates a storage entry for the 
**   width of a vertical stem;
***/
static short GetVStemWidth(WeightControl *weight, const funit width)
{
   StemWidth *newwidths = NULL;
   short entry = 0;
   USHORT j;

   if (weight->cnt_vw >= weight->max_vw) {
      newwidths = Realloc(weight->vwidths,
                          sizeof(StemWidth)*(weight->max_vw+BUFSIZE));
      if (newwidths == NULL) {
         entry = NOMEM;
      } else {
         weight->vwidths = newwidths;
         weight->max_vw += BUFSIZE;
      }
   }

   if (entry != NOMEM) {
      for (j=0; j<weight->cnt_vw; j++) {
         if (weight->vwidths[j].width==width) {
            entry = (short)weight->vwidths[j].storage;
            break;
         }
      }

      if (j==weight->cnt_vw) {
         weight->vwidths[weight->cnt_vw].storage = weight->storage;
         weight->vwidths[weight->cnt_vw].width = width;
         entry = (short)weight->storage;
         weight->storage += 2;
         weight->cnt_vw++;
      }
   }

   return entry;
}


/***
** Function: GetHStemWidth
**
** Description:
**   This function allocates a storage entry for the 
**   width of a vertical stem;
***/
static short GetHStemWidth(WeightControl *weight, const funit width)
{
   StemWidth *newwidths = NULL;
   short entry = 0;
   USHORT j;

   if (weight->cnt_hw >= weight->max_hw) {
      newwidths = Realloc(weight->hwidths,
                          sizeof(StemWidth)*(weight->max_hw+BUFSIZE));
      if (newwidths == NULL) {
         entry = NOMEM;
      } else {
         weight->hwidths = newwidths;
         weight->max_hw += BUFSIZE;
      }
   }

   if (entry != NOMEM) {
      for (j=0; j<weight->cnt_hw; j++) {
         if (weight->hwidths[j].width==width) {
            entry = (short)weight->hwidths[j].storage;
            break;
         }
      }

      if (j==weight->cnt_hw) {
         weight->hwidths[weight->cnt_hw].storage = weight->storage;
         weight->hwidths[weight->cnt_hw].width = width;
         entry = (short)weight->storage;
         weight->storage += 2;
         weight->cnt_hw++;
      }
   }

   return entry;
}




/***** GLOBAL FUNCTIONS */

/***
** Function: SetZone
**
** Description:
**   This function initiate an alignment zone
**   by creating an appropriate point in the
**   twilight zone.
***/
USHORT SetZone(UBYTE *prep, USHORT tp, const short cvt)
{
   /* Set up the zone. */
   if (cvt>255) {
      prep[tp++] = op_pushw1;
      prep[tp++] = HIBYTE(cvt);
      prep[tp++] = LOBYTE(cvt);
      prep[tp++] = op_pushb1;
      prep[tp++] = TTFUN_SET_ZONE;
   } else {
      prep[tp++] = op_pushb1 + 1;
      prep[tp++] = (UBYTE)cvt;
      prep[tp++] = TTFUN_SET_ZONE;
   }
   prep[tp++] = op_call;

   return tp;
}



/***
** Function: CopyZone
**
** Description:
**   This function copies a cvt entry, representing an
**   alignment zone, to the cvt used for a particular hstem.
***/
USHORT CopyZone(UBYTE *prep, short tp, short *args, const short ta)
{
   args[0] = TTFUN_COPY_ZONE;
   args[1] = (short)((ta-2)/2);
   AssembleArgs(args, ta, prep, &tp);
   prep[tp++] = op_loopcall;

   return (USHORT)tp;
}



/***
** Function: CopyFamilyBlue
**
** Description:
**   This function copies a cvt entry, representing a
**   family blue zone, to the cvt used for a particular hstem.
***/
USHORT CopyFamilyBlue(UBYTE *prep, short tp, short *args, const short ta)
{
   args[0] = TTFUN_COPY_FAMILY;
   args[1] = (short)(ta-2);
   AssembleArgs(args, ta, prep, &tp);
   prep[tp++] = op_loopcall;

   return (USHORT)tp;
}



/***
** Function: AlignFlat
**
** Description:
**   This function creates a cvt entry for
**   a particular hstem.
***/
USHORT AlignFlat(UBYTE *prep, short tp, short *args, const short ta)
{
   args[0] = TTFUN_ALIGN_BLUE_ZONE;
   args[1] = (short)(ta-2);
   AssembleArgs(args, ta, prep, &tp);
   prep[tp++] = op_loopcall;

   return (USHORT)tp;
}



/***
** Function: AlignOvershoot
**
** Description:
**   This function creates a cvt entry for
**   a particular hstem.
***/
USHORT AlignOvershoot(UBYTE *prep, short tp, short *args, const short ta)
{
   args[0] = TTFUN_SHIFT_BLUE_ZONE;
   args[1] = (short)(ta-2);
   AssembleArgs(args, ta, prep, &tp);
   prep[tp++] = op_loopcall;

   return (USHORT)tp;
}


/***
** Function: GetTopPos
**
** Description:
**   This function allocates a cvt entry for the 
**   top side of a horizontal stem;
***/
short GetTopPos(const Blues *blues,
                AlignmentControl *align,
                const funit pos)
{
   short entry = UNDEF;
   const funit *bluevals;
   short fuzz;
   USHORT i, j;

   bluevals = &(blues->bluevalues[0]);
   fuzz = blues->blueFuzz;

   /* Check if it is within a zone. */
   for (i=0; i<blues->blue_cnt; i+=2) {
      if (((bluevals[i]-fuzz)<=pos) && ((bluevals[i+1]+fuzz)>=pos))
         break;
   }

   /* Record the position? */
   if (i!=blues->blue_cnt) {
      i /= 2;

      /* Is the position already mapped to a cvt entry? */
      for (j=0; j<align->top[i].cnt; j++) {
         if (align->top[i].pos[j].y==pos) {
            entry = (short)align->top[i].pos[j].cvt;
            break;
         }
      }

      if (j==align->top[i].cnt) {

         /* Allocate the BlueZone cvt's */
         if (align->top[i].cnt==0) {
            align->top[i].blue_cvt = align->cvt;
            align->cvt +=2;
         }

         align->top[i].pos[align->top[i].cnt].cvt = align->cvt;
         align->top[i].pos[align->top[i].cnt].y = pos;
         entry = (short)align->cvt;
         align->cvt+=2;
         align->top[i].cnt++;
      }
   }

   return entry;
}


/***
** Function: GetBottomPos
**
** Description:
**   This function allocates a cvt entry for the 
**   top side of a horizontal stem;
***/
short GetBottomPos(const Blues *blues,
                   AlignmentControl *align,
                   const funit pos)
{
   short entry = UNDEF;
   const funit *bluevals;
   short fuzz;
   USHORT i, j;

   bluevals = &(blues->otherblues[0]);
   fuzz = blues->blueFuzz;

   /* Check if it is within a zone. */
   for (i=0; i<blues->oblue_cnt; i+=2) {
      if (((bluevals[i]-fuzz)<=pos) && ((bluevals[i+1]+fuzz)>=pos))
         break;
   }


   /* Record the position? */
   if (i!=blues->oblue_cnt) {
      i /= 2;

      /* Is the position already mapped to a cvt entry? */
      for (j=0; j<align->bottom[i].cnt; j++) {
         if (align->bottom[i].pos[j].y==pos) {
            entry = (short)align->bottom[i].pos[j].cvt;
            break;
         }
      }

      if (j==align->bottom[i].cnt) {

         /* Allocate the BlueZone and FamilyBlue cvt's */
         if (align->bottom[i].cnt==0) {
            align->bottom[i].blue_cvt = align->cvt++;
         }

         align->bottom[i].pos[align->bottom[i].cnt].cvt = align->cvt;
         align->bottom[i].pos[align->bottom[i].cnt].y = pos;
         entry = (short)align->cvt;
         align->cvt+=2;
         align->bottom[i].cnt++;
      }
   }

   return entry;
}


/***
** Function: CutInSize
**
** Description:
**   This function computes the cut in size
**   of a stem, given a master width and the
**   width of the stem. This is done with the
**   StdVW==2.0 pixel treshold and the thinn
**   and wide cut in values.
***/
USHORT CutInSize(const funit width,
                 const funit master,
                 const USHORT tresh,
                 const funit upem)
{
   USHORT cis, ci1, ci2;

   /*lint -e776 */
   if (width > master) {
      ci1 = (USHORT)((long)upem * SMALL_UPPER / ONEPIXEL /
                     (long)(width - master));
      ci2 = (USHORT)((long)upem * LARGE_UPPER / ONEPIXEL /
                     (long)(width - master));
   } else if (width < master) {
      ci1 = (USHORT)((long)upem * SMALL_LOWER / ONEPIXEL /
                     (long)(master - width));
      ci2 = (USHORT)((long)upem * LARGE_LOWER / ONEPIXEL /
                     (long)(master - width));
   } else {
      ci1 = INFINITY;  
      ci2 = INFINITY;
   }
   /*lint +e776 */

   if (ci1 < tresh) {
      cis = ci1;
   } else if (ci2 < tresh) {
      cis = tresh;
   } else {
      cis = ci2;
   }

   return cis;
}


/***
** Function: SnapStemArgs
**
** Description:
**   
***/
USHORT SnapStemArgs(short *args, USHORT ta,
                    const funit width,
                    const USHORT std_cvt,
                    const USHORT snap_cvt,
                    const USHORT std_ci,
                    const USHORT snap_ci,
                    const USHORT storage)
{
   args[ta++] = (short)std_ci;
   args[ta++] = (short)std_cvt;
   args[ta++] = (short)snap_ci;
   args[ta++] = (short)snap_cvt;
   args[ta++] = (short)(width/2);
   args[ta++] = (short)storage;

   return ta;
}



/***
** Function: StdStemArgs
**
** Description:
**   
***/
USHORT StdStemArgs(short *args, USHORT ta,
                   const funit width,
                   const USHORT std_cvt,
                   const USHORT std_ci,
                   const USHORT storage)
{
   args[ta++] = (short)std_ci;
   args[ta++] = (short)std_cvt;
   args[ta++] = (short)(width/2);
   args[ta++] = (short)storage;

   return ta;
}



/***
** Function: CreateStdStems
**
** Description:
**   
***/
USHORT CreateStdStems(UBYTE *prep, USHORT tp, const short cnt)
{
   if (cnt>255) {
      prep[tp++] = op_pushw1;
      prep[tp++] = HIBYTE(cnt);
      prep[tp++] = LOBYTE(cnt);
      prep[tp++] = op_pushb1;
      prep[tp++] = TTFUN_STEM_STD_WIDTH;
   } else {
      prep[tp++] = op_pushb1 + 1;
      prep[tp++] = (UBYTE)cnt;
      prep[tp++] = TTFUN_STEM_STD_WIDTH;
   }

   prep[tp++] = op_loopcall;

   return tp;
}



/***
** Function: CreateSnapStems
**
** Description:
**   
***/
USHORT CreateSnapStems(UBYTE *prep, USHORT tp, const short cnt)
{
   if (cnt>255) {
      prep[tp++] = op_pushw1;
      prep[tp++] = HIBYTE(cnt);
      prep[tp++] = LOBYTE(cnt);
      prep[tp++] = op_pushb1;
      prep[tp++] = TTFUN_STEM_SNAP_WIDTH;
   } else {
      prep[tp++] = op_pushb1 + 1;
      prep[tp++] = (UBYTE)cnt;
      prep[tp++] = TTFUN_STEM_SNAP_WIDTH;
   }

   prep[tp++] = op_loopcall;

   return tp;
}




/***
** Function: tt_GetFontProg
**
** Description:
**   This function returns the static font
**   font program.
***/
const UBYTE *tt_GetFontProg(void)
{
   return FontProg;
}




/***
** Function: tt_GetFontProgSize
**
** Description:
**   This function returns the size of the
**   static font program.
***/
USHORT tt_GetFontProgSize(void)
{
   return (USHORT)sizeof(FontProg);
}




/***
** Function: tt_GetNumFuns
**
** Description:
**   This function returns the number of functions
**   defined in the static font program.
***/
USHORT tt_GetNumFuns(void)
{
   return (USHORT)TTFUN_NUM;
}



/***
** Function: EmitFlex
**
** Description:
**   Convert a T1 flex hint into a TrueType IP[] 
**   intruction sequence that will reduce a flex
**   that is flatter than a given height.
***/
errcode EmitFlex(short *args,
                 short *pcd,
                 const funit height,
                 const short start,
                 const short mid,
                 const short last)
{
   errcode status = SUCCESS;
   int i;

   /* Enough space for the instructions? */
   args[(*pcd)++] = TTFUN_FLEX;
   args[(*pcd)++] = start;
   args[(*pcd)++] = mid;
   args[(*pcd)++] = (short)height;
   args[(*pcd)++] = TMPCVT;
   args[(*pcd)++] = TMPCVT;
   args[(*pcd)++] = mid;
   args[(*pcd)++] = start;
   args[(*pcd)++] = mid;

   /* Push the flex points onto the stack. */
   args[(*pcd)++] = (short)(last-start-2);
   for (i=start+(short)1; i<last; i++)
      if (i!=mid)
         args[(*pcd)++] = (short)i;

   return status;
}




/***
** Function: ReduceDiagonals
**
** Description:
**   This function generates the TT instructions
**   that will shrink the outline, in order to
**   control the width of diagonals. This implementation
**   can probably be improved.
***/
short ReduceDiagonals(const Outline *paths,
                      UBYTE *pgm, short *pc,
                      short *args,  short *pcd)
{
   short cw[MAXTHINPNTS];
   short ccw[MAXTHINPNTS];
   short targ[MAXTHINPNTS];
   const Outline *path;
   Point *pts;
   short i,j;
   short cwi = 0, ccwi = 0;
   short prev;
   short n,m;
   short prev_cw, prev_ccw;
   short ta;



   /* Collect points on left and right side that are diagonals. */
   i = 0;
   for (path = paths; path && ccwi<MAXTHINPNTS && cwi<MAXTHINPNTS;
   path=path->next) {

      pts = &path->pts[0];
      prev_cw = FALSE;
      prev_ccw = FALSE;

      /* Are the first and last point coinciding? */
      if (pts[path->count-1].x!=pts[0].x ||
          pts[path->count-1].y!=pts[0].y)
         prev = (short)(path->count-(short)1);
      else
         prev = (short)(path->count-(short)2);

      /* Special case the first point. */
      if (!OnCurve(path->onoff, prev) ||
          (pts[0].x != pts[prev].x &&
           ABS(pts[0].x - pts[prev].x) < ABS(pts[0].y - pts[prev].y)*8)) {
         if (pts[0].y>pts[prev].y+20) {
            if (pts[prev].y<=pts[prev-1].y)
               cw[cwi++] = (short)(i+(short)path->count-1);
            cw[cwi++] = i;
            prev_cw = TRUE;
            prev_ccw = FALSE;
         } else if (pts[0].y<pts[prev].y-20) {
            if (pts[prev].y>=pts[prev-1].y)
               ccw[ccwi++] = (short)(i+(short)path->count-1); 
            ccw[ccwi++] = i;
            prev_cw = FALSE;
            prev_ccw = TRUE;
         }
      }


      for (j=1; j<(short)path->count &&
             ccwi<MAXTHINPNTS && cwi<MAXTHINPNTS; j++) {
         i++;
         if (!OnCurve(path->onoff, j-1) ||
             (pts[j].x != pts[j-1].x &&
              ABS(pts[j].x - pts[j-1].x) < ABS(pts[j].y - pts[j-1].y)*8)) {
            if (pts[j].y>pts[j-1].y+20) {
               if (!prev_cw)
                  cw[cwi++] = (short)(i-1);
               cw[cwi++] = i;
               prev_cw = TRUE; 
               prev_ccw = FALSE;
            } else if (pts[j].y<pts[j-1].y-20) {
               if (!prev_ccw)
                  ccw[ccwi++] = (short)(i-1);
               ccw[ccwi++] = i;
               prev_cw = FALSE;
               prev_ccw = TRUE;
            } else {
               prev_cw = FALSE;
               prev_ccw = FALSE;
            }
         } else {
            prev_cw = FALSE;
            prev_ccw = FALSE;
         }
      }
      i++;
   }


   /* Did we get all points? */
   if (ccwi>=MAXTHINPNTS || cwi>=MAXTHINPNTS) {
      LogError(MSG_WARNING, MSG_DIAG, NULL);
   }


   /* Any points to shift? */
   if (cwi || ccwi) {
      args[(*pcd)++] = STORAGE_DIAG;
      pgm[(*pc)++] = op_rs;
      pgm[(*pc)++] = op_if;
      pgm[(*pc)++] = op_svcta + SUBOP_X;

      /* Switch over to GLYPHZONE */
      pgm[(*pc)++] = op_szp2;
      args[(*pcd)++] = 1;


      ta = 3;

      /* Disable "cw[m] may not have been initialized".*/ /*lint -e644 */
      for (n=0; n<cwi; n=m) {
         for (m=(short)(n+1); m<cwi && cw[m]==cw[m-1]+1; m++); /*lint +e644 */
         if (m-n<=4) {
            for (i=n; i<m; i++)
               targ[ta++] = cw[i];
         } else {
            targ[0] = TTFUN_RANGE;
            targ[1] = (short)(m-n-1);
            targ[2] = cw[n];
            AssembleArgs(targ, ta, pgm, pc);
            pgm[(*pc)++] = op_loopcall;
            ta = 3;
         }
      }
      targ[0] = TTFUN_SHIFT1;
      targ[1] = cwi;
      targ[2] = STORAGE_DIAG;
      AssembleArgs(targ, ta, pgm, pc);
      pgm[(*pc)++] = op_call;


      /************ Shift back the left side of the glyph. */

      ta = 3;

      /* Disable "ccw[m] may not have been initialized".*/ /*lint -e644 */
      for (n=0; n<ccwi; n=m) {
         for (m=(short)(n+1); m<ccwi && ccw[m]==ccw[m-1]+1; m++); /*lint +e644 */
         if (m-n<=4) {
            for (i=n; i<m; i++)
               targ[ta++] = ccw[i];
         } else {
            targ[0] = TTFUN_RANGE;
            targ[1] = (short)(m-n-1);
            targ[2] = ccw[n];
            AssembleArgs(targ, ta, pgm, pc);
            pgm[(*pc)++] = op_loopcall;
            ta = 3;
         }
      }
      targ[0] = TTFUN_SHIFT2;
      targ[1] = ccwi;
      targ[2] = STORAGE_DIAG;
      AssembleArgs(targ, ta, pgm, pc);
      pgm[(*pc)++] = op_call;


#ifdef SYMETRICAL_REDUCTION

      /* The amount that the outline is shrunk is computed once at
      each size, in the pre-program. The outline is shrunk
      symetrically by the amount: 1/16 + (12 Funits)*size/UPEm.

      This approach yields more symmetrical results than shrinking
      the outline horizontally alone (see separate papers on the topic). */


      /* Same thing for the height... */
      i = 0;
      cwi = 0;
      ccwi = 0;
      for (path = paths; path && ccwi<MAXTHINPNTS && cwi<MAXTHINPNTS;
      path=path->next) {

         pts = &path->pts[0];

         /* Are the first and last point coinciding? */
         if (pts[path->count-1].y!=pts[0].y ||
             pts[path->count-1].x!=pts[0].x)
            prev = path->count-1;
         else
            prev = path->count-2;

         if (!OnCurve(path->onoff, prev) ||
             (pts[0].y != pts[prev].y &&
              ABS(pts[0].y - pts[prev].y) < ABS(pts[0].x - pts[prev].x)*8)) {
            if (pts[0].x>pts[prev].x+20) {
               if (pts[prev].x<=pts[prev-1].x)
                  cw[cwi++] = i+path->count-1;
               cw[cwi++] = i;
            } else if (pts[0].x<pts[prev].x-20) {
               if (pts[prev].x>=pts[prev-1].x)
                  ccw[ccwi++] = i+path->count-1; 
               ccw[ccwi++] = i;
            }
         }


         for (j=1; j<path->count && ccwi<MAXTHINPNTS && cwi<MAXTHINPNTS; j++) {
            i++;
            if (!OnCurve(path->onoff, j-1) ||
                (pts[j].y != pts[j-1].y &&
                 ABS(pts[j].y - pts[j-1].y) < ABS(pts[j].x - pts[j-1].x)*8)) {
               if (pts[j].x>pts[j-1].x+20) {
                  if (!cwi || cw[cwi-1]!=i-1)
                     cw[cwi++] = i-1;
                  cw[cwi++] = i;
               } else if (pts[j].x<pts[j-1].x-20) {
                  if (!ccwi || ccw[ccwi-1]!=i-1)
                     ccw[ccwi++] = i-1;
                  ccw[ccwi++] = i;
               }
            }
         }
         i++;
      }


      if (ccwi>=MAXTHINPNTS || cwi>=MAXTHINPNTS) {
         LogError(MSG_WARNING, MSG_DIAG, NULL);
      }


      /* Any points to shift? */
      if (cwi || ccwi) {
         pgm[(*pc)++] = op_svcta + SUBOP_Y;


         for (n=0; n<cwi; n=m) {
            for (m=n+1; m<cwi && cw[m]==cw[m-1]+1; m++);
            pgm[(*pc)++] = op_pushb1 + 2;
            pgm[(*pc)++] = cw[n];
            pgm[(*pc)++] = (UBYTE)(m-n-1);
            pgm[(*pc)++] = TTFUN_RANGE;
            pgm[(*pc)++] = op_loopcall;
         }
         pgm[(*pc)++] = op_pushb1+2;
         pgm[(*pc)++] = STORAGE_DIAG;
         pgm[(*pc)++] = cwi;
         pgm[(*pc)++] = TTFUN_SHIFT2;
         pgm[(*pc)++] = op_call;



         /************ Shift back the left side of the glyph. */


         for (n=0; n<ccwi; n=m) {
            for (m=n+1; m<ccwi && ccw[m]==ccw[m-1]+1; m++);
            pgm[(*pc)++] = op_pushb1 + 2;
            pgm[(*pc)++] = (UBYTE)ccw[n];
            pgm[(*pc)++] = (UBYTE)(m-n-1);
            pgm[(*pc)++] = TTFUN_RANGE;
            pgm[(*pc)++] = op_loopcall;
         }
         pgm[(*pc)++] = op_pushb1+2;
         pgm[(*pc)++] = STORAGE_DIAG;
         pgm[(*pc)++] = (UBYTE)ccwi;
         pgm[(*pc)++] = TTFUN_SHIFT1;
         pgm[(*pc)++] = op_call;
      }
#endif

      pgm[(*pc)++] = op_eif;
   }

   /* Args + num of args + function number. */
   return (short)(MAX(cwi, ccwi)+2); 
}




/***
** Function: ScaleDown3
**
** Description:
**   This function generates the TT instructions
**   that will scale down points 3%.
***/
void ScaleDown3(const Extremas *extr, const short xcnt, 
                UBYTE *pgm, short *pc,
                short *args, short *pcd)
{
   short i,j,offset, opc, opcd;

   /* Remember the state of the stacks. */
   opc = (*pc);
   opcd = (*pcd);

   args[(*pcd)++] = TTFUN_SCALE3;

   offset = (*pcd)++;
   args[offset] = 0;
   for (i=0; i<xcnt; i++) {
      if ((extr[i].rp1==UNDEF || extr[i].rp2==UNDEF)) {
         for (j=0; j<extr[i].n; j++) {
            args[(*pcd)++] = extr[i].pts[j];
         }
         args[offset] = (short)(args[offset] + extr[i].n);
      }
   }
   if (args[offset]>0) {
      pgm[(*pc)++] = op_call;
   } else {
      /* Back track. */
      (*pc) = opc;
      (*pcd) = opcd;
   }
}


/***
** Function: EmitIP
**
** Description:
**   This function generates the TT instructions
**   that will interpolate points that are either
**   within or between stem sides.
***/
void EmitIP(const Extremas *extr, const short xcnt, 
            UBYTE *pgm, short *pc,
            short *args, short *pcd,
            const short scale3offset)
{
   short i,j,num;
   short ones[MAXIP], twoes[MAXIP], nths[MAXIP];
   short cnt1, cnt2, cntn;


   /*lint -e530 -e644 */
   /* Shift extrems. */
   cnt1 = 0; cnt2 = 0; cntn = 0; num = 0;
   for (i=0; i<xcnt; i++) {
      short rp;

      /* Skip interpolations. */
      if (extr[i].rp1!=UNDEF && extr[i].rp2!=UNDEF)
         continue;

      /* Set the reference points. */
      if (extr[i].rp1!=UNDEF) {
         rp = (short)(extr[i].rp1+scale3offset);
      }  else {
         rp = (short)(extr[i].rp2+scale3offset);
      }

      if (extr[i].n==1) {
         if ((cnt1+2)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_SHP1;
            args[(*pcd)++] = (short)(cnt1/2);
            for (j=0; j<cnt1; j++)
               args[(*pcd)++] = (short)ones[j];
            cnt1 = 0;
         }
         ones[cnt1++] = rp;
         ones[cnt1++] = extr[i].pts[0];
      } else if (extr[i].n==2) {
         if ((cnt2+3)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_SHP2;
            args[(*pcd)++] = (short)(cnt2/3);
            for (j=0; j<cnt2; j++)
               args[(*pcd)++] = (short)twoes[j];
            cnt2 = 0;
         }
         twoes[cnt2++] = rp;
         twoes[cnt2++] = extr[i].pts[0];
         twoes[cnt2++] = extr[i].pts[1];
      } else {
         if ((cntn+2+extr[i].n)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_SHPN;
            args[(*pcd)++] = num;
            for (j=0; j<cntn; j++)
               args[(*pcd)++] = (short)nths[j];
            cntn = 0;
            num = 0;
         }
         nths[cntn++] = rp;
         nths[cntn++] = extr[i].n;
         for (j=0; j<extr[i].n; j++) {
            nths[cntn++] = extr[i].pts[j];
         }
         num++;
      }
   }

   if (cnt1) {
      if (cnt1>2) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_SHP1;
         args[(*pcd)++] = (short)(cnt1/2);
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_SHP1;
      }
      for (i=0; i<cnt1; i++)
         args[(*pcd)++] = ones[i];
   }
   if (cnt2) {
      if (cnt2>3) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_SHP2;
         args[(*pcd)++] = (short)(cnt2/3);
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_SHP2;
      }
      for (i=0; i<cnt2; i++)
         args[(*pcd)++] = twoes[i];
   }
   if (cntn) {
      if (num>1) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_SHPN;
         args[(*pcd)++] = num;
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_SHPN;
      }
      for (i=0; i<cntn; i++)
         args[(*pcd)++] = (short)nths[i];
   }


   /* Interpolate the extrems. */
   cnt1 = 0; cnt2 = 0; cntn = 0; num = 0;
   for (i=0; i<xcnt; i++) {

      /* Skip interpolations. */
      if (extr[i].rp1==UNDEF || extr[i].rp2==UNDEF)
         continue;

      if (extr[i].n==1) {
         if ((cnt1+3)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_IP1;
            args[(*pcd)++] = (short)(cnt1/2);
            for (j=0; j<cnt1; j++)
               args[(*pcd)++] = (short)ones[j];
            cnt1 = 0;
         }
         ones[cnt1++] = extr[i].rp1;
         ones[cnt1++] = extr[i].rp2;
         ones[cnt1++] = extr[i].pts[0];
      } else if (extr[i].n==2) {
         if ((cnt2+4)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_IP2;
            args[(*pcd)++] = (short)(cnt2/3);
            for (j=0; j<cnt2; j++)
               args[(*pcd)++] = (short)twoes[j];
            cnt2 = 0;
         }
         twoes[cnt2++] = extr[i].rp1;
         twoes[cnt2++] = extr[i].rp2;
         twoes[cnt2++] = extr[i].pts[0];
         twoes[cnt2++] = extr[i].pts[1];
      } else {
         if ((cntn+3+extr[i].n)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_IPN;
            args[(*pcd)++] = num;
            for (j=0; j<cntn; j++)
               args[(*pcd)++] = (short)nths[j];
            cntn = 0;
            num = 0;
         }
         nths[cntn++] = extr[i].rp1;
         nths[cntn++] = extr[i].rp2;
         nths[cntn++] = extr[i].n;
         for (j=0; j<extr[i].n; j++) {
            nths[cntn++] = extr[i].pts[j];
         }
         num++;
      }
   }

   if (cnt1) {
      if (cnt1>3) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_IP1;
         args[(*pcd)++] = (short)(cnt1/3);
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_IP1;
      }
      for (i=0; i<cnt1; i++)
         args[(*pcd)++] = (short)ones[i];
   }
   if (cnt2) {
      if (cnt2>4) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_IP2;
         args[(*pcd)++] = (short)(cnt2/4);
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_IP2;
      }
      for (i=0; i<cnt2; i++)
         args[(*pcd)++] = (short)twoes[i];
   }
   if (cntn) {
      if (num>1) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_IPN;
         args[(*pcd)++] = num;
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_IPN;
      }
      for (i=0; i<cntn; i++)
         args[(*pcd)++] = (short)nths[i];
   }
   /*lint +e530 +e644 */
}




/***
** Function: EmitVerticalStem
**
** Description:
**   This function generates the code that
**   will initiate the graphics state of the
**   TrueType interpreter for the grid fitting
**   of vertical stems.
***/
void EmitVerticalStems(UBYTE *pgm, short *pc, short *args, short *pcd)
{
   pgm[(*pc)++] = op_call;
   args[(*pcd)++] = TTFUN_VERTICAL;
}





/***
** Function: EmitHorizontalStem
**
** Description:
**   This function generates the code that
**   will initiate the graphics state of the
**   TrueType interpreter for the grid fitting
**   of vertical stems.
***/
void EmitHorizontalStems(UBYTE *pgm, short *pc, short *args, short *pcd)
{
   pgm[(*pc)++] = op_call;
   args[(*pcd)++] = TTFUN_HORIZONTAL;
}





/***
** Function: EmitVStem
**
** Description:
**   This function generates the code that
**   will create and grid fit points in the
**   twilight zone, corresponding to a vstem.
***/
errcode EmitVStem(UBYTE *pgm, short *pc,
                  short *args, short *pcd,
                  struct T1Metrics *t1m,
                  const funit width,
                  const funit real_side1,
                  const funit real_side2,
                  const funit side1,
                  const funit side2,
                  const short rp,
                  const enum aligntype align,
                  const short ref)
{
                     errcode status = SUCCESS;
                     short w_storage;

                     if ((w_storage = GetVStemWidth(GetWeight(t1m), width))==NOMEM) {
                        SetError(status = NOMEM);
                     } else {

                        pgm[(*pc)++] = op_call;
                        switch (align) {
                           case at_centered:
                              args[(*pcd)++] = TTFUN_VCENTER;
                              args[(*pcd)++] = (short)real_side1;
                              args[(*pcd)++] = (short)real_side2;
                              args[(*pcd)++] = (short)side1;
                              args[(*pcd)++] = (short)side2;
                              args[(*pcd)++] = (short)((side1+side2)/2);
                              args[(*pcd)++] = rp;
                              args[(*pcd)++] = w_storage;
                              break;

                           case at_relative1:
                              args[(*pcd)++] = TTFUN_RELATIVE1V;
                              args[(*pcd)++] = (short)real_side1;
                              args[(*pcd)++] = (short)real_side2;
                              args[(*pcd)++] = (short)side1;
                              args[(*pcd)++] = (short)side2;
                              args[(*pcd)++] = ref;
                              args[(*pcd)++] = rp;
                              args[(*pcd)++] = w_storage;
                              break;

                           case at_relative2:
                              args[(*pcd)++] = TTFUN_RELATIVE2V;
                              args[(*pcd)++] = (short)real_side1;
                              args[(*pcd)++] = (short)real_side2;
                              args[(*pcd)++] = (short)side1;
                              args[(*pcd)++] = (short)side2;
                              args[(*pcd)++] = ref;
                              args[(*pcd)++] = rp;
                              args[(*pcd)++] = w_storage;
                              break;

                           case at_side1:
                           case at_side2:
                              LogError(MSG_WARNING, MSG_ALIGN, NULL);
                              break;
                        }
                     }

                     return status;
} 




/***
** Function: EmitHStem
**
** Description:
**   This function generates the code that
**   will create and grid fit points in the
**   twilight zone, corresponding to a hstem.
***/
errcode EmitHStem(UBYTE *pgm, short *pc,
                  short *args, short *pcd,
                  struct T1Metrics *t1m,
                  const funit width,
                  const funit side1,
                  const funit side2,
                  const short rp,
                  const enum aligntype align,
                  const short ref)
{
   errcode status = SUCCESS;
   short w_storage;

   if ((w_storage = GetHStemWidth(GetWeight(t1m), width))==NOMEM) {
      SetError(status = NOMEM);
   } else {

      pgm[(*pc)++] = op_call;
      switch (align) {

         case at_side1:
            args[(*pcd)++] = TTFUN_SIDE1;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = ref;
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;

         case at_side2:
            args[(*pcd)++] = TTFUN_SIDE2;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = ref;
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;

         case at_relative1:
            args[(*pcd)++] = TTFUN_RELATIVE1H;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = ref;
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;

         case at_relative2:
            args[(*pcd)++] = TTFUN_RELATIVE2H;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = ref;
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;

         case at_centered:
         default:
            args[(*pcd)++] = TTFUN_HCENTER;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = (short)((side1+side2)/2);
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;
      }
   }

   return status;
}






/***
** Function: FamilyCutIn
**
** Description:
**   This function generates a branch in the
**   pre-program. 
***/
USHORT FamilyCutIn(UBYTE *prep,
                   USHORT tp,
                   const short cis)
{
   prep[tp++] = op_mppem;
   if (cis<256) {
      prep[tp++] = op_pushb1; prep[tp++] = (UBYTE)cis;
   } else {
      prep[tp++] = op_pushw1;
      prep[tp++] = HIBYTE(cis);
      prep[tp++] = LOBYTE(cis);
   }
   prep[tp++] = op_lt;
   prep[tp++] = op_if;

   return tp;
}




/***
** Function: SetProjection
**
** Description:
**   This function generates the TrueType code that
**   changes the projection vector in oblique typefaces.
***/
void SetProjection(UBYTE *pgm, short *pc,
                   short *args, short *pcd,
                   const funit x, const funit y)
{
   pgm[(*pc)++] = op_call;
   args[(*pcd)++] = TTFUN_OBLIQUE;
   args[(*pcd)++] = (short)y;
   args[(*pcd)++] = (short)x;
}


/***
** Function: AssembleArgs
**
** Description:
**   This function takes a sequence of arguments and
**   assembles them into a sequence of PUSHB1[], PUSHW1[],
**   NPUSHB[] and NPUSHW[] instructions.
***/
void AssembleArgs(short *args, const short pcd, UBYTE *is, short *cnt)
{
   short bytes;
   short i,j;


   if ((args[pcd-1] <= UCHAR_MAX && args[pcd-1]>=0)) {
      bytes = 1;
   } else {
      bytes = 0;
   }

   for (i=0, j=0; j<pcd; i++) {

      /* Pack a sequence of bytes? */
      if (bytes) {
         if ((i-j)>=255 || i==pcd ||
             (args[pcd-i-1]>UCHAR_MAX || args[pcd-i-1]<0)) {
            bytes = 0;
            if ((i-j)<=8) {
               is[(*cnt)++] = (UBYTE)(op_pushb1 + (i-j) - 1);
            } else {
               is[(*cnt)++] = op_npushb;
               is[(*cnt)++] = (UBYTE)(i-j);
            }
            while (j<i)
               is[(*cnt)++] = (UBYTE)args[pcd-1-j++];
         }

         /* Pack a sequence of words? */
      } else {
         if ((i-j)>=255 || i==pcd || 
             (args[pcd-i-1]<=UCHAR_MAX && args[pcd-i-1]>=0)) {
            bytes = 1;
            if ((i-j)<=8) {
               is[(*cnt)++] = (UBYTE)(op_pushw1 + (i-j) - 1);
            } else {
               is[(*cnt)++] = op_npushw;
               is[(*cnt)++] = (UBYTE)(i-j);
            }
            while (j<i) {
               is[(*cnt)++] = HIBYTE(args[pcd-j-1]);
               is[(*cnt)++] = LOBYTE(args[pcd-j-1]);
               j++;
            }
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontreg\ttf.h ===
#define tag_cmap  0x70616d63        // 'cmap'
#define tag_gasp  0x70736167        // 'gasp'
#define tag_head  0x64616568        // 'head'
#define tag_hdmx  0x786d6468        // 'hdmx'
#define tag_hhea  0x61656868        // 'hhea'
#define tag_hmtx  0x78746d68        // 'hmtx'
#define tag_kern  0x6e72656b        // 'kern'
#define tag_LTSH  0x4853544c        // 'LTSH'
#define tag_maxp  0x7078616d        // 'maxp'
#define tag_name  0x656d616e        // 'name'
#define tag_OS2   0x322f534f        // 'OS/2'
#define tag_post  0x74736f70        // 'post'
#define tag_VDMX  0x584d4456        // 'VDMX'



typedef signed char    int8;
typedef unsigned char  uint8;
typedef short          int16;
typedef unsigned short uint16;
typedef long           int32;
typedef unsigned long  uint32;

typedef short          FUnit;
typedef unsigned short uFUnit;

typedef long Fixed;
typedef long Fract;



#define FS_2BYTE(p)  ( ((unsigned short)((p)[0]) << 8) |  (p)[1])
#define FS_4BYTE(p)  ( FS_2BYTE((p)+2) | ( (FS_2BYTE(p)+0L) << 16) )

#define SWAPW(a) ((int16) FS_2BYTE( (unsigned char *)(&a) ))
#define SWAPL(a) ((int32) FS_4BYTE( (unsigned char *)(&a) ))



typedef struct {
	uint32 bc;
	uint32 ad;
} BigDate;


typedef uint32 sfnt_TableTag;

typedef struct {
	sfnt_TableTag   tag;
	uint32          checkSum;
	uint32          offset;
	uint32          length;
} sfnt_DirectoryEntry, *sfnt_DirectoryEntryPtr;

typedef struct {
	int32 version;                  // 0x10000 (1.0)
	uint16 numOffsets;              // number of tables
	uint16 searchRange;             // (max2 <= numOffsets)*16
	uint16 entrySelector;           // log2 (max2 <= numOffsets)
	uint16 rangeShift;              // numOffsets*16-searchRange
	sfnt_DirectoryEntry table[1];   // table[numOffsets]
} sfnt_OffsetTable, *sfnt_OffsetTablePtr;


#define SFNT_MAGIC 0x5F0F3CF5

typedef struct {
	Fixed       version;            // for this table, set to 1.0
	Fixed       fontRevision;       // For Font Manufacturer
	uint32      checkSumAdjustment;
	uint32      magicNumber;        // signature, should always be 0x5F0F3CF5  == MAGIC
	uint16      flags;
	uint16      unitsPerEm;         // Specifies how many in Font Units we have per EM

	BigDate     created;
	BigDate     modified;

	FUnit       xMin;
	FUnit       yMin;
	FUnit       xMax;
	FUnit       yMax;

	uint16      macStyle;           // macintosh style word
	uint16      lowestRecPPEM;      // lowest recommended pixels per Em

	int16       fontDirectionHint;

	int16       indexToLocFormat;
	int16       glyphDataFormat;
} sfnt_FontHeader, *sfnt_FontHeaderPtr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontreg\fontreg.c ===
/***************************************************************************
 * MODULE:  FontReg.c
 *
 * PURPOSE: This module does a very simple thing: Moves font information 
 *          from the [fonts] section of the WIN.INI into the registry.
 *
 *          1)  If a font is in the \windows\system directory, it is moved
 *              to \windows\fonts. (If it is already in the fonts directory
 *              it is just left there.)
 *
 *          2)  The information is written into the Registry at:
 *                   HKLM\Software\Microsoft\Windows\CurrentVersion\Fonts
 *
 *          3)  The entry i removed from WIN.INI
 *
 *
 *          NOTE: This program has NOT been checked in a DBCS environment.
 *          Somethings will need to be changed, most notibly, checking for 
 *          a backslash in a path name.
 *
 *
 * REVISION LOG:
 *    10/17/94    Initial revision. Eric Robinson, ElseWare Corporation.
 *                eric@elseware.com.
 *
 *
 ***************************************************************************/

////#include <windows.h>

#include <excpt.h>	// From windows.h.
#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winuser.h>
#include <winnls.h>
#include <winreg.h>


#include "ttf.h"


HKEY  hKeyFonts;

char szWindowsDir[MAX_PATH];
char szSystemDir[MAX_PATH];
char szSharedDir[MAX_PATH];
char szFontsDir[MAX_PATH];

BOOL bNetworkInstall;

BYTE Buffer[2048];


typedef struct
 {
  DWORD dwVersion;
  DWORD dwFlags;
  UINT  uDriveType;
  char  *pszFilePart;
  char  szIniName[MAX_PATH];
  char  szFullPath[MAX_PATH];
 } FILEDETAILS, *PFILEDETAILS;


//*****************************************************************************
//**************************   D P R I N T F   ********************************
//*****************************************************************************

#ifdef DEBUG   //************  DEBUG  **************

void msgprintf( LPCSTR pszMsg, ... )
 {
  char ach[256];

  wvsprintf(ach, pszMsg, ((char *)&pszMsg + sizeof(char *)));
  OutputDebugString(ach);
 }

#define dprintf( args ) msgprintf args

#else          //***********  RETAIL  *************

#define dprintf( args )

#endif


//*****************************************************************************
//******************   A P P E N D   F I L E   N A M E   **********************
//*****************************************************************************

void AppendFileName( PSZ pszPath, PSZ pszFile )
 {
  int cbPath;

  cbPath = lstrlen(pszPath);
  if( pszPath[cbPath-1] != '\\' ) pszPath[cbPath++] = '\\';

  lstrcpy( pszPath+cbPath, pszFile );
 }


//*****************************************************************************
//*************************   O P E N   K E Y   *******************************
//*****************************************************************************

#define szCurrentVersion "Software\\Microsoft\\Windows\\CurrentVersion"

HKEY OpenKey( char *pszKey )
 {
  HKEY  hKey;
  LONG  lrc;
  DWORD dwBogus;
  char  szSubKey[256];


  lstrcpy( szSubKey, szCurrentVersion );
  lstrcat( szSubKey, pszKey );

  dprintf(( "   RegCreateKeyEx('%s')\n", szSubKey ));

  lrc = RegCreateKeyEx( HKEY_LOCAL_MACHINE,	    // hKey
  						      szSubKey,				    // lpszSubKey
  						      0L,							 // dwReserved
  						      NULL,						    // lpszClass
  						      REG_OPTION_NON_VOLATILE, // fdwOptions
  						      KEY_ALL_ACCESS,			 // samDesired
  						      NULL,							 // lpSecurityAttributes
  						      &hKey,						 // phkResult
  						      &dwBogus );					 // pdwDisposition

  if( lrc != ERROR_SUCCESS )
	{
    hKey = NULL;
	 dprintf(( "   Couldn't open registry key '%s'\n", szSubKey ));
	}

  return hKey;
 }


//*****************************************************************************
//****************   G E T   F O N T S   D I R E C T O R Y   ******************
//*****************************************************************************

void GetFontsDirectory( void )
 {
  HKEY   hKey;
  LONG   lrc = ERROR_SUCCESS+1;
  DWORD  cbShared;


  dprintf(( "Getting shared directory string from registry\r\n" ));

  hKey = OpenKey( "\\Setup" );
  if( hKey )
   {
    cbShared = MAX_PATH;

    lrc = RegQueryValueEx( hKey,					// hKey
    							  "SharedDir",			// lpszValueName
    							  NULL,					// lpdwReserved
    							  NULL,					// lpdwType
    							  szSharedDir,		   // lpbData
    							  &cbShared );    	// lpcbData

    RegCloseKey( hKey );
   }

  if( lrc != ERROR_SUCCESS )
   {
    dprintf(( "RegQueryValue( SharedDir ) failed! Error = %d\r\n", lrc ));
    dprintf(( "  Using path from GetWindowsDirectory\r\n" ));

    lstrcpy( szSharedDir, szWindowsDir );
   }

  dprintf(( "  szSharedDir = '%s'\r\n", szSharedDir ));

  lstrcpy( szFontsDir, szSharedDir );
  AppendFileName( szFontsDir, "fonts" );

  dprintf(( "  szFontsDir = '%s'\r\n", szFontsDir ));
 }


//*****************************************************************************
//*************************   G E T   D I R S   *******************************
//*****************************************************************************

void GetDirs( void )
 {
  GetWindowsDirectory( szWindowsDir, MAX_PATH );
  GetSystemDirectory( szSystemDir, MAX_PATH );

  GetFontsDirectory();

  bNetworkInstall = (lstrcmpi( szSharedDir, szWindowsDir ) != 0);

  dprintf(( "GetDirs\r\n" ));
  dprintf(( "  szWindowsDir = '%s'\r\n", szWindowsDir ));
  dprintf(( "  szSystemDir  = '%s'\r\n", szSystemDir  ));
  dprintf(( "  szSharedDir  = '%s'\r\n", szSharedDir  ));
  dprintf(( "  szFontsDir   = '%s'\r\n", szFontsDir   ));

  dprintf(( "  bNetworkInstall = %d\r\n", bNetworkInstall ));

 }


//*****************************************************************************
//********************   F I N D   F O N T   F I L E   ************************
//*****************************************************************************

#define MODE_WIN31  1
#define MODE_WIN95  2


PSZ FindFontFile( PSZ pszFile, PSZ pszFullPath, DWORD dwMode )
 {
  DWORD dwrc;
  PSTR  pszFilePart;


  dprintf(( "FindFontFile\r\n" ));
  pszFilePart = NULL;


// Search fonts directory first if in win95 mode

  if( dwMode == MODE_WIN95 )
   {
    dprintf(( "Calling SearchPath( %s, %s )\r\n", szFontsDir, pszFile ));
    dwrc = SearchPath( szFontsDir, 				// Path to search for file
     					     pszFile, 					// Filename to search for
  					        NULL, 						// No extension
  					        MAX_PATH,   				// Size of output buffer
    					     pszFullPath,				// Output buffer
    					     &pszFilePart );			// & of filename pointer

    dprintf(( "  dwrc = %u\n", dwrc ));
    if( dwrc ) goto FFFReturn;
   }


// Search win31 style

  dprintf(( "Calling SearchPath( NULL, %s )\r\n", pszFile ));
  dwrc = SearchPath( NULL,							// Path to search for file
                     pszFile,						// Filename to search for
                     NULL,							// No extension
                     MAX_PATH,					// Size of output buffer
                     pszFullPath,				// Output buffer
                     &pszFilePart );			// & of filename pointer

  dprintf(( "  dwrc = %u\r\n", dwrc ));


// If not found and in win31 mode, search in fonts folder

  if( !dwrc && dwMode == MODE_WIN31 )
   {
    dprintf(( "Calling SearchPath( %s, %s )\r\n", szFontsDir, pszFile ));
    dwrc = SearchPath( szFontsDir, 				// Path to search for file
     					     pszFile, 					// Filename to search for
  					        NULL, 						// No extension
  					        MAX_PATH,   				// Size of output buffer
    					     pszFullPath,				// Output buffer
    					     &pszFilePart );			// & of filename pointer

    dprintf(( "  dwrc = %u\n", dwrc ));
   }


FFFReturn:
  return pszFilePart;
 }


//*****************************************************************************
//*******************   G E T   F I L E   D E T A I L S   *********************
//*****************************************************************************

#define IN_SYSTEM   0x0001
#define IN_WINDOWS  0x0002
#define IN_SHARED   0x0004
#define IN_FONTS    0x0008
#define IN_OTHER    0x0010

#define FON_FILE    0x0100
#define FOT_FILE    0x0200
#define TTF_FILE    0x0400

#define SZT2BANNER  "This is a TrueType font, not a program.\r\r\n$"


BOOL GetFileDetails( PSTR pszIniFile, PFILEDETAILS pfd, DWORD dwMode )
 {
  HANDLE hFile;
  char   szDir[MAX_PATH];


//-----------------------  Crunch source filename  ----------------------------

  pfd->dwFlags    = 0;
  pfd->uDriveType = 0;
  pfd->dwVersion  = 0;
  lstrcpy( pfd->szIniName, pszIniFile );


  dprintf(( "GetFileDetails\r\n" ));
  dprintf(( "  pszIniFile = '%s'\r\n",    pszIniFile ));
  dprintf(( "  dwMode     = 0x%.8lX\r\n", dwMode     ));


  pfd->pszFilePart = FindFontFile( pszIniFile, pfd->szFullPath, dwMode );
  if( !pfd->pszFilePart )
   {
    dprintf(( "  Couldn't find file\r\n" ));
    return FALSE;
   }

  dprintf(( "    szFullPath  = '%s'\r\n", pfd->szFullPath ));
  dprintf(( "    pszFilePart = '%s'\r\n", pfd->pszFilePart ));


//------------------  Figure out which directory its in  ----------------------

  lstrcpy( szDir, pfd->szFullPath );
  szDir[pfd->pszFilePart-pfd->szFullPath-1] = '\0';

  dprintf(( "  szDir = '%s'\r\n", szDir ));

  if(       !lstrcmpi(szSystemDir,szDir) )
    pfd->dwFlags |= IN_SYSTEM;
   else if( !lstrcmpi(szWindowsDir,szDir) )
    pfd->dwFlags |= IN_WINDOWS;
   else if( !lstrcmpi(szSharedDir,szDir) )
    pfd->dwFlags |= IN_SHARED;
   else if( !lstrcmpi(szFontsDir,szDir) )
    pfd->dwFlags |= IN_FONTS;


  if( szDir[0] != '\\' )
    {
     szDir[3] = 0;
     dprintf(( "GetDriveType( %s )\r\n", szDir ));
     pfd->uDriveType = GetDriveType( szDir );
    }
   else
    pfd->uDriveType = DRIVE_REMOTE;

  dprintf(( "  uDriveType = %d\r\n", pfd->uDriveType ));


//-----------------  Read in first chunk for examination  ---------------------

  hFile = CreateFile( pfd->szFullPath,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL );

  if( hFile != INVALID_HANDLE_VALUE )
    {
     DWORD dwRead;

     if( ReadFile( hFile, Buffer, sizeof(Buffer), &dwRead, NULL ) )
       {
        if( lstrcmp( &Buffer[78], SZT2BANNER ) == 0 )   // FOT check
          {
           dprintf(( "  FOT file\r\n" ));
           pfd->dwFlags |= FOT_FILE;
          }
         else if( *(WORD *)&Buffer[0] == 0x5A4D )       // FON check
          {
           dprintf(( "  FON file\r\n" ));
           pfd->dwFlags |= FON_FILE;
          }
         else                                           // TTF check
          {
           int i, nOffsets;
           sfnt_OffsetTablePtr    pOffsetTable;
           sfnt_DirectoryEntryPtr pDirEntry;
           sfnt_FontHeader        FontHeader;


           dprintf(( " Checking for TTF file\r\n" ));

           pOffsetTable = (sfnt_OffsetTablePtr)Buffer;
           nOffsets     = (int)SWAPW(pOffsetTable->numOffsets);

           dprintf(( "   Version    = 0x%.8X\r\n", SWAPL(pOffsetTable->version) ));
           dprintf(( "   numOffsets = %d\r\n",     nOffsets ));

           if( nOffsets < sizeof(Buffer)/sizeof(sfnt_DirectoryEntry) )
             {
              pDirEntry = (sfnt_DirectoryEntryPtr)pOffsetTable->table;

              for( i = 0; i < nOffsets; i++, pDirEntry++ )
               {
#ifdef DEBUG
                DWORD dwTag[2];
             
                dwTag[0] = (DWORD)pDirEntry->tag;
                dwTag[1] = 0;
                dprintf(( "  tag[%d] = '%s'\r\n", i, (PSZ)&dwTag[0] ));
#endif

                if( pDirEntry->tag == tag_head )
                 {
                  dprintf(( "Found 'head' table\r\n" ));
                  dprintf(( "  offset = %d\r\n", SWAPL(pDirEntry->offset) ));
                  dprintf(( "  length = %d\r\n", SWAPL(pDirEntry->length) ));

                  SetFilePointer( hFile, SWAPL(pDirEntry->offset), NULL, FILE_BEGIN );
                  
                  FontHeader.fontRevision = 0;
                  ReadFile( hFile, &FontHeader, sizeof(FontHeader), &dwRead, NULL );
                  
                  dprintf(( "  fontRevision = 0x%.8X\r\n", SWAPL(FontHeader.fontRevision) ));
                  
                  pfd->dwVersion = SWAPL(FontHeader.fontRevision);
                  pfd->dwFlags  |= TTF_FILE;
                  
                  break;
                 }
               }
           
             }
            else
             {
              dprintf(( "OffsetTable.numOffsets is out of range!" ));
             }
          }
       }
      else
       {
        dprintf(( "  ReadFile failed\r\n" ));
       }

  	  CloseHandle( hFile );
    }
   else
    {
     dprintf(( "  CreateFile failed\r\n" ));
    }


  dprintf(( "  dwFlags = 0x%.8lX\r\n", pfd->dwFlags ));

  return TRUE;
 }


//*****************************************************************************
//*******************   D O R K   O N   R E G I S T R Y   *********************
//*****************************************************************************

void DorkOnRegistry( PSZ pszDescription, PSZ pszRegFile )
 {
  LONG lrc;

  dprintf(( "  Writing registry entry: '%s' '%s'\r\n", pszDescription, pszRegFile ));

  lrc = RegSetValueEx( hKeyFonts,
                       pszDescription,
                       0,
                       REG_SZ, 
                       pszRegFile,
                       lstrlen(pszRegFile) );

  if( lrc != ERROR_SUCCESS )
   {
    dprintf(( "*** error writing to registry! rc = %d\r\n", GetLastError() ));
   }


  dprintf(( "<<< Calling AddFontResource(%s)\r\n", pszRegFile ));
  lrc = AddFontResource( pszRegFile );
  if( !lrc )
   {
    dprintf(( "*** AddFontResource(%s) failed!\r\n", pszRegFile ));
   }
 }


//*****************************************************************************
//********************   H A N D L E   E X I S T I N G   **********************
//*****************************************************************************

BOOL HandleExisting( char *pszCheck, PFILEDETAILS pfdSource )
 {
  FILEDETAILS fdExisting;


  dprintf(( "Looking for existing file'\r\n" ));

  dprintf(( "  pszCheck   = '%s'\r\n",   pszCheck ));

  dprintf(( "  Source file details\r\n" ));
  dprintf(( "    szIniName  = '%s'\r\n",   pfdSource->szIniName   ));
  dprintf(( "    szFullPath = '%s'\r\n",   pfdSource->szFullPath  ));
  dprintf(( "    szFilePart = '%s'\r\n",   pfdSource->pszFilePart ));
  dprintf(( "    dwFlags    = 0x%.8X\r\n", pfdSource->dwFlags     ));
  dprintf(( "    dwVersion  = 0x%.8X\r\n", pfdSource->dwVersion   ));

  if( !GetFileDetails( pszCheck, &fdExisting, MODE_WIN95 ) ) return FALSE;

  dprintf(( "  Existing file details\r\n" ));
  dprintf(( "    szIniPath  = '%s'\r\n",   fdExisting.szIniName   ));
  dprintf(( "    szFullPath = '%s'\r\n",   fdExisting.szFullPath  ));
  dprintf(( "    szFilePart = '%s'\r\n",   fdExisting.pszFilePart ));
  dprintf(( "    dwFlags    = 0x%.8X\r\n", fdExisting.dwFlags     ));
  dprintf(( "    dwVersion  = 0x%.8X\r\n", fdExisting.dwVersion   ));

  if( fdExisting.dwVersion >= pfdSource->dwVersion )
   {
    dprintf(( "Existing file is newer or the same, killing ini entry\r\n" ));

    if( (pfdSource->dwFlags & (TTF_FILE+IN_SYSTEM)) == (TTF_FILE+IN_SYSTEM) )
      {
       dprintf(( "Deleting older source file '%s'\r\n", pfdSource->szFullPath ));
       if( !DeleteFile( pfdSource->szFullPath ) )
        {
         dprintf(( "*** couldn't delete '%s', le = #%d\r\n", pfdSource->szFullPath, GetLastError() ));
        }
      }
     else
      {
       dprintf(( "Ini file not SYSTEM dir, not deleting\r\n" ));
      }

    return TRUE;   // return "source was older"
   }


  dprintf(( "Removing existing font resource\r\n" ));

  while( RemoveFontResource(fdExisting.szIniName) );   // Clear all instances
  while( RemoveFontResource(fdExisting.szFullPath) );
  while( RemoveFontResource(fdExisting.pszFilePart) );


  // If existing font is in fonts or system directory, delete it. But make
  //  make sure that the file we're deleting isn't the source file.

  if( fdExisting.dwFlags & (IN_SYSTEM+IN_FONTS)                   &&
      lstrcmpi(fdExisting.szFullPath,pfdSource->szFullPath)  != 0    )
   {
    dprintf(( "Deleting existing file '%s'\r\n", fdExisting.szFullPath ));
    if( !DeleteFile( fdExisting.szFullPath ) )
     {
      dprintf(( "*** error deleting '%s', le = #%d\r\n", fdExisting.szFullPath, GetLastError() ));
     }
   }

  return FALSE;   // return "source was newer or not existing"
 }


//*****************************************************************************
//*******************   P R O C E S S   I N I   L I N E   *********************
//*****************************************************************************

void ProcessIniLine( PSZ pszDescription, PSZ pszIniFile )
 {
  FILEDETAILS fdSource;
  FILEDETAILS fdFOT;

  char  szRegFile[MAX_PATH];


  dprintf(( "ProcessIniLine\r\n" ));
  dprintf(( "  pszDescription = '%s'\r\n", pszDescription ));
  dprintf(( "  pszIniFile     = '%s'\r\n", pszIniFile     ));

  fdSource.dwFlags = 0;
  fdFOT.dwFlags    = 0;

//--------------------  Get details on file in WIN.INI  -----------------------

  GetFileDetails( pszIniFile, &fdSource, MODE_WIN31 );
  if( fdSource.dwFlags == 0 )
   {
    // This is bad, it means we couldn't find the font file referenced
    //  in WIN.INI. That means that gdi probably won't find it either but
    //  to be extra safe I'll just copy the ini file entry to the registry
    //  so that we get the same bootup behavior as before.

////    dprintf(( "  Error getting file details, copying to registry\r\n" ));
////    DorkOnRegistry( pszDescription, pszIniFile );

    dprintf(( "  Couldn't find source file, nuking WIN.INI entry\r\n" ));
    WriteProfileString( "Fonts", pszDescription, NULL );

    return;
   }

  if( fdSource.dwFlags & FOT_FILE )
   {
    dprintf(( "  its an FOT file, getting TTF information\r\n" ));

    fdFOT = fdSource;
    GetFileDetails( &Buffer[0x400], &fdSource, MODE_WIN31 );

    //  If the ttf file for this fot file isn't found then simply
    //    use the fot file. This will emulate win31 behavior.
    //
    //  03/25/95 - mikegi
    //
    //  When the ttf file installed 'in place' on some sort of
    //    removable disk, then we'll use the fot file. Do this
    //    because we can't guarantee that the ttf file will be
    //    available on subsequent boots.
    //
    //  04/20/95 - mikegi

    if( fdSource.dwFlags    == 0           ||     // ttf file not found or
        fdSource.uDriveType != DRIVE_FIXED    )   //   is on non-fixed media
     {
      dprintf(( "  couldn't find ttf file or its on removable media" ));
      dprintf(( "    installing fot file" ));

      fdSource = fdFOT;
      fdFOT.dwFlags = 0;
     }
   }

//--------------  See if entry already exists in the registry  ----------------

  {
   LONG  lrc;
   DWORD dwExisting;
   char  szExisting[MAX_PATH];


   dprintf(( "Calling RegQueryValueEx('%s')\r\n", pszDescription ));

   dwExisting = sizeof(szExisting);
   lrc = RegQueryValueEx( hKeyFonts, pszDescription, NULL, NULL, szExisting, &dwExisting );
   dprintf(( "  lrc = %d\r\n", lrc ));

   if( lrc == ERROR_SUCCESS )
    {
     dprintf(( "Entry already exists in registry\r\n" ));
     dprintf(( "  szExisting = '%s'\r\n", szExisting ));

     if( HandleExisting(szExisting,&fdSource) ) goto CleanupSource;
    }
  }

//---------------------  Copy file to fonts directory  ------------------------

  if( fdSource.dwFlags & IN_SYSTEM )
    {
     dprintf(( "  Copying source from SYSTEM directory to FONTS folder\r\n" ));

     if( !(fdSource.dwFlags & FON_FILE) )
       {
        lstrcpy( szRegFile, szFontsDir );
        AppendFileName( szRegFile, fdSource.pszFilePart );
      
        dprintf(( "    Checking for existing file in FONTS folder\r\n" ));
      
        if( HandleExisting(szRegFile,&fdSource) )
          {
           // file exists in fonts dir, but no registry entry for it
           dprintf(( "  already in FONTS directory, just adding registry entry" ));
          }
         else
          {
           dprintf(( "    Moving file: '%s' to '%s'\r\n", fdSource.szFullPath, szRegFile ));
           if( !MoveFile( fdSource.szFullPath, szRegFile ) )
            {
             dprintf(( "*** MoveFile failed! rc = %d\r\n", GetLastError() ));
            }
          }
       }
      else
       {
        dprintf(( "  leaving .FON in SYSTEM directory\r\n" ));
       }

     lstrcpy( szRegFile, fdSource.pszFilePart );
    }
   else if( fdSource.dwFlags & IN_FONTS )
    {
     dprintf(( "  Leaving in FONTS dir: '%s'\r\n", fdSource.szFullPath ));
     lstrcpy( szRegFile, fdSource.pszFilePart );
    }
   else
    {
     dprintf(( "  Installing file in place: '%s'\r\n", fdSource.szFullPath ));
     lstrcpy( szRegFile, fdSource.szFullPath );
    }

  DorkOnRegistry( pszDescription, szRegFile );


//-----------------------  Delete source FOT file  ----------------------------

CleanupSource:
  dprintf(( "  Nuking WIN.INI entry: '%s'\r\n", pszDescription ));
  WriteProfileString( "Fonts", pszDescription, NULL );

  if( fdFOT.dwFlags & (FOT_FILE+IN_SYSTEM) == FOT_FILE+IN_SYSTEM )
   {
    dprintf(( "  Deleting '%s'\r\n", fdFOT.szFullPath ));
    if( !DeleteFile( fdFOT.szFullPath ) )
     {
      dprintf(( "*** couldn't delete '%s', le = #%d\r\n", fdFOT.szFullPath, GetLastError() ));
     }
   }
 }


//*****************************************************************************
//***********************   G E T   S E C T I O N   ***************************
//*****************************************************************************

int GetSection( LPSTR lpFile, LPSTR lpSection, LPHANDLE hSection)
{
    int    nCount;
    int    nSize;
    HANDLE hLocal, hTemp;
    char *pszSect;

    if( !( hLocal = LocalAlloc( LMEM_MOVEABLE, nSize=4096 ) ) )
        return( 0 );

    //
    //  Now that a buffer exists, Enumerate all LHS of the section.  If the
    //  buffer overflows, reallocate it and try again. 
    //

    do
    {
        pszSect = (PSTR) LocalLock( hLocal );

		if( lpFile )
			nCount = GetPrivateProfileString(lpSection, NULL, "", pszSect,
																		nSize, lpFile);
		else
			nCount = GetProfileString(lpSection, NULL, "", pszSect, nSize);

		LocalUnlock(hLocal);

      if (nCount <= nSize-10)
			break;

		nSize += 2048;
		if (!(hLocal = LocalReAlloc(hTemp=hLocal, nSize, LMEM_MOVEABLE)))
			{
			LocalFree(hTemp);
			return(0);
			}
    } while (1) ;

	*hSection = hLocal;
	return (nCount);
}


//*****************************************************************************
//******************   P R O C E S S   I N I   F I L E   **********************
//*****************************************************************************

void ProcessIt( void )
{
    char	  szFonts[] = "FONTS";
    PSTR	  pszItem;
    HANDLE  hLocalBuf;
    PSTR	  pLocalBuf, pEnd;
    int     nCount;
    char    szPath[ MAX_PATH ];


    GetDirs();

    nCount = GetSection(NULL, szFonts, &hLocalBuf);

    if( !hLocalBuf ) return;

    pLocalBuf = (PSTR) LocalLock(hLocalBuf);
    pEnd = pLocalBuf+nCount;

    // Add all the fonts in the list, if they haven't been added already

    for( pszItem=pLocalBuf; pszItem<pEnd; pszItem+=lstrlen(pszItem)+1)
    {
  	    if( !*pszItem ) continue;

  	    GetProfileString(szFonts, pszItem, "", szPath, sizeof(szPath));

  	    if( *szPath )
        {
            ProcessIniLine( pszItem, szPath );
  	    }
    }

    LocalUnlock( hLocalBuf );
    LocalFree( hLocalBuf );
}


//*****************************************************************************
//*************************   W I N   M A I N   *******************************
//*****************************************************************************

int APIENTRY WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
 {
  LONG  lrc;
  DWORD dwDisposition;

  lrc = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                        "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Fonts", 
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_SET_VALUE, 
                        NULL,
                        &hKeyFonts,
                        &dwDisposition );

  if( lrc == ERROR_SUCCESS )
    {
     ProcessIt();

     dprintf(( "  Flushing fonts key\r\n" ));
     RegFlushKey( hKeyFonts );

     RegCloseKey( hKeyFonts );
    }
   else
    {
     dprintf(( "*** RegCreateKeyEx failed! rc = %d\r\n", GetLastError() ));
    }                                                
                                                     
  return 0;                                          
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontext\t1instal\ttprog.h ===
/**
**   Description:
**      This is a module of the T1 to TT font converter. This is a
**      sub-module of Hint module. This modules deals with the 
**      the font program fo the font.
**
**   Author: Michael Jansson
**
**   Created: 8/24/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

#define HIBYTE(v)	(UBYTE)((USHORT)(v)>>8)
#define LOBYTE(v)	(UBYTE)((USHORT)(v)&0xff)

#define TWILIGHT  0
#define GLYPHZONE 1

#define TMPCVT 0L
#define TMPPNT 0L
#define TMPPNT1 1L

#define STORAGE_DIAG 3

#define ONEPIXEL    64L

#define INFINITY	   (USHORT)SHRT_MAX


#define MAXPTS 10         /* Max num of pts on a stem hint side. */


/* IP bucket - Used for collecting points that should be
interpolated within the zones defined by the stem hints. */
typedef struct Extremas {
   short rp1;
   short rp2;
   short n;
   short pts[MAXPTS];
} Extremas;



enum aligntype  {
   at_side1,
   at_side2,
   at_relative1,
   at_relative2,
   at_centered
};



/***
**
**   Description:
**      This file contains op-codes for a sub-set of the
**      TrueType instruction set.
**
**   Author: Michael Jansson
**
**   Created: 10/14/93
**
***/


/* TrueType sub-op codes. */
#define SUBOP_Y         0x00
#define SUBOP_X         0x01

#define SUBOP_R         0x01

#define SUBOP_MOVE      0x10
#define SUBOP_MINDIST   0x08
#define SUBOP_ROUND     0x04
#define SUBOP_GRAY      0x00

#define SUBOP_mMRGR  SUBOP_MINDIST | SUBOP_ROUND | SUBOP_GRAY
#define SUBOP_MmRGR  SUBOP_MOVE | SUBOP_ROUND | SUBOP_GRAY


/* TrueType op codes. */
enum {        
   op_mps = 0x4c,
   op_spvtl = 0x07,
   op_roll = 0x8a,
   op_gteq = 0x53,
   op_cindex =  0x25,
   op_rtdg = 0x3d,
   op_clear = 0x22,
   op_szp0 = 0x13,
   op_szp1 = 0x14,
   op_szp2 = 0x15,
   op_szps = 0x16,
   op_loopcall = 0x2a,
   op_shz = 0x36,
   op_smd = 0x1a,
   op_rutg = 0x7c,
   op_rdtg = 0x7d,
   op_pop = 0x21,
   op_abs = 0x64,
   op_scvtci = 0x1d,
   op_rs = 0x43,
   op_spvfs = 0x0a,
   op_shp = 0x33,
   op_roff = 0x7a,
   op_md = 0x49,
   op_ssw = 0x1f,
   op_mul = 0x63,
   op_odd = 0x56,
   op_gc = 0x46,
   op_dup = 0x20,
   op_min = 0x8c,
   op_max = 0x8b,
   op_neg = 0x65,
   op_sfvtl = 0x08,
   op_spvtca =  0x06,
   op_swap = 0x23,
   op_mdrp = 0xc0,
   op_mdap = 0x2e,
   op_miap = 0x3e,
   op_mirp = 0xe0,
   op_alignrp = 0x3c,
   op_iup = 0x30,
   op_svcta = 0x00,
   op_sloop = 0x17,
   op_npushb = 0x40,
   op_npushw = 0x41,
   op_mppem = 0x4b,
   op_lt = 0x50,
   op_gt = 0x52,
   op_if = 0x58,
   op_scfs = 0x48,
   op_else = 0x1b,
   op_wcvtf = 0x70,
   op_wcvtp = 0x44,
   op_pushw1 = 0xb8,
   op_pushb1 = 0xb0,
   op_eif = 0x59,
   op_shpix = 0x38,
   op_srp0 = 0x10,
   op_srp1 = 0x11,
   op_srp2 = 0x12,
   op_ip = 0x39,
   op_rcvt = 0x45,
   op_round = 0x68,
   op_rtg = 0x18,
   op_rthg = 0x19,
   op_add = 0x60,
   op_div = 0x62,
   op_scanctrl = 0x85,
   op_ws = 0x42,
   op_sswci = 0x1e,
   op_scantype = 0x8d,
   op_sub = 0x61,
   op_fdef = 0x2c,
   op_endf = 0x2d,
   op_call = 0x2b,
   op_getinfo = 0x88
};



/***
** Function: GetTopPos
**
** Description:
**   This function allocates a cvt entry for the 
**   top side of a horizontal stem;
***/
short	       GetTopPos	    _ARGS((IN	   Blues *blues,
					   INOUT   AlignmentControl *align,
					   IN	   funit pos));
/***
** Function: GetBottomPos
**
** Description:
**   This function allocates a cvt entry for the 
**   top side of a horizontal stem;
***/
short	       GetBottomPos	    _ARGS((IN	   Blues *blues,
					   INOUT   AlignmentControl *align,
					   IN	   funit pos));
/***
** Function: CutInSize
**
** Description:
**   This function computes the cut in size
**   of a stem, given a master width and the
**   width of the stem. This is done with the
**   StdVW==2.0 pixel treshold and the thinn
**   and wide cut in values.
***/
USHORT	       CutInSize	    _ARGS((IN	   funit width,
					   IN	   funit master,
					   IN	   USHORT tresh,
					   IN	   funit upem));

/***
** Function: SnapStemArgs
**
** Description:
**   
***/
USHORT	       SnapStemArgs	    _ARGS((OUT	   short *args,
					   INOUT   USHORT ta,
					   IN	   funit width,
					   IN	   USHORT std_cvt,
					   IN	   USHORT snap_cvt,
					   IN	   USHORT std_ci,
					   IN	   USHORT snap_ci,
					   IN	   USHORT storage));
/***
** Function: StdStemArgs
**
** Description:
**   
***/
USHORT	       StdStemArgs	    _ARGS((OUT	   short *args,
					   INOUT   USHORT ta,
					   IN	   funit width,
					   IN	   USHORT std_cvt,
					   IN	   USHORT std_ci,
					   IN	   USHORT storage));
/***
** Function: CreateStdStems
**
** Description:
**   
***/
USHORT	       CreateStdStems	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   USHORT tp,
					   IN	   short cnt));
/***
** Function: CreateSnapStems
**
** Description:
**   
***/
USHORT	       CreateSnapStems	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   USHORT tp,
					   IN	   short cnt));
/***
** Function: tt_GetFontProg
**
** Description:
**   This function returns the static font
**   font program.
***/
const UBYTE    *tt_GetFontProg	    _ARGS((void));


/***
** Function: tt_GetNumFuns
**
** Description:
**   This function returns the number of functions
**   defined in the static font program.
***/
USHORT	       tt_GetNumFuns	    _ARGS((void));


/***
** Function: tt_GetFontProgSize
**
** Description:
**   This function returns the size of the
**   static font program.
***/
USHORT	       tt_GetFontProgSize   _ARGS((void));


/***
** Function: SetZone
**
** Description:
**   This function initiate an alignment zone
**   by creating an appropriate point in the
**   twilight zone.
***/
USHORT	       SetZone		    _ARGS((INOUT   UBYTE *prep,
					   INOUT   USHORT tp,
					   IN	   short cvt));
/***
** Function: CopyZone
**
** Description:
**   This function copies a cvt entry, representing an
**   alignment zone, to the cvt used for a particular hstem.
***/
USHORT	       CopyZone		    _ARGS((INOUT   UBYTE *prep,
					   INOUT   short tp,
					   INOUT   short *args,
					   IN	   short ta));
/***
** Function: CopyFamilyBlue
**
** Description:
**   This function copies a cvt entry, representing a
**   family blue zone, to the cvt used for a particular hstem.
***/
USHORT	       CopyFamilyBlue	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   short tp,
					   INOUT   short *args,
					   IN	   short ta));
/***
** Function: AlignFlat
**
** Description:
**   This function creates a cvt entry for
**   a particular hstem.
***/
USHORT	       AlignFlat	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   short tp,
					   INOUT   short *args,
					   IN	   short ta));
/***
** Function: AlignOvershoot
**
** Description:
**   This function creates a cvt entry for
**   a particular hstem.
***/
USHORT	       AlignOvershoot	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   short tp,
					   INOUT   short *args,
					   IN	   short ta));
/***
** Function: EmitFlex
**
** Description:
**   Convert a T1 flex hint into a TrueType IP[] 
**   intruction sequence that will reduce a flex
**   that is flatter than a given height.
***/
errcode	       EmitFlex		    _ARGS((INOUT   short *args,
					   INOUT   short *pcd,
					   IN	   funit height,
					   IN	   short start,
					   IN	   short mid,
					   IN	   short last));
/***
** Function: ReduceDiagonals
**
** Description:
**   This function generates the TT instructions
**   that will shrink the outline, in order to
**   control the width of diagonals. This implementation
**   can probably be improved.
***/
short	       ReduceDiagonals	    _ARGS((IN	   Outline *paths,
					   INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd));
/***
** Function: ScaleDown3
**
** Description:
**   This function generates the TT instructions
**   that will scale down points 3%.
***/
void	       ScaleDown3	    _ARGS((IN	   Extremas *extr,
					   IN	   short xcnt, 
					   INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd));
/***
** Function: EmitIP
**
** Description:
**   This function generates the TT instructions
**   that will interpolate points that are either
**   within or between stem sides.
***/
void	       EmitIP		    _ARGS((IN	   Extremas *extr,
					   IN	   short xcnt, 
					   INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd,
					   IN	   short scale3offset));
/***
** Function: EmitVerticalStem
**
** Description:
**   This function generates the code that
**   will initiate the graphics state of the
**   TrueType interpreter for the grid fitting
**   of vertical stems.
***/
void	       EmitVerticalStems    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd));
/***
** Function: EmitHorizontalStem
**
** Description:
**   This function generates the code that
**   will initiate the graphics state of the
**   TrueType interpreter for the grid fitting
**   of vertical stems.
***/
void	       EmitHorizontalStems  _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd));
/***
** Function: EmitVStem
**
** Description:
**   This function generates the code that
**   will create and grid fit points in the
**   twilight zone, corresponding to a vstem.
***/
errcode	       EmitVStem	    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd,
					   INOUT   struct T1Metrics *t1m,
					   IN	   funit width,
					   IN      funit real_side1,
					   IN      funit real_side2,
					   IN      funit side1,
					   IN      funit side2,
					   IN      short rp,
					   IN      enum aligntype align,
					   IN      short ref));
/***
** Function: EmitHStem
**
** Description:
**   This function generates the code that
**   will create and grid fit points in the
**   twilight zone, corresponding to a hstem.
***/
errcode	       EmitHStem	    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd,
					   INOUT   struct T1Metrics *t1m,
					   IN	   funit width,
					   IN      funit side1,
					   IN      funit side2,
					   IN      short rp,
					   IN      enum aligntype align,
					   IN      short ref));
/***
** Function: FamilyCutIn
**
** Description:
**   This function generates a branch in the
**   pre-program. 
***/
USHORT	       FamilyCutIn	    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   USHORT tp,
					   IN	   short cis));
/***
** Function: SetProjection
**
** Description:
**   This function generates the TrueType code that
**   changes the projection vector in oblique typefaces.
***/
void	       SetProjection	    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd,
					   IN	   funit x,
					   IN	   funit y));
/***
** Function: AssembleArgs
**
** Description:
**   This function takes a sequence of arguments and
**   assembles them into a sequence of PUSHB1[], PUSHW1[],
**   NPUSHB[] and NPUSHW[] instructions.
***/
void           AssembleArgs         _ARGS((INOUT   short *args,
                                           IN      short pcd,
                                           OUT     UBYTE *is,
                                           INOUT   short *cnt));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontview\fvrc.h ===
#define IDS_FONTFACE    100

#define IDB_DONE        200
#define IDB_PRINT       201
#define IDB_PREV_FONT   202
#define IDB_NEXT_FONT   203

#define IDK_UP          300
#define IDK_DOWN        301
#define IDK_PGUP        302
#define IDK_PGDWN       303
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontview\fmttools.c ===
#include <windows.h>
#include <fontdefs.h>
#include <fvmsg.h>

TCHAR gpszUnknownError[MAX_PATH] = TEXT("Error");
TCHAR gszDots[] = TEXT("...");
/***************************************************************************\
*
*     FUNCTION: FmtMessageBox( HWND hwnd, DWORD dwTitleID, UINT fuStyle,
*                   BOOL fSound, DWORD dwTextID, ... );
*
*     PURPOSE:  Formats messages with FormatMessage and then displays them
*               in a message box
*
*
*
*
* History:
* 22-Apr-1993 JonPa         Created it.
\***************************************************************************/
int FmtMessageBox( HWND hwnd, DWORD dwTitleID, LPTSTR pszTitleStr,
    UINT fuStyle, BOOL fSound, DWORD dwTextID, ... ) {
    LPTSTR pszMsg;
    LPTSTR pszTitle;
    int idRet;

    va_list marker;

    va_start( marker, dwTextID );

    if(!FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK, hInst,
            dwTextID, 0, (LPTSTR)&pszMsg, 1, &marker))
        pszMsg = gpszUnknownError;

    va_end( marker );

    GetLastError();

    if (dwTitleID != FMB_TTL_ERROR ||
            !FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK |
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
                hInst, dwTitleID, 0, (LPTSTR)&pszTitle, 1, (va_list *)&pszTitleStr)) {
        pszTitle = NULL;
    }

    GetLastError();

    if (fSound) {
        MessageBeep( fuStyle & (MB_ICONASTERISK | MB_ICONEXCLAMATION |
                MB_ICONHAND | MB_ICONQUESTION | MB_OK) );
    }

    if (hwnd == NULL)
        hwnd = GetDesktopWindow();

    idRet = MessageBox(hwnd, pszMsg, pszTitle, fuStyle);

    if (pszTitle != NULL)
        FmtFree( pszTitle );

    if (pszMsg != gpszUnknownError)
        FmtFree( pszMsg );

    return idRet;
}

/***************************************************************************\
*
*     FUNCTION: FmtSprintf( DWORD id, ... );
*
*     PURPOSE:  sprintf but it gets the pattern string from the message rc.
*
* History:
* 03-May-1993 JonPa         Created it.
\***************************************************************************/
LPTSTR FmtSprintf( DWORD id, ... ) {
    LPTSTR pszMsg;
    va_list marker;

    va_start( marker, id );

    if(!FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK, hInst,
            id, 0, (LPTSTR)&pszMsg, 1, &marker)) {
        GetLastError();
        pszMsg = gszDots;
    }
    va_end( marker );

    return pszMsg;
}

/***************************************************************************\
*
*     FUNCTION: PVOID AllocMem( DWORD cb );
*
*     PURPOSE:  allocates memory, checking for errors
*
*   Do not call this function until after LoadFontFile() has been called
*   since this function will try and remove the font.
*
* History:
*   22-Apr-1993 JonPa   Wrote it.
\***************************************************************************/
PVOID AllocMem( DWORD cb ) {
    PVOID pv = (PVOID)LocalAlloc(LPTR, cb);

    if (pv == NULL) {
        FmtMessageBox( ghwndFrame, FMB_TTL_ERROR, NULL, MB_OK | MB_ICONSTOP,
                TRUE, MSG_OUTOFMEM );
        RemoveFontResource( gszFontPath );
        ExitProcess(2);
    }

    return pv;
}

#ifdef FV_DEBUG
/***************************************************************************\
*
*     FUNCTION: FmtSprintf( DWORD id, ... );
*
*     PURPOSE:  sprintf but it gets the pattern string from the message rc.
*
* History:
* 03-May-1993 JonPa         Created it.
\***************************************************************************/
void Dprintf( LPTSTR pszFmt, ... ) {
    TCHAR szBuffer[256];
    va_list marker;

    va_start( marker, pszFmt );

    StringCchVPrintf( szBuffer, ARRAYSIZE(szBuffer), pszFmt, marker );
    OutputDebugString(szBuffer);

    va_end( marker );

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontview\fontdefs.h ===
typedef enum {
    FFT_TRUETYPE,       // FFT_TRUETYPE *Must* be the first one in the list
    FFT_BITMAP,
    FFT_PRINTER,
    FFT_ATM,
    FFT_OTF,
    FFT_BAD_FILE        // FFT_BAD_FILE *Must* be the last one in the list
} FFTYPE;

typedef enum {
    DTP_UNUSED = 0,
    DTP_NORMALDRAW,
    DTP_SHRINKDRAW,
    DTP_SHRINKTEXT,
    DTP_WRAPDRAW,
    DTP_TEXTOUT
} DTYPE;

typedef struct {
    DTYPE   dtyp;
    int     cptsSize;
    BOOL    fLineUnder;
    LPTSTR  pszText;
    int     cchText;
} TXTLN;

typedef TXTLN *PTXTLN;

#define CLINES_DISPLAY  20      // max of 20 lines in sample text

typedef struct {
    LOGFONT     lfTestFont;
    TXTLN    atlDsp[CLINES_DISPLAY];
} DISPTEXT;

typedef DISPTEXT *PDISPTEXT;

typedef struct {
    int x;
    int y;
    int cx;
    int cy;
    int id;
    HWND hwnd;
    int idText;
    LPTSTR pszText;
} BTNREC;

#define FMB_TTL_ERROR   ((DWORD)-1)
#define C_PTS_PER_INCH  72          // 72 points per inch
#define CB_ONE_K        1024

#define CY_MIN_WINSIZE  300
#define CX_MIN_WINSIZE  300


#define CPTS_COPYRIGHT_SIZE 10
#define CPTS_INFO_SIZE      12
#define CPTS_SAMPLE_ALPHA   16
#define CPTS_TITLE_SIZE     30


#define ROUND_UP_DIV( x, y )    ( ((x) + (y-1)) / y )
#define OTM_STRING( lpOTM, field )   ((LPTSTR)((LPBYTE)lpOTM + (DWORD)(lpOTM->field)))
#define ABS( i )    ((i) < 0 ? -(i) : (i))
#define ARRAYSIZE(a)    (sizeof(a) / sizeof(a[0]))
#define INDEX_TYPEFACENAME   1


typedef BOOL (* PFNFONTPARSER)( HANDLE hfile, PTXTLN ptxlFontInfo );


extern HANDLE hInst;
extern HWND ghwndFrame;
extern HWND ghwndView;
extern TCHAR gszFontPath[2*MAX_PATH];


extern TCHAR gszDots[];
#define FmtFree( s )    if(NULL == (s) || (s) == gszDots) { /* do nothing */ } else LocalFree( s )

/***************************************************************************\
*
* Prototypes
*
\***************************************************************************/
//
// In FONTVIEW.C
//
BOOL InitApplication(HANDLE hInstance, HICON hIcon);
BOOL InitInstance( HANDLE  hInstance, int nCmdShow, LPTSTR  pszTitle);
void InitGlobals();
LRESULT FAR PASCAL ViewWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT FAR PASCAL FrameWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL DoCommand( HWND hWnd, WPARAM wParam, LPARAM lParam );
BOOL ParseCommand( LPTSTR lpstrCmdLine, LPTSTR pszFontPath, size_t cchFontPath, BOOL *pfPrint );
FFTYPE LoadFontFile( LPTSTR pszFontPath, PDISPTEXT pdtSmpl, HICON *phIcon );
WORD GetGDILangID();
//
//  In FMTTOOLS.C
//
int FmtMessageBox( HWND hwnd, DWORD dwTitleID, LPTSTR pszTitleStr,
    UINT fuStyle, BOOL fSound, DWORD dwTextID, ... );
LPTSTR FmtSprintf( DWORD id, ... );
PVOID AllocMem( DWORD cb );
#define FreeMem( pb )   LocalFree(pb)


#ifdef FV_DEBUG
extern void Dprintf( LPTSTR pszFmt, ... );
#   define  DBTX( s )   TEXT( s ) TEXT("\n")
#   define  DPRINT(p)   Dprintf p
#else
#   define  DPRINT(p)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontview\ttdefs.h ===
typedef struct {
    BYTE    bMSB;
    BYTE    bLSB;
} MWORD;

typedef MWORD *LPMWORD;

#define MWORD2INT(mw)  ((mw).bMSB * 256 + (mw).bLSB)

typedef struct {
    MWORD   mwidPlatform;
    MWORD   mwidEncoding;
    MWORD   mwidLang;
    MWORD   mwidName;
    MWORD   mwcbString;
    MWORD   mwoffString;
} TTNAMEREC;

typedef TTNAMEREC *PTTNAMEREC;

typedef struct {
    MWORD   mwiFmtSel;
    MWORD   mwcNameRec;
    MWORD   mwoffStrings;
    TTNAMEREC   anrNames[1];
} TTNAMETBL;

typedef TTNAMETBL *PTTNAMETBL;


#define     TT_TBL_NAME         0x656D616E      // 'name'

#define     TTID_PLATFORM_MAC   1
#define     TTID_PLATFORM_MS    3

#define     TTID_MS_UNDEFINED   0
#define     TTID_MS_UNICODE     1
#define     TTID_MS_SHIFTJIS    2
#define     TTID_MS_GB          3
#define     TTID_MS_BIG5        4
#define     TTID_MS_WANSUNG     5

#define     TTID_NAME_COPYRIGHT  0
#define     TTID_NAME_FONTFAMILY 1
#define     TTID_NAME_FONTSUBFAM 2
#define     TTID_NAME_UNIQFONTID 3
#define     TTID_NAME_FULLFONTNM 4
#define     TTID_NAME_VERSIONSTR 5
#define     TTID_NAME_PSFONTNAME 6
#define     TTID_NAME_TRADEMARK  7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\fontview\fontview.c ===
/****************************************************************************\
*
*     PROGRAM: fontview.c
*
*     PURPOSE: Loads and displays fonts from the given filename
*
*     COMMENTS:
*
*     HISTORY:
*       02-Oct-1995 JonPa       Created It
*
\****************************************************************************/

#include <windows.h>                /* required for all Windows applications */
#include <commdlg.h>
#include <shellapi.h>
#include <shlwapi.h> 
#include <strsafe.h>
#include <wingdip.h>                /* prototype for GetFontRsourceInfo     */
#include <objbase.h>
#include "fontdefs.h"               /* specific to this program             */
#include "fvmsg.h"
#include "fvrc.h"
#include "ttdefs.h"



HANDLE hInst;                       /* current instance                     */
HWND ghwndView = NULL;
HWND ghwndFrame = NULL;
BOOL    gfPrint = FALSE;
TCHAR   gszFontPath[2 * MAX_PATH];
LPTSTR  gpszSampleText;
LPTSTR  gpszSampleAlph[3];
FFTYPE  gfftFontType;
LOGFONT glfFont;
DISPTEXT gdtDisplay;
HBRUSH  ghbr3DFace;
HBRUSH  ghbr3DShadow;


int gyScroll = 0;              // Vertical scroll offset in pels
int gcyLine = 0;

int gcxMinWinSize = CX_MIN_WINSIZE;
int gcyMinWinSize = CY_MIN_WINSIZE;

BOOL gbIsDBCS = FALSE;    // Indicates whether system default langID is DBCS
int  gNumOfFonts = 0;     // number of fonts in the file.
int  gIndexOfFonts = 0;   // current index of the fonts.
LPLOGFONT glpLogFonts;    // get global data by GetFontResourceInfo()

int apts[] = { 12, 18, 24, 36, 48, 60, 72 };
#define C_POINTS_LIST  (sizeof(apts) / sizeof(apts[0]))

#define CPTS_BTN_AREA   28
int gcyBtnArea = CPTS_BTN_AREA;
BTNREC gabtCmdBtns[] = {
    {   6,  6, 36, 16, IDB_DONE,      NULL, MSG_DONE,      NULL },
    {  -6,  6, 36, 16, IDB_PRINT,     NULL, MSG_PRINT,     NULL },
    {  68,  6, 20, 16, IDB_PREV_FONT, NULL, MSG_PREV_FONT, NULL }, // DBCS only.
    { -68,  6, 20, 16, IDB_NEXT_FONT, NULL, MSG_NEXT_FONT, NULL }  // DBCS only.
};

#define C_DBCSBUTTONS  2  // Prev & Next font are DBCS specific.
//
// This may be recalculated in WinMain to adjust for a DBCS locale.
//
int C_BUTTONS = (sizeof(gabtCmdBtns) / sizeof(gabtCmdBtns[0]));


#if DBG
void DDPrint( LPTSTR sz, DWORD dw ) {
    TCHAR szBuff[246];
    StringCchPrintf( szBuff, ARRAYSIZE(szBuff), sz, dw );

    OutputDebugString( szBuff );
}

#   define DDPRINT( s, d )  DDPrint( s, d )
#else
#   define DDPRINT( s, d )
#endif


#define IsZeroFSig( fs )  ( (fs)->fsUsb[0] == 0 && (fs)->fsUsb[1] == 0 && (fs)->fsUsb[2] == 0 && \
                                (fs)->fsUsb[3] == 0 && (fs)->fsCsb[0] == 0 && (fs)->fsCsb[1] == 0 )

BOOL NativeCodePageSupported(LPLOGFONT lplf) {
    BOOL fRet = FALSE;
    HDC hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        HFONT hf, hfOld;
        FONTSIGNATURE fsig;
        CHARSETINFO  csi;

        DDPRINT( TEXT("System default code page: %d\n"), GetACP() );

        TranslateCharsetInfo( (LPDWORD)IntToPtr(GetACP()), &csi, TCI_SRCCODEPAGE );

        hf = CreateFontIndirect( lplf );

        hfOld = SelectObject( hdc, hf );

        GetTextCharsetInfo( hdc, &fsig, 0 );

        SelectObject( hdc, hfOld );

        DeleteObject(hf);

        if (IsZeroFSig( &fsig ) ) {
            // Font does not support GetTextCharsetInfo(), just go off of the lfCharSet value

            DDPRINT( TEXT("Font does not support GetTextCharsetInfo... \nTesting %d (font cs) against"), lplf->lfCharSet );
            DDPRINT( TEXT("%d (sys charset)\n"), csi.ciCharset );

            fRet = (lplf->lfCharSet == csi.ciCharset);

        } else {
            DDPRINT( TEXT("GTCI() worked...\nChecking font charset bits %08x"),  fsig.fsCsb[0] );
            DDPRINT( TEXT(" %08x against"),  fsig.fsCsb[1] );
            DDPRINT( TEXT(" system charset bits %08x "), csi.fs.fsCsb[0] );
            DDPRINT( TEXT("  %08x\n"), csi.fs.fsCsb[1] );

            fRet = ((csi.fs.fsCsb[0] &  fsig.fsCsb[0]) || (csi.fs.fsCsb[1] &  fsig.fsCsb[1]));
        }

        DeleteDC(hdc);
    }

    return fRet;
}

/****************************************************************************
*
*     FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)
*
*     PURPOSE: calls initialization function, processes message loop
*
*
\****************************************************************************/
int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpstrCmdLine,
    int nCmdShow
    )
{
    int i, iCpts;
    MSG msg;
    HACCEL  hAccel;
    HICON hIcon;
    USHORT wLanguageId;
    BOOL bCoInitialized = FALSE;

    //
    // Initialize the gbIsDBCS flag based on the current default language.
    //
    wLanguageId = LANGIDFROMLCID(GetThreadLocale());

    gbIsDBCS    = (LANG_JAPANESE == PRIMARYLANGID(wLanguageId)) ||
                  (LANG_KOREAN   == PRIMARYLANGID(wLanguageId)) ||
                  (LANG_CHINESE  == PRIMARYLANGID(wLanguageId));

    //
    // In a DBCS locale, exclude the Prev-Next font buttons.
    //
    if (!gbIsDBCS)
         C_BUTTONS -= C_DBCSBUTTONS;
    //
    // Need to initialize COM so that SHGetFileInfo will load the IExtractIcon handler
    // implemented in fontext.dll.
    //
    if (SUCCEEDED(CoInitialize(NULL)))
        bCoInitialized = TRUE;

    /*
     * Parse the Command Line
     *
     *  Use GetCommandLine() here (instead of lpstrCmdLine) so the
     *  command string will be in Unicode on NT
     */
    FillMemory( &gdtDisplay, sizeof(gdtDisplay), 0 );

    if (!ParseCommand( GetCommandLine(), gszFontPath, ARRAYSIZE(gszFontPath), &gfPrint ) ||
        (gfftFontType = LoadFontFile( gszFontPath, &gdtDisplay, &hIcon )) == FFT_BAD_FILE) {

        // Bad font file, inform user, and exit

        FmtMessageBox( NULL, MSG_APP_TITLE, NULL, MB_OK | MB_ICONSTOP,
                FALSE, MSG_BADFILENAME, gszFontPath );

        if (bCoInitialized)
            CoUninitialize();

        ExitProcess(1);
    }

    /*
     * Now finish initializing the display structure
     */
    gpszSampleAlph[0] = FmtSprintf(MSG_SAMPLEALPH_0);
    gpszSampleAlph[1] = FmtSprintf(MSG_SAMPLEALPH_1);
    gpszSampleAlph[2] = FmtSprintf(MSG_SAMPLEALPH_2);

    // find next line on display
    for( i = 0; i < CLINES_DISPLAY; i++ ) {
        if (gdtDisplay.atlDsp[i].dtyp == DTP_UNUSED)
            break;
    }

    // fill in sample alphabet
    gdtDisplay.atlDsp[i].pszText = gpszSampleAlph[0];
    gdtDisplay.atlDsp[i].cchText = lstrlen(gpszSampleAlph[0]);
    gdtDisplay.atlDsp[i].dtyp    = DTP_SHRINKTEXT;
    gdtDisplay.atlDsp[i].cptsSize = CPTS_SAMPLE_ALPHA;

    i++;
    gdtDisplay.atlDsp[i] = gdtDisplay.atlDsp[i-1];
    gdtDisplay.atlDsp[i].pszText = gpszSampleAlph[1];
    gdtDisplay.atlDsp[i].cchText = lstrlen(gpszSampleAlph[1]);

    i++;
    gdtDisplay.atlDsp[i] = gdtDisplay.atlDsp[i-1];
    gdtDisplay.atlDsp[i].pszText = gpszSampleAlph[2];
    gdtDisplay.atlDsp[i].cchText = lstrlen(gpszSampleAlph[2]);
    gdtDisplay.atlDsp[i].fLineUnder = TRUE;


    // now fill in sample Sentences
    iCpts = 0;

    if (gbIsDBCS)
    {
        //
        // Determine with string to use: the default or the language
        // specific.
        //
        switch (gdtDisplay.lfTestFont.lfCharSet) {
            case SYMBOL_CHARSET:
            case ANSI_CHARSET:
            case DEFAULT_CHARSET:
            case OEM_CHARSET:
                gpszSampleText = FmtSprintf(MSG_SAMPLETEXT);
                break;

            default:
                gpszSampleText = FmtSprintf(MSG_SAMPLETEXT_ALT);
                break;
        }
    }
    else
    {
        if(NativeCodePageSupported(&(gdtDisplay.lfTestFont))) {
            //
            // Native code page is supported, select that codepage
            // and print the localized string.
            //
            CHARSETINFO csi;

            TranslateCharsetInfo( (LPDWORD)IntToPtr(GetACP()), &csi, TCI_SRCCODEPAGE );

            gdtDisplay.lfTestFont.lfCharSet = (BYTE)csi.ciCharset;

            gpszSampleText =  FmtSprintf(MSG_SAMPLETEXT);

        } else {
            //
            // Font does not support the local code page.  Print
            // a random string up instead using the font's default charset.
            //
            gpszSampleText =  FmtSprintf(MSG_ALTSAMPLE);
        }
    }

    for( i += 1; i < CLINES_DISPLAY && iCpts < C_POINTS_LIST; i++ ) {
        if (gdtDisplay.atlDsp[i].dtyp == DTP_UNUSED) {
            gdtDisplay.atlDsp[i].pszText = gpszSampleText;
            gdtDisplay.atlDsp[i].cchText = lstrlen(gpszSampleText);
            gdtDisplay.atlDsp[i].dtyp    = DTP_TEXTOUT;
            gdtDisplay.atlDsp[i].cptsSize = apts[iCpts++];
        }
    }

    /*
     * Init the title font LOGFONT, and other variables
     */
    InitGlobals();

    if (!hPrevInstance) {
        if (!InitApplication(hInstance, hIcon)) {
            msg.wParam = FALSE;
            goto ExitProg;
        }
    }

    /* Perform initializations that apply to a specific instance */

    if (!InitInstance(hInstance, nCmdShow, gdtDisplay.atlDsp[0].pszText)) {
        msg.wParam = FALSE;
        goto ExitProg;
    }

    /* Acquire and dispatch messages until a WM_QUIT message is received. */
    hAccel = LoadAccelerators(hInstance, TEXT("fviewAccel"));

    while (GetMessage(&msg, NULL, 0L, 0L)) {
        if (!TranslateAccelerator(ghwndView, hAccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

ExitProg:
    for ( i = 0; i < C_BUTTONS; i++ )
        FmtFree( gabtCmdBtns[i].pszText );

    if (gbIsDBCS && glpLogFonts)
        FreeMem(glpLogFonts);

    RemoveFontResource( gszFontPath );

    if (bCoInitialized)
        CoUninitialize();

    return (int)(msg.wParam);
}


/****************************************************************************
*
*     FUNCTION: InitApplication(HANDLE)
*
*     PURPOSE: Initializes window data and registers window class
*
*     COMMENTS:
*
*         This function is called at initialization time only if no other
*         instances of the application are running.  This function performs
*         initialization tasks that can be done once for any number of running
*         instances.
*
*         In this case, we initialize a window class by filling out a data
*         structure of type WNDCLASS and calling the Windows RegisterClass()
*         function.  Since all instances of this application use the same window
*         class, we only need to do this when the first instance is initialized.
*
*
\****************************************************************************/

BOOL InitApplication(HANDLE hInstance, HICON hIcon)       /* current instance             */
{
    WNDCLASS  wc;
    BOOL fRet = FALSE;

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = FrameWndProc;

    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;           /* Application that owns the class.   */
    wc.hIcon = hIcon ? hIcon : LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = ghbr3DFace;
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("FontViewWClass");

    /* Register the window class and return success/failure code. */

    if (RegisterClass(&wc)) {
        /* Fill in window class structure with parameters that describe the       */
        /* main window.                                                           */

        wc.style = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc = ViewWndProc;

        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = hInstance;           /* Application that owns the class.   */
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject(WHITE_BRUSH);
        wc.lpszMenuName =  NULL;
        wc.lpszClassName = TEXT("FontDisplayClass");

        fRet = RegisterClass(&wc);
    }

    return fRet;
}


/****************************************************************************
*
*     FUNCTION:  InitInstance(HANDLE, int)
*
*     PURPOSE:  Saves instance handle and creates main window
*
*     COMMENTS:
*
*         This function is called at initialization time for every instance of
*         this application.  This function performs initialization tasks that
*         cannot be shared by multiple instances.
*
*         In this case, we save the instance handle in a static variable and
*         create and display the main program window.
*
\****************************************************************************/

BOOL InitInstance( HANDLE  hInstance, int nCmdShow, LPTSTR  pszTitle)
{

    /* Save the instance handle in static variable, which will be used in  */
    /* many subsequence calls from this application to Windows.            */

    hInst = hInstance;

    /* Create a main window for this application instance.  */

    ghwndFrame = CreateWindow( TEXT("FontViewWClass"), pszTitle,
            WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CLIPCHILDREN,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL );

    /* If window could not be created, return "failure" */

    if (!ghwndFrame)
        return (FALSE);

    return (TRUE);               /* Returns the value from PostQuitMessage */

}

/****************************************************************************
*
*     FUNCTION: InitLogFont
*
\****************************************************************************/
void InitGlobals( void ) {
    TCHAR szMsShellDlg2[LF_FACESIZE];
    INT cyDPI,i, cxFiller, cxMaxTxt, cxTxt, cxMax;
    HDC hdc;
    HFONT hfOld;
    RECT rc;

    FillMemory( &glfFont, sizeof(glfFont), 0 );

    glfFont.lfCharSet         = DEFAULT_CHARSET;
    glfFont.lfOutPrecision    = OUT_DEFAULT_PRECIS;
    glfFont.lfClipPrecision   = CLIP_DEFAULT_PRECIS;
    glfFont.lfQuality         = DEFAULT_QUALITY;
    glfFont.lfPitchAndFamily  = DEFAULT_PITCH | FF_DONTCARE;

    if (LoadString(hInst, IDS_FONTFACE, szMsShellDlg2, ARRAYSIZE(szMsShellDlg2)))
        StringCchCopy(glfFont.lfFaceName, ARRAYSIZE(glfFont.lfFaceName), szMsShellDlg2);
    else
        StringCchCopy(glfFont.lfFaceName, ARRAYSIZE(glfFont.lfFaceName), TEXT("MS Shell Dlg2"));

    hdc = CreateCompatibleDC(NULL);
    cyDPI = GetDeviceCaps(hdc, LOGPIXELSY );

    hfOld = SelectObject( hdc, GetStockObject(DEFAULT_GUI_FONT));

    // Find out size of padding around text
    SetRect(&rc, 0, 0, 0, 0 );
    DrawText(hdc, TEXT("####"), -1, &rc, DT_CALCRECT | DT_CENTER);
    cxFiller = rc.right - rc.left;

    gcyBtnArea = MulDiv( gcyBtnArea, cyDPI, C_PTS_PER_INCH );
    cxMax = cxMaxTxt = 0;
    for( i = 0; i < C_BUTTONS; i++ ) {
        gabtCmdBtns[i].x  = MulDiv( gabtCmdBtns[i].x,  cyDPI, C_PTS_PER_INCH );
        gabtCmdBtns[i].y  = MulDiv( gabtCmdBtns[i].y,  cyDPI, C_PTS_PER_INCH );
        gabtCmdBtns[i].cx = MulDiv( gabtCmdBtns[i].cx, cyDPI, C_PTS_PER_INCH );
        gabtCmdBtns[i].cy = MulDiv( gabtCmdBtns[i].cy, cyDPI, C_PTS_PER_INCH );

        if (gabtCmdBtns[i].cx > cxMax)
            cxMax = gabtCmdBtns[i].cx;

        gabtCmdBtns[i].pszText = FmtSprintf( gabtCmdBtns[i].idText );
        SetRect(&rc, 0, 0, 0, 0 );
        DrawText(hdc, gabtCmdBtns[i].pszText, -1, &rc, DT_CALCRECT | DT_CENTER);

        cxTxt = rc.right - rc.left + cxFiller;

        if (cxMaxTxt < cxTxt) {
            cxMaxTxt = cxTxt;
        }
    }

    //
    // Make sure buttons are big enough for text! (So localizer's won't have
    // to change code.
    //
    if (cxMax < cxMaxTxt) {
        for( i = 0; i < C_BUTTONS; i++ ) {
            gabtCmdBtns[i].cx = gabtCmdBtns[i].cx * cxMaxTxt / cxMax;
        }
    }

    //
    // Make sure buttons don't overlap
    //
    i = C_BUTTONS - 1;
    cxMax = gabtCmdBtns[0].x + gabtCmdBtns[0].cx + gabtCmdBtns[0].x + gabtCmdBtns[i].cx + (-gabtCmdBtns[i].x) +
            (2 * GetSystemMetrics(SM_CXSIZEFRAME));

    if (cxMax > gcxMinWinSize)
        gcxMinWinSize = cxMax;

    SelectObject(hdc, hfOld);
    DeleteDC(hdc);

    gcyLine = MulDiv( CPTS_INFO_SIZE, cyDPI, C_PTS_PER_INCH );

    ghbr3DFace   = GetSysColorBrush(COLOR_3DFACE);
    ghbr3DShadow = GetSysColorBrush(COLOR_3DSHADOW);
}

/****************************************************************************
*
*     FUNCTION: SkipWhiteSpace
*
\****************************************************************************/
LPTSTR SkipWhiteSpace( LPTSTR psz ) {

    while( *psz == TEXT(' ') || *psz == TEXT('\t') || *psz == TEXT('\n') ) {
        psz = CharNext( psz );
    }

    return psz;
}


/****************************************************************************
*
*     FUNCTION: CloneString
*
\****************************************************************************/
LPTSTR CloneString(LPTSTR psz) {
    int cch;
    LPTSTR pszRet;
    cch = (lstrlen( psz ) + 1);

    pszRet = AllocMem(cch * sizeof(TCHAR));
    StringCchCopy( pszRet, cch, psz );
    return pszRet;
}


/****************************************************************************
*
*     FUNCTION: GetFileSizeFromName(pszFontPath)
*
\****************************************************************************/
DWORD GetFileSizeFromName( LPCTSTR pszPath ) {
    HANDLE hfile;
    DWORD cb = 0;

    hfile = CreateFile( pszPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL );
    if (hfile != INVALID_HANDLE_VALUE) {
        cb = GetFileSize( hfile, NULL );
        CloseHandle(hfile);
    }

    return cb;
}




HRESULT FindPfb (LPCTSTR pszPFM, LPTSTR pszPFB, size_t cchPFB);
HRESULT BuildType1FontSpec(LPCTSTR pszPFM, LPTSTR pszSpec, size_t cchSpec);


/****************************************************************************
*
*     FUNCTION: ParseCommand
*
\****************************************************************************/


BOOL ParseCommand( LPTSTR lpstrCmdLine, LPTSTR pszFontPath, size_t cchFontPath, BOOL *pfPrint ) {
    LPTSTR psz;
    BOOL fInQuote = FALSE;
    TCHAR szPfmPfb[(2 * MAX_PATH) + 1];  // +1 for possible '|' delimiter.

    //
    // Skip program name
    //
    for( psz = SkipWhiteSpace(lpstrCmdLine);
            *psz != TEXT('\0') && (fInQuote || *psz != TEXT(' ')); psz = CharNext(psz) ) {

        if (*psz == TEXT('\"')) {
            fInQuote = !fInQuote;
        }
    }

    if (*psz == TEXT('\0')) {
        *pszFontPath = TEXT('\0');
        return FALSE;
    }

    psz = SkipWhiteSpace(psz);

    //
    // Check for "/p"
    //
    if (psz[0] == TEXT('/') && (psz[1] == TEXT('p') || psz[1] == TEXT('P'))) {
        *pfPrint = TRUE;
        psz += 2;           // DBCS OK since we already verified that the
                            // chars were '/' and 'p', they can't be lead bytes
    } else
        *pfPrint = FALSE;

    psz = SkipWhiteSpace(psz);

    //
    // If the string ends in ".PFM"...
    //
    if (0 == lstrcmpi(PathFindExtension(psz), TEXT(".PFM")))
    {
        if (SUCCEEDED(BuildType1FontSpec(psz, szPfmPfb, ARRAYSIZE(szPfmPfb))))
        {
            psz = szPfmPfb;
        }
    }
    StringCchCopy( pszFontPath, cchFontPath, psz );
    return *psz != TEXT('\0');
}


/****************************************************************************
*
*     FUNCTION: GetGDILangID
*
*   REVIEW!  I believe this is how GDI determines the LangID, verify on
*   international builds.
*
\****************************************************************************/
WORD   GetGDILangID() {
    return (WORD)GetSystemDefaultLangID();
}



void ConvertTTStrToWinZStr( LPWSTR pwsz, LPVOID pvTTS, int cbMW ) {
    int i, cch;
    LPMWORD lpmw = pvTTS;

    cch = cbMW / sizeof(MWORD);

    for( i = 0; i < cch; i++ ) {
        *pwsz++ = MWORD2INT(*lpmw);
        lpmw++;
    }

    *pwsz = L'\0';
}


VOID ConvertDBCSTTStrToWinZStr( LPTSTR pwsz, LPCSTR pvTTS, ULONG cbMW ) {
    BYTE Name[256];
    WORD wordChar;
    BYTE *ansiName = Name;
    WORD *srcString = (WORD *)pvTTS;
    int length = 0;
    int cb = cbMW;

    for(;cb;cb-=2) {
        wordChar = *srcString;
        if(wordChar & 0x00FF) {
            *ansiName++ = (CHAR)((wordChar & 0x00FF));
            *ansiName++ = (CHAR)((wordChar & 0xFF00) >> 8);
            length += 2;
        } else {
            *ansiName++ = (CHAR)((wordChar & 0xFF00) >> 8);
            length++;
        }
        srcString++;
    }

    ansiName[length] = '\0';

    MultiByteToWideChar(CP_ACP,0,Name,length,pwsz,cbMW);
}

/****************************************************************************
*
*     FUNCTION: FindNameString
*
*   helper function for GetAlignedTTName
*
\****************************************************************************/
LPTSTR FindNameString(PBYTE pbTTData, int cNameRec, int idName, WORD wLangID)
{
    PTTNAMETBL ptnt;
    PTTNAMEREC ptnr;
    LPTSTR     psz;
    int        i;

    ptnt = (PTTNAMETBL)pbTTData;

    for( i = 0; i < cNameRec; i++ ) {
        LPVOID pvTTStr;

        ptnr = &(ptnt->anrNames[i]);
        if (MWORD2INT(ptnr->mwidPlatform) != TTID_PLATFORM_MS ||
            MWORD2INT(ptnr->mwidName) != idName               ||
            MWORD2INT(ptnr->mwidLang) != wLangID) {
            continue;
        }

        pvTTStr = (LPVOID)(pbTTData + MWORD2INT(ptnt->mwoffStrings)
                                    + MWORD2INT(ptnr->mwoffString));

        psz = AllocMem((MWORD2INT(ptnr->mwcbString) + sizeof(TEXT('\0'))) * 2);

        if ((MWORD2INT(ptnr->mwidEncoding) == TTID_MS_GB) ||
            (MWORD2INT(ptnr->mwidEncoding) == TTID_MS_WANSUNG) ||
            (MWORD2INT(ptnr->mwidEncoding) == TTID_MS_BIG5)) {
            ConvertDBCSTTStrToWinZStr( psz, pvTTStr, MWORD2INT(ptnr->mwcbString) );
        } else {
            ConvertTTStrToWinZStr( psz, pvTTStr, MWORD2INT(ptnr->mwcbString) );
        }

        return psz;
    }

    return NULL;
}



/****************************************************************************
*
*     FUNCTION: GetAlignedTTName
*
*   NOTE: This function returns an allocated string that must be freed
*   after use.
*
*   This function allocs a buffer to recopy the string into incase we are
*   running on a RISC machine with NT.  Since the string will be UNICODE
*   (ie. each char is a WORD), those strings must be aligned on WORD
*   boundaries.  Unfortunatly, TrueType files do not neccesarily align
*   the embedded unicode strings.  Furthur more, on NT we can not simply
*   return a pointer to the data stored in the input buffer, since the
*   'Unicode' strings stored in the TTF file are stored in Motorola (big
*   endian) format, and we need the unicode chars in Intel (little endian)
*   format. Last but not least, we need the returned string to be null terminated
*   so we need to either alloc the buffer for that case anyway.
*
\****************************************************************************/
LPTSTR GetAlignedTTName( PBYTE pbTTData, int idName ) {
    PTTNAMEREC ptnr;
    PTTNAMETBL ptnt;
    int cNameRec,i;
    LPTSTR psz;
    BOOL bFirstRetry;
    WORD wLangID = GetGDILangID();
    LCID lcid = GetThreadLocale();

    ptnt = (PTTNAMETBL)pbTTData;
    cNameRec = MWORD2INT(ptnt->mwcNameRec);

    //
    // Look For Microsoft Platform ID's
    //
    if (gbIsDBCS)
    {
        if ((psz = FindNameString(pbTTData, cNameRec, idName, wLangID)) != NULL) {
            return psz;
        }
        //
        // If we didn't find it, try English if we haven't already.
        //
        if ( wLangID != 0x0409 ) {
            if ((psz = FindNameString(pbTTData, cNameRec, idName, 0x0409)) != NULL) {
                return psz;
            }
        }
    }
    else
    {
        bFirstRetry = TRUE;

retry_lang:

        for( i = 0; i < cNameRec; i++ ) {
            LPVOID pvTTStr;
            ptnr = &(ptnt->anrNames[i]);
            if (MWORD2INT(ptnr->mwidPlatform) != TTID_PLATFORM_MS ||
                MWORD2INT(ptnr->mwidName) != idName               ||
                MWORD2INT(ptnr->mwidLang) != wLangID) {
                continue;
            }

            pvTTStr = (LPVOID)(pbTTData + MWORD2INT(ptnt->mwoffStrings) + MWORD2INT(ptnr->mwoffString));
            psz = AllocMem(MWORD2INT(ptnr->mwcbString) + sizeof(TEXT('\0')));

            ConvertTTStrToWinZStr( psz, pvTTStr, MWORD2INT(ptnr->mwcbString) );
            return psz;
        }

        //
        // Give 0x409 a try if there is no specified MAC language.
        //
        if (bFirstRetry && wLangID != 0x0409) {
            bFirstRetry = FALSE;
            wLangID     = 0x0409;
            goto retry_lang;
        }
    }

    //
    // Didn't find MS Platform, try Macintosh
    //
    for( i = 0; i < cNameRec; i++ ) {
        int cch;
        LPSTR pszMacStr;

        ptnr = &(ptnt->anrNames[i]);
        if (MWORD2INT(ptnr->mwidPlatform) != TTID_PLATFORM_MAC ||
            MWORD2INT(ptnr->mwidName) != idName                ||
            MWORD2INT(ptnr->mwidLang) != wLangID) {
            continue;
        }

        pszMacStr = (LPVOID)(pbTTData + MWORD2INT(ptnt->mwoffStrings) + MWORD2INT(ptnr->mwoffString));

        cch = MultiByteToWideChar(CP_MACCP, 0, pszMacStr, MWORD2INT(ptnr->mwcbString), NULL, 0);
        if (cch == 0)
            continue;

        cch += 1; // for null
        psz = AllocMem(cch * sizeof(TCHAR));
        if (psz == NULL)
            continue;

        cch = MultiByteToWideChar(CP_MACCP, 0, pszMacStr, MWORD2INT(ptnr->mwcbString), psz, cch);
        if (cch == 0) {
            FreeMem(psz);
            continue;
        }

        return psz;
    }

    //
    // Didn't find MS Platform nor Macintosh
    // 1. Try change Thread Locale to data Locale
    // 2. MultiByteToWideChar with Thread code page CP_THREAD_ACP
    //
    for( i = 0; i < cNameRec; i++ ) {
        int cch;
        LPSTR pszStr;

        ptnr = &(ptnt->anrNames[i]);
        if (MWORD2INT(ptnr->mwidName) != idName ||
            MWORD2INT(ptnr->mwidLang) == 0) {
            continue;
        }

        if (LANGIDFROMLCID(lcid) != MWORD2INT(ptnr->mwidLang)) {
            lcid = MAKELCID(MWORD2INT(ptnr->mwidLang), SORT_DEFAULT);
            if (!SetThreadLocale(lcid)) {
                break;
            }
        }

        pszStr = (LPVOID)(pbTTData + MWORD2INT(ptnt->mwoffStrings) + MWORD2INT(ptnr->mwoffString));

        cch = MultiByteToWideChar(CP_THREAD_ACP, 0, pszStr, MWORD2INT(ptnr->mwcbString), NULL, 0);
        if (cch == 0)
            continue;

        cch += 1; // for null
        psz = AllocMem(cch * sizeof(TCHAR));
        if (psz == NULL)
            continue;

        cch = MultiByteToWideChar(CP_THREAD_ACP, 0, pszStr, MWORD2INT(ptnr->mwcbString), psz, cch);
        if (cch == 0) {
            FreeMem(psz);
            continue;
        }

        return psz;
    }

    return NULL;
}


/****************************************************************************
*
*     FUNCTION: LoadFontFile
*
\****************************************************************************/
FFTYPE LoadFontFile( LPTSTR pszFontPath, PDISPTEXT pdtSmpl, HICON *phIcon ) {
    int cFonts;
    FFTYPE fft = FFT_BAD_FILE;
    SHFILEINFO sfi;
    LPTSTR pszAdobe;
    TCHAR szFPBuf[MAX_PATH];

    cFonts = AddFontResource( pszFontPath );

    if (gbIsDBCS)
    {
        //
        // save cFonts value to global variable.
        //
        gNumOfFonts = cFonts;
    }

    if (cFonts != 0) {
        LPLOGFONT lplf;
        DWORD cb;
        DWORD cbCFF = 0, cbMMSD = 0, cbDSIG = 0; // for OpenType
        BYTE *pbDSIG = NULL; // for OpenType
        BOOL  fIsTT;

        cb = sizeof(LOGFONT) * cFonts;

        if (gbIsDBCS)
        {
            //
            // save lplf to global variable.
            //
            glpLogFonts = lplf = AllocMem(cb);
        }
        else
        {
            lplf = AllocMem(cb);
        }

        // ?? Should this be GetFontResourceInfo (doesn't matter; but why force W)
        if (GetFontResourceInfoW( (LPTSTR)pszFontPath, &cb, lplf, GFRI_LOGFONTS )) {
            HDC hdc;
            HFONT hf, hfOld;
            LOGFONT lf;
            int nIndex;
            int cLoopReps = 1;

            BOOL fIsTrueTypeFont;
            DWORD dwSize = sizeof(BOOL);

            if(GetFontResourceInfoW((LPTSTR) pszFontPath, &dwSize, &fIsTrueTypeFont, GFRI_ISTRUETYPE)) {
                // If there is a raster & true type font on the system at the same time, 
                // and the height/width requested is supported by both fonts, the 
                // the font methods (which take the LOGFONT struct, *lplf) will select
                // the raster font (by design).  THis causes a problem when the user wants
                // to view the true type font; so, an extra check needs to be done to see if
                // the font requested is a true type, and if so then specify in the LOGFONT
                // struct to only show the true type font
                if(fIsTrueTypeFont) {
                    lplf->lfOutPrecision = OUT_TT_ONLY_PRECIS;
                }
            }

            //
            // This DBCS-aware code was originally placed within #ifdef DBCS
            // preprocessor statements.  For single-binary, these had to be
            // replaced with runtime checks.  The original code did some funky
            // things to execute a loop in DBCS builds but only a single iteration
            // in non-DBCS builds.  To do this, the "for" statement and it's
            // closing brace were placed in #ifdef DBCS like this:
            //
            // #ifdef DBCS
            //     for (nIndex = 0; nIndex < cFonts; nIndex++)
            //     {
            //          //
            //          // Other DBCS-specific code.
            //          //
            // #endif
            //          //
            //          // Code for both DBCS and non-DBCS systems
            //          // executes only once.
            //          //
            // #ifdef DBCS
            //     }
            // #endif
            //
            // While effective in a multi-binary configuration, this doesn't
            // translate well to a single-binary build.
            // To preserve the original logic without having to do major
            // reconstruction, I've replaced the loop sentinel variable with
            // "cLoopReps".  In non-DBCS locales, it is set to 1.  In DBCS
            // locales, it is assigned the value in "cFonts".
            //
            // [BrianAu 5/4/97]
            //

          if (gbIsDBCS)
              cLoopReps = cFonts;

          for (nIndex = 0; nIndex < cLoopReps; nIndex++) {
            if (gbIsDBCS)
            {
                lf = *(lplf + nIndex);

                //
                // Skip vertical font
                //
                if (lf.lfFaceName[0] == TEXT('@')) {
                    gNumOfFonts = (cFonts == 2) ? gNumOfFonts-1 : gNumOfFonts;
                    continue;
                }

                hf = CreateFontIndirect(&lf);
            }
            else
            {
                hf = CreateFontIndirect(lplf);
            }

            hdc = CreateCompatibleDC(NULL);

            if (hdc)
            {
                hfOld = SelectObject(hdc, hf);

                // Only otf fonts will have CFF table, tag is ' FFC'.

                cbCFF = GetFontData(hdc,' FFC', 0, NULL, 0);
                cbDSIG = GetFontData(hdc,'GISD', 0, NULL, 0);

                if (cbDSIG != GDI_ERROR)
                {
                    if ((pbDSIG = AllocMem(cbDSIG)) == NULL)
                    {
                        // Can't determine what's in the DSIG table.
                        // Continue as though the DSIG table does not exist.
                        cbDSIG = 0;
                    }
                    else
                    {
                        if (GetFontData (hdc, 'GISD', 0, pbDSIG, cbDSIG) == GDI_ERROR)
                        {
                            // Continue as though the DSIG table does not exist
                            cbDSIG = 0;
                        }
                        FreeMem(pbDSIG);
                    }
                }


                if (cbCFF == GDI_ERROR)
                    cbCFF = 0;

                if (cbDSIG == GDI_ERROR)
                    cbDSIG = 0;

                if (cbCFF || cbDSIG)
                {
                    fft = FFT_OTF;
                    if (cbCFF)
                    {
                        cbMMSD = GetFontData(hdc,'DSMM', 0, NULL, 0);
                        if (cbMMSD == GDI_ERROR)
                            cbMMSD = 0;
                    }
                }

                cb = GetFontData(hdc, TT_TBL_NAME, 0, NULL, 0);

                if (fft != FFT_OTF)
                {
                    fIsTT = (cb != 0 && cb != GDI_ERROR);
                    fft = fIsTT ? FFT_TRUETYPE : FFT_BITMAP;
                }

                if ((fft == FFT_TRUETYPE) || (fft == FFT_OTF)) {
                    int i;
                    LPBYTE lpTTData;
                    LPTSTR pszTmp;

                    lpTTData = AllocMem(cb);
                    GetFontData(hdc, TT_TBL_NAME, 0, lpTTData, cb);

                    i = 0;

                    //
                    // Title String
                    //
                    pdtSmpl->atlDsp[i].dtyp = DTP_SHRINKDRAW;
                    pdtSmpl->atlDsp[i].cptsSize = CPTS_TITLE_SIZE;
                    pdtSmpl->atlDsp[i].fLineUnder = TRUE;

                    pszTmp = GetAlignedTTName( lpTTData, TTID_NAME_FULLFONTNM );
                    if (pszTmp != NULL) {
                        if (gbIsDBCS)
                        {
                            //
                            // TTC Support.
                            //
                            if (nIndex == 0) {
                                pdtSmpl->atlDsp[i].pszText = CloneString(pszTmp);
                            } else {
                                pdtSmpl->atlDsp[i].pszText = FmtSprintf(MSG_TTC_CONCAT,
                                                                        pdtSmpl->atlDsp[i].pszText,
                                                                        pszTmp);
                            }

                            if (nIndex + 1 == cFonts) {
                                //
                                // If last this is last font, append "(True Type)"
                                //
                            pdtSmpl->atlDsp[i].pszText = FmtSprintf((fft == FFT_TRUETYPE) ? MSG_PTRUETYPEP : MSG_POPENTYPEP,
                                                                    pdtSmpl->atlDsp[i].pszText);
                            }
                            pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);
                            FreeMem(pszTmp);
                        }
                        else
                        {
                            pdtSmpl->atlDsp[i].pszText = FmtSprintf((fft == FFT_TRUETYPE) ? MSG_PTRUETYPEP : MSG_POPENTYPEP, pszTmp);
                            pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);
                            FreeMem(pszTmp);
                        }
                    } else {
                        if (gbIsDBCS)
                        {
                            //
                            // TTC support
                            //
                            if (nIndex == 0) {
                                pdtSmpl->atlDsp[i].pszText = CloneString(lf.lfFaceName);
                            } else {
                                pdtSmpl->atlDsp[i].pszText = FmtSprintf(MSG_TTC_CONCAT,
                                                                        pdtSmpl->atlDsp[i].pszText,
                                                                        lf.lfFaceName);
                            }

                            if (nIndex + 1 == cFonts) {
                                //
                                // If last this is last font, append "(True Type)"
                                //
                                pdtSmpl->atlDsp[i].pszText = FmtSprintf((fft == FFT_TRUETYPE) ? MSG_PTRUETYPEP : MSG_POPENTYPEP,
                                                                        pdtSmpl->atlDsp[i].pszText);
                            }
                            pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);
                        }
                        else
                        {
                            pdtSmpl->atlDsp[i].pszText = CloneString(lplf->lfFaceName);
                            pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[0].pszText);
                        }
                    }
                    i++;
                    pdtSmpl->atlDsp[i] = pdtSmpl->atlDsp[i-1];

                    //// insert an extra line to provide better description of the font

                    if (fft == FFT_OTF)
                    {
                        LPTSTR pszTemp = NULL;
                        WCHAR awcTmp[256];
                        awcTmp[0] = 0; // zero init

                        pdtSmpl->atlDsp[i].dtyp = DTP_NORMALDRAW;
                        pdtSmpl->atlDsp[i].cptsSize = CPTS_INFO_SIZE;
                        pdtSmpl->atlDsp[i].fLineUnder = FALSE;

                        pdtSmpl->atlDsp[i].pszText = FmtSprintf(
                                          MSG_POTF,
                                          awcTmp);

                        if (cbDSIG)
                        {
                            pszTemp = pdtSmpl->atlDsp[i].pszText;

                            pdtSmpl->atlDsp[i].pszText = FmtSprintf(
                                          MSG_PDSIG,
                                          pdtSmpl->atlDsp[i].pszText);

                            FmtFree(pszTemp);
                        }

                        pszTemp = pdtSmpl->atlDsp[i].pszText;
                        pdtSmpl->atlDsp[i].pszText = FmtSprintf(
                                      cbCFF ? MSG_PPSGLYPHS : MSG_PTTGLYPHS,
                                      pdtSmpl->atlDsp[i].pszText);
                        FmtFree(pszTemp);

                        pszTemp = pdtSmpl->atlDsp[i].pszText;
                        pdtSmpl->atlDsp[i].pszText = FmtSprintf(
                                      MSG_PINSTRUCTIONS,
                                      pdtSmpl->atlDsp[i].pszText);
                        FmtFree(pszTemp);

                        if (cbCFF)
                        {
                            pszTemp = pdtSmpl->atlDsp[i].pszText;
                            pdtSmpl->atlDsp[i].pszText = FmtSprintf(
                                          cbMMSD ? MSG_PMULTIPLEMASTER : MSG_PSINGLEMASTER,
                                          pdtSmpl->atlDsp[i].pszText);
                            FmtFree(pszTemp);
                        }

                        pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);

                        i++;
                        pdtSmpl->atlDsp[i] = pdtSmpl->atlDsp[i-1];
                    }

                    //
                    // Typeface Name:
                    //
                    pdtSmpl->atlDsp[i].cptsSize = CPTS_INFO_SIZE;
                    pdtSmpl->atlDsp[i].dtyp = DTP_NORMALDRAW;
                    pdtSmpl->atlDsp[i].fLineUnder = FALSE;
                    pszTmp = GetAlignedTTName( lpTTData, TTID_NAME_FONTFAMILY );
                    if (pszTmp != NULL) {
                        pdtSmpl->atlDsp[i].pszText = FmtSprintf(MSG_TYPEFACENAME, pszTmp);
                        pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);
                        FreeMem(pszTmp);
                        i++;
                        pdtSmpl->atlDsp[i] = pdtSmpl->atlDsp[i-1];
                    }

                    //
                    // File size:
                    //
                    pdtSmpl->atlDsp[i].pszText = FmtSprintf(MSG_FILESIZE,
                            ROUND_UP_DIV(GetFileSizeFromName(pszFontPath), CB_ONE_K));
                    pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);

                    //
                    // Version:
                    //
                    pszTmp = GetAlignedTTName( lpTTData, TTID_NAME_VERSIONSTR );
                    if (pszTmp != NULL) {
                        i++;
                        pdtSmpl->atlDsp[i] = pdtSmpl->atlDsp[i-1];
                        pdtSmpl->atlDsp[i].pszText = FmtSprintf(MSG_VERSION, pszTmp);
                        pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);
                        FreeMem( pszTmp );
                    }

                    //
                    // Copyright string
                    //
                    pszTmp = GetAlignedTTName( lpTTData, TTID_NAME_COPYRIGHT );
                    if (pszTmp != NULL) {
                        i++;
                        pdtSmpl->atlDsp[i] = pdtSmpl->atlDsp[i-1];
                        pdtSmpl->atlDsp[i].cptsSize = CPTS_COPYRIGHT_SIZE;
                        pdtSmpl->atlDsp[i].dtyp = DTP_WRAPDRAW;
                        pdtSmpl->atlDsp[i].pszText = FmtSprintf(MSG_COPYRIGHT, pszTmp);
                        pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);
                        FreeMem( pszTmp );
                    }

                    pdtSmpl->atlDsp[i].fLineUnder = TRUE;

                    if (gbIsDBCS)
                    {
                        //
                        // TTC Support.
                        //
                        FreeMem(lpTTData);
                    }
                } else {

                    // Title String (Non TrueType case)

                    pdtSmpl->atlDsp[0].dtyp = DTP_SHRINKDRAW;
                    pdtSmpl->atlDsp[0].cptsSize = CPTS_TITLE_SIZE;
                    pdtSmpl->atlDsp[0].fLineUnder = TRUE;
                    pdtSmpl->atlDsp[0].pszText = CloneString(lplf->lfFaceName);
                    pdtSmpl->atlDsp[0].cchText = lstrlen(pdtSmpl->atlDsp[0].pszText);

                    // Use Default quality, so we can see GDI scaling of Bitmap Fonts
                    lplf->lfQuality = DEFAULT_QUALITY;
                    lplf->lfWidth = 0;
                }

                // If LPK is loaded then GetFontResourceInfo(GFRI_LOGFONTS) may return ANSI_CHARSET for some DBCS fonts.
                // Get the native char set.
                if (gbIsDBCS & NativeCodePageSupported(lplf)) {
                        //
                        // Native code page is supported, set that codepage
                        //
                        CHARSETINFO csi;
        
                        TranslateCharsetInfo( (LPDWORD)IntToPtr(GetACP()), &csi, TCI_SRCCODEPAGE );
        
                        lplf->lfCharSet = (BYTE)csi.ciCharset;
                }

                SelectObject(hdc, hfOld);
                DeleteDC(hdc);
            } // if (hdc)
            
            if (hf)
            {
                DeleteObject(hf);
            }

          } // for
            pdtSmpl->lfTestFont = *lplf;
        }

        if (!gbIsDBCS)
        {
            FreeMem(lplf);
        }
    }


    //
    // MAJOR HACK!
    //
    // Since ATM-Type1 fonts are split between two files, (*.PFM and *.PFB) we have done a hack
    // earlier in the code to find the missing filename and concatinate them together in
    // the form "FOO.PFM|FOO.PFB", so we can then call AddFontResource() with only one string.
    //
    // Since SHGetFileInfo does not understand this hacked filename format, we must split ATM-Type1
    // names appart here and then reconcat them after we call the shell api.
    //
    pszAdobe = pszFontPath;

    while( *pszAdobe && *pszAdobe != TEXT('|') )
        pszAdobe = CharNext(pszAdobe);

    if ( *pszAdobe ) {

        *pszAdobe = TEXT('\0');

        pdtSmpl->atlDsp[0].pszText = FmtSprintf(MSG_PTYPE1, pdtSmpl->atlDsp[0].pszText);
        pdtSmpl->atlDsp[0].cchText = lstrlen(pdtSmpl->atlDsp[0].pszText);

    } else {
        pszAdobe = NULL;
    }
    // end of HACK


    //
    // Get the associated icon for this font file type
    //
    if ( fft != FFT_BAD_FILE && SHGetFileInfo( pszFontPath, 0, &sfi, sizeof(sfi), SHGFI_ICON )) {
        *phIcon = sfi.hIcon;
    } else
        *phIcon = NULL;

    //
    // HACK - restore the '|' we nuked above
    //
    if ( pszAdobe != NULL ) {
        *pszAdobe = TEXT('|');
    }
    // end of HACK

    return fft;
}


/****************************************************************************
*
*     FUNCTION: DrawFontSample
*
* Parameters:
*
*   lprcPage    Size of the page in pels.  A page is either a printed
*               sheet (on a printer) or the Window.
*
*   cyOffset    Offset into the virtual sample text.  Used to "scroll" the
*               window up and down.  Positive number means start further
*               down in the virtual sample text as the top line in the
*               lprcPage.
*
*   lprcPaint   Rectangle to draw.  It is in the same coord space as
*               lprcPage.  Used to optimize window repaints, and to
*               support banding to printers.
*
*
\****************************************************************************/
int DrawFontSample( HDC hdc, LPRECT lprcPage, int cyOffset, LPRECT lprcPaint, BOOL fReallyDraw ) {
    int cyDPI;
    HFONT hfOld, hfText, hfDesk;
    LOGFONT lfTmp;
    int yBaseline = -cyOffset;
    int taOld,i;
    TCHAR szNumber[10];
    int cyShkTxt = -1, cptsShkTxt = -1;
    SIZE sz;
    int cxPage;

    DPRINT((DBTX("PAINTING")));

    cyDPI = GetDeviceCaps(hdc, LOGPIXELSY );
    taOld = SetTextAlign(hdc, TA_BASELINE);

    glfFont.lfHeight = MulDiv( -CPTS_COPYRIGHT_SIZE, cyDPI, C_PTS_PER_INCH );
    hfDesk = CreateFontIndirect(&glfFont);

    // Get hfOld for later
    hfOld = SelectObject(hdc, hfDesk);


    if (gbIsDBCS)
    {
        //
        // if two or more fonts exist, set correct typeface name
        //
        if (gNumOfFonts > 1 && gfftFontType == FFT_TRUETYPE) {
            gdtDisplay.atlDsp[INDEX_TYPEFACENAME].pszText =
                                FmtSprintf(MSG_TYPEFACENAME, gdtDisplay.lfTestFont.lfFaceName);
            gdtDisplay.atlDsp[INDEX_TYPEFACENAME].cchText =
                                lstrlen(gdtDisplay.atlDsp[INDEX_TYPEFACENAME].pszText);
        }
    }

    //
    // Find the longest shrinktext line so we can make sure they will fit
    // on the screen
    //
    cxPage = lprcPage->right - lprcPage->left;
    for( i = 0; i < CLINES_DISPLAY && gdtDisplay.atlDsp[i].dtyp != DTP_UNUSED; i++ ) {
        PTXTLN ptlCurrent = &(gdtDisplay.atlDsp[i]);

        if (ptlCurrent->dtyp == DTP_SHRINKTEXT) {
            lfTmp = gdtDisplay.lfTestFont;

            if (cptsShkTxt == -1)
                cptsShkTxt = ptlCurrent->cptsSize;

            cyShkTxt = MulDiv( -cptsShkTxt, cyDPI, C_PTS_PER_INCH );

            lfTmp.lfHeight = cyShkTxt;

            hfText = CreateFontIndirect( &lfTmp );
            SelectObject(hdc, hfText);

            GetTextExtentPoint32(hdc, ptlCurrent->pszText, ptlCurrent->cchText, &sz );

            SelectObject(hdc, hfOld);
            DeleteObject(hfText);

            // Make sure shrink lines are not too long
            if (sz.cx > cxPage) {

                DPRINT((DBTX(">>>Old lfH:%d sz.cx:%d cxPage:%d"), lfTmp.lfHeight, sz.cx, cxPage));

                cptsShkTxt = cptsShkTxt * cxPage / sz.cx;
                cyShkTxt = MulDiv( -cptsShkTxt, cyDPI, C_PTS_PER_INCH );

                DPRINT((DBTX(">>>New lfH:%d"),lfTmp.lfHeight));
            }
        }
    }


    //
    // Paint the screen/page
    //
    for( i = 0; i < CLINES_DISPLAY && gdtDisplay.atlDsp[i].dtyp != DTP_UNUSED; i++ ) {
        TEXTMETRIC tm;
        PTXTLN ptlCurrent = &(gdtDisplay.atlDsp[i]);

        // Create and select the font for this line

        if (ptlCurrent->dtyp == DTP_TEXTOUT || ptlCurrent->dtyp == DTP_SHRINKTEXT )
            lfTmp = gdtDisplay.lfTestFont;
        else
            lfTmp = glfFont;

        if (ptlCurrent->dtyp == DTP_SHRINKTEXT) {
            DPRINT((DBTX("PAINT:Creating ShrinkText Font:%s height:%d"), lfTmp.lfFaceName, lfTmp.lfHeight ));
            lfTmp.lfHeight = cyShkTxt;
        }
        else
            lfTmp.lfHeight = MulDiv( -ptlCurrent->cptsSize, cyDPI, C_PTS_PER_INCH );

        hfText = CreateFontIndirect( &lfTmp );
        SelectObject(hdc, hfText);


        // Get size characteristics for this line in the selected font
        if (ptlCurrent->dtyp == DTP_SHRINKDRAW) {

            GetTextExtentPoint32(hdc, ptlCurrent->pszText, ptlCurrent->cchText, &sz );

            // Make sure shrink lines are not too long
            if (sz.cx > cxPage) {

                SelectObject(hdc, hfOld);
                DeleteObject(hfText);

                DPRINT((DBTX("===Old lfH:%d sz.cx:%d cxPage:%d"), lfTmp.lfHeight, sz.cx, cxPage));

                lfTmp.lfHeight = MulDiv( -ptlCurrent->cptsSize * cxPage / sz.cx, cyDPI, C_PTS_PER_INCH );

                DPRINT((DBTX("===New lfH:%d"),lfTmp.lfHeight));

                hfText = CreateFontIndirect( &lfTmp );
                SelectObject(hdc, hfText);
            }
        }



        GetTextMetrics(hdc, &tm);

        yBaseline += (tm.tmAscent + tm.tmExternalLeading);
        DPRINT((DBTX("tmH:%d tmA:%d tmD:%d tmIL:%d tmEL:%d"), tm.tmHeight, tm.tmAscent, tm.tmDescent, tm.tmInternalLeading, tm.tmExternalLeading));

        // Draw the text
        switch(ptlCurrent->dtyp) {
            case DTP_NORMALDRAW:
            case DTP_SHRINKDRAW:
            case DTP_SHRINKTEXT:
                if (fReallyDraw) {
                    ExtTextOut(hdc, lprcPage->left, yBaseline, ETO_CLIPPED, lprcPaint,
                            ptlCurrent->pszText, ptlCurrent->cchText, NULL);
                }

                //
                // Bob says "This looks nice!" (Adding a little extra white space before the underline)
                //
                if (ptlCurrent->fLineUnder)
                    yBaseline += tm.tmDescent;

                break;

            case DTP_WRAPDRAW: {
                RECT rc;
                int cy;

                yBaseline += tm.tmDescent;
                SetRect(&rc, lprcPage->left, yBaseline - tm.tmHeight, lprcPage->right, yBaseline );

                DPRINT((DBTX("**** Org RC:(%d, %d, %d, %d)  tmH:%d"), rc.left, rc.top, rc.right, rc.bottom, tm.tmHeight));
                cy = DrawText(hdc, ptlCurrent->pszText, ptlCurrent->cchText, &rc,
                        DT_NOPREFIX | DT_WORDBREAK | DT_CALCRECT);


                DPRINT((DBTX("**** Cmp RC:(%d, %d, %d, %d)  cy:%d"), rc.left, rc.top, rc.right, rc.bottom, cy));
                if( cy > tm.tmHeight )
                    yBaseline = rc.bottom = rc.top + cy;

                if (fReallyDraw) {
                    SetTextAlign(hdc, taOld);
                    DrawText(hdc, ptlCurrent->pszText, ptlCurrent->cchText, &rc, DT_NOPREFIX | DT_WORDBREAK);
                    SetTextAlign(hdc, TA_BASELINE);
                }
                break;
            }

            case DTP_TEXTOUT:
                if (fReallyDraw) {
                    SIZE szNum;
                    int cchNum;
                    SelectObject(hdc, hfDesk );
                    StringCchPrintf( szNumber, ARRAYSIZE(szNumber), TEXT("%d"), ptlCurrent->cptsSize );
                    cchNum = lstrlen(szNumber);
                    ExtTextOut(hdc, lprcPage->left, yBaseline, ETO_CLIPPED, lprcPaint, szNumber, cchNum, NULL);


                    GetTextExtentPoint32(hdc, szNumber, cchNum, &szNum);

                    SelectObject(hdc, hfText);
                    ExtTextOut(hdc, lprcPage->left + szNum.cx * 2, yBaseline, ETO_CLIPPED, lprcPaint,
                            ptlCurrent->pszText, ptlCurrent->cchText, NULL);
                }
                break;
        }

        yBaseline += tm.tmDescent;

        if (fReallyDraw && ptlCurrent->fLineUnder) {
            MoveToEx( hdc, lprcPage->left, yBaseline, NULL);
            LineTo( hdc, lprcPage->right, yBaseline );

            // Leave space for the line we just drew
            yBaseline += 1;
        }

        SelectObject( hdc, hfOld );
        DeleteObject( hfText );
    }

    SelectObject(hdc, hfOld);
    SetTextAlign(hdc, taOld);
    DeleteObject(hfDesk);

    return yBaseline;
}

/****************************************************************************
*
*     FUNCTION: PaintSampleWindow
*
\****************************************************************************/
void PaintSampleWindow( HWND hwnd, HDC hdc, PAINTSTRUCT *pps ) {
    RECT rcClient;

    GetClientRect(hwnd, &rcClient);

    DrawFontSample( hdc, &rcClient, gyScroll, &(pps->rcPaint), TRUE );

}


/****************************************************************************
*
*     FUNCTION: FrameWndProc(HWND, unsigned, WORD, LONG)
*
*     PURPOSE:  Processes messages
*
*     MESSAGES:
*
*         WM_COMMAND    - application menu (About dialog box)
*         WM_DESTROY    - destroy window
*
*     COMMENTS:
*
*         To process the IDM_ABOUT message, call MakeProcInstance() to get the
*         current instance address of the About() function.  Then call Dialog
*         box which will create the box according to the information in your
*         fontview.rc file and turn control over to the About() function.  When
*         it returns, free the intance address.
*
\****************************************************************************/

LRESULT APIENTRY FrameWndProc(
        HWND hwnd,                /* window handle                   */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* additional information          */
        LPARAM lParam)            /* additional information          */
{
    static SIZE szWindow = {0, 0};

    switch (message) {

        case WM_PAINT: {
            HDC hdc;
            RECT rc;
            PAINTSTRUCT ps;
            int x;

            hdc = BeginPaint(hwnd, &ps);

            // get the window rect
            GetClientRect(hwnd, &rc);

            // extend only down by gcyBtnArea
            rc.bottom = rc.top + gcyBtnArea;

            // Fill rect with button face color (handled by class background brush)
            // FillRect(hdc, &rc, ghbr3DFace);

            // Fill small rect at bottom with edge color
            rc.top = rc.bottom - 2;
            FillRect(hdc, &rc, ghbr3DShadow);

            ReleaseDC(hwnd, hdc);

            EndPaint(hwnd, &ps);
            break;
        }

        case WM_CREATE: {
            HDC hdc;
            RECT rc;
            int i;

            GetClientRect(hwnd, &rc);
            szWindow.cx = rc.right - rc.left;
            szWindow.cy = rc.bottom - rc.top;

            for( i = 0; i < C_BUTTONS; i++ ) {
                int x = gabtCmdBtns[i].x;
                HWND hwndBtn;

                if (gbIsDBCS)
                {
                    DWORD dwStyle = 0;

                    //
                    // If font is not TrueType font or not TTC font,
                    // AND button id is previous/next,
                    // then just continue.
                    //
                    if ((gfftFontType != FFT_TRUETYPE ||
                         gNumOfFonts <= 1) &&
                        (gabtCmdBtns[i].id == IDB_PREV_FONT ||
                         gabtCmdBtns[i].id == IDB_NEXT_FONT)) {
                            continue;
                    }
                    //
                    // Set x potision for each button.
                    //
                    switch (gabtCmdBtns[i].id) {
                        case IDB_PREV_FONT:
                            x = szWindow.cx / 2 - gabtCmdBtns[i].cx - 5;
                            dwStyle = WS_DISABLED;  // initially disabled.
                            break;
                        case IDB_NEXT_FONT:
                            x = szWindow.cx / 2 + 5;
                            break;
                        default:
                            if (x < 0)
                                x = szWindow.cx + x - gabtCmdBtns[i].cx;
                    }
                    gabtCmdBtns[i].hwnd = hwndBtn = CreateWindow( TEXT("button"),
                            gabtCmdBtns[i].pszText,
                            BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | dwStyle,
                            x, gabtCmdBtns[i].y,
                            gabtCmdBtns[i].cx, gabtCmdBtns[i].cy,
                            hwnd, (HMENU)IntToPtr(gabtCmdBtns[i].id),
                            hInst, NULL);
                }
                else
                {
                    if (x < 0)
                        x = szWindow.cx + x - gabtCmdBtns[i].cx;

                    gabtCmdBtns[i].hwnd = hwndBtn = CreateWindow( TEXT("button"),
                            gabtCmdBtns[i].pszText, BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE,
                            x, gabtCmdBtns[i].y,
                            gabtCmdBtns[i].cx, gabtCmdBtns[i].cy,
                            hwnd, (HMENU)IntToPtr(gabtCmdBtns[i].id),
                            hInst, NULL);

                }
                if (hwndBtn != NULL) {
                    SendMessage(hwndBtn,
                                WM_SETFONT,
                                (WPARAM)GetStockObject(DEFAULT_GUI_FONT),
                                MAKELPARAM(TRUE, 0));
                }
            }

            ghwndView = CreateWindow( TEXT("FontDisplayClass"), NULL, WS_CHILD | WS_VSCROLL | WS_VISIBLE,
                    0, gcyBtnArea, szWindow.cx, szWindow.cy - gcyBtnArea, hwnd, 0, hInst, NULL );

            break;
        }

        case WM_GETMINMAXINFO: {
            LPMINMAXINFO lpmmi = (LPMINMAXINFO) lParam;

            lpmmi->ptMinTrackSize.x = gcxMinWinSize;
            lpmmi->ptMinTrackSize.y = gcyMinWinSize;

            break;
        }

        case WM_SIZE: {
            int cxNew, cyNew;
            HDC hdc;
            RECT rc;
            SCROLLINFO sci;

            cxNew = LOWORD(lParam);
            cyNew = HIWORD(lParam);

            if (cyNew != szWindow.cy || cxNew != szWindow.cx) {
                int i;

                if (gbIsDBCS)
                {
                    for( i = 0; i < C_BUTTONS; i++ ) {
                        int x = gabtCmdBtns[i].x;

                        //
                        // If font is not TrueType font or not TTC font,
                        // AND button id is previous/next,
                        // then just continue.
                        //
                        if ((gfftFontType != FFT_TRUETYPE ||
                             gNumOfFonts <= 1) &&
                            (gabtCmdBtns[i].id == IDB_PREV_FONT ||
                             gabtCmdBtns[i].id == IDB_NEXT_FONT)) {
                                continue;
                        }
                        //
                        // Set x potision for each button.
                        //
                        switch (gabtCmdBtns[i].id) {
                            case IDB_PREV_FONT:
                                SetWindowPos(gabtCmdBtns[i].hwnd,
                                             NULL,
                                             cxNew / 2 - gabtCmdBtns[i].cx - 5,
                                             gabtCmdBtns[i].y,
                                             0,
                                             0,
                                             SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
                                break;
                            case IDB_NEXT_FONT:
                                SetWindowPos(gabtCmdBtns[i].hwnd,
                                             NULL,
                                             cxNew /2 + 5,
                                             gabtCmdBtns[i].y,
                                             0,
                                             0,
                                             SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
                                break;
                            default:
                                if (x < 0) {
                                    SetWindowPos(gabtCmdBtns[i].hwnd,
                                                 NULL,
                                                 cxNew + x - gabtCmdBtns[i].cx,
                                                 gabtCmdBtns[i].y,
                                                 0,
                                                 0,
                                                 SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
                                }
                        }
                    }
                }
                else // !DBCS
                {
                    for( i = 0; i < C_BUTTONS; i++ ) {
                        int x = gabtCmdBtns[i].x;

                        if (x < 0) {
                            SetWindowPos(gabtCmdBtns[i].hwnd, NULL, cxNew + x - gabtCmdBtns[i].cx, gabtCmdBtns[i].y, 0, 0,
                                    SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
                        }
                    }
                } // DBCS

                szWindow.cx = cxNew;
                szWindow.cy = cyNew;

                SetWindowPos(ghwndView, NULL, 0, gcyBtnArea, szWindow.cx, szWindow.cy - gcyBtnArea,
                        SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE );

            }
            break;
        }

        case WM_COMMAND:           /* message: command from application menu */
            if (LOWORD(wParam) != IDB_DONE)
                return SendMessage(ghwndView, message, wParam, lParam);

            PostMessage(ghwndFrame, WM_CLOSE, 0, 0);
            break;

        case WM_DESTROY: {
            int i;

            DestroyWindow(ghwndView);
            for( i = 0; i < C_BUTTONS; i++ ) {
                DestroyWindow(gabtCmdBtns[i].hwnd);
            }

            PostQuitMessage(0);
            break;
        }

        default:                          /* Passes it on if unproccessed    */
            return (DefWindowProc(hwnd, message, wParam, lParam));
    }
    return (0L);
}

/****************************************************************************
*
*     FUNCTION: ViewWndProc(HWND, unsigned, WORD, LONG)
*
*     PURPOSE:  Processes messages
*
*     MESSAGES:
*
*         WM_COMMAND    - application menu (About dialog box)
*         WM_DESTROY    - destroy window
*
*     COMMENTS:
*
*         To process the IDM_ABOUT message, call MakeProcInstance() to get the
*         current instance address of the About() function.  Then call Dialog
*         box which will create the box according to the information in your
*         fontview.rc file and turn control over to the About() function.  When
*         it returns, free the intance address.
*
\****************************************************************************/

LRESULT APIENTRY ViewWndProc(
        HWND hwnd,                /* window handle                   */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* additional information          */
        LPARAM lParam)            /* additional information          */
{
    static SIZE szWindow = {0, 0};
    static int  cyVirtPage = 0;

    switch (message) {

        case WM_CREATE: {
            HDC hdc;
            RECT rc;
            SCROLLINFO sci;
            int i;

            GetClientRect(hwnd, &rc);
            szWindow.cx = rc.right - rc.left;
            szWindow.cy = rc.bottom - rc.top;

            hdc = CreateCompatibleDC(NULL);
            cyVirtPage = DrawFontSample(hdc, &rc, 0, NULL, FALSE);
            DeleteDC(hdc);


            gyScroll = 0;

            sci.cbSize = sizeof(sci);
            sci.fMask = SIF_ALL | SIF_DISABLENOSCROLL;
            sci.nMin = 0;
            sci.nMax = cyVirtPage;
            sci.nPage = szWindow.cy;
            sci.nPos = gyScroll;

            SetScrollInfo(hwnd, SB_VERT, &sci, TRUE );

            if (gfPrint)
                PostMessage(hwnd, WM_COMMAND, IDB_PRINT, 0);
            break;
        }

        case WM_SIZE: {
            int cxNew, cyNew;
            HDC hdc;
            RECT rc;
            SCROLLINFO sci;

            cxNew = LOWORD(lParam);
            cyNew = HIWORD(lParam);

            if (cyNew != szWindow.cy || cxNew != szWindow.cx) {
                int i;

                szWindow.cx = cxNew;
                szWindow.cy = cyNew;

                hdc = CreateCompatibleDC(NULL);
                SetRect(&rc, 0, 0, szWindow.cx, szWindow.cy);
                cyVirtPage = DrawFontSample(hdc, &rc, 0, NULL, FALSE);
                DeleteDC(hdc);

                if (cyVirtPage <= cyNew) {
                    // Disable the scrollbar
                    gyScroll = 0;
                }

                if (cyVirtPage > szWindow.cy && gyScroll > cyVirtPage - szWindow.cy)
                    gyScroll = cyVirtPage - szWindow.cy;

                sci.cbSize = sizeof(sci);
                sci.fMask = SIF_ALL | SIF_DISABLENOSCROLL;
                sci.nMin = 0;
                sci.nMax = cyVirtPage;
                sci.nPage = cyNew;
                sci.nPos = gyScroll;

                SetScrollInfo(hwnd, SB_VERT, &sci, TRUE );
            }
            break;
        }

        case WM_VSCROLL: {
            int iCode = (int)LOWORD(wParam);
            int yPos = (int)HIWORD(wParam);
            int yNewScroll = gyScroll;

            switch( iCode ) {

            case SB_THUMBPOSITION:
            case SB_THUMBTRACK:
                if (yPos != yNewScroll)
                    yNewScroll = yPos;
                break;

            case SB_LINEUP:
                yNewScroll -= gcyLine;
                break;

            case SB_PAGEUP:
                yNewScroll -= szWindow.cy;
                break;

            case SB_LINEDOWN:
                yNewScroll += gcyLine;
                break;

            case SB_PAGEDOWN:
                yNewScroll += szWindow.cy;
                break;

            case SB_TOP:
                yNewScroll = 0;
                break;

            case SB_BOTTOM:
                yNewScroll = cyVirtPage;
                break;
            }

            if (yNewScroll < 0)
                yNewScroll = 0;

            if (yNewScroll > cyVirtPage - szWindow.cy)
                yNewScroll = cyVirtPage - szWindow.cy;

            if (yNewScroll < 0)
                yNewScroll = 0;

            if (gyScroll != yNewScroll) {
                SCROLLINFO sci;
                int dyScroll;

                dyScroll = gyScroll - yNewScroll;

                if (ABS(dyScroll) < szWindow.cy) {
                    ScrollWindowEx(hwnd, 0, dyScroll, NULL, NULL, NULL, NULL, SW_ERASE | SW_INVALIDATE);
                } else
                    InvalidateRect(hwnd, NULL, TRUE);

                gyScroll = yNewScroll;

                sci.cbSize = sizeof(sci);
                sci.fMask = SIF_ALL | SIF_DISABLENOSCROLL;
                sci.nMin = 0;
                sci.nMax = cyVirtPage;
                sci.nPage = szWindow.cy;
                sci.nPos = gyScroll;

                SetScrollInfo(hwnd, SB_VERT, &sci, TRUE );
            }

            break;
        }


        case WM_COMMAND:           /* message: command from application menu */
            if( !DoCommand( hwnd, wParam, lParam ) )
                return (DefWindowProc(hwnd, message, wParam, lParam));
            break;

        case WM_PAINT: {
            HDC hdc;
            PAINTSTRUCT ps;

            hdc = BeginPaint( hwnd, &ps );
            PaintSampleWindow( hwnd, hdc, &ps );
            EndPaint( hwnd, &ps );
            break;
        }

        default:                          /* Passes it on if unproccessed    */
            return (DefWindowProc(hwnd, message, wParam, lParam));
    }
    return (0L);
}

/*********************************************\
*
* PRINT DLGS
*
*
\*********************************************/
HDC PromptForPrinter(HWND hwnd, HINSTANCE hInst, int *pcCopies ) {
    PRINTDLG pd;

    FillMemory(&pd, sizeof(pd), 0);

    pd.lStructSize = sizeof(pd);
    pd.hwndOwner = hwnd;
    pd.Flags = PD_RETURNDC | PD_NOSELECTION;
    pd.nCopies = 1;
    pd.hInstance = hInst;

    if (PrintDlg(&pd)) {
        *pcCopies = pd.nCopies;
        return pd.hDC;
    } else
        return NULL;
}

/****************************************************************************\
*
*     FUNCTION: PrintSampleWindow(hwnd)
*
*       Prompts for a printer and then draws the sample text to the printer
*
\****************************************************************************/
void PrintSampleWindow(HWND hwnd) {
    HDC hdc;
    DOCINFO di;
    int cxDPI, cyDPI, iPage, cCopies;
    RECT rcPage;
    HCURSOR hcur;

    hdc = PromptForPrinter(hwnd, hInst, &cCopies);
    if (hdc == NULL)
        return;

    hcur = SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));

    cyDPI = GetDeviceCaps(hdc, LOGPIXELSY );
    cxDPI = GetDeviceCaps(hdc, LOGPIXELSX );

    /*
     * Set a one inch margine around the page
     */
    SetRect(&rcPage, 0, 0, GetDeviceCaps(hdc, HORZRES), GetDeviceCaps(hdc, VERTRES));

    rcPage.left    += cxDPI;
    rcPage.right   -= cxDPI;


    di.cbSize = sizeof(di);
    di.lpszDocName = gdtDisplay.atlDsp[0].pszText;
    di.lpszOutput = NULL;
    di.lpszDatatype = NULL;
    di.fwType = 0;

    StartDoc(hdc, &di);

    for( iPage = 0; iPage < cCopies; iPage++ ) {
        StartPage(hdc);

        DrawFontSample( hdc, &rcPage, -cyDPI, &rcPage, TRUE );

        EndPage(hdc);
    }

    EndDoc(hdc);

    DeleteDC(hdc);

    SetCursor(hcur);
}


/****************************************************************************\
*
*     FUNCTION: EnableCommandButtons(id, bEnable)
*
*       Enable/disable command button.
*
\****************************************************************************/
BOOL EnableCommandButton(int id, BOOL bEnable)
{
    int  i;
    HWND hwnd = NULL;

    for( i = 0; i < C_BUTTONS; i++ ) {
        if (gabtCmdBtns[i].id == id) {
            hwnd = gabtCmdBtns[i].hwnd;
            break;
        }
    }
    return (hwnd == NULL) ? FALSE: EnableWindow(hwnd, bEnable);
}


/****************************************************************************\
*
*     FUNCTION: ViewNextFont(iInc)
*
*       Show the previous/next font.
*
\****************************************************************************/
void ViewNextFont(int iInc)
{
    int index = gIndexOfFonts + iInc;

    while (1) {
        if ( index < 0 || index >= gNumOfFonts ) {
            //
            // if out of range, then return.
            //
            MessageBeep(MB_OK);
            return;
        }
        else if ((*(glpLogFonts + index)).lfFaceName[0] == TEXT('@')) {
            //
            // if the font is vertical font, skip this font and
            // try next/previous font.
            //
            index += iInc;
        }
        else {
            break;
        }
    }

    //
    // Enable/Disable Prev/Next buttons.
    //
    if (index == 0) {
        // first font
        EnableCommandButton(IDB_PREV_FONT, FALSE);
        EnableCommandButton(IDB_NEXT_FONT, TRUE);
    }
    else if (index == gNumOfFonts - 1) {
        // last font
        EnableCommandButton(IDB_PREV_FONT, TRUE);
        EnableCommandButton(IDB_NEXT_FONT, FALSE);
    }
    else {
        // other
        EnableCommandButton(IDB_PREV_FONT, TRUE);
        EnableCommandButton(IDB_NEXT_FONT, TRUE);
    }

    //
    // Show the new font.
    //
    gIndexOfFonts = index;
    gdtDisplay.lfTestFont = *(glpLogFonts + index);
    InvalidateRect(ghwndView, NULL, TRUE);
}


/****************************************************************************\
*
*     FUNCTION: DoCommand(HWND, unsigned, WORD, LONG)
*
*     PURPOSE:  Processes messages for "About" dialog box
*
*     MESSAGES:
*
*         WM_INITDIALOG - initialize dialog box
*         WM_COMMAND    - Input received
*
*     COMMENTS:
*
*         No initialization is needed for this particular dialog box, but TRUE
*         must be returned to Windows.
*
*         Wait for user to click on "Ok" button, then close the dialog box.
*
\****************************************************************************/
BOOL DoCommand( HWND hWnd, WPARAM wParam, LPARAM lParam )
{

    switch(LOWORD(wParam)){
        case IDB_PRINT: {
            PrintSampleWindow(hWnd);
            break;
        }

        case IDB_DONE: {
            PostMessage(ghwndFrame, WM_CLOSE, 0, 0);
            break;
        }

        case IDK_UP: {
            SendMessage(hWnd, WM_VSCROLL, SB_LINEUP, (LPARAM)NULL );
            break;
        }

        case IDK_DOWN: {
            SendMessage(hWnd, WM_VSCROLL, SB_LINEDOWN, (LPARAM)NULL );
            break;
        }

        case IDK_PGUP: {
            SendMessage(hWnd, WM_VSCROLL, SB_PAGEUP, (LPARAM)NULL );
            break;
        }

        case IDK_PGDWN: {
            SendMessage(hWnd, WM_VSCROLL, SB_PAGEDOWN, (LPARAM)NULL );
            break;
        }

        case IDB_PREV_FONT: {
            ViewNextFont(-1);
            break;
        }

        case IDB_NEXT_FONT: {
            ViewNextFont(1);
            break;
        }

        default: {
            return FALSE;
        }
    }

    return TRUE;
}



BOOL bFileExists(TCHAR*pszFile)
{
    HANDLE  hf;

    if ((hf = CreateFile(pszFile,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL)) != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hf);
        return TRUE;
    }

    return FALSE;
}


/******************************Public*Routine******************************\
*
* FindPfb, given pfm file, see if pfb file exists in the same dir or in the
* parent directory of the pfm file
*
* Given:  c:\foo\bar\font.pfm
* Check:  c:\foo\bar\font.pfb
*         c:\foo\font.pfb
*
* Given:  font.pfm
* Check:  font.pfb
*         ..\font.pfb
*
* History:
*  14-Jun-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
*  28-Feb-2002 -by- Brian Aust [BrianAu]
* Replaced all of Bodin's character manipulations with calls to 
* shlwapi path functions and strsafe helpers.
*
* Returns:
*     S_OK    - PFB file found.  Full path to PFB written to pszPFB buffer.
*     S_FALSE - PFB file not found.
*     Other   - Error HRESULT.
*
\**************************************************************************/

HRESULT FindPfb (LPCTSTR pszPFM, LPTSTR pszPFB, size_t cchPFB)
{
    TCHAR szPath[MAX_PATH];  // Working 'scratch' buffer.
    HRESULT hr;
    
    if (0 != lstrcmpi(PathFindExtension(pszPFM), TEXT(".PFM")))
    {
        //
        // Caller didn't provide a PFM file path.
        //
        return E_INVALIDARG;
    }

    //
    // Copy input path to our scratch buffer so we can modify it.
    //
    hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pszPFM);
    if (SUCCEEDED(hr))
    {
        //
        // Does a PFB file exist in the same directory as the PFM file?
        //
        PathRenameExtension(szPath, TEXT(".PFB"));
        if (bFileExists(szPath))
        {
            hr = S_OK;  // Found a match!
        }
        else
        {
            LPCTSTR pszFileName = PathFindFileName(pszPFM);
            //
            // PFB doesn't exist in same directory.  
            // Try the parent directory.
            // Remove the file name so we have only a directory path.
            //
            if (!PathRemoveFileSpec(szPath))
            {
                //
                // This shouldn't happen.  We've already tested earlier
                // for content in the path string.  
                //
                hr = E_FAIL;
            }
            else
            {
                if (0 == szPath[0])
                {
                    //
                    // Removing the file spec left us with an empty string.
                    // That means a bare "font.pfm" name was passed in. 
                    // Build a relative path to the parent directory.
                    //
                    hr = StringCchPrintf(szPath, ARRAYSIZE(szPath), TEXT("..\\%s"), pszFileName);
                }
                else
                {
                    //
                    // Remove the containing directory so we have a path
                    // to the parent directory.
                    //
                    if (PathRemoveFileSpec(szPath))
                    {
                        //
                        // We're now at the parent directory.
                        // Build a full file path here.
                        //
                        if (PathAppend(szPath, pszFileName))
                        {
                            hr = S_OK;  // We have a path to test.
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        //
                        // No parent directory exists in the path.  That 
                        // means, the PFM file is in the root of the path.
                        // We've already tested for a PFB in the same
                        // directory so our search is over.  No match.
                        //
                        hr = S_FALSE;
                    }
                }
            }
            if (S_OK == hr)
            {
                //
                // We have a valid path to search.  Replace the extension
                // with .PFB and see if the file exists.
                //
                PathRenameExtension(szPath, TEXT(".PFB"));
                if (!bFileExists(szPath))
                {
                    hr = S_FALSE;  // No match.
                }
            }
        }
        if (S_OK == hr)
        {
            //
            // Found matching PFB file.  Return the path to the caller.
            //
            hr = StringCchCopy(pszPFB, cchPFB, szPath);
        }
    }
    return hr;
}

//
// Given the path for a PFM file, try to locate a matching
// PFB file.  If one is found, the two paths are concatenated together
// and returned with a '|' character as a delimiter.  If a PFB file is 
// not found, the path to the PFM file is returned unaltered.
//
HRESULT BuildType1FontSpec(LPCTSTR pszPFM, LPTSTR pszSpec, size_t cchSpec)
{
    TCHAR szPFB[MAX_PATH];
    HRESULT hr = FindPfb(pszPFM, szPFB, ARRAYSIZE(szPFB));
    if (S_OK == hr)
    {
        //
        // PFB file found.  Build the concatenated PFM|PFB path string.
        //
        hr = StringCchPrintf(pszSpec, cchSpec, TEXT("%s|%s"), pszPFM, szPFB);
    }
    else if (S_FALSE == hr)
    {
        //
        // No PFB found.  Return the original PFM file path.
        //
        hr = StringCchCopy(pszSpec, cchSpec, pszPFM);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\ole2map\elsepan.c ===
/***************************************************************************
 * ELSEPAN.C - ElseWare PANOSE(tm) 1.0 Font Mapper routines.
 *
 * $keywords: elsepan.c 1.5 19-Jul-93 11:15:09 AM$
 *
 * Copyright (C) 1991-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/
#define ELSE_MAPPER_CORE
#include <windows.h>
#include "elsepan.h"

/* Sanity check: this is the poor man's way to make sure the mapstate
 * we get is valid. We init this value during startup and check it upon
 * entry to every API routine.
 *
 * Note it is a good idea to modify SANITY_VALUE every time you make a
 * significant change to the software just in case the mapper ends up
 * in an environment where there may be multiple copies of it running,
 * or if client software tries to save the mapstate (which is a no-no: it
 * should use the API to get and set the exposed mapstate variables).
 */

#ifndef NOELSEWEIGHTS

#define SANITY_VALUE           0xD0CACA12L

#else

#define SANITY_VALUE           0xD0CACA13L

#endif

#define M_SANE(lpMapState) \
   (((lpMapState) != NULL) && ((lpMapState)->ulSanity == SANITY_VALUE))

#define M_lpjOFFS(lpDB, lOffs) (((EW_LPBYTE)(lpDB)) + (lOffs))

#ifndef M_ELSEMEMCPY

#define ELSELOCALMEMCPY

#define M_ELSEMEMCPY(dst, src, len) s_lpPANMemCpy((dst), (src), (len))
LOCAL EW_LPBYTE EW_NEAR EW_PASCAL s_lpPANMemCpy
   ELSEARGS (( EW_LPBYTE lpDst, EW_LPBYTE lpSrc, EW_USHORT unLen ));

#endif

LOCAL EW_LPPIND_MEM EW_NEAR EW_PASCAL s_lpPANGetIndRec
   ELSEARGS (( EW_LPPDICT_MEM lpPDB, EW_LPBYTE EW_FAR *lplpPanWant,
      EW_LPBYTE EW_FAR *lplpPanThis ));

LOCAL EW_BOOL EW_NEAR EW_PASCAL s_bPANGetPenaltyC0
   ELSEARGS (( EW_LPPIND_MEM lpPanIndRec, EW_LPPTBL_C0_MEM lpPC0,
      EW_LPUSHORT lpunMatch, EW_USHORT unTblSize, EW_USHORT unAttrA,
      EW_USHORT unAttrB ));

LOCAL EW_USHORT EW_NEAR EW_PASCAL s_unPANGetPenaltyC1
   ELSEARGS (( EW_USHORT unAttrA, EW_USHORT unAttrB ));

LOCAL EW_BOOL EW_NEAR EW_PASCAL s_bPANGetPenaltyC2
   ELSEARGS (( EW_LPPIND_MEM lpPanIndRec, EW_LPBYTE lpPTbl,
      EW_LPUSHORT lpunMatch, EW_USHORT unTblSize,
      EW_USHORT unAttrA, EW_USHORT unAttrB ));

LOCAL EW_USHORT EW_NEAR EW_PASCAL s_unPANGetPenaltyC4
   ELSEARGS (( EW_LPPTBL_C4_MEM lpPC4, EW_USHORT unAttrA,
      EW_USHORT unAttrB ));

LOCAL EW_LPBYTE EW_NEAR EW_PASCAL s_lpPANGetWeights
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_LPPDICT_MEM lpPDB,
      EW_LPPIND_MEM lpPanIndRec ));

LOCAL EW_BOOL EW_NEAR EW_PASCAL s_bPANMatchDigits
   ELSEARGS (( EW_LPPDICT_MEM lpPDB, EW_LPUSHORT lpunMatchTotal,
      EW_LPPIND_MEM lpPanIndRec, EW_LPPTBL_MEM lpPTblRec, EW_USHORT unWt,
      EW_USHORT unAttrA, EW_USHORT unAttrB ));



/***************************************************************************
 * FUNCTION: nPANMapInit
 *
 * PURPOSE:  Initialize the font mapper.  Fill in the default settings.
 *
 * RETURNS:  Return the size of the map-state struct if successful, or
 *           the negative size if the passed in struct was too small.
 *           The function returns zero if it failed to initialize.
 ***************************************************************************/
EW_SHORT EW_FAR EW_PASCAL nPANMapInit( EW_LPMAPSTATE lpMapState,
                                       EW_USHORT unSizeMapState)
{
    EW_USHORT i;
    EW_LPPDICT_MEM lpPDB;
    EW_LPBYTE lpPanDef;
    EW_LPBYTE lpjWtA;
    EW_LPBYTE lpjWtB;
    
    //
    //  Simple version check: make sure we got the right size struct.
    //

    if( unSizeMapState < sizeof( EW_MAPSTATE ) )
    {
        if( unSizeMapState >= sizeof( EW_ULONG ) )
        {
            lpMapState->ulSanity = 0L;
        }
        return( -(EW_SHORT) sizeof( EW_MAPSTATE ) );
    }

    lpMapState->ulSanity = 0L;
    
    //
    //  Attempt to allocate the penalty database. We keep the handle
    //  until the mapper is disabled.
    //

    if( !( lpMapState->ulhPan1Data = M_lAllocPAN1DATA( ) ) )
    {
        goto errout0;
    }

    //
    //  Make sure the penalty database is the right version and
    //  in the right byte ordering.
    //

    if( !( lpPDB = M_lLockPAN1DATA( lpMapState->ulhPan1Data ) ) )
    {
        goto errout1;
    }

    if( ( lpPDB->unVersion != PANOSE_PENALTY_VERS ) ||
         ( lpPDB->unByteOrder != PTBL_BYTE_ORDER ) )
    {
        goto errout2;
    }

    M_bUnlockPAN1DATA( lpMapState->ulhPan1Data );
    
    //
    //  Fill in defaults.
    //

    lpMapState->unThreshold = ELSEDEFTHRESHOLD;
    lpMapState->unRelaxThresholdCount = 0;
    lpMapState->bUseDef = TRUE;
    
    //
    //  Initial default font is the PANOSE number for Courier.
    //

    lpPanDef = lpMapState->ajPanDef;

    lpPanDef[PAN_IND_FAMILY]     = FAMILY_LATTEXT;
    lpPanDef[PAN_IND_SERIF]      = SERIF_THIN;
    lpPanDef[PAN_IND_WEIGHT]     = WEIGHT_THIN;
    lpPanDef[PAN_IND_PROPORTION] = PROPORTION_MONOSPACE;
    lpPanDef[PAN_IND_CONTRAST]   = CONTRAST_NONE;
    lpPanDef[PAN_IND_STROKE]     = STROKE_GRADVERT;
    lpPanDef[PAN_IND_ARMSTYLE]   = ARM_STRAIGHTSGLSERIF;
    lpPanDef[PAN_IND_LTRFORM]    = LTRFORM_NORMCONTACT;
    lpPanDef[PAN_IND_MIDLINE]    = MIDLINE_STDSERIFED;
    lpPanDef[PAN_IND_XHEIGHT]    = XHEIGHT_CONSTLARGE;


#ifndef NOELSEWEIGHTS
    //
    //  Initialize the custom weights array.
    //

    for( i = 0, lpjWtA = lpMapState->ajWtRefA,
          lpjWtB = lpMapState->ajWtRefB;
          i < MAX_CUSTOM_WEIGHTS;
          ++i, *lpjWtA++ = PANOSE_ANY, *lpjWtB++ = PANOSE_ANY)
       ;

#endif
    
    //
    //  This value is checked by all other functions, in an attempt
    //  to safeguard against a mapstate that we didn't initialize.
    //

    lpMapState->ulSanity = SANITY_VALUE;
    
    //
    //  Normal return.
    //

    return( sizeof( EW_MAPSTATE ) );
    
errout2:
    M_bUnlockPAN1DATA(lpMapState->ulhPan1Data);

errout1:
    M_bFreePAN1DATA(lpMapState->ulhPan1Data);

errout0:
    return( 0 );
}


/***************************************************************************
 * FUNCTION: bPANMapClose
 *
 * PURPOSE:  Free the penalty database and close the font mapper. Also
 *           clear the sanity value so we will not service any more calls
 *           on this mapstate.
 *
 * RETURNS:  The function returns TRUE if the penalty database is
 *           successfully freed.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANMapClose( EW_LPMAPSTATE lpMapState )
{
    if( M_SANE( lpMapState ) )
    {
       lpMapState->ulSanity = 0L;

       return( M_bFreePAN1DATA( lpMapState->ulhPan1Data ) );
    }

    return( FALSE );
}


#ifndef NOELSEPICKFONTS

/***************************************************************************
 * FUNCTION: nPANGetMapDefault
 *
 * PURPOSE:  Fill in the passed-in PANOSE number structure with the
 *           default font.
 *
 * RETURNS:  Return 0 if the default number was not copied (passed-in
 *           structure too small), or NUM_PAN_DIGITS if it was.
 ***************************************************************************/

EW_SHORT EW_FAR EW_PASCAL nPANGetMapDefault( EW_LPMAPSTATE lpMapState,
                                             EW_LPBYTE lpPanDef,
                                             EW_USHORT unSizePanDef)
{
    //
    //  Sanity checks.
    //
    
    if( !M_SANE( lpMapState ) || ( unSizePanDef < SIZE_PAN1_NUM ) )
    {
        return( 0 );
    }

    //
    //  Copy the number.
    //

    M_ELSEMEMCPY( lpPanDef, lpMapState->ajPanDef, SIZE_PAN1_NUM );
    
    return( NUM_PAN_DIGITS );
}


/***************************************************************************
 * FUNCTION: nPANSetMapDefault
 *
 * PURPOSE:  Make the passed-in PANOSE number the new default font.  There
 *           is no sanity checking on the number.
 *
 * RETURNS:  Return 0 if the default number was not copied (passed-in
 *           structure too small), or NUM_PAN_DIGITS if it was.
 ***************************************************************************/

EW_SHORT EW_FAR EW_PASCAL nPANSetMapDefault( EW_LPMAPSTATE lpMapState,
                                             EW_LPBYTE lpPanDef,
                                             EW_USHORT unSizePanDef)
{
    //
    //  Sanity checks.
    //
    
    if( !M_SANE( lpMapState ) || ( unSizePanDef < SIZE_PAN1_NUM ) )
    {
       return( 0 );
    }
    
    //
    //  Copy the number.
    //
    
    M_ELSEMEMCPY( lpMapState->ajPanDef, lpPanDef, SIZE_PAN1_NUM );
    
    return( NUM_PAN_DIGITS );
}


/***************************************************************************
 * FUNCTION: bPANEnableMapDefault
 *
 * PURPOSE:  Enable/disable usage of the default font.
 *
 * RETURNS:  Return the previous usage state, or FALSE in the event of
 *           an error.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANEnableMapDefault( EW_LPMAPSTATE lpMapState,
                                               EW_BOOL bEnable)
{
    if( M_SANE( lpMapState ) )
    {
        EW_BOOL bPrev = lpMapState->bUseDef;

        lpMapState->bUseDef = bEnable;

        return( bPrev );
    }
    else
    {
        return( FALSE );
    }
}


/***************************************************************************
 * FUNCTION: bPANIsDefaultEnabled
 *
 * PURPOSE:  This function gets the state of using the default font.
 *
 * RETURNS:  Return TRUE if usage of the default font is enabled, and
 *           FALSE if it is not or an error occurred.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANIsDefaultEnabled( EW_LPMAPSTATE lpMapState )
{
    return( M_SANE( lpMapState ) && lpMapState->bUseDef );
}

#endif /* ifndef NOELSEPICKFONTS */


#ifndef NOELSETHRESHOLD

/***************************************************************************
 * FUNCTION: unPANGetMapThreshold
 *
 * PURPOSE:  This function gets the state of using threshold checking
 *           in the mapper.
 *
 * RETURNS:  Return the match threshold, or zero if an error occurred.
 ***************************************************************************/

EW_USHORT EW_FAR EW_PASCAL unPANGetMapThreshold( EW_LPMAPSTATE lpMapState )
{
    return( M_SANE( lpMapState ) ? lpMapState->unThreshold : 0 );
}


/***************************************************************************
 * FUNCTION: bPANSetMapThreshold
 *
 * PURPOSE:  Change the match threshold.
 *
 * RETURNS:  Return TRUE if the threshold is changed, FALSE if it is
 *           equal to the match error value and therefore rejected, or
 *           an error occurred.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANSetMapThreshold( EW_LPMAPSTATE lpMapState,
                                              EW_USHORT unThreshold)
{
    //
    //  Cannot set a threshold equal to the error value.
    //
    
    if( !M_SANE( lpMapState ) || ( unThreshold == PAN_MATCH_ERROR ) )
    {
       return( FALSE );
    }
    
    //
    //  Set new threshold.
    //
    
    lpMapState->unThreshold = unThreshold;
    
    return( TRUE );
}


/***************************************************************************
 * FUNCTION: bPANIsThresholdRelaxed
 *
 * PURPOSE:  This function gets the state of using the threshold in
 *           mapping.
 *
 * RETURNS:  Return TRUE if the match threshold is relaxed, or FALSE if
 *           it is not or an error occurred.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANIsThresholdRelaxed( EW_LPMAPSTATE lpMapState )
{
    return( M_SANE( lpMapState ) &&( lpMapState->unRelaxThresholdCount > 0 ) );
}


/***************************************************************************
 * FUNCTION: vPANRelaxThreshold
 *
 * PURPOSE:  Temporarily relax the threshold variable so every font
 *           except the erroneous ones will return a match value.
 *
 * RETURNS:  Nothing.
 ***************************************************************************/

EW_VOID EW_FAR EW_PASCAL vPANRelaxThreshold( EW_LPMAPSTATE lpMapState )
{
    if( M_SANE( lpMapState ) )
    {
       ++lpMapState->unRelaxThresholdCount;
    }
}


/***************************************************************************
 * FUNCTION: bPANRestoreThreshold
 *
 * PURPOSE:  Restore mapping within a threshold.
 *
 * RETURNS:  Return TRUE if the threshold is back in effect or an error
 *           occurred, FALSE if someone else has relaxed it too so it
 *           still is relaxed. We return TRUE on error in the event someone
 *           rights a 'for' loop restoring until TRUE is returned.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANRestoreThreshold( EW_LPMAPSTATE lpMapState )
{
    if( M_SANE( lpMapState ) &&( lpMapState->unRelaxThresholdCount > 0 ) )
    {
       return( --lpMapState->unRelaxThresholdCount == 0 );
    }
    else
    {
       return( TRUE );
    }
}

#endif /* ifndef NOELSETHRESHOLD */


#ifndef NOELSEWEIGHTS

/***************************************************************************
 * FUNCTION: bPANGetMapWeights
 *
 * PURPOSE:  Retrieve the mapper weight values for the passed-in family
 *           digits pair. The variable *lpbIsCustom is set if custom
 *           mapper weights have been set by the caller.
 *
 *           The weights array is an array of 10 bytes corresponding to
 *           the 10 PANOSE digits. The first weight is ignored (and usually
 *           set to zero) because we never actually assess a weighted
 *           penalty on the family digit. We include it so the index
 *           constants may be used to access the values in the weights
 *           array.
 *
 * RETURNS:  Return TRUE if mapper weights were retrieved/available (it is
 *           legal for the caller to pass in NULL for lpjWts), or FALSE
 *           if none exist.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANGetMapWeights( EW_LPMAPSTATE lpMapState,
                                            EW_BYTE jFamilyA,
                                            EW_BYTE jFamilyB,
                                            EW_LPBYTE lpjWts,
                                            EW_LPBOOL lpbIsCustom)
{
    EW_USHORT      i;
    EW_BOOL        bFound = FALSE;
    EW_LPPDICT_MEM lpPDB;
    EW_LPPIND_MEM  lpPanIndRec;
    EW_LPBYTE      lpjWtA;
    EW_LPBYTE      lpjWtB;
    

    //
    //  Sanity test on the family digits.
    //

    if( !M_SANE( lpMapState ) ||
         ( jFamilyA <= PANOSE_NOFIT ) ||( jFamilyA > MAX_PAN1_FAMILY ) ||
         ( jFamilyB <= PANOSE_NOFIT ) ||( jFamilyB > MAX_PAN1_FAMILY ) )
    {
        return( FALSE );
    }

    //
    //  Search for custom weights.
    //

    for( i = 0, lpjWtA = lpMapState->ajWtRefA, lpjWtB = lpMapState->ajWtRefB;
          !bFound && ( i < MAX_CUSTOM_WEIGHTS ) && *lpjWtA;
          ++i, ++lpjWtA, ++lpjWtB)
    {
        //
        //  If custom weights are found then set *lpbIsCustom to
        //  TRUE, copy the weights, and return success.
        //
        
        if( ( (*lpjWtA == jFamilyA ) &&( *lpjWtB == jFamilyB ) ) ||
             ( (*lpjWtA == jFamilyB ) &&( *lpjWtB == jFamilyA ) ) )
        {
            if( lpjWts )
            {
                M_ELSEMEMCPY( lpjWts,
                              &lpMapState->ajCustomWt[SIZE_PAN1_NUM * i],
                              SIZE_PAN1_NUM );
            }

            if( lpbIsCustom )
            {
                *lpbIsCustom = TRUE;
            }

            bFound = TRUE;
        }
    }

    //
    //  No custom weights available. Search the penalty database
    //  for default weights.
    //

    if( !bFound && ( lpPDB = M_lLockPAN1DATA( lpMapState->ulhPan1Data ) ) )
    {
        for( i = 0, lpPanIndRec = lpPDB->pind;
             !bFound && ( i < lpPDB->unNumDicts );
             ++i, ++lpPanIndRec )
        {
            if( ( (lpPanIndRec->jFamilyA == jFamilyA ) &&
                (  lpPanIndRec->jFamilyB == jFamilyB ) ) ||
                ( (lpPanIndRec->jFamilyA == jFamilyB ) &&
                (  lpPanIndRec->jFamilyB == jFamilyA ) ) )
            {
                if( lpPanIndRec->unOffsWts )
                {
                    if( lpjWts )
                    {
                        M_ELSEMEMCPY( lpjWts,
                                      M_lpjOFFS( lpPDB, lpPanIndRec->unOffsWts ),
                                      SIZE_PAN1_NUM );
                    }

                    if( lpbIsCustom )
                    {
                        *lpbIsCustom = FALSE;
                    }

                    bFound = TRUE;
                }
            }
        }

        M_bUnlockPAN1DATA( lpMapState->ulhPan1Data );
    }

    //
    //  Return the result of the search.
    //

    return( bFound );
}


/***************************************************************************
 * FUNCTION: bPANSetMapWeights
 *
 * PURPOSE:  Set the mapper weight values for the passed-in family
 *           digits pair.
 *
 *           The weights array is an array of 10 bytes corresponding to
 *           the 10 PANOSE digits. The first weight is ignored (and usually
 *           set to zero) because we never actually assess a weighted
 *           penalty on the family digit. We include it so the index
 *           constants may be used to access the values in the weights
 *           array.
 *
 * RETURNS:  Return TRUE if mapper weights were set, or FALSE if this
 *           family pair is not supported by the mapper or there is no
 *           more room for custom mapper weights.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANSetMapWeights( EW_LPMAPSTATE lpMapState,
                                            EW_BYTE jFamilyA,
                                            EW_BYTE jFamilyB,
                                            EW_LPBYTE lpjWts )
{
    EW_USHORT      i;
    EW_BOOL        bFound;
    EW_LPPDICT_MEM lpPDB;
    EW_LPPIND_MEM  lpPanIndRec;
    EW_LPBYTE      lpjWtA;
    EW_LPBYTE      lpjWtB;
    EW_LPBYTE      lpjWtFam;
    

    //
    //  Sanity test on the family digits.
    //

    if( !M_SANE( lpMapState ) || !lpjWts ||
         ( jFamilyA <= PANOSE_NOFIT ) ||( jFamilyA > MAX_PAN1_FAMILY ) ||
         ( jFamilyB <= PANOSE_NOFIT ) ||( jFamilyB > MAX_PAN1_FAMILY ) )
    {
        return( FALSE );
    }

    //
    //  First make sure this family pair exists in the penalty
    //  database (it does not make sense to store penalties for
    //  a family pair we'll never map against).
    //

    if( lpPDB = M_lLockPAN1DATA( lpMapState->ulhPan1Data ) )
    {
        for( i = 0, bFound = FALSE, lpPanIndRec = lpPDB->pind;
             i < lpPDB->unNumDicts; ++i, ++lpPanIndRec)
        {
            if( ( (lpPanIndRec->jFamilyA == jFamilyA ) &&
                (  lpPanIndRec->jFamilyB == jFamilyB ) ) ||
                ( (lpPanIndRec->jFamilyA == jFamilyB ) &&
                (  lpPanIndRec->jFamilyB == jFamilyA ) ) )
            {
                bFound = TRUE;
                break;
            }
        }

        M_bUnlockPAN1DATA( lpMapState->ulhPan1Data );

        if( !bFound )
        {
            return( FALSE );
        }
    }
    else
    {
        return( FALSE );
    }

    //
    //  Search for an existing entry.
    //

    for( i = 0, lpjWtA = lpMapState->ajWtRefA, lpjWtB = lpMapState->ajWtRefB;
         ( i < MAX_CUSTOM_WEIGHTS ) && *lpjWtA;
          ++i, ++lpjWtA, ++lpjWtB)
    {
        if( ( (*lpjWtA == jFamilyA ) &&( *lpjWtB == jFamilyB ) ) ||
            ( (*lpjWtA == jFamilyB ) &&( *lpjWtB == jFamilyA ) ) )
        {
            break;
        }
    }

    //
    //  Abort if the weights were not found and there are no free slots.
    //

    if( i >= MAX_CUSTOM_WEIGHTS )
    {
        return( FALSE );
    }

    //
    //  We either found the previous weights or have a free slot,
    //  in both cases copy the passed-in weights. For aesthetics,
    //  preserve zero for the family weight( it is not used ).
    //

    *lpjWtA = jFamilyA;
    *lpjWtB = jFamilyB;

    M_ELSEMEMCPY( lpjWtFam = &lpMapState->ajCustomWt[SIZE_PAN1_NUM * i],
                  lpjWts, SIZE_PAN1_NUM);

    *lpjWtFam = 0;
    
    //
    //  Return success.
    //

    return( TRUE );
}


/***************************************************************************
 * FUNCTION: bPANClearMapWeights
 *
 * PURPOSE:  Locate the custom mapper weights for the passed-in family
 *           digit pair and clear them, thus causing the mapper to revert
 *           back to using the default weights.
 *
 * RETURNS:  Return TRUE if custom mapper weights were located and cleared,
 *           FALSE if there are no custom weights for the passed-in family
 *           digit pair.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANClearMapWeights( EW_LPMAPSTATE lpMapState,
                                              EW_BYTE jFamilyA,
                                              EW_BYTE jFamilyB )
{
    EW_USHORT i;
    EW_USHORT j;
    EW_LPBYTE lpjWtA;
    EW_LPBYTE lpjWtB;
    

    //
    //  Sanity test on the family digits.
    //

    if( !M_SANE( lpMapState ) ||
         ( jFamilyA <= PANOSE_NOFIT ) ||( jFamilyA > MAX_PAN1_FAMILY ) ||
         ( jFamilyB <= PANOSE_NOFIT ) ||( jFamilyB > MAX_PAN1_FAMILY ) )
    {
        return( FALSE );
    }

    //
    //  Search for custom weights.
    //

    for( i = 0, lpjWtA = lpMapState->ajWtRefA, lpjWtB = lpMapState->ajWtRefB;
         ( i < MAX_CUSTOM_WEIGHTS ) && *lpjWtA;
          ++i, ++lpjWtA, ++lpjWtB)
    {
        //
        //  If custom weights are found then overwrite them by
        //  shifting other weights forward in the array.
        //

        if( ( (*lpjWtA == jFamilyA ) &&( *lpjWtB == jFamilyB ) ) ||
            ( (*lpjWtA == jFamilyB ) &&( *lpjWtB == jFamilyA ) ) )
        {
            for( j = i + 1, ++lpjWtA, ++lpjWtB;
                 ( j < MAX_CUSTOM_WEIGHTS ) && *lpjWtA;
                  ++j, ++lpjWtA, ++lpjWtB)
            {
                lpjWtA[-1] = *lpjWtA;
                lpjWtB[-1] = *lpjWtB;
            }

            lpjWtA[-1] = PANOSE_ANY;
            lpjWtB[-1] = PANOSE_ANY;

            if( i < ( j - 1 ) )
            {
                M_ELSEMEMCPY( &lpMapState->ajCustomWt[SIZE_PAN1_NUM * i],
                              &lpMapState->ajCustomWt[SIZE_PAN1_NUM * (i + 1)],
                              ( SIZE_PAN1_NUM * (j - i - 1 ) ) );
            }

            return( TRUE );
        }
    }

    //
    //  Custom weights matching this family digit pair were not
    //  found, return failure.
    //

    return( FALSE );
}


#endif /* ifndef NOELSEWEIGHTS */


/***************************************************************************
 * FUNCTION: unPANMatchFonts
 *
 * PURPOSE:  Match two PANOSE numbers.
 *
 * RETURNS:  Return a match value if the fonts are successfully compared
 *           and are within range of the threshold, otherwise return
 *           PAN_MATCH_ERROR if there is an error or the fonts are out
 *           of range.
 ***************************************************************************/

EW_USHORT EW_FAR EW_PASCAL unPANMatchFonts( EW_LPMAPSTATE lpMapState,
                                            EW_LPBYTE lpPanWant,
                                            EW_ULONG ulSizeWant,
                                            EW_LPBYTE lpPanThis,
                                            EW_ULONG ulSizeThis,
                                            EW_BYTE jMapToFamily )
{
    EW_USHORT unMatch = PAN_MATCH_ERROR;
    EW_USHORT unThreshold;
    EW_USHORT i;
    EW_USHORT j;
    EW_LPPDICT_MEM lpPDB;
    EW_LPPIND_MEM lpPanIndRec;
    EW_LPPTBL_MEM lpPTblRec;
    EW_LPBYTE lpjWts;
    EW_LPATOB_MEM lpAtoBHead;
    EW_LPATOB_ITEM_MEM lpAtoB;


    //
    //  Sanity check on the PANOSE numbers. Both numbers must be
    //  valid PANOSE 1.0 numbers, and the 'this'( compared-to )
    //  number must match the map-to family.
    //

    if( !M_SANE( lpMapState ) ||
         ( ulSizeWant != SIZE_PAN1_NUM ) || ( ulSizeThis != SIZE_PAN1_NUM ) ||
         ( lpPanWant[PAN_IND_FAMILY] <= PANOSE_NOFIT )   ||
         ( lpPanWant[PAN_IND_FAMILY] > MAX_PAN1_FAMILY ) ||
         ( lpPanThis[PAN_IND_FAMILY] <= PANOSE_NOFIT )   ||
         ( lpPanThis[PAN_IND_FAMILY] > MAX_PAN1_FAMILY ) ||
         ( lpPanThis[PAN_IND_FAMILY] != jMapToFamily ) )
    {
        goto backout0;
    }

    //
    //  Lock the penalty database.
    //

    if( !(lpPDB = M_lLockPAN1DATA( lpMapState->ulhPan1Data ) ) )
    {
        goto backout0;
    }

    //
    //  Locate the index entry that points to the dictionary containing
    //  the penalty tables for this PANOSE number.
    //  This routine may flip what lpPanWant and lpPanThis point to so
    //  we can guarantee the 'FamilyA' from the penalty tables is always
    //  associated with lpPanWant and 'FamilyB' is associated with
    //  lpPanThis.
    // 
    //  Optimization for unsupported families: If we do not support this
    //  family, but the numbers are identical, then return an 'exact match'
    //  value of zero. Otherwise return the usual match error value.
    //

    if( !(lpPanIndRec = s_lpPANGetIndRec(lpPDB, &lpPanWant, &lpPanThis ) ) )
    {
        for( i = 0; ( i < NUM_PAN_DIGITS ) && ( *lpPanWant == *lpPanThis ) &&
             ( *lpPanWant != PANOSE_NOFIT );
              ++i, ++lpPanWant, ++lpPanThis)
           ;
        
        if( i >= NUM_PAN_DIGITS )
        {
            unMatch = 0;
        }

        goto backout1;
    }

    //
    //  Get the array of mapper weights -- this could be a custom array
    //  supplied by the user, or the default array from the penalty
    //  database.
    //

    if( !( lpjWts = s_lpPANGetWeights( lpMapState, lpPDB, lpPanIndRec ) ) )
    {
        goto backout1;
    }

    //
    //  If we are NOT supposed to do threshold testing then just set
    //  it to the maximum integer.
    //

    if( lpMapState->unRelaxThresholdCount > 0 )
    {
        unThreshold = ELSEMAXSHORT;
    }
    else
    {
        unThreshold = lpMapState->unThreshold;
    }

    //
    //  Index the penalty table array.
    //

    lpPTblRec = (EW_LPPTBL_MEM) M_lpjOFFS( lpPDB, lpPanIndRec->unOffsPTbl );
    
    //
    //  There are two flavors of walking the digits:
    // 
    //  1. For cross-family matching, we walk an array of indices mapping
    //     digits from one family to the digits of another.
    //  2. For normal( same family ) matching, we directly walk the digits.
    // 
    //  Test for an a-to-b array( cross-family matching ).
    //

    if( lpPanIndRec->unOffsAtoB )
    {
        //
        //  This is a cross-family mapping, get the a-to-b array head.
        //
        
        lpAtoBHead = (EW_LPATOB_MEM) M_lpjOFFS( lpPDB, lpPanIndRec->unOffsAtoB );
        
        //
        //  Walk the a-to-b array.
        //
        
        for( i = unMatch = 0, j = lpAtoBHead->unNumAtoB,
              lpAtoB = lpAtoBHead->AtoBItem;
              i < j;
              ++i, ++lpPTblRec, ++lpjWts, ++lpAtoB)
        {
            //
            //  Compare the two digits. Abort if the test fails or the
            //  accumulated match value is greater than the threshold.
            //

            if( !s_bPANMatchDigits( lpPDB, &unMatch, lpPanIndRec,
                  lpPTblRec, *lpjWts, lpPanWant[lpAtoB->jAttrA],
                  lpPanThis[lpAtoB->jAttrB]) ||
                 ( unMatch > unThreshold ) )
            {
                unMatch = PAN_MATCH_ERROR;
                goto backout1;
            }
        }
    }
    else
    {
        //
        //  Normal match: comparing PANOSE numbers from the same
        //  families. Walk the digits accumulating the match result.
        //
        
        for( i = unMatch = 0, ++lpPanWant, ++lpPanThis;
              i <( NUM_PAN_DIGITS - 1 );
              ++i, ++lpPTblRec, ++lpjWts, ++lpPanWant, ++lpPanThis )
        {
            //
            //  Compare the two digits. Abort if the test fails or the
            //  accumulated match value is greater than the threshold.
            //

            if( !s_bPANMatchDigits( lpPDB, &unMatch, lpPanIndRec,
                  lpPTblRec, *lpjWts, *lpPanWant, *lpPanThis) ||
                 ( unMatch > unThreshold ) )
            {
                unMatch = PAN_MATCH_ERROR;
                goto backout1;
            }
        }
    }

    //
    //  Return the match value. If it was out of range or an error
    //  occurred, then it will equal PAN_MATCH_ERROR.
    //

backout1:
    M_bUnlockPAN1DATA( lpMapState->ulhPan1Data );

backout0:
    return( unMatch );
}


#ifndef NOELSEPICKFONTS


/***************************************************************************
 * FUNCTION: unPANPickFonts
 *
 * PURPOSE:  Walk an array of fonts ordering them by the closest to the
 *           requested font.  If no font is within range of the threshold
 *           then look for the closest to the default font.  If still
 *           no font is found then just pick the first font in the list.
 *
 *           Implementation note: This proc assumes PANOSE 1.0 numbers.
 *           A future version of this proc will accept intermixed PANOSE
 *           1.0 and 2.0 numbers, and will call a callback routine to
 *           supply each record, instead of presuming it can walk an
 *           array of fixed-length records.
 *
 * RETURNS:  Return the number of fonts found to match the requested
 *           font, or zero if unNumInds == 0 or an error ocurred.
 *
 *           If no close match was found but the default font is enabled,
 *           then one is returned and *lpMatchValues == PAN_MATCH_ERROR.
 *
 *           If no suitable match was found and the default font is
 *           disabled, then zero is returned.
 ***************************************************************************/
EW_USHORT EW_FAR EW_PASCAL unPANPickFonts( EW_LPMAPSTATE lpMapState,
                                           EW_LPUSHORT lpIndsBest,
                                           EW_LPUSHORT lpMatchValues,
                                           EW_LPBYTE lpPanWant,
                                           EW_USHORT unNumInds,
                                           EW_LPBYTE lpPanFirst,
                                           EW_USHORT unNumAvail,
                                           EW_SHORT nRecSize,
                                           EW_BYTE jMapToFamily )
{
    EW_USHORT i;
    EW_USHORT j;
    EW_USHORT k;
    EW_USHORT unNumFound = 0;
    EW_USHORT unMatchValue;
    EW_USHORT unSavedThreshold;
    EW_LPUSHORT lpMatches;
    EW_LPUSHORT lpInds;
    EW_LPBYTE lpPanThis;
    
    //
    //  Sanity check.
    //

    if( !M_SANE( lpMapState ) || ( unNumInds == 0 ) || ( unNumAvail == 0 ) ||
         ( (nRecSize < 0 ) &&( nRecSize > -(EW_SHORT )SIZE_PAN1_NUM) ) ||
         ( (nRecSize > 0 ) &&( nRecSize < (EW_SHORT )SIZE_PAN1_NUM) ) )
    {
        return( 0 );
    }

    //
    //  This routine implements a 'quit early' algorithm by modifying
    //  the threshold to the worst acceptable value in the list (once
    //  the list is full). This has the effect of causing matchfonts
    //  to abort & return PAN_MATCH_ERROR whenever a penalty exceeds
    //  the threshold.
    //

    unSavedThreshold = lpMapState->unThreshold;
    
    //
    //  Walk the PANOSE numbers ordering them from best to worst
    //  match.  Walk the array with a byte pointer, advancing by
    //  the passed-in record size.
    //

    for( i = 0, lpPanThis = lpPanFirst; i < unNumAvail;
         ++i, lpPanThis += nRecSize)
    {
        //
        //  Get the match value.
        //

        if( ( unMatchValue = unPANMatchFonts( lpMapState,
              lpPanWant, SIZE_PAN1_NUM, lpPanThis, SIZE_PAN1_NUM,
              jMapToFamily ) ) != PAN_MATCH_ERROR )
        {
            //
            //  Find the slot in the array where this match value
            //  should reside.
            // 

            for( j = 0, lpMatches = lpMatchValues;
                ( j < unNumFound ) &&( *lpMatches < unMatchValue );
                ++j, ++lpMatches)
               ;
            
            //
            //  If this match value is better than one of the matches
            //  already in the array, then insert it.  Notice that
            //  until the array is full everything goes in it.  After
            //  that, we shuffle less close matches off the end.
            //

            if( j < unNumInds )
            {
                if( unNumFound < unNumInds )
                {
                   ++unNumFound;
                }

                for( lpInds = &lpIndsBest[k = unNumFound - 1],
                     lpMatches = &lpMatchValues[k];
                     k > j;
                     lpInds[0] = lpInds[-1], lpMatches[0] = lpMatches[-1],
                     --k, --lpInds, --lpMatches)
                    ;

                *lpInds = i;
                *lpMatches = unMatchValue;
                
                //
                //  If the list is full, then set the threshold equal
                //  to the last match value in the list. The matchfonts
                //  routine will abort & return PAN_MATCH_ERROR on any
                //  match greater than this value.
                // 
                //  Also, if the last value in the list is zero (exact
                //  match), then exit the loop because the list will
                //  not change.
                //

                if( unNumFound == unNumInds )
                {
                    if( (k = lpMatchValues[unNumFound - 1] ) == 0)
                    {
                        break;
                    }

                    lpMapState->unThreshold = k;
                }
            }
        }
    }

    //
    //  If no acceptable match was found, then attempt to find a match
    //  for the default font.  We temporarily step off the threshold
    //  so we will definitely find something.  At this point, we do
    //  not care if the default is not within the threshold, we just
    //  want to find it.
    //

    if( !unNumFound && lpMapState->bUseDef )
    {
        lpMapState->unThreshold = ELSEMAXSHORT;
    
        for( i = 0, lpPanThis = lpPanFirst; i < unNumAvail;
             ++i, lpPanThis += nRecSize)
        {
            if( ( unMatchValue = unPANMatchFonts( lpMapState,
                lpMapState->ajPanDef, SIZE_PAN1_NUM, lpPanThis, SIZE_PAN1_NUM,
                lpMapState->ajPanDef[PAN_IND_FAMILY] ) ) != PAN_MATCH_ERROR )
            {
                if( unNumFound == 0 )
                {
                    *lpIndsBest = i;
                    lpMapState->unThreshold = *lpMatchValues = unMatchValue;
                    ++unNumFound;
                }
                else if( unMatchValue < *lpMatchValues )
                {
                    *lpIndsBest = i;
                    lpMapState->unThreshold = *lpMatchValues = unMatchValue;
                }
            }
        }

        //
        //  We flag this match with the error so the caller can
        // determine that the default font was substituted.
        // 

        if( unNumFound > 0 )
        {
            *lpMatchValues = PAN_MATCH_ERROR;
        }
    }

    //
    //  Restore the threshold.
    // 

    lpMapState->unThreshold = unSavedThreshold;
    
    //
    //  If still no match is found then just pick the first font.
    //

    if( !unNumFound )
    {
        *lpIndsBest = 0;
        *lpMatchValues = PAN_MATCH_ERROR;
        ++unNumFound;
    }

    //
    //  Return the number of fonts found.  It will be zero if we
    //  encountered an error or couldn't find a suitable match.
    //

    return( unNumFound );
}


#endif /* ifndef NOELSEPICKFONTS */


/***************************************************************************
 * FUNCTION: vPANMakeDummy
 *
 * PURPOSE:  Build a dummy PANOSE number with all attributes set to
 *           PANOSE_NOFIT.
 *
 * RETURNS:  Nothing.
 ***************************************************************************/

EW_VOID EW_FAR EW_PASCAL vPANMakeDummy( EW_LPBYTE lpPanThis,
                                        EW_USHORT unSize )
{
    EW_USHORT i;
    EW_USHORT j;
    
    unSize /= sizeof( EW_BYTE );
    
    for( i = j = 0; (i < NUM_PAN_DIGITS ) &&( j < unSize );
       ++i, j += sizeof( EW_BYTE ), *lpPanThis++ = PANOSE_NOFIT)
       ;
}


/***************************************************************************/
/************************** LOCAL SERVICE ROUTINES *************************/
/***************************************************************************/


/***************************************************************************
 * FUNCTION: s_lpPANGetIndRec
 *
 * PURPOSE:  Search the header of the database looking for a dictionary
 *           of penalty tables designed for this family pair.
 *
 *           There is a similar search for the index rec in the routine
 *           bPANGetMapWeights. If you make a change here, also check in
 *           that routine.
 *
 * RETURNS:  Return the pointer to the index record if a match is found,
 *           or NULL if one is not.
 ***************************************************************************/

LOCAL EW_LPPIND_MEM EW_NEAR EW_PASCAL s_lpPANGetIndRec(
                                               EW_LPPDICT_MEM lpPDB,
                                               EW_LPBYTE EW_FAR *lplpPanWant,
                                               EW_LPBYTE EW_FAR *lplpPanThis )
{
    EW_USHORT i;
    EW_BYTE jFamilyA =( *lplpPanWant )[PAN_IND_FAMILY];
    EW_BYTE jFamilyB =( *lplpPanThis )[PAN_IND_FAMILY];
    EW_LPBYTE lpPanSwitch;
    EW_LPPIND_MEM lpPanIndRec;


    //
    //  Walk the index array in the penalty database looking for
    //  a matching family pair.
    //

    for( i = 0, lpPanIndRec = lpPDB->pind; i < lpPDB->unNumDicts;
          ++i, ++lpPanIndRec)
    {
        if( ( lpPanIndRec->jFamilyA == jFamilyA ) &&
            ( lpPanIndRec->jFamilyB == jFamilyB ) )
        {
            //
            //  Straight match. Return the index.
            //

            return( lpPanIndRec );
        
        }
        else if( ( lpPanIndRec->jFamilyA == jFamilyB ) &&
                 ( lpPanIndRec->jFamilyB == jFamilyA ) )
        {
            //
            //  There is a match but the families are swapped. Swap
            //  the PANOSE numbers to match the order in the penalty
            //  database in the event it contains tables that are
            //  order-dependent (this can happen with cross-family
            //  mapping, C0-style/uncompressed/non-symmetric tables).
            //

            lpPanSwitch = *lplpPanWant;

            *lplpPanWant = *lplpPanThis;
            *lplpPanThis = lpPanSwitch;

            return( lpPanIndRec );
        }
    }

    //
    //  No match found, return an error.
    // 

    return( NULL );
}


/***************************************************************************
 * FUNCTION: s_bPANGetPenaltyC0
 *
 * PURPOSE:  Compute the penalty between two PANOSE digits using 'C0'
 *           compression, where the entire table is provided (except
 *           the any and no-fit rows and columns).
 *
 * RETURNS:  Return TRUE if the computed index is within range, and
 *           *lpunMatch is filled in with the penalty value, FALSE if
 *           it is out of range.
 ***************************************************************************/

LOCAL EW_BOOL EW_NEAR EW_PASCAL s_bPANGetPenaltyC0( EW_LPPIND_MEM lpPanIndRec,
                                                    EW_LPPTBL_C0_MEM lpPC0,
                                                    EW_LPUSHORT lpunMatch,
                                                    EW_USHORT unTblSize,
                                                    EW_USHORT unAttrA,
                                                    EW_USHORT unAttrB )
{
    EW_USHORT unInd;


    //
    //  Make sure each value is within range.  Notice this may
    //  be a non-square table.
    //

    if( ( unAttrA > lpPC0->jARangeLast ) ||( unAttrB > lpPC0->jBRangeLast ) )
    {
        *lpunMatch = lpPanIndRec->jDefNoFitPenalty;

        return( FALSE );
    }

    //
    //  Compute the table index.
    //

    if( ( unInd = ( (unAttrA - 2 ) *(lpPC0->jBRangeLast - 1 ) )
                        + unAttrB - 2) >= unTblSize )
    {
        *lpunMatch = lpPanIndRec->jDefNoFitPenalty;

        return( FALSE );
    }

    //
    //  Get the penalty.
    //

    *lpunMatch = lpPC0->jPenalties[unInd];

    return( TRUE );
}


/***************************************************************************
 * FUNCTION: s_unPANGetPenaltyC1
 *
 * PURPOSE:  Compute the penalty between two PANOSE digits using 'C1'
 *           compression, which is a perfectly symmetrical table around
 *           the diagonal.  Two digits on the diagonal are an exact match.
 *           A difference of 1 yields a penalty of 1, a difference of 2
 *           yields a penalty of 2, and so on.
 *
 *           It is assumed the caller handled any, no-fit, and exact
 *           matches.
 *
 * RETURNS:  Return the penalty from the table, the function cannot fail.
 ***************************************************************************/
LOCAL EW_USHORT EW_NEAR EW_PASCAL s_unPANGetPenaltyC1( EW_USHORT unAttrA,
                                                       EW_USHORT unAttrB )
{
    EW_SHORT nDiff;
    

    //
    //  Compute the penalty, which is simply the absolute value
    //  of the difference between the two numbers.
    //

    if( ( nDiff = (EW_SHORT) unAttrA - (EW_SHORT) unAttrB ) < 0 )
    {
        nDiff = -nDiff;
    }

    return( nDiff );
}


/***************************************************************************
 * FUNCTION: s_bPANGetPenaltyC2
 *
 * PURPOSE:  Compute the penalty between two PANOSE digits using 'C2'
 *           compression, which is a table symmetrical about the
 *           diagonal, but not a smooth range from low to high, so the
 *           lower left corner of the table is provided.  The unAttrA
 *           digit references the row and unAttrB references the column.
 *
 *           It is assumed the caller handled any, no-fit, and exact
 *           matches.
 *
 * RETURNS:  Return TRUE if the computed index is within range, and
 *           *lpunMatch is filled in with the penalty value, FALSE if
 *           it is out of range.
 ***************************************************************************/

LOCAL EW_BOOL EW_NEAR EW_PASCAL s_bPANGetPenaltyC2( EW_LPPIND_MEM lpPanIndRec,
                                                    EW_LPBYTE lpPTbl,
                                                    EW_LPUSHORT lpunMatch,
                                                    EW_USHORT unTblSize,
                                                    EW_USHORT unAttrA,
                                                    EW_USHORT unAttrB )
{
    EW_USHORT unSwap;
    EW_SHORT nInd;


    //
    //  The formula we use assumes the lower left half of the
    //  penalty table, which means row > column.  The table is
    //  symmetric about the diagonal, so if row < column we can
    //  just switch their values.
    // 

    if( unAttrA < unAttrB )
    {
       unSwap = unAttrA;
       unAttrA = unAttrB;
       unAttrB = unSwap;
    }

    //
    //  The table is missing the any, no-fit, and exact match
    //  penalties as those are handled separately.  Since the
    //  table is triangular shaped, we use the additive series
    //  to compute the row:
    // 
    //    n + ... + 3 + 2 + 1 == 1/2 * n *( n + 1 )
    // 
    //  Substituting n for row - 3, the first possible row, and
    //  adding the column offset, we get the following formula:
    // 
    //   ( 1/2 * (row - 3 ) *( row - 2 ) ) +( col - 2 )
    // 
    //  We know that row >= 3 and col >= 2 as we catch the other
    //  cases above.
    // 

    if( ( nInd = M_ELSEMULDIV( unAttrA - 3, unAttrA - 2, 2 ) +
         (EW_SHORT) unAttrB - 2) >= (EW_SHORT) unTblSize )
    {
        *lpunMatch = lpPanIndRec->jDefNoFitPenalty;

        return( FALSE );
    }

    *lpunMatch = lpPTbl[nInd];

    return( TRUE );
}


/***************************************************************************
 * FUNCTION: s_unPANGetPenaltyC4
 *
 * PURPOSE:  Compute the penalty between two PANOSE digits using 'C4'
 *           compression, which is almost identical to  'C1' compression
 *           except a start and increment value are supplied.
 *
 *           It is assumed the caller handled any, no-fit, and exact
 *           matches.
 *
 * RETURNS:  Return the penalty from the table, the function cannot fail.
 ***************************************************************************/

LOCAL EW_USHORT EW_NEAR EW_PASCAL s_unPANGetPenaltyC4( EW_LPPTBL_C4_MEM lpPC4,
                                                       EW_USHORT unAttrA,
                                                       EW_USHORT unAttrB )
{
    EW_SHORT nDiff;
    

    //
    //  First compute the absolute value of the difference
    //  between the two numbers.
    // 

    if( (nDiff = (EW_SHORT )unAttrA -( EW_SHORT )unAttrB) < 0)
    {
       nDiff = -nDiff;
    }

    //
    //  Then scale by the increment and start values.
    // 

    if( nDiff > 0 )
    {
       nDiff = ( ( nDiff - 1 ) *(EW_SHORT) lpPC4->jIncrement ) +
                (EW_SHORT) lpPC4->jStart;
    }

    return( nDiff );
}


/***************************************************************************
 * FUNCTION: s_lpPANGetWeights
 *
 * PURPOSE:  Check the mapstate record for a set of user-supplied custom
 *           weights. If none are present, then use the default weights
 *           from the mapping table.
 *
 * RETURNS:  Return the pointer to the array of weight values.
 ***************************************************************************/

LOCAL EW_LPBYTE EW_NEAR EW_PASCAL s_lpPANGetWeights( EW_LPMAPSTATE lpMapState,
                                                     EW_LPPDICT_MEM lpPDB,
                                                     EW_LPPIND_MEM lpPanIndRec )
{
    EW_USHORT i;
    EW_LPBYTE lpjWtA;
    EW_LPBYTE lpjWtB;
    EW_BYTE jFamilyA = lpPanIndRec->jFamilyA;
    EW_BYTE jFamilyB = lpPanIndRec->jFamilyB;
    
#ifndef NOELSEWEIGHTS
    //
    //  Search for custom weights.
    // 

    for( i = 0, lpjWtA = lpMapState->ajWtRefA, lpjWtB = lpMapState->ajWtRefB;
         ( i < MAX_CUSTOM_WEIGHTS ) && *lpjWtA;
          ++i, ++lpjWtA, ++lpjWtB )
    {
        //
        //  If custom weights are found then return a pointer into
        //  the mapstate struct. We store a weight value for the family
        //  digit but do not use it. The pointer points to the first
        //  digit after the family digit.
        // 

        if( ( (*lpjWtA == jFamilyA ) &&( *lpjWtB == jFamilyB ) ) ||
            ( (*lpjWtA == jFamilyB ) &&( *lpjWtB == jFamilyA ) ) )
        {
            return( &lpMapState->ajCustomWt[ ( SIZE_PAN1_NUM * i ) + 1] );
        }
    }
#endif

    //
    //  If no custom weights were found then return the default
    //  weight from the penalty database.
    // 

    if( lpPanIndRec->unOffsWts )
    {
       return( M_lpjOFFS(lpPDB, lpPanIndRec->unOffsWts + 1 ) );
    }
    else
    {
       return( NULL );
    }
}


/***************************************************************************
 * FUNCTION: s_bPANMatchDigits
 *
 * PURPOSE:  Compute the match value between two PANOSE digits and add
 *           it to the passed in match total.
 *
 * RETURNS:  Return TRUE if the match value is computed and added to
 *           *lpunMatchTotal.  If an error occurs, return FALSE and
 *           set *lpunMatchTotal to the value PAN_MATCH_ERROR.
 ***************************************************************************/

LOCAL EW_BOOL EW_NEAR EW_PASCAL s_bPANMatchDigits( EW_LPPDICT_MEM lpPDB,
                                                   EW_LPUSHORT lpunMatchTotal,
                                                   EW_LPPIND_MEM lpPanIndRec,
                                                   EW_LPPTBL_MEM lpPTblRec,
                                                   EW_USHORT unWt,
                                                   EW_USHORT unAttrA,
                                                   EW_USHORT unAttrB )
{
    EW_USHORT unLast = lpPTblRec->jRangeLast;
    EW_USHORT unMatch;
    

    //
    //  First make sure the digit values are not out of range.
    // 

    if( (unAttrA > unLast ) ||( unAttrB > unLast ) )
    {
       goto errout;
    }

    //
    //  Special case no-fit, any, or exact matches.
    // 

    if( ( unAttrA == PANOSE_NOFIT ) || ( unAttrB == PANOSE_NOFIT ) )
    {
        if( lpPTblRec->jCompress != PAN_COMPRESS_C3 )
        {
           *lpunMatchTotal += lpPanIndRec->jDefNoFitPenalty * unWt;
           return( TRUE );
        }
    }
    else if( ( unAttrA == PANOSE_ANY ) || ( unAttrB == PANOSE_ANY ) )
    {
        *lpunMatchTotal += lpPanIndRec->jDefAnyPenalty * unWt;
        return( TRUE );
    }
    else if( (unAttrA == unAttrB ) &&
            ( lpPTblRec->jCompress != PAN_COMPRESS_C0 ) )
    {
        *lpunMatchTotal += lpPanIndRec->jDefMatchPenalty * unWt;
        return( TRUE );
    }

    //
    //  Compute the penalty depending on the kind of compression
    //  used for the table.
    // 

    switch( lpPTblRec->jCompress )
    {
    
        case PAN_COMPRESS_C0:
            if( !lpPTblRec->unOffsTbl || !lpPTblRec->unTblSize
                || !s_bPANGetPenaltyC0( lpPanIndRec,
                  (EW_LPPTBL_C0_MEM) M_lpjOFFS( lpPDB, lpPTblRec->unOffsTbl ),
                  &unMatch, lpPTblRec->unTblSize, unAttrA, unAttrB ) )
            {
                goto errout;
            }
            
            *lpunMatchTotal += unMatch * unWt;
            break;
        
        case PAN_COMPRESS_C1:
            *lpunMatchTotal += s_unPANGetPenaltyC1( unAttrA, unAttrB ) * unWt;
            break;
        
        case PAN_COMPRESS_C2:
            if( !lpPTblRec->unOffsTbl || !lpPTblRec->unTblSize ||
                !s_bPANGetPenaltyC2( lpPanIndRec,
                  M_lpjOFFS( lpPDB, lpPTblRec->unOffsTbl ), &unMatch,
                  lpPTblRec->unTblSize, unAttrA, unAttrB ) )
            {
                goto errout;
            }
            
            *lpunMatchTotal += unMatch * unWt;
            break;
        
        case PAN_COMPRESS_C3:
            if( !lpPTblRec->unOffsTbl || !lpPTblRec->unTblSize )
            {
                goto errout;
            }
            
            if( ( unAttrA == PANOSE_NOFIT ) || ( unAttrB == PANOSE_NOFIT ) )
            {
                unMatch = *M_lpjOFFS( lpPDB, lpPTblRec->unOffsTbl );
            }
            else if( !s_bPANGetPenaltyC2( lpPanIndRec,
                     M_lpjOFFS( lpPDB, lpPTblRec->unOffsTbl + 1 ), &unMatch,
                                (EW_USHORT) ( lpPTblRec->unTblSize - 1 ),
                                unAttrA, unAttrB ) )
            {
                goto errout;
            }
            
            *lpunMatchTotal += unMatch * unWt;
            break;
        
        case PAN_COMPRESS_C4:
            if( !lpPTblRec->unOffsTbl || !lpPTblRec->unTblSize )
            {
                goto errout;
            }
            
            *lpunMatchTotal += s_unPANGetPenaltyC4(
                (EW_LPPTBL_C4_MEM) M_lpjOFFS( lpPDB, lpPTblRec->unOffsTbl ),
                unAttrA, unAttrB) * unWt;
            break;
    }

    //
    //  Match computed, successful return.
    // 

    return( TRUE );
    
    //
    //  An error occurred, return FALSE.
    // 

errout:

    *lpunMatchTotal = PAN_MATCH_ERROR;

    return( FALSE );
}


/***************************************************************************
 * FUNCTION: s_lpPANMemCpy
 *
 * PURPOSE:  Perform a memcpy operation.
 *
 * RETURNS:  The function returns lpDst.
 ***************************************************************************/

#ifdef ELSELOCALMEMCPY
LOCAL EW_LPBYTE EW_NEAR EW_PASCAL s_lpPANMemCpy( EW_LPBYTE lpDst,
                                                 EW_LPBYTE lpSrc,
                                                 EW_USHORT unLen)
{
    EW_LPBYTE lpRet = lpDst;
    EW_USHORT i;

    for( i = 0; i < unLen; ++i, *lpDst++ = *lpSrc++ )
        ;

    return( lpRet );
}
#endif

/***************************************************************************
 * Revision log:
 *
 * 31-Jan-93  msd PANOSE 1.0 mapper: 10-digit PANOSE.
 *  2-Feb-93  msd Removed huge pointer stuff.
 *  3-Feb-93  msd Removed ctrl-z at EOF.  Added 'unused' pragmas.
 *  3-Feb-93  msd Fixed bug caused by vcs check-in.
 * 14-Feb-93  msd Removed extra restore-threshold call in pickfonts.
 * 15-Feb-93  msd For extra security, bumped the sanity value from
 *                word to a long.
 ***************************************************************************/
/*
 * $lgb$
 * 1.0    17-Feb-93    msd New module created because of vcs problems.
 * 1.1    17-Feb-93    msd Small doc change.
 * 1.2    18-Feb-93    msd Added penalty table byte-ordering check, and C4 ptbl compression( new version of ptbl ). Modified internal routines so 'unused' pragmas are not necessary. Use EW_FAR.
 * 1.3    23-Feb-93    msd On close session, kill the sanity value so subsequent mapper calls will fail.
 * 1.4    25-Feb-93    msd Modified the default font search logic in pickfonts -- search by the default font's family, not by the requested family. Also use M_ELSEMEMCPY() in a few more places.
 * 1.5    19-Jul-93    msd Added compilation flags to selectively disable mapper routines.
 * $lge$
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\ole2map\elsepan.h ===
/***************************************************************************
 * ELSEPAN.H - Base definitions for ElseWare PANOSE(tm) 1.0 Font Mapper.
 *
 * $keywords: elsepan.h 1.10 19-Jul-93 11:11:34 AM$
 *
 * Copyright (C) 1991-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __ELSEPAN_H__
#define __ELSEPAN_H__

/***************************************************************************
 * ELSEUSER
 *
 * Rather than modify elsepan.h, put flags and additions in elseuser.h, or
 * disable inclusion of elseuser.h by placing "#define NOELSEUSER" ahead of
 * the #include for elsepan.h.
 ***************************************************************************/
#ifdef NOELSEUSER
#define __ELSEUSER_H__
#endif
#ifndef __ELSEUSER_H__
#include "elseuser.h"
#endif

/***************************************************************************
 * ELSETYPE
 *
 * Basic ElseWare types.
 ***************************************************************************/
#ifndef __ELSETYPE_H__
#include "elsetype.h"
#endif

/***************************************************************************
 * C++ SUPPORT
 *
 * If we are compiling with a C++ compiler, make these C-callable functions.
 ***************************************************************************/
#ifdef __cplusplus
extern "C" {
#endif

/***************************************************************************
 * COMPILER FLAG OVERRIDES
 *
 * If we are compiling one of the core ElseWare Font Mapper source files,
 * then override some flags.
 ***************************************************************************/
#ifdef ELSE_MAPPER_CORE
#undef NOELSEPANCONST
#define ELSEPENALTYDB
#endif

/***************************************************************************
 * PANOSE 1.0 PENALTIES DATABASE
 *
 * By default, this is declared as a static data object that stores
 * all the penalty tables in a variable called 's_panDB.' This is in
 * PAN1PTBL.H, which is generated by a stand-alone program in PAN1PTBL.C.
 *
 * Two sets of macros 'allocate' and 'lock' the database, which really
 * just return the pointer to the statically defined 's_panDB.'
 *
 * To override, the user should '#define NOELSEPANDATA' in ELSEUSER.H
 * and provide replacements for the allocate and lock routines. The file
 * PAN1PTBL.H should be used to generate the user-provided penalty database.
 ***************************************************************************/
#ifdef ELSE_MAPPER_CORE
#ifdef NOELSEPANDATA
#define __PAN1PTBL_H__
#endif
#ifndef __PAN1PTBL_H__
#include "pan1ptbl.h"
#define M_lAllocPAN1DATA() (1L)              /* returns data handle     */
#define M_bFreePAN1DATA(hData) (TRUE)        /* returns TRUE/FALSE      */
#define M_lLockPAN1DATA(hData) ((EW_LPPDICT_MEM)s_panDB) /* returns ptr */
#define M_bUnlockPAN1DATA(hData) (TRUE)      /* returns TRUE/FALSE      */
#endif
#endif

/***************************************************************************
 * COMPILATION FLAGS
 *
 * These flags control various aspects of compiling the font mapper.  You
 * turn these flags on by #defining them in elseuser.h.
 ***************************************************************************/

/* ELSEARGS macro
 *
 * Disable argument lists on prototypes by #defining NOELSEARGS.
 */
#ifdef ELSEARGS
#undef ELSEARGS
#endif
#ifndef NOELSEARGS
#define ELSEARGS(args) args
#else
#define ELSEARGS(args) ()
#endif

/* PAN_MATCH_ERROR
 *
 * This constant marks an error.
 */
#ifndef PAN_MATCH_ERROR
#define PAN_MATCH_ERROR 0xFFFF
#endif

/* ELSEMAXSHORT
 *
 * Maximum legal value for a SHORT.
 */
#ifndef ELSEMAXSHORT
#define ELSEMAXSHORT 0x7FFF
#endif

/* ELSEDEFTHRESHOLD
 *
 * Default value for the mapper threshold.
 */
#ifndef ELSEDEFTHRESHOLD
#define ELSEDEFTHRESHOLD 30
#endif

/* M_ELSELMUL
 *
 * a * b long math operation.
 */
#ifndef M_ELSELMUL
#define M_ELSELMUL(a, b) ((long)((long)(a) * (long)(b)))
#endif

/* M_ELSELDIV
 *
 * a / b long math operation.
 */
#ifndef M_ELSELDIV
#define M_ELSELDIV(a, b) ((long)((long)(a) / (long)(b)))
#endif

/* M_ELSEMULDIV
 *
 * (a * b) / c math operation.
 */
#ifndef M_ELSEMULDIV
#define M_ELSEMULDIV(a, b, c) \
   ((int)(M_ELSELDIV((M_ELSELMUL((a), (b)) + M_ELSELDIV((c), 2)), (c))))
#endif

/* M_ELSEMEMCPY
 *
 * memcpy(dst, src, len) operation.
 *
 * Defined in elsepan.c. Override it by defining a macro
 * for M_ELSEMEMCPY(dst, src, len).
 */

/***************************************************************************
 * PANOSE CONSTANTS
 *
 * These constants represent the individual values of the PANOSE digits.
 ***************************************************************************/
#define PANOSE_ANY             0
#define PANOSE_NOFIT           1
#define NUM_PAN_DIGITS         10
#define MAX_PAN1_FAMILY        127
#define MAX_PAN1_DIGIT         31
#define MAX_CUSTOM_WEIGHTS     8
#define SIZE_PAN1_NUM          (sizeof(EW_BYTE) * NUM_PAN_DIGITS)

#ifndef NOELSEPANCONST

/* Latin Text PANOSE values.
 */
#define FAMILY_LATTEXT             2
#define FAMILY_LATSCRIPT           3
#define FAMILY_LATDECORATIVE       4
#define FAMILY_LATPICTORIAL        5
#define FAMILY_KANJI3TEXTANDSCRIPT 6
#define FAMILY_KANJI3DECORATIVE    7
#define FAMILY_KANJI3SYMBOLS       8
#define FAMILY__LAST               8

#define SERIF_COVE             2
#define SERIF_OBTUSECOVE       3
#define SERIF_SQUARECOVE       4
#define SERIF_OBTSQUARECOVE    5
#define SERIF_SQUARE           6
#define SERIF_THIN             7
#define SERIF_BONE             8
#define SERIF_EXAGGERATED      9
#define SERIF_TRIANGLE         10
#define SERIF_NORMALSANS       11
#define SERIF_OBTUSESANS       12
#define SERIF_PERPSANS         13
#define SERIF_FLARED           14
#define SERIF_ROUNDED          15
#define SERIF__LAST            15

#define WEIGHT_VERYLIGHT       2
#define WEIGHT_LIGHT           3
#define WEIGHT_THIN            4
#define WEIGHT_BOOK            5
#define WEIGHT_MEDIUM          6
#define WEIGHT_DEMI            7
#define WEIGHT_BOLD            8
#define WEIGHT_HEAVY           9
#define WEIGHT_BLACK           10
#define WEIGHT_NORD            11
#define WEIGHT__LAST           11

#define PROPORTION_OLDSTYLE    2
#define PROPORTION_MODERN      3
#define PROPORTION_EVENWIDTH   4
#define PROPORTION_EXPANDED    5
#define PROPORTION_CONDENSED   6
#define PROPORTION_VERYEXP     7
#define PROPORTION_VERYCOND    8
#define PROPORTION_MONOSPACE   9
#define PROPORTION__LAST       9

#define CONTRAST_NONE          2
#define CONTRAST_VERYLOW       3
#define CONTRAST_LOW           4
#define CONTRAST_MEDIUMLOW     5
#define CONTRAST_MEDIUM        6
#define CONTRAST_MEDIUMHIGH    7
#define CONTRAST_HIGH          8
#define CONTRAST_VERYHIGH      9
#define CONTRAST__LAST         9

#define STROKE_NOVARIATION     2
#define STROKE_GRADDIAG        3
#define STROKE_GRADTRANS       4
#define STROKE_GRADVERT        5
#define STROKE_GRADHORZ        6
#define STROKE_RAPIDVERT       7
#define STROKE_RAPIDHORZ       8
#define STROKE_INSTANTVERT     9
#define STROKE__LAST           9

#define ARM_STRAIGHTHORZ       2
#define ARM_STRAIGHTWEDGE      3
#define ARM_STRAIGHTVERT       4
#define ARM_STRAIGHTSGLSERIF   5
#define ARM_STRAIGHTDBLSERIF   6
#define ARM_NONSTRTHORZ        7
#define ARM_NONSTRTWEDGE       8
#define ARM_NONSTRTVERT        9
#define ARM_NONSTRTSGLSERIF    10
#define ARM_NONSTRTDBLSERIF    11
#define ARM__LAST              11

#define LTRFORM_NORMCONTACT    2
#define LTRFORM_NORMWEIGHTED   3
#define LTRFORM_NORMBOXED      4
#define LTRFORM_NORMFLATTENED  5
#define LTRFORM_NORMROUNDED    6
#define LTRFORM_NORMOFFCENTER  7
#define LTRFORM_NORMSQUARE     8
#define LTRFORM_OBLQCONTACT    9
#define LTRFORM_OBLQWEIGHTED   10
#define LTRFORM_OBLQBOXED      11
#define LTRFORM_OBLQFLATTENED  12
#define LTRFORM_OBLQROUNDED    13
#define LTRFORM_OBLQOFFCENTER  14
#define LTRFORM_OBLQSQUARE     15
#define LTRFORM__LAST          15

#define MIDLINE_STDTRIMMED     2
#define MIDLINE_STDPOINTED     3
#define MIDLINE_STDSERIFED     4
#define MIDLINE_HIGHTRIMMED    5
#define MIDLINE_HIGHPOINTED    6
#define MIDLINE_HIGHSERIFED    7
#define MIDLINE_CONSTTRIMMED   8
#define MIDLINE_CONSTPOINTED   9
#define MIDLINE_CONSTSERIFED   10
#define MIDLINE_LOWTRIMMED     11
#define MIDLINE_LOWPOINTED     12
#define MIDLINE_LOWSERIFED     13
#define MIDLINE__LAST          13

#define XHEIGHT_CONSTSMALL     2
#define XHEIGHT_CONSTSTD       3
#define XHEIGHT_CONSTLARGE     4
#define XHEIGHT_DUCKSMALL      5
#define XHEIGHT_DUCKSTD        6
#define XHEIGHT_DUCKLARGE      7
#define XHEIGHT__LAST          7

/* Latin Script PANOSE values.
 */
#ifndef NOELSEPANSCRIPT

#define STOOL_FLATNIB          2
#define STOOL_PRESSUREPT       3
#define STOOL_ENGRAVED         4
#define STOOL_BALL             5
#define STOOL_BRUSH            6
#define STOOL_ROUGH            7
#define STOOL_FELTPEN          8
#define STOOL_WILDBRUSH        9
#define STOOL__LAST            9

#define STOP_ROMDISCONNECT     2
#define STOP_ROMTRAIL          3
#define STOP_ROMCONNNECT       4
#define STOP_CURDISCONNECT     5
#define STOP_CURTRAIL          6
#define STOP_CURCONNECT        7
#define STOP_BLACKDISCONNECT   8
#define STOP_BLACKTRAIL        9
#define STOP_BLACKCONNECT      10
#define STOP__LAST             10

#define SFORM_UPNOWRAP         2
#define SFORM_UPSOMEWRAP       3
#define SFORM_UPMOREWRAP       4
#define SFORM_UPEXCESSWRAP     5
#define SFORM_OBNOWRAP         6
#define SFORM_OBSOMEWRAP       7
#define SFORM_OBMOREWRAP       8
#define SFORM_OBEXCESSWRAP     9
#define SFORM_EXNOWRAP         10
#define SFORM_EXSOMEWRAP       11
#define SFORM_EXMOREWRAP       12
#define SFORM_EXEXCESSWRAP     13
#define SFORM__LAST            13

#define SFINIAL_NONENOLOOP     2
#define SFINIAL_NONECLOSELOOP  3
#define SFINIAL_NONEOPENLOOP   4
#define SFINIAL_SHARPNOLOOP    5
#define SFINIAL_SHARPCLOSELOOP 6
#define SFINIAL_SHARPOPENLOOP  7
#define SFINIAL_TAPERNOLOOP    8
#define SFINIAL_TAPERCLOSELOOP 9
#define SFINIAL_TAPEROPENLOOP  10
#define SFINIAL_ROUNDNOLOOP    11
#define SFINIAL_ROUNDCLOSELOOP 12
#define SFINIAL_ROUNDOPENLOOP  13
#define SFINIAL__LAST          13

#define SXASCENT_VERYLOWDIF    2
#define SXASCENT_LOWDIF        3
#define SXASCENT_MEDIUMDIF     4
#define SXASCENT_HIGHDIF       5
#define SXASCENT_VERYHIGHDIF   6
#define SXASCENT__LAST         6

#endif  /* ifndef NOELSEPANSCRIPT */

/* Kanji PANOSE values.
 */
#ifndef NOELSEPANKANJI

#define KSTROKE_TRADBRUSH      2
#define KSTROKE_VIGBRUSH       3
#define KSTROKE_DRYBRUSH       4
#define KSTROKE_FLATNIBPEN     5
#define KSTROKE_SQUARE         6
#define KSTROKE_OBTSQUARE      7
#define KSTROKE_ROUND          8
#define KSTROKE_TAPERED        9
#define KSTROKE_MECHBRUSH      10
#define KSTROKE_STACCATO       11
#define KSTROKE_VOLATE         12
#define KSTROKE__LAST          12

#define KCELL_NORMNOSLANT      2
#define KCELL_NORMSLANTED      3
#define KCELL_WIDENOSLANT      4
#define KCELL_WIDESLANTED      5
#define KCELL_TALLNOSLANT      6
#define KCELL_TALLSLANTED      7
#define KCELL_XTRAWIDENOSLANT  8
#define KCELL_XTRAWIDESLANTED  9
#define KCELL_XTRATALLNOSLANT  10
#define KCELL_XTRATALLSLANTED  11
#define KCELL__LAST            11

#define KSSTROKE_ZOT           2
#define KSSTROKE_LONGZOT       3
#define KSSTROKE_FATZOT        4
#define KSSTROKE_HOOKEDZOT     5
#define KSSTROKE_SHORTRECT     6
#define KSSTROKE_LONGRECT      7
#define KSSTROKE_TAPEREDRECT   8
#define KSSTROKE_SPIKE         9
#define KSSTROKE_ROUNDED       10
#define KSSTROKE_EXAGGERATED   11
#define KSSTROKE_ROUGH         12
#define KSSTROKE__LAST         12

#define KTOP_STDNOSQUARE       2
#define KTOP_MODNOSQUARE       3
#define KTOP_STRONGNOSQUARE    4
#define KTOP_WILDNOSQUARE      5
#define KTOP_STDSQUARE         6
#define KTOP_MODSQUARE         7
#define KTOP_STRONGSQUARE      8
#define KTOP_WILDSQUARE        9
#define KTOP__LAST             9

#define KSTYLESIM_FULL         2
#define KSTYLESIM_COMPLEMENT   3
#define KSTYLESIM_SIMILAR      4
#define KSTYLESIM_DIFFERENT    5
#define KSTYLESIM_DISPARATE    6
#define KSTYLESIM__LAST        6

#define KSTROKEVAR_FULL        2
#define KSTROKEVAR_MODERATE    3
#define KSTROKEVAR_LOW         4
#define KSTROKEVAR_NONE        5
#define KSTROKEVAR__LAST       5

#endif  /* ifndef NOELSEPANKANJI */
#endif  /* ifndef NOELSEPANCONST */

/***************************************************************************
 * LATIN TEXT PANOSE INDICES
 *
 * Indices into an array containing the standard 10-digit PANOSE number.
 ***************************************************************************/
#define PAN_IND_FAMILY         0
#define PAN_IND_SERIF          1
#define PAN_IND_WEIGHT         2
#define PAN_IND_PROPORTION     3
#define PAN_IND_CONTRAST       4
#define PAN_IND_STROKE         5
#define PAN_IND_ARMSTYLE       6
#define PAN_IND_LTRFORM        7
#define PAN_IND_MIDLINE        8
#define PAN_IND_XHEIGHT        9
#define PAN_IND__LAST          9

/***************************************************************************
 * LATIN SCRIPT PANOSE INDICES
 *
 * Indices into an array containing the Latin Script 10-digit PANOSE number.
 ***************************************************************************/
#ifndef NOELSEPANSCRIPT
/* define PAN_IND_FAMILY       0 */
#define SPAN_IND_STOOL         1
#define SPAN_IND_WEIGHT        2
#define SPAN_IND_MONOSPC       3
#define SPAN_IND_ASPECT        4
#define SPAN_IND_CONTRAST      5
#define SPAN_IND_STOP          6
#define SPAN_IND_SFORM         7
#define SPAN_IND_SFINIAL       8
#define SPAN_IND_SXASCENT      9
#define SPAN_IND__LAST         9 
#endif  /* ifndef NOELSEPANSCRIPT */

/***************************************************************************
 * KANJI PANOSE INDICES
 *
 * Indices into an array containing the Kanji 10-digit PANOSE number.
 ***************************************************************************/
#ifndef NOELSEPANKANJI
/* define PAN_IND_FAMILY       0 */
#define KPAN_IND_KSTROKE       1
#define KPAN_IND_WEIGHT        2
#define KPAN_IND_KCELL         3
#define KPAN_IND_MONOSPC       4
#define KPAN_IND_CONTRAST      5
#define KPAN_IND_KSSTROKE      6
#define KPAN_IND_KTOP          7
#define KPAN_IND_KSTYLESIM     8
#define KPAN_IND_KSTROKEVAR    9
#define KPAN_IND__LAST         9
#endif  /* ifndef NOELSEPANKANJI */

/***************************************************************************
 * KANJI-TO-LATIN WEIGHT INDICES
 *
 * Indices into the weights array for the Kanji-to-Latin cross-class
 * penalty database.
 ***************************************************************************/
#ifndef NOELSEPANKANJI
/* define PAN_IND_FAMILY       0 */
#define PAN_IND_WT_KLSTROKETOSERIF 1
#define PAN_IND_WT_KLWEIGHT        2
#define PAN_IND_WT_KLCELLTOPROP    3
#define PAN_IND_WT_KLCELLTOLTRFORM 4
#define PAN_IND_WT_KLMONOTOPROP    5
#define PAN_IND_WT_KLCONTRAST      6
#define PAN_IND_WT_KLTOPTOLTRFORM  7
#endif  /* ifndef NOELSEPANKANJI */

/***************************************************************************
 * PANOSE_PENALTY_VERS
 *
 * Database format version number.
 *
 * 0x0100 - Original implementation.
 * 0x0101 - Modified the compression formats in which the tables are stored,
 *          and added a flat table format (zero compression).
 * 0x0110 - PANOSE version 1.0 penalties, previous versions were
 *          "Expanded PANOSE" penalties. Added C3 compression.
 * 0x0111 - Added byte ordering check, and C4 compression. Also the penalty
 *          table builder will make identical ptbls point to the same data
 *          to further compress the database.
 ***************************************************************************/
#define PANOSE_PENALTY_VERS    0x0111

/***************************************************************************
 * PANOSE PENALTY TABLE data structures
 *
 * The following structures are fused together into one big block.  See
 * the sample code in PAN1PTBL.C (provided with the ElseWare Font Mapper
 * source code) for an example of how to build this structure.
 ***************************************************************************/
#ifdef ELSEPENALTYDB

#define PAN_COMPRESS_C0        0
#define PAN_COMPRESS_C1        1
#define PAN_COMPRESS_C2        2
#define PAN_COMPRESS_C3        3
#define PAN_COMPRESS_C4        4
#define PAN_COMPRESS__LAST     4

/* Byte ordering test: the unByteOrder field of the header is
 * tested to make sure it matches this value -- if the bytes
 * are swapped, the test will fail.
 */
#define PTBL_BYTE_ORDER        0x1234

/* C0 compression == full table provided.  The first two bytes
 * of the table contain its dimensions.  When the need exists
 * to specify the whole table it is usually because it is a
 * non-square, non-symmetrical table.
 */
typedef struct _tagEW_PTBL_C0_MEM {
   EW_BYTE jARangeLast;        /* highest possible A value (table width) */
   EW_BYTE jBRangeLast;        /* highest possible B value (table depth) */
   EW_BYTE jReserved;          /* reserved, should be zero */
   EW_BYTE jPenalties[1];      /* penalty table */
} EW_PTBL_C0_MEM, EW_FAR *EW_LPPTBL_C0_MEM;

/* C1 compression == smooth penalty range symetrical about the
 * diagonal where closest to diagonal == 1 and each increment
 * away from the diagonal == increment penalty by one.  NO table
 * is provided, and the any, no-fit, and match penalties take
 * on the defaults listed in the index entry for the dictionary.
 * The variables ulOffsTbl and unTblSize in the range record
 * should be zero.
 */

/* C2 penalties symmetrical around the diagonal but without
 * a smooth range, lower left half specified.  There is no special
 * record needed: it is an array of bytes where any, no-fit, and
 * match penalties are taken from the header.
 */

/* C3 penalties are identical to C2 except the very first byte
 * is the no-fit penalty value: any and match penalties are taken
 * from the header.
 */

/* C4 penalties are similar to C1: symmetric around the diagonal,
 * increasing in uniform increments the further from the diagonal.
 * The difference is it doesn't start at 1 and/or doesn't increment
 * by 1. The start and increment values are provided.
 */
typedef struct _tagEW_PTBL_C4_MEM {
   EW_BYTE jStart;             /* lowest value in table */
   EW_BYTE jIncrement;         /* increment away from the diagonal */
} EW_PTBL_C4_MEM, EW_FAR *EW_LPPTBL_C4_MEM;

/* Penalty table record, which describes the format of the penalty
 * table and contains its offset and size.  There is an array of
 * 9 of these at the offset unOffsPTbl stored in the index record
 * (there is no penalty table for the family digit). In the case of
 * cross-family mapping, there are unNumAtoB records (instead of 9).
 */
typedef struct _tagEW_PTBL_MEM {
   EW_BYTE jRangeLast;         /* highest possible PANOSE digit value */
   EW_BYTE jCompress;          /* type of compression */
   EW_USHORT unOffsTbl;        /* byte offset to penalty table */
   EW_USHORT unTblSize;        /* # bytes in penalty table */
} EW_PTBL_MEM, EW_FAR *EW_LPPTBL_MEM;

/* The A to B array maps PANOSE digits from one classification to
 * those in another (this happens when the two Family digits are
 * not equal).
 */
typedef struct _tagEW_ATOB_ITEM_MEM {
   EW_BYTE jAttrA;             /* PANOSE number index from family A */
   EW_BYTE jAttrB;             /* related PANOSE number ind from family B */
} EW_ATOB_ITEM_MEM, EW_FAR *EW_LPATOB_ITEM_MEM;

typedef struct _tagEW_ATOB_MEM {
   EW_USHORT unNumAtoB;        /* count of array items */
   EW_ATOB_ITEM_MEM AtoBItem[1]; /* remapping array (variable length) */
} EW_ATOB_MEM, EW_FAR *EW_LPATOB_MEM;

/* Mapper weights are stored in an array of 10 1-byte values.
 * We include a weight for the family digit even though it is
 * ignored by the mapper (it is included so the weights array
 * is parrallel to the PANOSE digits array, allowing the same
 * constants to be used to access both arrays). In cross-family
 * mappings there are still 10 weights, and the unused ones are
 * set to zero.
 */

/* Penalty index record.  Each record contains information for a
 * penalty database, which contains all the penalty tables for one
 * given family pair.
 */
typedef struct _tagEW_PIND_MEM {
   EW_BYTE jFamilyA;           /* family pair for which penalties apply */
   EW_BYTE jFamilyB;           /* ditto */
   EW_BYTE jDefAnyPenalty;     /* default penalty value for 'any' match */
   EW_BYTE jDefNoFitPenalty;   /* default penalty value for 'no fit' match */
   EW_BYTE jDefMatchPenalty;   /* default penalty value for exact match */
   EW_BYTE jReserved;          /* to keep the record word-aligned */
   EW_USHORT unOffsWts;        /* byte offs to mapper weights */
   EW_USHORT unOffsAtoB;       /* byte offs to array relates family A to B */
   EW_USHORT unOffsPTbl;       /* byte offs to penalty tables */
} EW_PIND_MEM, EW_FAR *EW_LPPIND_MEM;

/* Penalty dictionary header.  This is the header to the entire
 * structure.  Its last item is a variable length array of index
 * records.  Each index record points to a penalty database.
 */
typedef struct _tagEW_PDICT_MEM {
   EW_USHORT unVersion;        /* version # of this structure */
   EW_USHORT unByteOrder;      /* byte ordering flag */
   EW_USHORT unNumDicts;       /* number of entries in PANOSE_PINDEX array */
   EW_USHORT unSizeDB;         /* count in bytes of the whole database */
   EW_PIND_MEM pind[1];        /* array of EW_PIND recs (variable len) */
} EW_PDICT_MEM, EW_FAR *EW_LPPDICT_MEM;

#endif  /* ifdef ELSEPENALTYDB */

/***************************************************************************
 * MAP STATE structure
 *
 * This data structure stores the state variables used by the mapper.
 * It is passed into almost all the mapper routines.
 ***************************************************************************/
typedef struct _tagEW_MAPSTATE {
   EW_ULONG ulSanity;
   EW_USHORT unThreshold;
   EW_USHORT unRelaxThresholdCount;
   EW_ULONG ulhPan1Data;
   EW_BOOL bUseDef;
   EW_BYTE ajPanDef[NUM_PAN_DIGITS];
#ifndef NOELSEWEIGHTS
   EW_BYTE ajWtRefA[MAX_CUSTOM_WEIGHTS];
   EW_BYTE ajWtRefB[MAX_CUSTOM_WEIGHTS];
   EW_BYTE ajCustomWt[SIZE_PAN1_NUM * MAX_CUSTOM_WEIGHTS];
#endif
} EW_MAPSTATE, EW_FAR *EW_LPMAPSTATE;

/***************************************************************************
 * ELSEPAN.C: Core PANOSE 1.0 font mapping routines.
 ***************************************************************************/

GLOBAL EW_SHORT EW_FAR EW_PASCAL nPANMapInit
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_USHORT unSizeMapState ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANMapClose
   ELSEARGS (( EW_LPMAPSTATE lpMapState ));

GLOBAL EW_USHORT EW_FAR EW_PASCAL unPANMatchFonts
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_LPBYTE lpPanWant,
      EW_ULONG ulSizeWant, EW_LPBYTE lpPanThis, EW_ULONG ulSizeThis,
      EW_BYTE jMapToFamily ));

GLOBAL EW_VOID EW_FAR EW_PASCAL vPANMakeDummy
   ELSEARGS (( EW_LPBYTE lpPanThis, EW_USHORT unSize ));


#ifndef NOELSEPICKFONTS

GLOBAL EW_SHORT EW_FAR EW_PASCAL nPANGetMapDefault
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_LPBYTE lpPanDef,
      EW_USHORT unSizePanDef ));

GLOBAL EW_SHORT EW_FAR EW_PASCAL nPANSetMapDefault
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_LPBYTE lpPanDef,
      EW_USHORT unSizePanDef ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANEnableMapDefault
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_BOOL bEnable ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANIsDefaultEnabled
   ELSEARGS (( EW_LPMAPSTATE lpMapState ));

GLOBAL EW_USHORT EW_FAR EW_PASCAL unPANPickFonts
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_LPUSHORT lpIndsBest,
      EW_LPUSHORT lpMatchValues, EW_LPBYTE lpPanWant,
      EW_USHORT unNumInds, EW_LPBYTE lpPanFirst, EW_USHORT unNumAvail,
      EW_SHORT nRecSize, EW_BYTE jMapToFamily ));

#endif /* ifndef NOELSEPICKFONTS */


#ifndef NOELSETHRESHOLD

GLOBAL EW_USHORT EW_FAR EW_PASCAL unPANGetMapThreshold
   ELSEARGS (( EW_LPMAPSTATE lpMapState ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANSetMapThreshold
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_USHORT unThreshold ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANIsThresholdRelaxed
   ELSEARGS (( EW_LPMAPSTATE lpMapState ));

GLOBAL EW_VOID EW_FAR EW_PASCAL vPANRelaxThreshold
   ELSEARGS (( EW_LPMAPSTATE lpMapState ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANRestoreThreshold
   ELSEARGS (( EW_LPMAPSTATE lpMapState ));

#endif /* ifndef NOELSETHRESHOLD */


#ifndef NOELSEWEIGHTS

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANGetMapWeights
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_BYTE jFamilyA,
      EW_BYTE jFamilyB, EW_LPBYTE lpjWts, EW_LPBOOL lpbIsCustom ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANSetMapWeights
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_BYTE jFamilyA,
      EW_BYTE jFamilyB, EW_LPBYTE lpjWts ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANClearMapWeights
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_BYTE jFamilyA,
      EW_BYTE jFamilyB ));

#endif /* ifndef NOELSEWEIGHTS */


#ifdef __cplusplus
}
#endif

#endif /* ifndef __ELSEPAN_H__ */

/***************************************************************************
 * Revision log:
 ***************************************************************************/
/*
 * $lgb$
 * 1.0    31-Jan-93    msd PANOSE 1.0 mapper: 10-digit PANOSE.
 * 1.1     2-Feb-93    msd Removed huge pointer stuff.
 * 1.2     2-Feb-93    msd 
 * 1.3     3-Feb-93    msd Removed ctrl-Z at EOF.
 * 1.4     3-Feb-93    msd Fixed bug caused by vcs check-in.
 * 1.5     6-Feb-93    msd Word-aligned C0 penalty header.
 * 1.6    15-Feb-93    msd For extra security, bumped the sanity value from word to a long.
 * 1.7    18-Feb-93    msd Added support for C++ compilers.
 * 1.8    18-Feb-93    msd Added penalty table byte-ordering check, and C4 ptbl compression (new version of ptbl). Use EW_FAR.
 * 1.9    27-Apr-93    msd Added MAX_PAN1_DIGIT.
 * 1.10   19-Jul-93    msd Added compilation flags to selectively disable mapper routines.
 * $lge$
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\ole2map\elseuser.h ===
/***************************************************************************
 * ELSEUSER.H - Supplemental header file with compiler flags for the
 *              ElseWare PANOSE(tm) font mapper.
 *
 * $keywords: elseuser.h 1.8 19-Jul-93 11:11:47 AM$
 *
 * Copyright (C) 1991-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __ELSEUSER_H__
#define __ELSEUSER_H__

/* Compiler flags.
 *
 * NOELSEARGS      - Suppress argument list in procedure prototypes.
 * NOELSEPANCONST  - Suppress list of PANOSE constants.
 * NOELSEPANDATA   - Suppress penalty db, see details below.
 * NOELSEPANSCRIPT - Suppress constants for Latin Script.
 * NOELSEPANKANJI  - Suppress PANOSE constants for Kanji.
 * NOELSEPICKFONTS - Excludes unPANPickFonts(), and default routines.
 * NOELSETHRESHOLD - Excludes threshold routines.
 * NOELSEWEIGHTS   - Exclude mapper custom weight controls.
 * ELSEPENALTYDB   - Include constants and structures for penalty tables.
 *
 * PAN_MATCH_ERROR <val> - Match result indicating no match, should equal
 *                         the max allowable unsigned value for EW_USHORT.
 *
 * ELSEMAXSHORT <val>    - The maximum allowable positive signed value for
 *                         EW_SHORT (should be less than PAN_MATCH_ERROR).
 *
 * ELSEDEFTHRESHOLD <val> - Default mapper threshold value (30 if not
 *                          specified). Set equal to ELSEMAXSHORT to
 *                          entirely disable threshold checking.
 */

/* Macros.
 *
 * Override these macros with system-dependant equivalents to improve
 * the performance of the mapper.
 *
 * M_ELSELMUL(a,b)     - Long multiply a * b.
 * M_ELSELDIV(a,b)     - Long divide a / b.
 * M_ELSEMULDIV(a,b,c) - Long multiply & divide, a * b / c, rounded.
 * M_ELSEMEMCPY(dst,src,len) - memcpy(dst,src,len).
 */

/* NOELSEPANDATA: Penalty database override
 *
 * The default behavior of the mapper is to declare a static data
 * structure containing the penalty database. The structure is
 * defined in the file PAN1PTBL.H, which is included in ELSEPAN.C.
 * The file is generated by the program PAN1PTBL, which reads the
 * file PAN1PTBL.TXT.
 *
 * To override this behavior, define NOELSEPANDATA and provide
 * replacements for the following macros:
 *
 * M_lAllocPAN1DATA()       - Allocate database, return 4-byte handle.
 * M_lLockPAN1DATA(hData)   - Lock penalty database.
 * M_bUnlockPAN1DATA(hData) - Unlock penalty database.
 * M_bFreePAN1DATA(hData)   - Free penalty database.
 *
 * The PAN1PTBL program can be used to create a binary file containing
 * the memory picture of the structure (type the program name at the
 * command line to recieve a usage statement).
 */

#ifndef MACINTOSH
#define NOELSEPANKANJI

/* overrides for Windows */
#if 0
#ifdef WIN32
int __stdcall MulDiv(int, int, int);
#else
int far pascal MulDiv(int, int, int);
#endif
#endif
#define M_ELSEMULDIV(a, b, c) MulDiv((a), (b), (c))

#include <memory.h>
#ifdef WIN32
#define M_ELSEMEMCPY(dst, src, len) memcpy((dst), (src), (len))
#else
#define M_ELSEMEMCPY(dst, src, len) _fmemcpy((dst), (src), (len))
#endif

#endif    /* ! MACINTOSH */

#endif /* ifndef __ELSEUSER_H__ */

/***************************************************************************
 * Revision log:
 ***************************************************************************/
/*
 * $lgb$
 * 1.0    21-Jan-93    msd New file taken from project MAI.
 * 1.1    31-Jan-93    msd Replaced Expanded PANOSE (1.1) mapper with 10-digit (1.0) mapper.
 * 1.2     1-Feb-93    msd Remove _huge reference.
 * 1.3     2-Feb-93    msd Removed huge pointer stuff.
 * 1.4     3-Feb-93    msd Removed ctrl-Z at EOF.
 * 1.5     3-Feb-93    msd Fixed bug caused by vcs check-in.
 * 1.6    16-Mar-93    msd Enable PANOSE constants.
 * 1.7    27-Apr-93    msd Enabled script constants.
 * 1.8    19-Jul-93    msd Added compilation flags to selectively disable mapper routines.
 * $lge$
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\ole2map\elsetype.h ===
/***************************************************************************
 * ELSETYPE.H - Public ElseWare include file.
 *
 * $keywords: elsetype.h 1.13  5-Oct-93 5:46:20 PM$
 *
 * Used to design public interfaces to mapper, mai, TMR, 318 etc.)
 *
 * Most ElseWare types contain an "EW_" to avoid confusion with other host
 * defined types.  All source files must include this file.  This file
 * should be included **AFTER** other standard environment headers such
 * as windows.h, c include files.
 *
 * Other include files:
 *
 *    ELSEPRIV.H     Used to contain other useful info that need not be
 *                   in public interfaces.
 *
 *    <proj>.h       Public interface to a project, e.g. TMR.H
 *
 *    <proj>PRIV.H   Private interfaces for a project, e.g. TMRPRIV.H
 *
 *    <comp>.H       Component interfaces within a project, e.g. DM.H
 *
 *    <comp>PRIV.H   Component private interfaces.
 *
 * Copyright (C) 1992-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __ELSETYPE_H__
#define __ELSETYPE_H__

/***************************************************************************
 * Keyword definitions.
 ***************************************************************************/


#if defined(__STDC__) || defined(WIN32)

/* Standard C, i.e. ANSI C
 */

#ifdef EW_FAR
#undef EW_FAR
#endif
#define EW_FAR

#ifdef EW_NEAR
#undef EW_NEAR
#endif
#define EW_NEAR

#ifdef EW_HUGE
#undef EW_HUGE
#endif
#define EW_HUGE

#ifdef EW_PASCAL
#undef EW_PASCAL
#endif
#ifdef WIN32
#define EW_PASCAL __stdcall
#else
#define EW_PASCAL
#endif /* WIN32 */

#ifdef EW_CDECL
#undef EW_CDECL
#endif
#define EW_CDECL

#else /* __STDC__ */

#ifndef EW_FAR
#define EW_FAR       __far
#endif

#ifndef EW_NEAR
#define EW_NEAR      __near
#endif

#ifndef EW_HUGE
#define EW_HUGE      __huge
#endif

#ifndef EW_PASCAL
#define EW_PASCAL    __pascal
#endif

#ifndef EW_CDECL
#define EW_CDECL     __cdecl
#endif

#endif /* __STDC__ */

#ifndef EXPORT
#define EXPORT       __export
#endif

#ifndef EW_VOID
#define EW_VOID      void
#endif

#ifndef GLOBAL
#define GLOBAL       extern
#endif

#ifndef LOCAL
#define LOCAL        static
#endif

#ifndef NULL
#define NULL         0L
#endif

#ifndef EW_NULL
#define EW_NULL      0L
#endif

#ifndef MAXLONG
#define MAXLONG      (0x7FFFFFFF)
#endif

#ifndef TRUE
#define TRUE         1
#endif

#ifndef FALSE
#define FALSE        0
#endif

#ifndef MAX
#define MAX(a, b) ( ((a) > (b)) ? (a) : (b) )
#endif

#ifndef MIN
#define MIN(a, b) ( ((a) < (b)) ? (a) : (b) )
#endif

#ifdef _NATIVE_IS_MOTOROLA /* native byte order matches Motorola 68000 */
   #ifndef SWAPL
      #define SWAPL(a)        (a)
   #endif
   #ifndef SWAPW
      #define SWAPW(a)        (a)
   #endif
   #ifndef SWAPWINC
      #define SWAPWINC(a)     (*(a)++)
   #endif
#else
 /* Portable code to extract a short or a long from a 2- or 4-byte buffer */
 /* which was encoded using Motorola 68000 (TrueType "native") byte order. */
   #define FS_2BYTE(p)  ( ((unsigned short)((p)[0]) << 8) |  (p)[1])
   #define FS_4BYTE(p)  ( FS_2BYTE((p)+2) | ( (FS_2BYTE(p)+0L) << 16) )

   #ifndef SWAPW
      #define SWAPW(a)        ((short) FS_2BYTE( (unsigned char EW_FAR*)(&(a)) ))
   #endif

   #ifndef SWAPL
      #define SWAPL(a)        ((long) FS_4BYTE( (unsigned char EW_FAR*)(&(a)) ))
   #endif

   #ifndef SWAPWINC
      #define SWAPWINC(a)     SWAPW(*(a)); a++  /* Do NOT parenthesize! */
   #endif


#endif

#ifndef FLIPW
   #define FLIPW(a)           ((short) FS_2BYTE( (unsigned char EW_FAR*)(&(a)) ))
#endif

#ifndef FLIPL
   #define FLIPL(a)           ((long) FS_4BYTE( (unsigned char EW_FAR*)(&(a)) ))
#endif

#ifndef ASW
   #define ASW(a,b)        (a = SWAPW((b)))
#endif

#ifndef ASL
   #define ASL(a,b)        (a = SWAPL((b)))
#endif

#ifndef ASWT
   extern short __nASWT;
   #define ASWT(a,b)       {__nASWT = (b); a = SWAPW(__nASWT);}
#endif

#ifndef ASLT
   extern long __lASLT;
   #define ASLT(a,b)       {__lASLT = (b); a = SWAPL(__lASLT);}
#endif


/***************************************************************************
 * ElseWare specific types.  These are unlikely to cause conflict.
 ***************************************************************************/

typedef int             EW_RC, EW_FAR* EW_LPRC;

/***************************************************************************
 * Common types.  Prepend with an "EW_" to avoid conflict.
 *
 * m means MOTOROLA order for multiple byte types
 *
 * Note that the types in, WORD, DWORD have been avoided.
 ***************************************************************************/

typedef EW_VOID                        EW_FAR* EW_LPVOID;    /*  v, lpv    */

typedef signed short     EW_SHORT,     EW_FAR* EW_LPSHORT;   /*  n,  lpn   */
typedef signed short     EW_mSHORT,    EW_FAR* EW_LPmSHORT;  /* mn,  lpmn  */

typedef unsigned short   EW_USHORT,    EW_FAR* EW_LPUSHORT;  /*  un, lpun  */
typedef unsigned short   EW_mUSHORT,   EW_FAR* EW_LPmUSHORT; /* mun, lpmun */

typedef signed long      EW_LONG,      EW_FAR* EW_LPLONG;    /*  l,  lpl   */
typedef signed long      EW_mLONG,     EW_FAR* EW_LPmLONG;   /* ul,  lpul  */

typedef unsigned long    EW_ULONG,     EW_FAR* EW_LPULONG;   /*  ul, lpul  */
typedef unsigned long    EW_mULONG,    EW_FAR* EW_LPmULONG;  /* mul, lpmul */

typedef signed char      EW_CHAR,      EW_FAR* EW_LPCHAR;    /* c,   lpc   */
typedef signed char                    EW_FAR* EW_LPSTR;     /*      lpsz  */
typedef unsigned char    EW_BYTE,      EW_FAR* EW_LPBYTE;    /* j,   lpj   */
typedef signed short     EW_BOOL,      EW_FAR* EW_LPBOOL;    /* b,   lpb   */

typedef signed short                  EW_HUGE* EW_HPSHORT;   /*      hpn   */
typedef signed short                  EW_HUGE* EW_HPmSHORT;  /*      hpmn  */
typedef unsigned short                EW_HUGE* EW_HPUSHORT;  /*      hpun  */
typedef unsigned short                EW_HUGE* EW_HPmUSHORT; /*      hpmun */
typedef signed long                   EW_HUGE* EW_HPLONG;    /*      hpl   */
typedef signed long                   EW_HUGE* EW_HPmLONG;   /*      hpml  */
typedef unsigned long                 EW_HUGE* EW_HPULONG;   /*      hpul  */
typedef unsigned long                 EW_HUGE* EW_HPmULONG;  /*      hpmul */
typedef signed char                   EW_HUGE* EW_HPCHAR;    /*      hpc   */
typedef signed char                   EW_HUGE* EW_HPSTR;     /*      hpsz  */
typedef unsigned char                 EW_HUGE* EW_HPBYTE;    /*      hpj   */

/*
 * other hungarian:
 *    sz    for zero terminated strings
 *    sp    for pascal strings
 *    a...  for arrays, except for arrays of char which are strings
 */

#ifdef __EW_TT_TYPES__
/*
 * Note: these typedefs do not follow the convention of all CAPS
 *       so that they more closely match the format used in the
 *       TrueType Spec 1.0.
 */
typedef unsigned long    EW_Fixed,     EW_FAR* EW_LPFixed;    /*  fi,  lpnfi  */
typedef unsigned long    EW_mFixed,    EW_FAR* EW_LPmFixed;   /* mfi,  lpmfi  */
typedef signed short     EW_FWord,     EW_FAR* EW_LPFWord;    /*  fw,  lpfw   */
typedef signed short     EW_mFWord,    EW_FAR* EW_LPmFWord;   /* mfw,  lpmfw  */
typedef unsigned short   EW_UFWord,    EW_FAR* EW_LPUFWord;   /* ufw,  lpufw  */
typedef unsigned short   EW_mUFWord,   EW_FAR* EW_LPmUFword;  /* mufw, lpmufw */

typedef signed short     EW_F2DOT14,   EW_FAR* EW_LPF2DOT14;  /* f2,   lpf2   */
typedef signed short     EW_mF2DOT14,  EW_FAR* EW_LPmF2DOT14; /* mf2,  lpmf2  */
typedef signed long      EW_F26DOT6,   EW_FAR* EW_LPF26DOT6;  /* f26,  lpf26  */
typedef signed long      EW_mF26DOT6,  EW_FAR* EW_LPmF26DOT6; /* mf26, lpmf26 */
typedef signed short     EW_F10DOT6,   EW_FAR* EW_LPF10DOT6;  /* f10,  lpf10  */
typedef signed short     EW_mF10DOT6,  EW_FAR* EW_LPmF10DOT6; /* mf10, lpmf10 */

typedef                  EW_Fixed      EW_HUGE* EW_HPFixed;   /*  fi,  lpnfi  */
typedef                  EW_mFixed     EW_HUGE* EW_HPmFixed;  /* mfi,  lpmfi  */
typedef                  EW_FWord      EW_HUGE* EW_HPFWord;   /*  fw,  lpfw   */
typedef                  EW_mFWord     EW_HUGE* EW_HPmFWord;  /* mfw,  lpmfw  */
typedef                  EW_UFWord     EW_HUGE* EW_HPUFWord;  /* ufw,  lpufw  */
typedef                  EW_mUFWord    EW_HUGE* EW_HPmUFword; /* mufw, lpmufw */

typedef                  EW_F2DOT14    EW_HUGE* EW_HPF2DOT14;  /* f2,   lpf2   */
typedef                  EW_mF2DOT14   EW_HUGE* EW_HPmF2DOT14; /* mf2,  lpmf2  */
typedef                  EW_F26DOT6    EW_HUGE* EW_HPF26DOT6;  /* f26,  lpf26  */
typedef                  EW_mF26DOT6   EW_HUGE* EW_HPmF26DOT6; /* mf26, lpmf26 */
typedef                  EW_F10DOT6    EW_HUGE* EW_HPF10DOT6;  /* f10,  lpf10  */
typedef                  EW_mF10DOT6   EW_HUGE* EW_HPmF10DOT6; /* mf10, lpmf10 */
#endif /* __EW_TT_TYPES__ */



typedef EW_LPBYTE (EW_NEAR EW_PASCAL *EW_NEAROPPTR)();
typedef EW_LPBYTE (EW_FAR  EW_PASCAL *EW_FAROPPTR )();
typedef EW_RC     (EW_FAR            *EW_FARFUNC)();
typedef EW_LPBYTE (EW_FAR            *EW_LPPTR);

/***************************************************************************
 * EW_PANOSE
 ***************************************************************************/

typedef struct tagEW_PANOSE
{
    EW_BYTE    jFamilyType;
    EW_BYTE    jSerifStyle;
    EW_BYTE    jWeight;
    EW_BYTE    jProportion;
    EW_BYTE    jContrast;
    EW_BYTE    jStrokeVariation;
    EW_BYTE    jArmStyle;
    EW_BYTE    jLetterform;
    EW_BYTE    jMidline;
    EW_BYTE    jXHeight;
} EW_PANOSE, EW_FAR* EW_LPPANOSE;


/***************************************************************************
 * EW_lseWare specific macros and constants.
 ***************************************************************************/


#endif /* __ELSETYPE_H__ */

/***************************************************************************
 * Revision log:
 ***************************************************************************/
/*
 * $lgb$
 * 1.0    22-Dec-92    cdm This is the official version.
 * 1.1    22-Dec-92    cdm Added LPBOOL.
 * 1.2    24-Dec-92    cdm Draft 2.
 * 1.3     6-Jan-93    cdm Fixed typo in EW_BOOL decl.
 * 1.4    27-Jan-93    emr Added EW_LPVOID
 * 1.5    30-Jan-93    msd Added EW_LPSTR.
 * 1.6    10-Feb-93    msd Added EW_ prefix to FAR, NEAR, HUGE, PASCAL, and CDECL.
 * 1.7    18-Feb-93    msd Bumped copyright notice.
 * 1.8    26-Feb-93    msd Added EW_PANOSE struct.
 * 1.9    21-Apr-93    emr Added EW_LPPTR. It's used by 318 and Pecos.
 * 1.10   21-Apr-93    emr Fixed MIN() macro.
 * 1.11   30-Apr-93    emr Some of the types in the TrueType section where being multiply defined. This was an error  on the Think C Macintosh compiler.
 * 1.12   19-Jul-93    pmh Latest engine5 elsetype.h.
 * 1.13    5-Oct-93   paul signed vars; FLIP macros
 * $lge$
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\ole2map\pan1ptbl.c ===
/*************************************************************************** 
 * PAN1PTBL.C - ElseWare PANOSE(tm) Font Mapper penalty database.
 *
 * $keywords: pan1ptbl.c 1.9 15-Apr-94 3:53:54 PM$
 *
 * This is a stand-alone program that writes a 'C' style header file
 * containing the penalty tables for the font mapper.  The tables are
 * in MEMORY format, e.g., they use Intel or Motorola byte ordering
 * depending on the platform upon which the program is compiled.
 *
 * This program should accompany ELSEPAN.C, the ElseWare PANOSE Mapper
 * source code, which assumes the output from this program is in a file
 * named PAN1PTBL.H.
 *
 * The command-line is as follows:
 *
 *       pan1ptbl [-b] [-v] [-l] [-d] <in-filename> <out-filename>
 *
 * where:
 *
 *       -b means produce a binary file (instead of a 'C' struct)
 *       -v means get from and put to version control
 *       -l means precede the struct with the keyword FAR
 *       -d means dump the database to the screen
 *       <in-filename> is the name of the text file containing the
 *                     penalty database (PAN1PTBL.TXT)
 *       <out-filename> is the name of the output file (PAN1PTBL.H)
 *
 * The '-b' switch causes the MEMORY representation of the struct to be
 * dumped to file (in binary form). The normal behavior (no '-b' switch)
 * is to produce a text file containing a C-style declaration of the
 * struct.
 *
 * The '-v' switch presumes the user has Sorcerer's Apprentice, and causes
 * a 'vout' of pan1ptbl.h followed by a 'vin' of the newly generated file.
 * Notice that Sorcerer's Apprentice ignores the transaction if the file
 * is not different from the previous revision.
 *
 * The '-l' switch causes the database to be declared 'FAR,' which in
 * DOS and Windows large model programs causes the data structure to be
 * placed in its own data segment.
 *
 * The '-d' switch causes a textual description of the database to be
 * dumped to stdout for debugging purposes.
 *
 * Copyright (C) 1991-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/
#define ELSE_MAPPER_CORE
#define NOELSEPANDATA
#include "elsepan.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef MACINTOSH
#include "osutils.h"
#endif /* MACINTOSH */


#ifdef MACINTOSH

#   define SZ_DATABASE "DATABASE"
#   define SZ_TABLE    "TABLE"

#   define  PT_strupr(p)        uprstring((p), FALSE)
BOOL PT_strcmpi(char *s, char *t) {
    uprstring(s, FALSE);
    return strcmp(s, t);
}

#else /* WINDOWS */

#   define SZ_DATABASE TEXT("Database")
#   define SZ_TABLE    TEXT("Table")

#   define  PT_strupr(p)        _strupr(p)
#   define  PT_strcmpi(s, t)    _strcmpi(s, t)

#endif


static EW_BOOL bReadDB(FILE *fpin, EW_BOOL bBuildIt);
static EW_BOOL bReadPTbl(FILE *fpin, EW_BOOL bBuildIt,
      EW_BOOL bExpectSquare, char *pLnBuf, int iBufSize,
      EW_PTBL_MEM *pPTbl, EW_BYTE *pDataBuf);
static int iGetCompressKind(EW_BYTE *pDataBuf,
      int iRow, int iCol, int iNoFit);
static EW_BOOL bAddUniqueTable(EW_PTBL_MEM *pPTbl, int iSize);
static int iReadData(FILE *fpin, char *pLnBuf, int iBufSize,
      EW_BYTE *pDataBuf);
static EW_BOOL bGetLine(char *pBuf, int iLen, FILE *fpin);
static void vShowDB(void);
static EW_BOOL bShowDupTbl(EW_PTBL_MEM *pPTbl);

static EW_BYTE s_buf[8192];
static EW_USHORT s_unOffs;
static int s_iLnPos;

/***************************************************************************
 * FUNCTION: main
 *
 * PURPOSE:  Write the file PAN1PTBL.H, which is a 'C'-style .H file
 *           containing the declaration of the memory copy of the
 *           penalty database.
 *
 * RETURNS:  The program returns 0 if it succeeds, 1 if there is a failure.
 ***************************************************************************/
int main (
   int argc,
   char *argv[])
{
   int i;
   int j;
   int iRet = 1;
   EW_BOOL bDumpBin = FALSE;
   EW_BOOL bDoVCS = FALSE;
   EW_BOOL bMakeFar = FALSE;
   EW_BOOL bShowDB = FALSE;
   time_t ltime;
   EW_PDICT_MEM *pHead = (EW_PDICT_MEM *)s_buf;
   FILE *fpin;
   FILE *fpout;
   char *p;
   char *pszInFileNm;
   char *pszOutFileNm;
   char szIncNm[64];
   char szTime[64];

   printf("ElseWare Penalty Table Maker v1.2\n");

   /* Display 'usage' message if the minimum number of parameters
    * was not recieved.
    */
   if( argc < 3 ) {
      printf("Usage: pan1ptbl [-b] [-v] [-l] [-d] <infile> <outfile>\n");
      printf("       -b means dump in binary form (not C-struct)\n");
      printf("       -v means get from and put to version control\n");
      printf("       -l means precede the struct with the keyword FAR\n");
      printf("       -d dump the database to the screen\n");
      printf("       <infile> is the text penalty database (PAN1PTBL.TXT)\n");
      printf("       <outfile> is the output file (PAN1PTBL.H)\n");
      goto backout0;
   }
   /* Set flags.
    */
   for( p = argv[i = 1]; i < (argc - 2 ); p = argv[++i]) {
      if( p[0] != '-' ) {
         printf("Expected command line flag at '%s,' pan1ptbl aborted.\n", p);
         goto backout0;
      }
      switch( p[1] ) {
         case 'b':
         case 'B':
            bDumpBin = TRUE;
            break;
         case 'v':
         case 'V':
            bDoVCS = TRUE;
            break;
         case 'l':
         case 'L':
            bMakeFar = TRUE;
            break;
         case 'd':
         case 'D':
            bShowDB = TRUE;
            break;
         default:
            printf("Unrecognized command line flag '%s' ignored.\n", p);
            break;
      }
   }
   /* Make sure the last few params are not flags (should be
    * file names).
    */
   if( *p == '-' ) {
      printf("Expected input file name at '%s,' pan1ptbl ignored.\n", p);
      goto backout0;
   }
   PT_strupr(pszInFileNm = p);

   p = argv[argc - 1];
   if( *p == '-' ) {
      printf("Expected output file name at '%s,' pan1ptbl ignored.\n", p);
      goto backout0;
   }
   PT_strupr(pszOutFileNm = p);

   /* Extract the file from version control if we're supposed to
    * do that (Sorcerer's Apprentice is assumed).
    */

   if( bDoVCS ) {

#ifdef WINDOWS 
      char cmd[128];
      sprintf(cmd, "vout %s", pszOutFileNm);
      if( system(cmd ) != 0) {
         printf("Failed to get %s from version control, pan1ptbl aborted.\n",
            pszOutFileNm);
         goto backout0;
      }
#endif /* WINDOWS */

#ifdef MACINTOSH
	   printf("VCS mode not valid on the Macintosh.  Continuing anyway...\n");
#endif /* MACINTOSH */
   }

   /* Open the input file.
    */
   if( !(fpin = fopen(pszInFileNm, "rt" ))) {
      printf("Could not open input file %s, pan1ptbl aborted.\n",
         pszInFileNm);
      goto backout0;
   }
   /* Create the output file.
    */
   if( bDumpBin ) {
      fpout = fopen(pszOutFileNm, "wb");
   } else {
      fpout = fopen(pszOutFileNm, "wt");
   }
   if( !fpout ) {
      printf("Could not open output file %s, pan1ptbl aborted.\n",
         pszOutFileNm);
      if( bDoVCS ) {
#ifdef WINDOWS 
         char cmd[128];
         sprintf(cmd, "vadmin u %s", pszOutFileNm);
         if( system(cmd ) != 0) {
            printf("Failed to unlock %s from version control.\n",
               pszOutFileNm);
         }
#endif /* WINDOWS */
      }
      goto backout1;
   }
   /* Build the database.
    */
   s_iLnPos = 0;
   if( !bReadDB(fpin, FALSE )) {
      goto backout2;
   }
   rewind(fpin);
   s_iLnPos = 0;
   if( !bReadDB(fpin, TRUE )) {
      goto backout2;
   }
   printf("%s: %u bytes in database.\n", pszOutFileNm, pHead->unSizeDB);

   if( bShowDB ) {
      vShowDB();
   }
   /* If we're writing binary, then dump it now and exit.
    */
   if( bDumpBin ) {
      fwrite(s_buf, pHead->unSizeDB, 1, fpout);
      goto webedun;
   }

   /* 'C' header write.
    *
    * Write the file containing the 'C' structure that defines
    * the penalty database.
    */
   if( time(&ltime )) {
      strcpy(szTime, asctime(localtime(&ltime)));
      szTime[strlen(szTime) - 1] = '\0';
   } else {
      szTime[0] = '\0';
   }
   strcpy(szIncNm, "__");
   if( (p = strrchr(pszOutFileNm, '\\' )) ||
        ( p = strrchr(pszOutFileNm, ':' ))) {
      strcat(szIncNm, &p[1]);
   } else {
      strcat(szIncNm, pszOutFileNm);
   }
   if( p = strchr(szIncNm, '.' )) {
      *p = '_';
   }
   strcat(szIncNm, "__");
   if( bDoVCS ) {
      fprintf(fpout,
         "/*\044change:Updated by PAN1PTBL.EXE on %s.\044*/\n", szTime);
   }
   fprintf(fpout,
      "/***************************************************************************\n");
   fprintf(fpout,
      " * %s - ElseWare PANOSE(tm) default penalty tables.\n", pszOutFileNm);
   fprintf(fpout,
      " *\n");
   if( bDoVCS ) {
      fprintf(fpout,
         " * $keywords: pan1ptbl.c 1.9 15-Apr-94 3:53:54 PM$\n");
      fprintf(fpout,
         " *\n");
   }
   fprintf(fpout,
      " * This file was generated by PAN1PTBL.EXE.\n");
   fprintf(fpout,
      " *\n");
   fprintf(fpout,
      " * This file contains the penalty tables for the PANOSE 1.0 font\n");
   fprintf(fpout,
      " * mapper. It was generated from the file %s.\n", pszInFileNm);
   fprintf(fpout,
      " *\n");
   fprintf(fpout,
      " * Penalty database structure version %x.%02x.\n",
      PANOSE_PENALTY_VERS / 0x100,
      PANOSE_PENALTY_VERS % 0x100);
   fprintf(fpout,
      " *\n");
   if( !bDoVCS ) {
      fprintf(fpout,
         " * File created %s.\n", szTime);
      fprintf(fpout,
         " *\n");
   }
   fprintf(fpout,
      " * Copyright( C ) 1992-93 ElseWare Corporation.  All rights reserved.\n");
   fprintf(fpout,
      " ***************************************************************************/\n");
   fprintf(fpout,
      "\n");
   fprintf(fpout,
      "#ifndef %s\n", szIncNm);
   fprintf(fpout,
      "#define %s\n", szIncNm);
   fprintf(fpout,
      "\n");
   fprintf(fpout,
      "/***************************************************************************\n");
   fprintf(fpout,
      " * PENALTY DATABASE\n");
   fprintf(fpout,
      " *\n");
   fprintf(fpout,
      " * Below is the default penalty database for the PANOSE font\n");
   fprintf(fpout,
      " * mapper.  It is in the MEMORY format.\n");
   fprintf(fpout,
      " *\n");
   fprintf(fpout,
      " * Look at PAN1PTBL.C to see how this is created.\n");
   fprintf(fpout,
      " ***************************************************************************/\n");
   if( bMakeFar ) {
      fprintf(fpout,
         "EW_BYTE FAR s_panDB[] = {");
   } else {
      fprintf(fpout,
         "EW_BYTE s_panDB[] = {");
   }
   for( i = 1, p = s_buf; i < (int )pHead->unSizeDB; ) {
      fprintf(fpout, "\n  ");
      for( j = 0; (i < (int )pHead->unSizeDB) &&( j < 10 );
            ++i, ++j, ++p) {
         fprintf(fpout, " 0x%02x,",( EW_BYTE )*p);
      }
   }
   if( j == 10 ) {
      fprintf(fpout, "\n  ");
   }
   fprintf(fpout,
      " 0x%02x\n};\n",( EW_BYTE )*p);

   fprintf(fpout,
      "\n");
   fprintf(fpout,
      "#endif /* ifndef %s */\n", szIncNm);

   if( bDoVCS ) {
      fprintf(fpout,
         "\n");
      fprintf(fpout,
         "/***************************************************************************\n");
      fprintf(fpout,
         " * Revision log:\n");
      fprintf(fpout,
         " ***************************************************************************/\n");
      fprintf(fpout,
         "/*\n");
      fprintf(fpout,
         " * \044log\044\n");
      fprintf(fpout,
         " */\n");
   }
webedun:
   fclose(fpout);
   fpout = NULL;

   /* Return the file to version control.
    */
   if( bDoVCS ) {

#ifdef WINDOWS
      char cmd[128];
      sprintf(cmd, "vin -c\"File updated by PAN1PTBL.EXE %s\" %s",
         szTime, pszOutFileNm);
      if( system(cmd ) != 0) {
         printf("Failed to put %s into version control.\n", pszOutFileNm);
      }
#endif /* WINDOWS */
   }
   iRet = 0;
   goto backout1;

backout2:
   fclose(fpout);
backout1:
   fclose(fpin);
backout0:
   return( iRet );
}

/***************************************************************************
 * FUNCTION: bReadDB
 *
 * PURPOSE:  Read the text penalty database. This routine is called twice:
 *           once to gather statistics, and then a second time to fill in
 *           everything else.
 *
 * RETURNS:  The function returns TRUE if parses the whole file without
 *           detecting errors.
 ***************************************************************************/
static EW_BOOL bReadDB(
   FILE *fpin,
   EW_BOOL bBuildIt)
{
   int i;
   int j;
   int w;
   int iNumTbl;
   EW_BOOL bUseAtoB;
   EW_PDICT_MEM *pHead =( EW_PDICT_MEM * )s_buf;
   EW_PIND_MEM *pInd = pHead->pind;
   EW_BYTE *pWt = NULL;
   EW_ATOB_MEM *pAtoB = NULL;
   EW_ATOB_ITEM_MEM *pAtoBItem = NULL;
   EW_PTBL_MEM *pPTbl = NULL;
   char szBuf[256];
   char szKey[128];

   /* First pass: init header. On the second pass it contains
    * the count of dictionaries in the database.
    */
   if( bBuildIt ) {
      s_unOffs = sizeof(EW_PDICT_MEM) +
        ( sizeof(EW_PIND_MEM ) *( pHead->unNumDicts - 1 ));
   } else {
      pHead->unVersion = PANOSE_PENALTY_VERS;
      pHead->unByteOrder = PTBL_BYTE_ORDER;
      pHead->unNumDicts = 0;
      pHead->unSizeDB = 0;
      s_unOffs = sizeof(EW_PDICT_MEM);
   }
   /* Get the first line.
    */
   if( !bGetLine(szBuf, sizeof(szBuf ), fpin)) {
      printf("No data found in the input file, pan1ptbl aborted.\n");
      return( FALSE );
   }
   /* For each database.
    *
    * Look for [ Database ]
    */
   while( (sscanf(szBuf, "[ %s ]", szKey ) == 1) &&
        ( PT_strcmpi(szKey, "Database" ) == 0)) {

      /* Init vars.
       */
      iNumTbl = 0;
      bUseAtoB = FALSE;
      pWt = NULL;
      pAtoB = NULL;
      pAtoBItem = NULL;
      pPTbl = NULL;

      /* If we're really building then set up the vars
       * to recieve the tables.
       */
      if( bBuildIt ) {
         /* The weight array is always exactly 10 bytes long,
          * initialized to all zeroes. The first byte contains
          * the weight for the family digit, which does not
          * have a penalty table associated with it.
          */
         pWt = &s_buf[s_unOffs];
         pInd->unOffsWts = s_unOffs;
         memset(pWt, 0, j =( sizeof(EW_BYTE ) * NUM_PAN_DIGITS));
         ++pWt;
         s_unOffs += j;

         /* For the A-to-B remapping array, the offset
          * variable in the index contains the count of
          * items from the first pass. Use that to set
          * up the array.
          */
         if( pInd->unOffsAtoB > 0 ) {
            pAtoB =( EW_ATOB_MEM * )&s_buf[s_unOffs];
            pAtoBItem = pAtoB->AtoBItem;
            i = pInd->unOffsAtoB;
            pInd->unOffsAtoB = s_unOffs;
            memset((char *)pAtoB, 0, j =( sizeof(EW_ATOB_MEM ) +
              ( sizeof(EW_ATOB_ITEM_MEM ) *( i - 1 ))));
            pAtoB->unNumAtoB = i;
            s_unOffs += j;
         } else {
            i = NUM_PAN_DIGITS - 1;
         }
         /* Set up penalty table pointer.
          */
         pPTbl =( EW_PTBL_MEM * )&s_buf[s_unOffs];
         pInd->unOffsPTbl = s_unOffs;
         memset((char *)pPTbl, 0, j =( sizeof(EW_PTBL_MEM ) * i));
         s_unOffs += j;

      } else {
         pInd->jFamilyA = 0;
         pInd->jFamilyB = 0;
         pInd->jDefAnyPenalty = 0;
         pInd->jDefNoFitPenalty = 10;
         pInd->jDefMatchPenalty = 0;
         pInd->jReserved = 0;
         pInd->unOffsWts = 0;
         pInd->unOffsAtoB = 0;
         pInd->unOffsPTbl = 0;
      }
      /* Look for row = <PANOSE-family-digit-for-row>
       */
      if( !bGetLine(szBuf, sizeof(szBuf ), fpin) ||
           ( sscanf(szBuf, "row = %d", &i ) != 1)) {
         printf("%d: Expected 'row' statement, pan1ptbl aborted.\n",
               s_iLnPos);
         return( FALSE );
      }
      if( (i < PANOSE_NOFIT ) ||( i > MAX_PAN1_FAMILY )) {
         printf("%d: Row PANOSE digit out of range, pan1ptbl aborted.\n",
            s_iLnPos);
         return( FALSE );
      }
      pInd->jFamilyA = i;

      /* Look for col = <PANOSE-family-digit-for-column>
       */
      if( !bGetLine(szBuf, sizeof(szBuf ), fpin) ||
           ( sscanf(szBuf, "col = %d", &i ) != 1)) {
         printf("%d: Expected 'col' statement, pan1ptbl aborted.\n",
               s_iLnPos);
         return( FALSE );
      }
      if( (i < PANOSE_NOFIT ) ||( i > MAX_PAN1_FAMILY )) {
         printf("%d: Column PANOSE digit out of range, pan1ptbl aborted.\n",
               s_iLnPos);
         return( FALSE );
      }
      pInd->jFamilyB = i;

      /* Read in a table heading:
       *
       * [ Table : <ind-row> : <ind-col> : <default-weight> ]
       */
      if( !bGetLine(szBuf, sizeof(szBuf ), fpin)) {
         printf("%d: Expected penalty table after database header, pan1ptbl aborted.\n",
               s_iLnPos);
         return( FALSE );
      }
      /* For each table.
       */
      while ((sscanf(szBuf, "[ %s : %d : %d : %d ]",
            szKey, &i, &j, &w) == 4) &&( PT_strcmpi(szKey, "Table" ) == 0)) {

         /* Make sure indices in range.
          */
         if( (i <= 0 ) ||( j <= 0 ) ||
              ( i >= NUM_PAN_DIGITS ) ||( j >= NUM_PAN_DIGITS )) {
            printf("%d: Digit index out of range, pan1ptbl aborted.\n",
                  s_iLnPos);
            return( FALSE );
         }
         /* Test non-zero weight.
          */
         if( !w && !bBuildIt ) {
            printf("%d: Warning: Weight value of zero.\n", s_iLnPos);
         }
         /* Detect need for A-to-B remapping array. This happens
          * when the row-ind != col-ind or when the inds do not
          * count from 1 to 9.
          */
         if( (i != j ) ||( i != (iNumTbl + 1 ))) {
            bUseAtoB = TRUE;
         }
         /* Attempt to read the table.
          *
          * This routine bumps s_unOffs.
          */
         if (!bReadPTbl(fpin, bBuildIt,
              ( EW_BOOL )((i == j) &&( pInd->jFamilyA == pInd->jFamilyB )),
               szBuf, sizeof(szBuf), pPTbl, &s_buf[s_unOffs])) {
            return( FALSE );
         }
         /* Pick up default weight value and A-to-B settings.
          */
         if( bBuildIt ) {
            *pWt++ = w;
            if( pAtoBItem ) {
               pAtoBItem->jAttrA = i;
               pAtoBItem->jAttrB = j;
               {
                  EW_ATOB_ITEM_MEM *pAtoBCmp = pAtoB->AtoBItem;
                  for( ; pAtoBCmp < pAtoBItem; ++pAtoBCmp ) {
                     if( (pAtoBCmp->jAttrA == pAtoBItem->jAttrA ) &&
                          ( pAtoBCmp->jAttrB == pAtoBItem->jAttrB )) {
                        printf("%u: Row & col pair used in a previous table, pan1ptbl aborted.\n",
                              s_iLnPos);
                        return( FALSE );
                     }
                  }
               }
               ++pAtoBItem;
            }
            ++pPTbl;
         }
         ++iNumTbl;
      }
      /* End of dictionary handling.
       */
      if( !iNumTbl ) {
         printf("%d: Expected penalty table header, pan1ptbl aborted.\n",
               s_iLnPos);
         return( FALSE );
      }
      /* Verify count of tables: there should be exactly 9 without
       * an A-to-B remapping array.
       */
      if( bUseAtoB ) {
         if( bBuildIt ) {
            if( iNumTbl != (int )pAtoB->unNumAtoB) {
               printf("%d: Second-pass: Error in AtoB count.\n", s_iLnPos);
               return( FALSE );
            }
         } else if( iNumTbl > (NUM_PAN_DIGITS - 1 )) {
            printf("%d: Cannot have more that %u tables, pan1ptbl aborted.\n",
                  s_iLnPos,( int )(NUM_PAN_DIGITS - 1));
            return( FALSE );
         } else {
            /* Save the count of tables here for second pass.
             */
            pInd->unOffsAtoB = iNumTbl;
         }
      } else if( iNumTbl != (NUM_PAN_DIGITS - 1 )) {
         printf("%d: Expected exactly %d tables, pan1ptbl aborted.\n",
               s_iLnPos,( int )(NUM_PAN_DIGITS - 1));
         return( FALSE );
      }
      /* Bump count of dictionaries, as we successfully read one.
       */
      if( !bBuildIt ) {
         ++pHead->unNumDicts;
         s_unOffs += sizeof(EW_PIND_MEM);
      }
      ++pInd;
   }
   if( !pHead->unNumDicts ) {
      printf("No penalty dictionaries found, pan1ptbl aborted.\n");
      return( FALSE );
   }
   if( bBuildIt ) {
      pHead->unSizeDB = s_unOffs;
   }
   return( TRUE );
}

/***************************************************************************
 * FUNCTION: bReadPTbl
 *
 * PURPOSE:  Read, validate, and compress a table.
 *
 * RETURNS:  The function returns TRUE if it succesfully processes the
 *           table, FALSE if it does not.
 ***************************************************************************/
static EW_BOOL bReadPTbl(
   FILE *fpin,
   EW_BOOL bBuildIt,
   EW_BOOL bExpectSquare,
   char *pLnBuf,
   int iBufSize,
   EW_PTBL_MEM *pPTbl,
   EW_BYTE *pDataBuf)
{
   int i;
   int j;
   int k;
   int iNoFit;
   int iCol;
   int iRow;

   *pDataBuf = 0;

   /* Read in the data table.
    *
    * First line is the column headings.
    */
   if( !(iCol = iReadData(fpin, pLnBuf, iBufSize, &pDataBuf[1] ))) {
      printf("%d: Expected table data, pan1ptbl aborted.\n", s_iLnPos);
      return( FALSE );
   }
   ++iCol;

   /* Read the remaining rows, watching for the same number of columns.
    */
   for (iRow = 1; (i = iReadData(fpin, pLnBuf, iBufSize,
         &pDataBuf[iRow * iCol]));
         ++iRow) {
      if( i != iCol ) {
         printf("%d: Inconsistent number of columns, pan1ptbl aborted.\n",
               s_iLnPos);
         return( FALSE );
      }
   }
   /* Test for table too small.
    */
   if( (iRow < 5 ) ||( iCol < 5 )) {
      printf("%d: The table is too small, pan1ptbl aborted.\n", s_iLnPos);
      return( FALSE );
   }
   /* Look for a square table.
    */
   if( bExpectSquare && (iRow != iCol )) {
      printf("%d: Expected a square table( #row = #col ), pan1ptbl aborted.\n",
            s_iLnPos);
      return( FALSE );
   }
   /* Test 'any' penalties. They should all equal zero.
    */
   for (i = 1, j = iCol;
        ( i < j ) &&( (i == 2 ) ||( pDataBuf[iCol + i] == 0 ));
         ++i)
      ;
   if( i >= j ) {
      for (i = 1, j = iRow;
           ( i < j ) &&( (i == 2 ) ||( pDataBuf[(iCol * i ) + 1] == 0));
            ++i)
         ;
   }
   if( i < j ) {
      printf("%d: All 'any' penalties should be zero, pan1ptbl aborted.\n",
            s_iLnPos);
      return( FALSE );
   }
   /* Test 'no-fit' penalties. They should all have the same value.
    */
   iNoFit = pDataBuf[iCol + 2];
   for (i = 1, j = iCol;
        ( i < j ) &&( pDataBuf[(iCol * 2 ) + i] ==( EW_BYTE )iNoFit);
         ++i)
      ;
   if( i >= j ) {
      for (i = 1, j = iRow;
           ( i < j ) &&( pDataBuf[(iCol * i ) + 2] ==( EW_BYTE )iNoFit);
            ++i)
         ;
   }
   if( i < j ) {
      printf("%d: All 'no-fit' penalties should match, pan1ptbl aborted.\n",
            s_iLnPos);
      return( FALSE );
   }
   /* If we're just scanning, then we're done collecting info.
    */
   if( !bBuildIt || !pPTbl ) {
      return( TRUE );
   }
   /* Init table.
    */
   pPTbl->jRangeLast =( (iRow > iCol ) ? iRow : iCol) - 2;
   pPTbl->unOffsTbl = 0;
   pPTbl->unTblSize = 0;
   k = 0;

   /* Determine the compression type, and then copy the table
    * based upon the type.
    */
   switch (pPTbl->jCompress =
        ( EW_BYTE )iGetCompressKind(pDataBuf, iRow, iCol, iNoFit)) {

      case PAN_COMPRESS_C0:
         /* C0 compression: suck in the whole table except
          * the any and no-fit values. This table is preceded
          * by a header containing the row and column dimensions.
          */
         {
            EW_PTBL_C0_MEM *pPC0 =( EW_PTBL_C0_MEM * )&pDataBuf[k];
            pPC0->jARangeLast =( EW_BYTE )iRow - 2;
            pPC0->jBRangeLast =( EW_BYTE )iCol - 2;
            pPC0->jReserved = 0;
            k +=( sizeof(EW_PTBL_C0_MEM ) - sizeof(EW_BYTE));
         }
         for( i = 3; i < iRow; ++i ) {
            for( j = 3; j < iCol; ++j, ++k ) {
               pDataBuf[k] = pDataBuf[(i * iCol) + j];
            }
         }
         bAddUniqueTable(pPTbl, k);
         break;

      case PAN_COMPRESS_C1:
         /* C1 compression: perfectly symmetrical table with
          * penalties increasing the further they are away
          * from the diagonal. No additional data stored.
          */
         break;

      case PAN_COMPRESS_C3:
         /* C3 compression: same as C2 compression except the
          * first byte is the no-fit penalty.
          */
         pDataBuf[k++] = iNoFit;

      case PAN_COMPRESS_C2:
         /* C2 compression: symmetrical about the diagonal,
          * suck in the lower left corner.
          */
         for( i = 4; i < iRow; ++i ) {
            for( j = 3; j < i; ++j, ++k ) {
               pDataBuf[k] = pDataBuf[(i * iCol) + j];
            }
         }
         bAddUniqueTable(pPTbl, k);
         break;

      case PAN_COMPRESS_C4:
         /* C4 compression: similar to C1, except the start
          * and increment values are specified.
          */
         {
            EW_PTBL_C4_MEM *pPC4 =( EW_PTBL_C4_MEM * )&pDataBuf[k];
            pPC4->jStart = pDataBuf[(iCol * 4) + 3];
            pPC4->jIncrement = pDataBuf[(iCol * 5) + 3] - pPC4->jStart;
            k += sizeof(EW_PTBL_C4_MEM);
         }
         bAddUniqueTable(pPTbl, k);
         break;
   }
   return( TRUE );
}

/***************************************************************************
 * FUNCTION: iGetCompressKind
 *
 * PURPOSE:  Examine the data table and determine what kind, if any, of
 *           data compression can be used.
 *
 *           Notice the tables have an extra row and column for the
 *           headings. The minimum table size should be 5 x 5, which
 *           is really a 4 x 4 table (the parse loop catches anything
 *           smaller and aborts).
 *
 * RETURNS:  The function returns the compression id.
 ***************************************************************************/
static int iGetCompressKind(
   EW_BYTE *pDataBuf,
   int iRow,
   int iCol,
   int iNoFit)
{
   int i;
   int j;

   /* All compression mechanisms require a square table.
    */
   if( (iRow != iCol ) ||( iCol < 5 )) {
      return( PAN_COMPRESS_C0 );
   }
   /* Test for symmetry around the diagonal.
    */
   for( i = 3; i < iCol; ++i ) {
      /* The diagonal( exact match value ) must be zero.
       */
      if( pDataBuf[(iCol * i ) + i] != 0) {
         return( PAN_COMPRESS_C0 );
      }
      /* Test for value at( i,j ) ==( j,i ).
       */
      for( j = i + 1; (j < iCol ); ++j) {
         if( pDataBuf[(iCol * i ) + j] != pDataBuf[(iCol * j) + i]) {
            return( PAN_COMPRESS_C0 );
         }
      }
   }
   /* The table is symmetrical, now walk it looking for a special
    * pattern: it starts at a given value and increments by a given
    * value. If we find this, then we just store the start and
    * increment values.
    *
    * The table must be atleast 4 x 4 to try this test. Note if
    * it is exactly 4 x 4 and the one value in the table is a 1,
    * then C1 is the most compact way to store it (the 'else'
    * statement below checks for that). Otherwise C2 or C3 is
    * the best.
    */
   if( (iCol > 5 ) &&( iNoFit == 10 )) {
      EW_BOOL bFits = TRUE;
      EW_BYTE jStart = pDataBuf[(iCol * 4) + 3];
      EW_BYTE jInc = pDataBuf[(iCol * 5) + 3] - jStart;

      for( i = 5; (i < iCol ) && bFits; ++i) {
         for( j = 3; (j < i ) && bFits; ++j) {
            bFits =( pDataBuf[(iCol * i ) + j] ==
              ( EW_BYTE )(((EW_BYTE)(i - j - 1) * jInc) + jStart));
         }
      }
      /* C1 compression implies( start, inc ) ==( 1, 1 ),
       * C4 stores the start and inc values.
       */
      if( bFits ) {
         return( ((jStart == 1 ) &&( jInc == 1 )) ?
               PAN_COMPRESS_C1 : PAN_COMPRESS_C4);
      }
   } else if( (pDataBuf[(iCol * 4 ) + 3] == 1) &&( iNoFit == 10 )) {
      return( PAN_COMPRESS_C1 );
   }
   /* The table is symmetrical about the diagonal, but there
    * is no recognized pattern within it, so return C2 or C3
    * compression (C3 is C2 compression with a specifier for
    * the 'no-fit' value).
    */
   return( (iNoFit == 10 ) ? PAN_COMPRESS_C2 : PAN_COMPRESS_C3);
}

/***************************************************************************
 * FUNCTION: bAddUniqueTable
 *
 * PURPOSE:  Add a unique table to the accumulated penalty database, if
 *           a table matching this table's data already exists, then re-use
 *           that data.
 *
 *           Upon entry to this routine, s_unOffs should point to the
 *           data that is about to be added. This func walks all the
 *           tables that have already been added looking for duplicate
 *           data.
 *
 *           This function should be called when we're building the
 *           database( second pass ).
 *
 * RETURNS:  The function returns TRUE if a new table was added, or FALSE
 *           if an existing table was re-used.
 ***************************************************************************/
static EW_BOOL bAddUniqueTable(
   EW_PTBL_MEM *pPTbl,
   int iSize)
{
   int i;
   int j;
   int iNumTbl;
   EW_PDICT_MEM *pHead =( EW_PDICT_MEM * )s_buf;
   EW_PIND_MEM *pInd = pHead->pind;
   EW_PTBL_MEM *pPTblTst;

   /* Shortcut for C1 compression: it has no data.
    */
   if( !iSize ) {
      return( FALSE );
   }
   /* This walk is kind of tricky: we are walking a penalty
    * database that is in the process of being created. Some
    * fields are valid, some are not.
    *
    * For each dictionary.
    */
   for( i = 0; i < (int )pHead->unNumDicts; ++i, ++pInd) {

      /* If the ptbl offset is NULL, then we've reached the
       * end of the filled-in dictionaries.
       */
      if( !pInd->unOffsPTbl ) {
         break;
      }
      /* Get the count of tables.
       */
      if( pInd->unOffsAtoB ) {
         iNumTbl =( int )((EW_ATOB_MEM *)&s_buf[pInd->unOffsAtoB])->unNumAtoB;
      } else {
         iNumTbl = NUM_PAN_DIGITS - 1;
      }
      /* For each penalty table.
       */
      for( j = 0, pPTblTst = (EW_PTBL_MEM * )&s_buf[pInd->unOffsPTbl];
            j < iNumTbl;
            ++j, ++pPTblTst) {

         /* The last filled-in table should be the one that
          * was passed in.
          */
         if( (pPTblTst >= pPTbl ) || !pPTblTst->jRangeLast) {
            break;
         }
         /* Look for matching data, and return if it is found.
          */
         if( (pPTblTst->unOffsTbl > 0 ) &&
              ( pPTbl->jCompress == pPTblTst->jCompress ) &&
              ( iSize == (int )pPTblTst->unTblSize) &&
               (memcmp(&s_buf[s_unOffs],
               &s_buf[pPTblTst->unOffsTbl], iSize) == 0)) {
            pPTbl->unTblSize = iSize;
            pPTbl->unOffsTbl = pPTblTst->unOffsTbl;
            return( FALSE );
         }
      }
   }
   /* No duplicate was found, keep the structure that is currently
    * in the buffer.
    */
   pPTbl->unOffsTbl = s_unOffs;
   s_unOffs += pPTbl->unTblSize = iSize;

   return( TRUE );
}

/***************************************************************************
 * FUNCTION: iReadData
 *
 * PURPOSE:  Read an array of numbers from file.
 *
 * RETURNS:  The function returns the count of numbers it read from the
 *           line.
 ***************************************************************************/
static int iReadData(
   FILE *fpin,
   char *pLnBuf,
   int iBufSize,
   EW_BYTE *pDataBuf)
{
   int i;
   int j = 0;

   /* Get the test line.
    */
   if( !bGetLine(pLnBuf, iBufSize, fpin )) {
      return( 0 );
   }
   /* For each number.
    */
   while( TRUE ) {

      /* Walk white space.
       */
      for( ; *pLnBuf && ((*pLnBuf == ' ' ) ||( *pLnBuf == '\t' )); ++pLnBuf)
         ;
      /* Stop if not at a number.
       */
      if( !*pLnBuf || (*pLnBuf < '0' ) ||( *pLnBuf > '9' )) {
         break;
      }
      /* Read the number.
       */
      for( i = 0; *pLnBuf && (*pLnBuf >= '0' ) &&( *pLnBuf <= '9' );
            ++pLnBuf) {
         i =( i * 10 ) +( *pLnBuf - '0' );
      }
      *pDataBuf++ = i;
      ++j;
   }
   /* Sanity check. At this point the buffer should be empty,
    * the end of the line, or the start of a comment.
    */
   if( *pLnBuf && (*pLnBuf >= ' ' ) &&( *pLnBuf != ';' )) {
      return( 0 );
   }
   return( j );
}

/***************************************************************************
 * FUNCTION: bGetLine
 *
 * PURPOSE:  Read a line from file. Skip blank and comment lines.
 *
 * RETURNS:  The function returns TRUE if it finds a line, FALSE if it
 *           does not.
 ***************************************************************************/
static EW_BOOL bGetLine(
   char *pBuf,
   int iLen,
   FILE *fpin)
{
   int i;
   char ch;
   char *p;

#define M_EOL(ch)( ((ch ) == '\r') ||( (ch ) == '\n'))

   do {
      /* First read through end of line characters.
       */
      while( ((ch = fgetc(fpin )) != EOF) && M_EOL(ch)) {
         if( ch == '\n' ) {
            ++s_iLnPos;
         }
      }
      if( ch == EOF ) {
         return( FALSE );
      }
      /* Read the line.
       */
      for (i = 1, p = pBuf, *p++ = ch;
           ( i < iLen ) &&( (*p = fgetc(fpin )) != EOF) && !M_EOL(*p);
            ++i, ++p)
         ;
      *p = '\0';

      /* Bump the line counter.
       */
      ++s_iLnPos;

      /* Skip this line if it begins with a comment character.
       */
   } while( pBuf[0] == ';' );

   return( TRUE );
}

/***************************************************************************
 * FUNCTION: vShowDB
 *
 * PURPOSE:  Dump the database to stdout.
 *
 * RETURNS:  Nothing.
 ***************************************************************************/
static void vShowDB()
{
   int i;
   int j;
   int k;
   int m;
   int n;
   int iNumPTbl;
   EW_PDICT_MEM *pHead =( EW_PDICT_MEM * )s_buf;
   EW_PIND_MEM *pInd = pHead->pind;
   EW_BYTE *pWt;
   EW_ATOB_MEM *pAtoB;
   EW_ATOB_ITEM_MEM *pAtoBItem;
   EW_PTBL_MEM *pPTbl;
   EW_BYTE *pData;

   printf("\n\nDATABASE DUMP\n");
   printf("~~~~~~~~~~~~~\n");
   printf("vers      = 0x%04x\n", pHead->unVersion);
   printf("num dicts = %u\n", pHead->unNumDicts);
   printf("size db   = %u\n", pHead->unSizeDB);

   for( i = 0; i < (int )pHead->unNumDicts; ++i, ++pInd) {
      printf("\n=======================================================\n");
      printf("0x%04x:Index entry:\n",
        ( (unsigned )(char *)pInd -( unsigned )(char *)pHead));
      printf("family row = %u\n",( EW_USHORT )pInd->jFamilyA);
      printf("family col = %u\n",( EW_USHORT )pInd->jFamilyB);
      printf("any        = %u\n",( EW_USHORT )pInd->jDefAnyPenalty);
      printf("no-fit     = %u\n",( EW_USHORT )pInd->jDefNoFitPenalty);
      printf("match      = %u\n",( EW_USHORT )pInd->jDefMatchPenalty);
      printf("reserved   = %u\n",( EW_USHORT )pInd->jReserved);
      printf("offs wt    = 0x%04x\n", pInd->unOffsWts);
      printf("offs atob  = 0x%04x\n", pInd->unOffsAtoB);
      printf("offs ptbl  = 0x%04x\n", pInd->unOffsPTbl);

      if( pInd->unOffsWts ) {
         pWt =( EW_BYTE * )&s_buf[pInd->unOffsWts];
         printf("\n0x%04x:weights:", pInd->unOffsWts);
         for( j = 0; j < NUM_PAN_DIGITS; ++j, ++pWt ) {
            printf(" %u",( EW_USHORT )*pWt);
         }
         printf("\n");
      } else {
         printf("\nERROR: NO WEIGHTS\n");
      }

      if( pInd->unOffsAtoB ) {
         pAtoB =( EW_ATOB_MEM * )&s_buf[pInd->unOffsAtoB];
         pAtoBItem = pAtoB->AtoBItem;
         printf("\n0x%04x:AtoB:\n", pInd->unOffsAtoB);
         printf("count = %u\n", pAtoB->unNumAtoB);
         for( j = 0; j < (int )pAtoB->unNumAtoB; ++j, ++pAtoBItem) {
            printf("pair  = %u, %u\n",( EW_USHORT )pAtoBItem->jAttrA,
              ( EW_USHORT )pAtoBItem->jAttrB);
         }
         iNumPTbl = pAtoB->unNumAtoB;
      } else {
         iNumPTbl = NUM_PAN_DIGITS - 1;
      }

      if( pInd->unOffsPTbl && (iNumPTbl > 0 )) {
         pPTbl =( EW_PTBL_MEM * )&s_buf[pInd->unOffsPTbl];

         for( j = 0; j < iNumPTbl; ++j, ++pPTbl ) {
            printf("\n0x%04x:penalty table:\n",
              ( (unsigned )(char *)pPTbl -( unsigned )(char *)pHead));
            printf("rng last = %u\n",( EW_USHORT )pPTbl->jRangeLast);
            printf("compress = %u\n",( EW_USHORT )pPTbl->jCompress);
            printf("offs tbl = 0x%04x\n", pPTbl->unOffsTbl);
            printf("tbl size = %u\n", pPTbl->unTblSize);

            if( pPTbl->unOffsTbl && !bShowDupTbl(pPTbl )) {
               k = 0;
               pData =( EW_BYTE * )&s_buf[pPTbl->unOffsTbl];

               switch( pPTbl->jCompress ) {

                  case PAN_COMPRESS_C0:
                     {
                        EW_PTBL_C0_MEM *pPC0 =( EW_PTBL_C0_MEM * )&pData[k];
                        pData += k =( sizeof(EW_PTBL_C0_MEM ) - sizeof(EW_BYTE));
                        printf("Non-symmetrical table, row = %u, col = %u, reserved = %u\n",
                          ( EW_USHORT )pPC0->jARangeLast,
                          ( EW_USHORT )pPC0->jBRangeLast,
                          ( EW_USHORT )pPC0->jReserved);
                        printf("  ");
                        for( m = 0; m <= (int )pPC0->jBRangeLast; ++m) {
                           printf(" %2u", m);
                        }
                        printf("\n");
                        for( m = 0; m <= (int )pPC0->jARangeLast; ++m) {
                           printf("%2u", m);
                           if( m > 1 ) {
                              printf("      ");
                              for( n = 2; (n <= (int )pPC0->jBRangeLast) &&
                                   ( k < (int )pPTbl->unTblSize);
                                    ++n, ++k, ++pData) {
                                 printf(" %2u",( EW_USHORT )*pData);
                              }
                           }
                           printf("\n");
                        }
                     }
                     break;

                  case PAN_COMPRESS_C1:
                     printf("ERROR: TABLE SHOULD BE EMPTY\n");
                     break;

                  case PAN_COMPRESS_C3:
                     printf("no-fit value = %u\n",( EW_USHORT )*pData);
                     ++pData, ++k;

                  case PAN_COMPRESS_C2:
                     printf("  ");
                     for( m = 0; m <= (int )pPTbl->jRangeLast; ++m) {
                        printf(" %2u", m);
                     }
                     printf("\n");
                     for( m = 0; m <= (int )pPTbl->jRangeLast; ++m) {
                        printf("%2u", m);
                        if( m > 2 ) {
                           printf("      ");
                           for( n = 2; (n < m ) &&( k < (int )pPTbl->unTblSize);
                                 ++n, ++k, ++pData) {
                              printf(" %2u",( EW_USHORT )*pData);
                           }
                        }
                        printf("\n");
                     }
                     break;

                  case PAN_COMPRESS_C4:
                     {
                        EW_PTBL_C4_MEM *pPC4 =( EW_PTBL_C4_MEM * )&pData[k];
                        pData += k = sizeof(EW_PTBL_C4_MEM);
                        printf("start = %u, increment = %u\n",
                          ( EW_USHORT )pPC4->jStart,
                          ( EW_USHORT )pPC4->jIncrement);
                     }
                     break;

                  default:
                     printf("ERROR: INVALID COMPRESSION TYPE\n");
                     break;
               }
            } else if (!pPTbl->unOffsTbl &&
                 ( pPTbl->jCompress != PAN_COMPRESS_C1 )) {
               printf("ERROR: NO DATA\n");
            }
         }
      } else {
         printf("\nERROR: NO PENALTIES\n");
      }
   }
   printf("\n=======================================================\n");
   printf("Raw data dump:\n");
   pData =( EW_BYTE * )s_buf;
   printf("        00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\n");
   for( k = 0; k < (int )pHead->unSizeDB; ) {
      printf("0x%04x:", k);
      for( i = 0; (i < 16 ) &&( k < (int )pHead->unSizeDB);
            ++i, ++k, ++pData) {
         printf(" %02x",( EW_USHORT )*pData);
      }
      printf("\n");
   }
}

/***************************************************************************
 * FUNCTION: bShowDupTbl
 *
 * PURPOSE:  Search for a duplicate table and don't show it twice, instead
 *           indicate it is a duplicate table.
 *
 * RETURNS:  The function returns TRUE if this is, indeed, a duplicate
 *           table, or FALSE if it is not.
 ***************************************************************************/
static EW_BOOL bShowDupTbl(
   EW_PTBL_MEM *pPTbl)
{
   int i;
   int j;
   int iNumTbl;
   EW_PDICT_MEM *pHead =( EW_PDICT_MEM * )s_buf;
   EW_PIND_MEM *pInd = pHead->pind;
   EW_PTBL_MEM *pPTblTst;

   /* Quick test for C1 compression.
    */
   if( !pPTbl->unTblSize || !pPTbl->unOffsTbl ) {
      return( FALSE );
   }
   /* For each dictionary.
    */
   for( i = 0; i < (int )pHead->unNumDicts; ++i, ++pInd) {

      /* Get the count of tables.
       */
      if( pInd->unOffsAtoB ) {
         iNumTbl =( int )((EW_ATOB_MEM *)&s_buf[pInd->unOffsAtoB])->unNumAtoB;
      } else {
         iNumTbl = NUM_PAN_DIGITS - 1;
      }
      /* For each penalty table.
       */
      for( j = 0, pPTblTst = (EW_PTBL_MEM * )&s_buf[pInd->unOffsPTbl];
            j < iNumTbl;
            ++j, ++pPTblTst) {

         /* Walk up to the current table.
          */
         if( pPTblTst >= pPTbl ) {
            break;
         }
         /* Look for matching data, and return if it is found.
          */
         if( (pPTblTst->unOffsTbl > 0 ) &&
              ( pPTbl->jRangeLast == pPTblTst->jRangeLast ) &&
              ( pPTbl->jCompress == pPTblTst->jCompress ) &&
              ( pPTbl->unTblSize == pPTblTst->unTblSize ) &&
              ( pPTbl->unOffsTbl == pPTblTst->unOffsTbl )) {
            printf("The data has already dumped( duplicate table ).\n");
            return( TRUE );
         }
      }
   }
   /* No duplicate found.
    */
   return( FALSE );
}

/***************************************************************************
 * Revision log:
 ***************************************************************************/
/*
 * $lgb$
 * 1.0    31-Jan-93    msd PANOSE 1.0 penalties database, textual version.
 * 1.1    31-Jan-93    msd Modified the way a file is written if we know we're checking it in and out of vcs.
 * 1.2     1-Feb-93    msd Fixed a bug with the vcs handling stuff.
 * 1.3     3-Feb-93    msd Removed ctrl-z at EOF. Ifdef'd in Mac code to get this to build as an MPW tool. Ifdef'd out system calls on the Mac.
 * 1.4     3-Feb-93    msd Added generic line-read routine that can handle both mac- and pc-format test files.
 * 1.5     6-Feb-93    msd Init reserved bye in C0 penalty header.
 * 1.6    18-Feb-93    msd Implemented binary file writing, init penalty table byte-ordering variable, and C4 ptbl compression( new version of ptbl ). Identical tables are not repeated.
 * 1.7    26-Feb-93    msd Don't abort on weight values of zero( just warn ). Also repaired line counter.
 * 1.8     1-Apr-93    msd Added _cdecl keyword to main().
 * 1.9    15-Apr-94 jasons Removed cdecl on main for Mac.
 * $lge$
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\ole2map\panmap.h ===
/***************************************************************************
 * PANMAP.H - Base definitions for ElseWare PANOSE(tm) 1.0 Font Mapper.
 *            OLE 2.0 Implementation
 *
 *
 * Copyright (C) 1991-94 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __PANOLE2_H__
#define __PANOLE2_H__


/* A Global Unique Identifier and an Interface ID for the PANOSE mapper.
 */
DEFINE_GUID(CLSID_PANOSEMapper, 0xBD84B381L, 0x8CA2, 0x1069, 0xAB, 0x1D, 0x08,
        0x00, 0x09, 0x48, 0xF5, 0x34);
DEFINE_GUID(IID_IPANOSEMapper, 0xBD84B382L, 0x8CA2, 0x1069, 0xAB, 0x1D, 0x08,
        0x00, 0x09, 0x48, 0xF5, 0x34);




DECLARE_INTERFACE_( IPANOSEMapper, IUnknown)
{
   /* IUnknown 
    */
   STDMETHOD(QueryInterface) (THIS_
                           REFIID riid,
                           LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS) PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   /* The PANOSE Mapper interface.
    */
   STDMETHOD_(USHORT, unPANMatchFonts) ( THIS_
         LPBYTE lpPanWant,
         ULONG ulSizeWant, LPBYTE lpPanThis, ULONG ulSizeThis,
         BYTE jMapToFamily) PURE;


   STDMETHOD_(VOID, vPANMakeDummy)( THIS_
         LPBYTE lpPanThis, USHORT unSize ) PURE;

   STDMETHOD_(SHORT, nPANGetMapDefault)( THIS_
         LPBYTE lpPanDef,
         USHORT unSizePanDef ) PURE;

   STDMETHOD_(SHORT, nPANSetMapDefault) (THIS_
         LPBYTE lpPanDef,
         USHORT unSizePanDef ) PURE;

   STDMETHOD_(BOOL, bPANEnableMapDefault) (THIS_
         BOOL bEnable )  PURE;

   STDMETHOD_(BOOL, bPANIsDefaultEnabled) (THIS)  PURE;

   STDMETHOD_(USHORT, unPANPickFonts) (THIS_
         USHORT FAR *lpIndsBest,
         USHORT FAR *lpMatchValues, LPBYTE lpPanWant,
         USHORT unNumInds, LPBYTE lpPanFirst, USHORT unNumAvail,
         SHORT nRecSize, BYTE jMapToFamily ) PURE ;

   STDMETHOD_(USHORT, unPANGetMapThreshold) (THIS) PURE;

   STDMETHOD_(BOOL, bPANSetMapThreshold) (THIS_
         USHORT unThreshold ) PURE;

   STDMETHOD_(BOOL, bPANIsThresholdRelaxed) (THIS) PURE;

   STDMETHOD_(VOID, vPANRelaxThreshold) (THIS) PURE;

   STDMETHOD_(BOOL, bPANRestoreThreshold) (THIS) PURE;

   STDMETHOD_(BOOL, bPANGetMapWeights) (THIS_
         BYTE jFamilyA,
         BYTE jFamilyB, LPBYTE lpjWts, LPBOOL lpbIsCustom ) PURE;

   STDMETHOD_(BOOL, bPANSetMapWeights) (THIS_
         BYTE jFamilyA,
         BYTE jFamilyB, LPBYTE lpjWts ) PURE;

   STDMETHOD_(BOOL, bPANClearMapWeights) (THIS_
         BYTE jFamilyA,
         BYTE jFamilyB ) PURE;
};
typedef IPANOSEMapper FAR * LPPANOSEMAPPER;

#endif   // __PANOLE2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\ole2map\panmap.cpp ===
/***************************************************************************
 * PANMAP.CPP - Implementaion for ElseWare PANOSE(tm) 1.0 Font Mapper.
 *             OLE 2.0 Implementation
 *
 *
 * Copyright (C) 1991-94 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/
#define _INC_OLE
#define CONST_VTABLE
#include <windows.h>
#include <ole2.h>

// #pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <cguid.h>
#include "elsepan.h"
#include "panmap.h"
#undef INITGUID
// #pragma data_seg()


ULONG g_ulRefThisDll = 0;
ULONG g_ulLock = 0;         //
ULONG g_ulObjs = 0;         // Number of objects

typedef void (FAR PASCAL *LPFNDESTROYED)(void);

////////////////////////////////////////////////////////////////////////////
//
//  Overloaded allocation operators.
//
//  Needed by NT since we don't yet link to real C++ runtimes
//
////////////////////////////////////////////////////////////////////////////

static inline void * __cdecl operator new(
    size_t size)
{
    return ((void *)LocalAlloc(LPTR, size));
}

static inline void __cdecl operator delete(
    void *ptr)
{
    LocalFree(ptr);
}

extern "C" inline __cdecl _purecall(void)
{
    return (0);
}




/**********************************************************************
 */
class CPanoseMapper : public IPANOSEMapper {
public:
   CPanoseMapper(LPUNKNOWN pUnk);
   ~CPanoseMapper(void);


   BOOL  bInit(void);

   /* IUnknown
    */
   STDMETHODIMP         QueryInterface ( REFIID riid, LPVOID FAR* ppvObj);
   STDMETHODIMP_(ULONG) AddRef( void );
   STDMETHODIMP_(ULONG) Release( void ) ;

   /* The PANOSE Mapper interface.
    */
   STDMETHODIMP_(USHORT) unPANMatchFonts(
         LPBYTE lpPanWant,
         ULONG ulSizeWant, EW_LPBYTE lpPanThis, ULONG ulSizeThis,
         BYTE jMapToFamily);


   STDMETHODIMP_(EW_VOID) vPANMakeDummy(
         LPBYTE lpPanThis, USHORT unSize ) ;

   STDMETHODIMP_(SHORT) nPANGetMapDefault(
         LPBYTE lpPanDef,
         USHORT unSizePanDef ) ;

   STDMETHODIMP_(SHORT) nPANSetMapDefault(
         LPBYTE lpPanDef,
         USHORT unSizePanDef ) ;

   STDMETHODIMP_(BOOL) bPANEnableMapDefault (
         BOOL bEnable )  ;

   STDMETHODIMP_(BOOL) bPANIsDefaultEnabled(  )  ;

   STDMETHODIMP_(USHORT) unPANPickFonts (
         USHORT FAR *lpIndsBest,
         USHORT FAR *lpMatchValues, LPBYTE lpPanWant,
         USHORT unNumInds, LPBYTE lpPanFirst, USHORT unNumAvail,
         SHORT nRecSize, BYTE jMapToFamily )  ;

   STDMETHODIMP_(USHORT) unPANGetMapThreshold(  ) ;

   STDMETHODIMP_(BOOL) bPANSetMapThreshold (
         USHORT unThreshold ) ;

   STDMETHODIMP_(BOOL) bPANIsThresholdRelaxed(  ) ;

   STDMETHODIMP_(VOID) vPANRelaxThreshold(  ) ;

   STDMETHODIMP_(BOOL) bPANRestoreThreshold(  ) ;

   STDMETHODIMP_(BOOL) bPANGetMapWeights (
         BYTE jFamilyA,
         BYTE jFamilyB, LPBYTE lpjWts, LPBOOL lpbIsCustom ) ;

   STDMETHODIMP_(BOOL) bPANSetMapWeights (
         BYTE jFamilyA,
         BYTE jFamilyB, LPBYTE lpjWts ) ;

   STDMETHODIMP_(BOOL) bPANClearMapWeights (
         BYTE jFamilyA,
         BYTE jFamilyB ) ;


private:
   LPUNKNOWN      m_pUnkOuter;   //Controlling unknown
   EW_MAPSTATE    m_MapState;    // Used for Core Mapper.

};

/**********************************************************************
 */
class CWrapper : public IUnknown {
public:
   CWrapper(LPUNKNOWN pUnk, LPFNDESTROYED pfn);
   ~CWrapper(void);

   BOOL bInit(void);

   /* IUnknown
    */
   STDMETHODIMP         QueryInterface ( REFIID riid, LPVOID FAR* ppvObj);
   STDMETHODIMP_(ULONG) AddRef( void );
   STDMETHODIMP_(ULONG) Release( void ) ;

private:
   ULONG          m_ulRef;       //Object reference count
   LPUNKNOWN      m_pUnkOuter;   //Controlling unknown
   LPFNDESTROYED  m_pfnDestroy;  // Function to call when destroyed.

   CPanoseMapper * m_pPM;        // the actual PAN mapper.
};

/**********************************************************************
 */
class CImpIClassFactory : public IClassFactory
{
public:
   CImpIClassFactory()
      { m_ulRef = 0; g_ulRefThisDll++;}
   ~CImpIClassFactory() { g_ulRefThisDll--; }

   // *** IUnknown methods ***
   STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   // *** IClassFactory methods ***
   STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject);
   STDMETHODIMP LockServer(BOOL fLock);

private:
   int m_ulRef;
};


// ******************************************************************
// LibMain
// extern "C" BOOL APIENTRY DllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved)
STDAPI_(BOOL) DllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved)
{
   switch(dwReason)
   {
      case DLL_PROCESS_ATTACH:
         break;

      case DLL_PROCESS_DETACH:
         break;

      case DLL_THREAD_ATTACH:
         break;

      case DLL_THREAD_DETACH:
         break;

      default:
         break;

   } // switch

   return(TRUE);
}

// ******************************************************************
// DllCanUnloadNow
STDAPI DllCanUnloadNow()
{
   HRESULT retval;

   retval = ResultFromScode((g_ulRefThisDll == 0) &&( g_ulLock == 0 )
            &&( g_ulObjs = 0 )
            ? S_OK : S_FALSE);
   return(retval);
}

//*******************************************************************
// Object destruction notification proc.
void FAR PASCAL vObjectDestroyed(void)
{
   g_ulObjs--;
}

// ******************************************************************
// DllGetClassObject
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid,
        LPVOID FAR* ppvObj)
{
   if(!(rclsid == CLSID_PANOSEMapper))
      return(ResultFromScode(E_FAIL));

   if(!(riid == IID_IUnknown) && !(riid == IID_IClassFactory))
      return(ResultFromScode(E_NOINTERFACE));

   *ppvObj = (LPVOID) new CImpIClassFactory;

   if(!*ppvObj)
      return(ResultFromScode(E_OUTOFMEMORY));


  ( (LPUNKNOWN )*ppvObj)->AddRef();

   return NOERROR;
}


// ***********************************************************************
// ***********************************************************************
// CImpIClassFactory member functions

// *** IUnknown methods ***
STDMETHODIMP CImpIClassFactory::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
   *ppvObj = NULL;

   // Any interface on this object is the object pointer
   if((riid == IID_IUnknown) ||( riid == IID_IClassFactory ))
      *ppvObj =( LPVOID ) this;

   if(*ppvObj) {
     ( (LPUNKNOWN )*ppvObj)->AddRef();
      return NOERROR;
   }

   return(ResultFromScode(E_NOINTERFACE));
}


STDMETHODIMP_(ULONG) CImpIClassFactory::AddRef(void)
{
   return(++m_ulRef);
}


STDMETHODIMP_(ULONG) CImpIClassFactory::Release(void)
{
   ULONG retval;
   retval = --m_ulRef;
   if(!retval) delete this;
   return(retval);
}


// *** IClassFactory methods ***
STDMETHODIMP CImpIClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
        REFIID riid, LPVOID FAR* ppvObj)
{
   HRESULT retval;
   CWrapper * pPM;

   *ppvObj=NULL;
   retval = ResultFromScode(E_OUTOFMEMORY);

   // Verify that a controlling unknown asks for IUnknown
   //
   if( NULL != pUnkOuter && !(riid == IID_IUnknown))
      return( E_NOINTERFACE );

   pPM = new CWrapper(pUnkOuter, vObjectDestroyed);

   // Increment the object count if we were successful.
   //
   if(!pPM)
      return(retval);
   g_ulObjs++;

   // Initialize the Panose Mapper. It will destroy itself if initialization
   // fails.
   //
   if(pPM->bInit())
      retval = pPM->QueryInterface(riid, ppvObj);

   return(retval);
}


STDMETHODIMP CImpIClassFactory::LockServer(BOOL fLock)
{
   if(fLock)
      g_ulLock++;
   else
      g_ulLock--;
   return(NOERROR);
}

// ***********************************************************************
// ***********************************************************************
// CWrapper member functions
CWrapper::CWrapper( LPUNKNOWN pUnk, LPFNDESTROYED pfn )
   :  m_pUnkOuter(pUnk),
      m_pfnDestroy(pfn),
      m_ulRef(0) ,
      m_pPM(0)
{

}

CWrapper::~CWrapper(void)
{
   // Clean up the mapper.
   //
   if( m_pPM )
      delete m_pPM;

   // Notify of destruction.
   //
   if( NULL != m_pfnDestroy )
     ( *m_pfnDestroy )();
}


BOOL  CWrapper::bInit(void)
{
   BOOL bRet = FALSE;
   LPUNKNOWN   pUnk = this;

   if( m_pUnkOuter )
      pUnk = m_pUnkOuter;

   m_pPM = new CPanoseMapper(pUnk);

   if(m_pPM) {
      bRet = m_pPM->bInit();
      if(  !bRet  )
         m_pPM = NULL;
   }

   if( !bRet )
      delete this;

   return bRet;
}

STDMETHODIMP CWrapper::QueryInterface(  REFIID riid, LPVOID FAR* ppvObj )
{
   *ppvObj=NULL;

   /*
    * The only calls for IUnknown are either in a nonaggregated
    * case or when created in an aggregation, so in either case
    * always return our IUnknown for IID_IUnknown.
    */
   if( riid == IID_IUnknown )
      *ppvObj=(LPVOID)this;

   /*
    * Return
    */
   if( riid == IID_IPANOSEMapper )
      *ppvObj=(LPVOID)m_pPM;

   //AddRef any interface we'll return.
   if( NULL!=*ppvObj )  {
     ( (LPUNKNOWN )*ppvObj)->AddRef();
      return NOERROR;
   }

   return ResultFromScode(E_NOINTERFACE);

}

STDMETHODIMP_(ULONG) CWrapper::AddRef( void )
{
   m_ulRef++;

    return m_ulRef;
}

STDMETHODIMP_(ULONG) CWrapper::Release( void )
{
   ULONG ulRet = --m_ulRef;
   if(( ULONG )0 == ulRet )
      delete this;

   return ulRet;
}

// ***********************************************************************
// ***********************************************************************
// CPanoseMapper member functions

CPanoseMapper::CPanoseMapper( LPUNKNOWN pUnk )
   :  m_pUnkOuter(pUnk)
{

}

CPanoseMapper::~CPanoseMapper(void)
{
   // Clean up the mapper.
   //
   ::bPANMapClose( &m_MapState );

}


BOOL  CPanoseMapper::bInit(void)
{
   // Initialize the MapState struct
   //
   BOOL bOK =( ::nPANMapInit(&m_MapState, sizeof(m_MapState )) > 0);

   // If init fails, then this is not valid. Delete it.
   //
   if( ! bOK )
      delete this;

   return bOK;
}


/* IUnknown
   */
STDMETHODIMP CPanoseMapper::QueryInterface(  REFIID riid, LPVOID FAR* ppvObj )
{
   return m_pUnkOuter->QueryInterface(riid, ppvObj);

}

STDMETHODIMP_(ULONG) CPanoseMapper::AddRef( void )
{
   return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CPanoseMapper::Release( void )
{
   return m_pUnkOuter->Release();
}

/* The PANOSE Mapper interface.
   */
STDMETHODIMP_(USHORT) CPanoseMapper::unPANMatchFonts(
      LPBYTE lpPanWant,
      ULONG ulSizeWant, LPBYTE lpPanThis, ULONG ulSizeThis,
      BYTE jMapToFamily)
{
   return ::unPANMatchFonts(
         &m_MapState,
         lpPanWant,
         ulSizeWant,
         lpPanThis,
         ulSizeThis,
         jMapToFamily);
}


STDMETHODIMP_(VOID) CPanoseMapper::vPANMakeDummy(
      LPBYTE lpPanThis, USHORT unSize )
{
   ::vPANMakeDummy( lpPanThis, unSize );
}

STDMETHODIMP_(SHORT) CPanoseMapper::nPANGetMapDefault(
      LPBYTE lpPanDef,
      USHORT unSizePanDef )
{
   return ::nPANGetMapDefault( &m_MapState, lpPanDef, unSizePanDef );
}


STDMETHODIMP_(SHORT) CPanoseMapper::nPANSetMapDefault(
      LPBYTE lpPanDef,
      USHORT unSizePanDef )
{
   return ::nPANSetMapDefault( &m_MapState, lpPanDef, unSizePanDef );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANEnableMapDefault (
      BOOL bEnable )
{
   return ::bPANEnableMapDefault( &m_MapState, (EW_BOOL)bEnable  );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANIsDefaultEnabled(  )
{
   return ::bPANIsDefaultEnabled(  &m_MapState  );
}


STDMETHODIMP_(USHORT) CPanoseMapper::unPANPickFonts (
      USHORT FAR * lpIndsBest,
      USHORT FAR * lpMatchValues, LPBYTE lpPanWant,
      USHORT unNumInds, LPBYTE lpPanFirst, USHORT unNumAvail,
      SHORT nRecSize, BYTE jMapToFamily )
{
   return ::unPANPickFonts (
         &m_MapState,
         lpIndsBest,
         lpMatchValues,
         lpPanWant,
         unNumInds,
         lpPanFirst,
         unNumAvail,
         nRecSize,
         jMapToFamily );
}


STDMETHODIMP_(USHORT) CPanoseMapper::unPANGetMapThreshold(  )
{
   return ::unPANGetMapThreshold( &m_MapState  );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANSetMapThreshold (
      USHORT unThreshold )
{
   return ::bPANSetMapThreshold( &m_MapState, unThreshold  );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANIsThresholdRelaxed(  )
{
   return ::bPANIsThresholdRelaxed( &m_MapState  );
}


STDMETHODIMP_(VOID) CPanoseMapper::vPANRelaxThreshold(  )
{
   ::vPANRelaxThreshold( &m_MapState  );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANRestoreThreshold(  )
{
   return ::bPANRestoreThreshold( &m_MapState  );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANGetMapWeights (
      BYTE jFamilyA,
      BYTE jFamilyB, LPBYTE lpjWts, LPBOOL lpbIsCustom )
{
   *lpbIsCustom =( BOOL )0;
   return ::bPANGetMapWeights (&m_MapState, jFamilyA,
               jFamilyB, lpjWts,( EW_LPBOOL )lpbIsCustom );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANSetMapWeights (
      BYTE jFamilyA,
      BYTE jFamilyB, LPBYTE lpjWts )
{
   return ::bPANSetMapWeights (
      &m_MapState, jFamilyA,
      jFamilyB, lpjWts );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANClearMapWeights (
      BYTE jFamilyA,
      BYTE jFamilyB )
{
   return ::bPANClearMapWeights( &m_MapState, jFamilyA, jFamilyB  );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\fontfldr\ole2map\pan1ptbl.h ===
/***************************************************************************
 * PAN1PTBL.H - ElseWare PANOSE(tm) default penalty tables.
 *
 * This file was generated by PAN1PTBL.EXE.
 *
 * This file contains the penalty tables for the PANOSE 1.0 font
 * mapper. It was generated from the file PAN1PTBL.TXT.
 *
 * Penalty database structure version 1.11.
 *
 * File created Mon Sep 26 10:13:46 1994.
 *
 * Copyright (C) 1992-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __PAN1PTBL_H__
#define __PAN1PTBL_H__

/***************************************************************************
 * PENALTY DATABASE
 *
 * Below is the default penalty database for the PANOSE font
 * mapper.  It is in the MEMORY format.
 *
 * Look at PAN1PTBL.C to see how this is created.
 ***************************************************************************/
EW_BYTE s_panDB[] = {
   0x11, 0x01, 0x34, 0x12, 0x06, 0x00, 0x46, 0x09, 0x02, 0x02,
   0x00, 0x0a, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x5a, 0x00,
   0x06, 0x06, 0x00, 0x0a, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00,
   0x33, 0x02, 0x06, 0x02, 0x00, 0x0a, 0x00, 0x00, 0x27, 0x03,
   0x31, 0x03, 0x41, 0x03, 0x03, 0x03, 0x00, 0x0a, 0x00, 0x00,
   0x70, 0x05, 0x00, 0x00, 0x7a, 0x05, 0x04, 0x04, 0x00, 0x0a,
   0x00, 0x00, 0xc8, 0x06, 0x00, 0x00, 0xd2, 0x06, 0x05, 0x05,
   0x00, 0x0a, 0x00, 0x00, 0x8b, 0x08, 0x00, 0x00, 0x95, 0x08,
   0x00, 0x07, 0x08, 0x09, 0x05, 0x02, 0x02, 0x06, 0x02, 0x01,
   0x0f, 0x02, 0x90, 0x00, 0x5b, 0x00, 0x0b, 0x02, 0xeb, 0x00,
   0x2d, 0x00, 0x09, 0x02, 0x18, 0x01, 0x1c, 0x00, 0x09, 0x01,
   0x00, 0x00, 0x00, 0x00, 0x09, 0x02, 0x34, 0x01, 0x1c, 0x00,
   0x0b, 0x02, 0x50, 0x01, 0x2d, 0x00, 0x0f, 0x02, 0x7d, 0x01,
   0x5b, 0x00, 0x0d, 0x02, 0xd8, 0x01, 0x42, 0x00, 0x07, 0x02,
   0x1a, 0x02, 0x0f, 0x00, 0x01, 0x03, 0x04, 0x04, 0x03, 0x01,
   0x06, 0x06, 0x02, 0x03, 0x05, 0x05, 0x03, 0x03, 0x02, 0x07,
   0x07, 0x05, 0x05, 0x06, 0x06, 0x07, 0x07, 0x06, 0x06, 0x07,
   0x08, 0x02, 0x03, 0x03, 0x05, 0x05, 0x06, 0x05, 0x05, 0x04,
   0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 0x09, 0x09,
   0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 0x09, 0x01, 0x09,
   0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 0x09, 0x02, 0x01,
   0x06, 0x06, 0x07, 0x07, 0x08, 0x07, 0x09, 0x09, 0x06, 0x04,
   0x04, 0x05, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
   0x0a, 0x07, 0x07, 0x07, 0x08, 0x01, 0x02, 0x01, 0x03, 0x02,
   0x01, 0x04, 0x03, 0x02, 0x01, 0x06, 0x05, 0x04, 0x03, 0x02,
   0x07, 0x06, 0x05, 0x04, 0x03, 0x01, 0x08, 0x07, 0x06, 0x05,
   0x04, 0x02, 0x01, 0x09, 0x08, 0x07, 0x06, 0x05, 0x03, 0x02,
   0x01, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x02, 0x01,
   0x02, 0x03, 0x02, 0x06, 0x06, 0x04, 0x05, 0x05, 0x05, 0x08,
   0x08, 0x08, 0x07, 0x03, 0x08, 0x07, 0x07, 0x08, 0x0a, 0x03,
   0x0c, 0x0c, 0x0c, 0x0a, 0x0c, 0x0a, 0x0c, 0x0c, 0x03, 0x04,
   0x02, 0x05, 0x03, 0x01, 0x08, 0x09, 0x09, 0x09, 0x07, 0x04,
   0x04, 0x03, 0x07, 0x08, 0x09, 0x09, 0x09, 0x02, 0x08, 0x09,
   0x08, 0x06, 0x06, 0x08, 0x06, 0x0a, 0x02, 0x04, 0x02, 0x06,
   0x06, 0x06, 0x06, 0x06, 0x06, 0x02, 0x07, 0x08, 0x08, 0x08,
   0x08, 0x08, 0x07, 0x08, 0x08, 0x08, 0x02, 0x08, 0x08, 0x07,
   0x08, 0x08, 0x04, 0x02, 0x09, 0x09, 0x09, 0x05, 0x06, 0x08,
   0x08, 0x08, 0x09, 0x09, 0x09, 0x06, 0x05, 0x08, 0x08, 0x08,
   0x03, 0x02, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03, 0x03, 0x03,
   0x02, 0x05, 0x05, 0x05, 0x06, 0x07, 0x06, 0x06, 0x04, 0x04,
   0x04, 0x06, 0x08, 0x0a, 0x0a, 0x0b, 0x0c, 0x0c, 0x0e, 0x0a,
   0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0e, 0x02, 0x0a, 0x09, 0x08,
   0x09, 0x0a, 0x0b, 0x0d, 0x02, 0x02, 0x0b, 0x09, 0x09, 0x08,
   0x09, 0x0a, 0x0c, 0x03, 0x02, 0x02, 0x0b, 0x0a, 0x0a, 0x09,
   0x08, 0x09, 0x0c, 0x03, 0x03, 0x03, 0x02, 0x0d, 0x0c, 0x0c,
   0x0b, 0x0c, 0x08, 0x0c, 0x05, 0x05, 0x05, 0x06, 0x07, 0x0e,
   0x0e, 0x0c, 0x0a, 0x09, 0x0a, 0x08, 0x06, 0x06, 0x04, 0x04,
   0x04, 0x06, 0x02, 0x04, 0x04, 0x06, 0x05, 0x06, 0x06, 0x04,
   0x06, 0x02, 0x06, 0x06, 0x05, 0x04, 0x04, 0x05, 0x05, 0x05,
   0x03, 0x05, 0x06, 0x05, 0x05, 0x05, 0x04, 0x03, 0x07, 0x03,
   0x05, 0x05, 0x04, 0x05, 0x06, 0x05, 0x02, 0x04, 0x06, 0x07,
   0x07, 0x07, 0x08, 0x08, 0x04, 0x03, 0x03, 0x06, 0x06, 0x07,
   0x08, 0x07, 0x08, 0x06, 0x03, 0x04, 0x04, 0x06, 0x07, 0x06,
   0x08, 0x08, 0x07, 0x05, 0x05, 0x02, 0x03, 0x04, 0x02, 0x04,
   0x02, 0x08, 0x06, 0x0c, 0x0a, 0x08, 0x0a, 0x02, 0x0c, 0x0a,
   0x08, 0x04, 0x02, 0x00, 0x09, 0x08, 0x05, 0x07, 0x05, 0x04,
   0x04, 0x05, 0x04, 0x0c, 0x02, 0x69, 0x02, 0x37, 0x00, 0x0b,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x03, 0xa0, 0x02, 0x2e,
   0x00, 0x03, 0x02, 0xce, 0x02, 0x01, 0x00, 0x09, 0x01, 0x00,
   0x00, 0x00, 0x00, 0x0c, 0x02, 0xcf, 0x02, 0x37, 0x00, 0x09,
   0x03, 0x06, 0x03, 0x1d, 0x00, 0x06, 0x04, 0x23, 0x03, 0x02,
   0x00, 0x05, 0x04, 0x25, 0x03, 0x02, 0x00, 0x03, 0x04, 0x04,
   0x07, 0x07, 0x06, 0x08, 0x08, 0x08, 0x04, 0x08, 0x08, 0x08,
   0x05, 0x03, 0x06, 0x06, 0x06, 0x06, 0x05, 0x04, 0x05, 0x05,
   0x05, 0x03, 0x06, 0x05, 0x04, 0x02, 0x03, 0x04, 0x03, 0x08,
   0x07, 0x05, 0x04, 0x04, 0x02, 0x03, 0x04, 0x08, 0x07, 0x08,
   0x06, 0x03, 0x05, 0x04, 0x04, 0x05, 0x08, 0x07, 0x08, 0x08,
   0x05, 0x02, 0x14, 0x04, 0x01, 0x05, 0x05, 0x01, 0x04, 0x01,
   0x05, 0x02, 0x06, 0x05, 0x01, 0x06, 0x02, 0x04, 0x02, 0x06,
   0x01, 0x05, 0x03, 0x07, 0x06, 0x02, 0x05, 0x01, 0x07, 0x03,
   0x04, 0x02, 0x06, 0x03, 0x07, 0x01, 0x05, 0x04, 0x08, 0x06,
   0x02, 0x07, 0x03, 0x05, 0x01, 0x08, 0x04, 0x04, 0x08, 0x02,
   0x03, 0x01, 0x05, 0x04, 0x04, 0x08, 0x07, 0x06, 0x08, 0x08,
   0x07, 0x08, 0x07, 0x02, 0x08, 0x06, 0x07, 0x06, 0x04, 0x03,
   0x07, 0x06, 0x07, 0x04, 0x07, 0x06, 0x04, 0x04, 0x04, 0x04,
   0x06, 0x05, 0x06, 0x07, 0x08, 0x07, 0x07, 0x06, 0x03, 0x08,
   0x08, 0x06, 0x04, 0x07, 0x09, 0x09, 0x08, 0x06, 0x09, 0x09,
   0x08, 0x06, 0x08, 0x05, 0x14, 0x02, 0x04, 0x02, 0x06, 0x04,
   0x02, 0x03, 0x05, 0x07, 0x09, 0x05, 0x03, 0x05, 0x07, 0x02,
   0x07, 0x05, 0x03, 0x05, 0x04, 0x02, 0x09, 0x07, 0x05, 0x03,
   0x06, 0x04, 0x02, 0x02, 0x02, 0x03, 0x03, 0x00, 0x09, 0x08,
   0x06, 0x04, 0x04, 0x05, 0x04, 0x00, 0x00, 0x07, 0x00, 0x01,
   0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x07, 0x04, 0x03, 0x05,
   0x04, 0x07, 0x07, 0x0f, 0x00, 0x6b, 0x03, 0x9d, 0x00, 0x0b,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x08, 0x04, 0x53,
   0x00, 0x0f, 0x00, 0x5b, 0x04, 0x8f, 0x00, 0x09, 0x00, 0xea,
   0x04, 0x13, 0x00, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0f,
   0x00, 0xfd, 0x04, 0x73, 0x00, 0x0c, 0x0f, 0x00, 0x02, 0x02,
   0x03, 0x03, 0x05, 0x04, 0x06, 0x04, 0x05, 0x07, 0x07, 0x07,
   0x03, 0x07, 0x03, 0x03, 0x04, 0x04, 0x06, 0x05, 0x07, 0x03,
   0x06, 0x08, 0x08, 0x08, 0x06, 0x08, 0x04, 0x04, 0x05, 0x05,
   0x08, 0x07, 0x08, 0x04, 0x07, 0x08, 0x07, 0x07, 0x08, 0x09,
   0x03, 0x03, 0x04, 0x04, 0x04, 0x03, 0x08, 0x05, 0x05, 0x07,
   0x07, 0x07, 0x05, 0x07, 0x05, 0x06, 0x04, 0x05, 0x02, 0x04,
   0x06, 0x07, 0x04, 0x02, 0x03, 0x03, 0x04, 0x06, 0x06, 0x05,
   0x05, 0x04, 0x03, 0x05, 0x07, 0x08, 0x04, 0x03, 0x02, 0x02,
   0x04, 0x06, 0x07, 0x07, 0x08, 0x08, 0x05, 0x07, 0x05, 0x07,
   0x07, 0x04, 0x05, 0x05, 0x07, 0x02, 0x08, 0x08, 0x08, 0x08,
   0x06, 0x06, 0x08, 0x06, 0x03, 0x04, 0x05, 0x05, 0x06, 0x05,
   0x01, 0x01, 0x02, 0x02, 0x04, 0x05, 0x07, 0x04, 0x04, 0x07,
   0x07, 0x07, 0x04, 0x07, 0x04, 0x04, 0x04, 0x04, 0x07, 0x07,
   0x08, 0x03, 0x04, 0x08, 0x08, 0x08, 0x07, 0x08, 0x08, 0x08,
   0x08, 0x08, 0x09, 0x08, 0x09, 0x03, 0x07, 0x09, 0x09, 0x09,
   0x09, 0x09, 0x0b, 0x09, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
   0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02,
   0x00, 0x01, 0x01, 0x01, 0x00, 0x02, 0x01, 0x03, 0x01, 0x01,
   0x01, 0x01, 0x00, 0x02, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01,
   0x02, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x00,
   0x03, 0x01, 0x01, 0x02, 0x02, 0x02, 0x01, 0x03, 0x00, 0x04,
   0x02, 0x02, 0x02, 0x02, 0x01, 0x03, 0x00, 0x04, 0x02, 0x02,
   0x02, 0x02, 0x03, 0x01, 0x04, 0x00, 0x02, 0x02, 0x02, 0x02,
   0x03, 0x01, 0x04, 0x00, 0x02, 0x0b, 0x0f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05,
   0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
   0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
   0x05, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
   0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
   0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05,
   0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
   0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x09,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07,
   0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x09, 0x0f, 0x00,
   0x03, 0x02, 0x04, 0x05, 0x06, 0x03, 0x07, 0x03, 0x02, 0x04,
   0x05, 0x06, 0x03, 0x07, 0x03, 0x02, 0x04, 0x05, 0x06, 0x03,
   0x07, 0x03, 0x02, 0x04, 0x05, 0x06, 0x03, 0x07, 0x03, 0x02,
   0x04, 0x05, 0x06, 0x03, 0x07, 0x03, 0x02, 0x04, 0x05, 0x06,
   0x03, 0x07, 0x03, 0x02, 0x04, 0x05, 0x06, 0x03, 0x07, 0x03,
   0x02, 0x04, 0x05, 0x06, 0x03, 0x07, 0x06, 0x05, 0x04, 0x03,
   0x02, 0x06, 0x04, 0x06, 0x05, 0x04, 0x03, 0x02, 0x06, 0x04,
   0x06, 0x05, 0x04, 0x03, 0x02, 0x06, 0x04, 0x06, 0x05, 0x04,
   0x03, 0x02, 0x06, 0x04, 0x06, 0x05, 0x04, 0x03, 0x02, 0x06,
   0x04, 0x06, 0x05, 0x04, 0x03, 0x02, 0x06, 0x04, 0x06, 0x05,
   0x04, 0x03, 0x02, 0x06, 0x04, 0x06, 0x05, 0x04, 0x03, 0x02,
   0x06, 0x04, 0x00, 0x05, 0x04, 0x06, 0x03, 0x04, 0x03, 0x02,
   0x01, 0x01, 0x09, 0x02, 0xb0, 0x05, 0x1c, 0x00, 0x0b, 0x01,
   0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0xcc, 0x05, 0x43, 0x00,
   0x07, 0x02, 0x0f, 0x06, 0x0f, 0x00, 0x09, 0x04, 0x1e, 0x06,
   0x02, 0x00, 0x0a, 0x02, 0x20, 0x06, 0x24, 0x00, 0x0d, 0x02,
   0x44, 0x06, 0x42, 0x00, 0x0d, 0x02, 0x86, 0x06, 0x42, 0x00,
   0x06, 0x04, 0x23, 0x03, 0x02, 0x00, 0x03, 0x02, 0x02, 0x05,
   0x05, 0x04, 0x07, 0x07, 0x08, 0x04, 0x07, 0x08, 0x09, 0x07,
   0x03, 0x06, 0x06, 0x08, 0x05, 0x04, 0x05, 0x08, 0x09, 0x09,
   0x07, 0x03, 0x03, 0x05, 0x09, 0x09, 0x00, 0x00, 0x09, 0x14,
   0x14, 0x14, 0x14, 0x14, 0x09, 0x09, 0x00, 0x14, 0x14, 0x14,
   0x14, 0x14, 0x00, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
   0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
   0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
   0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
   0x14, 0x14, 0x14, 0x09, 0x00, 0x14, 0x14, 0x14, 0x14, 0x14,
   0x00, 0x02, 0x03, 0x02, 0x04, 0x03, 0x02, 0x05, 0x04, 0x03,
   0x02, 0x09, 0x08, 0x07, 0x08, 0x09, 0x02, 0x01, 0x02, 0x04,
   0x02, 0x04, 0x06, 0x08, 0x06, 0x04, 0x06, 0x02, 0x08, 0x06,
   0x04, 0x04, 0x02, 0x03, 0x05, 0x07, 0x05, 0x07, 0x09, 0x05,
   0x03, 0x05, 0x07, 0x05, 0x07, 0x02, 0x07, 0x05, 0x03, 0x09,
   0x07, 0x05, 0x04, 0x02, 0x03, 0x05, 0x03, 0x07, 0x05, 0x03,
   0x02, 0x04, 0x06, 0x08, 0x04, 0x02, 0x04, 0x06, 0x03, 0x06,
   0x04, 0x02, 0x04, 0x05, 0x03, 0x08, 0x06, 0x04, 0x02, 0x07,
   0x05, 0x03, 0x03, 0x05, 0x07, 0x09, 0x02, 0x04, 0x06, 0x08,
   0x05, 0x03, 0x05, 0x07, 0x04, 0x02, 0x04, 0x06, 0x03, 0x07,
   0x05, 0x03, 0x05, 0x06, 0x04, 0x02, 0x04, 0x05, 0x03, 0x09,
   0x07, 0x06, 0x03, 0x08, 0x06, 0x04, 0x02, 0x07, 0x05, 0x06,
   0x02, 0x04, 0x02, 0x03, 0x05, 0x07, 0x05, 0x03, 0x05, 0x02,
   0x07, 0x05, 0x03, 0x04, 0x02, 0x03, 0x05, 0x07, 0x03, 0x05,
   0x07, 0x05, 0x03, 0x05, 0x05, 0x03, 0x05, 0x02, 0x07, 0x05,
   0x03, 0x07, 0x05, 0x03, 0x04, 0x02, 0x03, 0x05, 0x07, 0x03,
   0x05, 0x07, 0x03, 0x05, 0x07, 0x05, 0x03, 0x05, 0x05, 0x03,
   0x05, 0x05, 0x03, 0x05, 0x02, 0x07, 0x05, 0x03, 0x07, 0x05,
   0x03, 0x07, 0x05, 0x03, 0x04, 0x02, 0x00, 0x05, 0x04, 0x04,
   0x03, 0x04, 0x04, 0x02, 0x02, 0x01, 0x0c, 0x02, 0x08, 0x07,
   0x37, 0x00, 0x0b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x09, 0x02,
   0x3f, 0x07, 0x1c, 0x00, 0x0d, 0x02, 0x5b, 0x07, 0x42, 0x00,
   0x10, 0x02, 0x9d, 0x07, 0x69, 0x00, 0x07, 0x02, 0x06, 0x08,
   0x0f, 0x00, 0x08, 0x02, 0x15, 0x08, 0x15, 0x00, 0x0f, 0x02,
   0x2a, 0x08, 0x5b, 0x00, 0x05, 0x02, 0x85, 0x08, 0x06, 0x00,
   0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x08, 0x08, 0x08, 0x06,
   0x08, 0x08, 0x08, 0x08, 0x06, 0x08, 0x08, 0x06, 0x08, 0x06,
   0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x06, 0x06, 0x06, 0x08,
   0x08, 0x08, 0x04, 0x04, 0x06, 0x06, 0x08, 0x08, 0x08, 0x08,
   0x08, 0x06, 0x06, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
   0x08, 0x08, 0x08, 0x08, 0x06, 0x02, 0x03, 0x02, 0x04, 0x03,
   0x02, 0x05, 0x04, 0x03, 0x02, 0x06, 0x05, 0x04, 0x03, 0x02,
   0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x09, 0x09, 0x08, 0x07,
   0x08, 0x09, 0x09, 0x02, 0x03, 0x02, 0x04, 0x03, 0x02, 0x05,
   0x04, 0x03, 0x02, 0x06, 0x05, 0x04, 0x03, 0x02, 0x07, 0x06,
   0x05, 0x04, 0x03, 0x02, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03,
   0x02, 0x04, 0x03, 0x03, 0x04, 0x05, 0x06, 0x08, 0x09, 0x06,
   0x06, 0x06, 0x06, 0x04, 0x05, 0x07, 0x08, 0x03, 0x08, 0x08,
   0x08, 0x08, 0x07, 0x05, 0x06, 0x07, 0x06, 0x03, 0x09, 0x09,
   0x09, 0x09, 0x09, 0x08, 0x08, 0x08, 0x09, 0x09, 0x08, 0x01,
   0x04, 0x04, 0x05, 0x05, 0x01, 0x06, 0x06, 0x02, 0x02, 0x05,
   0x05, 0x03, 0x03, 0x03, 0x07, 0x07, 0x04, 0x04, 0x06, 0x06,
   0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x02, 0x03, 0x03, 0x05,
   0x05, 0x06, 0x05, 0x04, 0x04, 0x08, 0x08, 0x08, 0x08, 0x08,
   0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x07,
   0x08, 0x08, 0x08, 0x01, 0x08, 0x08, 0x08, 0x08, 0x08, 0x07,
   0x08, 0x08, 0x08, 0x02, 0x01, 0x04, 0x04, 0x07, 0x07, 0x08,
   0x06, 0x07, 0x07, 0x04, 0x04, 0x04, 0x04, 0x09, 0x09, 0x09,
   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x06, 0x06, 0x06, 0x07,
   0x06, 0x05, 0x06, 0x06, 0x04, 0x05, 0x07, 0x05, 0x06, 0x09,
   0x08, 0x07, 0x06, 0x08, 0x06, 0x07, 0x04, 0x08, 0x05, 0x03,
   0x08, 0x05, 0x04, 0x04, 0x09, 0x07, 0x05, 0x03, 0x03, 0x03,
   0x04, 0x02, 0x05, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x06,
   0x06, 0x05, 0x07, 0x02, 0x08, 0x08, 0x08, 0x05, 0x06, 0x05,
   0x02, 0x03, 0x03, 0x03, 0x05, 0x04, 0x04, 0x04, 0x04, 0x05,
   0x03, 0x04, 0x03, 0x04, 0x03, 0x05, 0x04, 0x03, 0x04, 0x04,
   0x04, 0x06, 0x06, 0x06, 0x07, 0x06, 0x06, 0x05, 0x07, 0x07,
   0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x09, 0x09, 0x08, 0x09,
   0x08, 0x08, 0x08, 0x08, 0x08, 0x05, 0x04, 0x05, 0x03, 0x06,
   0x05, 0x06, 0x05, 0x07, 0x08, 0x06, 0x08, 0x06, 0x06, 0x07,
   0x07, 0x07, 0x05, 0x07, 0x09, 0x08, 0x07, 0x08, 0x07, 0x07,
   0x08, 0x08, 0x08, 0x04, 0x07, 0x09, 0x09, 0x04, 0x03, 0x06,
   0x08, 0x06, 0x08, 0x04, 0x04, 0x03, 0x07, 0x08, 0x07, 0x03,
   0x04, 0x02, 0x07, 0x06, 0x05, 0x04, 0x03, 0x00, 0x05, 0x00,
   0x04, 0x00, 0x04, 0x01, 0x01, 0x01, 0x01, 0x0c, 0x02, 0xcb,
   0x08, 0x37, 0x00, 0x0b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03,
   0x02, 0x02, 0x09, 0x01, 0x00, 0x07, 0x02, 0x0f, 0x06, 0x0f,
   0x00, 0x09, 0x00, 0x03, 0x09, 0x43, 0x00, 0x09, 0x00, 0x03,
   0x09, 0x43, 0x00, 0x09, 0x00, 0x03, 0x09, 0x43, 0x00, 0x09,
   0x00, 0x03, 0x09, 0x43, 0x00, 0x09, 0x00, 0x03, 0x09, 0x43,
   0x00, 0x09, 0x09, 0x04, 0x09, 0x09, 0x04, 0x09, 0x09, 0x09,
   0x04, 0x09, 0x09, 0x09, 0x09, 0x04, 0x09, 0x09, 0x09, 0x09,
   0x09, 0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x09,
   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x09, 0x09, 0x09,
   0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x09, 0x09, 0x09, 0x09,
   0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x09, 0x09, 0x09, 0x00,
   0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x00,
   0x03, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x03, 0x00, 0x03,
   0x09, 0x09, 0x09, 0x09, 0x0a, 0x09, 0x03, 0x00, 0x03, 0x09,
   0x09, 0x09, 0x0a, 0x09, 0x09, 0x03, 0x00, 0x03, 0x09, 0x09,
   0x0a, 0x09, 0x09, 0x09, 0x03, 0x00, 0x03, 0x09, 0x0a, 0x09,
   0x09, 0x09, 0x09, 0x03, 0x00, 0x03, 0x0a, 0x09, 0x09, 0x09,
   0x09, 0x09, 0x03, 0x00
};

#endif /* ifndef __PAN1PTBL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\comp2.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

comp2.cpp

Aug 92, JimH
May 93, JimH    chico port

Logic for computer player to select cards to play when not holding
the lead, and initializing data tables is here.

****************************************************************************/

#include "hearts.h"

#include "main.h"
#include "resource.h"

#include "debug.h"      // undef _DEBUG instead to remove messages

/****************************************************************************

computer::SelectCardToPlay

computer player chooses a card to play.

****************************************************************************/

void computer::SelectCardToPlay(handinfotype &h, BOOL bCheating)
{
    TRACE1("<%d> ", id);

    Setup(h);                       // calculate values of private vars

    SLOT s;
    if (bFirst)                     // am I leading?
        s = SelectLeadCard(h);
    else
        s = SelectNonLeadCard(h);

    ASSERT(s >= 0);
    ASSERT(s < MAXSLOT);
    ASSERT(cd[s].IsValid());

    SetMode(WAITING);
    cd[s].Play();                                   // mark card as played
    h.cardplayed[id] = &(cd[s]);                    // update handinfo

    // inform other players

    ::move.playerid = id;
    ::move.cardid = cd[s].ID();
    ::move.playerled = h.playerled;
    ::move.turn = h.turn;

    ddeServer->PostAdvise(hszMove);

    // inform gamemeister

    ::pMainWnd->PostMessage(WM_COMMAND, IDM_REF);
    TRACE0("\n");
}


/****************************************************************************

computer::SelectNonLeadCard

This is where cards to play are selected when the computer player is
not leading.

****************************************************************************/

SLOT computer::SelectNonLeadCard(handinfotype &h)
{
    BOOL bFirstTrick = (cardled != NULL) && (cardled->ID() == TWOCLUBS);

    // If we have at least one card of the led suit...

    if (sHighCard[nSuitLed] != EMPTY)
    {
        TRACE0("can follow suit. ");

        // If there's only one card of this suit, return it.

        if (sHighCard[nSuitLed] == sLowCard[nSuitLed])
        {
            TRACE0("must ");
            PLAY(sHighCard[nSuitLed]);
            return sHighCard[nSuitLed];
        }

        // if it's the first trick, play the high club

        if (bFirstTrick)
        {
            TRACE0("might as well ");
            PLAY(sHighCard[nSuitLed]);
            return sHighCard[nSuitLed];
        }

        // If I am the last player in this trick, and I've won the hand anyway,
        // return highest legal card (unless it's the queen of spades.)

        if (bLast && (nLowVal[nSuitLed] > currentval))
        {
            TRACE0("must win trick. ");
            if (sHighCard[nSuitLed] != sBlackLady)
            {
                PLAY(sHighCard[nSuitLed]);
                return sHighCard[nSuitLed];
            }
            else
            {
                TRACE0("avoid queen. ");
                PLAY(sLowCard[nSuitLed]);
                return sLowCard[nSuitLed];
            }
        }

        // If I am the last player and I CAN win the trick....

        if (bLast && (nHighVal[nSuitLed] > currentval))
        {
            TRACE0("can win. ");

            // Don't grab the trick if there aren't enough low cards
            // left in hand.  The lead may be hard to lose!

            if (nLowestVal < 7)                     // i.e., card val < 8
            {
                if ((nPoints == 0) && (sHighCard[nSuitLed] != sBlackLady))
                {
                    TRACE0("go for it. ");
                    PLAY(sHighCard[nSuitLed]);
                    return sHighCard[nSuitLed];
                }

                // Take a few hearts if it means losing a high spade.

                if ((!h.bQSPlayed) && nSuitLed == SPADES && nPoints < 4)
                {
                    if (nHighVal[SPADES] > QUEEN)
                    {
                        TRACE0("sacrifice hearts to lose high spade. ");
                        PLAY(sHighCard[SPADES]);
                        return sHighCard[SPADES];
                    }
                }
                TRACE0("decline. ");
            }
            else
            {
                TRACE0("no low cards. ");
            }
        }

        // Otherwise, try to find the highest safe card to play...

        SLOT safe = SafeCard(h);
        if (safe != EMPTY)
        {
            // if someone other than me is potentially shooting,
            // hold back high cards.

            if (h.bShootingRisk && h.bHumanShooter && (h.nMoonShooter != id))
            {
                TRACE0("2nd ");
                SLOT s2 = CardBelow(safe);
                if (s2 != EMPTY)
                    safe = s2;
            }

            TRACE0("highest safe card. ");
            PLAY(safe);
            return safe;
        }

        // And if that fails, just play the lowest card.

        TRACE0("no safe card, choose lowest. ");
        if (sLowCard[nSuitLed] != sBlackLady)
        {
            PLAY(sLowCard[nSuitLed]);
            return sLowCard[nSuitLed];
        }
        else
        {
            TRACE0("try to avoid queen. ");
            PLAY(sHighCard[nSuitLed]);
            return sHighCard[nSuitLed];
        }
    }

    TRACE0("can't follow suit. ");

    // At this point, there are no cards of the led suit.  The first
    // priority is to try to sluff off the queen of spades.

    if (!bFirstTrick || !::pMainWnd->IsFirstBloodEnforced())
    {
        if (sBlackLady != EMPTY)
        {
            TRACE0("gotcha! Queen of Spades. ");
            return sBlackLady;
        }
    }

    //  The next priority is to dump high spades (if queen not yet played).

    if ((!h.bQSPlayed) && (nHighVal[SPADES] > QUEEN))
    {
        TRACE0("lose high spade. ");
        PLAY(sHighCard[SPADES]);
        return sHighCard[SPADES];
    }

    // The next priority is to find the most vulnerable suit

    int mvsuit = BestSuitToDump(!bFirstTrick);

    // There is an unusual situation which must be checked for explicitly.
    // It's possible BestSuitToDump may return SPADES, and the high card
    // is the queen.  This would still be illegal if it was first round.

    if (bFirstTrick && ::pMainWnd->IsFirstBloodEnforced() && mvsuit == SPADES)
    {
        SLOT s = sHighCard[mvsuit];
        if (cd[s].ID() == BLACKLADY)
        {
            if (sHighCard[DIAMONDS] != EMPTY)       // we know there's no clubs
                mvsuit = DIAMONDS;
            else if (sLowCard[SPADES] != sHighCard[SPADES])
            {
                TRACE0("dump low spade.  ");
                return sLowCard[SPADES];
            }
            else
                mvsuit = HEARTS;
        }
    }


    // if someone other than me is potentially shooting, hold back high cards

    if (h.bShootingRisk && h.bHumanShooter && (h.nMoonShooter != id) &&
                                (sHighCard[mvsuit] != sLowCard[mvsuit]))
    {
        SLOT s = sHighCard[mvsuit];
        SLOT s2 = CardBelow(s);
        if (s2 != EMPTY)
            s = s2;

#ifdef _DEBUG
        TRACE1("hold high %c. ", suitid[mvsuit]);
#endif
        PLAY(s);
        return s;
    }

#ifdef _DEBUG
    TRACE1("dump %c. ", suitid[mvsuit]);
#endif
    PLAY(sHighCard[mvsuit]);
    return sHighCard[mvsuit];
}


/****************************************************************************

computer::SafeCard

Returns highest safe card or EMPTY if no safe card found.

****************************************************************************/

SLOT computer::SafeCard(handinfotype &h)
{
    // Special check.  If Ace of Spades is current trick winner, play the
    // Queen of Spades rather than the King, even though the King is higher.

    if ((sBlackLady!=EMPTY) && (nSuitLed==SPADES) && (currentval==(KING+1)))
        return sBlackLady;

    // Look for highest card of same suit that won't win trick.

    SLOT sSafe = EMPTY;             // highest safe slot
    int  nSafeVal = -1;             // value of highest safe card

    for (SLOT s = 0; s < MAXSLOT; s++)
    {
        if (cd[s].IsValid())
        {
            if (cd[s].Suit() == nSuitLed)
            {
                int v = cd[s].Value2();

                // If card is safe (v < currentval) and card is highest
                // safe card found so far (v > nSaveVal)...

                if ((v < currentval) && (v > nSafeVal))
                {
                    sSafe = s;
                    nSafeVal = v;
                }
            }
        }
    }

    return sSafe;
}


/****************************************************************************

computer::Setup

Set up reference tables for high and low cards in each suit, etc.

****************************************************************************/

void computer::Setup(handinfotype &h)
{
    cardled   = h.cardplayed[h.playerled];
    if (cardled)
    {
        nSuitLed  = cardled->Suit();
        nValueLed = cardled->Value2();
    }
    else
    {
        nSuitLed  = EMPTY;
        nValueLed = EMPTY;
    }

    nPoints   = 0;                      // points in hand already

    // Initialize Tables

    for (int suit = 0; suit < MAXSUIT; suit++)  // highs and lows by suit
    {
        sHighCard[suit] = EMPTY;
        sLowCard[suit]  = EMPTY;
        nHighVal[suit]  = ACE - 1;          // lower than any real card
        nLowVal[suit]   = KING + 2;         // higher than any real card
    }

    sHighestCard = EMPTY;                   // highs and lows regardless of suit
    sLowestCard = EMPTY;
    nHighestVal = ACE - 1;
    nLowestVal = KING + 2;

    // Determine currentval (the value of the winning card so far) and nPoints.

    currentval = nValueLed;
    for (int i = 0; i < MAXPLAYER; i++)
    {
        card *c = h.cardplayed[i];
        if (c->IsValid())
        {
            // First, determine if there are any point cards in play.

            if (c->Suit() == HEARTS)
                nPoints++;

            if (c->ID() == BLACKLADY)
                nPoints += 13;

            // Then, find the highest card (on table) of the led suit.

            if (c->Suit() == nSuitLed)
            {
                int v = c->Value2();

                if (v > currentval)
                    currentval = v;
            }
        }
    }

    // Calculate if we're leading or completing this trick.

    bFirst = (h.playerled == id);
    bLast  = (((h.playerled + (MAXPLAYER-1)) % MAXPLAYER) == id);

    // Special check for the Queen of Spades

    sBlackLady = EMPTY;     // assume we don't have it

    // Collect information on high and low cards in each suit.

    for (SLOT s = 0; s < MAXSLOT; s++)
    {
        if (cd[s].IsValid())
        {
            int suit = cd[s].Suit();
            int v = cd[s].Value2();

            if (cd[s].ID() == BLACKLADY)
                sBlackLady = s;

            if (v < nLowVal[suit])
            {
                nLowVal[suit] = v;
                sLowCard[suit] = s;
            }

            if (v < nLowestVal)
            {
                nLowestVal = v;
                sLowestCard = s;
            }

            if (v > nHighVal[suit])
            {
                nHighVal[suit] = v;
                sHighCard[suit] = s;
            }

            if (v > nHighestVal)
            {
                nHighestVal = v;
                sHighestCard = s;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\computer.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

computer.cpp

keithmo

****************************************************************************/

#include "hearts.h"

#include "main.h"
#include "resource.h"


//
//  Static members.
//

//
//  This array is used to prioritize the search for cards
//  to pass.  This basically maps the irritating A-K ordering
//  used by CARDS.DLL into a more appropriate 2-A ordering.
//

int computer :: _VectorPriority[13] =
	{
	    VECTOR_ACE,
	    VECTOR_KING,
	    VECTOR_QUEEN,
	    VECTOR_JACK,
	    VECTOR_10,
	    VECTOR_9,
	    VECTOR_8,
	    VECTOR_7,
	    VECTOR_6,
	    VECTOR_5,
	    VECTOR_4,
	    VECTOR_3,
	    VECTOR_2
	};

//
//  This array is used to prioritize the card suits.
//

int computer :: _SuitPriority[4] =
    {
	INDEX_HEARTS,
	INDEX_SPADES,
	INDEX_DIAMONDS,
	INDEX_CLUBS
    };


/****************************************************************************

computer constructor

****************************************************************************/
computer :: computer(int n) : player(n, n)
{
    CString newname;
    TCHAR    buf[MAXNAMELENGTH+1];

    *buf = '\0';
    RegEntry    Reg(szRegPath);
    Reg.GetString(regvalPName[n-1], buf, sizeof(buf));
    newname = buf;

    if (newname.IsEmpty())
        newname.LoadString(IDS_P1NAME + n - 1);

    CClientDC dc(::pMainWnd);
    SetName(newname, dc);
    
}   // computer :: computer


/****************************************************************************

Keith:  Make sure you Select(TRUE) cards you select, and
        SetMode(DONE_SELECTING) before you return.

****************************************************************************/
void computer :: SelectCardsToPass()
{
    //
    //  This will hold the total number of cards that
    //  have been passed.
    //
    
    int cPassed = 0;
    int i;
    int nSuit;
    
    //
    //  First we must build our database.
    //

    ComputeVectors();

    //
    //  Priority 1:  Lose the Queen, King, and Ace of Spades.
    //

    PassCardsInVector( QuerySpadesVector() & QKA_CARDS,
		       INDEX_SPADES,
		       &cPassed );

    //
    //  Priority 2:  Lose the Jack, Queen, King, and Ace of Hearts.
    //

    PassCardsInVector( QueryHeartsVector() & JQKA_CARDS,
		       INDEX_HEARTS,
		       &cPassed );

    //
    //  Priority 3:  Pass any high cards not accompanied by two or
    //		     more low cards.
    //

    for( i = 0 ; ( i < 4 ) && ( cPassed < 3 ) ; i++ )
    {
	nSuit = _SuitPriority[i];

	if( nSuit == INDEX_SPADES )
	{
	    continue;
	}
	
	if( CountBits( _CardVectors[nSuit] & LOW_CARDS ) < 2 )
	{
	    PassCardsInVector( _CardVectors[nSuit] & HIGH_CARDS,
			       nSuit,
			       &cPassed );
	}
    }

    //
    //  Priority 4:  If we have the opportunity to "short suit" our
    //  hand, do it.
    //

    for( i = 0 ; ( i < 4 ) && ( cPassed < 3 ) ; i++ )
    {
	nSuit = _SuitPriority[i];
	
	if( CountBits( _CardVectors[nSuit] ) <= ( 3 - cPassed ) )
	{
	    PassCardsInVector( _CardVectors[nSuit],
			       nSuit,
			       &cPassed );
	}
    }

    //
    //  Priority 5:  Hell, I don't know.  Just find some cards to pass.
    //

    for( i = 0 ; ( i < 4 ) && ( cPassed < 3 ) ; i++ )
    {
	nSuit = _SuitPriority[i];
	
	PassCardsInVector( _CardVectors[nSuit],
			   nSuit,
			   &cPassed );
    }
    
    SetMode( DONE_SELECTING );
    
}   // computer :: SelectCardsToPass


/****************************************************************************

    ComputeVectors

    This method sets the _CardVectors[] array to reflect the current set
    of cards held by the computer.
    
****************************************************************************/
void computer :: ComputeVectors( void )
{
    //
    //  First, clear out the current vectors.
    //

    _CardVectors[0] = 0;
    _CardVectors[1] = 0;
    _CardVectors[2] = 0;
    _CardVectors[3] = 0;

    //
    //  Now, scan the currently held cards, updating the vectors.
    //
    
    for( int i = 0 ; i < 13 ; i++ )
    {
	if( cd[i].IsInHand() )
	{
	    AddCard( cd[i].ID() );
	}
    }

}   // computer :: ComputeVectors


/****************************************************************************

    PassCardsInVector
    
****************************************************************************/
void computer :: PassCardsInVector( int nVector, int nSuit, int * pcPassed )
{
    int tmpVector;
    
    //
    //  Don't even try if the vector is already empty or we've already
    //  passed three cards.
    //

    if( ( nVector == 0 ) || ( *pcPassed >= 3 ) )
	return;

    //
    //  Scan the cards in our hand.  Pass all of those whose suit
    //  matches nSuit & are in nVector.  Prioritize the search
    //  via the _VectorPriority array.
    //

    for( int m = 0 ; ( m < 13 ) && ( *pcPassed < 3 ) ; m++ )
    {
	tmpVector = nVector & _VectorPriority[m];

	if( tmpVector == 0 )
	    continue;

	for( int i = 0 ; i < 13 ; i++ )
	{
	    if( cd[i].Suit() != nSuit )
		continue;
	    
	    if( ( tmpVector & CardToVector( cd[i].ID() ) ) == 0 )
		continue;
	
	    //
	    //  We found a card.  Mark it as selected.
	    //
	    
	    cd[i].Select( TRUE );

	    //
	    //  Remove the card from our local vector.  Also
	    //  remove it from the card database and update the
	    //  number of passed cards.
	    //
	    
	    nVector &= ~CardToVector( cd[i].ID() );
	    RemoveCard( cd[i].ID() );
	    (*pcPassed)++;

	    //
	    //  Since there's always *exactly* one bit set in
	    //  tmpVector, and we've found the card for that
	    //  bit, we can exit this inner loop.
	    //

	    break;
	}
    
	//
	//  If the vector has become empty, we can terminate the
	//  outer loop.
	//

	if( nVector == 0 )
	    break;
    }
    
}   // computer :: PassCardsInVector


/****************************************************************************

    CountBits
    
****************************************************************************/
int computer :: CountBits( int x ) const
{
    x = ( ( x >> 1 ) & 0x5555 ) + ( x & 0x5555 );
    x = ( ( x >> 2 ) & 0x3333 ) + ( x & 0x3333 );
    x = ( ( x >> 4 ) & 0x0f0f ) + ( x & 0x0f0f );
    x = ( ( x >> 8 ) & 0x00ff ) + ( x & 0x00ff );

    return x;
    
}   // computer :: CountBits
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\card.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/


/****************************************************************************

card.cpp

Nov 91, JimH

Methods for card objects

****************************************************************************/

#include "hearts.h"

#include <stdlib.h>                 // for labs() prototype

#include "card.h"

// Declare (and initialize) static members

HINSTANCE card::hCardsDLL;
INITPROC card::lpcdtInit;
DRAWPROC card::lpcdtDraw;
FARPROC  card::lpcdtTerm;
CBitmap  card::m_bmFgnd;
CBitmap  card::m_bmBgnd2;
CDC      card::m_MemB;
CDC      card::m_MemB2;
CRgn     card::m_Rgn1;
CRgn     card::m_Rgn2;
CRgn     card::m_Rgn;
DWORD    card::dwPixel[12];

BOOL     card::bConstructed;
int      card::dxCrd;
int      card::dyCrd;
CBitmap  card::m_bmBgnd;

int      card::count    = 0;
int      card::stepsize = 15;       // bigger stepsize -> faster glide

/****************************************************************************

card::card

If this is the first card being constructed, links to cards.dll are
set up, along with the bitmaps and regions required for glide()

****************************************************************************/

card::card(int n) : id(n), state(NORMAL)
{
    loc.x = 0;
    loc.y = 0;
    if (count == 0)
    {
        bConstructed = FALSE;

        hCardsDLL = LoadLibrary(TEXT("CARDS.DLL"));
        if (hCardsDLL < (HINSTANCE)HINSTANCE_ERROR)
            return;

        lpcdtInit = (INITPROC) GetProcAddress(hCardsDLL, "cdtInit");
        lpcdtDraw = (DRAWPROC) GetProcAddress(hCardsDLL, "cdtDraw");
        lpcdtTerm =  (FARPROC) GetProcAddress(hCardsDLL, "cdtTerm");

        BOOL bResult = FALSE;
        if(lpcdtInit)
        {
            bResult = (*lpcdtInit)(&dxCrd, &dyCrd);
        }
        if (!bResult)
            return;

        bConstructed = TRUE;

        CDC ic;
        ic.CreateIC(TEXT("DISPLAY"), NULL, NULL, NULL);

        if (!m_bmBgnd.CreateCompatibleBitmap(&ic, dxCrd, dyCrd) ||
            !m_bmFgnd.CreateCompatibleBitmap(&ic, dxCrd, dyCrd) ||
            !m_bmBgnd2.CreateCompatibleBitmap(&ic, dxCrd, dyCrd))
                bConstructed = FALSE;

        ic.DeleteDC();

        if (!m_Rgn1.CreateRectRgn(1, 1, 2, 2) ||        // dummy sizes
            !m_Rgn2.CreateRectRgn(1, 1, 2, 2) ||
            !m_Rgn.CreateRectRgn(1, 1, 2, 2))
                bConstructed = FALSE;
    }
    count++;
}


/****************************************************************************

card::~card

If this is the last card being destroyed, cards.dll is freed and the
bitmaps and regions created for glide() are deleted.

****************************************************************************/
card::~card()
{
    count--;
    if (count == 0)
    {
        (*lpcdtTerm)();
        FreeLibrary(hCardsDLL);
        m_bmBgnd.DeleteObject();
        m_bmFgnd.DeleteObject();
        m_bmBgnd2.DeleteObject();
        m_Rgn.DeleteObject();
        m_Rgn1.DeleteObject();
        m_Rgn2.DeleteObject();
    }
}


/****************************************************************************

card::Draw

wrapper for cards.cdtDraw()
EMPTY cards are not passed through

****************************************************************************/

BOOL card::Draw(CDC &dc, int x, int y, int mode, BOOL bUpdateLoc)
{
    if (bUpdateLoc)
    {
        loc.x = x;              // update current location
        loc.y = y;
    }

    if (id == EMPTY)
        return FALSE;

    return (*lpcdtDraw)(dc.m_hDC, x, y,
        mode == FACEDOWN ? CARDBACK : id, mode, 255);
}


/****************************************************************************

card::CleanDraw

Same as Draw except corners are cleaned up before bitmap is blted.
It's slower than normal draw, but there won't be a white flash in the
corners.

****************************************************************************/

BOOL card::CleanDraw(CDC &dc)
{
    if (id == EMPTY)
        return FALSE;

    SaveCorners(dc, loc.x, loc.y);
    CDC memDC;
    memDC.CreateCompatibleDC(&dc);
    CBitmap bitmap;
    if (!bitmap.CreateCompatibleBitmap(&dc, dxCrd, dyCrd))
        return FALSE;

    CBitmap *oldbitmap = memDC.SelectObject(&bitmap);
    BOOL bResult = (*lpcdtDraw)(memDC.m_hDC, 0, 0, id, FACEUP, 0);
    if (!bResult)
        return FALSE;

    RestoreCorners(memDC, 0, 0);
    dc.BitBlt(loc.x, loc.y, dxCrd, dyCrd, &memDC, 0, 0, SRCCOPY);

    memDC.SelectObject(oldbitmap);
    bitmap.DeleteObject();

    return TRUE;
}


/****************************************************************************

card::PopDraw

Version of Draw intended for local humans.  Selected cards are popped up.

****************************************************************************/

BOOL card::PopDraw(CDC &dc)
{
    if (id == EMPTY)
        return FALSE;

    int y = loc.y;
    if (state == SELECTED)
        y -= POPSPACING;

    return (*lpcdtDraw)(dc.m_hDC, loc.x, y, id, FACEUP, 0);
}


/****************************************************************************

card::Draw

This routine glides a card from its current position to the specified
end position.

NOTE: before Glide() is called, the client must load card::m_bmBgnd with
a bitmap of what should be displayed as being underneath the original
card location.  card::m_bmBgnd is created when the first card is
constructed, and destroyed when the last card is destructed.  Note also
that card::m_bmBgnd must NOT be selected in any DC when Glide() is called.

****************************************************************************/

VOID card::Glide(CDC &dc, int xEnd, int yEnd)
{
    int     x1, y1, x2, y2;             // each step is x1,y1 to x2,y2

    if (!m_MemB.CreateCompatibleDC(&dc) ||  // memory DCs
        !m_MemB2.CreateCompatibleDC(&dc))
            return;

    m_MemB2.SelectObject(&m_bmBgnd2);
    m_MemB.SelectObject(&m_bmFgnd);

    // draw card into fgnd bitmap
    (*lpcdtDraw)(m_MemB.m_hDC, 0, 0, id, FACEUP, 0);

    m_MemB.SelectObject(&m_bmBgnd);     // associate memDCs with bitmaps
    SaveCorners(dc, loc.x, loc.y);
    RestoreCorners(m_MemB, 0, 0);

    long dx = xEnd - loc.x;
    long dy = yEnd - loc.y;
    int  distance = IntSqrt(dx*dx + dy*dy); // int approx. of dist. to travel

    int  steps = distance / stepsize;   // determine # of intermediate steps

    // Ensure that GlideStep gets called an even number of times so
    // the background bitmap will get set properly for multi-glide moves

    if ((steps % 2) == 1)
        steps++;

    x1 = loc.x;
    y1 = loc.y;
    for (int i = 1; i < steps; i++)
    {
        x2 = loc.x + (int) (((long)i * dx) / (long)steps);
        y2 = loc.y + (int) (((long)i * dy) / (long)steps);
        GlideStep(dc, x1, y1, x2, y2);
        x1 = x2;
        y1 = y2;
    }

    // do last step manually so it lands exactly on xEnd, yEnd

    GlideStep(dc, x1, y1, xEnd, yEnd);

    // reset clip region for entire screen

    m_Rgn.SetRectRgn(0, 0, 30000, 30000);   // really big region
    dc.SelectObject(&m_Rgn);

    loc.x = xEnd;
    loc.y = yEnd;

    m_MemB.DeleteDC();        // clean up memory DCs
    m_MemB2.DeleteDC();
}


/******************************************************************************

GlideStep

This routine gets called once for each step in the glide animation.  On
input, it needs the screen under the source in m_MemB, and the card to be
moved in m_bmFgnd.  It calculates the screen under the destination itself
and blts it into m_MemB2.  At the end of the animation, it moves m_MemB2 into
m_MemB so it can be called again immediately with new coordinates.

******************************************************************************/

VOID card::GlideStep(CDC &dc, int x1, int y1, int x2, int y2)
{
    m_Rgn1.SetRectRgn(x1, y1, x1+dxCrd, y1+dyCrd);
    m_Rgn2.SetRectRgn(x2, y2, x2+dxCrd, y2+dyCrd);

    /* create background of new location by combing screen background
       plus overlap from old background */

    m_MemB2.BitBlt(0, 0, dxCrd, dyCrd, &dc, x2, y2, SRCCOPY);
    m_MemB2.BitBlt(x1-x2, y1-y2, dxCrd, dyCrd, &m_MemB, 0, 0, SRCCOPY);
    SaveCorners(m_MemB2, 0, 0);

    /* Draw old background and then draw card  */

    m_Rgn.CombineRgn(&m_Rgn1, &m_Rgn2, RGN_DIFF); // part of hRgn1 not in hRgn2
    dc.SelectObject(&m_Rgn);
    dc.BitBlt(x1, y1, dxCrd, dyCrd, &m_MemB, 0, 0, SRCCOPY);
    dc.SelectObject(&m_Rgn2);
    CBitmap *oldbitmap = m_MemB.SelectObject(&m_bmFgnd);    // temp
    RestoreCorners(m_MemB, 0, 0);
    dc.BitBlt(x2, y2, dxCrd, dyCrd, &m_MemB, 0, 0, SRCCOPY);
    m_MemB.SelectObject(oldbitmap);                         // restore

    /* copy new background to old background, or rather, accomplish the
       same effect by swapping the associated memory device contexts. */

    HDC temp = m_MemB.Detach();         // detach the hDC from the CDC
    m_MemB.Attach(m_MemB2.Detach());    // move the hDC from B2 to B
    m_MemB2.Attach(temp);               // finish the swap
}


/******************************************************************************

IntSqrt

Newton's method to find a quick close-enough square root without pulling
in the floating point libraries.

f(x)  = x*x - square = 0
f'(x) = 2x

******************************************************************************/

int card::IntSqrt(long square)
{
    long lastguess = square;
    long guess = min(square / 2L, 1024L);

    while (labs(guess-lastguess) > 3L)       // 3 is close enough
    {
        lastguess = guess;
        guess -= ((guess * guess) - square) / (2L * guess);
    }

    return (int) guess;
}


/******************************************************************************

SaveCorners
RestoreCorners

based on similar routines in cards.dll

******************************************************************************/

VOID card::SaveCorners(CDC &dc, int x, int y)
{
    // Upper Left
    dwPixel[0] = dc.GetPixel(x, y);
    dwPixel[1] = dc.GetPixel(x+1, y);
    dwPixel[2] = dc.GetPixel(x, y+1);

    // Upper Right
    x += dxCrd -1;
    dwPixel[3] = dc.GetPixel(x, y);
    dwPixel[4] = dc.GetPixel(x-1, y);
    dwPixel[5] = dc.GetPixel(x, y+1);

    // Lower Right
    y += dyCrd-1;
    dwPixel[6] = dc.GetPixel(x, y);
    dwPixel[7] = dc.GetPixel(x, y-1);
    dwPixel[8] = dc.GetPixel(x-1, y);

    // Lower Left
    x -= dxCrd-1;
    dwPixel[9] = dc.GetPixel(x, y);
    dwPixel[10] = dc.GetPixel(x+1, y);
    dwPixel[11] = dc.GetPixel(x, y-1);
}

VOID card::RestoreCorners(CDC &dc, int x, int y)
{
    // Upper Left
    dc.SetPixel(x, y, dwPixel[0]);
    dc.SetPixel(x+1, y, dwPixel[1]);
    dc.SetPixel(x, y+1, dwPixel[2]);

    // Upper Right
    x += dxCrd-1;
    dc.SetPixel(x, y, dwPixel[3]);
    dc.SetPixel(x-1, y, dwPixel[4]);
    dc.SetPixel(x, y+1, dwPixel[5]);

    // Lower Right
    y += dyCrd-1;
    dc.SetPixel(x, y, dwPixel[6]);
    dc.SetPixel(x, y-1, dwPixel[7]);
    dc.SetPixel(x-1, y, dwPixel[8]);

    // Lower Left
    x -= dxCrd-1;
    dc.SetPixel(x, y, dwPixel[9]);
    dc.SetPixel(x+1, y, dwPixel[10]);
    dc.SetPixel(x, y-1, dwPixel[11]);
}


/******************************************************************************

GetRect()

sets and returns a rect that covers the card

******************************************************************************/

CRect &card::GetRect(CRect &rect)
{
    rect.SetRect(loc.x, loc.y, loc.x+dxCrd, loc.y+dyCrd);
    return(rect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\card.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/


/****************************************************************************

card.h

Feb 92, JimH

Header file for class card

****************************************************************************/

#ifndef	CARD_INC
#define	CARD_INC

// typedefs for pointers to functions in cards.dll
// cdtTerm() can use standard FARPROC

typedef BOOL (FAR PASCAL *DRAWPROC)(HDC, int, int, int, int, DWORD);
typedef BOOL (FAR PASCAL *INITPROC)(int FAR *, int FAR *);

const   int     EMPTY       = -1;
const   int     FACEUP      = 0;
const   int     FACEDOWN    = 1;
const   int     HILITE      = 2;
const   int     CARDBACK    = 54;
const   int     ACE         = 0;
const   int     QUEEN       = 11;
const   int     KING        = 12;

const   int     TWOCLUBS    = 4;
const   int     BLACKLADY   = 47;
const   int     CLUBS       = 0;
const   int     DIAMONDS    = 1;
const   int     HEARTS      = 2;
const   int     SPADES      = 3;

const   int     POPSPACING  = 20;       // selected cards pop up this high

const   int     MAXSUIT     = 4;

enum    statetype { NORMAL, SELECTED, PLAYED, HIDDEN };

class card {

    private:
        int     id;                         // 0 to 51
        POINT   loc;                        // current top-left corner loc.
        statetype state;                    // selected or hidden?

        static  int         count;          // number of card instances
        static  int         stepsize;       // size of glide() steps
        static  HINSTANCE   hCardsDLL;      // handle to cards.dll
        static  INITPROC    lpcdtInit;      // ptr to cards.cdtInit()
        static  DRAWPROC    lpcdtDraw;      // ptr to cards.cdtDraw()
        static  FARPROC     lpcdtTerm;      // ptr to cards.cdtTerm()
        static  CBitmap     m_bmFgnd;       // animation card
        static  CBitmap     m_bmBgnd2;      // background dest bitmap
        static  CDC         m_MemB, m_MemB2; // memory DCs for bkgnd bitmaps
        static  CRgn        m_Rgn1, m_Rgn2; // hRgn1 is source, hRgn2 is dest
        static  CRgn        m_Rgn;          // combined region
        static  DWORD       dwPixel[12];    // corner pixels for save/restore

        VOID GlideStep(CDC &dc, int x1, int y1, int x2, int y2);
        VOID SaveCorners(CDC &dc, int x, int y);
        VOID RestoreCorners(CDC &dc, int x, int y);
        int  IntSqrt(long square);

    public:
        static  BOOL        bConstructed;
        static  int         dxCrd, dyCrd;   // size of card bitmap
        static  CBitmap     m_bmBgnd;       // what's under card to glide

        card(int n = EMPTY);
        ~card();

        int ID()    { ASSERT(this != NULL); return id; }
        int Suit()  { ASSERT(this != NULL); return (id % MAXSUIT); }
        int Value() { ASSERT(this != NULL); return (id / MAXSUIT); }
        int Value2() { int v = Value(); return ((v == ACE) ? (KING + 1) : v); }
        VOID Select(BOOL b) { state = (b ? SELECTED : NORMAL); }
        BOOL IsEmpty() { ASSERT(this != NULL); return (id == EMPTY); }
        BOOL IsSelected() { ASSERT(this != NULL); return (state == SELECTED); }
        BOOL IsPlayed() { ASSERT(this != NULL); return (state == PLAYED); }
        BOOL IsHeart() { return (Suit() == HEARTS); }
        BOOL IsValid() { return ((this != NULL) && (id != EMPTY)); }

        VOID SetID(int n) { id = n; }
        VOID SetLoc(int x, int y) { loc.x = x; loc.y = y; }
        int  SetStepSize(int s) { int old = stepsize; stepsize = s; return old;}
        int  GetX(void) { return loc.x; }
        int  GetY(void) { return loc.y; }

        BOOL Draw(CDC &dc, int x, int y,
                  int mode = FACEUP, BOOL bUpdateLoc = TRUE);
        BOOL Draw(CDC &dc) { return Draw(dc, loc.x, loc.y, FACEUP); }
        BOOL Draw(CDC &dc, int mode) { return Draw(dc, loc.x, loc.y, mode); }
        BOOL PopDraw(CDC &dc);      // draw with selections popped
        BOOL CleanDraw(CDC &dc);    // draw with clean corners

        VOID Glide(CDC &dc, int xEnd, int yEnd);
        CRect &GetRect(CRect& rect);
        VOID Remove() { state = HIDDEN; id = EMPTY; }
        VOID Play() { state = PLAYED; }
        BOOL IsNormal() { return (state == NORMAL); }
        BOOL IsInHand() { return ((state == NORMAL) || (state == SELECTED)); }
};

#endif  // conditional include
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\computer.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/


/****************************************************************************

    computer.h

    This file contains the class declarations and manifest constants
    necessary for implementing the 'computer' object.

    FILE HISTORY:

	KeithMo	    01-Mar-1992	    Created from JimH's PLAYER.H.

****************************************************************************/

#include "card.h"
#include "player.h"

#ifndef	_COMPUTER_H_
#define	_COMPUTER_H_


//
//  These constants are used for indexing the _CardVectors array.
//
//  Note that this ordering *must* match the ordering used for the
//  card ID values!!
//

#define INDEX_CLUBS		0
#define INDEX_DIAMONDS		1
#define INDEX_HEARTS		2
#define INDEX_SPADES            3

//
//  These constants represent the values returned from the
//  CardToVector() function.
//
//  Note that this ordering *must* match the ordering used for the
//  card ID values!!
//

#define VECTOR_ACE		0x0001
#define VECTOR_2       		0x0002
#define VECTOR_3       		0x0004
#define VECTOR_4       		0x0008
#define VECTOR_5       		0x0010
#define VECTOR_6       		0x0020
#define VECTOR_7       		0x0040
#define VECTOR_8       		0x0080
#define VECTOR_9		0x0100
#define VECTOR_10		0x0200
#define VECTOR_JACK		0x0400
#define VECTOR_QUEEN		0x0800
#define VECTOR_KING		0x1000

//
//  These constants define various combinations of cards.
//

#define LOW_CARDS		(VECTOR_2 | VECTOR_3 | VECTOR_4 | VECTOR_5 \
				 | VECTOR_6 | VECTOR_7)
				 
#define HIGH_CARDS		(VECTOR_8 | VECTOR_9 | VECTOR_10 \
				 | VECTOR_JACK | VECTOR_QUEEN | VECTOR_KING \
				 | VECTOR_ACE)

#define QKA_CARDS		(VECTOR_QUEEN | VECTOR_KING | VECTOR_ACE)

#define JQKA_CARDS		(VECTOR_JACK | VECTOR_QUEEN | VECTOR_KING \
				 | VECTOR_ACE)


/****************************************************************************

    computer

****************************************************************************/
class computer : public player
{
private:
    static int _VectorPriority[13];
    static int _SuitPriority[4];
    
    int _CardVectors[4];

    int CardToSuit( int nCard ) const
        { return nCard % 4; }

    int CardToValue( int nCard ) const
        { return nCard / 4; }

    int CardToVector( int nCard ) const
        { return 1 << CardToValue( nCard ); }

    int CountBits( int x ) const;

    void AddCard( int nCard )
        { _CardVectors[CardToSuit(nCard)] |= CardToVector(nCard); }

    void RemoveCard( int nCard )
        { _CardVectors[CardToSuit(nCard)] &= ~CardToVector(nCard); }

    BOOL TestCard( int nCard ) const
        { return (_CardVectors[CardToSuit(nCard)] & CardToVector(nCard)) != 0; }

    int QueryClubsVector( void ) const
	{ return _CardVectors[INDEX_CLUBS]; }

    int QueryDiamondsVector( void ) const
	{ return _CardVectors[INDEX_DIAMONDS]; }

    int QueryHeartsVector( void ) const
	{ return _CardVectors[INDEX_HEARTS]; }

    int QuerySpadesVector( void ) const
	{ return _CardVectors[INDEX_SPADES]; }

    void ComputeVectors( void );

    void PassCardsInVector( int nVector, int nSuit, int * pcPassed );

    // comp2.cpp helper functions and data

    int  BestSuitToDump(BOOL bIncludeHearts = TRUE);
    int  BestSuitToLose(BOOL bIncludeHearts = TRUE);
    SLOT CardBelow(SLOT s);
    int  CardsAbove(SLOT s);
    int  CardsAboveLow(int suit);
    int  CardsBelowLow(int suit);
    SLOT MidSlot(int suit);
    SLOT SafeCard(handinfotype &h);
    SLOT SelectLeadCard(handinfotype &h);
    SLOT SelectNonLeadCard(handinfotype &h);
    void Setup(handinfotype &h);
    int  SureLossSuit(BOOL bIncludeHearts);
	
    BOOL    bFirst;                 // am I leading?
    BOOL    bLast;                  // am I last?
    card    *cardled;
    int     nSuitLed;
    int     nValueLed;
    int     currentval;             // current winning value
    int     nPoints;                // points currently in hand

    SLOT    sBlackLady;             // non-EMPTY if in hand

    SLOT    sHighCard[MAXSUIT];     // highest and lowest cards by suit
    int     nHighVal[MAXSUIT];
    SLOT    sLowCard[MAXSUIT];
    int     nLowVal[MAXSUIT];

    SLOT    sHighestCard;           // highest and lowest regardless of suit
    int     nHighestVal;
    SLOT    sLowestCard;
    int     nLowestVal;

    int     nAvailable[MAXSUIT][KING+2];    // cards unaccounted for this hand

public:
    computer(int n);
    virtual void NotifyEndHand(handinfotype &h);
    virtual void NotifyNewRound(void);
    virtual void SelectCardsToPass(void);
    virtual void SelectCardToPlay(handinfotype &h, BOOL bCheating);
    virtual void UpdateStatus(void) { }
    virtual void UpdateStatus(int stringid) { status = stringid; }
    virtual void UpdateStatus(const TCHAR *string) { }
    
};  // class computer


#endif	// _COMPUTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\ddecb.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

ddecb.cpp

Aug 92, JimH
May 93, JimH    chico port

DDE callback functions are here, as well as some helper functions.  The
callbacks quickly call CMainWindow member function equivalents.

****************************************************************************/

#include "hearts.h"

#include "main.h"
#include "debug.h"
#include "resource.h"


/****************************************************************************

DdeServerCallback()

****************************************************************************/

HDDEDATA EXPENTRY EXPORT DdeServerCallBack(WORD wType, WORD wFmt, HCONV hConv,
                                    HSZ hsz1, HSZ hsz2, HDDEDATA hData,
                                    DWORD dwData1, DWORD dwData2)
{
    return ::pMainWnd->DdeSrvCallBack(wType, wFmt, hConv, hsz1, hsz2, hData,
                                    dwData1, dwData2);
}

HDDEDATA CMainWindow::DdeSrvCallBack(
WORD    wType,              // transaction type
WORD    wFmt,               // clipboard format
HCONV   hConv,              // handle to conversation
HSZ     hsz1,               // string handles
HSZ     hsz2,
HDDEDATA hData,             // handle to a global memory object
DWORD   dwData1,            // transaction-specific data
DWORD   dwData2)
{
    switch(wType)
    {
        case XTYP_ADVREQ:               // server called PostAdvise

            if (hsz2 == hszStatus)      // if status update
            {
                return GetGameStatus(hConv);
            }
            else if (hsz2 == hszGameNumber)
            {
                int num = GetGameNumber();
                return dde->CreateDataHandle(&num, sizeof(num), hszGameNumber);
            }
            else if (hsz2 == hszPass)   // update pass selections all players
            {
                PASS12  pass12;

                GetPass12(pass12);
                return dde->CreateDataHandle(&pass12, sizeof(pass12), hszPass);
            }
            else if (hsz2 == hszMove)
            {
                return dde->CreateDataHandle(&::move, sizeof(::move), hszMove);
            }
            else
                return (HDDEDATA) NULL;

        case XTYP_ADVSTART:             // client requested advise loop
            if (hsz2 == hszGameNumber)
            {
                if (CountClients() == 3)
                    PostMessage(WM_COMMAND, IDM_NEWGAME);
            }
            return (HDDEDATA) TRUE;

        case XTYP_ADVSTOP:
            return (HDDEDATA) NULL;

        case XTYP_CONNECT:              // return TRUE to accept connection
            return (HDDEDATA) TRUE;

        case XTYP_CONNECT_CONFIRM:
            return (HDDEDATA) NULL;

        case XTYP_DISCONNECT:
            {
                int id;

                if (IsCurrentPlayer(hConv, &id))
                    PlayerQuit(id);
            }

            return (HDDEDATA) NULL;

        case XTYP_ERROR:
            return (HDDEDATA) NULL;

        case XTYP_EXECUTE:
            return (HDDEDATA) NULL;

        case XTYP_POKE:
            if (hsz2 == hszJoin)
            {
                // add new player and inform others of new arrival

                if (CountClients() < 3)
                {
                    AddNewPlayer(hConv, hData);
                    ddeServer->PostAdvise(hszStatus);
                    return (HDDEDATA) DDE_FACK;
                }
                else
                    return (HDDEDATA) DDE_FBUSY;
            }
            else if (hsz2 == hszPass)
            {
                // client notifies server of 3 cards to pass

                ReceivePassFromClient(hData);
                HandlePassing();
                return (HDDEDATA) DDE_FACK;
            }
            else if (hsz2 == hszMove)
            {
                // client informs server of card played

                ddeServer->GetData(hData, (PBYTE)&::move, sizeof(::move));
                ddeServer->PostAdvise(hszMove);
                ReceiveMove(::move);
                return (HDDEDATA) DDE_FACK;
            }
            else if (hsz2 == hszPassUpdate)
            {
                // Client just shuffled and wants to know who has passed so far.
                // Be sure we're not still looking at score.

                int mode = GetPlayerMode(0);
                if (mode == SELECTING || mode == DONE_SELECTING)
                    ddeServer->PostAdvise(hszPass);
            }
            else
                return (HDDEDATA) DDE_FNOTPROCESSED;

        case XTYP_REGISTER:
            return (HDDEDATA) NULL;

        case XTYP_REQUEST:

            // when client first joins game, he asks for update on names
            // of other players already in the game

            if (hsz2 == hszStatus)
                return GetGameStatus(hConv);
            else
                return (HDDEDATA) NULL;

        case XTYP_UNREGISTER:
            return (HDDEDATA) NULL;

        case XTYP_WILDCONNECT:
            return (HDDEDATA) NULL;

        default:
            return (HDDEDATA) NULL;
    }
}


/****************************************************************************

DdeClientCallback()

****************************************************************************/

HDDEDATA EXPENTRY EXPORT DdeClientCallBack(WORD wType, WORD wFmt, HCONV hConv,
                                    HSZ hsz1, HSZ hsz2, HDDEDATA hData,
                                    DWORD dwData1, DWORD dwData2)
{
    return ::pMainWnd->DdeCliCallBack(wType, wFmt, hConv, hsz1, hsz2, hData,
                                    dwData1, dwData2);
}

HDDEDATA CMainWindow::DdeCliCallBack(
WORD    wType,              // transaction type
WORD    wFmt,               // clipboard format
HCONV   hConv,              // handle to conversation
HSZ     hsz1,               // string handles
HSZ     hsz2,
HDDEDATA hData,             // handle to a global memory object
DWORD   dwData1,            // transaction-specific data
DWORD   dwData2)
{
    switch(wType)
    {
        case XTYP_ADVDATA:

            // advdata is sent whenever the server posts an advise
            // on topics client has set up an advise loop on

            if (hsz2 == hszStatus)
            {
                // someone new joined, and here's the names

                GAMESTATUS gs;
                ddeClient->GetData(hData, (PBYTE)&gs, sizeof(gs));
                UpdateStatusNames(gs);
                return (HDDEDATA) DDE_FACK;
            }
            else if (hsz2 == hszGameNumber)
            {
                // OnNewGame called, here's the game number

                int num;
                ddeClient->GetData(hData, (PBYTE)&num, sizeof(num));

                // Future versions of Hearts can use a negative number
                // in the gamenumber field to indicate a version.

                if (num < 0)
                    FatalError(IDS_VERSION);

                SetGameNumber(num);
                OnNewGame();
                return (HDDEDATA) DDE_FACK;
            }
            else if (hsz2 == hszPass)
            {
                // someone has passed, here's the update on everyone

                PASS12  pass12;

                ddeClient->GetData(hData, (PBYTE)&pass12, sizeof(pass12));

                UpdatePassStatus(pass12);
                HandlePassing();
                return (HDDEDATA) DDE_FACK;
            }
            else if (hsz2 == hszMove)
            {
                // someone has moved

                MOVE moveLocal;

                ddeClient->GetData(hData, (PBYTE)&moveLocal, sizeof(moveLocal));
                ReceiveMove(moveLocal);
                return (HDDEDATA) DDE_FACK;
            }
            else
                return (HDDEDATA) NULL;

        case XTYP_DISCONNECT:
            FatalError(IDS_DISCONNECT);
            return (HDDEDATA) NULL;

        case XTYP_ERROR:
            return (HDDEDATA) NULL;

        case XTYP_UNREGISTER:
            return (HDDEDATA) NULL;

        case XTYP_XACT_COMPLETE:
            return (HDDEDATA) NULL;

        default:
            return (HDDEDATA) NULL;
    }
}


/****************************************************************************
****************************************************************************/

// Server helper functions

/****************************************************************************

CMainWindow::AddNewPlayer()

After the server gets a valid request from a new player to join the game,
this function is called to create the new player object.

****************************************************************************/

int CMainWindow::AddNewPlayer(HCONV hConv, HDDEDATA hData)
{
    int id;             // only gamemeister calls this, so pos == id

    if (!p[2])          // new players get added in order 2, 1, 3
        id = 2;
    else if (!p[1])
        id = 1;
    else
        id = 3;

    p[id] = new remote_human(id, id, hConv);

    if (p[id] == NULL)
    {
        FatalError(IDS_MEMORY);
        return id;
    }

    CClientDC   dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    CString     name = ddeServer->GetDataString(hData);
    p[id]->SetName(name, dc);
    p[id]->DisplayName(dc);

    return id;
}


/****************************************************************************

CMainWindow::GetPass12()

This function gets called in response to the server calling PostAdvise(hszPass).
That happens when the gamemeister passes cards, when the gamemeister learns
that another player has passed cards, or when a client request an update
via Poke(hszPassUpdate).

****************************************************************************/

void CMainWindow::GetPass12(PASS12& pass12)
{
    pass12.passdir = passdir;

    for (int pos = 0; pos < MAXPLAYER; pos++)
        p[Pos2Id(pos)]->ReturnSelectedCards(pass12.cardid[pos]);
}


/****************************************************************************

CMainWindow::ReceivePassFromClient()

Called in reponse to a client poking hszPass info.

****************************************************************************/

void CMainWindow::ReceivePassFromClient(HDDEDATA hData)
{
    PASS3       pass3;

    ddeServer->GetData(hData, (PBYTE)&pass3, sizeof(pass3));

    // queue up pass info if gamemeister is still looking at score

    if (p[0]->GetMode() == SCORING)
    {
        ::passq[::cQdPasses++] = pass3;
        return;
    }
    else if (::cQdMoves > 0)
    {
        for (int i = 0; i < ::cQdPasses; i++)
            HandlePass(::passq[i]);

        ::cQdPasses = 0;
    }

    HandlePass(pass3);
}


/****************************************************************************

CMainWindow::HandlePass()

Called from ReceivePassFromClient() and also DispatchCards() in case any
passes were queued up when the gamemeister was looking at the score.

****************************************************************************/

void CMainWindow::HandlePass(PASS3& pass3)
{
    CClientDC   dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    int pos = pass3.id;                 // only gamemeister queues moves
    for (int i = 0; i < 3; i++)
    {
        SLOT s = p[pos]->GetSlot(pass3.cardid[i]);
        p[pos]->Select(s, TRUE);
    }
    p[pos]->SetMode(DONE_SELECTING);
    p[pos]->MarkSelectedCards(dc);
    ddeServer->PostAdvise(hszPass);
}


/****************************************************************************

CMainWindow::IsCurrentPlayer()

The gamemeister uses this function to determine if an XTYP_DISCONNECT
message comes from a currently active player, or whether it can just
be ignored.

****************************************************************************/

BOOL CMainWindow::IsCurrentPlayer(HCONV hConv, int *id)
{
    BOOL bResult = FALSE;

    for (int i = 1; i < MAXPLAYER; i++)
        if (p[i])
            if (hConv == p[i]->GetConv())
            {
                bResult = TRUE;
                *id = i;
            }

    return bResult;
}


/****************************************************************************

CMainWindow::GetGameStatus()

Returns a dde handle with current active players' names and ids.

****************************************************************************/

HDDEDATA CMainWindow::GetGameStatus(HCONV hConv)
{
    GAMESTATUS gs;

    gs.id = -1;             // error value if not reset

    for (int i = 0; i < MAXPLAYER; i++)
    {
        if (p[i])
        {
            lstrcpy(gs.name[i], p[i]->GetName());
            if (p[i]->GetConv() == hConv)
            {
                gs.id = i;
            }
        }
        else
            gs.name[i][0] = '\0';
    }

    return dde->CreateDataHandle(&gs, sizeof(gs), hszStatus);
}


/****************************************************************************

CMainWindow::UpdatePassStatus()

Fills a PASS12 structure with current pass information.

****************************************************************************/

void CMainWindow::UpdatePassStatus(PASS12& pass12)
{
    CClientDC   dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    for (int id = 0; id < MAXPLAYER; id++)
    {
        if (pass12.cardid[id][0] != EMPTY)
        {
            int pos = Id2Pos(id);
            if (pos != 0)                   // if it's not me
            {
                if (p[pos]->GetMode() == SELECTING)
                {
                    for (int i = 0; i < 3; i++)
                    {
                        SLOT slot = p[pos]->GetSlot(pass12.cardid[id][i]);
                        p[pos]->Select(slot, TRUE);
                    }
                    p[pos]->MarkSelectedCards(dc);
                    p[pos]->SetMode(DONE_SELECTING);
                }
            }
        }
    }
}


/****************************************************************************

CMainWindow::PlayerQuit()

The gamemeister has been notified that a currently active player has
disconnected.

****************************************************************************/

void CMainWindow::PlayerQuit(int id)
{
    // If hearts is running only because it has been autostarted, and
    // the autostarted leaves, you might as well shut down.  Note that
    // bAutostarted is set to FALSE as soon as the dealer actually
    // starts a game.

    if (bAutostarted && (id == 2))
        PostMessage(WM_CLOSE);

    p[id]->Quit();                          // mark this player as quitting

    modetype mode = p[id]->GetMode();

    // change name to [name]

    CString name = p[id]->GetName();
    CString newname = "[" + name + "]";

    CClientDC   dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    p[id]->SetName(newname, dc);
    p[id]->DisplayName(dc);

    if (mode == SELECTING)
    {
        p[id]->SelectCardsToPass();
        ddeServer->PostAdvise(hszPass);     // let others put up white dots

        BOOL bReady = TRUE;                 // time to ungray pass button?

        for (int i = 1; i < MAXPLAYER; i++)
            if (p[i]->GetMode() != DONE_SELECTING)
                bReady = FALSE;

        if (bReady)
            HandlePassing();
    }
    else if (mode == PLAYING)
    {
        p[id]->SelectCardToPlay(handinfo, bCheating);
    }

    ddeServer->PostAdvise(hszStatus);   // let others know quitter is [quitter]
}


/****************************************************************************
****************************************************************************/

// Helper functions used by both server and client

/****************************************************************************

CMainWindow::ReceiveMove()

Move data has been received.  Determine if the move can be handled now
or if it must be queued.

****************************************************************************/

void CMainWindow::ReceiveMove(MOVE& move)
{
    if (move.playerid == m_myid)        // don't have to handle my own moves
        return;

    int mode = p[0]->GetMode();
    if (mode == ACCEPTING || mode == SCORING || bTimerOn)
    {
        ::moveq[::cQdMoves++] = move;
        return;
    }
    else if (::cQdMoves > 0)
    {
        for (int i = 0; i < ::cQdMoves; i++)
            HandleMove(::moveq[i]);

        ::cQdMoves = 0;
    }

    HandleMove(move);
}


/****************************************************************************

CMainWindow::Handle Move()

This is called either from ReceiveMove() or from some other function that
has temporarily suspended move processing and is now clearing out its
move queue.

****************************************************************************/

void CMainWindow::HandleMove(MOVE& move)
{
    int pos = Id2Pos(move.playerid);
    SLOT s = p[pos]->GetSlot(move.cardid);

    ASSERT(s >= 0);
    ASSERT(s < MAXSLOT);
    ASSERT(p[pos]->Card(s)->IsValid());

    p[pos]->SetMode(WAITING);
    p[pos]->MarkCardPlayed(s);
    handinfo.cardplayed[move.playerid] = p[pos]->Card(s);
    OnRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\debug.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

//  Aug 92, JimH

#if defined(_DEBUG)

extern TCHAR suitid[];
extern TCHAR cardid[];

#define  PLAY(s)   { int v = cd[s].Value2() + 1;\
                     if (v < 11) { TRACE1("play %d", v); } else\
                     { TRACE1("play %c", cardid[v-11]); } \
                     TRACE1("%c. ", suitid[cd[s].Suit()]); }

#define  CDNAME(c) { int v = c->Value2() + 1;\
                     if (v < 11) { TRACE("%d", v); } else\
                     { TRACE("%c", cardid[v-11]); } \
                     TRACE("%c ", suitid[c->Suit()]); }

#define  DUMP()      Dump(afxDump)

#else
#define PLAY(s)
#define CDNAME(c)
#define DUMP()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\dde.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/


/****************************************************************************

dde.cpp

Aug 92, JimH
May 93, JimH    chico port

Member functions for DDE, DDEServer, and DDEClient are here.

****************************************************************************/

#include "hearts.h"

#include "dde.h"
#include "debug.h"

// declare DDE objects

DDEClient   *ddeClient;
DDEServer   *ddeServer;


/****************************************************************************

DDE:DDE
    performs basic DDEML initialization.
    m_bResult is TRUE if everything works.

****************************************************************************/

DDE::DDE(const TCHAR *server, const TCHAR *topic, DDECALLBACK CallBack,
         DWORD filters) : m_idInst(0), m_CallBack(NULL)
{
    // Check for basic compatibility, ie protect mode

//    m_bResult = ( (LOBYTE(GetVersion()) > 2) && (GetWinFlags() & WF_PMODE) )
//        ? TRUE : FALSE;
	m_bResult = TRUE;
    if (!m_bResult)
        return;

    m_data.Empty();         // clear CString object

    // Set callback function and filters from passed-in parameters

    if (!SetCallBack(CallBack))
        return;

    SetFilters(filters);
    if (!Initialize())
    {
        m_idInst = 0;
        return;
    }

    // create CString objects and HSZ handles for server and topic

    m_server = server;
    m_topic  = topic;
    m_hServer = CreateStrHandle(m_server);
    m_hTopic  = CreateStrHandle(m_topic);
}


/****************************************************************************

DDE::~DDE
    cleans up string handles and DDEML-uninitializes

****************************************************************************/

DDE::~DDE()
{
    if (!m_idInst)
        return;

    DestroyStrHandle(m_hServer);
    DestroyStrHandle(m_hTopic);

    ::DdeUninitialize(m_idInst);
    FreeProcInstance((FARPROC)m_CallBack);
}


/****************************************************************************

DDE:CreateDataHandle
    converts data to a HDDEDATA handle.

****************************************************************************/

HDDEDATA DDE::CreateDataHandle(void FAR *pdata, DWORD size, HSZ hItem)
{
    return ::DdeCreateDataHandle(m_idInst,       // instance ID
                                 (LPBYTE)pdata,  // data to convert
                                 size,           // size of data
                                 0,              // offset of data
                                 hItem,          // corresponding string handle
                                 CF_OWNERDISPLAY,// clipboard format
                                 0);             // creation flags, system owns
}


/****************************************************************************

DDE:CreateStrHandle
    converts a string into a HSZ.  The codepage defaults to CP_WINANSI.

****************************************************************************/

HSZ DDE::CreateStrHandle(LPCTSTR str, int codepage)
{
    HSZ hsz = NULL;

    if (m_idInst)
        hsz = ::DdeCreateStringHandle(m_idInst, str, codepage);

    if (hsz == NULL)
        m_bResult = FALSE;

    return hsz;
}


/****************************************************************************

DDE::DestroyStrHandle
    frees HSZ created by CreateStrHandle

****************************************************************************/

void DDE::DestroyStrHandle(HSZ hsz)
{
    if (m_idInst && hsz)
        ::DdeFreeStringHandle(m_idInst, hsz);
}


/****************************************************************************

DDE:GetData
    Like GetDataString, this function retrieves data represented by
    hData provided in callback function.  However, the buffer must be
    provided by the caller.  The len parameter defaults to 0 meaning
    the caller promises pdata points to a large enough buffer.

****************************************************************************/

PBYTE DDE::GetData(HDDEDATA hData, PBYTE pdata, DWORD len)
{
    DWORD datalen = ::DdeGetData(hData, NULL, 0, 0);
    if (len == 0)
        len = datalen;
    ::DdeGetData(hData, pdata, min(len, datalen), 0);
    return pdata;
}


/****************************************************************************

DDE:GetDataString
    The default value of hData is NULL meaning just return the current
    m_data string.  Otherwise get associated DDE data.  The caller does
    not have to provide a CString buffer.

****************************************************************************/

CString DDE::GetDataString(HDDEDATA hData)
{
    if (hData == NULL)          // default paramenter
        return m_data;

    DWORD len = ::DdeGetData(hData, NULL, 0, 0);      // find length
    TCHAR *pdata = m_data.GetBuffer((int)len);
    ::DdeGetData(hData, (LPBYTE)pdata, len, 0);
    m_data.ReleaseBuffer();
    return m_data;
}


/****************************************************************************

DDE::Initialize
    performs DDEML initialization

****************************************************************************/

BOOL DDE::Initialize()
{
    m_initerr = (WORD)::DdeInitialize(&m_idInst, (PFNCALLBACK)m_CallBack,
                 m_filters, 0);
    m_bResult = (m_initerr == DMLERR_NO_ERROR);
    return m_bResult;
}


/****************************************************************************

DDE::SetCallBack

****************************************************************************/

BOOL DDE::SetCallBack(DDECALLBACK CallBack)
{
    if (m_CallBack)
        FreeProcInstance((FARPROC)m_CallBack);

    m_CallBack = (DDECALLBACK)MakeProcInstance((FARPROC)CallBack,
                                                AfxGetInstanceHandle());

    m_bResult = (m_CallBack != NULL);
    return m_bResult;
}


/****************************************************************************
    DDEServer functions
****************************************************************************/
/****************************************************************************

DDEServer::DDEServer
    registers server name

****************************************************************************/

DDEServer::DDEServer(const TCHAR *server, const TCHAR *topic,
                     DDECALLBACK ServerCallBack, DWORD filters) :
                     DDE(server, topic, ServerCallBack, filters)
{
    if (!m_bResult)
        return;

    if (::DdeNameService(m_idInst, m_hServer, NULL, DNS_REGISTER) == 0)
        m_bResult = FALSE;
}


/****************************************************************************

DDEServer::~DDEServer
    unregisters server name

****************************************************************************/

DDEServer::~DDEServer()
{
    ::DdeNameService(m_idInst, NULL, NULL, DNS_UNREGISTER);
}


/****************************************************************************

DDEServer::PostAdvise
    notify clients that data has changed

****************************************************************************/

BOOL DDEServer::PostAdvise(HSZ hItem)
{
    return ::DdePostAdvise(m_idInst, m_hTopic, hItem);
}


/****************************************************************************
    DDEClient functions
****************************************************************************/
/****************************************************************************

DDEClient::DDEClient
    after DDE construction, connect to specified server and topic.
    m_bResult indicates success or failure.

****************************************************************************/

DDEClient::DDEClient(const TCHAR *server, const TCHAR *topic,
                     DDECALLBACK ClientCallBack, DWORD filters) :
                     DDE(server, topic, ClientCallBack, filters)
{
    if (!m_bResult)             // if DDE construction failed
        return;

    m_timeout = m_deftimeout = TIMEOUT_ASYNC;   // default to asynch trans

    m_hConv = ::DdeConnect(m_idInst, m_hServer, m_hTopic, NULL);
    if (m_hConv == NULL)
        m_bResult = FALSE;
}


/****************************************************************************

DDEClient::~DDEClient
    disconnects from server

****************************************************************************/

DDEClient::~DDEClient()
{
    ::DdeDisconnect(m_hConv);
}


/****************************************************************************

DDEClient:Poke
    Use this function to send general unsolicited data to the server.
    String data can be sent more conveniently using string Poke below.

****************************************************************************/

BOOL DDEClient::Poke(HSZ hItem, void FAR *pdata, DWORD len, DWORD uTimeout)
{
    if (uTimeout == NULL)   // default
        m_timeout = m_deftimeout;
    else
        m_timeout = uTimeout;

    ClientTransaction((LPBYTE)pdata, len, hItem, XTYP_POKE, CF_OWNERDISPLAY);
    return m_bResult;
}

BOOL DDEClient::Poke(HSZ hItem, const TCHAR *string, DWORD uTimeout)
{
    if (uTimeout == NULL)   // default
        m_timeout = m_deftimeout;
    else
        m_timeout = uTimeout;

    ClientTransaction((void FAR *)string, lstrlen(string)+1, hItem, XTYP_POKE);
    return m_bResult;
}


/****************************************************************************

DDEClient::RequestString
DDEClient::RequestData
    These request a synchronous update from server on specified item.

    RequestString returns a BOOL which says if the request succeeded.
    Get the result from GetDataString(void).

    RequestData returns a HDDEDATA.  If it is not NULL, pass it to
    GetData() along with a buffer to copy the result in to.

****************************************************************************/

BOOL DDEClient::RequestString(HSZ hItem, DWORD uTimeout)
{
    if (uTimeout == NULL)   // default
        m_timeout = m_deftimeout;
    else
        m_timeout = uTimeout;

    HDDEDATA hData = ClientTransaction(NULL, 0, hItem, XTYP_REQUEST);

    if (m_bResult)
        GetDataString(hData);
    else
        m_data.Empty();

    return m_bResult;
}

HDDEDATA DDEClient::RequestData(HSZ hItem, DWORD uTimeout)
{
    if (uTimeout == NULL)   // default
        m_timeout = m_deftimeout;
    else
        m_timeout = uTimeout;

    HDDEDATA hData = ClientTransaction(NULL, 0, hItem, XTYP_REQUEST,
                        CF_OWNERDISPLAY);
    return hData;
}


/****************************************************************************

DDEClient::StartAdviseLoop
    This function sets up a hotlink with the server on the specified item.
    It returns TRUE if the link was set up successfully.

    Setting up a warm link would involve changing the XTYP.

****************************************************************************/

BOOL DDEClient::StartAdviseLoop(HSZ hItem)
{
    ClientTransaction(NULL, 0, hItem, XTYP_ADVSTART);
    return m_bResult;
}


/****************************************************************************

DDEClient::ClientTransaction
    an internal wrapper for ::DdeClientTransaction()

****************************************************************************/

HDDEDATA DDEClient::ClientTransaction(void FAR *lpvData, DWORD cbData,
                                      HSZ hItem, UINT uType, UINT uFmt)
{
    HDDEDATA hData = ::DdeClientTransaction(
            (LPBYTE)lpvData,    // data to send to server
            cbData,             // size of data in bytes
            m_hConv,            // conversation handle
            hItem,              // handle of item name string
            uFmt,               // clipboard format
            uType,              // XTYP_* type
            m_timeout,          // timeout duration in milliseconds
            NULL);              // transaction result, not used

    m_bResult = (hData != FALSE);

    return hData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\dde.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/


/****************************************************************************

dde.h

Aug 92, JimH

Header file for DDE objects (DDEClient, and DDEServer.)  DDE is not meant to
be instantiated directly.

Class DDE
   This superclass requires both a server name and a topic name for which
   it creates and destroys string handles.  Servers technically do not
   need the topic name to instantiate, but they generally need at least
   one to do useful things, so it is provided here.  Clients require the
   topic name to connect.  DDE also requires a dde callback function pointer.
   Type DDECALLBACK is defined for this purpose.

   DDE provides a convenient way to retrieve dde data from within
   callback functions, especially string data in CString objects via
   GetDataString(hData).  Structures can also be retrieved, but in that
   case memory must be allocated prior to the GetData() call.

   Some built-in methods return a BOOL to determine success.  Others (like
   the constructor) cannot, so use GetResult() for current status.  If it
   is FALSE, GetLastError() can be useful.

Class DDEServer : DDE
   This is a very simple extension.  The contructor registers the server
   name and the destructor unregisters it.  Most of the work for DDEML
   servers is done in the server callback function, not here.

Class DDEClient : DDE
   This is used to instantiate a client-only DDE object.  New methods
   request new data (RequestString) set up hot links (StartAdviseLoop)
   and send unsolicited data (Poke.)

****************************************************************************/

#ifndef	DDE_INC
#define	DDE_INC

#include <ddeml.h>

typedef HDDEDATA (EXPENTRY *DDECALLBACK) (WORD, WORD, HCONV, HSZ, HSZ, HDDEDATA, DWORD, DWORD);
HDDEDATA EXPENTRY EXPORT DdeServerCallBack(WORD, WORD, HCONV, HSZ, HSZ, HDDEDATA, DWORD, DWORD);
HDDEDATA EXPENTRY EXPORT DdeClientCallBack(WORD, WORD, HCONV, HSZ, HSZ, HDDEDATA, DWORD, DWORD);

class DDE
{
    public:
        DDE(const TCHAR *server, const TCHAR *topic, DDECALLBACK CallBack,
            DWORD filters = APPCLASS_STANDARD);
        virtual ~DDE();
        HDDEDATA CreateDataHandle(void FAR *pdata, DWORD size, HSZ hItem);
        HSZ     CreateStrHandle(LPCTSTR str, int codepage = CP_WINANSI);
        void    DestroyStrHandle(HSZ hsz);
        PBYTE   GetData(HDDEDATA hData, PBYTE pdata, DWORD len = 0);
        CString GetDataString(HDDEDATA hData = NULL);
        WORD    GetInitError()      { return m_initerr; }
        UINT    GetLastError()      { return ::DdeGetLastError(m_idInst); }
        BOOL    GetResult()         { return m_bResult; }
        CString GetServer()         { return m_server; }
        CString GetTopic()          { return m_topic; }
        BOOL    SetCallBack(DDECALLBACK CallBack);
        void    SetFilters(DWORD filters) { m_filters = filters; }

    private:
        BOOL    Initialize(void);

        DDECALLBACK m_CallBack;
        DWORD   m_filters;          // filters passed to ::DdeInitialize()
        WORD    m_initerr;          // return error from ::DdeInitialize()

    protected:
        DWORD   m_idInst;           // instance id from ::DdeInitialize()
        BOOL    m_bResult;          // current state of object
        CString m_data;             // last string acquired from GetDataString()
        CString m_server, m_topic;  // server and topic names
        HSZ     m_hServer, m_hTopic;
};


class DDEServer : public DDE
{
    public:
        DDEServer(const TCHAR *server, const TCHAR *topic,
                  DDECALLBACK ServerCallBack,
                  DWORD filters = APPCLASS_STANDARD);
        ~DDEServer(void);
        BOOL    PostAdvise(HSZ hItem);
};


class DDEClient : public DDE
{
    public:
        DDEClient(const TCHAR *server, const TCHAR *topic,
                DDECALLBACK ClientCallBack,
                DWORD filters = APPCMD_CLIENTONLY | CBF_FAIL_SELFCONNECTIONS);
        ~DDEClient(void);

        BOOL    Poke(HSZ hItem, const TCHAR *string, DWORD uTimeout = NULL);
        BOOL    Poke(HSZ hItem, void FAR *pdata, DWORD len,
                        DWORD uTimeout = NULL);
        void    SetTimeOut(DWORD timeout) { m_timeout = timeout; }
        HDDEDATA RequestData(HSZ hItem, DWORD uTimeout = NULL);
        BOOL    RequestString(HSZ hItem, DWORD uTimeout = NULL);
        BOOL    StartAdviseLoop(HSZ hItem);

    private:
        HDDEDATA ClientTransaction(void FAR *lpvData, DWORD cbData, HSZ hItem,
                                   UINT uType, UINT uFmt = CF_TEXT);

        HCONV   m_hConv;        // conversation handle from ::DdeConnect()
        DWORD   m_timeout;      // timeout used in ::DdeClientTransaction()
        DWORD   m_deftimeout;   // default timeout
};

extern  DDEClient   *ddeClient;
extern  DDEServer   *ddeServer;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\dlg.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

dlg.h

Aug 92, JimH

Dialog classes are declared here.

CScoreDlg       shows current score sheet

CQuoteDlg       quote dialog

CWelcomeDlg     welcome to hearts, do you want to be GameMeister?

COptionsDlg     set options

****************************************************************************/

#ifndef	DLG_INC
#define	DLG_INC

typedef WORD (FAR PASCAL *BROWSEPROC)(HWND, LPCSTR, LPSTR, UINT, LONG);

const int   MAXHANDS = 12;      // can display this many in score sheet
const int   MAXPLAYER = 4;
const int   UNKNOWN = -1;       // third BOOL value

class CScoreDlg : public CModalDialog
{
    public:
        CScoreDlg(CWnd *pParent);
        CScoreDlg(CWnd *pParent, int s[MAXPLAYER], int id);
        BOOL    IsGameOver()        { return bGameOver; }
        void    ResetScore()        { nHandsPlayed = 0; bGameOver = FALSE; }
        void    SetText();

    private:
        CStatic *text[MAXPLAYER];
        int     m_myid;

        static  int  score[MAXPLAYER][MAXHANDS+1];
        static  int  nHandsPlayed;
        static  BOOL bGameOver;

        virtual BOOL OnInitDialog();
        afx_msg void OnPaint();

        DECLARE_MESSAGE_MAP()
};

class CQuoteDlg : public CModalDialog
{
    public:
        CQuoteDlg(CWnd *pParent);
        afx_msg void OnPaint();

        DECLARE_MESSAGE_MAP()
};

class CWelcomeDlg : public CModalDialog
{
    public:
        CWelcomeDlg(CWnd *pParent);
        virtual BOOL OnInitDialog();
        virtual void OnOK();
        CString GetMyName()         { return m_myname; }
        BOOL    IsGameMeister()     { return m_bGameMeister; }
        BOOL    IsNetDdeActive();

        afx_msg void OnHelp();

    private:
        CString m_myname;
        BOOL    m_bGameMeister;
        BOOL    m_bNetDdeActive;

        DECLARE_MESSAGE_MAP()
};

class COptionsDlg : public CModalDialog
{
    public:
        COptionsDlg(CWnd *pParent);
        virtual BOOL OnInitDialog();
        virtual void OnOK();

    private:
        BOOL    IsAutoStart(BOOL bToggle = FALSE);

        BOOL    m_bInitialState;
        BYTE    m_buffer[200];
};

class CLocateDlg : public CModalDialog
{
    public:
        CLocateDlg(CWnd *pParent);
        virtual BOOL OnInitDialog();
        virtual void OnOK();
        CString GetServer()         { return m_server; }
        afx_msg void OnBrowse();
        afx_msg void OnHelp();

    private:
        CString     m_server;
        HINSTANCE   m_hmodNetDriver;

        DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\hearts.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

hearts.cpp

Main file for Microsoft Hearts Network.

Aug 92, JimH
May 93, JimH    chico port

****************************************************************************/

#include "hearts.h"
#include "debug.h"

extern "C" void _setargv() { }      // reduces size of C runtimes
extern "C" void _setenvp() { }

TCHAR   suitid[] = TEXT("CDHS");
TCHAR   cardid[] = TEXT("JQKA");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\dlg.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

dlg.cpp

Aug 92, JimH
May 93, JimH    chico port

Dialog classes are defined here.

CScoreDlg       shows current score sheet

CQuoteDlg       quote dialog

CWelcomeDlg     welcome to Hearts, wanna be gamemeister?

COptionsDlg     set options

CLocateDlg      locate dealer

****************************************************************************/

#include "hearts.h"

#include "resource.h"
#include "main.h"
#include "debug.h"
#include "helpnum.h"
#include "stdlib.h"

#include <nddeapi.h>

typedef int (CALLBACK* FPROC)();            // a FARPROC that returns int

// NDDE typedefs for ShareGetInfo and ShareSetInfo (SGI and SSI)

typedef UINT (WINAPI *SGIPROC)(LPSTR, LPCSTR, UINT, LPBYTE, DWORD, LPDWORD, LPWORD);
typedef UINT (WINAPI *SSIPROC)(LPSTR, LPCSTR, UINT, LPBYTE, DWORD, WORD);


// declare statics

int  CScoreDlg::nHandsPlayed = 0;
int  CScoreDlg::score[MAXPLAYER][MAXHANDS+1];
BOOL CScoreDlg::bGameOver = FALSE;

BEGIN_MESSAGE_MAP( CScoreDlg, CModalDialog )
    ON_WM_PAINT()
END_MESSAGE_MAP()


/****************************************************************************

CScoreDlg constructors

The first constructor takes only one argument, the pointer to the class
of the parent window.  It is used to display the current score at
arbitrary points in the game, ie when the user requests it.

The second also updates the static score array with new information.

****************************************************************************/

CScoreDlg::CScoreDlg(CWnd *pParent) : CModalDialog(DLG_SCORE, pParent),
                                      m_myid(-1)
{

}

CScoreDlg::CScoreDlg(CWnd *pParent, int s[MAXPLAYER], int id) :
            CModalDialog(DLG_SCORE, pParent), m_myid(id)
{
    if (nHandsPlayed == MAXHANDS)
    {
        for (int hand = 1; hand < MAXHANDS; hand++)
            for (int player = 0; player < MAXPLAYER; player++)
                score[player][hand-1] = score[player][hand];

        nHandsPlayed--;
    }

    // add latest scores to list

    for (int player = 0; player < MAXPLAYER; player++)
        score[player][nHandsPlayed] = s[player];

    nHandsPlayed++;
}


/****************************************************************************

CScoreDlg::OnInitDialog

****************************************************************************/

BOOL CScoreDlg::OnInitDialog()
{
    RECT rcDlg, rcMain;

    GetParent()->GetClientRect(&rcMain);
    GetParent()->ClientToScreen(&rcMain);
    rcMain.bottom -= ::nStatusHeight;
    GetWindowRect(&rcDlg);

    int dxDlg = rcDlg.right - rcDlg.left;
    int dxMain = rcMain.right - rcMain.left;
    int x = rcMain.left + ((dxMain - dxDlg) / 2);

    int dyDlg = rcDlg.bottom - rcDlg.top;
    int dyMain = rcMain.bottom - rcMain.top;
    int y = rcMain.top + ((dyMain - dyDlg) / 2);

    SetWindowPos(NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
    SetText();          // set title bar text
    return TRUE;
}


/****************************************************************************

CScoreDlg::SetText  -- set title bar text

****************************************************************************/

void CScoreDlg::SetText()
{
    CString s, s2;

    s.LoadString(IDS_SCORESHEET);

    if (nHandsPlayed != 0)
    {
        int place = 0;
        for (int i = 1; i < MAXPLAYER; i++)
            if (score[i][nHandsPlayed-1] < score[0][nHandsPlayed-1])
                place++;

        s2.LoadString(IDS_PLACE1 + place);
        s += " -- ";
        s += s2;
    }

    SetWindowText(s);
}


/****************************************************************************

CScoreDlg::OnPaint

The score text is not drawn with text controls because the strikeout
text is needed for some parts of the score.  Instead, the paint message
is hooked here.

****************************************************************************/

void CScoreDlg::OnPaint()
{
    BYTE charset = 0;
    int	fontsize = 0; 
    CString fontname, charsetstr, fontsizestr;
    fontname.LoadString(IDS_FONTFACE);
    charsetstr.LoadString(IDS_CHARSET);
    fontsizestr.LoadString(IDS_FONTSIZE);
    charset = (BYTE)_ttoi((const TCHAR *)charsetstr);
    fontsize = _ttoi((const TCHAR *)fontsizestr);

    // Nobody has best score if game hasn't started yet

    int nBestScore = (nHandsPlayed == 0 ? 0 : 30000);
    int nWorstScore = 0;

    if (nHandsPlayed > 0)
    {
        for (int pos = 0; pos < MAXPLAYER; pos++)
        {
            if (score[pos][nHandsPlayed-1] < nBestScore)
            {
                nBestScore = score[pos][nHandsPlayed-1];
            }
            if (score[pos][nHandsPlayed-1] > nWorstScore)
            {
                nWorstScore = score[pos][nHandsPlayed-1];
            }
        }
    }

    // If the game is over, display appropriate text in title bar

    if (nWorstScore >= 100)
    {
        CString title;

        if (score[0][nHandsPlayed-1] == nBestScore)
            title.LoadString(IDS_GAMEOVERWIN);
        else
            title.LoadString(IDS_GAMEOVER);

        SetWindowText(title);
        bGameOver = TRUE;
    }

    CPaintDC dc(this);
    CRect rect;
    GetClientRect(&rect);

    // Divide the dialog up into columns for displaying scores

    rect.right -= 5;                // 5 pixels on left, overlap on right
    int nWidth = rect.right / 5;
    rect.bottom -= 10;              // 5 pixels on top and bottom
    int nHeight = rect.bottom;
    CString text, s;
    dc.SetBkMode(TRANSPARENT);

    // If game is over, change the appearance of the dialog so people
    // notice it.  The section below adds the icon under the OK button.

    if (bGameOver)
    {
        HICON    hIcon = ::LoadIcon(AfxGetInstanceHandle(),
                              MAKEINTRESOURCE(AFX_IDI_STD_FRAME));

        int x = (nWidth * 4) + ((nWidth - 32) / 2);
        int y = 75;

        dc.DrawIcon(x, y, hIcon);
        // CRect   rectIcon(x-10, y-10, x+32+10, y+32+10);
        // FrameRect(rectIcon);
    }

    // create Helv 8 bold font, and Helv 8 bold strikeout font

    CFont   font, strikefont;
    font.CreateFont(fontsize, 0, 0, 0, 700, 0, 0, 0, charset, 0, 0, 0, 0, fontname);
    strikefont.CreateFont(fontsize, 0, 0, 0, 700, 0, 0, 1, charset, 0, 0, 0, 0, fontname);
    CFont *oldfont = dc.SelectObject(&font);

    for (int pos = 0; pos < MAXPLAYER; pos++)
    {
        int red = 127;      // ega needed special processing here

        if (nHandsPlayed > 0)
            if (score[pos][nHandsPlayed-1] == nBestScore)
                dc.SetTextColor(bGameOver ? RGB(red, 0, 0) : RGB(0, 0, 255));

        text = ((CMainWindow *)::pMainWnd)->GetPlayerName(pos);

        // The line below allows overlapping of names at top of score dlg.
        // To disallow overlapping, use:
        // rect.SetRect(5 + (nWidth*pos), 5, 5 + (nWidth*(pos+1)), nHeight);

        rect.SetRect((nWidth*pos) - 5, 5, 15 + (nWidth*(pos+1)), nHeight);
        int nTextHeight = dc.DrawText(text, -1, &rect, DT_CENTER | DT_NOPREFIX);
        rect.top += nTextHeight;

        dc.SelectObject(&strikefont);
        text.Empty();
        for (int hand = 0; hand < (nHandsPlayed - 1); hand++)
        {
            wsprintf(s.GetBuffer(20), TEXT("%d\r\n"), score[pos][hand]);
            s.ReleaseBuffer();
            text += s;
        }
        dc.DrawText(text, -1, &rect, DT_CENTER);
        rect.top += (nTextHeight * (nHandsPlayed - 1));

        dc.SelectObject(&font);
        if (nHandsPlayed > 0)
        {
            wsprintf(text.GetBuffer(20), TEXT("%d"), score[pos][nHandsPlayed-1]);
            text.ReleaseBuffer();
        }
        dc.DrawText(text, -1, &rect, DT_CENTER);
        dc.SetTextColor(0);
    }

    dc.SelectObject(oldfont);
}


/****************************************************************************

CQuoteDlg

****************************************************************************/

BEGIN_MESSAGE_MAP( CQuoteDlg, CModalDialog )
    ON_WM_PAINT()
END_MESSAGE_MAP()

/****************************************************************************

CQuoteDlg constructor

****************************************************************************/

CQuoteDlg::CQuoteDlg(CWnd *pParent) : CModalDialog(DLG_QUOTE, pParent)
{

}


/****************************************************************************

CQuoteDlg::OnPaint

This used to draw an icon and a 3d frame.  Now it just draws the icon.

****************************************************************************/

void CQuoteDlg::OnPaint()
{
    CPaintDC dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    HICON    hIcon = ::LoadIcon(AfxGetInstanceHandle(),
                          MAKEINTRESOURCE(AFX_IDI_STD_FRAME));

    int x = 24;
    int y = 24;
    dc.DrawIcon(x, y, hIcon);
    // CRect rectIcon(x-10, y-10, x+32+10, y+32+10);
    // FrameRect(rectIcon);
}


/****************************************************************************

CWelcomeDlg

****************************************************************************/

BEGIN_MESSAGE_MAP( CWelcomeDlg, CModalDialog )
    ON_BN_CLICKED(IDC_WELCOMEHELP,  OnHelp)
END_MESSAGE_MAP()

/****************************************************************************

CWelcomeDlg constructor

****************************************************************************/

CWelcomeDlg::CWelcomeDlg(CWnd *pParent) : CModalDialog(DLG_WELCOME, pParent),
        m_bNetDdeActive(UNKNOWN), m_bGameMeister(FALSE)
{
    RegEntry    Reg(szRegPath);
    TCHAR *pm_myname = m_myname.GetBuffer(MAXNAMELENGTH+1);
    Reg.GetString(regvalName, pm_myname, MAXNAMELENGTH+1);
    m_myname.ReleaseBuffer();
}


/****************************************************************************

CWelcomeDlg::OnInitDialog()

Restore settings from .ini file

****************************************************************************/

BOOL CWelcomeDlg::OnInitDialog()
{
#ifdef USENETDDE
    if (IsNetDdeActive())
    {
        RegEntry    Reg(szRegPath);

        if (Reg.GetNumber(regvalRole, FALSE))
            ((CButton *)GetDlgItem(IDC_MEISTER))->SetCheck(TRUE);
        else
            ((CButton *)GetDlgItem(IDC_JOIN))->SetCheck(TRUE);
    }
    else
    {
        ((CWnd *)GetDlgItem(IDC_GROUP))->EnableWindow(FALSE);
        ((CWnd *)GetDlgItem(IDC_JOIN))->EnableWindow(FALSE);
        ((CWnd *)GetDlgItem(IDC_MEISTER))->EnableWindow(FALSE);
    }
#endif

    CEdit *editname = (CEdit *)GetDlgItem(IDC_YOURNAME);
    editname->SetWindowText(m_myname);
    editname->LimitText(MAXNAMELENGTH);

    return TRUE;
}


/****************************************************************************

CWelcomeDlg::OnOK()

Don't allow empty name.  Store data in .ini file.

****************************************************************************/

void CWelcomeDlg::OnOK()
{
    GetDlgItemText(IDC_YOURNAME, m_myname.GetBuffer(MAXNAMELENGTH+1),
                  MAXNAMELENGTH+1);
    m_myname.ReleaseBuffer();

    if (m_myname.IsEmpty())
    {
        ((CEdit *)GetDlgItem(IDC_YOURNAME))->SetFocus();
        return;
    }

    if (IsNetDdeActive())
        m_bGameMeister = ((CButton *)GetDlgItem(IDC_MEISTER))->GetCheck();
    else
        m_bGameMeister = TRUE;

    RegEntry    Reg(szRegPath);

    Reg.SetValue(regvalRole, m_bGameMeister ? 1 : 0L);
    Reg.SetValue(regvalName, m_myname);

//    ::WinHelp(m_hWnd, szHelpFileName, HELP_QUIT, 0);

    EndDialog(IDOK);
}


/****************************************************************************

CWelcomeDlg::IsNetDdeActive()

This check is only done once.  m_bNetDdeActive starts as -1 (UNKNOWN).
The first time this function is called, a call to NDdeGetWindow returns
NULL if NETDDE is not loaded.  NetDDE is exec'd and the call is repeated.
If the call fails the second time, it is assumed NetDDE couldn't start
because no compatible NETBIOS was found.

****************************************************************************/

BOOL CWelcomeDlg::IsNetDdeActive()
{
    if (m_bNetDdeActive != UNKNOWN)
        return m_bNetDdeActive;

    m_bNetDdeActive = TRUE;             // assume true, then check

    SetErrorMode(SEM_NOOPENFILEERRORBOX);
    HINSTANCE hinstNDDEAPI = LoadLibrary(TEXT("NDDEAPI.DLL"));

    if (hinstNDDEAPI <= (HINSTANCE)HINSTANCE_ERROR)
    {
        m_bNetDdeActive = FALSE;
        return m_bNetDdeActive;
    }

    FPROC lpfnNDDEGetWindow = (FPROC) GetProcAddress(hinstNDDEAPI, "NDdeGetWindow");
    if (lpfnNDDEGetWindow == NULL)
    {
        FreeLibrary(hinstNDDEAPI);
        m_bNetDdeActive = FALSE;
        return m_bNetDdeActive;
    }

    if ((*lpfnNDDEGetWindow)() == NULL)         // look for netdde main window
    {
        UINT ret = WinExec("NETDDE.EXE", SW_SHOWNA);
        TRACE1("ret from WinExec is %u\n", ret);

        if ((*lpfnNDDEGetWindow)() == NULL)
            m_bNetDdeActive = FALSE;
    }

    FreeLibrary(hinstNDDEAPI);
    return m_bNetDdeActive;
}


/****************************************************************************

CWelcomeDlg::OnHelp()

****************************************************************************/

void CWelcomeDlg::OnHelp()
{
//    ::WinHelp(m_hWnd, szHelpFileName, HELP_CONTEXT, IDH_START_HOW_HRTS);
}


/****************************************************************************

COptionsDlg constructor

****************************************************************************/

COptionsDlg::COptionsDlg(CWnd *pParent) : CModalDialog(DLG_OPTIONS, pParent)
{

}


/****************************************************************************

COptionsDlg::OnInitDialog

Set dialog controls to current values

****************************************************************************/

BOOL COptionsDlg::OnInitDialog()
{
    RegEntry    Reg(szRegPath);

    // Set animation speed radio button

    DWORD dwSpeed = Reg.GetNumber(regvalSpeed, IDC_NORMAL);

    ((CButton *)GetDlgItem((int)dwSpeed))->SetCheck(TRUE);

    // Set current computer player names.  If they are not specified in
    // the .ini file, get defaults from the resource file.

    CEdit   *pName[3];
    CString sName[3];

    for (int i = 0; i < 3; i++)
    {
        pName[i] = (CEdit *)GetDlgItem(IDC_NAME1 + i);
        pName[i]->LimitText(MAXNAMELENGTH);
        TCHAR *p = sName[i].GetBuffer(MAXNAMELENGTH + 1);
        Reg.GetString(regvalPName[i], p, MAXNAMELENGTH+1);
        sName[i].ReleaseBuffer();

        if (sName[i].IsEmpty())
            sName[i].LoadString(IDS_P1NAME + i);

        pName[i]->SetWindowText(p);
    }

    // get current autostart state

    m_bInitialState = IsAutoStart();
//    ((CButton *)GetDlgItem(IDC_AUTO))->SetCheck(m_bInitialState);

    return TRUE;
}


/****************************************************************************

COptionsDlg::OnOK

save contol settings

****************************************************************************/

void COptionsDlg::OnOK()
{
    RegEntry    Reg(szRegPath);

    // save animation speed setting

    DWORD dwSpeed;
    int   nStepSize;

    if (((CButton *)GetDlgItem(IDC_FAST))->GetCheck())
    {
        dwSpeed = IDC_FAST;
        nStepSize = 60;
    }
    else if (((CButton *)GetDlgItem(IDC_SLOW))->GetCheck())
    {
        dwSpeed = IDC_SLOW;
        nStepSize = 5;
    }
    else
    {
        dwSpeed = IDC_NORMAL;
        nStepSize = 15;
    }

    card c;
    c.SetStepSize(nStepSize);
    Reg.SetValue(regvalSpeed, dwSpeed);

    // save computer player names

    for (int i = 0; i < 3; i++)
    {
        CString sDefault, sEdit;
        sDefault.LoadString(IDS_P1NAME + i);

        GetDlgItemText(IDC_NAME1 + i, sEdit.GetBuffer(MAXNAMELENGTH+1),
                      MAXNAMELENGTH+1);
        sEdit.ReleaseBuffer();

        if (sDefault == sEdit)
            Reg.DeleteValue(regvalPName[i]);
        else
            Reg.SetValue(regvalPName[i], sEdit);
    }

    // save autostart state

//    BOOL bState = ((CButton *)GetDlgItem(IDC_AUTO))->GetCheck();

//    if (bState != m_bInitialState)
//        IsAutoStart(TRUE);              // toggle state

    EndDialog(IDOK);
}


/****************************************************************************

COptionsDlg::IsAutoStart

returns autostart state, and optionally toggles it.  The bToggle
parameter is FALSE by default.

If bToggle is TRUE, this function returns the NEW state.

****************************************************************************/

BOOL COptionsDlg::IsAutoStart(BOOL bToggle)
{
#ifdef USENETDDE
    DWORD           dwAvail;
    WORD            wItems;
    BOOL            bStatus;
    CButton *check = (CButton *)GetDlgItem(IDC_AUTO);

    SetErrorMode(SEM_NOOPENFILEERRORBOX);
    HINSTANCE hinstNDDEAPI = LoadLibrary("NDDEAPI.DLL");

    if (hinstNDDEAPI <= (HINSTANCE)HINSTANCE_ERROR)
    {
        check->EnableWindow(FALSE);
        (CWnd *)GetDlgItem(IDC_AUTOGROUP)->EnableWindow(FALSE);
        return FALSE;
    }

    SGIPROC lpfnNDdeShareGetInfo =
        (SGIPROC) GetProcAddress(hinstNDDEAPI, "NDdeShareGetInfo");

    if (lpfnNDdeShareGetInfo == NULL)
    {
        check->EnableWindow(FALSE);
        (CWnd *)GetDlgItem(IDC_AUTOGROUP)->EnableWindow(FALSE);
        FreeLibrary(hinstNDDEAPI);
        return FALSE;
    }

    (*lpfnNDdeShareGetInfo)(NULL, szShareName, 2, m_buffer,
                    sizeof(m_buffer), &dwAvail, &wItems);

    NDDESHAREINFO *pnddeInfo = (NDDESHAREINFO *)m_buffer;

    bStatus = (pnddeInfo->dwPermissions1 == 31);

    if (bToggle)
    {
        pnddeInfo->dwPermissions1 = (bStatus ? 15 : 31);

        SSIPROC lpfnNDdeShareSetInfo =
            (SSIPROC) GetProcAddress(hinstNDDEAPI, "NDdeShareSetInfo");

        UINT res = (*lpfnNDdeShareSetInfo)(NULL, szShareName, 2, m_buffer,
            sizeof(m_buffer), 0);

        if (res == NDDE_NO_ERROR)
            bStatus = !bStatus;
    }

    FreeLibrary(hinstNDDEAPI);
    return bStatus;
#else
	return FALSE;
#endif
}


/****************************************************************************

CLocateDlg

****************************************************************************/

BEGIN_MESSAGE_MAP( CLocateDlg, CModalDialog )
    ON_BN_CLICKED(IDC_BROWSE,     OnBrowse)
    ON_BN_CLICKED(IDC_LOCATEHELP, OnHelp)
END_MESSAGE_MAP()

/****************************************************************************

CLocateDlg constructor

****************************************************************************/
CLocateDlg::CLocateDlg(CWnd *pParent) : CModalDialog(DLG_LOCATE, pParent)
{

}


/****************************************************************************

CLocateDlg::OnInitDialog()

Gray browse button if not available.  Read old server name from .ini file.

****************************************************************************/

BOOL CLocateDlg::OnInitDialog()
{
//  BUGBUG -- uncomment this if we ever get a Chicago browse dialog
//  (no support for this in Win95)
//
//  BROWSEPROC  m_pWNetServerBrowseDialog = NULL;
//
//  m_hmodNetDriver = WNetGetCaps(0xFFFF);
//
//  if (m_hmodNetDriver >= HINSTANCE_ERROR)
//      m_pWNetServerBrowseDialog =
//          (BROWSEPROC)GetProcAddress(m_hmodNetDriver, MAKEINTRESOURCE(146));
//
//  if (m_hmodNetDriver < HINSTANCE_ERROR || m_pWNetServerBrowseDialog == NULL)
//      ((CButton *)GetDlgItem(IDC_BROWSE))->EnableWindow(FALSE);

    CEdit *locname = (CEdit *)GetDlgItem(IDC_SERVERNAME);
    locname->LimitText(MAXCOMPUTERNAME);

    CString oldname;
    RegEntry Reg(szRegPath);
    TCHAR *poldname = oldname.GetBuffer(MAXCOMPUTERNAME+1);
    Reg.GetString(regvalServer, poldname, MAXCOMPUTERNAME+1);
    oldname.ReleaseBuffer();
    locname->SetWindowText(oldname);
    return TRUE;
}


/****************************************************************************

CLocateDlg::OnOK()

Store server name in .ini file.

****************************************************************************/

void CLocateDlg::OnOK()
{
    RegEntry Reg(szRegPath);

    GetDlgItemText(IDC_SERVERNAME, m_server.GetBuffer(MAXCOMPUTERNAME+1),
                  MAXCOMPUTERNAME+1);
    m_server.ReleaseBuffer();
    Reg.SetValue(regvalServer, m_server);
//    ::WinHelp(m_hWnd, szHelpFileName, HELP_QUIT, 0);

    EndDialog(IDOK);
}


/****************************************************************************

CLocateDlg::OnHelp()

****************************************************************************/

void CLocateDlg::OnHelp()
{
//    ::WinHelp(m_hWnd, szHelpFileName, HELP_CONTEXT, IDH_LOCATE);
}


/****************************************************************************

CLocateDlg::OnBrowse()

Call the winnet driver computer browse dialog.

****************************************************************************/

void CLocateDlg::OnBrowse()
{
//  BUGBUG -- uncomment if we ever get a Chicago browse dialog

/*  char        buf[MAXCOMPUTERNAME+10];        // handle slashes, etc.
    BROWSEPROC  m_pWNetServerBrowseDialog;

    m_pWNetServerBrowseDialog =
        (BROWSEPROC)GetProcAddress(m_hmodNetDriver, MAKEINTRESOURCE(146));

    (*m_pWNetServerBrowseDialog)( m_hWnd,
                                  "MRU_MSHearts",
                                  buf,
                                  MAXCOMPUTERNAME+10,
                                  0L );

    char *p = buf;
    if (*p != '\0')                 // if server name is not empty
    {
        while (*p == '\\')          // skip past leading backslashes
            p++;

        SetDlgItemText(IDC_SERVERNAME, p);
        OnOK();
    }
    else
    {
        // server name was empty, set focus back to edit field.

        ((CButton *)GetDlgItem(IDOK))->SetButtonStyle(BS_DEFPUSHBUTTON);
        ((CButton *)GetDlgItem(IDC_BROWSE))->SetButtonStyle(BS_PUSHBUTTON);
        ((CEdit *)GetDlgItem(IDC_SERVERNAME))->SetFocus();
    }
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\helpnum.h ===
#define IDH_START_HOW_HRTS      2001
#define IDH_LOCATE              2002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\human.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

human.cpp

Aug 92, JimH
May 93, JimH    chico port

local_human and remote_human member functions

****************************************************************************/

#include "hearts.h"

#include "main.h"                       // friendly access
#include "resource.h"
#include "debug.h"

#include <stdio.h>
#include <stdlib.h>                     // abs() prototype

static  CRect   rectCard;               // used in timer callback


// declare static members

BOOL    local_human::bTimerOn;
CString local_human::m_StatusText;


/****************************************************************************

human constructor -- abstract class

****************************************************************************/

human::human(int n, int pos) : player(n, pos)
{

}


/****************************************************************************

remote_human constructor

****************************************************************************/

remote_human::remote_human(int n, int pos, HCONV hConv) : human(n, pos),
                            m_hConv(hConv), bQuit(FALSE)
{

}


/****************************************************************************

remote_human::SelectCardToPlay()

Under normal circumstances, all that is required is that mode be set
to PLAYING.  If the remote human has quit and the computer player has
not yet taken over, this routine just picks the first legal card it
can find and plays it.

****************************************************************************/

void remote_human::SelectCardToPlay(handinfotype &h, BOOL bCheating)
{
    if (!bQuit)
    {
        SetMode(PLAYING);
        return;
    }

    BOOL bFirst   = (h.playerled == id);            // am I leading?
    card *cardled = h.cardplayed[h.playerled];
    int  nSuitLed = (cardled == NULL ? EMPTY : cardled->Suit());

    SLOT sLast[MAXSUIT];                // will contain some card of each suit
    SLOT s = EMPTY;

    for (int i = 0; i < MAXSUIT; i++)
        sLast[i] = EMPTY;

    // fill sLast array, and look for two of clubs while were are at it

    for (i = 0; i < MAXSLOT; i++)
    {
        if (cd[i].IsValid())
        {
            sLast[cd[i].Suit()] = i;
            if (cd[i].ID() == TWOCLUBS)
                s = i;
        }
    }

    if (s == EMPTY)                         // if two of clubs not found
    {
        if (sLast[CLUBS] != EMPTY)
            s = sLast[CLUBS];
        else if (sLast[DIAMONDS] != EMPTY)
            s = sLast[DIAMONDS];
        else if (sLast[SPADES] != EMPTY)
            s = sLast[SPADES];
        else
            s = sLast[HEARTS];

        if (!bFirst && (sLast[nSuitLed] != EMPTY))
            s = sLast[nSuitLed];
    }

    SetMode(WAITING);
    cd[s].Play();                                   // mark card as played
    h.cardplayed[id] = &(cd[s]);                    // update handinfo

    // inform other players

    ::move.playerid = id;
    ::move.cardid = cd[s].ID();
    ::move.playerled = h.playerled;
    ::move.turn = h.turn;

    ddeServer->PostAdvise(hszMove);

    // inform gamemeister

    ::pMainWnd->PostMessage(WM_COMMAND, IDM_REF);
}


/****************************************************************************

remote_human::SelectCardsToPass()

Under normal circumstances, all that is required is that mode be set to
SELECTING.  If the remote human has quit and the computer player has not
yet taken over, just select the first three cards found.

****************************************************************************/

void remote_human::SelectCardsToPass()
{
    if (!bQuit)
    {
        SetMode(SELECTING);
        return;
    }

    cd[0].Select(TRUE);
    cd[1].Select(TRUE);
    cd[2].Select(TRUE);

    for (int i = 3; i < MAXSLOT; i++)
        cd[i].Select(FALSE);

    CClientDC dc(::pMainWnd);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    MarkSelectedCards(dc);

    SetMode(DONE_SELECTING);

    ddeServer->PostAdvise(hszPass);     // let other players know
}



/****************************************************************************

local_human::local_human()

This is the constructor that initializes player::hWnd and player::hInst.
It also creates the stretch bitmap that covers a card plus its popped
height extension.

****************************************************************************/

local_human::local_human(int n) : human(n, 0)
{
    m_pStatusWnd = new CStatusBarCtrl();
    m_StatusText.LoadString(IDS_INTRO);

    CClientDC dc(::pMainWnd);

    m_pStatusWnd->Create(WS_CHILD|WS_VISIBLE|CCS_BOTTOM, CRect(), ::pMainWnd, 0);
    m_pStatusWnd->SetSimple();
    UpdateStatus();

    bTimerOn = FALSE;

    if (!m_bmStretchCard.CreateCompatibleBitmap(&dc, card::dxCrd,
                        card::dyCrd + POPSPACING))
    {
        ::pMainWnd->FatalError(IDS_MEMORY);
        return;
    }
}


/****************************************************************************

local_human destructor

****************************************************************************/

local_human::~local_human()
{
    m_bmStretchCard.DeleteObject();
    delete m_pStatusWnd;
    m_pStatusWnd = NULL;
}


/****************************************************************************

local_human::Draw()

This virtual function draws selected cards in the popped up position.
ALL is not used for slot in this variant.

****************************************************************************/

void local_human::Draw(CDC &dc, BOOL bCheating, SLOT slot)
{
    DisplayName(dc);
    SLOT start = (slot == ALL ? 0 : slot);
    SLOT stop  = (slot == ALL ? MAXSLOT : slot+1);

    SLOT playedslot = EMPTY;            // must draw cards in play last for EGA

    for (SLOT s = start; s < stop; s++)
    {
        if (cd[s].IsPlayed())
            playedslot = s;
        else
            cd[s].PopDraw(dc);          // pop up selected cards
    }

    if (playedslot != EMPTY)
        cd[playedslot].Draw(dc);
}


/****************************************************************************

local_human::PopCard()

handles mouse button selection of card to pass

****************************************************************************/

void local_human::PopCard(CBrush &brush, int x, int y)
{
    SLOT s = XYToCard(x, y);
    if (s == EMPTY)
        return;

    // count selected cards

    int c = 0;
    for (int i = 0; i < MAXSLOT; i++)
        if (cd[i].IsSelected())
            c++;

    if (cd[s].IsSelected() && (c == 3))
    {
        ::pMainWnd->PostMessage(WM_COMMAND, IDM_HIDEBUTTON);
    }
    else if (!cd[s].IsSelected())
    {
        if (c == 3)                 // only allow three selections
            return;
        else if (c == 2)
            ::pMainWnd->PostMessage(WM_COMMAND, IDM_SHOWBUTTON);
    }

    // toggle selection

    BOOL bSelected = cd[s].IsSelected();
    cd[s].Select(!bSelected);

    CClientDC dc(::pMainWnd);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    CDC memDC;
    memDC.CreateCompatibleDC(&dc);
    memDC.SelectObject(&m_bmStretchCard);
    memDC.SelectObject(&brush);
    memDC.PatBlt(0, 0, card::dxCrd, card::dyCrd + POPSPACING, PATCOPY);

    for (i = 0; i < MAXSLOT; i++)
    {
        if (abs(i - s) <= (card::dxCrd / HORZSPACING))
        {
            cd[i].Draw(memDC,                                   // cdc
                       (i - s) * HORZSPACING,                   // x
                       cd[i].IsSelected() ? 0 : POPSPACING,     // y
                       FACEUP,                                  // mode
                       FALSE);                                  // update loc?
        }
    }

    dc.BitBlt(loc.x + (HORZSPACING * s), loc.y - POPSPACING,
           card::dxCrd, card::dyCrd + POPSPACING,
           &memDC, 0, 0, SRCCOPY);
}


/****************************************************************************

local_human::PlayCard()

handles mouse button selection of card to play
and ensures move is legal.

PlayCard starts a timer that calls StartTimer() which calls TimerBadMove().
Think of it as one long function with a timer delay half way through.

****************************************************************************/

BOOL local_human::PlayCard(int x, int y, handinfotype &h, BOOL bCheating,
                            BOOL bFlash)
{
    SLOT s = XYToCard(x, y);
    if (s == EMPTY)
        return FALSE;

    card *cardled    = h.cardplayed[h.playerled];
    BOOL bFirstTrick = (cardled != NULL && cardled->ID() == TWOCLUBS);

    /* check if selected card is valid */

    if (h.playerled == id)              // if local human is leading...
    {
        if (cd[s].ID() != TWOCLUBS)
        {
            for (int i = 0; i < MAXSLOT; i++)   // is there a two of clubs?
            {
                if ((i != s) && (cd[i].ID() == TWOCLUBS))
                {
                    UpdateStatus(IDS_LEAD2C);
                    if (bFlash)
                        StartTimer(cd[s]);

                    return FALSE;
                }
            }
        }
        if ((cd[s].Suit() == HEARTS) && (!h.bHeartsBroken))   // if hearts led
        {
            for (int i = 0; i < MAXSLOT; i++)   // are there any non-hearts?
            {
                if ((!cd[i].IsEmpty()) && (cd[i].Suit() != HEARTS))
                {
                    UpdateStatus(IDS_LEADHEARTS);
                    if (bFlash)
                        StartTimer(cd[s]);

                    return FALSE;
                }
            }
        }
    }

    // if not following suit

    else if (cardled != NULL && (cd[s].Suit() != cardled->Suit()))
    {
        // make sure we're following suit if possible

        for (int i = 0; i < MAXSLOT; i++)
        {
            if ((!cd[i].IsEmpty()) && (cd[i].Suit()==cardled->Suit()))
            {
                CString s1, s2;
                s1.LoadString(IDS_BADMOVE);
                s2.LoadString(IDS_SUIT0+cardled->Suit());
                TCHAR string[80];
                wsprintf(string, s1, s2);

                if (bFlash)
                {
                    UpdateStatus(string);
                    StartTimer(cd[s]);
                }

                return FALSE;
            }
        }

        // make sure we're not trying to break the First Blood rule

        if (bFirstTrick && ::pMainWnd->IsFirstBloodEnforced())
        {
            BOOL bPointCard =
                         (cd[s].Suit() == HEARTS || cd[s].ID() == BLACKLADY);

            BOOL bOthersAvailable = FALSE;

            for (int i = 0; i < MAXSLOT; i++)
                if ((!cd[i].IsEmpty()) && (cd[i].Suit() != HEARTS))
                    if (cd[i].ID() != BLACKLADY)
                        bOthersAvailable = TRUE;

            if (bPointCard && bOthersAvailable)
            {
                UpdateStatus(IDS_BADBLOOD);
                if (bFlash)
                    StartTimer(cd[s]);

                return FALSE;
            }
        }
    }

    SetMode(WAITING);
    cd[s].Play();
    h.cardplayed[id] = &(cd[s]);

    ::move.playerid = id;
    ::move.cardid = cd[s].ID();
    ::move.playerled = h.playerled;
    ::move.turn = h.turn;

    if (id == 0)                            // if gamemeister
        ddeServer->PostAdvise(hszMove);
    else
        ddeClient->Poke(hszMove, &move, sizeof(move));

    ::pMainWnd->OnRef();

    return TRUE;
}

void local_human::StartTimer(card &c)
{
    CClientDC dc(::pMainWnd);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    c.Draw(dc, HILITE);           // flash
    c.GetRect(rectCard);

    if (::pMainWnd->SetTimer(1, 250, TimerBadMove))
    {
        bTimerOn = TRUE;
    }
    else
    {
        bTimerOn = FALSE;
        ::pMainWnd->InvalidateRect(&rectCard, FALSE);
    }
}

// MFC2 changes same as SetTimer in main2.cpp

#if defined (MFC1)

UINT FAR PASCAL EXPORT
        TimerBadMove(HWND hWnd, UINT nMsg, int nIDEvent, DWORD dwTime)
{
    ::KillTimer(hWnd, 1);
    local_human::bTimerOn = FALSE;
    ::InvalidateRect(hWnd, &rectCard, FALSE);
    return 0;
}

#else

void FAR PASCAL EXPORT
        TimerBadMove(HWND hWnd, UINT nMsg, UINT_PTR nIDEvent, DWORD dwTime)
{
    ::KillTimer(hWnd, 1);
    local_human::bTimerOn = FALSE;
#ifdef USE_MIRRORING
    CRect rect;
	int  i;
	DWORD ProcessDefaultLayout;
	if (GetProcessDefaultLayout(&ProcessDefaultLayout))
		if (ProcessDefaultLayout == LAYOUT_RTL)
		{
    	GetClientRect(hWnd, &rect);
		rectCard.left = abs(rect.right - rect.left) - rectCard.left;
		rectCard.right = abs(rect.right - rect.left) - rectCard.right;
		i = rectCard.left;
		rectCard.left = rectCard.right;
		rectCard.right = i;
		}
#endif

    ::InvalidateRect(hWnd, &rectCard, FALSE);

}

#endif


/****************************************************************************

local_human::XYToCard()

returns a card slot number (or EMPTY) given a mouse location

****************************************************************************/

int local_human::XYToCard(int x, int y)
{
    // check that we are in the right general area on the screen

    if (y < (loc.y - POPSPACING))
        return EMPTY;

    if (y > (loc.y + card::dyCrd))
        return EMPTY;

    if (x < loc.x)
        return EMPTY;

    if (x > (loc.x + (12 * HORZSPACING) + card::dxCrd))
        return EMPTY;

    // Take first stab at card selected.

    SLOT s = (x - loc.x) / HORZSPACING;
    if (s > 12)
        s = 12;

    // If the click is ABOVE the top of the normal card location,
    // check to see if this is a selected card.

    if (y < loc.y)
    {
        // If the card is bSelected, then we have it.  If not, it could
        // be overhanging other cards.

        if (!cd[s].IsSelected())
        {
            for (;;)
            {
                if (s == 0)
                    return EMPTY;
                s--;

                // if this card doesn't extend as far as x, give up

                if ((loc.x + (s * HORZSPACING) + card::dxCrd) < x)
                    return EMPTY;

                // if this card is selected, we've got it

                if (cd[s].IsSelected())
                    break;
            }
        }
    }

    // a similar check is used to make sure we pick a card not yet played

    if (!cd[s].IsInHand())
    {
        for (;;)
        {
            if (s == 0)
                return EMPTY;
            s--;

            // if this card doesn't extend as far as x, give up

            if ((loc.x + (s * HORZSPACING) + card::dxCrd) < x)
                return EMPTY;

            // if this card is selected, we've got it

            if (cd[s].IsInHand())
                break;
        }
    }

    return s;
}


/****************************************************************************

local_human::SelectCardsToPass()

This virtual function allows mouse clicks to mean select a card to play.

****************************************************************************/

void local_human::SelectCardsToPass()
{
    SetMode(SELECTING);
}


/****************************************************************************

local_human::SelectCardToPlay

Computer versions of this virtual function actually do the card selection.
This local_human version marks the player as ready to select a card to
play with the mouse, and updates the status to reflect this.

****************************************************************************/

void local_human::SelectCardToPlay(handinfotype &h, BOOL bCheating)
{
    SetMode(PLAYING);
    UpdateStatus(IDS_GO);
}


/****************************************************************************

local_human::UpdateStatus

The status bar can be updated either by manually filling m_StatusText
or by passing a string resource id.

****************************************************************************/

void local_human::UpdateStatus(void)
{
    m_pStatusWnd->SetText(m_StatusText, 255, 0);
}

void local_human::UpdateStatus(int stringid)
{
    status = stringid;
    m_StatusText.LoadString(stringid);
    UpdateStatus();
}

void local_human::UpdateStatus(const TCHAR *string)
{
    m_StatusText = string;
    UpdateStatus();
}


/****************************************************************************

local_human::ReceiveSelectedCards

The parameter c[] is an array of three cards being passed from another
player.

****************************************************************************/

void local_human::ReceiveSelectedCards(int c[])
{
    for (int i = 0, j = 0; j < 3; i++)
    {
        if (cd[i].IsSelected())
            cd[i].SetID(c[j++]);

        ASSERT(i < MAXSLOT);
    }

    SetMode(ACCEPTING);
    UpdateStatus(IDS_ACCEPT);
}


/****************************************************************************

local_human::WaitMessage()

Makes and shows the "Waiting for %s to move..." message

****************************************************************************/

void local_human::WaitMessage(const TCHAR *name)
{
    TCHAR buf[100];
    CString s;

    s.LoadString(IDS_WAIT);
    wsprintf(buf, s, name);
    UpdateStatus(buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\hearts.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

hearts.h

Aug 92, JimH
May 93, JimH    chico port

declaration of theApp class

****************************************************************************/


#ifndef	HEARTS_INC
#define	HEARTS_INC

#ifndef STRICT
#define STRICT
#endif

//#include <windows.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>			// MFC support for Windows Common Controls

#include <shellapi.h>
//#include <shell.h>

#include <afxwin.h>

#include <htmlhelp.h>

class CTheApp : public CWinApp
{
    public:
        BOOL InitInstance();
};

#endif


#if defined (WINDOWS_ME) && ! defined (USE_MIRRORING)
extern DWORD meMsgBox;
extern DWORD meSystem;
//#define MessageBox(h,s,c,f) MessageBoxEx(h,s,c,f|meMsgBox,0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\lead.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

lead.cpp

Aug 92, JimH
May 93, JimH    chico port

Logic to select lead card is here

****************************************************************************/

#include "hearts.h"

#include "main.h"
#include "resource.h"

#include "debug.h"      // undef _DEBUG instead to remove messages

/****************************************************************************

computer::SelectLeadCard

****************************************************************************/

SLOT computer::SelectLeadCard(handinfotype &h)
{
    SLOT    s;

    TRACE0("leading. ");

    // count cards left and check for two of clubs

    SLOT s2Clubs = EMPTY;
    int cTricksLeft = 0;
    for (s = 0; s < MAXSLOT; s++)
    {
        if (cd[s].IsValid())
        {
            cTricksLeft++;
            if (cd[s].ID() == TWOCLUBS)
                s2Clubs = s;
        }
    }

    if (s2Clubs != EMPTY)
    {
        TRACE0("lead 2 of clubs. ");
        return s2Clubs;
    }

    // If the Queen of Spades has not yet been played, try to force it out.
    // See if we are "spade safe" -- i.e., if we have no spades that are
    // queen or higher.  If we are safe, lead the lowest spade.

    if (!h.bQSPlayed)       // this is only interesting if queen not yet played
    {
        BOOL bHaveSpades = (sLowCard[SPADES] != EMPTY);
        BOOL bSpadeSafe = (nHighVal[SPADES] < QUEEN);

        if (bHaveSpades && bSpadeSafe)
        {
            TRACE0("try to force out spades, ");
            PLAY(sLowCard[SPADES]);
            return sLowCard[SPADES];
        }
    }

    // Now we just want to lead the lowest card of the best suit

    int suit = SureLossSuit(h.bHeartsBroken);

    if (suit == EMPTY)
        suit = BestSuitToLose(h.bHeartsBroken);

    // Be brave early on and lead a card near the midpoint of the suit
    // (if the queen of spades has been played already.)
    // Later on, just lead the lowest card of that suit.

    if (cTricksLeft > 8 && suit != HEARTS && h.bQSPlayed)
    {
        TRACE0("try midslot. ");
        s = MidSlot(suit);
    }
    else
    {
        s = sLowCard[suit];
    }

    PLAY(s);
    return s;
}


/****************************************************************************

computer::NotifyNewRound

Each player gets this call immediately after cards are passed.
It is a chance to initialize tables, etc.

****************************************************************************/

void computer::NotifyNewRound()
{
    // assume all cards are available

    for (int suit = 0; suit < MAXSUIT; suit++)
        for (int i = 0; i < (KING+2); i++)
            nAvailable[suit][i] = TRUE;

    // mark cards in hand as unavailable

    for (SLOT s = 0; s < MAXSLOT; s++)
        nAvailable[cd[s].Suit()][cd[s].Value2()] = FALSE;
}



/****************************************************************************

computer::NotifyEndHand

Each player gets this call immediately after the hand is completed.
The computer player here looks through the handplayed and marks
those cards are no longer available.

****************************************************************************/

void computer::NotifyEndHand(handinfotype &h)
{
    for (int i = 0; i < 4; i++)
        nAvailable[h.cardplayed[i]->Suit()][h.cardplayed[i]->Value2()] = FALSE;
}


/****************************************************************************

computer::CardsAboveLow(int suit)

Returns number of available (not yet played) cards that can beat the
low card held for the given suit.

****************************************************************************/

int computer::CardsAboveLow(int suit)
{
    int     count = 0;

    for (int i = nLowVal[suit]+1; i < (KING+2); i++)
        if (nAvailable[suit][i])
        {
            int j = i+1;                   // zero offset
            count++;
        }

    return count;
}


/****************************************************************************

computer::CardsBelowLow(int suit)

Returns number of available (not yet played) cards that are less than the
low card held for the given suit.

****************************************************************************/

int computer::CardsBelowLow(int suit)
{
    int     count = 0;

    for (int i = ACE+1; i < nLowVal[suit]; i++)
        if (nAvailable[suit][i])
        {
            int j = i+1;                   // zero offset
            count++;
        }

    return count;
}


/****************************************************************************

computer::BestSuitToLose

Returns the suit with the most CardsAboveLow()
bIncludeHearts defaults to TRUE.  Use FALSE if hearts not
yet broken and you're looking for a card to lead.

****************************************************************************/

int computer::BestSuitToLose(BOOL bIncludeHearts)
{
    int     best = -1;
    int     bestsuit = EMPTY;

    for (int suit = 0; suit < MAXSUIT; suit++)
    {
        if (sLowCard[suit] != EMPTY)        // if we have a card of this suit
        {
            if (suit != HEARTS || bIncludeHearts)
            {
                int count = CardsAboveLow(suit);
#ifdef _DEBUG
                TRACE2("%c=%d ", suitid[suit], count);
#endif
                if (count == best)      // if they're the same, pick lower card
                {
                    if (nLowVal[suit] < nLowVal[bestsuit])
                    {
                        bestsuit = suit;
                        best = count;
                    }
                }
                else if (count > best)
                {
                    bestsuit = suit;
                    best = count;
                }
            }
        }
    }

    if (bestsuit == EMPTY)          // only if all we have are unbroken hearts
        return HEARTS;
    else
        return bestsuit;
}


/****************************************************************************

computer::BestSuitToDump

Returns the suit with the most CardsBelowLow()
This is the most-vulnerable suit.
bIncludeHearts defaults to TRUE.

****************************************************************************/

int computer::BestSuitToDump(BOOL bIncludeHearts)
{
    int     best = -1;
    int     bestsuit = EMPTY;

    for (int suit = 0; suit < MAXSUIT; suit++)
    {
        if (sLowCard[suit] != EMPTY)        // if we have a card of this suit
        {
            if (suit != HEARTS || bIncludeHearts)
            {
                int count = CardsBelowLow(suit);
#ifdef _DEBUG
                TRACE2("%c=%d ", suitid[suit], count);
#endif
                if (count == best)      // if they're the same, pick lower card
                {
                    if (nLowVal[suit] > nLowVal[bestsuit])
                    {
                        bestsuit = suit;
                        best = count;
                    }
                }
                else if (count > best)
                {
                    bestsuit = suit;
                    best = count;
                }
            }
        }
    }

    if (bestsuit == EMPTY)          // only if all we have are unbroken hearts
        return HEARTS;
    else
        return bestsuit;
}


/****************************************************************************

computer::MidSlot

Instead of choosing the high or low card from a given suit, this function
can be used to pick something in the middle, where middle is defined as
the card with about the same number of available cards above and below it.

****************************************************************************/

SLOT computer::MidSlot(int suit)
{
    SLOT midslot = sLowCard[suit];
    int maxtricks = CardsAbove(sLowCard[suit]);
    int tricks = maxtricks;

    for (SLOT s = 0; s < MAXSLOT; s++)
    {
        if ((cd[s].IsValid()) && (cd[s].Suit()==suit) && (s!=sLowCard[suit]))
        {
            int above = CardsAbove(s);
            if ((above < tricks) && (above > (maxtricks / 2)))
            {
                midslot = s;
                tricks = above;
            }
        }
    }
    return midslot;
}


/****************************************************************************

computer::CardsAbove

Similar to CardsAboveLow except that it finds number of cards in the same
suit available from an arbitrary card.

****************************************************************************/

int computer::CardsAbove(SLOT s)
{
    int     suit = cd[s].Suit();
    int     count = 0;

    for (int i = cd[s].Value2()+1; i < (KING+2); i++)
        if (nAvailable[suit][i])
            count++;

    return count;
}


/****************************************************************************

computer::CardBelow

returns the slot of the next highest card of the same suit, or EMPTY

****************************************************************************/

SLOT computer::CardBelow(SLOT slot)
{
    SLOT sBelow = EMPTY;
    int  suit  = cd[slot].Suit();
    int  value = cd[slot].Value2();
    int  best  = -1;

    for (SLOT s = 0; s < MAXSLOT; s++)
    {
        if ((cd[s].IsValid()) && (cd[s].Suit()==suit) && (cd[s].Value2()<value))
        {
            if (cd[s].Value2() > best)
            {
                best = cd[s].Value2();
                sBelow = s;
            }
        }
    }

    return sBelow;
}


/****************************************************************************

computer::SureLossSuit

Returns a suit that can be led which guarantees a loss of
lead, or EMPTY if none is found.

****************************************************************************/

int computer::SureLossSuit(BOOL bIncludeHearts)
{
    for (int suit = (MAXSUIT-1); suit >= 0; --suit)
    {
        if (sLowCard[suit] != EMPTY)        // if we have a card of this suit
        {
            if (suit != HEARTS || bIncludeHearts)
            {
                if (CardsAboveLow(suit) > 0 && CardsBelowLow(suit) == 0)
                {
                    TRACE0("can lose this trick. ");
                    return suit;
                }
            }
        }
    }

    return EMPTY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\main.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

main.h

CMainWindow object
This class encompasses most of what is interesting in the main window of
Hearts.

Aug 92, JimH

****************************************************************************/

#ifndef STRICT
#define STRICT
#endif

#include "regentry.h"

#include "player.h"
#include "computer.h"
#include "dlg.h"
#include "dde.h"

#ifndef	MAIN_INC
#define	MAIN_INC


// non-translateable strings

extern  const TCHAR szRegPath[];
extern  const TCHAR regvalSound[];
extern  const TCHAR regvalName[];
extern  const TCHAR regvalRole[];
extern  const TCHAR regvalSpeed[];
extern  const TCHAR regvalServer[];
extern  const TCHAR *regvalPName[3];

extern  const TCHAR szHelpFileName[];
extern  const TCHAR szShareName[];

const   int     WINWIDTH    = 540;
const   int     WINHEIGHT   = 480;

const   int     LEFT        = 0;        // passdir
const   int     RIGHT       = 1;
const   int     ACROSS      = 2;
const   int     NOPASS      = 3;

const   int     OFF         = 0;        // used in PlaySound

const   int     MAXNAMELENGTH   = 14;
const   int     MAXCOMPUTERNAME = 15;

enum    roletype { GAMEMEISTER, PLAYER };


// The following structures are used to pass around DDE data

typedef struct {
    int     id;
    TCHAR    name[4][MAXNAMELENGTH+3];   // might have square brackets too!
} GAMESTATUS;

typedef struct {                        // I'm passing these three cards
    int     id;
    int     passdir;
    int     cardid[3];
} PASS3;

typedef struct {                        // the complete set of passed cards
    int     passdir;
    int     cardid[MAXPLAYER][3];
} PASS12;

typedef struct {                        // sent out after each move
    int     playerid;
    int     cardid;
    int     playerled;
    int     turn;
} MOVE;


#if defined (MFC1)
UINT FAR PASCAL EXPORT TimerDispatch(HWND, UINT, int, DWORD);
#else
void FAR PASCAL EXPORT TimerDispatch(HWND, UINT, UINT, DWORD);
#endif


class CMainWindow : public CFrameWnd
{
    friend  player::player(int n, int pos);
    friend  void player::GlideToCentre(SLOT s, BOOL bFaceup);
    friend  HDDEDATA EXPENTRY EXPORT DdeServerCallBack(WORD, WORD, HCONV, HSZ, HSZ, HDDEDATA, DWORD, DWORD);
    friend  HDDEDATA EXPENTRY EXPORT DdeClientCallBack(WORD, WORD, HCONV, HSZ, HSZ, HDDEDATA, DWORD, DWORD);

#if defined(MFC1)
    friend  UINT FAR PASCAL EXPORT TimerDispatch(HWND, UINT, int, DWORD);
#else
    friend  void FAR PASCAL EXPORT TimerDispatch(HWND, UINT, UINT_PTR, DWORD);
#endif

    public:
        CMainWindow(LPTSTR lpCmdLine);
        void     FatalError(int errorno = -1);
        int      GetGameNumber()            { return m_gamenumber; }
        COLORREF GetBkColor()               { return m_bkgndcolor; }
        CString  GetPlayerName(int num)     { return p[num]->GetName(); }
        modetype GetPlayerMode(int num)     { return p[num]->GetMode(); }
        int      GetMyId()                  { return m_myid; }
        int      Id2Pos(int id)             { return ((id - m_myid + 4) % 4); }
        BOOL     IsFirstBloodEnforced()     { return bEnforceFirstBlood; }
        void     PlayerQuit(int id);
        int      Pos2Id(int pos)            { return ((pos + m_myid) % 4); }
        void     SetGameNumber(int num)     { m_gamenumber = num; }

        afx_msg void OnAbout();
        afx_msg void OnBossKey()            { ShowWindow(SW_MINIMIZE); }
        afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
        afx_msg void OnCheat();
        afx_msg void OnClose();
        afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
        afx_msg BOOL OnEraseBkgnd(CDC *);
        afx_msg void OnExit()               { bConstructed = FALSE; OnClose(); }
        afx_msg void OnHelp()
                        { ::HtmlHelp(::GetDesktopWindow(), szHelpFileName, HH_DISPLAY_TOPIC, 0); }
/*
        afx_msg void OnHelpOnHelp()
                        { ::WinHelp(m_hWnd, NULL, HELP_HELPONHELP, 0); }
*/
        afx_msg void OnHideButton()         { m_Button.EnableWindow(FALSE); }
/*
        afx_msg void OnSearch()
                      { ::WinHelp(m_hWnd, szHelpFileName, HELP_PARTIALKEY,
                                                        (DWORD_PTR)(LPSTR)""); }
*/
        afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
        afx_msg void OnNewGame();
        afx_msg void OnOptions();
        afx_msg void OnPaint();
        afx_msg void OnPass();
        afx_msg void OnQuote();
        afx_msg void OnRef();
        afx_msg void OnShowButton() { m_Button.EnableWindow();
                                      m_Button.SetFocus(); }
        afx_msg void OnScore();
        afx_msg void OnSound();
        afx_msg void OnWelcome();
        afx_msg LRESULT OnPrintClient(WPARAM wParam, LPARAM lParam);

    private:
        int      AddNewPlayer(HCONV hConv, HDDEDATA hData);
        void     CheckNddeShare();
        void     ClientConnect(CString& server, CString& myname);
        int      CountClients();
        BOOL     CreateStrHandles();
        HDDEDATA DdeSrvCallBack(WORD, WORD, HCONV, HSZ, HSZ, HDDEDATA, DWORD, DWORD);
        HDDEDATA DdeCliCallBack(WORD, WORD, HCONV, HSZ, HSZ, HDDEDATA, DWORD, DWORD);
        void     DestroyStrHandles();
        void     DoSort();
        void     DispatchCards();
        void     EndHand();
        void     FirstMove();
        void     GameOver();
        HDDEDATA GetGameStatus(HCONV hConv);
        void     GetPass12(PASS12& pass12);
        void     HandleMove(MOVE& move);
        void     HandlePass(PASS3& pass3);
        BOOL     HandlePassing();
        BOOL     IsCurrentPlayer(HCONV hConv, int *id);
        void     ResetHandInfo(int playernumber);
        void     Shuffle();
        BOOL     SoundInit();
        BOOL     HeartsPlaySound(int id);
        void     ReceivePassFromClient(HDDEDATA hData);
        void     ReceiveMove(MOVE& move);
        void     UpdatePassStatus(PASS12& pass12);
        void     UpdateStatusNames(GAMESTATUS& gs);

        CButton  m_Button;
        int      m_StatusHeight;
        CScoreDlg *m_pScoreDlg;

        BOOL     bAutostarted;
        BOOL     bCheating;
        BOOL     bConstructed;
        BOOL     bEnforceFirstBlood;
        BOOL     bHasSound;
        BOOL     bNetDdeActive;
        BOOL     bSoundOn;
        BOOL     bTimerOn;
        int      m_gamenumber;
        LPTSTR    m_lpCmdLine;
        player   *p[MAXPLAYER];
        int      m_myid;
        int      passdir;
        int      m_FatalErrno;

        COLORREF        m_bkgndcolor;
        handinfotype    handinfo;
        roletype        role;

        int      tricksleft;
        int      trickwinner;

        static   CBrush m_BgndBrush;
        static   CRect  m_TableRect;

        DECLARE_MESSAGE_MAP()
};

// global variables

extern  CMainWindow *pMainWnd;
extern  HSZ     hszJoin;
extern  HSZ     hszPass;
extern  HSZ     hszMove;
extern  HSZ     hszStatus;
extern  HSZ     hszGameNumber;
extern  HSZ     hszPassUpdate;
extern  DDE     *dde;

extern  MOVE    move;
extern  MOVE    moveq[8];
extern  int     cQdMoves;
extern  PASS3   passq[4];
extern  int     cQdPasses;
extern  int     nStatusHeight;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\player.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

player.cpp

Aug 92, JimH
May 93, JimH    chico port

Methods for player objects

****************************************************************************/

#include "hearts.h"

#include "main.h"                           // friendly access
#include "resource.h"
#include "debug.h"

#include <stdlib.h>                         // qsort() prototype
#include <stdio.h>


extern "C" {                                // compare routine for qsort()
int __cdecl CompareCards(card *c1, card *c2);
}


/****************************************************************************

player::player

****************************************************************************/

player::player(int n, int pos) : id(n), position(pos)
{
    // Set up font
    BYTE charset = 0;
    int	fontsize = 0; 
    CString fontname, charsetstr, fontsizestr;
    fontname.LoadString(IDS_FONTFACE);
    charsetstr.LoadString(IDS_CHARSET);
    fontsizestr.LoadString(IDS_FONTSIZE);
    charset = (BYTE)_ttoi(charsetstr);
    fontsize = _ttoi(fontsizestr);
    font.CreateFont(fontsize, 0, 0, 0, 700, 0, 0, 0, charset, 0, 0, 0, 0, fontname);

    CRect   rect = CMainWindow::m_TableRect;

    POINT centre;
    const int offset = 30;          // offset from centre for playloc

    mode = STARTING;

    centre.x = (rect.right / 2) - (card::dxCrd / 2);
    centre.y = (rect.bottom / 2) - (card::dyCrd / 2);
    playloc = centre;
    score = 0;

    CClientDC dc(::pMainWnd);
    TEXTMETRIC  tm;
    dc.GetTextMetrics(&tm);
    int nTextHeight = tm.tmHeight + tm.tmExternalLeading;

    switch (position) {
        case 0:
            loc.x = (rect.right - (12 * HORZSPACING + card::dxCrd)) / 2;
            loc.y = rect.bottom - card::dyCrd - IDGE;
            dx = HORZSPACING;
            dy = 0;
            playloc.x -= 5;
            playloc.y += offset;
            dotloc.x = loc.x + (HORZSPACING / 2);
            dotloc.y = loc.y - IDGE;
            homeloc.x = playloc.x;
            homeloc.y = rect.bottom + card::dyCrd;
            nameloc.x = loc.x + card::dxCrd + IDGE;
            nameloc.y = rect.bottom - nTextHeight - IDGE;
            break;

        case 1:
            loc.x = 3 * IDGE;
            loc.y = (rect.bottom - (12 * VERTSPACING + card::dyCrd)) / 2;
            dx = 0;
            dy = VERTSPACING;
            playloc.x -= offset;
            playloc.y -= 5;
            dotloc.x = loc.x + card::dxCrd + IDGE;
            dotloc.y = loc.y + (VERTSPACING / 2);
            homeloc.x = -card::dxCrd;
            homeloc.y = playloc.y;
            nameloc.x = loc.x + 2;
            nameloc.y = loc.y - nTextHeight;
            break;

        case 2:
            loc.x = ((rect.right - (12 * HORZSPACING + card::dxCrd)) / 2)
                    + (12 * HORZSPACING);
            loc.y = IDGE;
            dx = -HORZSPACING;
            dy = 0;
            playloc.x += 5;
            playloc.y -= offset;
            dotloc.x = loc.x + card::dxCrd - (HORZSPACING / 2);
            dotloc.y = loc.y + card::dyCrd + IDGE;
            homeloc.x = playloc.x;
            homeloc.y = -card::dyCrd;
            nameloc.x = ((rect.right - (12 * HORZSPACING + card::dxCrd)) / 2)
                        + (12 * HORZSPACING) + card::dxCrd + IDGE;
            nameloc.y = IDGE;
            break;

        case 3:
            loc.x = rect.right - (card::dxCrd + (3 * IDGE));
            loc.y = ((rect.bottom - (12 * VERTSPACING + card::dyCrd)) / 2)
                   + (12 * VERTSPACING);
            dx = 0;
            dy = -VERTSPACING;
            playloc.x += offset;
            playloc.y += 5;
            dotloc.x = loc.x - IDGE;
            dotloc.y = loc.y + card::dyCrd - (VERTSPACING / 2);
            homeloc.x = rect.right;
            homeloc.y = playloc.y;
            nameloc.x = ((rect.right - (12 * HORZSPACING + card::dxCrd)) / 2)
                         - IDGE - 2;
            nameloc.y = ((rect.bottom - (12 * VERTSPACING + card::dyCrd)) / 2)
                   + (12 * VERTSPACING) + card::dyCrd;
            break;
    }

    ResetLoc();
}


/****************************************************************************

player::ResetLoc

This routine puts cards in locations based on their slot number.
It is used to initialize their x,y locs, or after cards have been sorted.

****************************************************************************/

void player::ResetLoc()
{
    int x = loc.x;
    int y = loc.y;

    for (SLOT s = 0; s < MAXSLOT; s++)
    {
        if (cd[s].IsInHand())
            cd[s].SetLoc(x, y);
        x += dx;
        y += dy;
    }
}


/****************************************************************************

player::Sort

****************************************************************************/

void player::Sort()
{
    qsort( (void *)cd,
	   MAXSLOT,
	   sizeof(card),
	   (int (__cdecl *)(const void *, const void *))CompareCards );

    ResetLoc();
}


/****************************************************************************

CompareCards

This is the compare function for player::Sort.

Aces are high, cards not in hand sort high, and order of suits is
clubs, diamonds, spades, hearts (alternating colours)

****************************************************************************/

int __cdecl CompareCards(card *c1, card *c2)
{
    int v1 = c1->Value2();
    int v2 = c2->Value2();
    int s1 = c1->Suit();
    int s2 = c2->Suit();

    if (!(c1->IsInHand()))
        v1 = EMPTY;

    if (!(c2->IsInHand()))
        v2 = EMPTY;

    if (v1 == EMPTY || v2 == EMPTY)
    {
        if (v1 == v2)                   // they're both EMPTY
            return 0;
        else if (v1 == EMPTY)
            return 1;
        else
            return -1;
    }

    if (s1 != s2)                           // different suits?
    {
        if (s1 == HEARTS && s2 == SPADES)   // these two suits reversed
            return 1;
        else if (s1 == SPADES && s2 == HEARTS)
            return -1;
        else
            return (s1 - s2);
    }

    return (v1 - v2);
}


/****************************************************************************

player::GetSlot

converts a card id to a slot number

****************************************************************************/

SLOT player::GetSlot(int id)
{
    SLOT s = EMPTY;

    for (int num = 0; num < MAXSLOT; num++)
    {
        if (GetID(num) == id)
        {
            s = num;
            break;
        }
    }

    ASSERT(s != EMPTY);
    return s;
}


/****************************************************************************

player::GetCardLoc

Loc gets location of upper-left corner of specified card slot.
Returns true if slot s is valid.

****************************************************************************/

BOOL player::GetCardLoc(SLOT s, POINT& loc)
{
    if (!cd[s].IsValid())
        return FALSE;

    loc.x = cd[s].GetX();
    loc.y = cd[s].GetY();

    return TRUE;
}


/****************************************************************************

player::GetCoverRect

returns a rect that covers all cards in hand

****************************************************************************/

CRect &player::GetCoverRect(CRect& rect)
{
    rect.left  = (dx < 0 ? loc.x + 12 * dx : loc.x);
    rect.right = rect.left + (dx != 0 ?
                      card::dxCrd + 12 * abs(dx) : card::dxCrd);
    rect.top   = (dy < 0 ? loc.y + 12 * dy : loc.y);
    rect.bottom = rect.top + (dy != 0 ?
                      card::dyCrd + 12 * abs(dy) : card::dyCrd);

    // expand rect to include selection indicators

    if (position == 0)
        rect.top -= POPSPACING;
    else if (position == 1)
        rect.right += 2 * IDGE;
    else if (position == 2)
        rect.bottom += 2 * IDGE;
    else
        rect.left -= 2 * IDGE;

    return rect;
}


/****************************************************************************

rect::GetMarkingRect

returns a rect that covers all selection marking dots

****************************************************************************/

CRect &player::GetMarkingRect(CRect& rect)
{
    rect.left   = (dx < 0 ? dotloc.x + (12 * dx) : dotloc.x);
    rect.right  = (dx < 0 ? dotloc.x + 2 : dotloc.x + (12 * dx) + 2);
    rect.top    = (dy < 0 ? dotloc.y + (12 * dy) : dotloc.y);
    rect.bottom = (dy < 0 ? dotloc.y + 2 : dotloc.y + (12 * dy) + 2);

    return rect;
}


/****************************************************************************

player::Draw

Draws all the cards belonging to this player.  bCheating defaults to
FALSE, and SLOT defaults to ALL.

****************************************************************************/

void player::Draw(CDC &dc, BOOL bCheating, SLOT slot)
{
    DisplayName(dc);
    SLOT start = (slot == ALL ? 0 : slot);
    SLOT stop  = (slot == ALL ? MAXSLOT : slot+1);

    SLOT playedslot = EMPTY;            // must draw cards in play last for EGA

    for (SLOT s = start; s < stop; s++)
    {
        if (cd[s].IsPlayed())
            playedslot = s;             // save and draw later
        else if (bCheating)
            cd[s].Draw(dc);
        else
            cd[s].Draw(dc, FACEDOWN);
    }

    if (playedslot != EMPTY)
        cd[playedslot].Draw(dc);
}

void player::DisplayName(CDC &dc)
{
    CFont *oldfont = dc.SelectObject(&font);
    dc.SetBkColor(::pMainWnd->GetBkColor());
    dc.TextOut(nameloc.x, nameloc.y, name, name.GetLength());
    dc.SelectObject(oldfont);
}

void player::SetName(CString& newname, CDC& dc)
{
    static RECT rect;               // client rect of main window
    static BOOL bFirst = TRUE;      // first time through this routine?

    if (bFirst)
        ::pMainWnd->GetClientRect(&rect);

    if (rect.right > 100)           // app started non-iconic
        bFirst = FALSE;

    name = newname;
    CFont *oldfont = dc.SelectObject(&font);
    if (position == 0)
    {
        CSize size = dc.GetTextExtent(name, name.GetLength());
        nameloc.x = ((rect.right - (12 * HORZSPACING + card::dxCrd)) / 2)
                        - IDGE - size.cx;
    }
    else if (position == 3)
    {
        CSize size = dc.GetTextExtent(name, name.GetLength());
        nameloc.x = rect.right - size.cx - (3*IDGE) - 2;
    }
    dc.SelectObject(oldfont);
}

/****************************************************************************

player::ReturnSelectedCards
player::ReceiveSelectedCards

When cards are passed from player to player, the first function is used
to return the selected cards.  The second is used to pass another player's
selections in.

****************************************************************************/

void player::ReturnSelectedCards(int c[])
{
    c[0] = EMPTY;               // default
    c[1] = EMPTY;
    c[2] = EMPTY;

    if (mode == STARTING || mode == SELECTING)
        return;

    for (int i = 0, j = 0; j < 3; i++)
    {
        if (cd[i].IsSelected())
            c[j++] = cd[i].ID();

        if (i >= MAXSLOT)
            { ASSERT(i < MAXSLOT); }
    }
}

void player::ReceiveSelectedCards(int c[])
{
    for (int i = 0, j = 0; j < 3; i++)
    {
        if (cd[i].IsSelected())
        {
            cd[i].SetID(c[j++]);
            cd[i].Select(FALSE);
        }
        ASSERT(i < MAXSLOT);
    }

    SetMode(WAITING);
}


/****************************************************************************

player::MarkSelectedCards

This virtual function puts white dots beside selected cards for all
non-local_human players.

****************************************************************************/

void player::MarkSelectedCards(CDC &dc)
{
    COLORREF color = RGB(255, 255, 255);

    for (int s = 0; s < MAXSLOT; s++)
    {
        if (cd[s].IsSelected())
        {
            int x = dotloc.x + (s * dx);
            int y = dotloc.y + (s * dy);
            dc.SetPixel(x, y, color);
            dc.SetPixel(x+1, y, color);
            dc.SetPixel(x, y+1, color);
            dc.SetPixel(x+1, y+1, color);
        }
    }
}


/****************************************************************************

player::GlideToCentre

This function takes a selected card and glides it to its play location.
The other normal cards (cards still in hand) are each checked to see if
the card is to be moved.  If so, their image is drawn into the background
bitmap.

****************************************************************************/

void player::GlideToCentre(SLOT s, BOOL bFaceup)
{
    CRect rectCard, rectSrc, rectDummy;

    CClientDC dc(::pMainWnd);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif

    CDC *memdc = new CDC;
    memdc->CreateCompatibleDC(&dc);

    memdc->SelectObject(&card::m_bmBgnd);
    memdc->SelectObject(&CMainWindow::m_BgndBrush);
    memdc->PatBlt(0, 0, card::dxCrd, card::dyCrd, PATCOPY);

    cd[s].GetRect(rectCard);

    for (SLOT i = 0; i < MAXSLOT; i++)
    {
        if (cd[i].IsNormal() && (i != s))
        {
            cd[i].GetRect(rectSrc);
            if (IntersectRect(&rectDummy, &rectSrc, &rectCard))
            {
                cd[i].Draw(*memdc,                      // CDC
                           rectSrc.left-rectCard.left,  // x
                           rectSrc.top-rectCard.top,    // y
                           bFaceup ? FACEUP : FACEDOWN, // mode
                           FALSE);                      // don't update loc
            }
        }
    }
    delete memdc;               // must delete before Glide() called

    cd[s].CleanDraw(dc);
    cd[s].Glide(dc, playloc.x, playloc.y);          // glide to play location
    cd[s].Play();                                   // mark card as played

    SetMode(WAITING);
}


/****************************************************************************

player::ResetCardsWon

cardswon[] keeps track of point cards won this hand.  This function
clears this data for a new hand.

****************************************************************************/

void player::ResetCardsWon()
{
    for (int i = 0; i < MAXCARDSWON; i++)
        cardswon[i] = EMPTY;

    numcardswon = 0;
}


/****************************************************************************

player::WinCard

Cards won in tricks are passed in.  If they are point cards (hearts
or queen on spades) the id is saved in cardswon[].

****************************************************************************/

void player::WinCard(CDC &dc, card *c)
{
    if ((c->IsHeart()) || (c->ID() == BLACKLADY))
        cardswon[numcardswon++] = c->ID();

    RegEntry Reg(szRegPath);
    DWORD    dwSpeed = Reg.GetNumber(regvalSpeed, IDC_NORMAL);

    int oldstep = c->SetStepSize(dwSpeed == IDC_SLOW ? 5 : 30);
    c->Glide(dc, homeloc.x, homeloc.y);
    c->SetStepSize(oldstep);
}


/****************************************************************************

player::EvaluateScore

Points stored in cardswon[] are added to players total score.

****************************************************************************/

int player::EvaluateScore(BOOL &bMoonShot)
{
    for (int i = 0; i < MAXCARDSWON; i++)
    {
        if (cardswon[i] == BLACKLADY)
            score += 13;
        else if (cardswon[i] != EMPTY)
            score++;
    }

    if (cardswon[MAXCARDSWON-1] != EMPTY)   // if player got ALL point cards
        bMoonShot = TRUE;
    else
        bMoonShot = FALSE;

    return score;
}


/****************************************************************************

player::DisplayHeartsWon

****************************************************************************/

void player::DisplayHeartsWon(CDC &dc)
{
    card    c;
    int     x = loc.x;
    int     y = loc.y;

    x += ((MAXCARDSWON - numcardswon) / 2) * dx;
    y += ((MAXCARDSWON - numcardswon) / 2) * dy;

    for (int i = 0; i < numcardswon; i++)
    {
        c.SetID(cardswon[i]);
        c.SetLoc(x, y);
        c.Draw(dc);
        x += dx;
        y += dy;
    }

    DisplayName(dc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\player.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

player.h

Aug 92, JimH
May 93, JimH    chico port

Header file for class player

hierarchy:              player
                      /       \
                 computer     human
                             /     \
                   local_human     remote_human

note: player and human are abstract classes.

    pos == 0 implies local human
    id  == 0 implies gamemeister

Relative to any human player, positions (pos) are arranged like this:

        2
      1   3
        0

If the human is the gamemeister, these are also the id's.

****************************************************************************/

#include "card.h"
#include "debug.h"
#include "ddeml.h"

#ifndef	PLAYER_INC
#define	PLAYER_INC

const int   HORZSPACING = 15;
const int   VERTSPACING = 15;
const int   IDGE        = 3;        // EDGE was defined as something else
const int   MAXCARDSWON = 14;

typedef     int     SLOT;

enum modetype { STARTING,
                SELECTING,
                DONE_SELECTING,
                WAITING,
                ACCEPTING,
                PLAYING,
                SCORING
              };

const int   MAXSLOT     = 13;

const int   ALL         = -1;

struct handinfotype {
    int     playerled;              // id of player led
    int     turn;                   // whose turn?  (0 to 3)
    card    *cardplayed[4];         // cards in play for each player
    BOOL    bHeartsBroken;          // hearts broken in this hand?
    BOOL    bQSPlayed;              // Queen of Spades played yet?
    BOOL    bShootingRisk;          // someone trying to shoot the moon?
    int     nMoonShooter;           // id of potential shooter
    BOOL    bHumanShooter;          // is nMoonShooter a human player?
};

/* timer callback */

#if defined (MFC1)
UINT FAR PASCAL EXPORT TimerBadMove(HWND hWnd, UINT nMsg, int nIDEvent, DWORD dwTime);
#else
void FAR PASCAL EXPORT TimerBadMove(HWND hWnd, UINT nMsg, UINT nIDEvent, DWORD dwTime);
#endif

class CMainWindow;

class player {

    private:
        CString     name;
        CFont       font;

    protected:
        int         id;                     // position relative to gamemeister
        int         position;               // position relative to you
        int         score;
        card        cd[MAXSLOT];
        POINT       loc;                    // location of cd[0]
        int         dx, dy;                 // offset for rest of cards
        POINT       playloc;                // played cards glided to here
        POINT       homeloc;                // won cards glided to here
        POINT       dotloc;                 // location of cd[0] "selected" dot
        POINT       nameloc;                // location of name
        modetype    mode;
        int         status;

        int         cardswon[MAXCARDSWON];
        int         numcardswon;

    public:
        player(int n, int pos);
        virtual ~player() { }               // required for ~local_human

        card    *Card(int s) { return &(cd[s]); }
        void    DisplayHeartsWon(CDC &dc);
        void    DisplayName(CDC &dc);
        int     EvaluateScore(BOOL &bMoonShot);
        BOOL    GetCardLoc(SLOT s, POINT& loc);
        SLOT    GetSlot(int id);
        CRect   &GetCoverRect(CRect& rect);
        int     GetID(SLOT slot) { return cd[slot].ID(); }
        CRect   &GetMarkingRect(CRect& rect);
        modetype GetMode() { return mode; }
        CString GetName() { return name; }
        int     GetScore() { return score; }
        void    GlideToCentre(SLOT s, BOOL bFaceup);
        void    MarkCardPlayed(SLOT s)      { cd[s].Play(); }
        void    ResetCardsWon(void);
        void    ResetLoc(void);
        void    ReturnSelectedCards(int c[]);
        void    Select(SLOT slot, BOOL bSelect)
                            { cd[slot].Select(bSelect); }
        void    SetID(SLOT slot, int id) { cd[slot].SetID(id); }
        void    SetMode(modetype m) { mode = m; }
        void    SetName(CString& newname, CDC& dc);
        void    SetScore(int s)     { score = s; }
        void    SetStatus(int s)    { status = s; }
        void    Sort(void);
        void    WinCard(CDC &dc, card *c);

        virtual void Draw(CDC &dc, BOOL bCheating = FALSE, SLOT slot = ALL);
        virtual HCONV GetConv()     { return NULL; }
        virtual BOOL IsHuman()      { return FALSE; }
        virtual void MarkSelectedCards(CDC &dc);
        virtual void NotifyEndHand(handinfotype &h) = 0;
        virtual void NotifyNewRound(void) = 0;

        virtual void ReceiveSelectedCards(int c[]);
        virtual void SelectCardsToPass(void) = 0;
        virtual void SelectCardToPlay(handinfotype &h, BOOL bCheating) = 0;

        virtual void UpdateStatus(void) = 0;
        virtual void UpdateStatus(int stringid) = 0;
        virtual void UpdateStatus(const TCHAR *string) = 0;

        virtual void Quit()     { }
        virtual BOOL HasQuit()  { return FALSE; }
};

class human : public player {

    private:

    protected:
        human(int n, int pos);

    public:
        virtual BOOL IsHuman()  { return TRUE; }

#if defined(_DEBUG)
        void    DebugMove(SLOT slot) { \
              TRACE1("<%d> human decides to ", id); PLAY(slot); TRACE0("\n"); }
#endif

};

class remote_human : public human {

    private:
        HCONV   m_hConv;
        BOOL    bQuit;

    public:
        remote_human(int n, int pos, HCONV hConv);

        virtual HCONV GetConv()     { return m_hConv; }
        virtual void NotifyEndHand(handinfotype &h) { }
        virtual void NotifyNewRound() { }
        virtual void SelectCardsToPass();
        virtual void SelectCardToPlay(handinfotype &h, BOOL bCheating);
        virtual void UpdateStatus()  { }
        virtual void UpdateStatus(int stringid) { status = stringid; }
        virtual void UpdateStatus(const TCHAR *string) { }
        virtual void Quit()         { bQuit = TRUE; }
        virtual BOOL HasQuit()      { return bQuit; }
};

class local_human : public human {

#if defined (MFC1)
    friend UINT FAR PASCAL EXPORT TimerBadMove(HWND, UINT, int, DWORD);
#else
    friend void FAR PASCAL EXPORT TimerBadMove(HWND, UINT, UINT_PTR, DWORD);
#endif

    protected:
        CBitmap m_bmStretchCard;                // bitmap for card + pop length
        CStatusBarCtrl *m_pStatusWnd;

        int     XYToCard(int x, int y);
        void    StartTimer(card &c);

        static  BOOL    bTimerOn;
        static  CString m_StatusText;

    public:
        local_human(int n);
        ~local_human();

        BOOL IsTimerOn() { return bTimerOn; }
        BOOL PlayCard(int x, int y, handinfotype &h, BOOL bCheating,
                        BOOL bFlash = TRUE);
        void PopCard(CBrush &brush, int x, int y);
        void SetPlayerId(int n)         { id = n; }
        void WaitMessage(const TCHAR *name);

        virtual void Draw(CDC &dc, BOOL bCheating = FALSE, SLOT slot = ALL);
        virtual void MarkSelectedCards(CDC &dc) { return; }
        virtual void NotifyEndHand(handinfotype &h) { return; }
        virtual void NotifyNewRound(void) { return; }
        virtual void ReceiveSelectedCards(int c[]);
        virtual void SelectCardsToPass(void);
        virtual void SelectCardToPlay(handinfotype &h, BOOL bCheating);
        virtual void UpdateStatus(void);
        virtual void UpdateStatus(int stringid);
        virtual void UpdateStatus(const TCHAR *string);
};

#endif	// PLAYER_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\games\mshearts\main.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

main.cpp

Aug 92, JimH
May 93, JimH    chico port

Main window callback functions
Other CMainWindow member functions are in main2.cpp, welcome.cpp and ddecb.cpp

****************************************************************************/

#include "hearts.h"
#include "main.h"
#include "resource.h"
#include "debug.h"
#include <regstr.h>

#if defined (WINDOWS_ME) && ! defined (USE_MIRRORING)
DWORD  meMsgBox=0;
DWORD  meSystem=0;
#define NLS_RESOURCE_LOCALE_KEY   "Control Panel\\desktop\\ResourceLocale"
#endif


// declare static memberes

CBrush  CMainWindow::m_BgndBrush;
CRect   CMainWindow::m_TableRect;

// declare globals

CMainWindow *pMainWnd;

DDE     *dde;               // same as either ddeClient or ddeServer
HSZ     hszJoin;            // string handles used by DDE
HSZ     hszPass;
HSZ     hszMove;
HSZ     hszStatus;
HSZ     hszGameNumber;
HSZ     hszPassUpdate;

MOVE    move;               // describes move for DDE transaction
MOVE    moveq[8];           // queue of moves waiting to be handled
int     cQdMoves;           // number of moves in above queue
PASS3   passq[4];           // queue of passes waiting to be handled
int     cQdPasses;          // number of passes in above queue
int     nStatusHeight;      // height of status window

// Do not translate these registry strings

const TCHAR szRegPath[]     = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\Hearts");
const TCHAR regvalSound[]   = TEXT("sound");
const TCHAR regvalName[]    = TEXT("name");
const TCHAR regvalRole[]    = TEXT("gamemeister");
const TCHAR regvalServer[]  = TEXT("server");
const TCHAR regvalSpeed[]   = TEXT("speed");
const TCHAR *regvalPName[3]  = { TEXT("p1name"), TEXT("p2name"), TEXT("p3name") };

const TCHAR szHelpFileName[]  = TEXT("mshearts.chm");
const TCHAR szShareName[]     = TEXT("HEARTS$");

CTheApp theApp;                     // start Hearts and run it!

/****************************************************************************

CTheApp::InitInstance

****************************************************************************/

BOOL CTheApp::InitInstance()
{

    m_pMainWnd = new CMainWindow(m_lpCmdLine);
    m_pMainWnd->ShowWindow(SW_SHOW);        // instead of m_nCmdShow
    m_pMainWnd->UpdateWindow();

    // Start the app off by posting Welcome dialog.

    m_pMainWnd->PostMessage(WM_COMMAND, IDM_WELCOME);

    return TRUE;
}


BEGIN_MESSAGE_MAP( CMainWindow, CFrameWnd )
    ON_COMMAND(IDM_ABOUT,       OnAbout)
    ON_COMMAND(IDM_BOSSKEY,     OnBossKey)
    ON_COMMAND(IDM_CHEAT,       OnCheat)
    ON_COMMAND(IDM_EXIT,        OnExit)
    ON_COMMAND(IDM_HELP,        OnHelp)
//    ON_COMMAND(IDM_HELPONHELP,  OnHelpOnHelp)
    ON_COMMAND(IDM_HIDEBUTTON,  OnHideButton)
//    ON_COMMAND(IDM_SEARCH,      OnSearch)
    ON_COMMAND(IDM_NEWGAME,     OnNewGame)
    ON_COMMAND(IDM_OPTIONS,     OnOptions)
    ON_COMMAND(IDM_QUOTE,       OnQuote)
    ON_COMMAND(IDM_REF,         OnRef)
    ON_COMMAND(IDM_SHOWBUTTON,  OnShowButton)
    ON_COMMAND(IDM_SCORE,       OnScore)
    ON_COMMAND(IDM_SOUND,       OnSound)
    ON_COMMAND(IDM_WELCOME,     OnWelcome)

    ON_BN_CLICKED(IDM_BUTTON,   OnPass)

    ON_WM_CHAR()
    ON_MESSAGE(WM_PRINTCLIENT, OnPrintClient)
    ON_WM_CLOSE()
    ON_WM_CREATE()
    ON_WM_ERASEBKGND()
    ON_WM_LBUTTONDOWN()
    ON_WM_PAINT()
END_MESSAGE_MAP()


/****************************************************************************

CMainWindow constructor

creates green background brush, and main hearts window

****************************************************************************/

CMainWindow::CMainWindow(LPTSTR lpCmdLine) :
    m_lpCmdLine(lpCmdLine), passdir(LEFT), bCheating(FALSE), bSoundOn(FALSE),
    bTimerOn(FALSE), bConstructed(TRUE), m_FatalErrno(0),
    bEnforceFirstBlood(TRUE)
{
#if !defined (MFC1)
    m_bAutoMenuEnable = FALSE;      // MFC 1.0 compatibility, required for MFC2
#endif
	
    ::cQdMoves = 0;                 // no moves in move queue
    ::cQdPasses = 0;                // no passes either

    for (int i = 0; i < MAXPLAYER; i++)
        p[i] = NULL;

    ResetHandInfo(-1);              // set handinfo struct to default values

    // Check for monochrome

    CDC ic;
    ic.CreateIC(TEXT("DISPLAY"), NULL, NULL, NULL);

    if (ic.GetDeviceCaps(NUMCOLORS) == 2)       // if monochrome
        m_bkgndcolor = RGB(255, 255, 255);      // white background for mono
    else
        m_bkgndcolor = RGB(0, 127, 0);

    ic.DeleteDC();

    m_BgndBrush.CreateSolidBrush(m_bkgndcolor); // destroyed in OnClose()
    LoadAccelTable( TEXT("HeartsAccel") );

    RECT rc;
    SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0);

    CRect rect;
    int dy = min(WINHEIGHT, (rc.bottom - rc.top));

    int x, y;
    if (GetSystemMetrics(SM_CYSCREEN) <= 480)   // VGA
    {
        x = (((rc.right - rc.left) - WINWIDTH) / 2) + rc.left;  // centered
        y = rc.top;
    }
    else
    {
        x = CW_USEDEFAULT;
        y = CW_USEDEFAULT;
    }

    rect.SetRect(x, y, x+WINWIDTH, y+dy);

    CString sAppname;
    sAppname.LoadString(IDS_APPNAME);

#if defined (WINDOWS_ME) && ! defined (USE_MIRRORING)
	if (GetSystemMetrics(SM_MIDEASTENABLED))
	{
		char sz[10];
		long cb = sizeof(sz);
		//
		// as we are releasing an enabled version, we need to check the
		// resource locale as well.
		//
		sz[0] = '\0';

		if( RegQueryValue( HKEY_CURRENT_USER, NLS_RESOURCE_LOCALE_KEY, sz, &cb) == ERROR_SUCCESS)

			if ( (cb == 9) && (sz[6] == '0') && ((sz[7] == '1') || (sz[7] == 'd') || (sz[7] == 'D')) )
			{
				meSystem = TRUE;
				meMsgBox = MB_RIGHT | MB_RTLREADING;
			}
	}
#endif

#if defined (WINDOWS_ME) && ! defined (USE_MIRRORING)
    Create( NULL,                                              // default class
            sAppname,                                          // window title
            WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU |
            WS_MINIMIZEBOX | WS_CLIPCHILDREN,                  // window style
            rect,                                              // size
            NULL,                                              // parent
            TEXT("HeartsMenu"),                                      // menu
            (meSystem ? WS_EX_RTLREADING | WS_EX_RIGHT : 0));  // dwStyle
#else
    Create( NULL,                                       // default class
            sAppname,                                   // window title
            WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU |
            WS_MINIMIZEBOX | WS_CLIPCHILDREN,           // window style
            rect,                                       // size
            NULL,                                       // parent
            TEXT("HeartsMenu"));                              // menu
#endif
}


/****************************************************************************

CMainWindow::OnAbout

displays about box

****************************************************************************/

//extern "C" int WINAPI ShellAbout(HWND, LPCSTR, LPCSTR, HICON);

void CMainWindow::OnAbout()
{
    HICON hIcon = ::LoadIcon(AfxGetInstanceHandle(),
                          MAKEINTRESOURCE(AFX_IDI_STD_FRAME));

    CString s;
    s.LoadString(IDS_NETWORK);
    ShellAbout(m_hWnd, s, NULL, hIcon);
}


/****************************************************************************

CMainWindow::OnQuote

displays quote box and plays quote.

****************************************************************************/

void CMainWindow::OnQuote()
{
    CQuoteDlg quote(this);
    // HeartsPlaySound(SND_QUOTE);
    quote.DoModal();
    HeartsPlaySound(OFF);
}


/****************************************************************************

CMainWindow::OnChar, looks space, plays first legal move, or pushes button

****************************************************************************/

void CMainWindow::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    // We know the cast below is legal because position 0 is always
    // the local human.

    local_human *p0 = (local_human *)p[0];

    int mode = p0->GetMode();

    if ((nChar != (UINT)' ') || (p0->IsTimerOn()))
        return;

    if (mode != PLAYING)
        return;

    p0->SetMode(WAITING);

    POINT loc;

    for (SLOT s = 0; s < MAXSLOT; s++)
    {
        if (p0->GetCardLoc(s, loc))
        {
            if (p0->PlayCard(loc.x, loc.y, handinfo, bCheating, FALSE))
            {
                return;
            }
        }
    }

    p0->SetMode(PLAYING);
}


/****************************************************************************

CMainWindow::OnCheat -- toggles bCheating used to show all cards face up.

****************************************************************************/

void CMainWindow::OnCheat()
{
    RegEntry    Reg(szRegPath);
    const TCHAR val[] = TEXT("ZB");
    TCHAR        buf[20];

    Reg.GetString(val, buf, sizeof(buf));
    if (buf[0] != TEXT('4') || buf[1] != TEXT('2'))
        return;

    bCheating = !bCheating;
    InvalidateRect(NULL, TRUE);     // redraw main hearts window

    CMenu *pMenu = GetMenu();
    pMenu->CheckMenuItem(IDM_CHEAT, bCheating ? MF_CHECKED : MF_UNCHECKED);
}


/****************************************************************************

CMainWindow::OnClose -- cleans up background brush, deletes players, etc.

****************************************************************************/

void CMainWindow::OnClose()
{
    m_BgndBrush.DeleteObject();

    for (int i = 0; i < 4; i++)
    {
        if (p[i])
        {
            delete p[i];
            p[i] = NULL;
        }
    }

    DestroyStrHandles();
    if (ddeClient)
        delete ddeClient;

    if (ddeServer)
        delete ddeServer;

    dde = NULL;
    ddeClient = NULL;
    ddeServer = NULL;

    ::HtmlHelp(::GetDesktopWindow(), szHelpFileName, HH_CLOSE_ALL, 0);

    {
        RegEntry Reg(szRegPath);
        Reg.FlushKey();
    }

    DestroyWindow();
}


/****************************************************************************

CMainWindow::OnCreate -- creates pass button child window & player objects.
                         also initializes some of the data members

****************************************************************************/

int CMainWindow::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    ::pMainWnd = this;

    if (!bConstructed)
    {
        FatalError(IDS_MEMORY);
        return -1;
    }

    // Check for existence of cards.dll

    SetErrorMode(SEM_NOOPENFILEERRORBOX);
    HINSTANCE hCardsDLL = LoadLibrary(TEXT("CARDS.DLL"));
    if (hCardsDLL < (HINSTANCE)HINSTANCE_ERROR)
    {
        FatalError(IDS_CARDSDLL);
        bConstructed = FALSE;
        return -1;
    }
    ::FreeLibrary(hCardsDLL);

    CClientDC dc(this);
    TEXTMETRIC  tm;

    ::srand((unsigned) ::time(NULL));       // set rand() seed
    ddeClient = NULL;
    ddeServer = NULL;

    dc.GetTextMetrics(&tm);
    int nTextHeight = tm.tmHeight + tm.tmExternalLeading;
    m_StatusHeight = nTextHeight + 11;
    GetClientRect(m_TableRect);

    m_TableRect.bottom -= m_StatusHeight;

    bConstructed = TRUE;

    // Player 0 is constructed as the gamemeister.  This
    // initializes lots of good stuff which is used later.
    // If player 0 doesn't happen to be a real gamemeister,
    // this gets fixed up in OnWelcome().

    p[0] = new local_human(0);      // display status bar

    if (p[0] == NULL)
    {
        bConstructed = FALSE;
        return -1;
    }

    // Construct pushbutton

    int cxChar = tm.tmAveCharWidth;
    int cyChar = tm.tmHeight + tm.tmExternalLeading;
    int nWidth = (60 * cxChar) / 4;
    int nHeight = (14 * cyChar) / 8;
    int x = (m_TableRect.right / 2) - (nWidth / 2);
    int y = m_TableRect.bottom - card::dyCrd - (2 * POPSPACING) - nHeight;
    CRect rect;
    rect.SetRect(x, y, x+nWidth, y+nHeight);

    if (!m_Button.Create(TEXT(""), WS_CHILD | BS_PUSHBUTTON, rect, this, IDM_BUTTON))
    {
        bConstructed = FALSE;
        return -1;
    }

    // check for sound capability

    RegEntry    Reg(szRegPath);

    bHasSound = SoundInit();
    if (bHasSound)
    {
        if (Reg.GetNumber(regvalSound, FALSE))
        {
            CMenu *pMenu = GetMenu();
            pMenu->CheckMenuItem(IDM_SOUND, MF_CHECKED);
            bSoundOn = TRUE;
        }
    }
    else
    {
        CMenu *pMenu = GetMenu();
        pMenu->EnableMenuItem(IDM_SOUND, MF_GRAYED);
    }

    card c;
    int  nStepSize;
    DWORD dwSpeed = Reg.GetNumber(regvalSpeed, IDC_NORMAL);

    if (dwSpeed == IDC_FAST)
        nStepSize = 60;
    else if (dwSpeed == IDC_SLOW)
        nStepSize = 5;
    else
        nStepSize = 15;

    c.SetStepSize(nStepSize);

    return (bConstructed ? 0 : -1);
}


/****************************************************************************

CMainWindow::OnEraseBkgnd -- required to draw background green

****************************************************************************/

BOOL CMainWindow::OnEraseBkgnd(CDC *pDC)
{
    if (!m_BgndBrush.m_hObject)         // if background brush is not valid
        return FALSE;

    m_BgndBrush.UnrealizeObject();
    CBrush *pOldBrush = pDC->SelectObject(&m_BgndBrush);
    pDC->PatBlt(0, 0, WINWIDTH, WINHEIGHT, PATCOPY);
    pDC->SelectObject(pOldBrush);
    return FALSE;
}



/****************************************************************************

CMainWindow::OnLButtonDown

Handles human selecting card to play or pass.

****************************************************************************/

void CMainWindow::OnLButtonDown(UINT nFlags, CPoint point)
{
    // We know the cast below is legal because position 0 is always
    // the local human.

#ifdef USE_MIRRORING
    CRect rect;
	DWORD ProcessDefaultLayout;
	if (GetProcessDefaultLayout(&ProcessDefaultLayout))
		if (ProcessDefaultLayout == LAYOUT_RTL)
		{
    	GetClientRect(&rect);
		point.x = rect.right - rect.left - point.x;
		}
#endif

    local_human *p0 = (local_human *)p[0];

    if (p0->IsTimerOn())    // ignore mouse clicks if timer running
        return;

    modetype mode = p0->GetMode();

    if (mode == SELECTING)
    {
        p0->PopCard(m_BgndBrush, point.x, point.y);
        return;
    }
    else if (mode != PLAYING)
        return;

    p0->SetMode(WAITING);
    if (p0->PlayCard(point.x, point.y, handinfo, bCheating))    // valid card?
        return;

    // move wasn't legal, so back to PLAYING mode

    p0->SetMode(PLAYING);
}


/****************************************************************************

CMainWindow::OnNewGame

****************************************************************************/

void CMainWindow::OnNewGame()
{
    passdir = LEFT;                 // each new game must start with LEFT

    bAutostarted = FALSE;           // means dealer has agreed to play at least

    CMenu *pMenu = GetMenu();
    pMenu->EnableMenuItem(IDM_NEWGAME, MF_GRAYED);

    if (role == GAMEMEISTER)
    {

        BOOL    bNewPlayers = FALSE;

        for (int i = 1; i < MAXPLAYER; i++)
        {
            if (!p[i])
            {
                bNewPlayers = TRUE;
                p[i] = new computer(i);
                if (!p[i])
                {
                    bConstructed = FALSE;
                    return;
                }
            }
        }

        if (bNewPlayers)
            ddeServer->PostAdvise(hszStatus);

        m_gamenumber = ::rand();
   