 update box);
   *  2. its maximum squared-distance to any point in the update box.
   * Both of these can be found by considering only the corners of the box.
   * We save the minimum distance for each color in mindist[];
   * only the smallest maximum distance is of interest.
   */
  minmaxdist = 0x7FFFFFFFL;

  for (i = 0; i < numcolors; i++) {
    /* We compute the squared-c0-distance term, then add in the other two. */
    x = GETJSAMPLE(cinfo->colormap[0][i]);
    if (x < minc0) {
      tdist = (x - minc0) * C0_SCALE;
      min_dist = tdist*tdist;
      tdist = (x - maxc0) * C0_SCALE;
      max_dist = tdist*tdist;
    } else if (x > maxc0) {
      tdist = (x - maxc0) * C0_SCALE;
      min_dist = tdist*tdist;
      tdist = (x - minc0) * C0_SCALE;
      max_dist = tdist*tdist;
    } else {
      /* within cell range so no contribution to min_dist */
      min_dist = 0;
      if (x <= centerc0) {
	tdist = (x - maxc0) * C0_SCALE;
	max_dist = tdist*tdist;
      } else {
	tdist = (x - minc0) * C0_SCALE;
	max_dist = tdist*tdist;
      }
    }

    x = GETJSAMPLE(cinfo->colormap[1][i]);
    if (x < minc1) {
      tdist = (x - minc1) * C1_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - maxc1) * C1_SCALE;
      max_dist += tdist*tdist;
    } else if (x > maxc1) {
      tdist = (x - maxc1) * C1_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - minc1) * C1_SCALE;
      max_dist += tdist*tdist;
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc1) {
	tdist = (x - maxc1) * C1_SCALE;
	max_dist += tdist*tdist;
      } else {
	tdist = (x - minc1) * C1_SCALE;
	max_dist += tdist*tdist;
      }
    }

    x = GETJSAMPLE(cinfo->colormap[2][i]);
    if (x < minc2) {
      tdist = (x - minc2) * C2_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - maxc2) * C2_SCALE;
      max_dist += tdist*tdist;
    } else if (x > maxc2) {
      tdist = (x - maxc2) * C2_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - minc2) * C2_SCALE;
      max_dist += tdist*tdist;
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc2) {
	tdist = (x - maxc2) * C2_SCALE;
	max_dist += tdist*tdist;
      } else {
	tdist = (x - minc2) * C2_SCALE;
	max_dist += tdist*tdist;
      }
    }

    mindist[i] = min_dist;	/* save away the results */
    if (max_dist < minmaxdist)
      minmaxdist = max_dist;
  }

  /* Now we know that no cell in the update box is more than minmaxdist
   * away from some colormap entry.  Therefore, only colors that are
   * within minmaxdist of some part of the box need be considered.
   */
  ncolors = 0;
  for (i = 0; i < numcolors; i++) {
    if (mindist[i] <= minmaxdist)
      colorlist[ncolors++] = (JSAMPLE) i;
  }
  return ncolors;
}


LOCAL void
find_best_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
		  int numcolors, JSAMPLE colorlist[], JSAMPLE bestcolor[])
/* Find the closest colormap entry for each cell in the update box,
 * given the list of candidate colors prepared by find_nearby_colors.
 * Return the indexes of the closest entries in the bestcolor[] array.
 * This routine uses Thomas' incremental distance calculation method to
 * find the distance from a colormap entry to successive cells in the box.
 */
{
  int ic0, ic1, ic2;
  int i, icolor;
  register INT32 * bptr;	/* pointer into bestdist[] array */
  JSAMPLE * cptr;		/* pointer into bestcolor[] array */
  INT32 dist0, dist1;		/* initial distance values */
  register INT32 dist2;		/* current distance in inner loop */
  INT32 xx0, xx1;		/* distance increments */
  register INT32 xx2;
  INT32 inc0, inc1, inc2;	/* initial values for increments */
  /* This array holds the distance to the nearest-so-far color for each cell */
  INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Initialize best-distance for each cell of the update box */
  bptr = bestdist;
  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
    *bptr++ = 0x7FFFFFFFL;
  
  /* For each color selected by find_nearby_colors,
   * compute its distance to the center of each cell in the box.
   * If that's less than best-so-far, update best distance and color number.
   */
  
  /* Nominal steps between cell centers ("x" in Thomas article) */
#define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
#define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
#define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)
  
  for (i = 0; i < numcolors; i++) {
    icolor = GETJSAMPLE(colorlist[i]);
    /* Compute (square of) distance from minc0/c1/c2 to this color */
    inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
    dist0 = inc0*inc0;
    inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
    dist0 += inc1*inc1;
    inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
    dist0 += inc2*inc2;
    /* Form the initial difference increments */
    inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
    inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;
    inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
    /* Now loop over all cells in box, updating distance per Thomas method */
    bptr = bestdist;
    cptr = bestcolor;
    xx0 = inc0;
    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
      dist1 = dist0;
      xx1 = inc1;
      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
	dist2 = dist1;
	xx2 = inc2;
	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
	  if (dist2 < *bptr) {
	    *bptr = dist2;
	    *cptr = (JSAMPLE) icolor;
	  }
	  dist2 += xx2;
	  xx2 += 2 * STEP_C2 * STEP_C2;
	  bptr++;
	  cptr++;
	}
	dist1 += xx1;
	xx1 += 2 * STEP_C1 * STEP_C1;
      }
      dist0 += xx0;
      xx0 += 2 * STEP_C0 * STEP_C0;
    }
  }
}


LOCAL void
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
/* Fill the inverse-colormap entries in the update box that contains */
/* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
/* we can fill as many others as we wish.) */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  int minc0, minc1, minc2;	/* lower left corner of update box */
  int ic0, ic1, ic2;
  register JSAMPLE * cptr;	/* pointer into bestcolor[] array */
  register histptr cachep;	/* pointer into main cache array */
  /* This array lists the candidate colormap indexes. */
  JSAMPLE colorlist[MAXNUMCOLORS];
  int numcolors;		/* number of candidate colors */
  /* This array holds the actually closest colormap index for each cell. */
  JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Convert cell coordinates to update box ID */
  c0 >>= BOX_C0_LOG;
  c1 >>= BOX_C1_LOG;
  c2 >>= BOX_C2_LOG;

  /* Compute true coordinates of update box's origin corner.
   * Actually we compute the coordinates of the center of the corner
   * histogram cell, which are the lower bounds of the volume we care about.
   */
  minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
  minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
  minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);
  
  /* Determine which colormap entries are close enough to be candidates
   * for the nearest entry to some cell in the update box.
   */
  numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);

  /* Determine the actually nearest colors. */
  find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist,
		   bestcolor);

  /* Save the best color numbers (plus 1) in the main cache array */
  c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
  c1 <<= BOX_C1_LOG;
  c2 <<= BOX_C2_LOG;
  cptr = bestcolor;
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
      cachep = & histogram[c0+ic0][c1+ic1][c2];
      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
	*cachep++ = (histcell) (GETJSAMPLE(*cptr++) + 1);
      }
    }
  }
}


/*
 * Map some rows of pixels to the output colormapped representation.
 */

METHODDEF void
pass2_no_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs no dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  register JSAMPROW inptr, outptr;
  register histptr cachep;
  register int c0, c1, c2;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    inptr = input_buf[row];
    outptr = output_buf[row];
    for (col = width; col > 0; col--) {
      /* get pixel value and index into the cache */
      c0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;
      c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
      c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
      cachep = & histogram[c0][c1][c2];
      /* If we have not seen this color before, find nearest colormap entry */
      /* and update the cache */
      if (*cachep == 0)
	fill_inverse_cmap(cinfo, c0,c1,c2);
      /* Now emit the colormap index for this cell */
      *outptr++ = (JSAMPLE) (*cachep - 1);
    }
  }
}


METHODDEF void
pass2_fs_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs Floyd-Steinberg dithering */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  register LOCFSERROR cur0, cur1, cur2;	/* current error or pixel value */
  LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */
  LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */
  register FSERRPTR errorptr;	/* => fserrors[] at column before current */
  JSAMPROW inptr;		/* => current input pixel */
  JSAMPROW outptr;		/* => current output pixel */
  histptr cachep;
  int dir;			/* +1 or -1 depending on direction */
  int dir3;			/* 3*dir, for advancing inptr & errorptr */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
  JSAMPLE *range_limit = cinfo->sample_range_limit;
  int *error_limit = cquantize->error_limiter;
  JSAMPROW colormap0 = cinfo->colormap[0];
  JSAMPROW colormap1 = cinfo->colormap[1];
  JSAMPROW colormap2 = cinfo->colormap[2];
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
    inptr = input_buf[row];
    outptr = output_buf[row];
    if (cquantize->on_odd_row) {
      /* work right to left in this row */
      inptr += (width-1) * 3;	/* so point to rightmost pixel */
      outptr += width-1;
      dir = -1;
      dir3 = -3;
      errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
      cquantize->on_odd_row = FALSE; /* flip for next time */
    } else {
      /* work left to right in this row */
      dir = 1;
      dir3 = 3;
      errorptr = cquantize->fserrors; /* => entry before first real column */
      cquantize->on_odd_row = TRUE; /* flip for next time */
    }
    /* Preset error values: no error propagated to first pixel from left */
    cur0 = cur1 = cur2 = 0;
    /* and no error propagated to row below yet */
    belowerr0 = belowerr1 = belowerr2 = 0;
    bpreverr0 = bpreverr1 = bpreverr2 = 0;

    for (col = width; col > 0; col--) {
      /* curN holds the error propagated from the previous pixel on the
       * current line.  Add the error propagated from the previous line
       * to form the complete error correction term for this pixel, and
       * round the error term (which is expressed * 16) to an integer.
       * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
       * for either sign of the error value.
       * Note: errorptr points to *previous* column's array entry.
       */
      cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);
      cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3+1] + 8, 4);
      cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3+2] + 8, 4);
      /* Limit the error using transfer function set by init_error_limit.
       * See comments with init_error_limit for rationale.
       */
      cur0 = error_limit[cur0];
      cur1 = error_limit[cur1];
      cur2 = error_limit[cur2];
      /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
       * The maximum error is +- MAXJSAMPLE (or less with error limiting);
       * this sets the required size of the range_limit array.
       */
      cur0 += GETJSAMPLE(inptr[0]);
      cur1 += GETJSAMPLE(inptr[1]);
      cur2 += GETJSAMPLE(inptr[2]);
      cur0 = GETJSAMPLE(range_limit[cur0]);
      cur1 = GETJSAMPLE(range_limit[cur1]);
      cur2 = GETJSAMPLE(range_limit[cur2]);
      /* Index into the cache with adjusted pixel value */
      cachep = & histogram[cur0>>C0_SHIFT][cur1>>C1_SHIFT][cur2>>C2_SHIFT];
      /* If we have not seen this color before, find nearest colormap */
      /* entry and update the cache */
      if (*cachep == 0)
	fill_inverse_cmap(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);
      /* Now emit the colormap index for this cell */
      { register int pixcode = *cachep - 1;
	*outptr = (JSAMPLE) pixcode;
	/* Compute representation error for this pixel */
	cur0 -= GETJSAMPLE(colormap0[pixcode]);
	cur1 -= GETJSAMPLE(colormap1[pixcode]);
	cur2 -= GETJSAMPLE(colormap2[pixcode]);
      }
      /* Compute error fractions to be propagated to adjacent pixels.
       * Add these into the running sums, and simultaneously shift the
       * next-line error sums left by 1 column.
       */
      { register LOCFSERROR bnexterr, delta;

	bnexterr = cur0;	/* Process component 0 */
	delta = cur0 * 2;
	cur0 += delta;		/* form error * 3 */
	errorptr[0] = (FSERROR) (bpreverr0 + cur0);
	cur0 += delta;		/* form error * 5 */
	bpreverr0 = belowerr0 + cur0;
	belowerr0 = bnexterr;
	cur0 += delta;		/* form error * 7 */
	bnexterr = cur1;	/* Process component 1 */
	delta = cur1 * 2;
	cur1 += delta;		/* form error * 3 */
	errorptr[1] = (FSERROR) (bpreverr1 + cur1);
	cur1 += delta;		/* form error * 5 */
	bpreverr1 = belowerr1 + cur1;
	belowerr1 = bnexterr;
	cur1 += delta;		/* form error * 7 */
	bnexterr = cur2;	/* Process component 2 */
	delta = cur2 * 2;
	cur2 += delta;		/* form error * 3 */
	errorptr[2] = (FSERROR) (bpreverr2 + cur2);
	cur2 += delta;		/* form error * 5 */
	bpreverr2 = belowerr2 + cur2;
	belowerr2 = bnexterr;
	cur2 += delta;		/* form error * 7 */
      }
      /* At this point curN contains the 7/16 error value to be propagated
       * to the next pixel on the current line, and all the errors for the
       * next line have been shifted over.  We are therefore ready to move on.
       */
      inptr += dir3;		/* Advance pixel pointers to next column */
      outptr += dir;
      errorptr += dir3;		/* advance errorptr to current column */
    }
    /* Post-loop cleanup: we must unload the final error values into the
     * final fserrors[] entry.  Note we need not unload belowerrN because
     * it is for the dummy column before or after the actual array.
     */
    errorptr[0] = (FSERROR) bpreverr0; /* unload prev errs into array */
    errorptr[1] = (FSERROR) bpreverr1;
    errorptr[2] = (FSERROR) bpreverr2;
  }
}


/*
 * Initialize the error-limiting transfer function (lookup table).
 * The raw F-S error computation can potentially compute error values of up to
 * +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be
 * much less, otherwise obviously wrong pixels will be created.  (Typical
 * effects include weird fringes at color-area boundaries, isolated bright
 * pixels in a dark area, etc.)  The standard advice for avoiding this problem
 * is to ensure that the "corners" of the color cube are allocated as output
 * colors; then repeated errors in the same direction cannot cause cascading
 * error buildup.  However, that only prevents the error from getting
 * completely out of hand; Aaron Giles reports that error limiting improves
 * the results even with corner colors allocated.
 * A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty
 * well, but the smoother transfer function used below is even better.  Thanks
 * to Aaron Giles for this idea.
 */

LOCAL void
init_error_limit (j_decompress_ptr cinfo)
/* Allocate and fill in the error_limiter table */
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  int * table;
  int in, out;

  table = (int *) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));
  table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
  cquantize->error_limiter = table;

#define STEPSIZE ((MAXJSAMPLE+1)/16)
  /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
  out = 0;
  for (in = 0; in < STEPSIZE; in++, out++) {
    table[in] = out; table[-in] = -out;
  }
  /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
    table[in] = out; table[-in] = -out;
  }
  /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
  for (; in <= MAXJSAMPLE; in++) {
    table[in] = out; table[-in] = -out;
  }
#undef STEPSIZE
}


/*
 * Finish up at the end of each pass.
 */

METHODDEF void
finish_pass1 (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;

  /* Select the representative colors and fill in cinfo->colormap */
  cinfo->colormap = cquantize->sv_colormap;
  select_colors(cinfo, cquantize->desired);
  /* Force next pass to zero the color index table */
  cquantize->needs_zeroed = TRUE;
}


METHODDEF void
finish_pass2 (j_decompress_ptr cinfo)
{
  /* no work */
}


/*
 * Initialize for each processing pass.
 */

METHODDEF void
start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
  int i;

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
    cinfo->dither_mode = JDITHER_FS;

  if (is_pre_scan) {
    /* Set up method pointers */
    cquantize->pub.color_quantize = prescan_quantize;
    cquantize->pub.finish_pass = finish_pass1;
    cquantize->needs_zeroed = TRUE; /* Always zero histogram */
  } else {
    /* Set up method pointers */
    if (cinfo->dither_mode == JDITHER_FS)
      cquantize->pub.color_quantize = pass2_fs_dither;
    else
      cquantize->pub.color_quantize = pass2_no_dither;
    cquantize->pub.finish_pass = finish_pass2;

    /* Make sure color count is acceptable */
    i = cinfo->actual_number_of_colors;
    if (i < 1)
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 1);
    if (i > MAXNUMCOLORS)
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);

    if (cinfo->dither_mode == JDITHER_FS) {
      size_t arraysize = (size_t) ((cinfo->output_width + 2) *
				   (3 * SIZEOF(FSERROR)));
      /* Allocate Floyd-Steinberg workspace if we didn't already. */
      if (cquantize->fserrors == NULL)
	cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
	  ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
      /* Initialize the propagated errors to zero. */
      jzero_far((void FAR *) cquantize->fserrors, arraysize);
      /* Make the error-limit table if we didn't already. */
      if (cquantize->error_limiter == NULL)
	init_error_limit(cinfo);
      cquantize->on_odd_row = FALSE;
    }

  }
  /* Zero the histogram or inverse color map, if necessary */
  if (cquantize->needs_zeroed) {
    for (i = 0; i < HIST_C0_ELEMS; i++) {
      jzero_far((void FAR *) histogram[i],
		HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
    }
    cquantize->needs_zeroed = FALSE;
  }
}


/*
 * Switch to a new external colormap between output passes.
 */

METHODDEF void
new_color_map_2_quant (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;

  /* Reset the inverse color map */
  cquantize->needs_zeroed = TRUE;
}


/*
 * Module initialization routine for 2-pass color quantization.
 */

GLOBAL void
jinit_2pass_quantizer (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize;
  int i;

  cquantize = (my_cquantize_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
  cquantize->pub.start_pass = start_pass_2_quant;
  cquantize->pub.new_color_map = new_color_map_2_quant;
  cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
  cquantize->error_limiter = NULL;

  /* Make sure jdmaster didn't give me a case I can't handle */
  if (cinfo->out_color_components != 3)
    ERREXIT(cinfo, JERR_NOTIMPL);

  /* Allocate the histogram/inverse colormap storage */
  cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(hist2d));
  for (i = 0; i < HIST_C0_ELEMS; i++) {
    cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
  }
  cquantize->needs_zeroed = TRUE; /* histogram is garbage now */

  /* Allocate storage for the completed colormap, if required.
   * We do this now since it is FAR storage and may affect
   * the memory manager's space calculations.
   */
  if (cinfo->enable_2pass_quant) {
    /* Make sure color count is acceptable */
    int desired = cinfo->desired_number_of_colors;
    /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
    if (desired < 8)
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);
    /* Make sure colormap indexes can be represented by JSAMPLEs */
    if (desired > MAXNUMCOLORS)
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
    cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
      ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);
    cquantize->desired = desired;
  } else
    cquantize->sv_colormap = NULL;

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
    cinfo->dither_mode = JDITHER_FS;

  /* Allocate Floyd-Steinberg workspace if necessary.
   * This isn't really needed until pass 2, but again it is FAR storage.
   * Although we will cope with a later change in dither_mode,
   * we do not promise to honor max_memory_to_use if dither_mode changes.
   */
  if (cinfo->dither_mode == JDITHER_FS) {
    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
    /* Might as well create the error-limiting table too. */
    init_error_limit(cinfo);
  }
}

#endif /* QUANT_2PASS_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\jpeglib\sources.inc ===
#############################################################
#
#Copyright (c) 1997  Microsoft Corporation
#
#  This directory builds
#     Common TWAIN Data source for FN project
#
#############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=jpeg
TARGETTYPE=LIBRARY
TARGETPATH=$(WIA_LIB_DEST)

USE_MSVCRT=1

MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=$(C_DEFINES) -DSTRICT -DHAVE_BOOLEAN -DNO_GETENV -DWIAJPEG
USE_NATIVE_EH=1
386_STDCALL=0

INCLUDES= \
        $(PROJECT_ROOT)\wia\jpeg; \
        $(INCLUDES);

SOURCES= \
    ..\jcapimin.cpp \
    ..\jcapistd.cpp \
    ..\jccoefct.cpp \
    ..\jccolor.cpp \
    ..\jcdctmgr.cpp \
    ..\jchuff.cpp \
    ..\jcinit.cpp \
    ..\jcmainct.cpp \
    ..\jcmarker.cpp \
    ..\jcmaster.cpp \
    ..\jcomapi.cpp \
    ..\jcparam.cpp \
    ..\jcphuff.cpp \
    ..\jcprepct.cpp \
    ..\jcsample.cpp \
    ..\jctrans.cpp \
    ..\jdapimin.cpp \
    ..\jdapistd.cpp \
    ..\jdatadst.cpp \
    ..\jdatasrc.cpp \
    ..\jdcoefct.cpp \
    ..\jdcolor.cpp \
    ..\jddctmgr.cpp \
    ..\jdhuff.cpp \
    ..\jdinput.cpp \
    ..\jdmainct.cpp \
    ..\jdmarker.cpp \
    ..\jdmaster.cpp \
    ..\jdmerge.cpp \
    ..\jdphuff.cpp \
    ..\jdpostct.cpp \
    ..\jdsample.cpp \
    ..\jdtrans.cpp \
    ..\jerror.cpp \
    ..\jfdctflt.cpp \
    ..\jfdctfst.cpp \
    ..\jfdctint.cpp \
    ..\jidctflt.cpp \
    ..\jidctfst.cpp \
    ..\jidctint.cpp \
    ..\jidctred.cpp \
    ..\jmemnobs.cpp \
    ..\jmemmgr.cpp \
    ..\jquant1.cpp \
    ..\jquant2.cpp \
    ..\jutils.cpp  \
    ..\jmemfile.cpp \
    ..\jpegapi.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\assert.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    str.cpp

Abstract:

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/


#include "cplusinc.h"
#include "sticomm.h"

extern "C" {

static CHAR szFmt0[] = "File %.40s, Line %u";
static CHAR szFmt1[] = "%.60s: File %.40s, Line %u";
static CHAR szMBCaption[] = "ASSERTION FAILED";
static TCHAR szFAE[] = TEXT("ASSERTION FAILURE IN APP");

BOOL   fDoMessageBox = FALSE;

VOID UIAssertHelper(
    const CHAR* pszFileName,
    UINT    nLine )
{
    CHAR szBuff[sizeof(szFmt0)+60+40];

    wsprintfA(szBuff, szFmt0, pszFileName, nLine);

    MessageBoxA(NULL, szBuff, szMBCaption,
           (MB_TASKMODAL | MB_ICONSTOP | MB_OK) );

    FatalAppExit(0, szFAE);
}


VOID UIAssertSzHelper(
    const TCHAR* pszMessage,
    const CHAR* pszFileName,
    UINT    nLine )
{
    CHAR szBuff[sizeof(szFmt1)+60+40];

    wsprintfA(szBuff, szFmt1, pszMessage, pszFileName, nLine);
    MessageBoxA(NULL, szBuff, szMBCaption,
           (MB_TASKMODAL | MB_ICONSTOP | MB_OK) );

    FatalAppExit(0, szFAE);
}

VOID AssertHelper(
    const CHAR* pszFileName,
    UINT    nLine )
{
    //DPRINTF(DM_ASSERT,szFmt0, pszFileName, nLine);
    Break();
}

VOID AssertSzHelper(
    const TCHAR* pszMessage,
    const CHAR* pszFileName,
    UINT    nLine )
{
    //DPRINTF(DM_ASSERT,szFmt1, pszMessage, pszFileName, nLine);
    Break();
}

//========== Debug output routines =========================================

UINT uiStiDebugMask = 0xffff;

UINT WINAPI StiSetDebugMask(UINT mask)
{
#ifdef DEBUG
    UINT uiOld = uiStiDebugMask;
    uiStiDebugMask = mask;

    return uiOld;
#else
    return 0;
#endif
}

UINT WINAPI StiGetDebugMask()
{
#ifdef DEBUG
    return uiStiDebugMask;
#else
    return 0;
#endif
}

#ifndef WINCAPI
#define WINCAPI __cdecl
#endif

#ifdef DEBUG

/* debug message output log file */

UINT    g_uSpewLine = 0;
PCTSTR  g_pcszSpewFile = NULL;
TCHAR    s_cszLogFile[MAX_PATH] = {'\0'};
TCHAR    s_cszDebugName[MAX_PATH] = {'\0'};

UINT WINAPI  StiSetDebugParameters(PTSTR pszName,PTSTR pszLogFile)
{
    lstrcpy(s_cszLogFile,pszLogFile);
    lstrcpy(s_cszDebugName,pszName);

    return 0;
}


BOOL LogOutputDebugString(PCTSTR pcsz)
{
   BOOL     bResult = FALSE;
   UINT     ucb;
   TCHAR    rgchLogFile[MAX_PATH];

   //if (IS_EMPTY_STRING(s_cszLogFile) )
   //          return FALSE;

   ucb = GetWindowsDirectory(rgchLogFile, sizeof(rgchLogFile));

   if (ucb > 0 && ucb < sizeof(rgchLogFile) && *s_cszLogFile) {

      HANDLE hfLog;

      lstrcat(rgchLogFile, TEXT("\\"));
      lstrcat(rgchLogFile, s_cszLogFile);

      hfLog = ::CreateFile(rgchLogFile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           OPEN_ALWAYS,
                           0,
                           NULL);

      if (hfLog != INVALID_HANDLE_VALUE) {

         if (SetFilePointer(hfLog, 0, NULL, FILE_END) != INVALID_FILE_SIZE) {
            DWORD dwcbWritten;

            bResult = WriteFile(hfLog, pcsz, lstrlen(pcsz), &dwcbWritten, NULL);

            if (! CloseHandle(hfLog) && bResult)
               bResult = FALSE;
         }
      }
   }

   return(bResult);
}

TCHAR    *achDebugDisplayPrefix[] = {TEXT("t "),TEXT("w "),TEXT("e "),TEXT("a "),TEXT("t "),TEXT("t "),TEXT("t "),TEXT("t "),TEXT("t "),TEXT("t "),TEXT("t ")};

void WINCAPI StiDebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    TCHAR    ach[1024];
    UINT    uiDisplayMask = mask & 0xff;

    va_list list;

    va_start (list, pszMsg);

    // Determine prefix
    *ach = TEXT('\0');
    if (uiStiDebugMask & DM_PREFIX) {

        // Add trace type
        ::lstrcat(ach,achDebugDisplayPrefix[uiDisplayMask]);

        // Add component name
        ::lstrcat(ach,s_cszDebugName);

        // Add thread ID
        TCHAR    szThreadId[16];
        ::wsprintf(szThreadId,TEXT("[%#lx] "),::GetCurrentThreadId());
        ::lstrcat(ach,szThreadId);
    }

    ::wvsprintf(ach+::lstrlen(ach), pszMsg, list);
    va_end(list);

    ::lstrcat(ach,TEXT("\r\n"));

    if (uiStiDebugMask & DM_LOG_FILE) {
         LogOutputDebugString(ach);
    }

    // Check if we need to display this trace
    if (uiStiDebugMask & uiDisplayMask) {
        OutputDebugString(ach);
    }
}

#endif

}   /* extern "C" */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\cassert.c ===
/*****************************************************************************
 *
 *  CAssert.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Assertions and debug output routines
 *      Based on Raymond's assertion code as it looks quite useful
 *
 *
 *  Contents:
 *
 *      DebugOutPtszV
 *      AssertPtszPtszLn
 *      ArgsPalPszV
 *      EnterDbgflPszPal
 *      ExitDbgflPalHresPpv
 *
 *****************************************************************************/

/*
#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <regstr.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <stdio.h>

#include <stilog.h>
#include <stiregi.h>

#include <sti.h>
#include <stierr.h>
#include <stiusd.h>
#include "wia.h"
#include "stipriv.h"
#include "stiapi.h"
#include "stirc.h"
#include "debug.h"
*/
#include "sticomm.h"

#ifdef MAXDEBUG

/*****************************************************************************
 *
 *      WarnPszV
 *
 *      Display a message, suitable for framing.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

CHAR c_szPrefix[] = "STI: ";

#pragma END_CONST_DATA

void EXTERNAL
WarnPszV(LPCSTR psz, ...)
{
    va_list ap;
    CHAR sz[1024];

    lstrcpyA(sz, c_szPrefix);
    va_start(ap, psz);
    wvsprintfA(sz + cA(c_szPrefix) - 1, psz, ap);
    va_end(ap);
    lstrcatA(sz, "\r\n");
    OutputDebugStringA(sz);
}

#endif

#ifdef DEBUG

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

DBGFL DbgflCur;

TCHAR g_tszLogFile[MAX_PATH] = {'\0'};

/*****************************************************************************
 *
 * Set current trace parameters
 *
 * This routine is not thread safe
 *
 *****************************************************************************/


VOID  InitializeDebuggingSupport(VOID)
{

    HKEY    hStiSettingsKey;
    DWORD   dwErr;
    DWORD   dwType;

    CHAR    szLogFile[MAX_PATH];
    UINT    cbBuffer ;

    DBGFL   dwFlags = 0;

    dwErr = OSUtil_RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        REGSTR_PATH_STICONTROL_W,
                        0L,KEY_READ,
                        &hStiSettingsKey
                        );

    if (NOERROR != dwErr) {
        return;
    }

    cbBuffer = MAX_PATH;
    ZeroX(szLogFile);

    dwErr = RegQueryValueExA( hStiSettingsKey,
                           REGSTR_VAL_DEBUG_FILE_A,
                           NULL,
                           &dwType,
                           (LPBYTE)szLogFile,
                           &cbBuffer );

    if( ( dwErr == NO_ERROR ) || ( dwErr == ERROR_MORE_DATA ) ) {
        if( ( dwType != REG_SZ ) &&
            ( dwType != REG_MULTI_SZ ) &&
            ( dwType != REG_EXPAND_SZ ) ) {

            dwErr = ERROR_FILE_NOT_FOUND;
        }
        else {
            SetDebugLogFileA(szLogFile);
        }
    }

    dwFlags = ReadRegistryDwordW(hStiSettingsKey,
                                      REGSTR_VAL_DEBUG_FLAGS_W,
                                      0L);

    SetCurrentDebugFlags(dwFlags ) ;

    RegCloseKey(hStiSettingsKey);

    return ;

}

DBGFL   SetCurrentDebugFlags(DBGFL NewFlags) {

    DBGFL   OldFlags = DbgflCur;
    DbgflCur = NewFlags;
    return OldFlags;
}

VOID    SetDebugLogFileA(CHAR *pszLogFileName)
{
    if (!pszLogFileName || !*pszLogFileName) {
        *g_tszLogFile = '\0';
        return;
    }

    lstrcpyA((CHAR*)g_tszLogFile,pszLogFileName);
    return;
}

/*****************************************************************************
 *
 *      DebugOutPtsz
 *
 *      Writes a message to the debugger and maybe a log file.
 *
 *****************************************************************************/

void INTERNAL
DebugOutPtsz(LPCTSTR ptsz)
{
    DWORD   cbWritten;

    OutputDebugString(ptsz);
    if (g_tszLogFile[0]) {
        HANDLE h = CreateFile(g_tszLogFile, GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        if (h != INVALID_HANDLE_VALUE) {
#ifdef UNICODE
            CHAR szBuf[1024];
#endif
            SetFilePointer(h, 0, 0, FILE_END);
#ifdef UNICODE
            WriteFile(h, szBuf, UToA(szBuf, cA(szBuf), ptsz),&cbWritten,NULL);
#else
            WriteFile(h, ptsz, cbCtch(lstrlen(ptsz)),&cbWritten,NULL);
#endif
            CloseHandle(h);
        }
    }
}

/*****************************************************************************
 *
 *      DebugOutPtszA
 *
 *      DebugOut an ANSI message to the debugger and maybe a log file.
 *
 *****************************************************************************/

#ifdef UNICODE

void INTERNAL
DebugOutPtszA(LPCSTR psz)
{
    OutputDebugStringA(psz);
    if (g_tszLogFile[0]) {
        HANDLE h = CreateFile(g_tszLogFile, GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        if (h != INVALID_HANDLE_VALUE) {
            _lwrite((HFILE)(LONG_PTR)h, psz, cbCch(lstrlenA(psz)));
            CloseHandle(h);
        }
    }
}

#else

#define DebugOutPtszA                 DebugOutPtsz

#endif

/*****************************************************************************
 *
 *      DebugOutPtszV
 *
 *      DebugOut a message with a trailing crlf.
 *
 *****************************************************************************/

void EXTERNAL
DebugOutPtszV(DBGFL Dbgfl, LPCTSTR ptsz, ...)
{
    if (Dbgfl == 0 || (Dbgfl & DbgflCur)) {
        va_list ap;
        TCHAR tsz[1024];
        va_start(ap, ptsz);
        wvsprintf(tsz, ptsz, ap);
        va_end(ap);
        lstrcat(tsz, TEXT("\r\n"));
        DebugOutPtsz(tsz);
    }
}

/*****************************************************************************
 *
 *      AssertPtszPtszLn
 *
 *      Something bad happened.
 *
 *****************************************************************************/

int EXTERNAL
AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine)
{
    DebugOutPtszV(DbgFlAlways, TEXT("Assertion failed: `%s' at %s(%d)"),
                    ptszExpr, ptszFile, iLine);
    DebugBreak();
    return 0;
}

/*****************************************************************************
 *
 *      Procedure call tracing is gross because of the C preprocessor.
 *
 *      Oh, if only we had support for m4...
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      ArgsPszV
 *
 *      Collect arguments to a procedure.
 *
 *      psz -> ASCIIZ format string
 *      ... = argument list
 *
 *      The characters in the format string are listed in EmitPal.
 *
 *****************************************************************************/

void EXTERNAL
ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...)
{
    va_list ap;
    va_start(ap, psz);
    if (psz) {
        PPV ppv;
        pal->pszFormat = psz;
        for (ppv = pal->rgpv; *psz; psz++) {
            *ppv++ = va_arg(ap, PV);
        }
    } else {
        pal->pszFormat = "";
    }
}

/*****************************************************************************
 *
 *      EmitPal
 *
 *      OutputDebugString the information, given a pal.  No trailing
 *      carriage return is emitted.
 *
 *      pal      -> place where info was saved
 *
 *      Format characters:
 *
 *      p   - 32-bit flat pointer
 *      x   - 32-bit hex integer
 *      s   - TCHAR string
 *      A   - ANSI string
 *      W   - UNICODE string
 *      G   - GUID
 *      u   - unsigned integer
 *      C   - clipboard format
 *
 *****************************************************************************/

void INTERNAL
EmitPal(PARGLIST pal)
{
    char sz[MAX_PATH];
    int i;
    DebugOutPtszA(pal->pszProc);
    DebugOutPtsz(TEXT("("));
    for (i = 0; pal->pszFormat[i]; i++) {
        if (i) {
            DebugOutPtsz(TEXT(", "));
        }
        switch (pal->pszFormat[i]) {

        case 'p':                               /* 32-bit flat pointer */
        case 'x':                               /* 32-bit hex */
            wsprintfA(sz, "%08x", pal->rgpv[i]);
            DebugOutPtszA(sz);
            break;

        case 's':                               /* TCHAR string */
            if (pal->rgpv[i]) {
                DebugOutPtsz(pal->rgpv[i]);
            }
            break;

        case 'A':                               /* ANSI string */
            if (pal->rgpv[i]) {
                DebugOutPtszA(pal->rgpv[i]);
            }
            break;

        case 'W':                               /* UNICODE string */
#ifdef  UNICODE
            OutputDebugStringW(pal->rgpv[i]);
#else
            WideCharToMultiByte(CP_ACP, 0, pal->rgpv[i], -1, sz, cA(sz), 0, 0);
            DebugOutPtszA(sz);
#endif
            break;

#ifndef _WIN64
            //
            // Ignore this option on SunDown
            //
        case 'G':                               /* GUID */
            wsprintfA(sz, "%08x",
                      HIWORD(pal->rgpv[i]) ? *(LPDWORD)pal->rgpv[i]
                                           : (DWORD)pal->rgpv[i]);
            DebugOutPtszA(sz);
            break;

            case 'C':
                if (GetClipboardFormatNameA((UINT)pal->rgpv[i], sz, cA(sz))) {
                } else {
                    wsprintfA(sz, "[%04x]", pal->rgpv[i]);
                }
                DebugOutPtszA(sz);
                break;
#endif

        case 'u':                               /* 32-bit unsigned decimal */
            wsprintfA(sz, "%u", pal->rgpv[i]);
            DebugOutPtszA(sz);
            break;


        default: AssertF(0);                    /* Invalid */
        }
    }
    DebugOutPtsz(TEXT(")"));
}

/*****************************************************************************
 *
 *      EnterDbgflPtsz
 *
 *      Mark entry to a procedure.  Arguments were already collected by
 *      ArgsPszV.
 *
 *      Dbgfl     -> DebugOuty flags
 *      pszProc  -> procedure name
 *      pal      -> place to save the name and get the format/args
 *
 *****************************************************************************/

void EXTERNAL
EnterDbgflPszPal(DBGFL Dbgfl, LPCSTR pszProc, PARGLIST pal)
{
    pal->pszProc = pszProc;
    if (Dbgfl == 0 || (Dbgfl & DbgflCur)) {
        EmitPal(pal);
        DebugOutPtsz(TEXT("\r\n"));
    }
}

/*****************************************************************************
 *
 *      ExitDbgflPalHresPpv
 *
 *      Mark exit from a procedure.
 *
 *      pal      -> argument list
 *      hres     -> exit result
 *      ppv      -> optional OUT pointer;
 *                  ppvDword means that hres is a dword
 *                  ppvBool  means that hres is a boolean
 *                  ppvVoid  means that hres is nothing at all
 *
 *****************************************************************************/

void EXTERNAL
ExitDbgflPalHresPpv(DBGFL Dbgfl, PARGLIST pal, HRESULT hres, PPV ppvObj)
{
    BOOL fInternalError;
    DWORD le = GetLastError();

    fInternalError = 0;
    if (ppvObj == ppvVoid) {
    } else if (ppvObj == ppvBool) {
        if (hres == 0) {
            Dbgfl |= DbgFlError;
        }
    } else {
        if (FAILED(hres)) {
            if (fLimpFF(ppvObj && !IsBadWritePtr(ppvObj, cbX(*ppvObj)),
                        *ppvObj == 0)) {
            } else {
                fInternalError = 1;
            }
            Dbgfl |= DbgFlError;
        }
    }

    if (Dbgfl == 0 || (Dbgfl & DbgflCur) || fInternalError) {
        EmitPal(pal);
        DebugOutPtsz(TEXT(" -> "));
        if (ppvObj != ppvVoid) {
            TCHAR tszBuf[32];
            wsprintf(tszBuf, TEXT("%08x"), hres);
            DebugOutPtsz(tszBuf);
            if (HIWORD(PtrToLong(ppvObj))) {
                wsprintf(tszBuf, TEXT(" [%08x]"), *ppvObj);
                DebugOutPtsz(tszBuf);
            } else if (ppvObj == ppvDword) {
                wsprintf(tszBuf, TEXT(" [%08x]"), hres);
                DebugOutPtsz(tszBuf);
            } else if (ppvObj == ppvBool) {
                wsprintf(tszBuf, hres ? TEXT(" OK ") :
                                 TEXT(" le=[%d]"), le);
                DebugOutPtsz(tszBuf);
            }
        }
        DebugOutPtsz(TEXT("\r\n"));
        AssertF(!fInternalError);
    }

    /*
     *  This redundant test prevents a breakpoint on SetLastError()
     *  from being hit constantly.
     */
    if (le != GetLastError()) {
        SetLastError(le);
    }
}

#endif

#ifdef MAXDEBUG

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | Random |
 *
 *          Returns a pseudorandom dword.  The value doesn't need to be
 *          statistically wonderful.
 *
 *  @returns
 *          A not very random dword.
 *
 *****************************************************************************/

DWORD s_dwRandom = 1;                   /* Random number seed */

DWORD INLINE
Random(void)
{
    s_dwRandom = s_dwRandom * 214013 + 2531011;
    return s_dwRandom;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ScrambleBuf |
 *
 *          Fill a buffer with garbage.  Used in RDEBUG to make sure
 *          the caller is not relying on buffer data.
 *
 *          Note: If the buffer is not a multiple of dwords in size,
 *          the leftover bytes are not touched.
 *
 *  @parm   OUT LPVOID | pv |
 *
 *          The buffer to be scrambled.
 *
 *  @parm   UINT | cb |
 *
 *          The size of the buffer.
 *
 *****************************************************************************/

void EXTERNAL
ScrambleBuf(LPVOID pv, UINT cb)
{
    UINT idw;
    UINT cdw = cb / 4;
    LPDWORD pdw = pv;
    for (idw = 0; idw < cdw; idw++) {
        pdw[idw] = Random();
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ScrambleBit |
 *
 *          Randomly set or clear a bit.
 *
 *  @parm   OUT LPDWORD | pdw |
 *
 *          The dword whose bit is to be set randomly.
 *
 *  @parm   UINT | flMask |
 *
 *          Mask for the bits to scramble.
 *
 *****************************************************************************/

void EXTERNAL ScrambleBit(LPDWORD pdw, DWORD flMask)
{
    *pdw ^= (*pdw ^ Random()) & flMask;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | Callback_CompareContexts |
 *
 *          Check if two <t CONTEXT> structures are substantially the same
 *          to the extent required by the Win32 calling convention.
 *
 *          This is necessary because lots of applications pass
 *          incorrectly prototyped functions as callbacks.  Others will
 *          write callback functions that trash registers that are
 *          supposed to be nonvolatile.  Yuck!
 *
 *          NOTE!  Platform-dependent code!
 *
 *  @parm   LPCONTEXT | pctx1 |
 *
 *          Context structure before we call the callback.
 *
 *  @parm   LPCONTEXT | pctx2 |
 *
 *          Context structure after we call the callback.
 *
 *  @returns
 *
 *          Nonzero if the two contexts are substantially the same.
 *
 *****************************************************************************/

BOOL INLINE
Callback_CompareContexts(LPCONTEXT pctx1, LPCONTEXT pctx2)
{
#if defined(_X86_)
    return pctx1->Esp == pctx2->Esp;            /* Stack pointer */
  #if 0
    /*
     *  Can't test these registers because Win95 doesn't preserve
     *  them properly.  GetThreadContext() stashes what happens to
     *  be in the registers when you finally reach the bowels of
     *  kernel, at which point who knows what they contain...
     */
           pctx1->Ebx == pctx2->Ebx &&          /* Nonvolatile registers */
           pctx1->Esi == pctx2->Esi &&
           pctx1->Edi == pctx2->Edi &&
           pctx1->Ebp == pctx2->Ebp;
  #endif

#elif defined(_ALPHA_)
    return pctx1->IntSp == pctx2->IntSp &&      /* Stack pointer */
           pctx1->IntS0 == pctx2->IntS0 &&      /* Nonvolatile registers */
           pctx1->IntS1 == pctx2->IntS1 &&
           pctx1->IntS2 == pctx2->IntS2 &&
           pctx1->IntS3 == pctx2->IntS3 &&
           pctx1->IntS4 == pctx2->IntS4 &&
           pctx1->IntS5 == pctx2->IntS5 &&
           pctx1->IntFp == pctx2->IntFp;

#elif defined(_MIPS_)
    #pragma message("I hope this is correct for MIPS")
    return pctx1->IntSp == pctx2->IntSp &&      /* Stack pointer */
           pctx1->IntS0 == pctx2->IntS0 &&      /* Nonvolatile registers */
           pctx1->IntS1 == pctx2->IntS1 &&
           pctx1->IntS2 == pctx2->IntS2 &&
           pctx1->IntS3 == pctx2->IntS3 &&
           pctx1->IntS4 == pctx2->IntS4 &&
           pctx1->IntS6 == pctx2->IntS6 &&
           pctx1->IntS7 == pctx2->IntS7 &&
           pctx1->IntS8 == pctx2->IntS8;

#elif defined(_PPC_)
    #pragma message("I don't know what the PPC calling conventions are")

    /* Just check the stack register */
    return pctx1->Gpr1 == pctx2->Gpr1;

#else
    #pragma message("I don't know what the calling conventions are for this platform")
    return 1;
#endif
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | Callback |
 *
 *          Perform a callback the paranoid way, checking that the
 *          application used the correct calling convention and preserved
 *          all nonvolatile registers.
 *
 *          NOTE!  Platform-dependent code!
 *
 *  @parm   STICALLBACKPROC | pfn |
 *
 *          Procedure to call back.
 *
 *  @parm   PV | pv1 |
 *
 *          First parameter to callback.
 *
 *  @parm   PV | pv2 |
 *
 *          Second parameter to callback.
 *
 *  @returns
 *
 *          Whatever the callback returns.
 *
 *****************************************************************************/

BOOL EXTERNAL
Callback(STICALLBACKPROC pfn, PV pv1, PV pv2)
{
    CONTEXT ctxPre;             /* Thread context before call */
    CONTEXT ctxPost;            /* Thread context after call */
    volatile BOOL fRc;          /* To prevent compiler from enregistering */

    /* Get state of registers before the callback */
    ctxPre.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
    GetThreadContext(GetCurrentThread(), &ctxPre);

    fRc = pfn(pv1, pv2);

    ctxPost.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
    if (GetThreadContext(GetCurrentThread(), &ctxPost) &&
        !Callback_CompareContexts(&ctxPre, &ctxPost)) {
        RPF("STI: Incorrectly prototyped callback! Crash soon!");
        ValidationException();
    }

    return fRc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\buffer.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    string.cpp

Abstract:

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

//
// Normal includes only for this module
//

#include "cplusinc.h"
#include "sticomm.h"

BOOL BUFFER::GetNewStorage( UINT cbRequested )
{

    _pb = (BYTE *) ::LocalAlloc( LPTR , cbRequested );

    if ( !_pb ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    _cb = cbRequested;

    return TRUE;
}


BOOL BUFFER::ReallocStorage( UINT cbNewRequested )
{

    HANDLE hNewMem = ::LocalReAlloc( _pb, cbNewRequested, 0 );

    if (hNewMem == 0) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    _pb = (BYTE *) hNewMem;

    ASSERT( _pb != NULL );

    _cb = cbNewRequested;

    return TRUE;
}

VOID BUFFER::VerifyState() const
{
    ASSERT(( _pb == NULL && _cb == 0 ) ||
             ( _pb != NULL && _cb != 0 ));
}

BOOL BUFFER::Resize( UINT cbNewRequested,
                     UINT cbSlop )
{
#if DBG
    VerifyState();
#endif

    if ( cbNewRequested != 0 ) {

        if ( _pb != 0 ) {

            if ( cbNewRequested > QuerySize() ) {

                /*
                 * The requested memory exceeds the currently allocated memory.
                 * A reallocation is in order.
                 */
                return ReallocStorage(cbNewRequested + cbSlop);
            }

            return TRUE;
        }
        else {
            /*
             * There is no memory handle.  Previous size of buffer
             * must have been 0.
             *
             * The new memory request is allocated.
             */
            return GetNewStorage( cbNewRequested );
        }
    }
    else {
        /*
         * The requested memory size is 0.  This will always work.
         */
        if ( _pb )
            ::LocalFree( (HANDLE)_pb );

        _pb = NULL;
        _cb = 0;

        return TRUE;
    }

    return TRUE;
}


VOID BUFFER::Trim()
{
#if DBG
    VerifyState();
#endif

    if ( _pb == 0 ) {
        /*
         * No memory is allocated.
         */
        ASSERT( _pb == NULL && _cb == 0 );
        return;
    }

    if ( _cb == 0 ) {
        /*
         * The requested size is 0.  Free the allocated memory.
         */
        ASSERT( _pb == NULL );

        return;
    }

    /*
     * (This should not fail, since we are reallocating to less
     * than current storage.)
     */
    REQUIRE( NO_ERROR == ReallocStorage(_cb) );
}

BOOL
BUFFER_CHAIN::AppendBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Adds a new buffer chain item to the end of the buffer chain

Arguments:

    pBCI - Chain item to append

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    ASSERT( pBCI );
    ASSERT( pBCI->_ListEntry.Flink == NULL );

    InsertTailList( &_ListHead,
                    &pBCI->_ListEntry );

    return TRUE;
}

DWORD
BUFFER_CHAIN::DeleteChain(
    VOID
    )
/*++

Routine Description:

    Deletes all of the buffers in this chain

Return Value:

    Total number of allocated bytes freed by this call

--*/
{
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbFreed = 0;

    while ( !IsListEmpty( &_ListHead ))
    {
        pBCI = CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );

        ASSERT( pBCI->_ListEntry.Flink != NULL );

        RemoveEntryList( &pBCI->_ListEntry );

        cbFreed += pBCI->QuerySize();

        delete pBCI;
    }

    return cbFreed;
}

BUFFER_CHAIN_ITEM *
BUFFER_CHAIN::NextBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Returns the next buffer in the chain.  Start the enumeration by
    passing pBCI as NULL.  Continue it by passing the return value

Arguments:

    pBCI - Previous item in enumeration

Return Value:

    Pointer to next item in chain, NULL when done

--*/
{
    if ( pBCI != NULL )
    {
        if ( pBCI->_ListEntry.Flink != &_ListHead )
        {
            return CONTAINING_RECORD( pBCI->_ListEntry.Flink,
                                      BUFFER_CHAIN_ITEM,
                                      _ListEntry );
        }
        else
        {
            return NULL;
        }
    }

    if ( !IsListEmpty( &_ListHead ))
    {
        return CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );
    }

    return NULL;
}

DWORD
BUFFER_CHAIN::CalcTotalSize(
    BOOL fUsed
    ) const
/*++

Routine Description:

    Returns the total amount of memory allocated by this buffer chain
    excluding the size of the structures themselves


Arguments:

    fUsed - If FALSE, returns total allocated by chain, if TRUE returns
        total used by chain

Return Value:

    Total bytes allocated or total bytes used

--*/
{
    LIST_ENTRY *        pEntry;
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbRet = 0;

    for ( pEntry  = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry  = pEntry->Flink )
    {
        pBCI = CONTAINING_RECORD( pEntry, BUFFER_CHAIN_ITEM, _ListEntry );

        if ( fUsed == FALSE )
            cbRet += pBCI->QuerySize();
        else
            cbRet += pBCI->QueryUsed();
    }

    return cbRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\cplusinc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cplusinc.h

Abstract:

Author:

    Byron CHanguion     (byronc)    29-May-2000

Revision History:

    29-May-2000         ByronC      created

--*/

#ifdef WINNT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#endif

#define _ATL_APARTMENT_FREE
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

#include <atlapp.h>
#include <atltmp.h>

#include <stilib.h>

#include <stidebug.h>

#include <validate.h>

#include <regentry.h>   // registry manipulation object
#include "wialog.h"

#include <stisvc.h>
#define STISVC_REG_PATH L"System\\CurrentControlSet\\Services\\" STI_SERVICE_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\common.c ===
/*****************************************************************************
 *
 *  Common.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Shared stuff that operates on all classes
 *
 *      This version of the common services supports multiple
 *      inheritance natively.  You can pass any interface of an object,
 *      and the common services will do the right thing.
 *
 *  Contents:
 *
 *****************************************************************************/
/*
#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <regstr.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <stdio.h>

#include <stilog.h>
#include <stiregi.h>

#include <sti.h>
#include <stierr.h>
#include <stiusd.h>
#include "wia.h"
#include "stipriv.h"
#include "stiapi.h"
#include "stirc.h"
#include "debug.h"
*/
#include "sticomm.h"

#define DbgFl DbgFlCommon

/*****************************************************************************
 *
 *  USAGE FOR OLE OBJECTS
 *
 *      Suppose you want to implement an object called CObj that supports
 *      the interfaces Foo, Bar, and Baz.  Suppose that you opt for
 *      Foo as the primary interface.
 *
 *      >> NAMING CONVENTION <<
 *
 *          COM objects begin with the letter "C".
 *
 *      (1) Declare the primary and secondary vtbls.
 *
 *              Primary_Interface(CObj, IFoo);
 *              Secondary_Interface(CObj, IBar);
 *              Secondary_Interface(CObj, IBaz);
 *
 *      (3) Declare the object itself.
 *
 *              typedef struct CObj {
 *                  IFoo        foo;        // Primary must come first
 *                  IBar        bar;
 *                  IBaz        baz;
 *                  ... other fields ...
 *              } CObj;
 *
 *      (4) Implement the methods.
 *
 *          You may *not* reimplement the AddRef and Release methods!
 *          although you can subclass them.
 *
 *      (5) To allocate an object of the appropriate type, write
 *
 *              hres = Common_NewRiid(CObj, punkOuter, riid, ppvOut);
 *
 *          or, if the object is variable-sized,
 *
 *              hres = Common_NewCbRiid(cb, CObj, punkouter, riid, ppvOut);
 *
 *          Common_NewRiid and Common_NewCbRiid will initialize both the
 *          primary and secondary vtbls.
 *
 *      (6) Define the object signature.
 *
 *              #pragma BEGIN_CONST_DATA
 *
 *              #define CObj_Signature        0x204A424F      // "OBJ "
 *
 *      (7) Define the object template.
 *
 *              Interface_Template_Begin(CObj)
 *                  Primary_Interface_Template(CObj, IFoo)
 *                Secondary_Interface_Template(CObj, IBar)
 *                Secondary_Interface_Template(CObj, IBaz)
 *              Interface_Template_End(CObj)
 *
 *      (8) Define the interface descriptors.
 *
 *              // The macros will declare QueryInterface, AddRef and Release
 *              // so don't list them again
 *
 *              Primary_Interface_Begin(CObj, IFoo)
 *                  CObj_FooMethod1,
 *                  CObj_FooMethod2,
 *                  CObj_FooMethod3,
 *                  CObj_FooMethod4,
 *              Primary_Interface_End(Obj, IFoo)
 *
 *              Secondary_Interface_Begin(CObj, IBar, bar)
 *                  CObj_Bar_BarMethod1,
 *                  CObj_Bar_BarMethod2,
 *              Secondary_Interface_Begin(CObj, IBar, bar)
 *
 *              Secondary_Interface_Begin(CObj, IBaz, baz)
 *                  CObj_Baz_BazMethod1,
 *                  CObj_Baz_BazMethod2,
 *                  CObj_Baz_BazMethod3,
 *              Secondary_Interface_Begin(CObj, IBaz, baz)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  USAGE FOR NON-OLE OBJECTS
 *
 *      All objects are COM objects, even if they are never given out.
 *      In the simplest case, it just derives from IUnknown.
 *
 *      Suppose you want to implement an object called Obj which is
 *      used only internally.
 *
 *      (1) Declare the vtbl.
 *
 *              Simple_Interface(Obj);
 *
 *      (3) Declare the object itself.
 *
 *              typedef struct Obj {
 *                  IUnknown unk;
 *                  ... other fields ...
 *              } Obj;
 *
 *      (4) Implement the methods.
 *
 *          You may *not* override the QueryInterface, AddRef or
 *          Release methods!
 *
 *      (5) Allocating an object of the appropriate type is the same
 *          as with OLE objects.
 *
 *      (6) Define the "vtbl".
 *
 *              #pragma BEGIN_CONST_DATA
 *
 *              Simple_Interface_Begin(Obj)
 *              Simple_Interface_End(Obj)
 *
 *          That's right, nothing goes between the Begin and the End.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      CommonInfo
 *
 *      Information tracked for all common objects.
 *
 *      A common object looks like this:
 *
 *                          rgvtbl
 *                          cbvtbl
 *            D(dwSig)      QIHelper
 *              cRef        FinalizeProc
 *              punkOuter   riid
 *              unkPrivate  0
 *      pFoo -> lpVtbl ->   QueryInterface
 *              lpVtbl2     Common_AddRef
 *              data        Common_Release
 *              ...         ...
 *
 *      Essentially, we use the otherwise-unused space above the
 *      pointers to record our bookkeeping information.
 *
 *      punkOuter    = controlling unknown, if object is aggregated
 *      lpvtblPunk   = special vtbl for controlling unknown to use
 *      cRef         = object reference count
 *      riid         = object iid
 *      rgvtbl       = array of vtbls of supported interfaces
 *      cbvtbl       = size of array in bytes
 *      QIHelper     = QueryInterface helper for aggregation
 *      FinalizeProc = Finalization procedure
 *
 *      For secondary interfaces, it looks like this:
 *
 *                        riid
 *                        offset to primary interface
 *      pFoo -> lpVtbl -> Forward_QueryInterface
 *                        Forward_AddRef
 *                        Forward_Release
 *                        ...
 *
 *****************************************************************************/

/* WARNING!  cin_dwSig must be first:  ci_Start relies on it */

typedef struct CommonInfoN {        /* This goes in front of the object */
 RD(ULONG cin_dwSig;)               /* Signature (for parameter validation) */
    ULONG cin_cRef;                 /* Object reference count */
    PUNK cin_punkOuter;             /* Controlling unknown */
    IUnknown cin_unkPrivate;        /* Private IUnknown */
} CommonInfoN, CIN, *PCIN;

typedef struct CommonInfoP {        /* This is how we pun the object itself */
    PREVTBLP *cip_prevtbl;          /* Vtbl of object (will be -1'd) */
} CommonInfoP, CIP, *PCIP;

typedef union CommonInfo {
    CIN cin[1];
    CIP cip[1];
} CommonInfo, CI, *PCI;

#define ci_dwSig        cin[-1].cin_dwSig
#define ci_cRef         cin[-1].cin_cRef
#define ci_punkOuter    cin[-1].cin_punkOuter
#define ci_unkPrivate   cin[-1].cin_unkPrivate
#define ci_rgfp         cip[0].cip_prevtbl

#define ci_rgvtbl       cip[0].cip_prevtbl[-1].rgvtbl
#define ci_cbvtbl       cip[0].cip_prevtbl[-1].cbvtbl
#define ci_QIHelper     cip[0].cip_prevtbl[-1].QIHelper
#define ci_Finalize     cip[0].cip_prevtbl[-1].FinalizeProc
#define ci_riid         cip[0].cip_prevtbl[-1].prevtbl.riid
#define ci_lib          cip[0].cip_prevtbl[-1].prevtbl.lib

#ifdef MAXDEBUG
#define ci_Start        ci_dwSig
#else
#define ci_Start        ci_cRef
#endif

#define ci_dwSignature  0x38162378              /* typed by my cat */

/*****************************************************************************
 *
 *      Common_Finalize (from Common_Release)
 *
 *      By default, no finalization is necessary.
 *
 *****************************************************************************/

void EXTERNAL
Common_Finalize(PV pv)
{
    DebugOutPtszV(DbgFlCommon, TEXT("Common_Finalize(%08x)"), pv);
}

/*****************************************************************************
 *
 *      "Private" IUnknown methods
 *
 *      When a COM object is aggregated, it exports *two* IUnknown
 *      interfaces.
 *
 *      The "private" IUnknown is the one that is returned to the
 *      controlling unknown.  It is this unknown that the controlling
 *      unknown uses to manipulate the refcount on the inner object.
 *
 *      The "public" IUnknown is the one that all external callers see.
 *      For this, we just hand out the controlling unknown.
 *
 *****************************************************************************/

Secondary_Interface(CCommon, IUnknown);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PV | thisPunk |
 *
 *          Convert a private punk (&cin_unkPrivate) into the beginning of
 *          the actual object.
 *
 *  @parm   PUNK | punkPrivate |
 *
 *          The private punk (&cin_unkPrivate) corresponding to some
 *          object we are managing.
 *
 *  @returns
 *
 *          The object pointer on success, or 0 on error.
 *
 *  @comm
 *
 *          We do not return an <t HRESULT> on error, because the
 *          callers of the procedure typically do not return
 *          <t HRESULT>s themselves.
 *
 *****************************************************************************/

#ifndef MAXDEBUG

#define thisPunk_(punk, z)                                          \
       _thisPunk_(punk)                                             \

#endif

PV INLINE
thisPunk_(PUNK punkPrivate, LPCSTR s_szProc)
{
    PV pv = NULL;

    if (SUCCEEDED(hresFullValidReadPdw(punkPrivate, 0))) {
        if (punkPrivate->lpVtbl == Class_Vtbl(CCommon, IUnknown)) {
            pv = pvAddPvCb(punkPrivate,
                             cbX(CIN) - FIELD_OFFSET(CIN, cin_unkPrivate));
        } else {
            // WarnPszV("%s: Invalid parameter 0", szProc);
            pv = NULL;
        }
    }
    return pv;
}

#define thisPunk(punk)                                              \
        thisPunk_(punk, s_szProc)                                   \


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Common_QIHelper |
 *
 *          Called when we can't find any interface in the standard list.
 *          See if there's a dynamic interface we can use.
 *
 *          Objects are expected to override this method if
 *          they implement dynamic interfaces.
 *
 *  @parm   PV | pv |
 *
 *          The object being queried.
 *
 *  @parm   RIID | riid |
 *
 *          The interface being requested.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *  @returns
 *
 *          Always returns <c E_NOINTERFACE>.
 *
 *****************************************************************************/

STDMETHODIMP
Common_QIHelper(PV pv, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    *ppvObj = NULL;
    hres = E_NOINTERFACE;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Common_PrivateQueryInterface |
 *
 *          Common implementation of <mf IUnknown::QueryInterface> for
 *          the "private <i IUnknown>".
 *
 *          Note that we AddRef through the public <i IUnknown>
 *          (<ie>, through the controlling unknown).
 *          That's part of the rules of aggregation,
 *          and we have to follow them in order to keep the controlling
 *          unknown from getting confused.
 *
 *  @parm   PUNK | punkPrivate |
 *
 *          The object being queried.
 *
 *  @parm   RIID | riid |
 *
 *          The interface being requested.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      The "compiler issue" remark boils down to the fact that the
 *      compiler fails to recognize this:
 *
 *      for (i = 0; i < n; i++) {
 *          if (cond) {
 *              mumble();
 *              break;
 *          }
 *      }
 *      if (i >= n) {
 *          gurgle();
 *      }
 *
 *      and turn it into this:
 *
 *      for (i = 0; i < n; i++) {
 *          if (cond) {
 *              mumble();
 *              goto done;
 *          }
 *      }
 *      gurgle();
 *      done:;
 *
 *      But even with this help, the compiler emits pretty dumb code.
 *
 *****************************************************************************/

STDMETHODIMP
Common_PrivateQueryInterface(PUNK punkPrivate, REFIID riid, PPV ppvObj)
{
    PCI pci;
    HRESULT hres;

    EnterProcR(IUnknown::QueryInterface, (_ "pG", punkPrivate, riid));

    pci = thisPunk(punkPrivate);
    if (pci) {
        if (IsEqualIID(riid, &IID_IUnknown)) {
            *ppvObj = pci;
            OLE_AddRef(pci->ci_punkOuter);
            hres = S_OK;
        } else {
            UINT ivtbl;
            for (ivtbl = 0; ivtbl * sizeof(PV) < pci->ci_cbvtbl; ivtbl++) {
                if (IsEqualIID(riid, ((PCI)(&pci->ci_rgvtbl[ivtbl]))->ci_riid)) {
                    *ppvObj = pvAddPvCb(pci, ivtbl * sizeof(PV));
                    OLE_AddRef(pci->ci_punkOuter);
                    hres = S_OK;
                    goto exit;          /* see "compiler issue" comment above */
                }
            }
            hres = pci->ci_QIHelper(pci, riid, ppvObj);
        }
    } else {
        hres = E_INVALIDARG;
    }

exit:;
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   ULONG | Common_PrivateAddRef |
 *
 *          Increment the object refcount.
 *
 *  @parm   PUNK | punkPrivate |
 *
 *          The object being addref'd.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Common_PrivateAddRef(PUNK punkPrivate)
{
    PCI pci;
    ULONG ulRef;
    EnterProcR(IUnknown::AddRef, (_ "p", punkPrivate));

    pci = thisPunk(punkPrivate);
    if (pci) {
        ulRef = ++pci->ci_cRef;
    } else {
        ulRef = 0;
    }

    ExitProcX(ulRef);
    return ulRef;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   ULONG | Common_PrivateRelease |
 *
 *          Decrement the object refcount.
 *
 *          If the object refcount drops to zero, finalize the object
 *          and free it, then decrement the dll refcount.
 *
 *          To protect against potential re-entrancy during finalization
 *          (in case finalization does an artificial
 *          <f AddRef>/<f Release>), we
 *          do our own artificial <f AddRef>/<f Release> up front.
 *
 *  @parm   PUNK | punkPrivate |
 *
 *          The object being release'd.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Common_PrivateRelease(PUNK punkPrivate)
{
    PCI pci;
    ULONG ulRc;
    EnterProcR(IUnknown::Release, (_ "p", punkPrivate));

    pci = thisPunk(punkPrivate);
    if (pci) {
        ulRc = --pci->ci_cRef;
        if (ulRc == 0) {
            ++pci->ci_cRef;
            pci->ci_Finalize(pci);
            /* Artificial release is pointless: we're being freed */
            FreePv(pvSubPvCb(pci, sizeof(CIN)));
            DllRelease();
        }
    } else {
        ulRc = 0;
    }

    ExitProcX(ulRc);
    return ulRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global IUnknownVtbl * | c_lpvtblPunk |
 *
 *          The special IUnknown object that only the controlling unknown
 *          knows about.
 *
 *          This is the one that calls the "Real" services.  All the normal
 *          vtbl's go through the controlling unknown (which, if we are
 *          not aggregated, points to ourselves).
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

_Secondary_Interface_Begin(CCommon, IUnknown,
                           (ULONG)(FIELD_OFFSET(CIN, cin_unkPrivate) - cbX(CIN)),
                           Common_Private)
_Secondary_Interface_End(CCommon, IUnknown)

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *      "Public" IUnknown methods
 *
 *      These simply forward through the controlling unknown.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Common_QueryInterface |
 *
 *          Forward through the controlling unknown.
 *
 *  @parm   PUNK | punk |
 *
 *          The object being queried.
 *
 *  @parm   RIID | riid |
 *
 *          The interface being requested.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

STDMETHODIMP
Common_QueryInterface(PV pv, REFIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IUnknown::QueryInterface, (_ "pG", pv, riid));

    if (SUCCEEDED(hres = hresFullValidPitf(pv, 0))) {
        PCI pci = _thisPv(pv);
        AssertF(pci->ci_punkOuter);
        hres = OLE_QueryInterface(pci->ci_punkOuter, riid, ppvObj);
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   ULONG | Common_AddRef |
 *
 *          Forward through the controlling unknown.
 *
 *  @parm   PUNK | punk |
 *
 *          The object being addref'd.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Common_AddRef(PV pv)
{
    ULONG ulRef;
    HRESULT hres;
    EnterProcR(IUnknown::AddRef, (_ "p", pv));

    if (SUCCEEDED(hres = hresFullValidPitf(pv, 0))) {
        PCI pci = _thisPv(pv);
        ulRef = OLE_AddRef(pci->ci_punkOuter);
    } else {
        ulRef = 0;
    }
    ExitProcX(ulRef);
    return ulRef;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   ULONG | Common_Release |
 *
 *          Forward through the controlling unknown.
 *
 *  @parm   PUNK | punk |
 *
 *          Object being release'd.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Common_Release(PV pv)
{
    ULONG ulRc;
    HRESULT hres;
    EnterProcR(IUnknown::Release, (_ "p", pv));

    if (SUCCEEDED(hres = hresFullValidPitf(pv, 0))) {
        PCI pci = _thisPv(pv);
        ulRc = OLE_Release(pci->ci_punkOuter);
    } else {
        ulRc = 0;
    }
    ExitProcX(ulRc);
    return ulRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | __Common_New |
 *
 *          Create a new object with refcount 1 and the specific vtbl.
 *          All other fields are zero-initialized.  All parameters must
 *          already be validated.
 *
 *  @parm   ULONG | cb |
 *
 *          Size of object.  This does not include the hidden bookkeeping
 *          bytes maintained by the object manager.
 *
 *  @parm   PUNK | punkOuter |
 *
 *          Controlling unknown for OLE aggregation.  May be 0 to indicate
 *          that the object is not aggregated.
 *
 *  @parm   PV | vtbl |
 *
 *          Pointer to primary vtbl for this object.  Note that the
 *          vtbl declaration macros include other magic goo near the vtbl,
 *          which we consult in order to create the object.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

STDMETHODIMP
__Common_New(ULONG cb, PUNK punkOuter, PV vtbl, PPV ppvObj)
{
    HRESULT hres;
    EnterProc(__Common_New, (_ "uxx", cb, punkOuter, vtbl));

    hres = AllocCbPpv(cb + sizeof(CIN), ppvObj);
    if (SUCCEEDED(hres)) {
        PCI pciO = (PV)&vtbl;
        PCI pci = pvAddPvCb(*ppvObj, sizeof(CIN));
     RD(pci->ci_dwSig = ci_dwSignature);
        pci->ci_unkPrivate.lpVtbl = Class_Vtbl(CCommon, IUnknown);
        if (punkOuter) {
            pci->ci_punkOuter = punkOuter;
        } else {
            pci->ci_punkOuter = &pci->ci_unkPrivate;
        }
        CopyMemory(pci, pciO->ci_rgvtbl, pciO->ci_cbvtbl);
        *ppvObj = pci;
        pci->ci_cRef++;
        DllAddRef();
        hres = S_OK;
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | _Common_New_ |
 *
 *          Create a new object with refcount 1 and the specific vtbl.
 *          All other fields are zero-initialized.  This entry point
 *          validates parameters.
 *
 *  @parm   ULONG | cb |
 *
 *          Size of object.  This does not include the hidden bookkeeping
 *          bytes maintained by the object manager.
 *
 *  @parm   PUNK | punkOuter |
 *
 *          Controlling unknown for OLE aggregation.  May be 0 to indicate
 *          that the object is not aggregated.
 *
 *  @parm   PV | vtbl |
 *
 *          Pointer to primary vtbl for this object.  Note that the
 *          vtbl declaration macros include other magic goo near the vtbl,
 *          which we consult in order to create the object.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

STDMETHODIMP
_Common_New_(ULONG cb, PUNK punkOuter, PV vtbl, PPV ppvObj, LPCSTR pszProc)
{
    HRESULT hres;
    EnterProc(_Common_New, (_ "uxx", cb, punkOuter, vtbl));

    if (SUCCEEDED(hres = hresFullValidPitf0_(punkOuter, pszProc, 1)) &&
        SUCCEEDED(hres = hresFullValidPdwOut_(ppvObj, pszProc, 3))) {
        hres = __Common_New(cb, punkOuter, vtbl, ppvObj);
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | _Common_NewRiid_ |
 *
 *          Create a new object with refcount 1 and the specific vtbl,
 *          but only if the object supports the indicated interface.
 *          All other fields are zero-initialized.
 *
 *          If punkOut is nonzero, then the object is being created for
 *          aggregation.  The interface must then be &IID_IUnknown.
 *
 *          Aggregation is used to allow multiple IStillImageXXX interfaces
 *          to hang off one logical object.
 *
 *          It is assumed that the prototype of the calling function is
 *
 *          foo(PV this, PUNK punkOuter, RIID riid, PPV ppvObj);
 *
 *  @parm   ULONG | cb |
 *
 *          Size of object.  This does not include the hidden bookkeeping
 *          bytes maintained by the object manager.
 *
 *  @parm   PV | vtbl |
 *
 *          Pointer to primary vtbl for this object.  Note that the
 *          vtbl declaration macros include other magic goo near the vtbl,
 *          which we consult in order to create the object.
 *
 *  @parm   PUNK | punkOuter |
 *
 *          Controlling unknown for OLE aggregation.  May be 0 to indicate
 *          that the object is not aggregated.
 *
 *  @parm   RIID | riid |
 *
 *          Interface requested.
 *
 *  @parm   PPV | ppvObj |
 *
 *          Output pointer.
 *
 *****************************************************************************/

STDMETHODIMP
_Common_NewRiid_(ULONG cb, PV vtbl, PUNK punkOuter, RIID riid, PPV ppvObj,
                 LPCSTR pszProc)
{
    HRESULT hres;
    EnterProc(Common_NewRiid, (_ "upG", cb, punkOuter, riid));

    /*
     * Note: __Common_New does not validate punkOuter or ppvObj,
     * so we have to.  Note also that we validate ppvObj first,
     * so that it will be set to zero as soon as possible.
     */

    if (SUCCEEDED(hres = hresFullValidPdwOut_(ppvObj, pszProc, 3)) &&
        SUCCEEDED(hres = hresFullValidPitf0_(punkOuter, pszProc, 1)) &&
        SUCCEEDED(hres = hresFullValidRiid_(riid, pszProc, 2))) {

        if (fLimpFF(punkOuter, IsEqualIID(riid, &IID_IUnknown))) {
            hres = __Common_New(cb, punkOuter, vtbl, ppvObj);
            if (SUCCEEDED(hres)) {

                /*
                 *  Move to the requested interface if we aren't aggregated.
                 *  Don't do this if aggregated! or we will lose the private
                 *  IUnknown and then the caller will be hosed.
                 */

                if (punkOuter) {
                    PCI pci = *ppvObj;
                    *ppvObj = &pci->ci_unkPrivate;
                } else {
                    PUNK punk = *ppvObj;
                    hres = Common_QueryInterface(punk, riid, ppvObj);
                    Common_Release(punk);
                }
            }
        } else {
            RD(RPF("%s: IID must be IID_IUnknown if created for aggregation",
                   pszProc));
            *ppvObj = 0;
            hres = CLASS_E_NOAGGREGATION;
        }
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      Invoke_Release
 *
 *      Release the object (if there is one) and wipe out the back-pointer.
 *      Note that we wipe out the value before calling the release, in order
 *      to ameliorate various weird callback conditions.
 *
 *****************************************************************************/

void EXTERNAL
Invoke_Release(PPV pv)
{
    LPUNKNOWN punk = (PV)pvExchangePpvPv((PPV)pv, (PV)0);
    if (punk) {
        punk->lpVtbl->Release(punk);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresPvVtbl_ |
 *
 *          Validate that an interface pointer is what it claims to be.
 *          It must be the object associated with the <p vtbl>.
 *
 *  @parm   IN PV | pv |
 *
 *          The thing that claims to be an interface pointer.
 *
 *  @parm   IN PV | vtbl |
 *
 *          What it should be, or something equivalent to this.
 *
 *  @returns
 *
 *          Returns <c S_OK> if everything is okay, else
 *          <c E_INVALIDARG>.
 *
 *****************************************************************************/

HRESULT EXTERNAL
hresPvVtbl_(PV pv, PV vtbl, LPCSTR s_szProc)
{
    PUNK punk = pv;
    HRESULT hres;

    AssertF(vtbl);
    if (SUCCEEDED(hres = hresFullValidReadPdw(punk, 0))) {
#ifdef MAXDEBUG
        if (punk->lpVtbl == vtbl) {
            hres = S_OK;
        } else {
            RPF("ERROR %s: arg %d: invalid pointer", s_szProc, 0);
            hres = E_INVALIDARG;
        }
#else
        UINT ivtbl;
        PV vtblUnk = punk->lpVtbl;
        PCI pci = (PV)&vtbl;
        if (pci->ci_lib == 0) {
            for (ivtbl = 0; ivtbl * sizeof(PV) < pci->ci_cbvtbl; ivtbl++) {
                if (pci->ci_rgvtbl[ivtbl] == vtblUnk) {
                    hres = S_OK;
                    goto found;
                }
            }
            hres = E_INVALIDARG;
        found:;
        } else {
            if (punk->lpVtbl == vtbl) {
                hres = S_OK;
            } else {
                hres = E_INVALIDARG;
            }
        }
#endif
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\cdlg.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cdlg.cpp

Abstract:

    Imitation of MFC CDialog class

Author:

    Vlad Sadovsky   (vlads) 26-Mar-1997

Revision History:

    26-Mar-1997     VladS       created

--*/


#include "cplusinc.h"
#include "sticomm.h"

#include "cdlg.h"
#include "windowsx.h"

VOID CALLBACK
TimerDlgProc(HWND hwnd,UINT uMsg,UINT idEvent,DWORD dwTime);

//
// Constructor/destructor
//
CDlg::CDlg(int DlgID, HWND hWnd, HINSTANCE hInst,UINT   msElapseTimePeriod)
: m_DlgID(DlgID),
  m_hParent(hWnd),
  m_Inst(hInst),
  m_bCreatedModeless(FALSE),
  m_msElapseTimePeriod(msElapseTimePeriod),
  m_hDlg(0),
  m_uiTimerId(0)
{
}

CDlg::~CDlg()
{
    if (m_uiTimerId) {
        ::KillTimer(GetWindow(),m_uiTimerId);
        m_uiTimerId = 0;
    }

    if(m_hDlg) {
        DestroyWindow(m_hDlg);
    }
}

INT_PTR
CALLBACK
CDlg::BaseDlgProc(
    HWND    hDlg,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM lParam
    )
{
    CDlg * pSV = (CDlg*) GetWindowLongPtr(hDlg,DWLP_USER);

    switch (uMessage) {
        case WM_INITDIALOG:
        {
            ASSERT(lParam);

            pSV=(CDlg*)lParam;
            pSV->SetWindow(hDlg);

            SetWindowLongPtr(hDlg,DWLP_USER,(LONG_PTR)pSV);

            //
            // Create timer for canceling dialog if user did not respond in time
            //
            if(pSV->m_msElapseTimePeriod) {
                pSV->m_uiTimerId = ::SetTimer(pSV->GetWindow(),ID_TIMER_EVENT,pSV->m_msElapseTimePeriod,NULL);
                //(TIMERPROC)TimerDlgProc);
            }

            pSV->OnInit();
        }
        break;

        case WM_COMMAND:
            if(pSV) {
                return pSV->OnCommand(LOWORD(wParam),(HWND)lParam,HIWORD(wParam));
            }
        break;

        case WM_NOTIFY:
            if(pSV) {
                return pSV->OnNotify((NMHDR FAR *)lParam);
            }
        break;

        case WM_DESTROY:
            if(pSV) {
                pSV->Destroy();
            }
            break;

        case WM_TIMER:
            if(pSV && pSV->m_uiTimerId && (ID_TIMER_EVENT == wParam)) {
                // Imitate cancel
                ::PostMessage(hDlg,
                              WM_COMMAND,
                              #ifdef _WIN64
                              (WPARAM)MAKELONG(IDCANCEL,0), (LPARAM)(pSV->GetDlgItem(IDCANCEL))
                              #else
                              GET_WM_COMMAND_MPS(IDCANCEL, pSV->GetDlgItem(IDCANCEL), 0)
                              #endif
                );
            }
        break;
    }

    if(pSV) {
        return pSV->DlgProc(hDlg,uMessage,wParam,lParam);
    }

    return FALSE;
}

//
// Overridable dialog procedure and message handlers
//
BOOL
CALLBACK
CDlg::DlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return FALSE;
}

int
CDlg::OnCommand(
    UINT    id,
    HWND    hwndCtl,
    UINT    codeNotify
    )
{
    switch( id) {
        case IDOK:
        case IDCANCEL:
            EndDialog(id);
        break;
    }
    return 1;   // not handled
}

void CDlg::OnInit()
{
}

int CDlg::OnNotify(NMHDR * pHdr)
{
    return FALSE;
}

//
// Creation functions
//
INT_PTR CDlg::CreateModal()
{
    m_bCreatedModeless=FALSE;
    return DialogBoxParam( m_Inst,  MAKEINTRESOURCE(m_DlgID), m_hParent, BaseDlgProc, (LPARAM)this);
}

HWND CDlg::CreateModeless()
{
    if(m_hDlg) {
        return m_hDlg;
    }

    HWND hWnd=CreateDialogParam(m_Inst, MAKEINTRESOURCE(m_DlgID), m_hParent, BaseDlgProc,  (LPARAM)this);
    if(hWnd) {
        m_bCreatedModeless=TRUE;
    }

    return hWnd;
}


void CDlg::Destroy()
{
    if(m_bCreatedModeless) {
        if(m_hDlg) {
            m_hDlg=NULL;
        }
    }
}


void CDlg::SetDlgID(UINT id)
{
    m_DlgID=id;
}

void CDlg::SetInstance(HINSTANCE hInst)
{
    m_Inst=hInst;
}

VOID CALLBACK
TimerDlgProc(
    HWND hDlg,      // handle of window for timer messages
    UINT uMsg,      // WM_TIMER message
    UINT idEvent,   // timer identifier
    DWORD dwTime    // current system time
)
{
    CDlg * pSV = (CDlg*) GetWindowLongPtr(hDlg,DWLP_USER);

    if((uMsg == WM_TIMER) &&
       (pSV &&(pSV->GetTimerId() == (UINT_PTR)idEvent))
       ) {
       // Imitate cancel
       PostMessage(hDlg,
                   WM_COMMAND,
                   // GET_WM_COMMAND_MPS(IDCANCEL, pSV->GetDlgItem(IDCANCEL), 0)
                   (WPARAM)MAKELONG(IDCANCEL,0), (LPARAM)(pSV->GetDlgItem(IDCANCEL))
                   );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\coredbg.cpp ===
#include "cplusinc.h"
#include "windows.h"
#include "stdlib.h"
#include "stdio.h"
#include "coredbg.h"

#define DEBUGBUFLEN 1024

// don't log at all
#define COREDBG_DONT_LOG (COREDBG_DONT_LOG_TO_FILE | COREDBG_DONT_LOG_TO_DEBUGGER)

// if we fail to acquire mutex within this time, shutdown tracing
#define COREDBG_DEBUG_TIMEOUT 10000L

// globals
DWORD  g_dwDebugFlags         = COREDBG_DEFAULT_FLAGS;
HANDLE g_hDebugFile           = INVALID_HANDLE_VALUE;
DWORD  g_dwDebugFileSizeLimit = COREDBG_FILE_SIZE_LIMIT;
BOOL   g_bDebugInited         = FALSE;

static CHAR   g_szDebugFileName[MAX_PATH] = { 0 };
static CHAR   g_szModuleName[MAX_PATH]    = { 0 };
static HANDLE g_hDebugFileMutex           = NULL;
static BOOL   g_bInited                   = FALSE;
static BOOL   g_bBannerPrinted            = FALSE;

#undef TRACE
#ifdef DEBUG
#define TRACE(x) InternalTrace x
#else
#define TRACE(x)
#endif

////////////////////////////////////////////////
// InternalTrace
//
// Internal tracing for problems in CoreDbgWrite
//
static void InternalTrace(LPCSTR fmt, ...)
{
    char buffer[DEBUGBUFLEN];
    size_t len = 0;
    va_list marker;

    va_start(marker, fmt);

    _vsnprintf(buffer, DEBUGBUFLEN-3, fmt, marker);
    buffer[DEBUGBUFLEN - 3] = 0;
    len = strlen(buffer);
    if(len > 0)
    {
        // make sure the line has terminating "\n"
        if(buffer[len - 1] != '\n') {
            buffer[len++] = '\n';
            buffer[len] = '\0';
        }
        OutputDebugStringA(buffer);
    }

    va_end(marker);
}

//
// Creates our mutex with appropriate security descriptor
//
BOOL CoreDbgCreateDebugMutex(void)
{
#undef CHECK
#define CHECK(x) if(!(x)) { \
     TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
     goto Cleanup; }
#undef CHECK2
#define CHECK2(x, y) if(!(x)) { \
     TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
     TRACE(y); goto Cleanup; }

    BOOL success = FALSE;
    char rgchSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR) &rgchSD;
    SECURITY_ATTRIBUTES     sa;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AuthenticatedUsers = NULL;
    PSID BuiltinAdministrators = NULL;
    ULONG AclSize;
    ACL *pAcl = NULL;

    CHECK(AllocateAndInitializeSid(&NtAuthority, 2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0,
                                   &BuiltinAdministrators));
    CHECK(AllocateAndInitializeSid(&NtAuthority, 1,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   SECURITY_AUTHENTICATED_USER_RID,
                                   0, 0, 0, 0, 0, 0,
                                   &AuthenticatedUsers));
    AclSize = sizeof(ACL) +
              2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG)) +
              GetLengthSid(BuiltinAdministrators) +
              GetLengthSid(AuthenticatedUsers);
    pAcl = (ACL *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, AclSize);
    CHECK(pAcl);

    CHECK(InitializeAcl(pAcl, AclSize, ACL_REVISION));
    CHECK(AddAccessAllowedAce(pAcl, ACL_REVISION,
                              GENERIC_ALL, BuiltinAdministrators));
    CHECK(AddAccessAllowedAce(pAcl, ACL_REVISION,
                              SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                              AuthenticatedUsers));

    CHECK(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    CHECK(SetSecurityDescriptorDacl(pSD, TRUE, pAcl, FALSE));
    sa.lpSecurityDescriptor = pSD;

    CHECK((g_hDebugFileMutex = CreateMutexA(&sa, FALSE, "Global\\WiaDebugFileMut")) != NULL);

    success = TRUE;

Cleanup:
    if(BuiltinAdministrators) FreeSid(BuiltinAdministrators);
    if(AuthenticatedUsers)  FreeSid(AuthenticatedUsers);
    if(pAcl) HeapFree(GetProcessHeap(), 0, pAcl);

    return success;
}

////////////////////////////////////////////////
// CoreDbgWrite
//
// Writes specified number of bytes to a debug
// file, creating it if needed. Thread-safe.
// Registers any failure and from that point returns
// immediately.
//
static void
CoreDbgWrite(LPCSTR buffer, DWORD n)
{
#undef CHECK
#define CHECK(x) if(!(x)) { \
    TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
    bCatastrophicFailure = TRUE; goto Cleanup; }
#undef CHECK2
#define CHECK2(x, y) if(!(x)) { \
    TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
    TRACE(y); bCatastrophicFailure = TRUE; goto Cleanup; }

    DWORD cbWritten;
    DWORD dwWaitResult;
    LARGE_INTEGER newPos = { 0, 0 };
    static BOOL bCatastrophicFailure = FALSE;
    BOOL bMutexAcquired = FALSE;

    // if something is broken, return immediately
    if(bCatastrophicFailure) return;

    // make sure we have file mutex
    if(!g_hDebugFileMutex)
    {
        CHECK(CoreDbgCreateDebugMutex());
    }

    // acquire mutex
    dwWaitResult = WaitForSingleObject(g_hDebugFileMutex, COREDBG_DEBUG_TIMEOUT);

    // if we failed to acquire mutex within the specified timeout,
    // shutdown tracing (on free builds users will not know this)
    CHECK(dwWaitResult == WAIT_OBJECT_0 || dwWaitResult == WAIT_ABANDONED);

    bMutexAcquired = TRUE;

    // make sure we have open file
    if(g_hDebugFile == INVALID_HANDLE_VALUE)
    {
        // attempt to open file
        CHECK(ExpandEnvironmentStringsA(COREDBG_FILE_NAME, g_szDebugFileName, MAX_PATH));

        g_hDebugFile = CreateFileA(g_szDebugFileName, GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        CHECK2(g_hDebugFile != INVALID_HANDLE_VALUE,
            ("g_szDebugFileName = '%s'", g_szDebugFileName));
    }

    // seek to the end of file
#ifdef UNICODE    
    CHECK(SetFilePointerEx(g_hDebugFile, newPos, &newPos, SEEK_END));
#else    
    CHECK(SetFilePointer(g_hDebugFile, newPos.LowPart, (PLONG)&newPos.LowPart, SEEK_END));
#endif    

    // check the file size
    if(newPos.HighPart != 0 || newPos.LowPart > g_dwDebugFileSizeLimit)
    {
        static CHAR LogFullMessage[128];

        TRACE(("Reached log file maximum size of %d", g_dwDebugFileSizeLimit));

        sprintf(LogFullMessage, "Log file reached maximum size of %d, logging stopped.", g_dwDebugFileSizeLimit);
        CHECK2(WriteFile(g_hDebugFile, LogFullMessage, strlen(LogFullMessage), &cbWritten, NULL), ("%d", cbWritten));
        bCatastrophicFailure = TRUE;
    }

    // write data
    CHECK2(WriteFile(g_hDebugFile, buffer, n, &cbWritten, NULL),
        ("%d %d", cbWritten, n));

    // make sure we write to the disk now.
    FlushFileBuffers(g_hDebugFile);

    CHECK2(cbWritten == n, ("%d %d", n, cbWritten))

Cleanup:
    if(bMutexAcquired) ReleaseMutex(g_hDebugFileMutex);
    return;
}

////////////////////////////////////////////////
// PrintBanner
//
// Since we append to the log file, we need a
// seperator of some sort so we know when a
// new execution has started.
//
void PrintBanner(void)
{
    char buffer[1024];
    size_t len = 0;

    SYSTEMTIME SysTime;
    GetLocalTime(&SysTime);

    if (g_dwDebugFlags)
    {
        _snprintf(buffer, sizeof(buffer),
                  "====================Start '%s' Debug - Time: %d/%02d/%02d %02d:%02d:%02d:%02d====================",
                  g_szModuleName,
                  SysTime.wYear,
                  SysTime.wMonth,
                  SysTime.wDay,
                  SysTime.wHour,
                  SysTime.wMinute,
                  SysTime.wSecond,
                  SysTime.wMilliseconds);
    }

    len = strlen(buffer);
    if(len > 0)
    {
        // make sure the line has terminating "\n"
        if(buffer[len - 1] != '\n')
        {
            buffer[len++] = '\r';
            buffer[len++] = '\n';
            buffer[len] = '\0';
        }

        if(!(g_dwDebugFlags & COREDBG_DONT_LOG_TO_FILE))
        {
            CoreDbgWrite(buffer, len);
        }

#ifdef DEBUG
        if(!(g_dwDebugFlags & COREDBG_DONT_LOG_TO_DEBUGGER))
        {
            OutputDebugStringA(buffer);
        }
#endif
    }

    return;
}


////////////////////////////////////////////////
// CoreDbgGenericTrace
//
// Formats message and writes it into log file
// and/or debugger;
//
void CoreDbgGenericTrace(LPCSTR     fmt,
                         va_list    marker,
                         BOOL       bIndent)
{
    char buffer[DEBUGBUFLEN];
    size_t len = 0;

    //
    // The first time we ever print a debug statement, lets
    // output a seperator line since when we output to file
    // we append, this way we can seperate different execution
    // sessions.
    //
    if (!g_bBannerPrinted)
    {
        PrintBanner();
        g_bBannerPrinted = TRUE;
    }

    if (bIndent)
    {
        buffer[0] = '\t';
        _vsnprintf(&buffer[1], DEBUGBUFLEN - 3, fmt, marker);
    }
    else
    {
        _vsnprintf(buffer, DEBUGBUFLEN - 3, fmt, marker);
    }

    buffer[DEBUGBUFLEN - 3] = 0;
    
    len = strlen(buffer);
    if(len > 0)
    {
        // make sure the line has terminating "\n"
        if(buffer[len - 1] != '\n')
        {
            buffer[len++] = '\r';
            buffer[len++] = '\n';
            buffer[len] = '\0';
        }

        if(!(g_dwDebugFlags & COREDBG_DONT_LOG_TO_FILE))
        {
            CoreDbgWrite(buffer, len);
        }

#ifdef DEBUG
        if(!(g_dwDebugFlags & COREDBG_DONT_LOG_TO_DEBUGGER))
        {
            OutputDebugStringA(buffer);
        }
#endif
    }
}


////////////////////////////////////////////////
// CoreDbgTrace
//
// Formats message and writes it into log file
// and/or debugger;
//
void CoreDbgTrace(LPCSTR fmt, ...)
{
    va_list marker;

    // get out if we don't have to log
#ifdef DEBUG
    if((g_dwDebugFlags & COREDBG_DONT_LOG) == COREDBG_DONT_LOG)
#else
    if(g_dwDebugFlags & COREDBG_DONT_LOG_TO_FILE)
#endif
    {
        return;
    }

    va_start(marker, fmt);

    CoreDbgGenericTrace(fmt, marker, FALSE);

    va_end(marker);
}

////////////////////////////////////////////////
// CoreDbgTraceWithTab
//
// Formats message and writes it into log file
// and/or debugger;
//
void CoreDbgTraceWithTab(LPCSTR fmt, ...)
{
    va_list marker;

    // get out if we don't have to log
#ifdef DEBUG
    if((g_dwDebugFlags & COREDBG_DONT_LOG) == COREDBG_DONT_LOG)
#else
    if(g_dwDebugFlags & COREDBG_DONT_LOG_TO_FILE)
#endif
    {
        return;
    }

    va_start(marker, fmt);

    CoreDbgGenericTrace(fmt, marker, TRUE);

    va_end(marker);
}

////////////////////////////////////////////////
// GetRegDWORD
//
// Attempts to get a DWORD from the specified
// location.  If bSetIfNotExist is set, it
// writes the registry setting to the current
// value in pdwValue.
//
LRESULT GetRegDWORD(HKEY        hKey,
                    const CHAR  *pszRegValName,
                    DWORD       *pdwValue,
                    BOOL        bSetIfNotExist)
{
    LRESULT lResult = ERROR_SUCCESS;
    DWORD   dwSize  = 0;
    DWORD   dwType  = REG_DWORD;

    if ((hKey          == NULL) ||
        (pszRegValName == NULL) ||
        (pdwValue      == NULL))
    {
        return ERROR_INVALID_HANDLE;
    }

    dwSize = sizeof(DWORD);

    lResult = RegQueryValueExA(hKey,
                               pszRegValName,
                               NULL,
                               &dwType,
                               (BYTE*) pdwValue,
                               &dwSize);

    // if we didn't find the key, create it.
    if (bSetIfNotExist)
    {
        if ((lResult != ERROR_SUCCESS) ||
            (dwType  != REG_DWORD))
        {
            lResult = RegSetValueExA(hKey,
                                     pszRegValName,
                                     0,
                                     REG_DWORD,
                                     (BYTE*) pdwValue,
                                     dwSize);
        }
    }

    return lResult;
}

////////////////////////////////////////////////
// CoreDbgInit
//
// Overwrite g_dwDebugFlags and g_dwDebugFileSizeLimit
// from registry
//
void CoreDbgInit(HINSTANCE  hInstance)
{
    HKEY        hKey         = NULL;
    DWORD       dwDispositon = 0;
    DWORD       dwData;
    SYSTEMTIME  SysTime;
    DWORD       dwDisposition               = 0;
    CHAR        szModulePath[MAX_PATH + 1]  = {0};
    CHAR        szDebugKey[1023 + 1]        = {0};
    CHAR        *pszFileName                = NULL;

    GetModuleFileNameA(hInstance, szModulePath, sizeof(szModulePath));
    pszFileName = strrchr(szModulePath, '\\');

    if (pszFileName == NULL)
    {
        pszFileName = szModulePath;
    }
    else
    {
        pszFileName++;
    }

    //
    // build the registry key.
    //
    _snprintf(szDebugKey, sizeof(szDebugKey), "%s\\%s", COREDBG_FLAGS_REGKEY, pszFileName);
    lstrcpynA(g_szModuleName, pszFileName, sizeof(g_szModuleName));

    //
    // get/set the debug subkey.  The DebugValues value is stored on a per module
    // basis
    //
    if(RegCreateKeyExA(HKEY_LOCAL_MACHINE,
        szDebugKey,
        0,
        NULL,
        0,
        KEY_READ | KEY_WRITE,
        NULL,
        &hKey,
        &dwDisposition) == ERROR_SUCCESS)
    {
        dwData = g_dwDebugFlags;

        if (GetRegDWORD(hKey, COREDBG_FLAGS_REGVAL, &dwData, TRUE) == ERROR_SUCCESS)
        {
            g_dwDebugFlags = dwData;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }

    //
    // get/set the Max File Size value.  This is global to all debug modules since
    // the all write to the same file.
    //
    if(RegCreateKeyExA(HKEY_LOCAL_MACHINE,
        COREDBG_FLAGS_REGKEY,
        0,
        NULL,
        0,
        KEY_READ | KEY_WRITE,
        NULL,
        &hKey,
        &dwDisposition) == ERROR_SUCCESS)
    {
        dwData = g_dwDebugFileSizeLimit;

        if (GetRegDWORD(hKey, COREDBG_REGVAL_FILE_SIZE_LIMIT, &dwData, TRUE) == ERROR_SUCCESS)
        {
            g_dwDebugFileSizeLimit = dwData;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }

    g_bDebugInited = TRUE;

    return;
}

////////////////////////////////////////////////
// CoreDbgTerm
//
// Clean up resources.
//
void CoreDbgTerm()
{
    //
    // This is FAR from perfect.  The expectation is that
    // this function is called in the DllMain of the
    // application that is shutting down.  Thus, we shouldn't
    // really have any synchronization in here.  However, 
    // this then doesn't address the problem of a thread 
    // calling into CoreDbgWrite above and recreating these
    // objects, since we closed them (CoreDbgWrite will re-create
    // objects that are closed automatically)
    // Even worse, the WaitForSingleObject function's behavior is
    // undefined if the handle is closed while it is in a wait
    // state.
    //
    //
    if (g_hDebugFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(g_hDebugFile);
        g_hDebugFile = INVALID_HANDLE_VALUE;
    }

    if (g_hDebugFileMutex)
    {
        CloseHandle(g_hDebugFileMutex);
        g_hDebugFileMutex = INVALID_HANDLE_VALUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\device.c ===
/*****************************************************************************
 *
 *  Device.c
 *
 *  Copyright (C) Microsoft Corporation, 1996 - 2000  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The standard implementation of IStiDevice.
 *
 *  Contents:
 *
 *      CStiDevice_New
 *
 *****************************************************************************/
/*
#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <regstr.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <stdio.h>

#include <stilog.h>
#include <stiregi.h>

#include <sti.h>
#include <stierr.h>
#include <stiusd.h>
#include "stipriv.h"
#include "stiapi.h"
#include "stirc.h"
#include "debug.h"
*/
#define INITGUID
#include "initguid.h"
#include "sti.h"
#include "stiusd.h"
#include "sticomm.h"
#include "enum.h"

//#define COBJMACROS

//
// Using CreateInstance
//
// #define USE_REAL_OLE32  1

//
// Private define
//

#define DbgFl DbgFlDevice

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CStiDevice, IStiDevice);

Interface_Template_Begin(CStiDevice)
    Primary_Interface_Template(CStiDevice, IStiDevice)
Interface_Template_End(CStiDevice)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CStiDevice |
 *
 *          The <i CStiDevice> device object
 *
 *
 *  @field  IStiDevice | stidev |
 *
 *          Device interface
 *
 *  @comm
 *
 *
 *****************************************************************************/

typedef struct CStiDevice {

    /* Supported interfaces */
    IStiDevice  stidev;

    DWORD       dwVersion;

    RD(LONG cCrit;)
    D(DWORD thidCrit;)
    BOOL                fCritInited;

    CRITICAL_SECTION    crst;

    BOOL                fLocked;

    HANDLE              hNotify;
    PSTIDEVICECONTROL   pDevCtl;
    IStiUSD             *pUsd;
    LPUNKNOWN           punkUsd;
    HKEY                hkeyDeviceParameters;
    STI_USD_CAPS        sUsdCaps;

    LPWSTR              pszDeviceInternalName;
    HANDLE              hDeviceStiHandle;

    HINSTANCE           hUsdInstance;

    BOOL                fCreateForMonitor;

} CStiDevice, *PCStiDevice;

#define ThisClass       CStiDevice
#define ThisInterface   IStiDevice

STDMETHODIMP
LockDeviceHelper(
    PCStiDevice pThisDevice,
    DWORD       dwTimeOut);

STDMETHODIMP
UnLockDeviceHelper(
    PCStiDevice pThisDevice);

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPStiDevice | lpStiDevice
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPStiDevice | lpStiDevice
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPStiDevice | lpStiDevice
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IStiDevice | QIHelper |
 *
 *          We don't have any dynamic interfaces and simply forward
 *          to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 */
#ifdef DEBUG

//Default_QueryInterface(CStiDevice)
Default_AddRef(CStiDevice)
Default_Release(CStiDevice)

#else

//#define CStiDevice_QueryInterface   Common_QueryInterface
#define CStiDevice_AddRef           Common_AddRef
#define CStiDevice_Release          Common_Release

#endif

#define CStiDevice_QIHelper         Common_QIHelper

#pragma BEGIN_CONST_DATA

#pragma END_CONST_DATA



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IStiDevice | EnterCrit |
 *
 *          Enter the object critical section.
 *
 *  @cwrap  LPStiDevice | lpStiDevice
 *
 *****************************************************************************/

void EXTERNAL
CStiDevice_EnterCrit(PCStiDevice this)
{
    EnterCriticalSection(&this->crst);
    D(this->thidCrit = GetCurrentThreadId());
    RD(InterlockedIncrement(&this->cCrit));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IStiDevice | LeaveCrit |
 *
 *          Leave the object critical section.
 *
 *  @cwrap  LPStiDevice | lpStiDevice
 *
 *****************************************************************************/

void EXTERNAL
CStiDevice_LeaveCrit(PCStiDevice this)
{
#ifdef MAXDEBUG
    AssertF(this->cCrit);
    AssertF(this->thidCrit == GetCurrentThreadId());
    if (InterlockedDecrement(&this->cCrit) == 0) {
      D(this->thidCrit = 0);
    }
#endif
    LeaveCriticalSection(&this->crst);
}


/*****************************************************************************
 *
 * Verify device is locked
 *
 *****************************************************************************
 */
BOOL
CStiDevice_IsLocked(PCStiDevice this)
{
    BOOL    fRet ;

    CStiDevice_EnterCrit(this);

    fRet = this->fLocked;

    CStiDevice_LeaveCrit(this);

    return fRet;
}

void
CStiDevice_MarkLocked(PCStiDevice this,BOOL fNewState)
{

    CStiDevice_EnterCrit(this);

    this->fLocked = fNewState;

    CStiDevice_LeaveCrit(this);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IStiDevice | NotifyEvent |
 *
 *          Set the event associated with the device, if any.
 *
 *  @cwrap  LPStiDevice | lpStiDevice
 *
 *****************************************************************************/

void EXTERNAL
CStiDevice_NotifyEvent(PCStiDevice this)
{
    if (this->hNotify) {
        SetEvent(this->hNotify);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CStiDevice | LoadInitUSD |
 *
 *
 *  @cwrap  LPStiDevice | lpStiDevice
 *
 *****************************************************************************/
STDMETHODIMP
LoadInitUSD(
    CStiDevice  *this,
    HKEY        hkeyDeviceParameters
    )
{

    HRESULT     hres = STI_OK;
    IStiUSD     *pNewUsd = NULL;

    BOOL        fExternalUSD = FALSE;

    LPWSTR      pwszCLSID = NULL;
    LPUNKNOWN   this_punk;

    //
    // Load and initialize command translator (USD)
    //

    // We always create USD object as aggregated, so first we get Unknown
    // pointer and then query it for needed interfaces
    //

    this->punkUsd = NULL;
    IStiDevice_QueryInterface(&this->stidev,&IID_IUnknown,&this_punk);

    StiLogTrace(STI_TRACE_INFORMATION,MSG_LOADING_USD);

    //
    // First read CLSID for USD from the device registry key
    //
    pwszCLSID = NULL;

    hres = ReadRegistryString(hkeyDeviceParameters,
                       REGSTR_VAL_USD_CLASS_W,
                       L"",FALSE,&pwszCLSID);

    if (SUCCEEDED(hres) && *pwszCLSID)  {
        if (DllInitializeCOM()) {

            #ifdef USE_REAL_OLE32
            CLSID       clsidUSD;

            hres = CLSIDFromString(pwszCLSID,&clsidUSD);
            if (SUCCEEDED(hres))  {
                hres = CoCreateInstance(&clsidUSD,this_punk,CLSCTX_INPROC,&IID_IUnknown,&this->punkUsd);
            }
            #else

            CHAR    *pszAnsi;

            if (SUCCEEDED(OSUtil_GetAnsiString(&pszAnsi,pwszCLSID)) ) {
                hres = MyCoCreateInstanceA(pszAnsi,this_punk,&IID_IUnknown,&this->punkUsd,&this->hUsdInstance);
                FreePpv(&pszAnsi);
            }

            #endif
        }
    }
    else {
        // No class ID in registry - resort to pass through provider
        StiLogTrace(STI_TRACE_WARNING,MSG_LOADING_PASSTHROUGH_USD,hres);

        hres = CStiEmptyUSD_New(this_punk, &IID_IUnknown,&this->punkUsd);
    }

    // Free Class name
    FreePpv(&pwszCLSID);

    //
    // If USD object had been created - initialize it
    //
    if (SUCCEEDED(hres))  {

        hres = OLE_QueryInterface(this->punkUsd,&IID_IStiUSD,&pNewUsd );

        if (SUCCEEDED(hres) && pNewUsd)  {

            StiLogTrace(STI_TRACE_INFORMATION,MSG_INITIALIZING_USD);

            //
            // Initialize newly created USD object
            //
            __try {

                hres = IStiUSD_Initialize(pNewUsd,
                                        this->pDevCtl,
                                        STI_VERSION_REAL,
                                        hkeyDeviceParameters);

            }
            __except(EXCEPTION_EXECUTE_HANDLER ) {

                hres = GetExceptionCode();

            }
            //

            if (SUCCEEDED(hres))  {

                HRESULT hResCaps;

                //
                // Now get capabilities of the USD and verify version
                //

                ZeroX(this->sUsdCaps);

                __try {
                    hResCaps = IStiUSD_GetCapabilities(pNewUsd,&this->sUsdCaps);
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    hResCaps = GetExceptionCode();
                }

                if (SUCCEEDED(hResCaps) &&
                    STI_VERSION_MIN_ALLOWED <= this->sUsdCaps.dwVersion) {

                    //
                    // Hurray we loaded USD.
                    //
                    this->pUsd = pNewUsd;
                    StiLogTrace(STI_TRACE_INFORMATION,MSG_SUCCESS_USD);
                }
                else {
                    StiLogTrace(STI_TRACE_ERROR,MSG_OLD_USD);
                    hres = STIERR_OLD_VERSION;
                }
            }
            else {

                StiLogTrace(STI_TRACE_ERROR,MSG_FAILED_INIT_USD,hres);

            }

            // Free original pointer to USD object
            //OLE_Release(this->punkUsd);

            //
            // Rules of aggregation require us to release outer object ( because it was
            // AddRef'd by inner object inside delegating QueryInterface
            // Only do it if SUCCEEDED, since the outer component wont be addref'd on
            // failure.
            //

            // Attention:  first version  of USD did not properly support aggregation, but claimed
            // they did, so check our internal ref  counter to see if it is too low already.
            //
            if (SUCCEEDED(hres)) {
                {
                    ULONG ulRC = OLE_AddRef(this_punk);
                    OLE_Release(this_punk);

                    if (ulRC > 1) {
                        OLE_Release(this_punk);
                    }
                }
            }
        }
    }
    else {
        ReportStiLogMessage(g_hStiFileLog,
                            STI_TRACE_WARNING,
                            TEXT("Failed to create instance of USD object ")
                            );
    }

    //
    // Free unknown interface we got to aggreagte USD object
    //
    OLE_Release(this_punk);

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CStiDevice | QueryInterface |
 *
 *  @cwrap  LPStiDevice | lpStiDevice
 *
 *****************************************************************************/
STDMETHODIMP
CStiDevice_QueryInterface(
    PSTIDEVICE  pDev,
    RIID        riid,
    PPV         ppvObj
    )
{
    HRESULT hres;

    EnterProcR(IStiDevice::QueryInterface,(_ "p", pDev ));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        //
        // If we are asked for STI Device interface - return it. All other requests are
        // blindly passed to USD object
        //
        if (IsEqualIID(riid, &IID_IStiDevice) ||
            IsEqualIID(riid, &IID_IUnknown)) {
            hres = Common_QueryInterface(pDev, riid, ppvObj);
        }
        /*else (IsEqualIID(riid, &IID_IStiUSD)) {
            //
            // We are asked for native USD interface - return it
            //
            if (this->pUsd) {
                *ppvObj= this->pUsd;
                OLE_AddRef(*ppvObj);

                hres = STI_OK;
            }
            else {
                hres = STIERR_NOT_INITIALIZED;
            }
        }
        */
        else {
            if (this->punkUsd) {
                hres = IStiUSD_QueryInterface(this->punkUsd,riid,ppvObj);
            }
            else {
                hres = STIERR_NOINTERFACE;
            }
        }
    }

    ExitOleProc();

    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | GetCapabilities |
 *
 *  @parm   PSTI_DEV_CAPS   | pDevCaps |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiDevice_GetCapabilities(
    PSTIDEVICE  pDev,
    PSTI_DEV_CAPS pDevCaps
    )
{
    HRESULT hres;
    EnterProcR(IStiDevice::GetCapabilities,(_ "pp", pDev, pDevCaps));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);
        STI_USD_CAPS    sUsdCaps;

        __try {
            hres = IStiUSD_GetCapabilities(this->pUsd,&sUsdCaps);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)  {
            hres = GetExceptionCode();
        }


        if (SUCCEEDED(hres)) {
            pDevCaps->dwGeneric = sUsdCaps.dwGenericCaps;
        }
    }

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | GetStatus |
 *
 *  @parm   PSTI_DEVICE_STATUS    | PSTI_DEVICE_STATUS pDevStatus) |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiDevice_GetStatus(
    PSTIDEVICE  pDev,
    PSTI_DEVICE_STATUS pDevStatus
    )
{
    HRESULT hres;
    EnterProcR(IStiDevice::GetStatus,(_ "pp", pDev, pDevStatus));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        ReportStiLogMessage(g_hStiFileLog,
                            STI_TRACE_INFORMATION,
                            TEXT("Called GetStatus on a device")
                            );

        if (CStiDevice_IsLocked(this)) {

            __try {
                hres = IStiUSD_GetStatus(this->pUsd,pDevStatus);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)  {
                hres = GetExceptionCode();
            }

        }
        else {
            hres = STIERR_NEEDS_LOCK;
        }

    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | DeviceReset |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
CStiDevice_InternalReset(
    PCStiDevice     this
    )
{
    HRESULT hres = S_OK;

    //
    // Free original pointer to USD object
    //
    CStiDevice_EnterCrit(this);

    //
    // Disconnect from monitor if connected
    //
    if ( INVALID_HANDLE_VALUE!= this->hDeviceStiHandle) {
        RpcStiApiCloseDevice(NULL,this->hDeviceStiHandle);
        this->hDeviceStiHandle = INVALID_HANDLE_VALUE;
    }

    if (this->pUsd) {

        CStiDevice_AddRef(this);
        IStiUSD_Release(this->pUsd );

        this->pUsd = NULL;
    }

    if (this->punkUsd) {
        IStiUSD_Release(this->punkUsd );
        this->punkUsd = NULL;
    }

    if (this->pDevCtl) {
        IStiDeviceControl_Release(this->pDevCtl);
        this->pDevCtl = NULL;
    }

    if (this->hNotify) {
        CloseHandle(this->hNotify);
    }

    if (!(this->fCreateForMonitor)) {
        // Unlock device if it was locked
        UnLockDeviceHelper(this);
    }

    // Free device name
    if(this->pszDeviceInternalName) {
        FreePpv(&this->pszDeviceInternalName);
        this->pszDeviceInternalName = NULL;
    }

    if(this->hUsdInstance) {

        //
        // Should do it only after last interface ptr deleted
        //
        #ifdef NOT_IMPL
         // FreeLibrary(this->hUsdInstance);
        #endif
        this->hUsdInstance = NULL;
    }
    CStiDevice_LeaveCrit(this);

    return hres;

}

STDMETHODIMP
CStiDevice_DeviceReset(
    PSTIDEVICE  pDev
    )
{
    HRESULT hres;
    EnterProcR(IStiDevice::DeviceReset,(_ "p", pDev));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        if (CStiDevice_IsLocked(this)) {

            __try {
                hres = IStiUSD_DeviceReset(this->pUsd);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)  {
                hres = GetExceptionCode();
            }


        }
        else {
            hres = STIERR_NEEDS_LOCK;
        }

    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | Diagnostic |
 *
 *  @parm   LPDIAG  |   pBuffer |

 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiDevice_Diagnostic(
    PSTIDEVICE  pDev,
    LPSTI_DIAG      pBuffer
    )
{
    HRESULT hres;
    EnterProcR(IStiDevice::Diagnostic,(_ "p", pDev, pBuffer ));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        if (CStiDevice_IsLocked(this)) {

            __try {
                hres = IStiUSD_Diagnostic(this->pUsd,pBuffer);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)  {
                hres = GetExceptionCode();
            }

        }
        else {
            hres = STIERR_NEEDS_LOCK;
        }

    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT     | IStiDevice    | LockDevice |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
LockDeviceHelper(
    PCStiDevice pThisDevice,
    DWORD       dwTimeOut
    )
{
    HRESULT         hres;
    PCStiDevice     this    = _thisPv(pThisDevice);


    hres = (HRESULT) RpcStiApiLockDevice(this->pszDeviceInternalName,
                                         dwTimeOut,
                                         this->fCreateForMonitor);
    if (!pThisDevice->fCreateForMonitor) {

        if (SUCCEEDED(hres)) {

            //
            //  Call USD to lock (i.e. open any ports etc.)
            //

            __try {
                hres = IStiUSD_LockDevice(this->pUsd);
                if (SUCCEEDED(hres)) {
                    CStiDevice_MarkLocked(this, TRUE);
                }
                else
                {
                    //
                    //  The device is locked for mutally exclusive access but failed
                    //  to open port.  Make sure we release the mutally exclusive lock.
                    //
                    UnLockDeviceHelper(this);
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER)  {
                hres = HRESULT_FROM_WIN32(GetExceptionCode());

            }
        }
    }

    return hres;
}

STDMETHODIMP
CStiDevice_LockDevice(
    PSTIDEVICE  pDev,
    DWORD       dwTimeOut
    )
{
    HRESULT hres;

    EnterProcR(IStiDevice::LockDevice,(_ "p", pDev));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        hres = LockDeviceHelper(this, dwTimeOut);
    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT     | IStiDevice    | UnLockDevice |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
UnLockDeviceHelper(
    PCStiDevice pThisDevice
    )
{
    HRESULT         hres;
    PCStiDevice     this    = _thisPv(pThisDevice);

    hres = (HRESULT) RpcStiApiUnlockDevice(this->pszDeviceInternalName,
                                           this->fCreateForMonitor);

    if (!pThisDevice->fCreateForMonitor) {

        if (this->pUsd) {

            //
            //  Call USD to unlock (i.e. close any open ports etc.)
            //

            __try {
                hres = IStiUSD_UnLockDevice(this->pUsd);
                if (SUCCEEDED(hres)) {
                    CStiDevice_MarkLocked(this, FALSE);
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER)  {
                hres = HRESULT_FROM_WIN32(GetExceptionCode());
            }
        }
    }

    return hres;
}


STDMETHODIMP
CStiDevice_UnLockDevice(
    PSTIDEVICE  pDev
    )
{
    HRESULT hres;

    EnterProcR(IStiDevice::UnLockDevice,(_ "p", pDev));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        hres = UnLockDeviceHelper(this);
    }
    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | SetNotificationEvent |
 *          Specify the event that should be set when the device
 *          state changes, or turns off such notifications.
 *
 *          "It is an error" to call <f CloseHandle> on the event
 *          while it has been selected into an <i IStiDevice>
 *          object.  You must call
 *          <mf IStiDevice::SetEventNotification> with the
 *          <p hEvent> parameter set to NULL before closing the
 *          event handle.
 *
 *          If the function is successful, then the application can
 *          use the event handle in the same manner as any other
 *          Win32 event handle.
 *
 *  @cwrap  LPSTIDEVICE | lpStiDevice
 *
 *  @parm   IN HANDLE | hEvent |
 *
 *          Specifies the event handle which will be set when the
 *          device state changes.  It "must" be an event
 *          handle.  DirectInput will <f SetEvent> the handle when
 *          the state of the device changes.
 *
 *          The application should create the handle via the
 *          <f CreateEvent> function.  If the event is created as
 *          an automatic-reset event, then the operating system will
 *          automatically reset the event once a wait has been
 *          satisfied.  If the event is created as a manual-reset
 *          event, then it is the application's responsibility to
 *          call <f ResetEvent> to reset it.  We put will not
 *          call <f ResetEvent> for event notification handles.
 *
 *          If the <p hEvent> is zero, then notification is disabled.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *          <c E_INVALIDARG>: The thing isn't an event handle.
 *
 *
 *****************************************************************************/
STDMETHODIMP
CStiDevice_SetNotificationEvent(
    PSTIDEVICE  pDev,
    HANDLE      hEvent
    )
{
    HRESULT hres;
    EnterProcR(IStiDevice::SetNotificationEvent,(_ "px", pDev, hEvent ));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);


        // Must protect with the critical section to prevent somebody from
        // acquiring or setting a new event handle while we're changing it.
        CStiDevice_EnterCrit(this);

        //
        // Don't operate on the original handle because
        // the app might decide to do something strange to it
        // on another thread.


        hres = DupEventHandle(hEvent, &hEvent);

        if (SUCCEEDED(hres)) {
            //
            // Resetting the event serves two purposes.
            //
            // 1. It performs parameter validation for us, and
            // 2. The event must be reset while the device is
            //    not acquired.

            if (fLimpFF(hEvent, ResetEvent(hEvent))) {

                if (!this->hNotify || !hEvent) {

                    if (SUCCEEDED(hres)) {
                    }
                } else {

                    hres = STIERR_HANDLEEXISTS;
                }
            } else {
                hres = E_HANDLE;
            }
            CloseHandle(hEvent);
        }

        CStiDevice_LeaveCrit(this);

    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT     | IStiDevice    | Subscribe |
 *
 *  @parm   LPSUBSCRIBE |   ppBuffer    |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiDevice_Subscribe(
    PSTIDEVICE  pDev,
    LPSTISUBSCRIBE  pBuffer
    )
{
    HRESULT hres;
    DWORD   dwError = NOERROR;

    EnterProcR(IStiDevice::Subscribe,(_ "pp", pDev, pBuffer));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        dwError = RpcStiApiSubscribe(this->hDeviceStiHandle,pBuffer);
    }

    hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT     | IStiDevice    | UnSubscribe |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiDevice_UnSubscribe(
    PSTIDEVICE  pDev
    )
{
    HRESULT hres;
    DWORD   dwError = NOERROR;

    EnterProcR(IStiDevice::UnSubscribe,(_ "p", pDev));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        dwError = RpcStiApiUnSubscribe(this->hDeviceStiHandle);
    }

    hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);

    ExitOleProc();
    return hres;

}



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT     | IStiDevice    | GetNotificationData |
 *
 *  @parm   LPNOTIFY    |   ppBuffer    |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiDevice_GetNotificationData(
    PSTIDEVICE  pDev,
    LPSTINOTIFY      pBuffer
    )
{
    HRESULT hres;
    DWORD   dwError = NOERROR;

    EnterProcR(IStiDevice::GetNotificationData,(_ "p", pDev, pBuffer));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);
        dwError = RpcStiApiGetLastNotificationData(this->hDeviceStiHandle,pBuffer);
    }

    hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | Escape |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
CStiDevice_Escape(
    PSTIDEVICE  pDev,
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID      lpInData,
    DWORD       cbInDataSize,
    LPVOID      lpOutData,
    DWORD       cbOutDataSize,
    LPDWORD     pcbActualData
    )
{
    HRESULT hres;
    EnterProcR(IStiDevice::Escape,(_ "pxpxp", pDev, EscapeFunction,lpInData,cbInDataSize,lpOutData ));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        if (CStiDevice_IsLocked(this)) {

            __try {

                hres = IStiUSD_Escape(this->pUsd,
                                      EscapeFunction,
                                      lpInData,
                                      cbInDataSize,
                                      lpOutData,
                                      cbOutDataSize,
                                      pcbActualData
                                      );

            }
            __except (EXCEPTION_EXECUTE_HANDLER)  {
                hres = GetExceptionCode();
            }


        }
        else {
            hres = STIERR_NEEDS_LOCK;
        }
    }

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | RawReadData |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
CStiDevice_RawReadData(
    PSTIDEVICE  pDev,
    LPVOID      lpBuffer,
    LPDWORD     lpdwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT hres;
    EnterProcR(IStiDevice::RawReadData,(_ "p", pDev  ));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        if (CStiDevice_IsLocked(this)) {

            __try {
                hres = IStiUSD_RawReadData(this->pUsd,lpBuffer,lpdwNumberOfBytes,lpOverlapped);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)  {
                hres = GetExceptionCode();
            }

        }
        else {
            hres = STIERR_NEEDS_LOCK;
        }
    }

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | RawWriteData |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
CStiDevice_RawWriteData(
    PSTIDEVICE  pDev,
    LPVOID      lpBuffer,
    DWORD       dwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT hres;
    EnterProcR(IStiDevice::RawWriteData,(_ "p", pDev  ));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        if (CStiDevice_IsLocked(this)) {

            __try {
                hres = IStiUSD_RawWriteData(this->pUsd,lpBuffer,dwNumberOfBytes,lpOverlapped);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)  {
                hres = GetExceptionCode();
            }

        }
        else {
            hres = STIERR_NEEDS_LOCK;
        }

    }

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | RawReadCommand |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
CStiDevice_RawReadCommand(
    PSTIDEVICE  pDev,
    LPVOID      lpBuffer,
    LPDWORD     lpdwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT hres;
    EnterProcR(IStiDevice::RawReadCommand,(_ "p", pDev  ));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        if (CStiDevice_IsLocked(this)) {

            __try {
                hres = IStiUSD_RawReadCommand(this->pUsd,lpBuffer,lpdwNumberOfBytes,lpOverlapped);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)  {
                hres = GetExceptionCode();
            }

        }
        else {
            hres = STIERR_NEEDS_LOCK;
        }

    }

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | RawWriteCommand |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
CStiDevice_RawWriteCommand(
    PSTIDEVICE  pDev,
    LPVOID      lpBuffer,
    DWORD       dwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT hres;
    EnterProcR(IStiDevice::RawWriteCommand,(_ "p", pDev  ));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        if (CStiDevice_IsLocked(this)) {

            __try {
                hres = IStiUSD_RawWriteCommand(this->pUsd,lpBuffer,dwNumberOfBytes,lpOverlapped);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)  {
                hres = GetExceptionCode();
            }

        }
        else {
            hres = STIERR_NEEDS_LOCK;
        }

    }

    ExitOleProc();

    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | GetLastError |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiDevice_GetLastError(
    PSTIDEVICE  pDev,
    LPDWORD     pdwLastDeviceError
    )
{
    HRESULT hres = STI_OK;
    EnterProcR(IStiDevice::GetLastError,(_ "p", pDev ));

    // Validate parameters
    if (!pdwLastDeviceError) {
        ExitOleProc();
        return STIERR_INVALID_PARAM;
    }

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        if (this->pDevCtl ) {

            //
            // Call USD to obtain last error information on this device
            //

            __try {
                hres = IStiUSD_GetLastError(this->pUsd,pdwLastDeviceError);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)  {
                hres = GetExceptionCode();
            }

        }
    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiDevice | GetLastError |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiDevice_GetLastErrorInfo(
    PSTIDEVICE  pDev,
    STI_ERROR_INFO *pLastErrorInfo
    )
{
    HRESULT hres = STI_OK;

    EnterProcR(IStiDevice::GetLastErrorInfo,(_ "p", pDev ));

    // Validate parameters
    if (!pLastErrorInfo) {
        ExitOleProc();
        return STIERR_INVALID_PARAM;
    }

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        //
        // Call USD to obtain last error information on this device
        //
        __try {
            hres = IStiUSD_GetLastErrorInfo(this->pUsd,pLastErrorInfo);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)  {
            hres = GetExceptionCode();
        }
    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @mfunc  HRESULT | IStiDevice | Initialize |
 *
 *          Initialize a StiDevice object.
 *
 *          Note that if this method fails, the underlying object should
 *          be considered to be an an indeterminate state and needs to
 *          be reinitialized before it can be subsequently used.
 *          The <i IStillImage::CreateDevice> method automatically
 *          initializes the device after creating it.  Applications
 *          normally do not need to call this function.
 *
 *  @cwrap  LPStiDEVICE | lpStiDevice
 *
 *  @parm   IN REFGUID | rguid |
 *
 *          Identifies the instance of the device for which the interface
 *          should be associated.
 *          The <mf IStillImage::EnumDevices> method
 *          can be used to determine which instance GUIDs are supported by
 *          the system.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The device had already been initialized with
 *          the instance GUID passed in <p lpGUID>.
 *
 *
 *****************************************************************************/

STDMETHODIMP
CStiDevice_Initialize(
    PSTIDEVICE  pDev,
    HINSTANCE   hinst,
    LPCWSTR     pwszDeviceName,
    DWORD       dwVersion,
    DWORD       dwMode
    )
{
    HRESULT hres = STI_OK;

    DWORD   dwControlTypeType;
    DWORD   dwBusType;

    LPWSTR  pwszPortName = NULL;
    DWORD   dwFlags = 0;
    DWORD   dwError = 0;
    HKEY    hkeyDeviceParameters = NULL;

    EnterProcR(IStiDevice::Initialize,(_ "pxpxx", pDev, hinst, pwszDeviceName,dwVersion, dwMode));

    //
    // Validate parameters
    //
    if (!SUCCEEDED(hres = hresFullValidReadPvCb(pwszDeviceName,2,3)) ) {
        goto Cleanup;
    }

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCStiDevice     this = _thisPv(pDev);

        if (SUCCEEDED(hres = hresValidInstanceVer(hinst, dwVersion)) ) {

            //
            // Open device key
            //
            hres = OpenDeviceRegistryKey(pwszDeviceName,NULL,&hkeyDeviceParameters);
            if (!SUCCEEDED(hres)) {

                DebugOutPtszV(DbgFl, TEXT("Cannot open device registry key"));
                StiLogTrace(STI_TRACE_ERROR,MSG_FAILED_OPEN_DEVICE_KEY);

                hres = STIERR_INVALID_PARAM;
                goto Cleanup;
            }

            pwszPortName = NULL;
            ReadRegistryString(hkeyDeviceParameters,
                               REGSTR_VAL_DEVICEPORT_W,
                               L"",FALSE,&pwszPortName);

            dwBusType = ReadRegistryDwordW(hkeyDeviceParameters,
                                          REGSTR_VAL_HARDWARE_W,
                                          0L);

            if (!pwszPortName ) {
                DebugOutPtszV(DbgFl, TEXT("Cannot read device name from registry"));
                StiLogTrace(STI_TRACE_ERROR,MSG_FAILED_READ_DEVICE_NAME);
                hres = STIERR_INVALID_PARAM;
                goto Cleanup;
            }

            //
            // Convert STI bit flags for device mode into HEL_ bit mask
            //
            dwFlags = 0L;

            #if 0
            if (dwMode & STI_DEVICE_CREATE_DATA) dwFlags |= STI_HEL_OPEN_DATA;
            if (dwMode & STI_DEVICE_CREATE_STATUS) dwFlags |= STI_HEL_OPEN_CONTROL;
            #endif

            //
            // Create device control object, establish connection to
            // hardware layer
            //

            if (dwBusType & (STI_HW_CONFIG_USB | STI_HW_CONFIG_SCSI)) {
                dwControlTypeType = HEL_DEVICE_TYPE_WDM;
            }
            else if (dwBusType & STI_HW_CONFIG_PARALLEL) {
                dwControlTypeType = HEL_DEVICE_TYPE_PARALLEL;
            }
            else if (dwBusType & STI_HW_CONFIG_SERIAL) {
                dwControlTypeType = HEL_DEVICE_TYPE_SERIAL;
            }
            else {
                DebugOutPtszV(DbgFl, TEXT("Cannot determine device control type, resort to WDM"));
                dwControlTypeType = HEL_DEVICE_TYPE_WDM;
            }

            hres = NewDeviceControl(dwControlTypeType,dwMode,pwszPortName,dwFlags,&this->pDevCtl);
            if (SUCCEEDED(hres))  {

                //
                // We created device control block, now load and initialize USD
                //
                hres = LoadInitUSD(this,hkeyDeviceParameters);
                if (!SUCCEEDED(hres))  {
                    //
                    // Failed to load USD - free device control object
                    //
                    IStiDeviceControl_Release(this->pDevCtl);
                    this->pDevCtl = NULL;

                    goto Cleanup;
                }
            }
            else {
                DebugOutPtszV(DbgFl, TEXT("Cannot create/allocate Device control object"));
                StiLogTrace(STI_TRACE_ERROR,MSG_FAILED_CREATE_DCB,hres );

                goto Cleanup;
            }

            // Store device name for future use

            this->pszDeviceInternalName = NULL;
            hres = AllocCbPpv(sizeof(WCHAR)*(OSUtil_StrLenW(pwszDeviceName)+1), &this->pszDeviceInternalName);
            if (SUCCEEDED(hres))  {
                OSUtil_lstrcpyW( this->pszDeviceInternalName, pwszDeviceName );
            }

            //
            // Connect to STI monitor if we are running in data mode or in status mode with device supporintg
            // notifications
            //

            if (SUCCEEDED(hres) ) {
                if (!(dwMode & STI_DEVICE_CREATE_FOR_MONITOR)) {
                    if ((dwMode & STI_DEVICE_CREATE_DATA) ||
                        (this->sUsdCaps.dwGenericCaps & STI_USD_GENCAP_NATIVE_PUSHSUPPORT ) ) {

                        DWORD dwProcessID = GetCurrentProcessId();

                        dwError = RpcStiApiOpenDevice(NULL,
                                                      pwszDeviceName,
                                                      dwMode,
                                                      0,
                                                      dwProcessID,
                                                      &(this->hDeviceStiHandle));

                        hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);

                        if (NOERROR != dwError) {

                            DebugOutPtszV(DbgFl, TEXT("Did not connect to monitor.Rpc status=%d"),dwError);

                            ReportStiLogMessage(g_hStiFileLog,
                                                STI_TRACE_ERROR,
                                                TEXT("Requested but failed to connect to STI monitor. "));
                        }
                    }
                } else {

                    //
                    //  Indicate that we are in the server process.  This is
                    //  used when locking/unlocking a device
                    //

                    this->fCreateForMonitor = TRUE;
                }

                //
                // BUGBUG - Problems connecting to RPC server on Millenium . Fix IT !!!
                // To allow STI TWAIN to continue working - ignore error now
                //
                hres = S_OK ;
                // END

           }

        }
    }

Cleanup:

    //
    // Free allocated buffers
    //
    FreePpv(&pwszPortName);

    //
    // If opened key - close it
    //
    if (hkeyDeviceParameters) {
        RegCloseKey(hkeyDeviceParameters);
        hkeyDeviceParameters = NULL;
    }

    // Did we Fail ?
    if (!SUCCEEDED(hres)) {
        DebugOutPtszV(DbgFl, TEXT("Cannot create device object."));
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  void | IStiDevice | Init |
 *
 *          Initialize the internal parts of the StiDevice object.
 *
 *****************************************************************************/

HRESULT INLINE
CStiDevice_Init(
    PCStiDevice this
    )
{
    HRESULT hr = S_OK;

    this->pUsd = NULL;

    __try {
        //  The critical section must be the very first thing we do,
        //  because only Finalize checks for its existence.
        #ifdef UNICODE
        if(!InitializeCriticalSectionAndSpinCount(&this->crst, MINLONG)) {
        #else
        InitializeCriticalSection(&this->crst); if (TRUE) {
        #endif

        hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else {
            this->fLocked = FALSE;

            this->hDeviceStiHandle = INVALID_HANDLE_VALUE;

            this->fCritInited = TRUE;

            this->hUsdInstance = NULL;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

            hr = E_OUTOFMEMORY;
    }

    return hr;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CStiDev_Finalize |
 *
 *          Releases the resources of a generic device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CStiDevice_Finalize(PV pvObj)
{
    HRESULT hres;
    PCStiDevice     this  = pvObj;

    #ifdef MAXDEBUG
    if (this->cCrit) {
        DebugOutPtszV(DbgFl, TEXT("IStiDevice::Release: Another thread is using the object; crash soon!"));
    }
    #endif

    hres = CStiDevice_InternalReset(this);
    AssertF(SUCCEEDED(hres));

    if (this->fCritInited) {
        DeleteCriticalSection(&this->crst);
        this->fCritInited = FALSE;
    }

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | IStiDevice | New |
 *
 *          Create a new StiDevice object, uninitialized.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          Output pointer for new object.
 *
 *****************************************************************************/

STDMETHODIMP
CStiDevice_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IStiDevice::<constructor>, (_ "Gp", riid, punkOuter));

    hres = Common_NewRiid(CStiDevice, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        PCStiDevice this = _thisPv(*ppvObj);
        hres = CStiDevice_Init(this);
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      Miscellaneous utility functions, specific for device processing
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  OpenDeviceRegistryKey
 *
 *          Opens registry key, associated with device instance to use for storing/retrieving
 *          instance information.
 *
 *          Key is obtained from setup api ,based on the STI device name. We should never
 *          open device key by concatenating fixed name with device name, as it works on Memphis.
 *
 *****************************************************************************/

STDMETHODIMP
OpenDeviceRegistryKey(
    LPCWSTR pwszDeviceName,
    LPCWSTR pwszSubKeyName,
    HKEY    *phkeyDeviceParameters
    )
{
    DWORD       dwErr;
    WCHAR       wszDeviceKeyName[MAX_PATH];
    HRESULT     hRes;

#ifdef WINNT

    GUID                    Guid = GUID_DEVCLASS_IMAGE;
    DWORD                   dwRequired;
    DWORD                   Idx;
    SP_DEVINFO_DATA         spDevInfoData;
    HKEY                    hKeyDevice;

    WCHAR                   szDevDriver[STI_MAX_INTERNAL_NAME_LENGTH];
    TCHAR                   sztDevClass[32];

    ULONG                   cbData;
    DWORD                   dwError;

    BOOL                    fRet;
    BOOL                    fFoundDriverNameMatch;
    PWIA_DEVKEYLIST         pWiaDevKeyList;

    dwRequired = 0;
    dwError = 0;


    hKeyDevice              = INVALID_HANDLE_VALUE;
    *phkeyDeviceParameters  = NULL;
    pWiaDevKeyList          = NULL;

    //
    // We need to open device registry key, navigating through Setup API set
    // As we don't have reverse search to retrive device info handle , based on
    // driver name, we do exsaustive search. Number of imaging devices for given class ID
    // is never as large to make a problem.
    //
    //

    hRes = STIERR_INVALID_DEVICE_NAME;
    pWiaDevKeyList = WiaCreateDeviceRegistryList(TRUE);

    fFoundDriverNameMatch = FALSE;

    if (NULL != pWiaDevKeyList) {

        for (Idx = 0; Idx < pWiaDevKeyList->dwNumberOfDevices; Idx++) {

            //
            //  Compare driver name
            //

            cbData = sizeof(szDevDriver);
            *szDevDriver = L'\0';
            dwError = RegQueryValueExW(pWiaDevKeyList->Dev[Idx].hkDeviceRegistry,
                                       REGSTR_VAL_DEVICE_ID_W,
//                                       REGSTR_VAL_FRIENDLY_NAME_W,
                                       NULL,
                                       NULL,
                                       (LPBYTE)szDevDriver,
                                       &cbData);

            if( (ERROR_SUCCESS == dwError)
             && (!lstrcmpiW(szDevDriver,pwszDeviceName)) )
            {

                fFoundDriverNameMatch = TRUE;
                hKeyDevice = pWiaDevKeyList->Dev[Idx].hkDeviceRegistry;

                //
                // Set INVALID_HANDLE_VALUE not to get closed on free.
                //

                pWiaDevKeyList->Dev[Idx].hkDeviceRegistry = INVALID_HANDLE_VALUE;
                break;

            }
        } // for (Idx = 0; Idx < pWiaDevKeyList->dwNumberOfDevices; Idx++)

        if(fFoundDriverNameMatch) {

            //
            // Open the software key and look for subclass.
            //

            if (hKeyDevice != INVALID_HANDLE_VALUE) {

                cbData = sizeof(sztDevClass);
                if ((RegQueryValueEx(hKeyDevice,
                                     REGSTR_VAL_SUBCLASS,
                                     NULL,
                                     NULL,
                                     (LPBYTE)sztDevClass,
                                     &cbData) != ERROR_SUCCESS) ||
                    (lstrcmpi(sztDevClass, STILLIMAGE) != 0)) {

                    fFoundDriverNameMatch = FALSE;

                    hRes = STIERR_INVALID_DEVICE_NAME;

                    RegCloseKey(hKeyDevice);

                }
                else {

                    //
                    // Now open subkey if asked to.
                    //

                    if (pwszSubKeyName && *pwszSubKeyName) {

                        dwErr = OSUtil_RegCreateKeyExW(hKeyDevice,
                                            (LPWSTR)pwszSubKeyName,
                                            0L,
                                            NULL,
                                            0L,
                                            KEY_READ | KEY_WRITE,
                                            NULL,
                                            phkeyDeviceParameters,
                                            NULL
                                            );

                        if ( ERROR_ACCESS_DENIED == dwErr ) {

                            dwErr = OSUtil_RegCreateKeyExW(hKeyDevice,
                                                (LPWSTR)pwszSubKeyName,
                                                0L,
                                                NULL,
                                                0L,
                                                KEY_READ,
                                                NULL,
                                                phkeyDeviceParameters,
                                                NULL
                                                );
                        }

                        RegCloseKey(hKeyDevice);

                    }
                    else {

                        //
                        // No subkey given - device key will be returned - don't close it.
                        //
                        *phkeyDeviceParameters = hKeyDevice;

                        dwErr = NOERROR;

                    }  // endif Subkey name passed

                    hRes = HRESULT_FROM_WIN32(dwErr);                                                                                    ;

                } // Is StillImage subclass

            } // endif Opened device registry key

        } // endif Found matching driver name

    } // if (NULL != pWiaDevKeyList)


    //
    // Free device registry list.
    //

    if(NULL != pWiaDevKeyList){
        WiaDestroyDeviceRegistryList(pWiaDevKeyList);
    }

    return hRes;

#else


    //
    // Based on device name and optional subkey name, open requested key
    //
    wcscat(wcscpy(wszDeviceKeyName,
                  (g_NoUnicodePlatform) ? REGSTR_PATH_STIDEVICES_W : REGSTR_PATH_STIDEVICES_NT_W),
           L"\\");

    wcscat(wszDeviceKeyName,pwszDeviceName);

    //
    // Validate this is correct device name ?
    //
    dwErr = OSUtil_RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        wszDeviceKeyName,
                        0L,
                        KEY_READ ,
                        phkeyDeviceParameters
                        );

    if (NOERROR != dwErr ) {

        if ( (dwErr == ERROR_INVALID_NAME) || (dwErr == ERROR_FILE_NOT_FOUND)) {
            return STIERR_INVALID_DEVICE_NAME;
        }

        return HRESULT_FROM_WIN32(dwErr);
    }
    else {
        RegCloseKey(*phkeyDeviceParameters);
        *phkeyDeviceParameters = NULL;
    }

    //
    // Now open subkey
    //

    if (pwszSubKeyName && *pwszSubKeyName) {
        wcscat(wszDeviceKeyName,L"\\");
        wcscat(wszDeviceKeyName,pwszSubKeyName);
    }

    dwErr = OSUtil_RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                        wszDeviceKeyName,
                        0L,
                        NULL,
                        0L,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        phkeyDeviceParameters,
                        NULL
                        );

    if ( ERROR_ACCESS_DENIED == dwErr ) {
        dwErr = OSUtil_RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                            wszDeviceKeyName,
                            0L,
                            NULL,
                            0L,
                            KEY_READ ,
                            NULL,
                            phkeyDeviceParameters,
                            NULL
                            );
    }

    return HRESULT_FROM_WIN32(dwErr);

    #endif

}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CStiDevice_Signature        (DWORD)'DEV'

Primary_Interface_Begin(CStiDevice, IStiDevice)
    CStiDevice_Initialize,
    CStiDevice_GetCapabilities,
    CStiDevice_GetStatus,
    CStiDevice_DeviceReset,
    CStiDevice_Diagnostic,
    CStiDevice_Escape,
    CStiDevice_GetLastError,
    CStiDevice_LockDevice,
    CStiDevice_UnLockDevice,
    CStiDevice_RawReadData,
    CStiDevice_RawWriteData,
    CStiDevice_RawReadCommand,
    CStiDevice_RawWriteCommand,
    CStiDevice_Subscribe,
    CStiDevice_GetNotificationData,
    CStiDevice_UnSubscribe,
    CStiDevice_GetLastErrorInfo,
Primary_Interface_End(CStiDevice, IStiDevice)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\globals.c ===
/*****************************************************************************
 *
 *  globals.c
 *
 *  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Global variables that are needed by modules in the STIRT library.
 *
 *****************************************************************************/
 
/* 
#include "wia.h"
#include "wiapriv.h"
*/
#include "sticomm.h"

#ifdef __cplusplus
extern "C" {
#endif

// Reference counter for the whole library
DWORD       g_cRef;

// DLL module instance
HINSTANCE   g_hInst;

// Critical section for low level syncronization
CRITICAL_SECTION g_crstDll;

// Can we use UNICODE APIs
#if defined(WINNT) || defined(UNICODE)
BOOL    g_NoUnicodePlatform = FALSE;
#else
BOOL    g_NoUnicodePlatform = TRUE;
#endif

// Is COM initialized
BOOL    g_COMInitialized = FALSE;

// Save process command line
CHAR    szProcessCommandLine[MAX_PATH] = {'\0'};

// Handle of file log
HANDLE  g_hStiFileLog = INVALID_HANDLE_VALUE;

// Pointer to lock manager
IStiLockMgr *g_pLockMgr = NULL;

#ifdef DEBUG

int         g_cCrit = -1;
UINT        g_thidCrit;

#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\enum.cpp ===
/*++
   Copyright    (c)    1997        Microsoft Corporation

   Module Name:

        enum.cpp

   Abstract:

        Enumerates WIA device registry.

   Author:

        Keisuke Tsuchida    (KeisukeT)    01-Jun-2000

   History:


--*/


//
//  Include Headers
//

#define INIT_GUID

#include "cplusinc.h"
#include "sticomm.h"
#include <setupapi.h>
#include <cfg.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <initguid.h>
#include <ntddpar.h>
#include "enum.h"

VOID
DebugOutputDeviceName(
    HDEVINFO                    hDevInfo,
    PSP_DEVINFO_DATA            pspDevInfoData,
    LPCTSTR                     szKeyName
    );

VOID
DebugOutputInterfaceName(
    HDEVINFO                    hDevInfo,
    PSP_DEVICE_INTERFACE_DATA   pspDevInterfaceData,
    LPCTSTR                     szKeyName
    );

BOOL
IsStiRegKey(
    HKEY    hkDevRegKey
    );

//
// Define
//

// from sti_ci.h
#define WIA_DEVKEYLIST_INITIAL_SIZE     1024
#define STILL_IMAGE                     TEXT("StillImage")
#define SUBCLASS                        TEXT("SubClass")


//
// Functions
//

extern "C"{

PWIA_DEVKEYLIST
WiaCreateDeviceRegistryList(
    BOOL    bEnumActiveOnly
    )
{
    PWIA_DEVKEYLIST                     pReturn;
    PWIA_DEVKEYLIST                     pTempBuffer;
    HKEY                                hkDevRegKey;
    DWORD                               dwError;
    DWORD                               dwCurrentSize;
    DWORD                               dwRequiredSize;
    DWORD                               dwNumberOfDevices;
    DWORD                               dwFlags;
    DWORD                               dwValueSize;
    DWORD                               dwDetailDataSize;
    BOOL                                bIsPlugged;
    HANDLE                              hDevInfo;
    CONFIGRET                           ConfigRet;
    ULONG                               ulStatus;
    ULONG                               ulProblemNumber;
    DWORD                               Idx;
    GUID                                Guid;
    SP_DEVINFO_DATA                     spDevInfoData;
    SP_DEVICE_INTERFACE_DATA            spDevInterfaceData;

    PSP_DEVICE_INTERFACE_DETAIL_DATA    pspDevInterfaceDetailData;

//      DPRINTF(DM_ERROR,TEXT("WiaCreateDeviceRegistryList: Enter... bEnumActiveOnly=%d"), bEnumActiveOnly);

    //
    // Initialize local.
    //

    pReturn                     = NULL;
    pTempBuffer                 = NULL;
    hkDevRegKey                 = (HKEY)INVALID_HANDLE_VALUE;
    dwError                     = ERROR_SUCCESS;
    dwCurrentSize               = WIA_DEVKEYLIST_INITIAL_SIZE;
    dwRequiredSize              = sizeof(DWORD);
    dwNumberOfDevices           = 0;
    dwFlags                     = (bEnumActiveOnly ? DIGCF_PRESENT : 0) | DIGCF_PROFILE;
    hDevInfo                    = INVALID_HANDLE_VALUE;
    Idx                         = 0;
    Guid                        = GUID_DEVCLASS_IMAGE;
    ConfigRet                   = CR_SUCCESS;
    ulStatus                    = 0;
    ulProblemNumber             = 0;
    bIsPlugged                  = FALSE;

    pspDevInterfaceDetailData   = NULL;

    memset(&spDevInfoData, 0, sizeof(spDevInfoData));
    memset(&spDevInterfaceData, 0, sizeof(spDevInterfaceData));

    //
    // Allocate buffer.
    //

    pTempBuffer = (PWIA_DEVKEYLIST)new BYTE[dwCurrentSize];
    if(NULL == pTempBuffer){
      DPRINTF(DM_ERROR,TEXT("WiaCreateDeviceRegistryList: ERROR!! Insufficient system resources. Err=0x%x\n"), GetLastError());

        pReturn = NULL;
        goto WiaCreateDeviceRegistryList_return;
    } // if(NULL == pTempBuffer)

    memset(pTempBuffer, 0, dwCurrentSize);

    //
    // Enumerate "devnode" devices.
    //

    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, dwFlags);
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        DPRINTF(DM_ERROR,TEXT("WiaCreateDeviceRegistryList: ERROR!! SetupDiGetClassDevs (devnodes) fails. Err=0x%x\n"), GetLastError());

        pReturn = NULL;
        goto WiaCreateDeviceRegistryList_return;
    }

    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

//        DebugOutputDeviceName(hDevInfo, &spDevInfoData, TEXT("DriverDesc"));

        //
        // Get device regkey.
        //

        hkDevRegKey = SetupDiOpenDevRegKey(hDevInfo,
                                           &spDevInfoData,
                                           DICS_FLAG_GLOBAL,
                                           0,
                                           DIREG_DRV,
                                           KEY_READ | KEY_WRITE);

        if(INVALID_HANDLE_VALUE == hkDevRegKey){

            //
            // Attempt to open the key as READ ONLY instead...
            //

            hkDevRegKey = SetupDiOpenDevRegKey(hDevInfo,
                                               &spDevInfoData,
                                               DICS_FLAG_GLOBAL,
                                               0,
                                               DIREG_DRV,
                                               KEY_READ);
            if(INVALID_HANDLE_VALUE == hkDevRegKey){
                DPRINTF(DM_ERROR,TEXT("WiaCreateDeviceRegistryList: ERROR!! SetupDiOpenDevRegKey (devnodes) fails. Err=0x%x\n"), GetLastError());
                continue;
            } // if(INVALID_HANDLE_VALUE == hkDevRegKey)
        } // if(INVALID_HANDLE_VALUE == hkDevRegKey)

        //
        // See if it has "StillImage" in SubClass key.
        //

        if(!IsStiRegKey(hkDevRegKey)){
            RegCloseKey(hkDevRegKey);
            hkDevRegKey = (HKEY)INVALID_HANDLE_VALUE;
            continue;
        } // if(!IsStiRegKey(hkDevRegKey))

        //
        // See if this node is active.
        //

        bIsPlugged = TRUE;
        ulStatus = 0;
        ulProblemNumber = 0;
        ConfigRet = CM_Get_DevNode_Status(&ulStatus,
                                          &ulProblemNumber,
                                          spDevInfoData.DevInst,
                                          0);
        if(CR_SUCCESS != ConfigRet){
//            DPRINTF(DM_ERROR,TEXT("WiaCreateDeviceRegistryList: Unable to get devnode status. CR=0x%x.\n"), ConfigRet);
            if(bEnumActiveOnly){
                RegCloseKey(hkDevRegKey);
                hkDevRegKey = (HKEY)INVALID_HANDLE_VALUE;
                continue;
            } else {
                bIsPlugged = FALSE;
            }
        } // if(CR_SUCCESS != ConfigRet)

//          DPRINTF(DM_ERROR,TEXT("WiaCreateDeviceRegistryList: Devnode status=0x%x, Problem=0x%x.\n"), ulStatus, ulProblemNumber);

        //
        // Skip a node with problem if enumerating only active devices.
        //

        if(bEnumActiveOnly){
            if(!(ulStatus & DN_STARTED)){
                RegCloseKey(hkDevRegKey);
                hkDevRegKey = (HKEY)INVALID_HANDLE_VALUE;
                continue;
            } // if(!(ulStatus & DN_STARTED))
        } // if(bEnumActiveOnly)

        //
        // Add acquired regkey handle. If running out of buffer, enlarge.
        //

        dwRequiredSize += sizeof(WIA_DEVPROP);

        if(dwCurrentSize < dwRequiredSize){
            PWIA_DEVKEYLIST pTempNew;
            DWORD           dwNewSize;

            dwNewSize = dwCurrentSize + WIA_DEVKEYLIST_INITIAL_SIZE;

            pTempNew    = (PWIA_DEVKEYLIST)new BYTE[dwNewSize];

            if(NULL == pTempNew){
                pReturn = NULL;
                goto WiaCreateDeviceRegistryList_return;
            } // if(NULL == pTempNew)

            memset(pTempNew, 0, dwNewSize);
            memcpy(pTempNew, pTempBuffer, dwCurrentSize);
            delete pTempBuffer;
            pTempBuffer = pTempNew;
            dwCurrentSize = dwNewSize;
        } // if(dwCurrentSize < dwRequiredSize)

        //
        // Fill in the structure.
        //

        pTempBuffer->Dev[dwNumberOfDevices].bIsPlugged          = bIsPlugged;
        pTempBuffer->Dev[dwNumberOfDevices].ulProblem           = ulProblemNumber;
        pTempBuffer->Dev[dwNumberOfDevices].ulStatus            = ulStatus;
        pTempBuffer->Dev[dwNumberOfDevices].hkDeviceRegistry    = hkDevRegKey;
        dwNumberOfDevices++;

    } // for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)

    //
    // Free device info set.
    //

    SetupDiDestroyDeviceInfoList(hDevInfo);
    hDevInfo = INVALID_HANDLE_VALUE;

    //
    // Enumerate "interface" devices.
    //

    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_PROFILE | DIGCF_DEVICEINTERFACE);
    if (hDevInfo == INVALID_HANDLE_VALUE) {

        pReturn = NULL;
        goto WiaCreateDeviceRegistryList_return;
    }

    spDevInterfaceData.cbSize = sizeof (spDevInterfaceData);
    for (Idx = 0; SetupDiEnumDeviceInterfaces (hDevInfo, NULL, &Guid, Idx, &spDevInterfaceData); Idx++) {

//        DebugOutputInterfaceName(hDevInfo, &spDevInterfaceData, TEXT("FriendlyName"));

        hkDevRegKey = SetupDiOpenDeviceInterfaceRegKey(hDevInfo,
                                                       &spDevInterfaceData,
                                                       0,
                                                       KEY_READ | KEY_WRITE);
        if(INVALID_HANDLE_VALUE == hkDevRegKey){

            //
            // Attempt to open the key as READ ONLY instead...
            //

            hkDevRegKey = SetupDiOpenDeviceInterfaceRegKey(hDevInfo,
                                                           &spDevInterfaceData,
                                                           0,
                                                           KEY_READ);
            if(INVALID_HANDLE_VALUE == hkDevRegKey){
                continue;
            } // if(INVALID_HANDLE_VALUE == hkDevRegKey)
        } // if(INVALID_HANDLE_VALUE == hkDevRegKey)

        //
        // See if it has "StillImage" in SubClass key.
        //

        if(!IsStiRegKey(hkDevRegKey)){
            RegCloseKey(hkDevRegKey);
            hkDevRegKey = (HKEY)INVALID_HANDLE_VALUE;
            continue;
        } // if(!IsStiRegKey(hkDevRegKey))


        bIsPlugged = TRUE;
        ulStatus = 0;
        ulProblemNumber = 0;

        //
        // Get devnode which this interface is created on.
        //

        SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                        &spDevInterfaceData,
                                        NULL,
                                        0,
                                        &dwDetailDataSize,
                                        NULL);
        if(0 == dwDetailDataSize){
            DPRINTF(DM_ERROR, TEXT("IsInterfaceActive: SetupDiGetDeviceInterfaceDetail() failed. Err=0x%x. ReqSize=0x%x"), GetLastError(), dwDetailDataSize);
            if(bEnumActiveOnly){
                RegCloseKey(hkDevRegKey);
                hkDevRegKey = (HKEY)INVALID_HANDLE_VALUE;
                continue;
            } else {
                bIsPlugged = FALSE;
            }
        } // if(0 == dwDetailDataSize)

        //
        // Allocate memory for data.
        //

        pspDevInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)new char[dwDetailDataSize];
        if(NULL == pspDevInterfaceDetailData){
            DPRINTF(DM_ERROR, TEXT("IsInterfaceActive: Insufficient buffer."));
            RegCloseKey(hkDevRegKey);
            hkDevRegKey = (HKEY)INVALID_HANDLE_VALUE;
            continue;
        } // if(NULL == pspDevInterfaceDetailData)

        //
        // Get the actual data.
        //

        spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        pspDevInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
        if(!SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                            &spDevInterfaceData,
                                            pspDevInterfaceDetailData,
                                            dwDetailDataSize,
                                            &dwDetailDataSize,
                                            &spDevInfoData)){
            DPRINTF(DM_ERROR, TEXT("IsInterfaceActive: SetupDiGetDeviceInterfaceDetail() failed. Err=0x%x. ReqSize=0x%x"), GetLastError(), dwRequiredSize);

            delete pspDevInterfaceDetailData;
            pspDevInterfaceDetailData = NULL;

            if(bEnumActiveOnly){
                RegCloseKey(hkDevRegKey);
                hkDevRegKey = (HKEY)INVALID_HANDLE_VALUE;
                continue;
            } else {
                bIsPlugged = FALSE;
            }
        }// if(!SetupDiGetDeviceInterfaceDetail()

        if(NULL != pspDevInterfaceDetailData){
            delete pspDevInterfaceDetailData;
            pspDevInterfaceDetailData = NULL;
        } // if(NULL != pspDevInterfaceDetailData)

        //
        // See its devnode is active.
        //

        ConfigRet = CM_Get_DevNode_Status(&ulStatus,
                                          &ulProblemNumber,
                                          spDevInfoData.DevInst,
                                          0);
        if(CR_SUCCESS != ConfigRet){
            DPRINTF(DM_ERROR,TEXT("WiaCreateDeviceRegistryList: Unable to get devnode status. CR=0x%x.\n"), ConfigRet);
            if(bEnumActiveOnly){
                RegCloseKey(hkDevRegKey);
                hkDevRegKey = (HKEY)INVALID_HANDLE_VALUE;
                continue;
            } else {
                bIsPlugged = FALSE;
            }
        } // if(CR_SUCCESS != ConfigRet)

        if(bEnumActiveOnly){
            if(!(ulStatus & DN_STARTED)){
                RegCloseKey(hkDevRegKey);
                hkDevRegKey = (HKEY)INVALID_HANDLE_VALUE;
                continue;
            } // if(!(ulStatus & DN_STARTED))
        } // if(bEnumActiveOnly)

        //
        // Add acquired regkey handle. If running out of buffer, enlarge.
        //

        dwRequiredSize += sizeof(WIA_DEVPROP);

        if(dwCurrentSize < dwRequiredSize){
            PWIA_DEVKEYLIST pTempNew;
            DWORD           dwNewSize;

            dwNewSize = dwCurrentSize + WIA_DEVKEYLIST_INITIAL_SIZE;

            pTempNew    = (PWIA_DEVKEYLIST)new BYTE[dwNewSize];
            if(NULL == pTempNew){
                pReturn = NULL;
                goto WiaCreateDeviceRegistryList_return;
            } // if(NULL == pTempNew)

            memset(pTempNew, 0, dwNewSize);
            memcpy(pTempNew, pTempBuffer, dwCurrentSize);
            delete pTempBuffer;
            pTempBuffer = pTempNew;
            dwCurrentSize = dwNewSize;
        } // if(dwCurrentSize < dwRequiredSize)

        //
        // Fill in the structure.
        //

        pTempBuffer->Dev[dwNumberOfDevices].bIsPlugged          = bIsPlugged;
        pTempBuffer->Dev[dwNumberOfDevices].ulProblem           = ulProblemNumber;
        pTempBuffer->Dev[dwNumberOfDevices].ulStatus            = ulStatus;
        pTempBuffer->Dev[dwNumberOfDevices].hkDeviceRegistry    = hkDevRegKey;
        dwNumberOfDevices++;

    } // for (Idx = 0; SetupDiEnumDeviceInterfaces (hDevInfo, NULL, &Guid, Idx, &spDevInterfaceData); Idx++)

    //
    // Operation succeeded.
    //

    if(0 != dwNumberOfDevices){
        pTempBuffer->dwNumberOfDevices = dwNumberOfDevices;
        pReturn = pTempBuffer;
        pTempBuffer = NULL;
    } // if(0 != dwNumberOfDevices)

WiaCreateDeviceRegistryList_return:

    //
    // Clean up.
    //

    if(INVALID_HANDLE_VALUE != hDevInfo){
        SetupDiDestroyDeviceInfoList(hDevInfo);
    } // if(INVALID_HANDLE_VALUE != hDevInfo)

    if(NULL != pTempBuffer){
        pTempBuffer->dwNumberOfDevices = dwNumberOfDevices;
        WiaDestroyDeviceRegistryList(pTempBuffer);
    } // if(NULL != pTempBuffer)

//      DPRINTF(DM_ERROR, TEXT("WiaCreateDeviceRegistryList: Leave... %d devices. Ret=0x%p."), dwNumberOfDevices, pReturn);

    return pReturn;
} // WiaCreateDeviceRegistryList()


VOID
WiaDestroyDeviceRegistryList(
    PWIA_DEVKEYLIST pWiaDevKeyList
    )
{
    DWORD   Idx;

    //
    // Check argument.
    //

    if(NULL == pWiaDevKeyList){
        goto WiaFreeDeviceRegistryList_return;
    }

    for(Idx = 0; Idx < pWiaDevKeyList->dwNumberOfDevices; Idx++){
        if(INVALID_HANDLE_VALUE != pWiaDevKeyList->Dev[Idx].hkDeviceRegistry){
            RegCloseKey(pWiaDevKeyList->Dev[Idx].hkDeviceRegistry);
        } // if(INVALID_HANDLE_VALUE != pWiaDevKeyList->Dev[Idx].hkDeviceRegistry)
    } // for(Idx = 0; Idx < pWiaDevKeyList->dwNumberOfDevices; Idx++)

    delete pWiaDevKeyList;

WiaFreeDeviceRegistryList_return:
    return;
}

VOID
EnumLpt(
    VOID
    )
{

    CONFIGRET       ConfigRet;
    HDEVINFO        hLptDevInfo;
    SP_DEVINFO_DATA spDevInfoData;
    DWORD           Idx;
    GUID            Guid;
    DWORD           dwCurrentTickCount;
    static DWORD    s_dwLastTickCount = 0;

    //
    // Initialize local.
    //

    ConfigRet           = CR_SUCCESS;
    hLptDevInfo         = (HDEVINFO) INVALID_HANDLE_VALUE;
    Idx                 = 0;
    Guid                = GUID_PARALLEL_DEVICE;
    dwCurrentTickCount  = 0;

    memset(&spDevInfoData, 0, sizeof(spDevInfoData));

    //
    // Get current system tick.
    //

    dwCurrentTickCount = GetTickCount();

    //
    // Bail out if the function is called within ENUMLPT_HOLDTIME millisec.
    //

    if( (dwCurrentTickCount - s_dwLastTickCount) < ENUMLPT_HOLDTIME){
        goto EnumLpt_return;
    }

    //
    // Save current tick
    //

    s_dwLastTickCount = dwCurrentTickCount;

    //
    // Enum LPT port as needed.
    //

    if(IsPnpLptExisting()){

        //
        // Get LPT devnodes.
        //

        Guid    = GUID_PARALLEL_DEVICE;
        hLptDevInfo = SetupDiGetClassDevs(&Guid, NULL, NULL, DIGCF_INTERFACEDEVICE);
        if(INVALID_HANDLE_VALUE == hLptDevInfo){

            goto EnumLpt_return;
        }

        //
        // Re-enumerate LPT port.
        //

        spDevInfoData.cbSize = sizeof(spDevInfoData);
        for(Idx = 0; SetupDiEnumDeviceInfo(hLptDevInfo, Idx, &spDevInfoData); Idx++){
            ConfigRet = CM_Reenumerate_DevNode(spDevInfoData.DevInst, CM_REENUMERATE_NORMAL);
            if(CR_SUCCESS != ConfigRet){
                DPRINTF(DM_ERROR,TEXT("EnumLpt: ERROR!! CM_Reenumerate_DevNode() fails. Idx=0x%x, ConfigRet=0x%x\n"), Idx, ConfigRet);
            } // if(CR_SUCCESS != ConfigRet)
        } // for(Idx = 0; SetupDiEnumDeviceInfo(hLptDevInfo, Idx, &spDevInfoData); Idx++)
    } // if(IsPnpLptExisting())

EnumLpt_return:

    //
    // Clean up.
    //

    if(INVALID_HANDLE_VALUE != hLptDevInfo){
        SetupDiDestroyDeviceInfoList(hLptDevInfo);
    } // if(INVALID_HANDLE_HALUE != hLptDevInfo)

    return;
} // EnumLpt()

BOOL
IsPnpLptExisting(
    VOID
    )
{

    HDEVINFO                            hDevInfo;
    CONFIGRET                           ConfigRet;
    DWORD                               Idx;
    GUID                                Guid;
    SP_DEVINFO_DATA                     spDevInfoData;
    HKEY                                hkDevRegKey;
    DWORD                               dwHardwareConfig;
    LONG                                lResult;
    ULONG                               ulStatus;
    ULONG                               ulProblemNumber;
    BOOL                                bRet;

    //
    // Initialize local.
    //

    hDevInfo        = INVALID_HANDLE_VALUE;
    ConfigRet       = CR_SUCCESS;
    Idx             = 0;
    Guid            = GUID_DEVCLASS_IMAGE;
    hkDevRegKey     = (HKEY)INVALID_HANDLE_VALUE;
    ulStatus        = 0;
    ulProblemNumber = 0;
    bRet            = FALSE;

    memset(&spDevInfoData, 0, sizeof(spDevInfoData));

    //
    // Enum Imaging class devnode.
    //

    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_PROFILE);
    if(hDevInfo == INVALID_HANDLE_VALUE){

        goto IsPnpLptExisting_return;
    } // if(hDevInfo == INVALID_HANDLE_VALUE)}

    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

        hkDevRegKey = SetupDiOpenDevRegKey(hDevInfo,
                                           &spDevInfoData,
                                           DICS_FLAG_GLOBAL,
                                           0,
                                           DIREG_DRV,
                                           KEY_READ);

        if(INVALID_HANDLE_VALUE == hkDevRegKey){
            DPRINTF(DM_ERROR,TEXT("WiaCreateDeviceRegistryList: ERROR!! SetupDiOpenDevRegKey (devnodes) fails. Err=0x%x\n"), GetLastError());
            continue;
        } // if(INVALID_HANDLE_VALUE == hkDevRegKey)

        //
        // Make sure it's STI/WIA device.
        //

        if(!IsStiRegKey(hkDevRegKey)){
            RegCloseKey(hkDevRegKey);
            hkDevRegKey = (HKEY)INVALID_HANDLE_VALUE;
            continue;
        } // if(!IsStiRegKey(hkDevRegKey))

        //
        // Get "Hardware config" key.
        //

        dwHardwareConfig = ReadRegistryDwordW(hkDevRegKey, REGSTR_VAL_HARDWARE_W, 0);

        RegCloseKey(hkDevRegKey);
        hkDevRegKey = (HKEY)INVALID_HANDLE_VALUE;

        if(!(dwHardwareConfig & STI_HW_CONFIG_PARALLEL)){

            //
            // This is not a parallel device.
            //

            continue;
        } // if(!IsStiRegKey(hkDevRegKey))

        //
        // See if device is detected by system.
        //

        ulStatus        = 0;
        ulProblemNumber = 0;
        ConfigRet = CM_Get_DevNode_Status(&ulStatus,
                                          &ulProblemNumber,
                                          spDevInfoData.DevInst,
                                          0);
        if(CR_SUCCESS != ConfigRet){

            //
            // There is a Pnp LPT device installed but not been detected on boot. Let enum LPT.
            //

            bRet = TRUE;
            break;
        } // if(CR_SUCCESS != ConfigRet)

    } // for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)

IsPnpLptExisting_return:

    //
    // Clean up.
    //

    if(INVALID_HANDLE_VALUE != hDevInfo){
        SetupDiDestroyDeviceInfoList(hDevInfo);
    } // if(INVALID_HANDLE_VALUE != hDevInfo)

    return bRet;

} // IsPnpLptExisting()


} // extern "C"


VOID
DebugOutputDeviceName(
    HDEVINFO                    hDevInfo,
    PSP_DEVINFO_DATA            pspDevInfoData,
    LPCTSTR                     szKeyName
    )
{
    HKEY        hkDev = NULL;
    TCHAR       szBuffer[1024];
    DWORD       dwSize;
    LONG        lResult;
    DWORD       dwType;

    hkDev = SetupDiOpenDevRegKey(hDevInfo,
                                 pspDevInfoData,
                                 DICS_FLAG_GLOBAL,
                                 0,
                                 DIREG_DRV,
                                 KEY_READ);

    if(INVALID_HANDLE_VALUE == hkDev){
        DPRINTF(DM_ERROR, TEXT("DebugOutputDeviceName: SetupDiOpenDevRegKey() failed. Err=0x%x"), GetLastError());
        goto DebugOutputDeviceName_return;
    } // if(INVALID_HANDLE_VALUE == hkDev)

    dwSize = sizeof(szBuffer);
    lResult = RegQueryValueEx(hkDev,
                              szKeyName,
                              NULL,
                              &dwType,
                              (LPBYTE)szBuffer,
                              &dwSize);
    if(ERROR_SUCCESS != lResult){
        DPRINTF(DM_ERROR, TEXT("DebugOutputDeviceName: RegQueryValueEx() failed. Err=0x%x"), lResult);
        goto DebugOutputDeviceName_return;
    }

    switch(dwType){
        case REG_DWORD:
            DPRINTF(DM_ERROR, TEXT("DebugOutputDeviceName: Value: %s, Data: 0x%x"), szKeyName, szBuffer);
            break;

        case REG_SZ:
            DPRINTF(DM_ERROR, TEXT("DebugOutputDeviceName: Value: %s, Data: %s"), szKeyName, szBuffer);
    }

DebugOutputDeviceName_return:

    // Close opened key
    if(hkDev && (INVALID_HANDLE_VALUE != hkDev) ){
        RegCloseKey(hkDev);
        hkDev = (HKEY)INVALID_HANDLE_VALUE;
    }

    return;
} // DebugOutputDeviceRegistry(

VOID
DebugOutputInterfaceName(
    HDEVINFO                    hDevInfo,
    PSP_DEVICE_INTERFACE_DATA   pspDevInterfaceData,
    LPCTSTR                     szKeyName
    )
{
    HKEY        hkDev = NULL;
    TCHAR       szBuffer[1024];
    DWORD       dwSize;
    LONG        lResult;
    DWORD       dwType;

    hkDev = SetupDiOpenDeviceInterfaceRegKey(hDevInfo,
                                             pspDevInterfaceData,
                                             0,
                                             KEY_READ);

    if(INVALID_HANDLE_VALUE == hkDev){
//        DPRINTF(DM_ERROR, TEXT("DebugOutputInterfaceName: SetupDiOpenDeviceInterfaceRegKey() failed. Err=0x%x"), GetLastError());
        goto DebugOutputInterfaceName_return;
    } // if(INVALID_HANDLE_VALUE == hkDev)

    dwSize = sizeof(szBuffer);
    lResult = RegQueryValueEx(hkDev,
                              szKeyName,
                              NULL,
                              &dwType,
                              (LPBYTE)szBuffer,
                              &dwSize);
    if(ERROR_SUCCESS != lResult){
//        DPRINTF(DM_ERROR, TEXT("DebugOutputInterfaceName: RegQueryValueEx() failed. Err=0x%x"), lResult);
        goto DebugOutputInterfaceName_return;
    }

    switch(dwType){
        case REG_DWORD:
            DPRINTF(DM_ERROR, TEXT("DebugOutputInterfaceName: Value: %s, Data: 0x%x"), szKeyName, szBuffer);
            break;

        case REG_SZ:
            DPRINTF(DM_ERROR, TEXT("DebugOutputInterfaceName: Value: %s, Data: %s"), szKeyName, szBuffer);
    }

DebugOutputInterfaceName_return:
    // Close opened key
    if(hkDev && (INVALID_HANDLE_VALUE != hkDev) ){
        RegCloseKey(hkDev);
        hkDev = (HKEY)INVALID_HANDLE_VALUE;
    }

    return;
} // DebugOutputInterfaceName()

BOOL
IsStiRegKey(
    HKEY    hkDevRegKey
    )
{
    DWORD   dwValueSize;
    TCHAR   szSubClass[MAX_PATH];
    BOOL    bRet;

    bRet        = TRUE;
    dwValueSize = sizeof(szSubClass);

    memset(&szSubClass, 0, sizeof(szSubClass));

    RegQueryValueEx(hkDevRegKey,
                    SUBCLASS,
                    NULL,
                    NULL,
                    (LPBYTE)szSubClass,
                    &dwValueSize);

    if( (0 == lstrlen(szSubClass))
     || (lstrcmpi(szSubClass, STILL_IMAGE)) )
    {
        bRet = FALSE;
    }

    return bRet;
} // IsStiRegKey()


/********************************* End of File ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\helwdm.c ===
/*****************************************************************************
 *
 *  Hel.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Hardware emulation layer calls. Used to provide common functionality
 *      for built-in device types we support ( WDM, serial and parallel)
 *      While access to DCB could be built as internal COM object , it does not make
 *      much sense to invest in it, because DCBs are exclusively owned and not shared
 *      between application objects or different applications. We also want to minimize
 *      any overhead when talking to raw device interface.
 *
 *      Note1: We don't deal at this level with access control, lower level drivers are supposed
 *      to take care of this. Queuing of requests for non-reentrant devices is also not done here.
 *      This Hel is basically thin layer of imaging device primitives, used only to isolate
 *      command translator from actual hardware.
 *
 *      Note2: Hel is not made extensible . If command translator needs to talk to non-supported
 *      device, it will need to establish direct link to it. There is no requirement to use
 *      Hel , it is service we provide to conformant devices.
 *
 *  Contents:
 *
 *****************************************************************************/

/*
#include "wia.h"
#include <stilog.h>
#include <stiregi.h>

#include <sti.h>
#include <stierr.h>
#include <stiusd.h>
#include "stipriv.h"
#include "debug.h"

#define DbgFl DbgFlDevice
*/
#include "sticomm.h"
#include "validate.h"

#define DbgFl DbgFlDevice


/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CWDMDeviceControl, IStiDeviceControl);

Interface_Template_Begin(CWDMDeviceControl)
    Primary_Interface_Template(CWDMDeviceControl, IStiDeviceControl)
Interface_Template_End(CWDMDeviceControl)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CWDMDeviceControl |
 *
 *          The <i CWDMDeviceControl> device object
 *
 *
 *  @field  IStiDeviceControl | stidev
 *
 *  @comm
 *
 *
 *****************************************************************************/

typedef struct CWDMDeviceControl {

    /* Supported interfaces */
    IStiDeviceControl  devctl;

    DWORD       dwVersion;

    DWORD       dwDeviceType;
    DWORD       dwMode;
    WCHAR       wszPortName[MAX_PATH];
    DWORD       dwFlags;
    DWORD       dwContext;
    DWORD       dwLastOperationError;
    HANDLE      hDeviceHandle;
    HANDLE      hDeviceControlHandle;

} CWDMDeviceControl, *PCWDMDeviceControl;

#define ThisClass       CWDMDeviceControl
#define ThisInterface   IStiDeviceControl

#ifdef DEBUG

Default_QueryInterface(CWDMDeviceControl)
Default_AddRef(CWDMDeviceControl)
Default_Release(CWDMDeviceControl)

#else

#define CWDMDeviceControl_QueryInterface   Common_QueryInterface
#define CWDMDeviceControl_AddRef           Common_AddRef
#define CWDMDeviceControl_Release          Common_Release

#endif

#define CWDMDeviceControl_QIHelper         Common_QIHelper

#pragma BEGIN_CONST_DATA

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CWDMDeviceControl | RawReadData |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CWDMDeviceControl_RawReadData(
    PSTIDEVICECONTROL   pDev,
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;
    BOOL    fRet;

    EnterProc(CWDMDeviceControl_WDMRawReadData, (_ "pppp",pDev,lpBuffer,lpdwNumberOfBytes,lpOverlapped));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCWDMDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        if (SUCCEEDED(hres = hresFullValidReadPvCb(lpdwNumberOfBytes, 4, 3)) &&
            SUCCEEDED(hres = hresFullValidReadPvCb(lpBuffer,*lpdwNumberOfBytes, 2)) &&
            (!lpOverlapped || SUCCEEDED(hres = hresFullValidReadPx(lpOverlapped, OVERLAPPED, 4))) ){

            // Call appropriate entry point
            fRet = ReadFile(this->hDeviceHandle,
                             lpBuffer,
                             *lpdwNumberOfBytes,
                             lpdwNumberOfBytes,
                             lpOverlapped
                             );
            this->dwLastOperationError = GetLastError();
            hres = fRet ? STI_OK : HRESULT_FROM_WIN32(this->dwLastOperationError);
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CWDMDeviceControl | WDMRawWriteData |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CWDMDeviceControl_RawWriteData(
    PSTIDEVICECONTROL   pDev,
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;
    BOOL    fRet;

    EnterProc(CWDMDeviceControl_WDMRawWriteData, (_ "ppup",pDev,lpBuffer,dwNumberOfBytes,lpOverlapped));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCWDMDeviceControl     this = _thisPv(pDev);

        // Validate parameters here

        hres = STIERR_INVALID_PARAM;

        if (SUCCEEDED(hres = hresFullValidReadPvCb(lpBuffer,dwNumberOfBytes, 2)) ) {
            if (!lpOverlapped || SUCCEEDED(hres = hresFullValidReadPx(lpOverlapped, OVERLAPPED, 4)) ){
                // Call appropriate entry point
                fRet = WriteFile(this->hDeviceHandle,
                                 lpBuffer,
                                 dwNumberOfBytes,
                                 &dwBytesReturned,
                                 lpOverlapped
                                 );
                this->dwLastOperationError = GetLastError();
                hres = fRet ? STI_OK : HRESULT_FROM_WIN32(this->dwLastOperationError);
            }
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CWDMDeviceControl | RawReadControl |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CWDMDeviceControl_RawReadCommand(
    PSTIDEVICECONTROL   pDev,
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;
    BOOL    fRet;

    EnterProc(CWDMDeviceControl_WDMRawReadData, (_ "pppp",pDev,lpBuffer,lpdwNumberOfBytes,lpOverlapped));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCWDMDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        if (SUCCEEDED(hres = hresFullValidReadPvCb(lpdwNumberOfBytes, 4, 3)) &&
            SUCCEEDED(hres = hresFullValidReadPvCb(lpBuffer,*lpdwNumberOfBytes, 2)) &&
            (!lpOverlapped || SUCCEEDED(hres = hresFullValidReadPx(lpOverlapped, OVERLAPPED, 4))) ){

            // Call appropriate entry point
            fRet = ReadFile(this->hDeviceControlHandle,
                             lpBuffer,
                             *lpdwNumberOfBytes,
                             lpdwNumberOfBytes,
                             lpOverlapped
                             );
            this->dwLastOperationError = GetLastError();

            hres = fRet ? STI_OK : HRESULT_FROM_WIN32(this->dwLastOperationError);
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CWDMDeviceControl | WDMRawWriteData |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CWDMDeviceControl_RawWriteCommand(
    PSTIDEVICECONTROL   pDev,
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;
    BOOL    fRet;

    EnterProc(CWDMDeviceControl_WDMRawWriteData, (_ "ppup",pDev,lpBuffer,dwNumberOfBytes,lpOverlapped));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCWDMDeviceControl     this = _thisPv(pDev);

        // Validate parameters here

        hres = STIERR_INVALID_PARAM;

        if (SUCCEEDED(hres = hresFullValidReadPvCb(lpBuffer,dwNumberOfBytes, 2)) ) {
            if (!lpOverlapped || SUCCEEDED(hres = hresFullValidReadPx(lpOverlapped, OVERLAPPED, 4)) ){
                // Call appropriate entry point
                fRet = WriteFile(this->hDeviceControlHandle,
                                 lpBuffer,
                                 dwNumberOfBytes,
                                 &dwBytesReturned,
                                 lpOverlapped
                                 );
                this->dwLastOperationError = GetLastError();
                hres = fRet ? STI_OK : HRESULT_FROM_WIN32(this->dwLastOperationError);
            }
        }
    }

    ExitOleProc();
    return hres;
}



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CWDMDeviceControl | RawReadControl |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CWDMDeviceControl_GetLastError(
    PSTIDEVICECONTROL   pDev,
    LPDWORD     lpdwLastError
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;

    EnterProc(CWDMDeviceControl_GetLastError, (_ "pppp",pDev,lpdwLastError));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCWDMDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        if (SUCCEEDED(hres = hresFullValidReadPvCb(lpdwLastError,4, 2))) {
            *lpdwLastError = this->dwLastOperationError                 ;
            hres = STI_OK;
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CWDMDeviceControl | GetMyDevicePortName   |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CWDMDeviceControl_GetMyDevicePortName(
    PSTIDEVICECONTROL   pDev,
    LPWSTR              lpszDevicePath,
    DWORD               cwDevicePathSize
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;

    EnterProc(CWDMDeviceControl_GetMyDevicePortName, (_ "pp",pDev,lpszDevicePath));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCWDMDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        if (SUCCEEDED(hres = hresFullValidReadPvCb(lpszDevicePath,4, 2)) &&
            SUCCEEDED(hres = hresFullValidReadPvCb(lpszDevicePath,sizeof(WCHAR)*cwDevicePathSize, 2)) ) {

            if (cwDevicePathSize > OSUtil_StrLenW(this->wszPortName)) {
                OSUtil_lstrcpyW(lpszDevicePath,this->wszPortName);
                hres = STI_OK;
            }
            else {
                hres = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            }
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CWDMDeviceControl | GetMyDeviceHandle   |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CWDMDeviceControl_GetMyDeviceHandle(
    PSTIDEVICECONTROL   pDev,
    LPHANDLE            pHandle
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;

    EnterProc(CWDMDeviceControl_GetMyDeviceHandle, (_ "pp",pDev,pHandle));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCWDMDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        if (SUCCEEDED(hres = hresFullValidReadPvCb(pHandle,4, 2)) ) {

            if (INVALID_HANDLE_VALUE != this->hDeviceHandle) {
                *pHandle = this->hDeviceHandle;
                hres = STI_OK;
            }
            else {
                hres = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
            }
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CWDMDeviceControl | pdwOpenMode   |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CWDMDeviceControl_GetMyDeviceOpenMode(
    PSTIDEVICECONTROL   pDev,
    LPDWORD             pdwOpenMode
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;

    EnterProc(CWDMDeviceControl_GetMyDeviceOpenMode, (_ "pp",pDev,pdwOpenMode));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCWDMDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        if (SUCCEEDED(hres = hresFullValidReadPvCb(pdwOpenMode,4, 2)) ) {
            *pdwOpenMode = this->dwMode;
            hres = STI_OK;
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CWDMDeviceControl | RawReadControl |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CWDMDeviceControl_RawDeviceControl(
    PSTIDEVICECONTROL   pDev,
    USD_CONTROL_CODE EscapeFunction,
    LPVOID      lpInData,
    DWORD       cbInDataSize,
    LPVOID      pOutData,
    DWORD       dwOutDataSize,
    LPDWORD     pdwActualData
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;

    EnterProc(CWDMDeviceControl_RawDeviceControl, (_ "p",pDev));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCWDMDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        hres = STIERR_UNSUPPORTED;
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CWDMDeviceControl | WriteToErrorLog |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CWDMDeviceControl_WriteToErrorLog(
    PSTIDEVICECONTROL   pDev,
    DWORD   dwMessageType,
    LPCWSTR pszMessage,
    DWORD   dwErrorCode
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;

    EnterProc(CWDMDeviceControl_WriteToErrorLog, (_ "p",pDev));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCWDMDeviceControl     this = _thisPv(pDev);

        //
        // Validate parameters here
        //
        if (SUCCEEDED(hres = hresFullValidReadPvCb(pszMessage,2, 3))) {

#ifdef UNICODE
            ReportStiLogMessage(g_hStiFileLog,
                                dwMessageType,
                                pszMessage
                                );
#else
            LPTSTR   lpszAnsi = NULL;

            if ( SUCCEEDED(OSUtil_GetAnsiString(&lpszAnsi,pszMessage))) {
                ReportStiLogMessage(g_hStiFileLog,
                                    dwMessageType,
                                    lpszAnsi
                                    );
                FreePpv(&lpszAnsi);
            }
#endif
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @mfunc  HRESULT | CWDMDeviceControl | Initialize |
 *
 *          Initialize a DeviceControl object.
 *
 *  @cwrap  PSTIDEVICECONTROL | pDev
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The device had already been initialized with
 *          the instance GUID passed in <p lpGUID>.
 *
 *
 *****************************************************************************/

STDMETHODIMP
CWDMDeviceControl_Initialize(
    PSTIDEVICECONTROL   pDev,
    DWORD               dwDeviceType,
    DWORD               dwDeviceMode,
    LPCWSTR             pwszPortName,
    DWORD               dwFlags
    )
{
    HRESULT hres = STI_OK;

    WCHAR   wszDeviceSymbolicName[MAX_PATH] = {L'\0'};
    //LPSTR   pszAnsiDeviceName;

    EnterProcR(CWDMDeviceControl::Initialize,(_ "pp", pDev, pwszPortName));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCWDMDeviceControl     this = _thisPv(pDev);

        this->dwDeviceType = dwDeviceType;
        lstrcpynW(this->wszPortName,pwszPortName, sizeof(this->wszPortName) / sizeof(this->wszPortName[0]));

        //
        // Create symbolic name for the device we are trying to talk to
        // Try to open device data and control handles.
        //

        this->dwMode = dwDeviceMode;

        if (dwFlags & STI_HEL_OPEN_DATA) {

            OSUtil_lstrcatW(wszDeviceSymbolicName,this->wszPortName);

            // For devices with separate channels open them specially. Kernel mode
            // driver will need to understand convention
            // OSUtil_lstrcatW(wszDeviceSymbolicName,L"\\Data");

            this->hDeviceHandle = OSUtil_CreateFileW(wszDeviceSymbolicName,
                                              GENERIC_READ | GENERIC_WRITE, // Access mask
                                              0,                            // Share mode
                                              NULL,                         // SA
                                              OPEN_EXISTING,                // Create disposition
                                              FILE_ATTRIBUTE_SYSTEM,        // Attributes
                                              NULL                                                          // Template
                                              );
            this->dwLastOperationError = GetLastError();

            hres = (this->hDeviceHandle != INVALID_HANDLE_VALUE) ?
                        S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,this->dwLastOperationError);
        }

        //
        // If needed open control handle for the device
        //
        if (SUCCEEDED(hres) && (dwFlags & STI_HEL_OPEN_CONTROL)) {

            OSUtil_lstrcpyW(wszDeviceSymbolicName,REGSTR_PATH_STIDEVICES_W);
            OSUtil_lstrcatW(wszDeviceSymbolicName,L"\\");
            OSUtil_lstrcatW(wszDeviceSymbolicName,this->wszPortName);

            // For devices with separate channels open them specially. Kernel mode
            // driver will need to understand convention
            // OSUtil_lstrcatW(wszDeviceSymbolicName,L"\\Control");

            this->hDeviceControlHandle = OSUtil_CreateFileW(wszDeviceSymbolicName,
                                                     GENERIC_READ | GENERIC_WRITE,  // Access mask
                                                     0,                             // Share mode
                                                     NULL,                          // SA
                                                     OPEN_EXISTING,                 // Create disposition
                                                     FILE_ATTRIBUTE_SYSTEM,         // Attributes
                                                     NULL                                                   // Template
                                                     );
            this->dwLastOperationError = GetLastError();

            hres = (this->hDeviceControlHandle != INVALID_HANDLE_VALUE) ?
                        S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,this->dwLastOperationError);
        }

    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  void | CWDMDeviceControl | Init |
 *
 *          Initialize the internal parts of the StiDevice object.
 *
 *****************************************************************************/

void INLINE
CWDMDeviceControl_Init(
    PCWDMDeviceControl this
    )
{
    // Initialize instance variables
    this->dwContext = 0L;
    this->dwLastOperationError = NO_ERROR;
    this->hDeviceHandle = INVALID_HANDLE_VALUE;
    this->hDeviceControlHandle = INVALID_HANDLE_VALUE;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CWDMDeviceControl_Finalize |
 *
 *          Releases the resources of a generic device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CWDMDeviceControl_Finalize(PV pvObj)
{
    HRESULT hres = STI_OK;

    PCWDMDeviceControl     this  = pvObj;

    // Close device handles
    if (IsValidHANDLE(this->hDeviceHandle)) {
        CloseHandle(this->hDeviceHandle);
    }

    if (IsValidHANDLE(this->hDeviceControlHandle)) {
        CloseHandle(this->hDeviceControlHandle );
    }

    this->dwContext = 0L;
    this->dwLastOperationError = NO_ERROR;
    this->hDeviceHandle = INVALID_HANDLE_VALUE;
    this->hDeviceControlHandle = INVALID_HANDLE_VALUE;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | CWDMDeviceControl | New |
 *
 *          Create a new  IDeviceControl object, uninitialized.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          Output pointer for new object.
 *
 *****************************************************************************/

STDMETHODIMP
CWDMDeviceControl_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(CWDMDeviceControl::<constructor>, (_ "Gp", riid, punkOuter));

    hres = Common_NewRiid(CWDMDeviceControl, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        PCWDMDeviceControl this = _thisPv(*ppvObj);
        CWDMDeviceControl_Init(this);
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func  HRESULT | NewDeviceControl |
 *
 *          Creates and initializes DCB for given device.
 *
 *****************************************************************************/
STDMETHODIMP
NewDeviceControl(
    DWORD               dwDeviceType,
    DWORD               dwDeviceMode,
    LPCWSTR             pwszPortName,
    DWORD               dwFlags,
    PSTIDEVICECONTROL   *ppDevCtl
    )
{

    HRESULT hres = STI_OK;

    EnterProc(NewDeviceControl,(_ "xpp", dwDeviceType,pwszPortName,ppDevCtl));


    // Validate device type
    #ifdef DEBUG

    hres = STI_OK;

    switch (dwDeviceType) {
        case HEL_DEVICE_TYPE_WDM:
            break;
        case HEL_DEVICE_TYPE_PARALLEL:
            break;
        case HEL_DEVICE_TYPE_SERIAL:
            break;
        default:
            ValidateF(0,("Invalid dwvice type passed to DcbNew"));
            return STIERR_INVALID_PARAM;
    }

    // Validate string
    if (!pwszPortName || !*pwszPortName) {
        //AssertF(0,("Invalid device name passed to DcbNew"));
        hres = STIERR_INVALID_PARAM;
    }
    else {
        hres = hresFullValidPdwOut(ppDevCtl,3);
    }
    #else
    if (!pwszPortName || !*pwszPortName) {
        hres = STIERR_INVALID_PARAM;
    }
    #endif

    if (SUCCEEDED(hres)) {

        //
        // Now call appropriate initialization routine
        //
        switch (dwDeviceType) {
            case HEL_DEVICE_TYPE_WDM:
            case HEL_DEVICE_TYPE_PARALLEL:
                hres = CWDMDeviceControl_New(NULL, &IID_IStiDeviceControl,ppDevCtl);
                break;

            case HEL_DEVICE_TYPE_SERIAL:
                hres = CCommDeviceControl_New(NULL, &IID_IStiDeviceControl,ppDevCtl);
                break;

            default:
                ValidateF(0,("Invalid device type passed to DcbNew"));
                return STIERR_INVALID_PARAM;
        }

    }

    if (SUCCEEDED(hres)) {
        hres = IStiDeviceControl_Initialize(*ppDevCtl,dwDeviceType,dwDeviceMode,pwszPortName,dwFlags);
    }

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CWDMDeviceControl_Signature        (DWORD)'WDM'

Primary_Interface_Begin(CWDMDeviceControl, IStiDeviceControl)
    CWDMDeviceControl_Initialize,
    CWDMDeviceControl_RawReadData,
    CWDMDeviceControl_RawWriteData,
    CWDMDeviceControl_RawReadCommand,
    CWDMDeviceControl_RawWriteCommand,
    CWDMDeviceControl_RawDeviceControl,
    CWDMDeviceControl_GetLastError,
    CWDMDeviceControl_GetMyDevicePortName,
    CWDMDeviceControl_GetMyDeviceHandle,
    CWDMDeviceControl_GetMyDeviceOpenMode,
    CWDMDeviceControl_WriteToErrorLog,
Primary_Interface_End(CWDMDeviceControl, IStiDeviceControl)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\eventlog.cpp ===
/*++
   Copyright    (c)    1997        Microsoft Corporation

   Module Name:

        eventlog.cpp

   Abstract:

        This module defines the generic class for logging events.
        Because Windows9x does not have system event logging mechanism
        we emulate it with text file


   Author:

        Vlad Sadovsky   (VladS)    01-Feb-1997

Environment:

    User Mode - Win32

   History:

    22-Sep-1997     VladS       created
    29-Sep-1997     VladS       Added native NT event logging calls

--*/


//
//  Include Headers
//

#include "cplusinc.h"
#include "sticomm.h"

#include <eventlog.h>
#include <stisvc.h>


# define   PSZ_EVENTLOG_REG_ENTRY    \
                        TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\")
# define   PSZ_PARAMETERS_REG_ENTRY     TEXT("EventMessageFile")
# define   PSZ_TYPES_REG_ENTRY     TEXT("TypesSupported")

#ifndef WINNT

#include <lock.h>

//
// Definitions for Win9x event logging ( which is based on text file)
//
# define   PSZ_EVENT_LOG_FILE_DIRECTORY_A   "EventLogDirectory"
# define   PSZ_EVENT_LOG_FILE__A            "\\Sti_Event.log"

//
// Static variables, common for all event loggin objects
//
//
static const TCHAR  szMutexNamePrefix[] = TEXT("StiEventLogMutex");

MUTEX_OBJ   EventLogSync(szMutexNamePrefix);

#endif WINNT

LONG        lTotalLoggers = 0;
HANDLE      hEventLogFile = INVALID_HANDLE_VALUE;

//
// Functions
//
//
inline BOOL
FormatStdTime( IN const SYSTEMTIME * pstNow,
               IN OUT TCHAR *    pchBuffer,
               IN int          cbBuffer)
{
    return ( GetTimeFormat( LOCALE_SYSTEM_DEFAULT,
                            ( LOCALE_NOUSEROVERRIDE | TIME_FORCE24HOURFORMAT|
                              TIME_NOTIMEMARKER),
                            pstNow, NULL, pchBuffer, cbBuffer)
             != 0);

} // FormatStdTime()


inline BOOL
FormatStdDate( IN const SYSTEMTIME * pstNow,
               IN OUT TCHAR *    pchBuffer,
               IN  int          cbBuffer)
{
    return ( GetDateFormat( LOCALE_SYSTEM_DEFAULT, LOCALE_NOUSEROVERRIDE,
                            pstNow, NULL, pchBuffer, cbBuffer)
             != 0);
} // FormatStdDate()



EVENT_LOG::EVENT_LOG( LPCTSTR lpszSource)
/*++

   Description
     Constructor function for given event log object.
     Initializes event logging services.

   Arguments:

      lpszSource:    Source string for the Event source module

   Note:

     This is intended to be executed once only.
     This is not to be used for creating multiple event
      log handles for same given source name.
     But can be used for creating EVENT_LOG objects for
      different source names.

--*/
{


    m_ErrorCode    = NO_ERROR;
    m_lpszSource   = lpszSource;
    m_hEventSource = INVALID_HANDLE_VALUE;

#ifdef WINNT

    //
    //  Register as an event source.
    //

    m_ErrorCode    = NO_ERROR;
    m_lpszSource   = lpszSource;
    m_hEventSource = RegisterEventSource( NULL, lpszSource);


    if( m_hEventSource == NULL ) {
        //
        // An Error in initializing the event log.
        //
        m_ErrorCode = GetLastError();
    }

    //
    //  Success!
    //

#else
    //
    // Windows 9x specific code
    //

    CHAR    szFilePath[MAX_PATH+1];
    CHAR    szKeyName[MAX_PATH+1];
    DWORD   cbBuffer;
    HKEY    hKey;

    *szFilePath = TEXT('\0');

    //
    // If file has not been opened yet - try to do it now
    // Nb: Speed is not critical here, because it is unlikely to have threads
    // competing, so we use not vey efficient locking

    EventLogSync.Lock();

    if ( 0 == lTotalLoggers && ( hEventLogFile ==  INVALID_HANDLE_VALUE)) {

        //
        // Nobody logging yet - open file
        //
        lstrcpy(szKeyName,REGSTR_PATH_STICONTROL_A);
        cbBuffer = sizeof(szFilePath);

        m_ErrorCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                szKeyName,
                               0,
                               KEY_ALL_ACCESS,
                               &hKey);

        if ( m_ErrorCode == NO_ERROR) {

            //
            // Read the value into buffer
            //

            *szFilePath = TEXT('\0');
            m_ErrorCode = RegQueryValueEx( hKey,
                                       REGSTR_VAL_EVENT_LOG_DIRECTORY_A,
                                       NULL,
                                       NULL,
                                       (LPBYTE) szFilePath,
                                       &cbBuffer);

            RegCloseKey( hKey);
        }

        // If we did not get log file directory - use system
        if ((NOERROR != m_ErrorCode) || !*szFilePath ) {
            m_ErrorCode = GetWindowsDirectory(szFilePath,sizeof(szFilePath));
        }

        if (*szFilePath ) {

            lstrcat(szFilePath,PSZ_EVENT_LOG_FILE__A);

            hEventLogFile =  CreateFile(szFilePath,
                                        GENERIC_WRITE,
                                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                                        NULL,       // security attributes
                                        OPEN_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);      // template file handle

            if ( hEventLogFile != INVALID_HANDLE_VALUE) {

                // set the file pointer at the end of the file (append mode)
                if ( SetFilePointer( hEventLogFile, 0, NULL, FILE_END)
                     == (DWORD) -1L) {

                    hEventLogFile = INVALID_HANDLE_VALUE;
                    CloseHandle(hEventLogFile);

                }
            }

        } /* endif ValidPath */

    } /* endif no loggers */

    InterlockedIncrement(&lTotalLoggers);

    EventLogSync.Unlock();

    if( hEventLogFile !=  INVALID_HANDLE_VALUE) {
        //
        // If log file successfully opened - register event message source file.
        // On Win9x registration simply means locating module handle for DLL , where we will
        // load messages from
        //

        lstrcpy(szKeyName,PSZ_EVENTLOG_REG_ENTRY);
        lstrcat(szKeyName,lpszSource);

        m_ErrorCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                  szKeyName,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hKey);

        if ( m_ErrorCode == NO_ERROR) {

            //
            // Read the value into buffer
            //

            cbBuffer = sizeof(szFilePath);
            *szFilePath = TEXT('\0');

            m_ErrorCode = RegQueryValueEx( hKey,
                                       PSZ_PARAMETERS_REG_ENTRY,
                                       NULL,
                                       NULL,
                                       (LPBYTE) szFilePath,
                                       &cbBuffer);

            RegCloseKey( hKey);

            if ((NOERROR == m_ErrorCode) && (*szFilePath)) {

                m_hEventSource  = GetModuleHandle(szFilePath);
                //ASSERT( m_hEventSource != NULL);

            }
        }

        if (NO_ERROR == m_ErrorCode) {

        }
        else {

            //
            // An Error in initializing the event log.
            //

        }
    }
    else {

        //
        // An Error in initializing the event log.
        //
        m_ErrorCode = GetLastError();

        DPRINTF(DM_ERROR,"Could not create log file  (%s) ( Error %lu)\n",
                   szFilePath,
                   m_ErrorCode);

    }

    m_ErrorCode    = NO_ERROR;

#endif  // WINNT

} /* EVENT_LOG::EVENT_LOG() */



EVENT_LOG::~EVENT_LOG( VOID)
/*++

    Description:
        Destructor function for given EVENT_LOG object.
        Terminates event logging functions and closes
         event log handle

--*/
{

#ifdef WINNT
    //
    // If there is a valid Events handle, deregister it
    //

    if ( m_hEventSource != NULL) {

        BOOL fSuccess;

        fSuccess = DeregisterEventSource( m_hEventSource);

        if ( !fSuccess) {

            //
            // An Error in DeRegistering
            //

            m_ErrorCode = GetLastError();
            DPRINTF( DM_ERROR, TEXT("Termination of EventLog for %s failed.error %lu\n"),m_lpszSource,m_ErrorCode);
        }

        //
        //  Reset the handle's value. Just as a precaution
        //
        m_hEventSource = NULL;
    }

#else

    TAKE_MUTEX_OBJ t(EventLogSync);

    InterlockedDecrement(&lTotalLoggers);

    if ( 0 == lTotalLoggers ) {

        if (hEventLogFile != INVALID_HANDLE_VALUE) {

            FlushFileBuffers( hEventLogFile);

            CloseHandle(hEventLogFile);
            hEventLogFile = INVALID_HANDLE_VALUE;

        }
    }

#endif

} /* EVENT_LOG::~EVENT_LOG() */

VOID
EVENT_LOG::LogEvent(
        IN DWORD  idMessage,
        IN WORD   nSubStrings,
        IN const CHAR * rgpszSubStrings[],
        IN DWORD  errCode)
/*++

     Description:
        Log an event to the event logger

     Arguments:

       idMessage           Identifies the event message

       nSubStrings         Number of substrings to include in
                            this message. (Maybe 0)

       rgpszSubStrings     array of substrings included in the message
                            (Maybe NULL if nSubStrings == 0)

       errCode             An error code from Win32 or NT_STATUS.
                            If this is not Zero, it is considered as
                            "raw" data to be included in message

   Returns:

     None

--*/
{

   WORD wType;                // Type of Event to be logged

   //
   //  Find type of message for the event log
   //

   if ( NT_INFORMATION( idMessage)) {

       wType = EVENTLOG_INFORMATION_TYPE;

   } else
     if ( NT_WARNING( idMessage)) {

         wType = EVENTLOG_WARNING_TYPE;

     } else
       if ( NT_ERROR( idMessage)) {

           wType = EVENTLOG_ERROR_TYPE;

       } else  {
           wType = EVENTLOG_ERROR_TYPE;
       }

   //
   //  Log the event
   //

   EVENT_LOG::LogEventPrivate( idMessage,
                              wType,
                              nSubStrings,
                              rgpszSubStrings,
                              errCode);


   return;

} /* EVENT_LOG::LogEvent() */


VOID
EVENT_LOG::LogEvent(
        IN DWORD   idMessage,
        IN WORD    nSubStrings,
        IN WCHAR * rgpszSubStrings[],
        IN DWORD   errCode)
/*++

     Description:
        Simple Unicode wrapper

     Arguments:

       idMessage           Identifies the event message

       nSubStrings         Number of substrings to include in
                            this message. (Maybe 0)

       rgpszSubStrings     array of substrings included in the message
                            (Maybe NULL if nSubStrings == 0)

       errCode             An error code from Win32 or WinSock or NT_STATUS.
                            If this is not Zero, it is considered as
                            "raw" data to be included in message

   Returns:

     None

--*/
{

    LPCSTR * apsz;
    DWORD    cch;
    DWORD    i;
    WORD     nUsedSubStrings = nSubStrings;

static const CHAR *szEmptyString = "";

    __try {

        apsz = new LPCSTR[nSubStrings];

        if ( !apsz ) {

            nUsedSubStrings = 0;
            __leave;
        }

        ZeroMemory(apsz, nSubStrings * sizeof(apsz[0]));

        //
        //  Convert the array of Wide char parameters
        //

        for ( i = 0; i < nSubStrings; i++ ) {

            UINT    cb;

            cb = (wcslen( rgpszSubStrings[i] ) + 1) * sizeof(CHAR);

            apsz[i] = new CHAR[cb];

            if (!apsz[i]) {
                //
                //  Ouch, we can't event convert the memory for the parameters.
                //  We'll just log the error without the params then
                //
                nUsedSubStrings = 0;
                __leave;
            }

            cch = WideCharToMultiByte( CP_ACP,
                                       WC_COMPOSITECHECK,
                                       rgpszSubStrings[i],
                                       -1,
                                       (LPSTR)apsz[i],
                                       cb,
                                       NULL,
                                       NULL );

            *((CHAR *) apsz[i] + cb) = '\0';
        }

    }
    __finally {

        //
        //  If no substrings, then nothing to convert
        //
        LogEvent( idMessage,
                 nUsedSubStrings,
                 nUsedSubStrings ? apsz : &szEmptyString,
                 errCode );

        if (apsz) {
            for ( i = 0; i < nSubStrings; i++ ) {
                if (apsz[i]) {
                    delete [] (VOID *)apsz[i];
                }
            }

            delete [] apsz;
        }
    }

}


//
//  Private functions.
//

VOID
EVENT_LOG::LogEventPrivate(
    IN DWORD   idMessage,
    IN WORD    wEventType,
    IN WORD    nSubStrings,
    IN const   CHAR  * apszSubStrings[],
    IN DWORD   errCode )
/*++

     Description:
        Log an event to the event logger.
        ( Private version, includes EventType)

     Arguments:

       idMessage           Identifies the event message

       wEventType          Specifies the severety of the event
                            (error, warning, or informational).

       nSubStrings         Number of substrings to include in
                            this message. (Maybe 0)

       apszSubStrings     array of substrings included in the message
                            (Maybe NULL if nSubStrings == 0)

       errCode             An error code from Win32 or NT_STATUS.
                            If this is not Zero, it is considered as
                            "raw" data to be included in message

   Returns:

     None

--*/
{
    VOID  * pRawData  = NULL;
    DWORD   cbRawData = 0;
    BOOL    fReturn;
    DWORD   cch,cbWritten;

#ifdef WINNT

    BOOL    fReport;

    ASSERT( (nSubStrings == 0) || (apszSubStrings != NULL));

    ASSERTSZ( (m_hEventSource != NULL),TEXT("Event log handle is not valid"));

    if( errCode != 0 ) {
        pRawData  = &errCode;
        cbRawData = sizeof(errCode);
    }

    m_ErrorCode  = NO_ERROR;

    fReport = ReportEvent( m_hEventSource,                   // hEventSource
                           wEventType,                       // fwEventType
                           0,                                // fwCategory
                           idMessage,                        // IDEvent
                           NULL,                             // pUserSid,
                           nSubStrings,                      // cStrings
                           cbRawData,                        // cbData
                           (LPCTSTR *) apszSubStrings,       // plpszStrings
                           pRawData );                       // lpvData

    if (!fReport) {
        m_ErrorCode = GetLastError();
    }

#else

    //CHAR    szErrCodeString[20];
    CHAR    *pchBuff = NULL;
    SYSTEMTIME  stCurrentTime;
    CHAR    szFmtTime[32];
    CHAR    szFmtDate[32];

    CHAR    szErrorText[MAX_PATH] = {'\0'};

    if( (hEventLogFile ==  INVALID_HANDLE_VALUE) ||
        (m_hEventSource == INVALID_HANDLE_VALUE) ) {
        return;
    }

    if( errCode != 0 ) {
        pRawData  = &errCode;
        cbRawData = sizeof(errCode);
    }

    m_ErrorCode  = NO_ERROR;

    //
    // Write name of the service, date and time, severity
    //

    *szFmtTime = *szFmtDate = '\0';

    GetLocalTime(&stCurrentTime);

    FormatStdTime( &stCurrentTime, szFmtTime, 15);
    FormatStdDate( &stCurrentTime, szFmtDate, 15);

    wsprintf(szErrorText,"[%s] %s %s :",m_lpszSource,szFmtDate,szFmtTime);
    WriteFile(hEventLogFile,
             szErrorText,
             lstrlen(szErrorText),
             &cbWritten,
             NULL);

    //
    // Read message and add inserts
    //
    cch = ::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_MAX_WIDTH_MASK  |
                           FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           m_hEventSource,
                           idMessage,
                           0,
                           (LPSTR) &pchBuff,
                           1024,
                           (va_list *)apszSubStrings
                           );

    if (cch ) {

        TAKE_MUTEX_OBJ t(EventLogSync);

        fReturn =  WriteFile(hEventLogFile,pchBuff,cch,&cbWritten,NULL);

        LocalFree(pchBuff);

        if (cbWritten) {
            WriteFile(hEventLogFile,"\n\r",2,&cbWritten,NULL);
            return ;
        }
    }


    m_ErrorCode = GetLastError();

#endif

}   /* EVENT_LOG::~LogEventPrivate() */

VOID
WINAPI
RegisterStiEventSources(
    VOID
    )
/*++

    Description:

        Adds necessary registry entry when installing service

    Arguments:

    Returns:

     None

--*/
{
    RegEntry    re(PSZ_EVENTLOG_REG_ENTRY,HKEY_LOCAL_MACHINE);

    re.SetValue(PSZ_PARAMETERS_REG_ENTRY,STI_IMAGE_NAME);
    re.SetValue(PSZ_TYPES_REG_ENTRY,7);

}

/********************************* End of File ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\msgi.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    msgi.h

Abstract:

    Message box routines

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#include "cplusinc.h"
#include "sticomm.h"

extern HINSTANCE    g_hInstance;


int MsgBox( HWND hwndOwner, UINT idMsg, UINT wFlags, const TCHAR  *aps[] /* = NULL */ )
{

    STR     strTitle;
    STR     strMsg;

    strTitle.LoadString(IDS_MSGTITLE);

    if (aps == NULL)
        strMsg.LoadString( idMsg );
    else
        strMsg.FormatString(idMsg,aps);

    return ::MessageBox( hwndOwner, strMsg.QueryStr(), strTitle.QueryStr(), wFlags | MB_SETFOREGROUND );
}

/*
 * MsgBoxPrintf
 * ------------
 *
 * Message box routine
 *
 */
UINT    MsgBoxPrintf(HWND hwnd,UINT uiMsg,UINT uiTitle,UINT uiFlags,...)
{
    STR     strTitle;
    STR     strMessage;
    LPTSTR   lpFormattedMessage = NULL;
    UINT    err;
    va_list start;

    va_start(start,uiFlags);

    strMessage.LoadString(uiMsg);

    err = ::FormatMessage(FORMAT_MESSAGE_FROM_STRING  | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        (LPVOID)strMessage.QueryStr(),
                        // FORMAT_MESSAGE_FROM_HMODULE,
                        //::g_hmodThisDll,
                        uiMsg,                  // Message resource id
                        NULL,                   // Language id
                        (LPTSTR)&lpFormattedMessage,    // Return pointer to fromatted text
                        255,                        // Min.length
                        &start
                        );

    if (!err || !lpFormattedMessage) {
        err = GetLastError();
        return err;
    }

    strTitle.LoadString(uiTitle);

    err = ::MessageBox(hwnd,
                       lpFormattedMessage,
                       strTitle.QueryStr(),
                       uiFlags);

    ::LocalFree(lpFormattedMessage);

    return err;

}

#if 0
/*
 * LoadMsgPrintf
 * -------------
 *
 * Uses normal printf style format string
 */
UINT
LoadMsgPrintf(
    NLS_STR&    nlsMessage,
    UINT        uiMsg,
    ...
    )
{
    LPSTR   lpFormattedMessage = NULL;
    UINT    err;
    va_list start;

    va_start(start,uiMsg);

    nlsMessage.LoadString(uiMsg);

#ifdef USE_PRINTF_STYLE

    lpFormattedMessage = ::LocalAlloc(GPTR,255);    // BUGBUG

    if (!lpFormattedMessage) {
        Break();
        return WN_OUT_OF_MEMORY;
    }

    ::wsprintf(lpFormattedMessage,
               nlsMessage.QueryPch(),
               &start);

#else

    err = ::FormatMessage(FORMAT_MESSAGE_FROM_STRING  | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        nlsMessage,
                        //| FORMAT_MESSAGE_FROM_HMODULE,
                        //::g_hmodThisDll,
                        uiMsg,                  // Message resource id
                        NULL,                   // Language id
                        (LPTSTR)&lpFormattedMessage,    // Return pointer to fromatted text
                        255,                        // Min.length
                        &start
                        );

    if (!err || !lpFormattedMessage) {
        err = GetLastError();
        return err;
    }

#endif

    nlsMessage = lpFormattedMessage;

    ::LocalFree(lpFormattedMessage);

    return WN_SUCCESS;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\lock.cpp ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Resource.cpp

Abstract:

    This module implements the executive functions to acquire and release
    a shared resource.

Author:

    Mark Lucovsky       (markl)     04-Aug-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable in only from user mode.  They make use of Nt system
    services.

Revision History:

    02-Feb-97   vlads   Adapted to Win9x environment to support portable syncronization
                        ( RTL calls do not exist)


--*/

#include "cplusinc.h"
#include "sticomm.h"

#include <lock.h>

//
//  The semaphore wait time before retrying the wait
//

#define _RES_TIMEOUT            (2 * 60 * 1000)



BOOL
InitializeResource(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine initializes the input resource variable

Arguments:

    Resource - Supplies the resource variable being initialized

Return Value:

    None

--*/

{

    //
    //  Initialize the lock fields, the count indicates how many are waiting
    //  to enter or are in the critical section, LockSemaphore is the object
    //  to wait on when entering the critical section.  SpinLock is used
    //  for the add interlock instruction.
    //

    __try {
#ifdef UNICODE        
        if(!InitializeCriticalSectionAndSpinCount( &Resource->CriticalSection, MINLONG ))
            return FALSE;
#else
        InitializeCriticalSection( &Resource->CriticalSection);
#endif        
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }

    Resource->DebugInfo = NULL;

    //
    //  Initialize flags so there is a default value.
    //  (Some apps may set RTL_RESOURCE_FLAGS_LONG_TERM to affect timeouts.)
    //

    Resource->Flags = 0;


    //
    //  Initialize the shared and exclusive waiting counters and semaphore.
    //  The counters indicate how many are waiting for access to the resource
    //  and the semaphores are used to wait on the resource.  Note that
    //  the semaphores can also indicate the number waiting for a resource
    //  however there is a race condition in the alogrithm on the acquire
    //  side if count if not updated before the critical section is exited.
    //

     Resource->SharedSemaphore = CreateSemaphore( NULL,
                                                  0,
                                                  MAXLONG,
                                                  NULL );

    if ( !Resource->SharedSemaphore ) {
        return FALSE;
    }

    Resource->NumberOfWaitingShared = 0;

    Resource->ExclusiveSemaphore = CreateSemaphore( NULL,
                                                    0,
                                                    MAXLONG,
                                                    NULL );
    if ( !Resource->ExclusiveSemaphore ){
        CloseHandle( Resource->SharedSemaphore );

        return FALSE;
    }

    Resource->NumberOfWaitingExclusive = 0;

    //
    //  Initialize the current state of the resource
    //

    Resource->NumberOfActive = 0;

    Resource->ExclusiveOwnerThread = NULL;

    return TRUE;
}


BOOL
AcquireResourceShared(
    IN PRTL_RESOURCE Resource,
    IN BOOL          Wait
    )

/*++

Routine Description:

    The routine acquires the resource for shared access.  Upon return from
    the procedure the resource is acquired for shared access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOL - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    DWORD          ret;
    ULONG          TimeoutCount = 0;
    DWORD          TimeoutTime  = _RES_TIMEOUT;
    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If it is not currently acquired for exclusive use then we can acquire
    //  the resource for shared access.  Note that this can potentially
    //  starve an exclusive waiter however, this is necessary given the
    //  ability to recursively acquire the resource shared.  Otherwise we
    //  might/will reach a deadlock situation where a thread tries to acquire
    //  the resource recusively shared but is blocked by an exclusive waiter.
    //
    //  The test to reanable not starving an exclusive waiter is:
    //
    //      if ((Resource->NumberOfWaitingExclusive == 0) &&
    //          (Resource->NumberOfActive >= 0)) {
    //

    if (Resource->NumberOfActive >= 0) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section
        //

        Resource->NumberOfActive += 1;

        LeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise check to see if this thread is the one currently holding
    //  exclusive access to the resource.  And if it is then we change
    //  this shared request to an exclusive recusive request and grant
    //  access to the resource.
    //

    } else if (Resource->ExclusiveOwnerThread == (HANDLE)ULongToPtr(GetCurrentThreadId())) {

        //
        //  The resource is ours (recusively) so indicate that we have it
        //  and exit the critial section
        //

        Resource->NumberOfActive -= 1;

        LeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise we'll have to wait for access.
    //

    } else {

        //
        //  Check if we are allowed to wait or must return immedately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            LeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting shared,
        //  release the lock, and wait on the shared semaphore
        //

        Resource->NumberOfWaitingShared += 1;

        LeaveCriticalSection(&Resource->CriticalSection);

rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = INFINITE;
        }
        ret = WaitForSingleObject(
                    Resource->SharedSemaphore,
                    TimeoutTime
                    );

        if ( ret == WAIT_TIMEOUT ) {
#if DBG
            OutputDebugString( TEXT("[AcquireResourceShared] Sem timeout\n") );
#endif

            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
#if DBG
                DebugBreak();
#endif
                }
#if DBG
            OutputDebugString(TEXT("[AcquireResourceShared]: Re-Waiting\n"));
#endif
            goto rewait;
        } else if ( ret != WAIT_OBJECT_0 ) {
#if DBG
            OutputDebugString(TEXT("[AcquireResourceShared]: WaitForSingleObjectFailed\n"));
#endif
        }
    }

    //
    //  Now the resource is ours, for shared access
    //

    return TRUE;

}


BOOL
AcquireResourceExclusive(
    IN PRTL_RESOURCE Resource,
    IN BOOL Wait
    )

/*++

Routine Description:

    The routine acquires the resource for exclusive access.  Upon return from
    the procedure the resource is acquired for exclusive access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOL - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    ULONG TimeoutCount = 0;
    DWORD TimeoutTime  = _RES_TIMEOUT;
    DWORD ret;

    //
    //  Loop until the resource is ours or exit if we cannot wait.
    //

    while (TRUE) {

        //
        //  Enter the critical section
        //

        EnterCriticalSection(&Resource->CriticalSection);

        //
        //  If there are no shared users and it is not currently acquired for
        //  exclusive use then we can acquire the resource for exclusive
        //  access.  We also can acquire it if the resource indicates exclusive
        //  access but there isn't currently an owner.
        //

        if ((Resource->NumberOfActive == 0)

                ||

            ((Resource->NumberOfActive == -1) &&
             (Resource->ExclusiveOwnerThread == NULL))) {

            //
            //  The resource is ours, so indicate that we have it and
            //  exit the critical section
            //

            Resource->NumberOfActive = -1;

            Resource->ExclusiveOwnerThread = (HANDLE) ULongToPtr(GetCurrentThreadId());

            LeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Otherwise check to see if we already have exclusive access to the
        //  resource and can simply recusively acquire it again.
        //

        if (Resource->ExclusiveOwnerThread == (HANDLE) ULongToPtr(GetCurrentThreadId())) {

            //
            //  The resource is ours (recusively) so indicate that we have it
            //  and exit the critial section
            //

            Resource->NumberOfActive -= 1;

            LeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Check if we are allowed to wait or must return immedately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            LeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting exclusive,
        //  release the lock, and wait on the exclusive semaphore
        //

        Resource->NumberOfWaitingExclusive += 1;

        LeaveCriticalSection(&Resource->CriticalSection);

rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = INFINITE;
        }
        ret = WaitForSingleObject(
                    Resource->ExclusiveSemaphore,
                    TimeoutTime
                    );

        if ( ret == WAIT_TIMEOUT ) {
#if DBG
            OutputDebugString( TEXT("[AcquireResourceExclusive] Sem timeout\n") );
#endif

            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
#if DBG
                DebugBreak();
#endif
                }
#if DBG
            OutputDebugString(TEXT("[AcquireResourceExclusive]: Re-Waiting\n"));
#endif
            goto rewait;
        } else if ( ret != WAIT_OBJECT_0 ) {
#if DBG
            OutputDebugString(TEXT("[AcquireResourceExclusive]: WaitForSingleObject Failed\n"));
#endif
        }
    }

    return TRUE;
}


BOOL
ReleaseResource(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine release the input resource.  The resource can have been
    acquired for either shared or exclusive access.

Arguments:

    Resource - Supplies the resource to release

Return Value:

    None.

--*/

{
    LONG PreviousCount;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  Test if the resource is acquired for shared or exclusive access
    //

    if (Resource->NumberOfActive > 0) {

        //
        //  Releasing shared access to the resource, so decrement
        //  the number of shared users
        //

        Resource->NumberOfActive -= 1;

        //
        //  If the resource is now available and there is a waiting
        //  exclusive user then give the resource to the waiting thread
        //

        if ((Resource->NumberOfActive == 0) &&
            (Resource->NumberOfWaitingExclusive > 0)) {

            //
            //  Set the resource state to exclusive (but not owned),
            //  decrement the number of waiting exclusive, and release
            //  one exclusive waiter
            //

            Resource->NumberOfActive = -1;
            Resource->ExclusiveOwnerThread = NULL;

            Resource->NumberOfWaitingExclusive -= 1;

            if ( !ReleaseSemaphore(
                         Resource->ExclusiveSemaphore,
                         1,
                         &PreviousCount
                         )) {
                return FALSE;
            }
        }

    } else if (Resource->NumberOfActive < 0) {

        //
        //  Releasing exclusive access to the resource, so increment the
        //  number of active by one.  And continue testing only
        //  if the resource is now available.
        //

        Resource->NumberOfActive += 1;

        if (Resource->NumberOfActive == 0) {

            //
            //  The resource is now available.  Remove ourselves as the
            //  owner thread
            //

            Resource->ExclusiveOwnerThread = NULL;

            //
            //  If there is another waiting exclusive then give the resource
            //  to it.
            //

            if (Resource->NumberOfWaitingExclusive > 0) {

                //
                //  Set the resource to exclusive, and its owner undefined.
                //  Decrement the number of waiting exclusive and release one
                //  exclusive waiter
                //

                Resource->NumberOfActive = -1;
                Resource->NumberOfWaitingExclusive -= 1;

                if ( !ReleaseSemaphore(
                             Resource->ExclusiveSemaphore,
                             1,
                             &PreviousCount
                             )) {
                    return FALSE;
                }

            //
            //  Check to see if there are waiting shared, who should now get
            //  the resource
            //

            } else if (Resource->NumberOfWaitingShared > 0) {

                //
                //  Set the new state to indicate that all of the shared
                //  requesters have access and there are no more waiting
                //  shared requesters, and then release all of the shared
                //  requsters
                //

                Resource->NumberOfActive = Resource->NumberOfWaitingShared;

                Resource->NumberOfWaitingShared = 0;

                if ( !ReleaseSemaphore(
                             Resource->SharedSemaphore,
                             Resource->NumberOfActive,
                             &PreviousCount
                             )) {
                    return FALSE;
                }
            }
        }

#if DBG
    } else {

        //
        //  The resource isn't current acquired, there is nothing to release
        //  so tell the user the mistake
        //


        OutputDebugString(TEXT("[ReleaseResource] - Resource released too many times!\n"));
        DebugBreak();
#endif
    }

    //
    //  Exit the critical section, and return to the caller
    //

    LeaveCriticalSection(&Resource->CriticalSection);

    return TRUE;
}


BOOL
ConvertSharedToExclusive(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for shared access into
    one acquired for exclusive access.  Upon return from the procedure
    the resource is acquired for exclusive access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for shared access

Return Value:

    None

--*/

{
    DWORD ret;
    DWORD TimeoutTime  = _RES_TIMEOUT;
    ULONG TimeoutCount = 0;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If there is only one shared user (it's us) and we can acquire the
    //  resource for exclusive access.
    //

    if (Resource->NumberOfActive == 1) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section, and return
        //

        Resource->NumberOfActive = -1;

        Resource->ExclusiveOwnerThread = (HANDLE) ULongToPtr(GetCurrentThreadId());

        LeaveCriticalSection(&Resource->CriticalSection);

        return TRUE;
    }

    //
    //  If the resource is currently acquired exclusive and it's us then
    //  we already have exclusive access
    //

    if ((Resource->NumberOfActive < 0) &&
        (Resource->ExclusiveOwnerThread == (HANDLE) ULongToPtr(GetCurrentThreadId()))) {

        //
        //  We already have exclusive access to the resource so we'll just
        //  exit the critical section and return
        //

        LeaveCriticalSection(&Resource->CriticalSection);

        return TRUE;
    }

    //
    //  If the resource is acquired by more than one shared then we need
    //  to wait to get exclusive access to the resource
    //

    if (Resource->NumberOfActive > 1) {

        //
        //  To wait we will decrement the fact that we have the resource for
        //  shared, and then loop waiting on the exclusive lock, and then
        //  testing to see if we can get exclusive access to the resource
        //

        Resource->NumberOfActive -= 1;

        while (TRUE) {

            //
            //  Increment the number of waiting exclusive, exit and critical
            //  section and wait on the exclusive semaphore
            //

            Resource->NumberOfWaitingExclusive += 1;

            LeaveCriticalSection(&Resource->CriticalSection);
rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = INFINITE;
        }
        ret = WaitForSingleObject(
                    Resource->ExclusiveSemaphore,
                    TimeoutTime
                    );

        if ( ret == WAIT_TIMEOUT ) {
#if DBG
            OutputDebugString( TEXT("[ConverSharedToExclusive] Sem timeout\n") );
#endif

            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
#if DBG
                DebugBreak();
#endif
                }
#if DBG
            OutputDebugString(TEXT("[ConvertSharedToExclusive]: Re-Waiting\n"));
#endif
            goto rewait;
        } else if ( ret != WAIT_OBJECT_0 ) {
#if DBG
            OutputDebugString(TEXT("[ConvertSharedToExclusive]: WaitForSingleObject Failed\n"));
#endif

            return FALSE;
        }

            //
            //  Enter the critical section
            //

            EnterCriticalSection(&Resource->CriticalSection);

            //
            //  If there are no shared users and it is not currently acquired
            //  for exclusive use then we can acquire the resource for
            //  exclusive access.  We can also acquire it if the resource
            //  indicates exclusive access but there isn't currently an owner
            //

            if ((Resource->NumberOfActive == 0)

                    ||

                ((Resource->NumberOfActive == -1) &&
                 (Resource->ExclusiveOwnerThread == NULL))) {

                //
                //  The resource is ours, so indicate that we have it and
                //  exit the critical section and return.
                //

                Resource->NumberOfActive = -1;

                Resource->ExclusiveOwnerThread = (HANDLE) ULongToPtr(GetCurrentThreadId());

                LeaveCriticalSection(&Resource->CriticalSection);

                return TRUE;
            }

            //
            //  Otherwise check to see if we already have exclusive access to
            //  the resource and can simply recusively acquire it again.
            //

            if (Resource->ExclusiveOwnerThread == (HANDLE) ULongToPtr(GetCurrentThreadId())) {

                //
                //  The resource is ours (recusively) so indicate that we have
                //  it and exit the critical section and return.
                //

                Resource->NumberOfActive -= 1;

                LeaveCriticalSection(&Resource->CriticalSection);

                return TRUE;
            }
        }

    }

    //
    //  The resource is not currently acquired for shared so this is a
    //  spurious call
    //

#if DBG
    OutputDebugString(TEXT("[ConvertSharedToExclusive]:  Failed error - SHARED_RESOURCE_CONV_ERROR\n"));
    DebugBreak();
#endif

    return FALSE;
}


BOOL
ConvertExclusiveToShared(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for exclusive access into
    one acquired for shared access.  Upon return from the procedure
    the resource is acquired for shared access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for exclusive access

Return Value:

    None

--*/

{
    LONG PreviousCount;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If there is only one shared user (it's us) and we can acquire the
    //  resource for exclusive access.
    //

    if (Resource->NumberOfActive == -1) {

        Resource->ExclusiveOwnerThread = NULL;

        //
        //  Check to see if there are waiting shared, who should now get the
        //  resource along with us
        //

        if (Resource->NumberOfWaitingShared > 0) {

            //
            //  Set the new state to indicate that all of the shared requesters
            //  have access including us, and there are no more waiting shared
            //  requesters, and then release all of the shared requsters
            //

            Resource->NumberOfActive = Resource->NumberOfWaitingShared + 1;

            Resource->NumberOfWaitingShared = 0;

            if ( !ReleaseSemaphore(
                         Resource->SharedSemaphore,
                         Resource->NumberOfActive - 1,
                         &PreviousCount
                         )) {
                return FALSE;
            }
        } else {

            //
            //  There is no one waiting for shared access so it's only ours
            //

            Resource->NumberOfActive = 1;

        }

        LeaveCriticalSection(&Resource->CriticalSection);

        return TRUE;

    }

    //
    //  The resource is not currently acquired for exclusive, or we've
    //  recursively acquired it, so this must be a spurious call
    //

#if DBG
    OutputDebugString(TEXT("[ConvertExclusiveToShared] Failed error - SHARED_RESOURCE_CONV_ERROR\n"));
    DebugBreak();
#endif

    return FALSE;
}


VOID
DeleteResource (
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) the input resource variable


Arguments:

    Resource - Supplies the resource variable being deleted

Return Value:

    None

--*/

{
    DeleteCriticalSection( &Resource->CriticalSection );
    CloseHandle(Resource->SharedSemaphore);
    CloseHandle(Resource->ExclusiveSemaphore);

    RtlZeroMemory( Resource, sizeof( *Resource ) );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\helcom.c ===
/*****************************************************************************
 *
 *  Hel.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Hardware emulation layer calls. Used to provide common functionality
 *      for built-in device types we support ( WDM, serial and parallel)
 *      While access to DCB could be built as internal COM object , it does not make
 *      much sense to invest in it, because DCBs are exclusively owned and not shared
 *      between application objects or different applications. We also want to minimize
 *      any overhead when talking to raw device interface.
 *
 *      Note1: We don't deal at this level with access control, lower level drivers are supposed
 *      to take care of this. Queuing of requests for non-reentrant devices is also not done here.
 *      This Hel is basically thin layer of imaging device primitives, used only to isolate
 *      command translator from actual hardware.
 *
 *      Note2: Hel is not made extensible . If command translator needs to talk to non-supported
 *      device, it will need to establish direct link to it. There is no requirement to use
 *      Hel , it is service we provide to conformant devices.
 *
 *  Contents:
 *
 *****************************************************************************/

/*
#include "wia.h"
#include <stilog.h>
#include <stiregi.h>

#include <sti.h>
#include <stierr.h>
#include <stiusd.h>
#include "stipriv.h"
#include "debug.h"

#define DbgFl DbgFlDevice
*/
#include "sticomm.h"
#include "validate.h"

#define DbgFl DbgFlDevice


/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CCommDeviceControl, IStiDeviceControl);

Interface_Template_Begin(CCommDeviceControl)
    Primary_Interface_Template(CCommDeviceControl, IStiDeviceControl)
Interface_Template_End(CCommDeviceControl)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CCommDeviceControl |
 *
 *          The <i CCommDeviceControl> device object
 *
 *
 *  @field  IStiDeviceControl | stidev
 *
 *  @comm
 *
 *
 *****************************************************************************/

#define IOBUFFERSIZE        255
#define WRITETOTALTIMEOUT   20

typedef struct CCommDeviceControl {

    /* Supported interfaces */
    IStiDeviceControl  devctl;

    DWORD       dwVersion;

    DWORD       dwDeviceType;
    WCHAR       wszPortName[MAX_PATH];
    DWORD       dwFlags;
    DWORD       dwMode;

    DWORD       dwContext;
    DWORD       dwLastOperationError;
    HANDLE      hDeviceHandle;

    HANDLE      hEvent;
    OVERLAPPED  Overlapped;

} CCommDeviceControl, *PCCommDeviceControl;

#define ThisClass       CCommDeviceControl
#define ThisInterface   IStiDeviceControl

#ifdef DEBUG

Default_QueryInterface(CCommDeviceControl)
Default_AddRef(CCommDeviceControl)
Default_Release(CCommDeviceControl)

#else

#define CCommDeviceControl_QueryInterface   Common_QueryInterface
#define CCommDeviceControl_AddRef           Common_AddRef
#define CCommDeviceControl_Release          Common_Release

#endif

#define CCommDeviceControl_QIHelper         Common_QIHelper

#pragma BEGIN_CONST_DATA

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CCommDeviceControl | RawReadData |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CCommDeviceControl_RawReadData(
    PSTIDEVICECONTROL   pDev,
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;
    BOOL    fRet = TRUE;
    OVERLAPPED  Overlapped;
    COMSTAT     ComStat;
    BOOL        fBlocking = FALSE;
    DWORD       dwErrorFlags;

    EnterProc(CCommDeviceControl_CommRawReadData, (_ "pppp",pDev,lpBuffer,lpdwNumberOfBytes,lpOverlapped));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCCommDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        if (SUCCEEDED(hres = hresFullValidReadPvCb(lpdwNumberOfBytes, 4, 3)) &&
            SUCCEEDED(hres = hresFullValidReadPvCb(lpBuffer,*lpdwNumberOfBytes, 2)) &&
            (!lpOverlapped || SUCCEEDED(hres = hresFullValidReadPx(lpOverlapped, OVERLAPPED, 4))) ){


            // We always call asyncronous i/o operations in order to time-out lengthy ones
            if (!lpOverlapped) {

                ZeroX(Overlapped);
                lpOverlapped = &Overlapped;
                fBlocking = TRUE;

            }
            //
            ClearCommError(this->hDeviceHandle, &dwErrorFlags, &ComStat);

            *lpdwNumberOfBytes = min(*lpdwNumberOfBytes, ComStat.cbInQue);
            if (*lpdwNumberOfBytes == 0) {
                return (STI_OK);
            }

            //
            if (fRet = ReadFile(this->hDeviceHandle, lpBuffer, *lpdwNumberOfBytes, lpdwNumberOfBytes, lpOverlapped)) {
                return (STI_OK);
            }

            if (GetLastError() != ERROR_IO_PENDING)
                return (STI_OK);

            this->dwLastOperationError = GetLastError();
            hres = fRet ? STI_OK : HRESULT_FROM_WIN32(this->dwLastOperationError);
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CCommDeviceControl | CommRawWriteData |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CCommDeviceControl_RawWriteData(
    PSTIDEVICECONTROL   pDev,
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;
    BOOL    fRet;

    EnterProc(CCommDeviceControl_CommRawWriteData, (_ "ppup",pDev,lpBuffer,dwNumberOfBytes,lpOverlapped));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCCommDeviceControl     this = _thisPv(pDev);

        // Validate parameters here

        hres = STIERR_INVALID_PARAM;

        if (SUCCEEDED(hres = hresFullValidReadPvCb(lpBuffer,dwNumberOfBytes, 2)) ) {
            if (!lpOverlapped || SUCCEEDED(hres = hresFullValidReadPx(lpOverlapped, OVERLAPPED, 4)) ){
                // Call appropriate entry point
                fRet = WriteFile(this->hDeviceHandle,
                                 lpBuffer,
                                 dwNumberOfBytes,
                                 &dwBytesReturned,
                                 lpOverlapped
                                 );
                this->dwLastOperationError = GetLastError();
                hres = fRet ? STI_OK : HRESULT_FROM_WIN32(this->dwLastOperationError);
            }
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CCommDeviceControl | RawReadControl |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CCommDeviceControl_RawReadCommand(
    PSTIDEVICECONTROL   pDev,
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;
    //BOOL    fRet;

    EnterProc(CCommDeviceControl_CommRawReadData, (_ "pppp",pDev,lpBuffer,lpdwNumberOfBytes,lpOverlapped));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCCommDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        if (SUCCEEDED(hres = hresFullValidReadPvCb(lpdwNumberOfBytes, 4, 3)) &&
            SUCCEEDED(hres = hresFullValidReadPvCb(lpBuffer,*lpdwNumberOfBytes, 2)) &&
            (!lpOverlapped || SUCCEEDED(hres = hresFullValidReadPx(lpOverlapped, OVERLAPPED, 4))) ){

            hres = STIERR_UNSUPPORTED;

        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CCommDeviceControl | CommRawWriteData |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CCommDeviceControl_RawWriteCommand(
    PSTIDEVICECONTROL   pDev,
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;
    //BOOL    fRet;

    EnterProc(CCommDeviceControl_CommRawWriteData, (_ "ppup",pDev,lpBuffer,dwNumberOfBytes,lpOverlapped));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCCommDeviceControl     this = _thisPv(pDev);

        // Validate parameters here

        hres = STIERR_INVALID_PARAM;

        if (SUCCEEDED(hres = hresFullValidReadPvCb(lpBuffer,dwNumberOfBytes, 2)) ) {
            if (!lpOverlapped || SUCCEEDED(hres = hresFullValidReadPx(lpOverlapped, OVERLAPPED, 4)) ){
                hres = STIERR_UNSUPPORTED;
            }
        }
    }

    ExitOleProc();
    return hres;
}



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CCommDeviceControl | RawReadControl |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CCommDeviceControl_GetLastError(
    PSTIDEVICECONTROL   pDev,
    LPDWORD     lpdwLastError
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;

    EnterProc(CCommDeviceControl_GetLastError, (_ "pppp",pDev,lpdwLastError));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCCommDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        if (SUCCEEDED(hres = hresFullValidReadPvCb(lpdwLastError,4, 2))) {
            *lpdwLastError = this->dwLastOperationError                 ;
            hres = STI_OK;
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CCommDeviceControl_ | GetMyDevicePortName |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CCommDeviceControl_GetMyDevicePortName(
    PSTIDEVICECONTROL   pDev,
    LPWSTR              lpszDevicePath,
    DWORD               cwDevicePathSize
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;

    EnterProc(CCommDeviceControl_GetMyDevicePortName, (_ "pp",pDev,lpszDevicePath));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCCommDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        if (SUCCEEDED(hres = hresFullValidReadPvCb(lpszDevicePath,4, 2)) &&
            SUCCEEDED(hres = hresFullValidReadPvCb(lpszDevicePath,2*cwDevicePathSize, 2)) ) {

            if (cwDevicePathSize > OSUtil_StrLenW(this->wszPortName)) {
                OSUtil_lstrcpyW(lpszDevicePath,this->wszPortName);
                hres = STI_OK;
            }
            else {
                hres = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            }
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CCommDeviceControl | GetMyDeviceHandle   |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CCommDeviceControl_GetMyDeviceHandle(
    PSTIDEVICECONTROL   pDev,
    LPHANDLE            pHandle
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;

    EnterProc(CCommDeviceControl_GetMyDeviceHandle, (_ "pp",pDev,pHandle));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCCommDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        if (SUCCEEDED(hres = hresFullValidReadPvCb(pHandle,4, 2)) ) {

            if (INVALID_HANDLE_VALUE != this->hDeviceHandle) {
                *pHandle = this->hDeviceHandle;
                hres = STI_OK;
            }
            else {
                hres = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
            }
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | GetMyDeviceOpenMode | pdwOpenMode         |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CCommDeviceControl_GetMyDeviceOpenMode(
    PSTIDEVICECONTROL   pDev,
    LPDWORD             pdwOpenMode
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;

    EnterProc(CCommDeviceControl_GetMyDeviceOpenMode, (_ "pp",pDev,pdwOpenMode));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCCommDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        if (SUCCEEDED(hres = hresFullValidReadPvCb(pdwOpenMode,4, 2)) ) {
            *pdwOpenMode = this->dwMode;
            hres = STI_OK;
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CCommDeviceControl | RawReadControl |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CCommDeviceControl_RawDeviceControl(
    PSTIDEVICECONTROL   pDev,
    USD_CONTROL_CODE EscapeFunction,
    LPVOID      lpInData,
    DWORD       cbInDataSize,
    LPVOID      pOutData,
    DWORD       dwOutDataSize,
    LPDWORD     pdwActualData
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;

    EnterProc(CCommDeviceControl_RawDeviceControl, (_ "p",pDev));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCCommDeviceControl     this = _thisPv(pDev);

        // Validate parameters here
        hres = STIERR_UNSUPPORTED;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CCommDeviceControl | WriteToErrorLog |
 *
 *  @parm    |  |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CCommDeviceControl_WriteToErrorLog(
    PSTIDEVICECONTROL   pDev,
    DWORD   dwMessageType,
    LPCWSTR pszMessage,
    DWORD   dwErrorCode
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwBytesReturned=0;

    EnterProc(CCommDeviceControl_WriteToErrorLog, (_ "p",pDev));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCCommDeviceControl     this = _thisPv(pDev);

        //
        // Validate parameters here
        //
        if (SUCCEEDED(hres = hresFullValidReadPvCb(pszMessage,2, 3))) {

#ifdef UNICODE
            ReportStiLogMessage(g_hStiFileLog,
                                dwMessageType,
                                pszMessage
                                );
#else
            LPTSTR   lpszAnsi = NULL;

            if ( SUCCEEDED(OSUtil_GetAnsiString(&lpszAnsi,pszMessage))) {
                ReportStiLogMessage(g_hStiFileLog,
                                    dwMessageType,
                                    lpszAnsi
                                    );
                FreePpv(&lpszAnsi);
            }
#endif
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @mfunc  HRESULT | CCommDeviceControl | Initialize |
 *
 *          Initialize a DeviceControl object.
 *
 *  @cwrap  PSTIDEVICECONTROL | pDev
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The device had already been initialized with
 *          the instance GUID passed in <p lpGUID>.
 *
 *
 *****************************************************************************/

STDMETHODIMP
CCommDeviceControl_Initialize(
    PSTIDEVICECONTROL   pDev,
    DWORD               dwDeviceType,
    DWORD               dwDeviceMode,
    LPCWSTR             pwszPortName,
    DWORD               dwFlags
    )
{
    HRESULT hres = STI_OK;
    BOOL    fRet = TRUE;

    WCHAR   wszDeviceSymbolicName[MAX_PATH] = {L'\0'};
    COMMTIMEOUTS    timoutInfo;
    //DWORD           dwError;


    //LPSTR   pszAnsiDeviceName;

    EnterProcR(CCommDeviceControl::Initialize,(_ "pp", pDev, pwszPortName));

    if (SUCCEEDED(hres = hresPvI(pDev, ThisInterface))) {

        PCCommDeviceControl     this = _thisPv(pDev);

        this->dwDeviceType = dwDeviceType;
        OSUtil_lstrcpyW(this->wszPortName,pwszPortName);

        this->dwMode = dwDeviceMode;

        if (dwFlags & STI_HEL_OPEN_DATA) {

            this->hDeviceHandle = OSUtil_CreateFileW(wszDeviceSymbolicName,
                                              GENERIC_READ | GENERIC_WRITE, // Access mask
                                              0,                            // Share mode
                                              NULL,                         // SA
                                              OPEN_EXISTING,                // Create disposition
                                              FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_OVERLAPPED, // overlapped I/O
                                             NULL  /* hTemplate must be NULL for comm devices */
                                              );
            this->dwLastOperationError = GetLastError();

            hres = (this->hDeviceHandle != INVALID_HANDLE_VALUE) ?
                        S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,this->dwLastOperationError);

            // wake up read thread will a byte arrives
            SetCommMask(this->hDeviceHandle, EV_RXCHAR);

            // setup read/write buffer for I/O
            SetupComm(this->hDeviceHandle, IOBUFFERSIZE, IOBUFFERSIZE);

            // set time outs
            timoutInfo.ReadIntervalTimeout = MAXDWORD;
            timoutInfo.ReadTotalTimeoutMultiplier = 0;
            timoutInfo.ReadTotalTimeoutConstant = 0;
            timoutInfo.WriteTotalTimeoutMultiplier = 0;
            timoutInfo.WriteTotalTimeoutConstant = WRITETOTALTIMEOUT;

            if (!SetCommTimeouts(this->hDeviceHandle, &timoutInfo)) {
                fRet = FALSE;
            }
            else {

                // create I/O event used for overlapped i/o
                ZeroX(this->Overlapped);
                this->hEvent = CreateEvent( NULL,   // no security
                                              TRUE, // explicit reset req
                                              FALSE,    // initial event reset
                                              NULL );   // no name
                if (this->hEvent == NULL) {
                    fRet = FALSE;
                }

                EscapeCommFunction(this->hDeviceHandle, SETDTR);
            }

            //  Error code
            this->dwLastOperationError = GetLastError();
            hres = fRet ? STI_OK : HRESULT_FROM_WIN32(this->dwLastOperationError);

        }
    }

    ExitOleProc();
    return hres;
}

#if 0
/*
 * SetupConnection
 *
 * Configure serial port with specified settings.
 */

static BOOL SetupConnection(HANDLE hCom, LPDPCOMPORTADDRESS portSettings)
{
    DCB     dcb;

    dcb.DCBlength = sizeof(DCB);
    if (!GetCommState(hCom, &dcb))
        return (FALSE);

    // setup various port settings

    dcb.fBinary = TRUE;
    dcb.BaudRate = portSettings->dwBaudRate;
    dcb.ByteSize = 8;
    dcb.StopBits = (BYTE) portSettings->dwStopBits;

    dcb.Parity = (BYTE) portSettings->dwParity;
    if (portSettings->dwParity == NOPARITY)
        dcb.fParity = FALSE;
    else
        dcb.fParity = TRUE;

    // setup hardware flow control

    if ((portSettings->dwFlowControl == DPCPA_DTRFLOW) ||
        (portSettings->dwFlowControl == DPCPA_RTSDTRFLOW))
    {
        dcb.fOutxDsrFlow = TRUE;
        dcb.fDtrControl = DTR_CONTROL_HANDSHAKE;
    }
    else
    {
        dcb.fOutxDsrFlow = FALSE;
        dcb.fDtrControl = DTR_CONTROL_ENABLE;
    }

    if ((portSettings->dwFlowControl == DPCPA_RTSFLOW) ||
        (portSettings->dwFlowControl == DPCPA_RTSDTRFLOW))
    {
        dcb.fOutxCtsFlow = TRUE;
        dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
    }
    else
    {
        dcb.fOutxCtsFlow = FALSE;
        dcb.fRtsControl = RTS_CONTROL_ENABLE;
    }

    // setup software flow control

    if (portSettings->dwFlowControl == DPCPA_XONXOFFFLOW)
    {
        dcb.fInX = TRUE;
        dcb.fOutX = TRUE;
    }
    else
    {
        dcb.fInX = FALSE;
        dcb.fOutX = FALSE;
    }

    dcb.XonChar = ASCII_XON;
    dcb.XoffChar = ASCII_XOFF;
    dcb.XonLim = 100;
    dcb.XoffLim = 100;

    if (!SetCommState( hCom, &dcb ))
       return (FALSE);

    return (TRUE);
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  void | CCommDeviceControl | Init |
 *
 *          Initialize the internal parts of the StiDevice object.
 *
 *****************************************************************************/

void INLINE
CCommDeviceControl_Init(
    PCCommDeviceControl this
    )
{

    // Initialize instance variables
    this->dwContext = 0L;
    this->dwLastOperationError = NO_ERROR;
    this->hDeviceHandle = INVALID_HANDLE_VALUE;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CCommDeviceControl_Finalize |
 *
 *          Releases the resources of a communication port and closed the device
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CCommDeviceControl_Finalize(PV pvObj)
{
    HRESULT hres = STI_OK;

    PCCommDeviceControl     this  = pvObj;

    //
    SetCommMask(this->hDeviceHandle, 0 );

    //
    EscapeCommFunction(this->hDeviceHandle, CLRDTR );

    // purge any outstanding reads/writes and close device handle
    PurgeComm(this->hDeviceHandle, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR );

    // Close device handles
    if (IsValidHANDLE(this->hDeviceHandle)) {
        CloseHandle(this->hDeviceHandle);
    }

    this->dwContext = 0L;
    this->dwLastOperationError = NO_ERROR;
    this->hDeviceHandle = INVALID_HANDLE_VALUE;
    //this->hDeviceControlHandle = INVALID_HANDLE_VALUE;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | CCommDeviceControl | New |
 *
 *          Create a new  IDeviceControl object, uninitialized.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          Output pointer for new object.
 *
 *****************************************************************************/

STDMETHODIMP
CCommDeviceControl_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(CCommDeviceControl::<constructor>, (_ "Gp", riid, punkOuter));

    hres = Common_NewRiid(CCommDeviceControl, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        PCCommDeviceControl this = _thisPv(*ppvObj);
        CCommDeviceControl_Init(this);
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CCommDeviceControl_Signature        (DWORD)'Comm'

Primary_Interface_Begin(CCommDeviceControl, IStiDeviceControl)
    CCommDeviceControl_Initialize,
    CCommDeviceControl_RawReadData,
    CCommDeviceControl_RawWriteData,
    CCommDeviceControl_RawReadCommand,
    CCommDeviceControl_RawWriteCommand,
    CCommDeviceControl_RawDeviceControl,
    CCommDeviceControl_GetLastError,
    CCommDeviceControl_GetMyDevicePortName,
    CCommDeviceControl_GetMyDeviceHandle,
    CCommDeviceControl_GetMyDeviceOpenMode,
    CCommDeviceControl_WriteToErrorLog,
Primary_Interface_End(CCommDeviceControl, IStiDeviceControl)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\olesupp.c ===
/*****************************************************************************
 *
 *  olesupp.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Implementation of CreateInstance for free-threaded components
 *      which allows us to not load OLE32.
 *
 *  Contents:
 *
 *      MyCoCreateInstance
 *
 *****************************************************************************/

/*
#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <regstr.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <stdio.h>
#include <stilog.h>
#include <stiregi.h>

#include <sti.h>
#include <stierr.h>
#include <stiusd.h>
#include "stipriv.h"
#include "stiapi.h"
#include "stirc.h"
#include "debug.h"


*/

#include "sticomm.h"
#include "coredbg.h"

#define DbgFl DbgFlSti

BOOL
ParseGUID(
    LPGUID  pguid,
    LPCTSTR ptsz
    );
BOOL
ParseGUIDA(
    LPGUID  pguid,
    LPCSTR  psz
);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | MyCoCreateInstance |
 *
 *          Private version of CoCreateInstance that doesn't use OLE32.
 *
 *  @parm   LPTSTR | ptszClsid |
 *
 *
 *  @parm   LPUNKNOWN | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   RIID | riid |
 *
 *          Interface ID
 *
 *  @parm   PPV | ppvOut |
 *
 *          Receives a pointer to the created object if successful.
 *
 *  @parm   HINSTANCE * | phinst |
 *
 *          As we don't have an infrastructure to unload objects , it becomes
 *          responsibility of the user to unload DLL when done with it.
 *
 *  @returns
 *
 *          OLE status code.
 *
 *****************************************************************************/

STDMETHODIMP
MyCoCreateInstanceW(
    LPWSTR      pwszClsid,
    LPUNKNOWN   punkOuter,
    RIID        riid,
    PPV         ppvOut,
    HINSTANCE   *phinst
    )
{
    HRESULT     hres;
    CLSID       clsid;
    HINSTANCE   hinst;

    EnterProcI(MyCoCreateInstanceW, (_ "spG", pwszClsid, punkOuter, riid));

#ifdef UNICODE

    *ppvOut = 0;
    *phinst = 0;

    if (SUCCEEDED(CLSIDFromString(pwszClsid, &clsid))) {

        HKEY    hk;
        LONG    lRet;
        WCHAR   wszKey[ctchGuid + 40];

        //
        //  Look up the CLSID in HKEY_CLASSES_ROOT.
        //
        swprintf(wszKey, L"CLSID\\%s\\InProcServer32", pwszClsid);

        lRet = RegOpenKeyExW(HKEY_CLASSES_ROOT, wszKey, 0, KEY_QUERY_VALUE, &hk);
        if (lRet == ERROR_SUCCESS) {
            WCHAR wszDll[MAX_PATH];
            DWORD cb;

            cb = cbX(wszDll);
            lRet = RegQueryValueW(hk, 0, wszDll, &cb);

            if (lRet == ERROR_SUCCESS) {

                WCHAR   wszModel[40];
                DWORD   dwType;
                DWORD   cbBuffer = sizeof(wszModel);

                lRet = RegQueryValueExW( hk,
                                        L"ThreadingModel",
                                        NULL,
                                        &dwType,
                                        (PBYTE)wszModel,
                                        &cbBuffer );

                if (NOERROR ==lRet &&
                    (lstrcmpiW(wszModel, L"Both") ||
                     lstrcmpiW(wszModel, L"Free"))) {

                    hinst = LoadLibrary(wszDll);
                    if (hinst) {
                        LPFNGETCLASSOBJECT DllGetClassObject;

                        DllGetClassObject = (LPFNGETCLASSOBJECT)
                                            GetProcAddress(hinst, "DllGetClassObject");

                        if (DllGetClassObject) {
                            IClassFactory *pcf;

                            hres = DllGetClassObject(&clsid, &IID_IClassFactory, &pcf);
                            if (SUCCEEDED(hres)) {
                                hres = pcf->lpVtbl->CreateInstance(pcf, punkOuter, riid, ppvOut);
                                pcf->lpVtbl->Release(pcf);

                                /*
                                 *  People forget to adhere to
                                 *  the OLE spec, which requires that *ppvOut be
                                 *  set to zero on failure.
                                 */
                                if (FAILED(hres)) {
                                    *ppvOut = 0;
                                }
                            }
                        } else {
                            /*
                             *  DLL does not export GetClassObject.
                             */
                            DBG_TRC(("MyCoCreateInstanceW, DLL does not export GetClassObject"));
                            hres = REGDB_E_CLASSNOTREG;
                        }

                        if (SUCCEEDED(hres)) {
                            *phinst = hinst;
                        } else {
                            FreeLibrary(hinst);
                        }
                    } else {
                        /*
                         *  DLL does not exist.
                         */
                        DBG_TRC(("MyCoCreateInstanceW, DLL does not exist"));
                        hres = REGDB_E_CLASSNOTREG;
                    }

                } else {
                    /*
                     *  No threading model or bad threading model.
                     */
                    DBG_TRC(("MyCoCreateInstanceW, No threading model or bad threading model"));
                    hres = REGDB_E_CLASSNOTREG;
                }
            } else {
                /*
                 *  No InprocServer32.
                 */
                DBG_TRC(("MyCoCreateInstanceW, No InprocServer32"));
                hres = REGDB_E_CLASSNOTREG;
            }

            RegCloseKey(hk);

        } else {
            /*
             *  CLSID not registered.
             */
            DBG_WRN(("MyCoCreateInstanceW, CLSID not registered"));
            hres = REGDB_E_CLASSNOTREG;
        }
    } else {
        /*
         *  Invalid CLSID string.
         */
        DBG_WRN(("MyCoCreateInstanceW, Invalid CLSID string"));
        hres = REGDB_E_CLASSNOTREG;
    }


#else

        hres = E_FAIL;

#endif // UNICODE

    ExitOleProcPpv(ppvOut);
    return hres;
}

STDMETHODIMP
MyCoCreateInstanceA(
    LPSTR       pszClsid,
    LPUNKNOWN   punkOuter,
    RIID        riid,
    PPV         ppvOut,
    HINSTANCE   *phinst
    )
{
    HRESULT     hres;
    CLSID       clsid;
    HINSTANCE   hinst;

    EnterProcI(MyCoCreateInstanceA, (_ "spG", TEXT("ANSI ClassId not converted to UNICODE"), punkOuter, riid));

    *ppvOut = 0;
    *phinst = 0;

    if (ParseGUIDA(&clsid, pszClsid)) {

        HKEY hk;
        LONG lRet;
        CHAR szKey[ctchGuid + 40];

        //
        //  Look up the CLSID in HKEY_CLASSES_ROOT.
        //
        sprintf(szKey, "CLSID\\%s\\InProcServer32", pszClsid);

        lRet = RegOpenKeyExA(HKEY_CLASSES_ROOT, szKey, 0,
                           KEY_QUERY_VALUE, &hk);
        if (lRet == ERROR_SUCCESS) {
            CHAR  szDll[MAX_PATH];
            DWORD cb;

            cb = cbX(szDll);
            lRet = RegQueryValueA(hk, 0, szDll, &cb);

            if (lRet == ERROR_SUCCESS) {

                CHAR    szModel[40];
                DWORD   dwType;
                DWORD   cbBuffer = sizeof(szModel);

                lRet = RegQueryValueExA( hk,
                                       "ThreadingModel",
                                       NULL,
                                       &dwType,
                                       szModel,
                                       &cbBuffer );

                if (NOERROR ==lRet &&
                    (lstrcmpiA(szModel, "Both") ||
                     lstrcmpiA(szModel, "Free"))) {

                    hinst = LoadLibraryA(szDll);
                    if (hinst) {
                        LPFNGETCLASSOBJECT DllGetClassObject;

                        DllGetClassObject = (LPFNGETCLASSOBJECT)
                                            GetProcAddress(hinst, "DllGetClassObject");

                        if (DllGetClassObject) {
                            IClassFactory *pcf;

                            hres = DllGetClassObject(&clsid, &IID_IClassFactory, &pcf);
                            if (SUCCEEDED(hres)) {
                                hres = pcf->lpVtbl->CreateInstance(pcf, punkOuter,
                                                                   riid, ppvOut);
                                pcf->lpVtbl->Release(pcf);

                                /*
                                 *  People forget to adhere to
                                 *  the OLE spec, which requires that *ppvOut be
                                 *  set to zero on failure.
                                 */
                                if (FAILED(hres)) {
                                    *ppvOut = 0;
                                }

                            }
                        } else {
                            /*
                             *  DLL does not export GetClassObject.
                             */
                            hres = REGDB_E_CLASSNOTREG;
                        }

                        if (SUCCEEDED(hres)) {
                            *phinst = hinst;
                        } else {
                            FreeLibrary(hinst);
                        }
                    } else {
                        /*
                         *  DLL does not exist.
                         */
                        hres = REGDB_E_CLASSNOTREG;
                    }

                } else {
                    /*
                     *  No threading model or bad threading model.
                     */
                    hres = REGDB_E_CLASSNOTREG;
                }
            } else {
                /*
                 *  No InprocServer32.
                 */
                hres = REGDB_E_CLASSNOTREG;
            }

            RegCloseKey(hk);

        } else {
            /*
             *  CLSID not registered.
             */
            hres = REGDB_E_CLASSNOTREG;
        }
    } else {
        /*
         *  Invalid CLSID string.
         */
        hres = REGDB_E_CLASSNOTREG;
    }

    ExitOleProcPpv(ppvOut);
    return hres;
}

#define ctchGuid    (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

LPCTSTR
_ParseHex(
    LPCTSTR ptsz,
    LPBYTE  *ppb,
    int     cb,
    TCHAR tchDelim
)
{
    if (ptsz) {
        int i = cb * 2;
        DWORD dwParse = 0;

        do {
            DWORD uch;
            uch = (TBYTE)*ptsz - TEXT('0');
            if (uch < 10) {             /* a decimal digit */
            } else {
                uch = (*ptsz | 0x20) - TEXT('a');
                if (uch < 6) {          /* a hex digit */
                    uch += 10;
                } else {
                    return 0;           /* Parse error */
                }
            }
            dwParse = (dwParse << 4) + uch;
            ptsz++;
        } while (--i);

        if (tchDelim && *ptsz++ != tchDelim) return 0; /* Parse error */

        for (i = 0; i < cb; i++) {
            (*ppb)[i] = ((LPBYTE)&dwParse)[i];
        }
        *ppb += cb;
    }
    return ptsz;

} // _ParseHex

LPCSTR
_ParseHexA(
    LPCSTR  psz,
    LPBYTE  *ppb,
    int     cb,
    CHAR    chDelim
)
{
    if (psz) {
        int i = cb * 2;
        DWORD dwParse = 0;

        do {
            DWORD uch;
            uch = (BYTE)*psz - '0';
            if (uch < 10) {             /* a decimal digit */
            } else {
                uch = (*psz | 0x20) - 'a';
                if (uch < 6) {          /* a hex digit */
                    uch += 10;
                } else {
                    return 0;           /* Parse error */
                }
            }
            dwParse = (dwParse << 4) + uch;
            psz++;
        } while (--i);

        if (chDelim && *psz++ != chDelim) return 0; /* Parse error */

        for (i = 0; i < cb; i++) {
            (*ppb)[i] = ((LPBYTE)&dwParse)[i];
        }
        *ppb += cb;
    }
    return psz;

} // _ParseHexA

BOOL
ParseGUID(
    LPGUID  pguid,
    LPCTSTR ptsz
)
{
    if (lstrlen(ptsz) == ctchGuid - 1 && *ptsz == TEXT('{')) {
        ptsz++;
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 4, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 2, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 2, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1, TEXT('}'));
        return (ptsz == NULL) ? FALSE : TRUE ;
    } else {
        return 0;
    }

} // ParseGUID

BOOL
ParseGUIDA(
    LPGUID  pguid,
    LPCSTR  psz
)
{
    if (lstrlenA(psz) == ctchGuid - 1 && *psz == '{') {
        psz++;
        psz = _ParseHexA(psz, (LPBYTE *)&pguid, 4, '-');
        psz = _ParseHexA(psz, (LPBYTE *)&pguid, 2, '-');
        psz = _ParseHexA(psz, (LPBYTE *)&pguid, 2, '-');
        psz = _ParseHexA(psz, (LPBYTE *)&pguid, 1, 0  );
        psz = _ParseHexA(psz, (LPBYTE *)&pguid, 1, '-');
        psz = _ParseHexA(psz, (LPBYTE *)&pguid, 1, 0  );
        psz = _ParseHexA(psz, (LPBYTE *)&pguid, 1, 0  );
        psz = _ParseHexA(psz, (LPBYTE *)&pguid, 1, 0  );
        psz = _ParseHexA(psz, (LPBYTE *)&pguid, 1, 0  );
        psz = _ParseHexA(psz, (LPBYTE *)&pguid, 1, 0  );
        psz = _ParseHexA(psz, (LPBYTE *)&pguid, 1, '}');
        return (psz == NULL) ? FALSE : TRUE ;
    } else {
        return 0;
    }

} // ParseGUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\purecall.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    purecall.cpp

Abstract:

   This function serves to avoid linking CRT code like assert etc.
   we really don;t do anything when pure virtual function is not redefined

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/


#include "cplusinc.h"
#include "sticomm.h"

extern "C" {

#ifdef WINNT
int __cdecl  _purecall(void)
{
#ifdef DEBUG
    DebugBreak();
#endif

    return(FALSE);
}
#endif

int __cdecl atexit(void (__cdecl *)(void))
{
    return 0;
}

};

#if 0
//
// Overloaded allocation operators
//

inline void  * __cdecl operator new(unsigned int size)
{
    return (void *)LocalAlloc(LPTR,size);
}
inline void  __cdecl operator delete(void *ptr)
{
    LocalFree(ptr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\osutil.c ===
/*****************************************************************************
 *
 *  OsUtil.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *      Various OS dependent utility functions
 *
 *  Contents:
 *
 *  History:
 *
 *      vlads   11/05/1996  created
 *****************************************************************************/
/*
#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <regstr.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <stdio.h>

#include <stilog.h>
#include <stiregi.h>

#include <sti.h>
#include <stierr.h>
#include <stiusd.h>
#include "wia.h"
#include "stipriv.h"
#include "stiapi.h"
#include "stirc.h"
#include "debug.h"

*/
#include "sticomm.h"

#define DbgFl DbgFlUtil


BOOL WINAPI
OSUtil_IsPlatformUnicode()
{
    OSVERSIONINFOA  ver;
    BOOL            bReturn = FALSE;

    ZeroX(ver);
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    // Just always call the ANSI function
    if(!GetVersionExA(&ver)) {
        DebugOutPtszV(DbgFl, TEXT("Unable to determinte platform -- setting flag to ANSI"));
        bReturn = FALSE;
    }
    else {
        switch(ver.dwPlatformId) {

            case VER_PLATFORM_WIN32_WINDOWS:
                bReturn = FALSE;
                break;

            case VER_PLATFORM_WIN32_NT:
                bReturn = TRUE;
                break;

            default:
                bReturn = FALSE;
                break;
        }
    }

    // Keep the compiler happy
    return bReturn;

}  //  endproc OSUtil_IsUnicodePlatform

HRESULT WINAPI
OSUtil_GetAnsiString(
    LPSTR *     ppszAnsi,
    LPCWSTR     lpszWide
    )
{
    HRESULT hres;
    int     cbStrLen;

    if (!lpszWide) {
        *ppszAnsi = NULL;
        return S_OK;
    }

    // We can use WideToChar to figure out exact resultant width
    cbStrLen = 2*(OSUtil_StrLenW(lpszWide)+1);

    hres = AllocCbPpv(cbStrLen, ppszAnsi);

    if (!*ppszAnsi) {
        DebugOutPtszV(DbgFl, TEXT("could not get ansi string -- out of memory"));
        return E_OUTOFMEMORY;
    }

    UToA(*ppszAnsi,cbStrLen,lpszWide);

    return S_OK;

} // OSUtil_GetAnsiString

HRESULT WINAPI
OSUtil_GetWideString(
    LPWSTR     *ppszWide,
    LPCSTR       pszAnsi
    )
{
    HRESULT hres;
    int     cbStrLen;

    if (!pszAnsi) {
        *ppszWide = NULL;
        return S_OK;
    }

    // We can use WideToChar to figure out exact resultant width
    cbStrLen = 2*(lstrlenA(pszAnsi)+1);

    hres = AllocCbPpv(cbStrLen, (PPV)ppszWide);

    if (!*ppszWide) {
        DebugOutPtszV(DbgFl,TEXT("Could not get unicode string -- out of memory"));
        return E_OUTOFMEMORY;
    }

    AToU(*ppszWide,cbStrLen,pszAnsi);

    return S_OK;

} // OSUtil_GetWideString


HINSTANCE
OSUtil_LoadLibraryW(
    LPCWSTR lpszWFileName
    )
{

    HINSTANCE   hinstRet = NULL;
    if (g_NoUnicodePlatform) {

        CHAR *pFileNameA = NULL;

        if ( SUCCEEDED(OSUtil_GetAnsiString(&pFileNameA,lpszWFileName))) {
            hinstRet = LoadLibraryA(pFileNameA);
            FreePpv(&pFileNameA);
        }
        else {
            DebugOutPtszV(DbgFl,TEXT("Failed in LoadLibraryW"));
        }
    }
    else {
        hinstRet =  LoadLibraryW(lpszWFileName);
    }

    return hinstRet;

} // OSUtil_LoadLibrary


/*
// There seems to be no getproc addressW
FARPROC
WINAPI
OSUtil_GetProcAddress(HMODULE  hModule,LPCTSTR lpProcName)
{
#ifndef UNICODE

    return GetProcAddress(hModule,lpProcNameW);

#else

    FARPROC pProcAddr = NULL;
    CHAR    *pProcNameA = NULL;


    if ( SUCCEEDED(OSUtil_GetAnsiString(&pProcNameA,lpProcName))) {
        pProcAddr = GetProcAddress(hModule,pProcNameA);
        FreePpv(&pProcNameA);
    }
    else {
        DebugOutPtszV(DbgFl,TEXT("Failed in GetProcAddress "));
    }

    return pProcAddr;

#endif

} // OSUtil_GetProcAddress
*/

LONG
WINAPI
OSUtil_RegOpenKeyExW(
    HKEY    hKey,
    LPCWSTR lpszKeyStrW,
    DWORD   dwReserved,
    REGSAM  samDesired,
    PHKEY   phkResult)
{

    LONG    lRet = 0L;
    if (g_NoUnicodePlatform) {

        CHAR *lpszKeyStrA = NULL;

        if ( SUCCEEDED(OSUtil_GetAnsiString(&lpszKeyStrA,lpszKeyStrW))) {
            lRet = RegOpenKeyExA(hKey,lpszKeyStrA,dwReserved,samDesired,phkResult);
            FreePpv(&lpszKeyStrA);
        }
        else {
            DebugOutPtszV(DbgFl,TEXT("Failed in RegOpenKeyExW"));
            lRet = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        lRet = RegOpenKeyExW(hKey,lpszKeyStrW,dwReserved,samDesired,phkResult);
    }

    return (lRet);
}

LONG WINAPI
OSUtil_RegDeleteValueW(
    HKEY hKey,
    LPWSTR lpszValueNameW
    )
{
    long                    lRet = NOERROR;

    if (g_NoUnicodePlatform) {

        CHAR *lpszValueNameA = NULL;

        if ( SUCCEEDED(OSUtil_GetAnsiString(&lpszValueNameA,lpszValueNameW))) {

            lRet = RegDeleteValueA(hKey, lpszValueNameA);
            FreePpv(&lpszValueNameA);
        }
        else {
            DebugOutPtszV(DbgFl,TEXT("Failed in RegDeleteValueKeyW"));
            lRet = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        lRet = RegDeleteValueW(hKey, lpszValueNameW);
    }

    return lRet;

}

LONG
WINAPI
OSUtil_RegCreateKeyExW(
    HKEY hKey,
    LPWSTR lpszSubKeyW, DWORD dwReserved, LPWSTR lpszClassW,
    DWORD dwOptions,
    REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    LPSTR                   lpszSubKeyA = NULL;
    LPSTR                   lpszClassA = NULL;
    long                    lRet = NOERROR;


    if (g_NoUnicodePlatform) {

        if ( SUCCEEDED(OSUtil_GetAnsiString(&lpszClassA,lpszClassW)) &&
             SUCCEEDED(OSUtil_GetAnsiString(&lpszSubKeyA,lpszSubKeyW))) {

            lRet = RegCreateKeyExA(hKey, lpszSubKeyA, dwReserved, lpszClassA, dwOptions,
                samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

            FreePpv(&lpszSubKeyA);
            FreePpv(&lpszClassA);

        }
        else {
            DebugOutPtszV(DbgFl,TEXT("Failed in RegCreateKeyExW"));
            lRet = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        lRet = RegCreateKeyExW(hKey, lpszSubKeyW, dwReserved, lpszClassW, dwOptions,
            samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
    }

    return lRet;

}


LONG WINAPI
OSUtil_RegQueryValueExW(
    HKEY    hKey,
    LPCWSTR lpszValueNameW,
    DWORD   *pdwType,
    BYTE*   lpData,
    DWORD   *pcbData,
    BOOL    fUnicodeCaller              // =FALSE
    )
{
    long    lRet = NOERROR;
    DWORD   cbDataGiven = *pcbData ;

    if (g_NoUnicodePlatform || !fUnicodeCaller) {

        CHAR *lpszValueNameA = NULL;

        if ( SUCCEEDED(OSUtil_GetAnsiString(&lpszValueNameA,lpszValueNameW))) {

            lRet = RegQueryValueExA( hKey,
                                   lpszValueNameA,
                                   NULL,
                                   pdwType,
                                   lpData,
                                   pcbData );

            FreePpv(&lpszValueNameA);

            #if 1
            //
            // The string came back as ANSI but we need UNICODE. Conversion in place
            // is not allowed, so do it with second buffer
            //

            if ( fUnicodeCaller && (NOERROR == lRet) && (*pdwType == REG_SZ)) {

                LPWSTR  pwszWideData  = NULL;
                DWORD   dwNewSize = *pcbData * sizeof(WCHAR);
                HRESULT hres;

                if (cbDataGiven >= dwNewSize ) {

                    hres = OSUtil_GetWideString(&pwszWideData,lpData);
                    if (SUCCEEDED(hres) && pwszWideData) {

                        memcpy(lpData,pwszWideData,dwNewSize);
                        FreePpv(&pwszWideData);

                    }
                    else {
                        lRet = GetLastError();
                    }
                }

                else {
                    lRet = ERROR_MORE_DATA;
                }

                *pcbData *= sizeof(WCHAR);
            }

            #endif
        }
        else {
            DebugOutPtszV(DbgFl,TEXT("Failed in RegDeleteValueKeyW"));
            lRet = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        lRet = RegQueryValueExW( hKey,
                               lpszValueNameW,
                               NULL,
                               pdwType,
                               lpData,
                               pcbData );

    }

    return lRet;
}

LONG WINAPI
OSUtil_RegSetValueExW(
    HKEY    hKey,
    LPCWSTR lpszValueNameW,
    DWORD   dwType,
    BYTE*   lpData,
    DWORD   cbData,
    BOOL    fUnicodeCaller              // =FALSE
    )
{
    long                    lRet = NOERROR;

    if (g_NoUnicodePlatform || !fUnicodeCaller) {

        CHAR *lpszValueNameA = NULL;

        if ( SUCCEEDED(OSUtil_GetAnsiString(&lpszValueNameA,lpszValueNameW))) {

            lRet = RegSetValueExA(hKey,
                                  lpszValueNameA,
                                  0,
                                  dwType,
                                  lpData,
                                  cbData);

            FreePpv(&lpszValueNameA);
        }
        else {
            DebugOutPtszV(DbgFl,TEXT("Failed in RegDeleteValueKeyW"));
            lRet = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        lRet = RegSetValueExW( hKey,
                               (LPVOID)lpszValueNameW,
                               0,
                               dwType,
                               lpData,
                               cbData);
    }

    return lRet;
}


DWORD ReadRegistryDwordW( HKEY   hkey,
                         LPCWSTR pszValueNameW,
                         DWORD   dwDefaultValue )
{
    DWORD  err = NOERROR;
    DWORD  dwBuffer = 0;
    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL ) {

        if (g_NoUnicodePlatform) {

            CHAR    *pszValueNameA = NULL;

            dwType = REG_DWORD;

            if ( SUCCEEDED(OSUtil_GetAnsiString(&pszValueNameA,pszValueNameW))) {

                err = RegQueryValueExA( hkey,
                                       pszValueNameA,
                                       NULL,
                                       &dwType,
                                       (LPBYTE)&dwBuffer,
                                       &cbBuffer );

                FreePpv(&pszValueNameA);
            }
            else {
                DebugOutPtszV(DbgFl,TEXT("Failed in ReadRegistryDwordW "));
                err = ERROR_INVALID_PARAMETER;
            }
        } else {

            err = RegQueryValueExW( hkey,
                                   pszValueNameW,
                                   NULL,
                                   &dwType,
                                   (LPBYTE)&dwBuffer,
                                   &cbBuffer );

        }

        if( ( err == NO_ERROR ) &&
            ( ( dwType == REG_DWORD ) || ( dwType == REG_BINARY ) )
            ) {
            dwDefaultValue = dwBuffer;
        }
    }

    return dwDefaultValue;

}   // ReadRegistryDwordW()



DWORD
WriteRegistryDwordW(
    IN HKEY      hkey,
    IN LPCWSTR   pszValueNameW,
    IN DWORD     dwValue)
{
    DWORD err = NOERROR;

    if ( hkey == NULL || pszValueNameW == NULL) {

        err = ( ERROR_INVALID_PARAMETER);

    } else {

        if (g_NoUnicodePlatform) {

            CHAR    *pszValueNameA = NULL;

            if ( SUCCEEDED(OSUtil_GetAnsiString(&pszValueNameA,pszValueNameW))) {

                err = RegSetValueExA( hkey,pszValueNameA,0,REG_DWORD,(LPBYTE ) &dwValue,sizeof( dwValue));

                FreePpv(&pszValueNameA);
            }
            else {
                DebugOutPtszV(DbgFl,TEXT("Failed in ReadRegistryDwordW "));
                err = ERROR_INVALID_PARAMETER;
            }

        }
        else {
            err = RegSetValueExW( hkey,(LPVOID)pszValueNameW,0,REG_DWORD,(LPBYTE ) &dwValue,sizeof( dwValue));
        }
    }

    return ( err);
} // WriteRegistryDwordW()



DWORD
WriteRegistryStringA(
    IN HKEY hkey,
    IN LPCSTR  pszValueName,
    IN LPCSTR  pszValue,
    IN DWORD   cbValue,
    IN DWORD   fdwType)
{
    DWORD err = NOERROR;

    if ( hkey == NULL ||
         pszValueName == NULL ||
         cbValue == 0 ) {

        err = ERROR_INVALID_PARAMETER;
    } else {

        err = RegSetValueExA(
                    hkey,
                    pszValueName,
                    0,
                    fdwType,
                    (LPBYTE ) pszValue,
                    cbValue);      // + 1 for null character
    }

    return ( err);
} // WriteRegistryStringA()


DWORD
WriteRegistryStringW(
    IN HKEY     hkey,
    IN LPCWSTR  pszValueNameW,
    IN LPCWSTR  pszValueW,
    IN DWORD    cbValue,
    IN DWORD    fdwType)
{
    DWORD   err = NOERROR;
    DWORD   le;

    if ( hkey == NULL ||
         pszValueNameW == NULL ||
         cbValue == 0 ) {

        err = ERROR_INVALID_PARAMETER;
    } else {

        if (g_NoUnicodePlatform) {
            err = ERROR_INVALID_PARAMETER;

            if ( (fdwType == REG_SZ) || (fdwType == REG_EXPAND_SZ)) {

                LPSTR   lpszAnsi = NULL;
                LPSTR   lpszAnsiName = NULL;

                if ( SUCCEEDED(OSUtil_GetAnsiString(&lpszAnsi,pszValueW)) &&
                     SUCCEEDED(OSUtil_GetAnsiString(&lpszAnsiName,pszValueNameW))
                    ) {

                    err = WriteRegistryStringA(hkey,
                                         lpszAnsiName,
                                         lpszAnsi,
                                         (lstrlenA(lpszAnsi)+1)*sizeof(CHAR),
                                         fdwType);

                }

                FreePpv(&lpszAnsi);
                FreePpv(&lpszAnsiName);
            }
            else {
                ValidateF(FALSE,("Wrong registry value type in WriteRegistryStringW"));
                err = ERROR_INVALID_PARAMETER;
            }
        }
        else {
            err = RegSetValueExW(
                                hkey,
                                pszValueNameW,
                                0,
                                fdwType,
                                (LPBYTE ) pszValueW,
                                cbValue);
            le = GetLastError();
        }
    }

    return ( err);
} // WriteRegistryStringW()

HRESULT
ReadRegistryStringA(
    HKEY     hkey,
    LPCWSTR  pszValueNameW,
    LPCWSTR  pszDefaultValueW,
    BOOL     fExpand,
    LPWSTR * ppwszResult
    )
{
    WCHAR   * pszBuffer1 = NULL;
    WCHAR   * pszBuffer2 = NULL;
    DWORD     cbBuffer;
    DWORD     dwType;
    DWORD     err = NOERROR;

    CHAR    *pszValueNameA = NULL;

    if (!ppwszResult) {
        return STIERR_INVALID_PARAM;
    }

    *ppwszResult = NULL;

    if ( !SUCCEEDED(OSUtil_GetAnsiString(&pszValueNameA,pszValueNameW))) {
        return STIERR_INVALID_PARAM;
    }

    //
    //  Determine the buffer size.
    //

    pszBuffer1 = NULL;
    pszBuffer2 = NULL;
    cbBuffer   = 0;

    if( hkey == NULL ) {

        //
        //  Pretend the key wasn't found.
        //

        err = ERROR_FILE_NOT_FOUND;
    }
    else {

        err = RegQueryValueExA( hkey,
                               pszValueNameA,
                               NULL,
                               &dwType,
                               NULL,
                               &cbBuffer );

        if( ( err == NO_ERROR ) || ( err == ERROR_MORE_DATA ) ) {
            if( ( dwType != REG_SZ ) &&
                ( dwType != REG_MULTI_SZ ) &&
                ( dwType != REG_EXPAND_SZ ) ) {
                //
                //  Type mismatch, registry data NOT a string.
                //  Use default.
                //

                err = ERROR_FILE_NOT_FOUND;
            }
            else {
                //
                //  Item found, allocate a buffer.
                //

                if (!SUCCEEDED(AllocCbPpv(2*cbBuffer+sizeof(WCHAR),&pszBuffer1)) ){
                    err = GetLastError();
                }
                else {
                    //
                    //  Now read the value into the buffer.
                    //

                    //if (g_NoUnicodePlatform) {

                        DWORD   dwType;
                        err = RegQueryValueExA( hkey,
                                           pszValueNameA,
                                           NULL,
                                           &dwType,
                                           (LPBYTE)pszBuffer1,
                                           &cbBuffer );

                        //
                        // The string came back as ANSI but we need UNICODE. Conversion in place
                        // is not allowed, so do it with second buffer
                        //

                        if (SUCCEEDED(AllocCbPpv(2*cbBuffer+sizeof(WCHAR),&pszBuffer2))){

                            AToU(pszBuffer2,cbBuffer,(LPSTR)pszBuffer1);
                            memcpy(pszBuffer1,pszBuffer2,2*cbBuffer+sizeof(WCHAR));

                            FreePpv(&pszBuffer2);

                            //
                            //  Truncate returned string to MAX_REG_CHAR characters
                            //  (only for REG_SZ)
                            //

                            if ((dwType == REG_SZ) && (cbBuffer >= MAX_REG_CHAR)) {
                                pszBuffer1[MAX_REG_CHAR] = L'\0';
                            }

                        }
                    //}

                }
            }
        }
    }

    FreePpv(&pszValueNameA);

    //if( err == ERROR_FILE_NOT_FOUND ) {
    if( err != NOERROR ) {

        //
        //  Item not found, use empty string (L"") as value
        //

        err = NO_ERROR;

        if( pszDefaultValueW != NULL ) {

            if (!SUCCEEDED(AllocCbPpv((OSUtil_StrLenW(L"") + 1) * sizeof(WCHAR),&pszBuffer1))) {
                err = GetLastError();
            }
            else {
                OSUtil_lstrcpyW( pszBuffer1, L"" );
            }
        }
    }

    if( err != NO_ERROR )
    {
        //
        //  Tragic error reading registry, abort now.
        //

        goto ErrorCleanup;
    }

    //
    //  pszBuffer1 holds the registry value.  Now expand
    //  the environment strings if necessary.
    //

    if( !fExpand ) {
        *ppwszResult = pszBuffer1;
        return S_OK;
    }

    #if 0

    // Does not work on Win95 ?
    //
    //  Returns number of characters
    //
    cbBuffer = ExpandEnvironmentStrings( pszBuffer1,
                                         NULL,
                                         0 );

    if (!SUCCEEDED(OSUtil_GetAnsiString(&pszBuffer2, (cbBuffer+1)*sizeof(TCHAR) ))){
        goto ErrorCleanup;
    }

    if( ExpandEnvironmentStrings( pszBuffer1,
                                  pszBuffer2,
                                  cbBuffer ) > cbBuffer ) {
        goto ErrorCleanup;
    }

    //
    //  pszBuffer2 now contains the registry value with
    //  environment strings expanded.
    //

    FreePpv(&pszBuffer1);

    return pszBuffer2;
    #endif

ErrorCleanup:

    //
    //  Something tragic happend; free any allocated buffers
    //  and return NULL to the caller, indicating failure.
    //
    FreePpv(&pszValueNameA);
    FreePpv(&pszBuffer1);
    FreePpv(&pszBuffer2);

    return HRESULT_FROM_WIN32(err);

}
HRESULT
ReadRegistryStringW(
    HKEY     hkey,
    LPCWSTR  pszValueNameW,
    LPCWSTR  pszDefaultValueW,
    BOOL     fExpand,
    LPWSTR * ppwszResult
    )
{
    WCHAR   * pszBuffer1 = NULL;
    DWORD     cbBuffer;
    DWORD     dwType;
    DWORD     err = NOERROR;

    if (!ppwszResult) {
        return STIERR_INVALID_PARAM;
    }

    *ppwszResult = NULL;

    //
    //  Determine the buffer size.
    //

    pszBuffer1 = NULL;
    cbBuffer   = 0;

    if( hkey == NULL ) {

        //
        //  Pretend the key wasn't found.
        //

        err = ERROR_FILE_NOT_FOUND;
    }
    else {

        err = RegQueryValueExW( hkey,
                               pszValueNameW,
                               NULL,
                               &dwType,
                               NULL,
                               &cbBuffer );

        if( ( err == NO_ERROR ) || ( err == ERROR_MORE_DATA ) ) {
            if( ( dwType != REG_SZ ) &&
                ( dwType != REG_MULTI_SZ ) &&
                ( dwType != REG_EXPAND_SZ ) ) {
                //
                //  Type mismatch, registry data NOT a string.
                //  Use default.
                //

                err = ERROR_FILE_NOT_FOUND;
            }
            else {
                //
                //  Item found, allocate a buffer.
                //

                if (!SUCCEEDED(AllocCbPpv(cbBuffer+sizeof(WCHAR),&pszBuffer1)) ){
                    err = GetLastError();
                }
                else {
                    //
                    //  Now read the value into the buffer.
                    //

                    DWORD   dwType;
                    err = RegQueryValueExW( hkey,
                                            pszValueNameW,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)pszBuffer1,
                                            &cbBuffer );
                }
            }
        }
    }

    if( err != NOERROR ) {

        //
        //  Item not found, use empty string (L"") as value
        //

        err = NO_ERROR;

        if( pszDefaultValueW != NULL ) {

            if (!SUCCEEDED(AllocCbPpv((OSUtil_StrLenW(L"") + 1) * sizeof(WCHAR),&pszBuffer1))) {
                err = GetLastError();
            }
            else {
                OSUtil_lstrcpyW( pszBuffer1, L"" );
            }
        }
    }

    if( err != NO_ERROR )
    {
        //
        //  Tragic error reading registry, abort now.
        //

        goto ErrorCleanup;
    }

    //
    //  pszBuffer1 holds the registry value.  Now expand
    //  the environment strings if necessary.
    //

    if( !fExpand ) {
        *ppwszResult = pszBuffer1;
        return S_OK;
    }

ErrorCleanup:

    //
    //  Something tragic happend; free any allocated buffers
    //  and return NULL to the caller, indicating failure.
    //
    FreePpv(&pszBuffer1);

    return HRESULT_FROM_WIN32(err);

}

HANDLE
WINAPI
OSUtil_CreateFileW(
    LPCWSTR     lpszFileNameW,
    DWORD       dwDesiredAccess,
    DWORD       dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD       dwCreationDisposition,
    DWORD       dwFlagsAndAttributes,
    HANDLE      hTemplateFile
    )
{

    HANDLE  hRet = INVALID_HANDLE_VALUE;

    if (g_NoUnicodePlatform) {

        CHAR *pFileNameA = NULL;

        if ( SUCCEEDED(OSUtil_GetAnsiString(&pFileNameA,lpszFileNameW))) {

            hRet = CreateFileA(pFileNameA,
                                dwDesiredAccess,dwShareMode,lpSecurityAttributes,dwCreationDisposition,
                                dwFlagsAndAttributes,hTemplateFile);
            FreePpv(&pFileNameA);
        }
        else {
            DebugOutPtszV(DbgFl,TEXT("Failed in LoadLibraryW"));
            hRet = INVALID_HANDLE_VALUE;
        }
    }
    else {
        hRet = CreateFileW(lpszFileNameW,
                            dwDesiredAccess,dwShareMode,lpSecurityAttributes,dwCreationDisposition,
                            dwFlagsAndAttributes,hTemplateFile);
    }

    return hRet;

} // OSUtil_LoadLibrary

HRESULT
WINAPI
ExtractCommandLineArgumentW(
    LPCSTR  lpszSwitchName,
    LPWSTR  pwszSwitchValue
    )
{
    HRESULT hres;

    LPSTR   lpszCommandLine;
    LPSTR   lpszSwitch;
    LPSTR   pszT;

    DWORD   cch;

    lpszCommandLine = GetCommandLineA();

    if (!lpszCommandLine || !*lpszCommandLine) {
        return STIERR_GENERIC;
    }

    if (!pwszSwitchValue) {
        return STIERR_GENERIC;
    }

    // Search for switch with given name
    lpszSwitch = strstr(lpszCommandLine,lpszSwitchName);
    if (!lpszSwitch ) {
        return STIERR_GENERIC;
    }

    lpszSwitch += lstrlenA(lpszSwitchName);
    if (*lpszSwitch != ':') {
        return STIERR_GENERIC;
    }
    lpszSwitch=CharNextA(lpszSwitch);

    // Skip till space
    pszT = lpszSwitch;
    while (*pszT && *pszT > ' ') {
        pszT = CharNextA(pszT);
    }

    cch = MultiByteToWideChar(CP_ACP, 0,
                        lpszSwitch, (INT)(pszT-lpszSwitch),
                        pwszSwitchValue,STI_MAX_INTERNAL_NAME_LENGTH
                        );
    pwszSwitchValue[cch] = L'\0';

    hres = (cch) ? STI_OK : HRESULT_FROM_WIN32(GetLastError());

    return hres;

}

HRESULT
WINAPI
ExtractCommandLineArgumentA(
    LPCSTR  lpszSwitchName,
    LPSTR   pszSwitchValue
    )
{
    HRESULT hres;

    LPSTR   lpszCommandLine;
    LPSTR   lpszSwitch;
    LPSTR   pszT;

    DWORD   cch;

    lpszCommandLine = GetCommandLineA();

    if (!lpszCommandLine || !*lpszCommandLine) {
        return STIERR_GENERIC;
    }

    if (!pszSwitchValue) {
        return STIERR_GENERIC;
    }

    // Search for switch with given name
    lpszSwitch = strstr(lpszCommandLine,lpszSwitchName);
    if (!lpszSwitch ) {
        return STIERR_GENERIC;
    }

    lpszSwitch += lstrlenA(lpszSwitchName);
    if (*lpszSwitch != ':') {
        return STIERR_GENERIC;
    }
    lpszSwitch=CharNextA(lpszSwitch);

    // Skip till space
    pszT = lpszSwitch;
    while (*pszT && *pszT > ' ') {
        pszT = CharNextA(pszT);
    }

    cch = min((INT)(pszT-lpszSwitch),STI_MAX_INTERNAL_NAME_LENGTH);
    memcpy(pszSwitchValue,lpszSwitch,cch);
    pszSwitchValue[cch] = L'\0';

    hres = (cch) ? STI_OK : STIERR_INVALID_PARAM;

    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DupEventHandle |
 *
 *          Duplicate an event handle intra-process-ly.  If the incoming
 *          handle is NULL, then so is the output handle (and the call
 *          succeeds).
 *
 *  @parm   HANDLE | h |
 *
 *          Source handle.
 *
 *  @parm   LPHANDLE | phOut |
 *
 *          Receives output handle.
 *
 *****************************************************************************/

HRESULT EXTERNAL
DupEventHandle(HANDLE h, LPHANDLE phOut)
{
    HRESULT hres;
    EnterProc(DupEventHandle, (_ "p", h));

    if (h) {
        HANDLE hProcessMe = GetCurrentProcess();
        if (DuplicateHandle(hProcessMe, h, hProcessMe, phOut,
                            EVENT_MODIFY_STATE, 0, 0)) {
            hres = S_OK;
        } else {
            hres = hresLe(GetLastError());
        }
    } else {
        *phOut = h;
        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

void
WINAPI
StiLogTrace(
    DWORD   dwMessageType,
    DWORD   idMessage,
    ...
    )
{
    va_list list;
    va_start (list, idMessage);

    if(g_hStiFileLog) {

        TCHAR    *pchBuff = NULL;        
        DWORD   cch;

        HMODULE hm;
        DWORD   dwError;

        pchBuff = NULL;

        hm = GetModuleHandleA("STI.dll") ; 
        
        cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                               FORMAT_MESSAGE_MAX_WIDTH_MASK |
                               FORMAT_MESSAGE_FROM_HMODULE,
                               hm,
                               idMessage,
                               0,
                               (LPTSTR) &pchBuff,
                               1024,
                               (va_list *)&list
                               );        

        dwError = GetLastError();

        if (cch && pchBuff) {
            ReportStiLogMessage(g_hStiFileLog,
                                dwMessageType,
                                pchBuff);
        }

        if (pchBuff) {
            LocalFree(pchBuff);
        }

    }

    va_end(list);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\passusd.c ===
/*****************************************************************************
 *
 *  Device.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *  Implementation for pass-through ( empty) user mode still image driver (USD)
 *  Insance of this object class is created for devices, which do not provide
 *  vendor-specific USD.
 *  Methods implemented in this object are only for sending/receiving escape
 *  sequences from app to device.
 *
 *  Contents:
 *
 *      CStiEmptyUSD_New
 *
 *****************************************************************************/
/*
#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <regstr.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <stdio.h>

#include <stilog.h>
#include <stiregi.h>

#include <sti.h>
#include <stierr.h>
#include <stiusd.h>
#include "wia.h"
#include "stipriv.h"
#include "stiapi.h"
#include "stirc.h"
#include "debug.h"
*/
#include "sticomm.h"


#define DbgFl DbgFlStiObj

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CStiEmptyUSD, IStiUSD);

Interface_Template_Begin(CStiEmptyUSD)
    Primary_Interface_Template(CStiEmptyUSD, IStiUSD)
Interface_Template_End(CStiEmptyUSD)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CStiEmptyUSD |
 *
 *          The <i CStiEmptyUSD> device object
 *
 *
 *  @field  IStiDevice | stidev
 *
 *  @comm
 *
 *
 *****************************************************************************/

typedef struct CStiEmptyUSD {

    /* Supported interfaces */
    IStiUSD     usd;

    DWORD       dwVersion;

    RD(LONG cCrit;)
    D(DWORD thidCrit;)
    BOOL        fCritInited;
    CRITICAL_SECTION    crst;

    PSTIDEVICECONTROL   pDcb;

} CStiEmptyUSD, *PCStiEmptyUSD;

#define ThisClass       CStiEmptyUSD
#define ThisInterface   IStiUSD

#ifdef DEBUG

Default_QueryInterface(CStiEmptyUSD)
Default_AddRef(CStiEmptyUSD)
Default_Release(CStiEmptyUSD)

#else

#define CStiEmptyUSD_QueryInterface   Common_QueryInterface
#define CStiEmptyUSD_AddRef           Common_AddRef
#define CStiEmptyUSD_Release          Common_Release

#endif

#define CStiEmptyUSD_QIHelper         Common_QIHelper

#pragma BEGIN_CONST_DATA

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CStiEmptyUSD | GetStatus |
 *
 *  @parm   PSTI_DEVICE_STATUS    | PSTI_DEVICE_STATUS pDevStatus) |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiEmptyUSD_GetStatus(
    PSTIUSD       pUsd,
    PSTI_DEVICE_STATUS pDevStatus
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;

    EnterProcR(CStiEmptyUSD::GetStatus,(_ "pp", pUsd, pDevStatus));

    if (SUCCEEDED(hres = hresPvI(pUsd, ThisInterface))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

        hres = STIERR_UNSUPPORTED;
    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CStiEmptyUSD | DeviceReset |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
CStiEmptyUSD_DeviceReset(
    PSTIUSD  pUsd
    )
{
    HRESULT hres;
    EnterProcR(CStiEmptyUSD::DeviceReset,(_ "p", pUsd));

    if (SUCCEEDED(hres = hresPvI(pUsd, ThisInterface))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

        hres = STIERR_UNSUPPORTED;
    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CStiEmptyUSD | Diagnostic |
 *
 *  @parm   LPDIAG  |   pBuffer |

 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiEmptyUSD_Diagnostic(
    PSTIUSD  pUsd,
    LPSTI_DIAG      pBuffer
    )
{
    HRESULT hres;
    EnterProcR(CStiEmptyUSD::Diagnostic,(_ "p", pUsd, pBuffer ));

    if (SUCCEEDED(hres = hresPvI(pUsd, ThisInterface))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

        hres = STI_OK;
    }

    ExitOleProc();

    return hres;

}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CStiEmptyUSD | SetNotificationEvent |
 *          Specify the event that should be set when the device
 *          state changes, or turns off such notifications.
 *
 *  @cwrap  LPSTIUSD | lpStiDevice
 *
 *  @parm   IN HANDLE | hEvent |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *          <c E_INVALIDARG>: The thing isn't an event handle.
 *
 *
 *****************************************************************************/
STDMETHODIMP
CStiEmptyUSD_SetNotificationEvent(
    PSTIUSD  pUsd,
    HANDLE      hEvent
    )
{
    HRESULT hres;
    EnterProcR(CStiEmptyUSD::SetNotificationEvent,(_ "px", pUsd, hEvent ));

    if (SUCCEEDED(hres = hresPvI(pUsd, ThisInterface))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

        hres = STIERR_UNSUPPORTED;
    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CStiEmptyUSD | GetNotificationData |
 *
 *  @parm   LPVOID* |   ppBuffer    |
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiEmptyUSD_GetNotificationData(
    PSTIUSD     pUsd,
    LPSTINOTIFY pBuffer
    )
{
    HRESULT hres;
    EnterProcR(CStiEmptyUSD::GetNotificationData,(_ "p", pUsd, pBuffer));

    if (SUCCEEDED(hres = hresPvI(pUsd, ThisInterface))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

        hres = STIERR_UNSUPPORTED;

    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CStiEmptyUSD | Escape |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiEmptyUSD_Escape(
    PSTIUSD  pUsd,
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID      lpInData,
    DWORD       cbInDataSize,
    LPVOID      lpOutData,
    DWORD       cbOutDataSize,
    LPDWORD     pcbActualData
    )
{
    HRESULT     hres;
    LPDWORD     pcbTemp = NULL;


    EnterProcR(CStiEmptyUSD::Escape,(_ "pxpxp", pUsd, EscapeFunction,lpInData,cbInDataSize,lpOutData ));

    if (SUCCEEDED(hres = hresPvI(pUsd, ThisInterface))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

        hres = S_OK;

        // Validate arguments
        if (pcbActualData && !SUCCEEDED(hresFullValidPdwOut(pcbActualData, 7))) {
            ExitOleProc();
            return STIERR_INVALID_PARAM;
        }

        // Write indata to device  if needed.
        if (EscapeFunction == StiWriteControlInfo || EscapeFunction == StiTransact) {
            hres = IStiDeviceControl_RawWriteData(this->pDcb,lpInData,cbInDataSize,NULL);
        }

        // If write was required and succeeded , read result data
        if (SUCCEEDED(hres)) {

            DWORD   dwBytesReturned = 0;

            if (EscapeFunction == StiReadControlInfo || EscapeFunction == StiTransact) {

                if (pcbActualData) {
                    *pcbActualData = cbOutDataSize;
                    pcbTemp = pcbActualData;
                }
                else {
                    dwBytesReturned = cbOutDataSize;
                    pcbTemp = &dwBytesReturned;
                }

                hres = IStiDeviceControl_RawReadData(this->pDcb,lpOutData,pcbTemp,NULL);
            }
        }

    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CStiEmptyUSD | GetLastError |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiEmptyUSD_GetLastError(
    PSTIUSD  pUsd,
    LPDWORD     pdwLastDeviceError
    )
{
    HRESULT hres = STI_OK;

    EnterProcR(CStiEmptyUSD::GetLastError,(_ "p", pUsd ));

    // Validate parameters
    if (!pdwLastDeviceError) {
        ExitOleProc();
        return STIERR_INVALID_PARAM;
    }

    if (SUCCEEDED(hres = hresPvI(pUsd, ThisInterface))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

        if (this->pDcb ) {
            hres = IStiDeviceControl_GetLastError(this->pDcb,pdwLastDeviceError);
        }
    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CStiEmptyUSD | LockDevice |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiEmptyUSD_LockDevice(
    PSTIUSD  pUsd
    )
{
    HRESULT hres;
    EnterProcR(CStiEmptyUSD::LockDevice,(_ "p", pUsd ));

    // Validate parameters

    if (SUCCEEDED(hres = hresPvI(pUsd, ThisInterface))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | CStiEmptyUSD | UnLockDevice |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/
STDMETHODIMP
CStiEmptyUSD_UnLockDevice(
    PSTIUSD  pUsd
    )
{
    HRESULT hres;
    EnterProcR(CStiEmptyUSD::UnLockDevice,(_ "p", pUsd ));

    // Validate parameters

    if (SUCCEEDED(hres = hresPvI(pUsd, ThisInterface))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiUSD | RawReadData |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
CStiEmptyUSD_RawReadData(
    PSTIUSD  pUsd,
    LPVOID      lpBuffer,
    LPDWORD     lpdwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT hres;
    EnterProcR(CStiEmptyUSD::RawReadData,(_ "p", pUsd  ));

    if (SUCCEEDED(hres = hresPvI(pUsd, ThisInterface))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

        hres = IStiDeviceControl_RawReadData(this->pDcb,lpBuffer,lpdwNumberOfBytes,lpOverlapped);
    }

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiUSD | RawWriteData |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
CStiEmptyUSD_RawWriteData(
    PSTIUSD  pUsd,
    LPVOID      lpBuffer,
    DWORD       dwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT hres;
    EnterProcR(IStiUSD::RawWriteData,(_ "p", pUsd  ));

    if (SUCCEEDED(hres = hresPvI(pUsd, ThisInterface))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

        hres = IStiDeviceControl_RawWriteData(this->pDcb,lpBuffer,dwNumberOfBytes,lpOverlapped);
    }

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiUSD | RawReadCommand |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
CStiEmptyUSD_RawReadCommand(
    PSTIUSD  pUsd,
    LPVOID      lpBuffer,
    LPDWORD     lpdwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT hres;
    EnterProcR(IStiUSD::RawReadCommand,(_ "p", pUsd  ));

    if (SUCCEEDED(hres = hresPvI(pUsd, ThisInterface))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

        hres = IStiDeviceControl_RawReadCommand(this->pDcb,lpBuffer,lpdwNumberOfBytes,lpOverlapped);

    }

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStiUSD | RawWriteCommand |
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
CStiEmptyUSD_RawWriteCommand(
    PSTIUSD  pUsd,
    LPVOID      lpBuffer,
    DWORD       dwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT hres;
    EnterProcR(IStiUSD::RawWriteCommand,(_ "p", pUsd  ));

    if (SUCCEEDED(hres = hresPvI(pUsd, ThisInterface))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

        hres = IStiDeviceControl_RawWriteCommand(this->pDcb,lpBuffer,dwNumberOfBytes,lpOverlapped);
    }

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  void | CStiEmptyUSD | Init |
 *
 *          Initialize the internal parts of the StiDevice object.
 *
 *****************************************************************************/

void INLINE
CStiEmptyUSD_Init(
    PCStiEmptyUSD this
    )
{
    // Initialize instance variables
    this->pDcb = NULL;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CStiDev_Finalize |
 *
 *          Releases the resources of a generic device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CStiEmptyUSD_Finalize(PV pvObj)
{
    HRESULT hres = STI_OK;
    PCStiEmptyUSD     this  = pvObj;

    IStiDeviceControl_Release(this->pDcb);
    this->pDcb = NULL;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | USD_Initialize |
 *
 *
 *  @parm    | |
 *
 *
 *****************************************************************************/
STDMETHODIMP
CStiEmptyUSD_Initialize(
    PSTIUSD             pUsd,
    PSTIDEVICECONTROL   pHelDcb,
    DWORD               dwStiVersion,
    HKEY                hkeyParameters
    )
{

    HRESULT     hres = STI_OK;

    EnterProcR(CStiEmptyUSD::USD_Initialize,(_ "ppx", pUsd,pHelDcb ,dwStiVersion));

    // Validate parameters
    if (!pHelDcb) {
        ExitOleProc();
        return STIERR_INVALID_PARAM;
    }

    if (SUCCEEDED(hres = hresPvI(pUsd, IStiUSD))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

        // Mark that we are using this instance
        IStiDeviceControl_AddRef(pHelDcb);

        this->pDcb = pHelDcb;
        hres = STI_OK;
    }

    ExitOleProc();
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | USD_Initialize |
 *
 *
 *  @parm    | |
 *
 *
 *****************************************************************************/
STDMETHODIMP
CStiEmptyUSD_GetCapabilities(
    PSTIUSD       pUsd,
    PSTI_USD_CAPS pUsdCaps
    )
{

    HRESULT     hres = STI_OK;

    EnterProcR(CStiEmptyUSD::USD_Initialize,(_ "pp", pUsd,pUsdCaps));

    // Validate parameters
    if (!pUsdCaps) {
        ExitOleProc();
        return STIERR_INVALID_PARAM;
    }

    if (SUCCEEDED(hres = hresPvI(pUsd, IStiUSD))) {

        PCStiEmptyUSD     this = _thisPv(pUsd);

        // Set that we are only pass-through, requiring serialization

        ZeroMemory(pUsdCaps,sizeof(*pUsdCaps));

        pUsdCaps->dwVersion = STI_VERSION;

        hres = STI_OK;
    }

    ExitOleProc();
    return hres;

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | CStiEmptyUSD | New |
 *
 *          Create a new StiDevice object, uninitialized.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          Output pointer for new object.
 *
 *****************************************************************************/

STDMETHODIMP
CStiEmptyUSD_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(CStiEmptyUSD::<constructor>, (_ "Gp", riid, punkOuter));

    hres = Common_NewRiid(CStiEmptyUSD, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        PCStiEmptyUSD this = _thisPv(*ppvObj);
        CStiEmptyUSD_Init(this);
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CStiEmptyUSD_Signature        (DWORD)'USD'

Primary_Interface_Begin(CStiEmptyUSD, IStiUSD)
    CStiEmptyUSD_Initialize,
    CStiEmptyUSD_GetCapabilities,
    CStiEmptyUSD_GetStatus,
    CStiEmptyUSD_DeviceReset,
    CStiEmptyUSD_Diagnostic,
    CStiEmptyUSD_Escape,
    CStiEmptyUSD_GetLastError,
    CStiEmptyUSD_LockDevice,
    CStiEmptyUSD_UnLockDevice,
    CStiEmptyUSD_RawReadData,
    CStiEmptyUSD_RawWriteData,
    CStiEmptyUSD_RawReadCommand,
    CStiEmptyUSD_RawWriteCommand,
    CStiEmptyUSD_SetNotificationEvent,
    CStiEmptyUSD_GetNotificationData,
Primary_Interface_End(CStiEmptyUSD, IStiDevice)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\regentry.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    regentry.cpp

Abstract:

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#include "cplusinc.h"
#include "sticomm.h"

RegEntry::RegEntry()
{
    m_hkey = NULL;
    bhkeyValid = FALSE;
}

RegEntry::RegEntry(const TCHAR *pszSubKey, HKEY hkey)
{
    m_hkey = NULL;
    bhkeyValid = FALSE;

    Open(pszSubKey, hkey);
}

RegEntry::~RegEntry()
{
    Close();
}

BOOL RegEntry::Open(const TCHAR *pszSubKey, HKEY hkey)
{
    Close();
    m_error = RegCreateKey(hkey, pszSubKey, &m_hkey);
    if (m_error) {
        bhkeyValid = FALSE;
    }
    else {
        bhkeyValid = TRUE;
    }
    return bhkeyValid;
}

BOOL RegEntry::Close()
{
    if (bhkeyValid) {
        RegCloseKey(m_hkey);
    }
    m_hkey = NULL;
    bhkeyValid = FALSE;
    return TRUE;
}



long RegEntry::SetValue(const TCHAR *pszValue, const TCHAR *string)
{
    if (bhkeyValid) {
        m_error = RegSetValueEx(m_hkey, pszValue, 0, REG_SZ,
                    (BYTE *)string, sizeof(TCHAR) * (lstrlen(string) + 1));
    }
    return m_error;
}

long RegEntry::SetValue(const TCHAR *pszValue, const TCHAR *string, DWORD dwType)
{
    DWORD cbData;
    cbData = sizeof(TCHAR) * (lstrlen(string) + 1);
    if (REG_MULTI_SZ == dwType)
    {
        // account for second null
        cbData+= sizeof(TCHAR);
    }
    if (bhkeyValid) {

        m_error = RegSetValueEx(m_hkey, pszValue, 0, dwType,
                    (BYTE *)string, cbData);
    }
    return m_error;
}


long RegEntry::SetValue(const TCHAR *pszValue, unsigned long dwNumber)
{
    if (bhkeyValid) {
        m_error = RegSetValueEx(m_hkey, pszValue, 0, REG_BINARY,
                    (BYTE *)&dwNumber, sizeof(dwNumber));
    }
    return m_error;
}

long RegEntry::SetValue(const TCHAR *pszValue,  BYTE * pValue,unsigned long dwNumber)
{
    if (bhkeyValid) {
        m_error = RegSetValueEx(m_hkey, pszValue, 0, REG_BINARY,
                    pValue, dwNumber);
    }
    return m_error;
}

long RegEntry::DeleteValue(const TCHAR *pszValue)
{
    if (bhkeyValid) {
        m_error = RegDeleteValue(m_hkey, (LPTSTR) pszValue);
    }
    return m_error;
}


TCHAR *RegEntry::GetString(const TCHAR *pszValue, TCHAR *string, unsigned long length)
{
    DWORD   dwType = REG_SZ;

    if (bhkeyValid) {
        DWORD   le;

        m_error = RegQueryValueEx(m_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
                    &length);
        le = ::GetLastError();

    }
    if (!m_error) {
        //
        // Expand string if indicated
        //
        if (dwType == REG_EXPAND_SZ) {

            DWORD   dwReqSize = 0;
            LPTSTR   pszExpanded = new TCHAR[length];

            if (pszExpanded) {

                *pszExpanded = TEXT('\0');

                dwReqSize = ExpandEnvironmentStrings(string,pszExpanded,length);

                if (dwReqSize && dwReqSize <= length) {
                    lstrcpy(string,pszExpanded);
                }

                delete[] pszExpanded;
            }
        }

    }
    else {
        *string = '\0';
    }

    return string;
}

long RegEntry::GetNumber(const TCHAR *pszValue, long dwDefault)
{
    DWORD   dwType = REG_BINARY;
    long    dwNumber = 0L;
    DWORD   dwSize = sizeof(dwNumber);

    if (bhkeyValid) {
        m_error = RegQueryValueEx(m_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)&dwNumber,
                    &dwSize);
    }
    if (m_error)
        dwNumber = dwDefault;

    return dwNumber;
}

VOID RegEntry::GetValue(const TCHAR *pszValueName, BUFFER *pValue)
{
    DWORD   dwType = REG_SZ;
    DWORD   length;

    m_error = NOERROR;

    if (bhkeyValid) {
        m_error = RegQueryValueEx( m_hkey,
                                  (LPTSTR) pszValueName,
                                  0,
                                  &dwType,
                                  NULL,
                                  &length );
        if (m_error == ERROR_SUCCESS) {

            pValue->Resize(length);

            if (length > (UINT)pValue->QuerySize()) {
                m_error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        if (NOERROR == m_error ) {

            m_error = RegQueryValueEx( m_hkey,
                                      (LPTSTR) pszValueName,
                                      0,
                                      &dwType,
                                      (LPBYTE) pValue->QueryPtr(),
                                      &length );
        }
    }

    if (m_error != ERROR_SUCCESS) {
        pValue->Resize(0);
    }
}

VOID RegEntry::MoveToSubKey(const TCHAR *pszSubKeyName)
{
    HKEY    _hNewKey;

    if (bhkeyValid) {
        m_error = RegOpenKey ( m_hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (m_error == ERROR_SUCCESS) {
            RegCloseKey(m_hkey);
            m_hkey = _hNewKey;
        }
    }
}

long RegEntry::FlushKey()
{
    if (bhkeyValid) {
        m_error = RegFlushKey(m_hkey);
    }
    return m_error;
}

BOOL RegEntry::GetSubKeyInfo(DWORD *pNumberOfSubKeys, DWORD *pMaxSubKeyLength)
{
    BOOL fResult = FALSE;
    if (bhkeyValid) {
        m_error = RegQueryInfoKey ( m_hkey,               // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   pNumberOfSubKeys,    // Number of subkeys
                                   pMaxSubKeyLength,    // Longest subkey name
                                   NULL,                // Longest class string
                                   NULL,                // Number of value entries
                                   NULL,                // Longest value name
                                   NULL,                // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
        if (m_error == ERROR_SUCCESS) {
            fResult = TRUE;
        }
    }
    return fResult;
}


BOOL RegEntry::EnumSubKey(DWORD index, StiCString *pstrString)
{
    BOOL    fResult = FALSE;

    m_error = NOERROR;

    if (!bhkeyValid) {
        return fResult;
    }

    m_error = RegEnumKey( m_hkey,
                         index,
                         (LPTSTR)(LPCTSTR)*pstrString,
                         pstrString->GetAllocLength() );

    if (m_error == ERROR_SUCCESS) {
        fResult = TRUE;
    }

    return fResult;
}


RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : pRegEntry(pReqRegEntry),
   iEnum(0),
   pchName(NULL),
   pbValue(NULL)
{
    m_error = pRegEntry->GetError();
    if (m_error == ERROR_SUCCESS) {
        m_error = RegQueryInfoKey ( pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &cEntries,           // Number of value entries
                                   &cMaxValueName,      // Longest value name
                                   &cMaxData,           // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (m_error == ERROR_SUCCESS) {
        if (cEntries != 0) {
            cMaxValueName = cMaxValueName + 1; // REG_SZ needs one more for null
            cMaxData = cMaxData + 1;           // REG_SZ needs one more for null
            pchName = new TCHAR[cMaxValueName];
            if (!pchName) {
                m_error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (cMaxData) {
                    pbValue = new BYTE[cMaxData];
                    if (!pbValue) {
                        m_error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete[] pchName;
    delete[] pbValue;
}

long RegEnumValues::Next()
{
    if (m_error != ERROR_SUCCESS) {
        return m_error;
    }
    if (cEntries == iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = cMaxValueName;

    dwDataLength = cMaxData;
    m_error = RegEnumValue ( pRegEntry->GetKey(), // Key
                            iEnum,               // Index of value
                            pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &dwType,             // Data type
                            pbValue,             // Address of buffer for value data
                            &dwDataLength );     // Address for size of data
    iEnum++;
    return m_error;
}



//
// Temporarily here
//
VOID
TokenizeIntoStringArray(
    STRArray&   array,
    LPCTSTR lpstrIn,
    TCHAR tcSplitter
    )
{

    //
    array.RemoveAll();

    if  (IS_EMPTY_STRING(lpstrIn)) {
        return;
    }

    while   (*lpstrIn) {

        //  First, strip off any leading blanks

        while   (*lpstrIn && *lpstrIn == _TEXT(' '))
            lpstrIn++;

        for (LPCTSTR lpstrMoi = lpstrIn;
             *lpstrMoi && *lpstrMoi != tcSplitter;
             lpstrMoi++)
            ;
        //  If we hit the end, just add the whole thing to the array
        if  (!*lpstrMoi) {
            if  (*lpstrIn)
                array.Add(lpstrIn);
            return;
        }

        //
        //  Otherwise, just add the string up to the splitter
        //
        TCHAR       szNew[MAX_PATH];
        SIZE_T      uiLen = (SIZE_T)(lpstrMoi - lpstrIn) + 1;

        if (uiLen < (sizeof(szNew) / sizeof(szNew[0])) - 1) {

            lstrcpyn(szNew,lpstrIn,(UINT)uiLen);
            szNew[uiLen] = TCHAR('\0');

            array.Add((LPCTSTR) szNew);
        }

        lpstrIn = lpstrMoi + 1;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\sched.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    str.cpp

Abstract:

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       added to Sti

--*/



#include "cplusinc.h"
#include "sticomm.h"

/* FlushInputQueue is a private routine to collect and dispatch all
 * messages in the input queue.  It returns TRUE if a WM_QUIT message
 * was detected in the queue, FALSE otherwise.
 */
BOOL FlushInputQueue(volatile DWORD *pidOtherThread)
{
    MSG msgTemp;
    while (PeekMessage(&msgTemp, NULL, 0, 0, PM_REMOVE)) {
        DispatchMessage(&msgTemp);

        // If we see a WM_QUIT in the queue, we need to do the same
        // sort of thing that a modal dialog does:  break out of our
        // waiting, and repost the WM_QUIT to the queue so that the
        // next message loop up in the app will also see it.  We also
        // post the message to the server thread's queue so that any
        // dialog stack displayed there will be destroyed as well.
        if (msgTemp.message == WM_QUIT) {
            if (pidOtherThread != NULL && *pidOtherThread != NULL) {
                PostThreadMessage(*pidOtherThread, msgTemp.message, msgTemp.wParam, msgTemp.lParam);
            }
            PostQuitMessage((int)msgTemp.wParam);
            return TRUE;
        }
    }
    return FALSE;
}


/* WaitAndYield() waits for the specified object using
 * MsgWaitForMultipleObjects.  If messages are received,
 * they are dispatched and waiting continues.  The return
 * value is the same as from MsgWaitForMultipleObjects.
 */
DWORD WaitAndYield(HANDLE hObject, DWORD dwTimeout, volatile DWORD *pidOtherThread /* = NULL */)
{
    DWORD dwTickCount, dwWakeReason, dwTemp;

    do {
        /* Flush any messages before we wait.  This is because
         * MsgWaitForMultipleObjects will only return when NEW
         * messages are put in the queue.
         */
        if (FlushInputQueue(pidOtherThread)) {
            dwWakeReason = WAIT_TIMEOUT;
            break;
        }

        // in case we handle messages, we want close to a true timeout
        if ((dwTimeout != 0) &&
            (dwTimeout != (DWORD)-1)) {
            // if we can timeout, store the current tick count
            // every time through
            dwTickCount = GetTickCount();
        }
        dwWakeReason = MsgWaitForMultipleObjects(1,
                                                 &hObject,
                                                 FALSE,
                                                 dwTimeout,
                                                 QS_ALLINPUT);
        // if we got a message, dispatch it, then try again
        if (dwWakeReason == 1) {
            // if we can timeout, see if we did before processing the message
            // that way, if we haven't timed out yet, we'll get at least one
            // more shot at the event
            if ((dwTimeout != 0) &&
                (dwTimeout != (DWORD)-1)) {
                if ((dwTemp = (GetTickCount()-dwTickCount)) >= dwTimeout) {
                    // if we timed out, make us drop through
                    dwWakeReason = WAIT_TIMEOUT;
                } else {
                    // subtract elapsed time from timeout and continue
                    // (we don't count time spent dispatching message)
                    dwTimeout -= dwTemp;
                }
            }
            if (FlushInputQueue(pidOtherThread)) {
                dwWakeReason = WAIT_TIMEOUT;
                break;
            }
        }
    } while (dwWakeReason == 1);

    return dwWakeReason;
}


/* WaitAndProcessSends is similar to WaitAndYield, but it only processes
 * SendMessage messages, not input messages.
 */
DWORD WaitAndProcessSends(HANDLE hObject, DWORD dwTimeout)
{
    DWORD dwWakeReason;

    do {
        dwWakeReason = MsgWaitForMultipleObjects(1,
                                                 &hObject,
                                                 FALSE,
                                                 dwTimeout,
                                                 QS_SENDMESSAGE);
        // if we got a message, yield, then try again
        if (dwWakeReason == 1) {
            MSG msgTemp;
            PeekMessage(&msgTemp, NULL, 0, 0, PM_NOREMOVE | PM_NOYIELD);
        }
    } while (dwWakeReason == 1);

    return dwWakeReason;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\rpcutil.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stiapi.h

Abstract:

    Common RPC related utility functions

Functions Exported:

    MIDL_user_allocate()
    MIDL_user_free()
    RpcBindHandleForServer()
    RpcBindHandleFree()

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#include "cplusinc.h"
#include "sticomm.h"

# include <rpc.h>

# include "apiutil.h"

#include "simstr.h"

/************************************************************
 *    Functions
 ************************************************************/

extern "C"
{
PVOID
MIDL_user_allocate(IN size_t size)
/*++

Routine Description:

    MIDL memory allocation.

Arguments:

    size : Memory size requested.

Return Value:

    Pointer to the allocated memory block.

--*/
{
    PVOID pvBlob;

    pvBlob = LocalAlloc( LPTR, size);

    return( pvBlob );

} // MIDL_user_allocate()


VOID
MIDL_user_free(IN PVOID pvBlob)
/*++

Routine Description:

    MIDL memory free .

Arguments:

    pvBlob : Pointer to a memory block that is freed.


Return Value:

    None.

--*/
{
    LocalFree( pvBlob);

    return;
}  // MIDL_user_free()


}

static CHAR szLocalAddress[] = "127.0.0.1";


RPC_STATUS
RpcBindHandleOverLocal( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++
  This function uses the parameters supplied and generates static
     binding handle for RPC over LRPC

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS  rpcStatus;
    LPTSTR      pszBinding = NULL;
    BOOL        fLocalCall = FALSE;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for local  binding
    //

    rpcStatus = RpcStringBindingCompose(0,                          // ObjUuid
                                        (RPC_STRING)STI_LRPC_SEQ,   // transport  seq
                                        (RPC_STRING)TEXT(""),       // NetworkAddr
                                        (RPC_STRING)STI_LRPC_ENDPOINT,     // Endpoint
                                         NULL,                      // Options
                                         (RPC_STRING *)&pszBinding);// StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBinding((RPC_STRING)pszBinding,pBindingHandle );

        if (rpcStatus == RPC_S_OK)
        {
            //
            //  Check that the server we're connecting to has the appropriate credentials.
            //  For XP CLient, we know the principal name is LocalSystem.
            //
            CSimpleStringWide   cswStiSvcPrincipalName = L"NT Authority\\System";

            RPC_SECURITY_QOS RpcSecQos = {0};

            RpcSecQos.Version           = RPC_C_SECURITY_QOS_VERSION_1;
            RpcSecQos.Capabilities      = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
            RpcSecQos.IdentityTracking  = RPC_C_QOS_IDENTITY_STATIC;
            RpcSecQos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

            rpcStatus = RpcBindingSetAuthInfoExW(*pBindingHandle,
                                                 (WCHAR*)cswStiSvcPrincipalName.String(),
                                                 RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                                 RPC_C_AUTHN_WINNT,
                                                 NULL,
                                                 RPC_C_AUTHZ_NONE,
                                                 &RpcSecQos);
        }
    }

    //
    // Cleanup and return back.
    //

    if ( pszBinding != NULL) {

        DWORD rpcStatus1 = RpcStringFree((RPC_STRING *)&pszBinding);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverLocal()

#ifdef STI_REMOTE_BINDING

RPC_STATUS
RpcBindHandleOverTcpIp( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszServerName,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++
  This function uses the parameters supplied and generates a dynamic end point
     binding handle for RPC over TCP/IP.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPSTR    pszBindingA = NULL;
    CHAR    szServerA[MAX_PATH];
    CHAR    szInterfaceA[MAX_PATH];
    int     cch;
    BOOL    fLocalCall = FALSE;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    *szServerA = '0';

    if (pwszServerName ) {
        cch = WideCharToMultiByte(CP_ACP,
                                  0,
                                  pwszServerName,
                                  -1,
                                  szServerA,
                                  sizeof(szServerA)/sizeof(CHAR),
                                  NULL,NULL
                                  );
    }

    // If empty server name has been passed - use address of local machine
    if (!*szServerA || !lstrcmpi(szServerA,szLocalAddress)) {

        fLocalCall = TRUE;
        lstrcpy(szServerA,szLocalAddress);

    }

    *szInterfaceA = '0';

    if(pwszInterfaceName)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszInterfaceName,
                              -1,
                              szInterfaceA,
                              sizeof(szInterfaceA)/sizeof(CHAR),
                              NULL,NULL
                              );


    //
    // Compose the binding string for TCP/IP  binding
    //

    rpcStatus = RpcStringBindingCompose(0,                      // ObjUuid
                                         "ncacn_ip_tcp",        // tcpip seq
                                         szServerA,             // NetworkAddr
                                         NULL,                  // Endpoint
                                         NULL,                  //L"",  // Options
                                         &pszBindingA);         // StringBinding

    DBGPRINTF( (DBG_CONTEXT, "\nRpcStringBindingCompose(%s, %s) return %s."
                " Error = %ld\n",
                "ncacn_ip_tcp",
                szServerA,
                pszBindingA,
                rpcStatus)
              );

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBinding(pszBindingA,
                                                 pBindingHandle );

        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingFromStringBinding(%s) return %d."
                    "Binding=%08x\n",
                    pszBindingA,
                    rpcStatus,
                    *pBindingHandle)
                  );
    }

    if ( (rpcStatus == RPC_S_OK) && !fLocalCall) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfo(*pBindingHandle,
                                 szInterfaceA,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,  // AuthnIdentity
                                 0      // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%s(Interface=%s), %08x)"
                    " return %d.\n",
                    pszBindingA,
                    szInterfaceA,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }

    //
    // Cleanup and return back.
    //

    if ( pszBindingA != NULL) {

        DWORD rpcStatus1 = RpcStringFree(&pszBindingA);
        DBGPRINTF( (DBG_CONTEXT, "RpcStringFreeW() returns %d.",
                    rpcStatus1)
                  );

    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(*pBindingHandle);
            DBGPRINTF( (DBG_CONTEXT, "RpcBindingFree() returns %d.\n",
                        rpcStatus1)
                      );
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverTcpIp()



RPC_STATUS
RpcBindHandleOverNamedPipe( OUT handle_t * pBindingHandle,
                           IN LPWSTR      pwszServerName,
                           IN LPWSTR      pwszEndpoint,
                           IN LPWSTR      pwszOptions
                          )
/*++
  This function uses the parameters supplied and generates a named pipe
   binding handle for RPC.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszEndpoint     pointer to string containing the Named Pipe Endpoint
   pwszOptions      pointer to string containing any additional options for
                       binding.


  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;

    LPWSTR   pwszBinding = NULL;
    LPSTR    pszBindingA = NULL;

    CHAR    szServerA[MAX_PATH+2];
    CHAR    szEndpointA[MAX_PATH];
    CHAR    szOptionsA[MAX_PATH];
    PSTR    pszStartServerName;

    int     cch;
    BOOL    fLocalCall = FALSE;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    *szServerA = '0';

    if (pwszServerName ) {

        // We are trying to bind over NP transport, so server name should start with leading slashes
        if(*pwszServerName  == L'\\' &&
           *(pwszServerName+1)  == L'\\') {
            pszStartServerName = szServerA;
        }
        else {
            lstrcpy(szServerA,TEXT("\\\\"));
            pszStartServerName = szServerA+2;
        }

        cch = WideCharToMultiByte(CP_ACP,
                                  0,
                                  pwszServerName,
                                  -1,
                                  pszStartServerName,
                                  sizeof(szServerA)/sizeof(CHAR)-2,
                                  NULL,NULL
                                  );
    }

    if (!*szServerA) {
        return ERROR_INVALID_PARAMETER;
    }

    // Remove extra slashes if there are too many

    *szEndpointA = '0';

    if(pwszEndpoint)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszEndpoint,
                              -1,
                              szEndpointA,
                              sizeof(szEndpointA)/sizeof(CHAR),
                              NULL,NULL
                              );

    *szOptionsA = '0';

    if(pwszOptions)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszOptions,
                              -1,
                              szOptionsA,
                              sizeof(szOptionsA)/sizeof(CHAR),
                              NULL,NULL
                              );


    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingCompose(0,            // ObjUuid
                                         "ncacn_np",  // prot seq: named pipe
                                         szServerA, // NetworkAddr
                                         szEndpointA, // Endpoint
                                         "", //szOptionsA,  // Options
                                         &pszBindingA);    // StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBinding(pszBindingA,
                                                 pBindingHandle );
    }


    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {
        RpcStringFree(&pszBindingA);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            RpcBindingFree(*pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverNamedPipe()

#endif // STI_REMOTE_BINDING



RPC_STATUS
RpcBindHandleForServer( OUT handle_t * pBindingHandle,
                       IN LPWSTR      pwszServerName,
                       IN LPWSTR      pwszInterfaceName,
                       IN LPWSTR      pwszOptions
                       )
/*++
  This function uses the parameters supplied and generates a binding
    handle for RPC.

  The transport used is determined dynamically based on following rules.

  If server name starts with a leading "\\" (double slash),
      then attempt RPC binding over NamedPipe.

  If server name does not start with leading "\\",
      then attempt RPC binding over TCPIP.

  If TCPIP binding fails, then this function tries binding over NamedPipe.

  It is assumed that binding over named pipe uses static end point
      with the interface name and options as provided.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name
   pwszOptions      pointer to string containing any additional options for
                       binding.

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus = RPC_S_SERVER_UNAVAILABLE;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // STI interfaces are not remotable, so only try binding to local server
    //
    if ( pwszServerName == NULL ||
         *pwszServerName == L'\0' ) {

        rpcStatus = RpcBindHandleOverLocal( pBindingHandle,
                                           pwszInterfaceName);

    }
    else {
        rpcStatus = RPC_S_INVALID_NET_ADDR;
    }

# ifdef STI_REMOTE_BINDING

#ifdef CHICAGO

    //
    // On Windows9x if there is no VRedir installed, RPC refuses to bind over
    // TCP/IP or NetBIOS. TO resolve this issue server always listens on LRPC
    // and if client is requesting local operation ( by passing empty string or NULL)
    // as first parameter binding is done over LRPC. Note, that passing non-null IP address
    // ( even if it points to local machine, like 127.0.0.1 ) will result in binding over TCP/IP
    // and may now work .
    //

    if ( pwszServerName == NULL ||
         *pwszServerName == L'\0' ) {

        rpcStatus = RpcBindHandleOverLocal( pBindingHandle,
                                           pwszInterfaceName);

    }
    else {

        if ( pwszServerName[0] != L'\\' &&
          pwszServerName[1] != L'\\' ) {

        //
        // Attempt binding over TCPIP using Dynamic Endpoint.
        //

        rpcStatus = RpcBindHandleOverTcpIp( pBindingHandle,
                                           pwszServerName,
                                           pwszInterfaceName);

        } else {

            rpcStatus = RPC_S_INVALID_NET_ADDR;
        }
    }
#endif


    if ( rpcStatus != RPC_S_OK) {

        WCHAR  rgchNp[1024];

        //
        // generate a NamedPipe end point name from the interface name.
        //  the End point =   \PIPE\<InterfaceName>
        //

        wcscpy( rgchNp, L"\\PIPE\\");
        wcscat( rgchNp, pwszInterfaceName);

        //
        // Attempt binding over static NamedPipe.
        //

        rpcStatus = RpcBindHandleOverNamedPipe( pBindingHandle,
                                               pwszServerName,
                                               rgchNp,
                                               pwszOptions
                                               );

        DBGPRINTF(( DBG_CONTEXT,
                   " RpcBindingOverNamedPipe(%S) returns %d. Handle = %08x\n",
                   pwszServerName, rpcStatus, *pBindingHandle));

    }

# endif // STI_REMOTE_BINDING

    return ( rpcStatus);

} // RpcBindHandleForServer()



RPC_STATUS
RpcBindHandleFree(IN OUT handle_t * pBindingHandle)
/*++

  Description:

    This function frees up the binding handle allocated using
      RpcBindHandleForServer(). It uses RPC Binding Free routing to do this.
    This function acts just as a thunk so that the alloc/free of RPC contexts
      are consolidated within this module.

  Arguments:
    pBindingHandle  pointer to RPC binding handle that needs to be freed.


  Returns:
    RPC_STATUS - containig the RPC status. RPC_S_OK for success.

--*/
{

    return ( RpcBindingFree( pBindingHandle));

} // RpcBindHandleFree()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\service.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    service.cpp

Abstract:

    This file provides access to the service control
    manager for starting, stopping, adding, and removing
    services.

Environment:

    WIN32 User Mode

Author:

    Vlad Sadovsky (vlads) 17-Apr-1998

--*/

#include "cplusinc.h"
#include "sticomm.h"

#include <stisvc.h>
#include <eventlog.h>

DWORD
SetServiceSecurity(
    LPTSTR AccountName
    );

//
// Installation routines.
//

DWORD
WINAPI
StiServiceInstall(
    BOOL    UseLocalSystem,
    BOOL    DemandStart,
    LPTSTR  lpszUserName,
    LPTSTR  lpszUserPassword
    )
/*++

Routine Description:

    Service installation function.
    Calls SCM to install STI service, which is running in user security context

    BUGBUG Review

Arguments:

Return Value:

    None.

--*/
{

    DWORD       dwError = NOERROR;

    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hService = NULL;

    __try  {

        hSCM = ::OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);

        if (!hSCM) {
            dwError = GetLastError();
            __leave;
        }

        //
        // If service already exists - bail out quickly
        //
        hService = OpenService(
                            hSCM,
                            STI_SERVICE_NAME,
                            SERVICE_ALL_ACCESS
                            );
        if (hService) {
            dwError = NOERROR;
            __leave;
        }

        //
        // If use local system - set security
        //
        if (!UseLocalSystem) {
            #ifdef LATER
            dwError = SetServiceSecurity( lpszUserName );
            if (dwError) {
                dwError = ERROR_SERVICE_LOGON_FAILED ;
                __leave;
            }
            #endif
        }

        hService = CreateService(
                                hSCM,
                                STI_SERVICE_NAME,
                                STI_DISPLAY_NAME,
                                SERVICE_ALL_ACCESS,
                                STI_SVC_SERVICE_TYPE,
                                DemandStart ? SERVICE_DEMAND_START : SERVICE_AUTO_START,
                                SERVICE_ERROR_NORMAL,
                                STI_IMAGE_NAME,
                                NULL,
                                NULL,
                                NULL, //STI_SERVICE_DEPENDENCY,
                                UseLocalSystem ? NULL : lpszUserName,
                                UseLocalSystem ? NULL : lpszUserPassword
                                );


        if (!hService) {
            dwError = GetLastError();
            __leave;
        }

        //
        // Add registry settings for event logging
        //
        RegisterStiEventSources();

        //
        // Start service
        //
        dwError = StartService(hService,0,(LPCTSTR *)NULL);

    }
    __finally {
        CloseServiceHandle( hService );
        CloseServiceHandle( hSCM );
    }

    return dwError;

} //StiServiceInstall


DWORD
WINAPI
StiServiceRemove(
    VOID
    )

/*++

Routine Description:

    Service removal function.  This function calls SCM to remove the STI  service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success

--*/

{
    DWORD       dwError = NOERROR;

    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hService = NULL;

    SERVICE_STATUS  ServiceStatus;
    UINT        uiRetry = 10;

    HKEY        hkRun;


    __try  {

        hSCM = ::OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);

        if (!hSCM) {
            dwError = GetLastError();
            __leave;
        }

        hService = OpenService(
                            hSCM,
                            STI_SERVICE_NAME,
                            SERVICE_ALL_ACCESS
                            );
        if (!hService) {
            dwError = GetLastError();
            __leave;
        }


        //
        // Stop service first
        //
        if (ControlService( hService, SERVICE_CONTROL_STOP, &ServiceStatus )) {
            //
            // Wait a little
            //
            Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );

            ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;

            while( QueryServiceStatus( hService, &ServiceStatus ) &&
                  (SERVICE_STOP_PENDING ==  ServiceStatus.dwCurrentState)) {
                Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );
                if (!uiRetry--) {
                    break;
                }
            }

            if (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
                dwError = GetLastError();
                __leave;
            }
        }
        else {
            dwError = GetLastError();
            __leave;
        }

        if (!DeleteService( hService )) {
            dwError = GetLastError();
            __leave;
        }
    }
    __finally {
        CloseServiceHandle( hService );
        CloseServiceHandle( hSCM );
    }

    //
    // Leftovers from Win9x - remove STI monitor from Run section
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUN, &hkRun) == NO_ERROR) {

        RegDeleteValue (hkRun, REGSTR_VAL_MONITOR);
        RegCloseKey(hkRun);
    }

    return dwError;

} // StiServiceRemove


BOOL
SetServiceDependency(
    LPTSTR ServiceName,
    LPTSTR DependentServiceName
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,               // handle to service
        SERVICE_NO_CHANGE,      // type of service
        SERVICE_NO_CHANGE,      // when to start service
        SERVICE_NO_CHANGE,      // severity if service fails to start
        NULL,                   // pointer to service binary file name
        NULL,                   // pointer to load ordering group name
        NULL,                   // pointer to variable to get tag identifier
        DependentServiceName,   // pointer to array of dependency names
        NULL,                   // pointer to account name of service
        NULL,                   // pointer to password for service account
        NULL                    // pointer to display name
        )) {
        goto exit;
    }

    rVal = TRUE;

exit:
    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


BOOL
SetServiceStart(
    LPTSTR ServiceName,
    DWORD StartType
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,                        // handle to service
        SERVICE_NO_CHANGE,               // type of service
        StartType,                       // when to start service
        SERVICE_NO_CHANGE,               // severity if service fails to start
        NULL,                            // pointer to service binary file name
        NULL,                            // pointer to load ordering group name
        NULL,                            // pointer to variable to get tag identifier
        NULL,                            // pointer to array of dependency names
        NULL,                            // pointer to account name of service
        NULL,                            // pointer to password for service account
        NULL                             // pointer to display name
        ))
    {
        goto exit;
    }

    rVal = TRUE;

exit:
    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}

/*
BOOL
SetServiceAccount(
    LPTSTR ServiceName,
    PSECURITY_INFO SecurityInfo
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,                        // handle to service
        SERVICE_NO_CHANGE,               // type of service
        SERVICE_NO_CHANGE,               // when to start service
        SERVICE_NO_CHANGE,               // severity if service fails to start
        NULL,                            // pointer to service binary file name
        NULL,                            // pointer to load ordering group name
        NULL,                            // pointer to variable to get tag identifier
        NULL,                            // pointer to array of dependency names
        SecurityInfo->AccountName,       // pointer to account name of service
        SecurityInfo->Password,          // pointer to password for service account
        NULL                             // pointer to display name
        )) {
        goto exit;
    }

    rVal = TRUE;

exit:
    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     stirt.lib    -
#
# ############################################################


!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=stirt
TARGETTYPE=LIBRARY
TARGETPATH=$(WIA_LIB_DEST)

USE_ATL=1

INCLUDES=$(INCLUDES);..\..\..\core\rpc;..\..\..\core\rpc\$(O);

SOURCES=\
        ..\assert.cpp   \
        ..\buffer.cpp   \
        ..\cdlg.cpp     \
        ..\lock.cpp     \
        ..\purecall.cpp \
        ..\regentry.cpp \
        ..\sched.cpp    \
        ..\rpcutil.cpp  \
        ..\stilog.cpp   \
        ..\eventlog.cpp \
        ..\valid.cpp    \
        ..\service.cpp  \
	..\wialog.cpp	\
	..\enum.cpp	\
	..\coredbg.cpp   \
	..\globals.c	\
	..\device.c	\
	..\olesupp.c	\
	..\stiobj.c	\
	..\common.c	\
	..\passusd.c	\
	..\cassert.c	\
	..\osutil.c	\
	..\stivalid.c	\
	..\stistub.c	\
	..\helwdm.c	\
	..\helcom.c	\
	..\wiaevent.c   \


##      ..\svcinfo.cpp  \

#
# Note:  The precompiled header is C not C++!
#
PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\cplusinc.h
PRECOMPILED_OBJ = precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\sticomm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sticomm.h

Abstract:

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created
    29-May-2000     ByronC      moved all ATL and C++ specific includes to 
                                    cplusinc.h, since ATL headers can not 
                                    be used in .C files.

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#define COBJMACROS

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <regstr.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <devguid.h>

#include "wia.h"
#include "stidebug.h"
#include <stiregi.h>
#include <sti.h>
#include <stierr.h>
#include <stiusd.h>
#include <stilog.h>
#include "stiapi.h"
#include "stirc.h"
#include "stipriv.h"
#include "wiapriv.h"
#include "debug.h"
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\stistub.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stistub.c

Abstract:

    Routines which use RPC to pass arguments to/from server while enclosed in SEH frame

Environment:

    User Mode -Win32

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

/*
#include "wia.h"
#include <stilog.h>
#include <stiregi.h>

#include <sti.h>
#include <stierr.h>
#include <stiusd.h>
#include "stipriv.h"
#include "debug.h"
*/
#include "sticomm.h"

#include <stiapi.h>
#include <apiutil.h>

#include <stirpc.h>

DWORD
WINAPI
RpcStiApiGetVersion(
    IN  LPCWSTR  pszServer,
    IN  DWORD   dwReserved,
    OUT LPDWORD lpdwVersion
    )
{

    DWORD   status;

    RpcTryExcept {

        status = R_StiApiGetVersion(NULL,
                                       dwReserved,
                                       lpdwVersion);
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
}



DWORD
WINAPI
RpcStiApiOpenDevice(
    IN  LPCWSTR  pszServer,
    IN  LPCWSTR  pdeviceName,
    IN  DWORD   dwMode,
    IN  DWORD   dwAccessRequired,
    IN  DWORD   dwProcessId,
    OUT HANDLE *pHandle
    )
{

    DWORD   status;

    RpcTryExcept {

        status = R_StiApiOpenDevice(NULL,
                                    pdeviceName,
                                    dwMode,
                                    dwAccessRequired,
                                    dwProcessId,
                                    pHandle
                                    );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
}



DWORD
WINAPI
RpcStiApiCloseDevice(
    IN  LPCWSTR  pszServer,
    IN  HANDLE  hDevice
    )
{

    DWORD   status;

    RpcTryExcept {

        status = R_StiApiCloseDevice(NULL,hDevice  );

    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
}


DWORD
WINAPI
RpcStiApiSubscribe(
    IN STI_DEVICE_HANDLE hDevice,
    IN LPSTISUBSCRIBE    lpSubScribe
    )
{

    DWORD   status;

    LOCAL_SUBSCRIBE_CONTAINER   sLocalContainer;

    ZeroMemory(&sLocalContainer,sizeof(LOCAL_SUBSCRIBE_CONTAINER));

    RpcTryExcept {

        sLocalContainer.dwSize = sizeof(LOCAL_SUBSCRIBE_CONTAINER);
        sLocalContainer.dwFlags = lpSubScribe->dwFlags;

        if (lpSubScribe->dwFlags & STI_SUBSCRIBE_FLAG_WINDOW) {
            sLocalContainer.upLocalWindowHandle = (UINT_PTR)lpSubScribe->hWndNotify;
            sLocalContainer.uiNotificationMessage = lpSubScribe->uiNotificationMessage;
        }
        else {
            sLocalContainer.upLocalEventHandle = (UINT_PTR)lpSubScribe->hEvent;
        }

        status = R_StiApiSubscribe(hDevice,&sLocalContainer);

    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
}



DWORD
WINAPI
RpcStiApiGetLastNotificationData(
    IN  STI_DEVICE_HANDLE   hDevice,
    OUT LPSTINOTIFY         lpNotify
    )
{
    DWORD   status;
    DWORD   cbNeeded;

    RpcTryExcept {

        status = R_StiApiGetLastNotificationData(hDevice,
                                                 (LPBYTE)lpNotify,
                                                 lpNotify->dwSize,
                                                 &cbNeeded
                                                 );

    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
}

DWORD
WINAPI
RpcStiApiUnSubscribe(
    IN STI_DEVICE_HANDLE hDevice
    )
{

    DWORD   status;

    RpcTryExcept {

        status = R_StiApiUnSubscribe(hDevice);

    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
}

DWORD
WINAPI
RpcStiApiEnableHwNotifications(
    IN  LPCWSTR  pszServer,
    IN  LPCWSTR  pdeviceName,
    IN  BOOL     bNewState
    )
{

    DWORD   status;

    RpcTryExcept {

        status = R_StiApiEnableHwNotifications(NULL,
                                    pdeviceName,
                                    bNewState
                                    );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
}


DWORD
WINAPI
RpcStiApiGetHwNotificationState(
    IN  LPCWSTR  pszServer,
    IN  LPCWSTR  pdeviceName,
    OUT LPDWORD  pState
    )
{

    DWORD   status;

    RpcTryExcept {

        status = R_StiApiGetHwNotificationState(NULL,
                                    pdeviceName,
                                    pState
                                    );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
}

DWORD
WINAPI
RpcStiApiLaunchApplication(
    IN  LPCWSTR  pszServer,
    IN  LPCWSTR  pdeviceName,
    IN  LPCWSTR  pAppName,
    IN  LPSTINOTIFY  pStiNotify
    )
{
    DWORD   status;

    RpcTryExcept {

        status = R_StiApiLaunchApplication(NULL,
                                    pdeviceName,
                                    pAppName,
                                    pStiNotify
                                    );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;

}

DWORD
WINAPI
RpcStiApiLockDevice(
    IN  LPCWSTR pdeviceName,
    IN  DWORD   dwWait,
    IN  BOOL    bInServerProcess
    )
{
    DWORD   status;

    RpcTryExcept {

        status = R_StiApiLockDevice(NULL,
                                    pdeviceName,
                                    dwWait,
                                    FALSE,
                                    GetCurrentThreadId());
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
}

DWORD
WINAPI
RpcStiApiUnlockDevice(
    IN  LPCWSTR  pdeviceName,
    IN  BOOL    bInServerProcess
    )
{

    DWORD   status;

    RpcTryExcept {

        status = R_StiApiUnlockDevice(NULL,
                                      pdeviceName,
                                      FALSE,
                                      GetCurrentThreadId());
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\stiobj.c ===
/*****************************************************************************
 *
 *  StiObj.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The IStillImage main interface.
 *
 *  Contents:
 *
 *      CStiObj_New
 *
 *****************************************************************************/
 
#include "sticomm.h"
#include "enum.h"
#include "stisvc.h"

//
//  Private defines
//

#define DbgFl DbgFlSti


//
//
//
#undef IStillImage

//
//  DEVICE_INFO_SIZE and WIA_DEVICE_INFO_SIZE
//
//  These defines represent the space needed to store the device information
//  structs and the string data that some of their members point to.
//  STI_DEVICE_INFORMATION has 5 strings while STI_WIA_DEVICE_INFORMATION
//  has 6.  To be completely safe, these device info sizes should be
//  (MAX_PATH * sizeof(WCHAR) * no. of strings) + struct size.
//

#define DEVICE_INFO_SIZE    (sizeof(STI_DEVICE_INFORMATION)+(MAX_PATH * sizeof(WCHAR) * 5))
#define WIA_DEVICE_INFO_SIZE (sizeof(STI_WIA_DEVICE_INFORMATION)+(MAX_PATH * sizeof(WCHAR) * 6))

//
//  DEVICE_LIST_SIZE.  Note that this is currently a fixed size, but will change
//  as soon we abstract device enumeration into a class.
//
//  Device list size is fixed at the moment.  It's size is:
//      MAX_NUM_DEVICES * (max(DEVICE_INFO_SIZE, WIA_DEVICE_INFO_SIZE))
//  i.e. enough to hold MAX_NUM_DEVICES only.

#define MAX_NUM_DEVICES     16
#define DEVICE_LIST_SIZE    MAX_NUM_DEVICES * (max(DEVICE_INFO_SIZE, WIA_DEVICE_INFO_SIZE))
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CStiObj |
 *
 *          The <i IStillImage> object, from which other things come.
 *
 *
 *  @field  IStillImage | Sti |
 *
 *          STI interface
 *
 *  @field  IStillImage | dwVersion |
 *
 *          Version identifier
 *
 *  @comm
 *
 *          We contain no instance data, so no critical section
 *          is necessary.
 *
 *****************************************************************************/

typedef struct CStiObj {

    /* Supported interfaces */
    TFORM(IStillImage)   TFORM(sti);
    SFORM(IStillImage)   SFORM(sti);

    DWORD           dwVersion;

} CStiObj, *PCStiObj;

#define ThisClass       CStiObj

#define ThisInterface TFORM(IStillImage)
#define ThisInterfaceA IStillImageA
#define ThisInterfaceW IStillImageW
#define ThisInterfaceT IStillImage

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CStiObj, TFORM(ThisInterfaceT));
Secondary_Interface(CStiObj, SFORM(ThisInterfaceT));

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IStillImage | QIHelper |
 *
 *          We don't have any dynamic interfaces and simply forward
 *          to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IStillImage | Finalize |
 *
 *          We don't have any instance data, so we can just
 *          forward to <f Common_Finalize>.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CStiObj)
Default_AddRef(CStiObj)
Default_Release(CStiObj)

#else

#define CStiObj_QueryInterface   Common_QueryInterface
#define CStiObj_AddRef           Common_AddRef
#define CStiObj_Release          Common_Release

#endif

#define CStiObj_QIHelper         Common_QIHelper
//#define CStiObj_Finalize         Common_Finalize

#pragma BEGIN_CONST_DATA

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IStillImage | CreateDeviceHelper |
 *
 *          Creates and initializes an instance of a device which is
 *          specified by the GUID and IID.
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          See <mf IStillImage::CreateDevice>.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          See <mf IStillImage::CreateDevice>.
 *
 *  @parm   IN LPUNKNOWN | punkOuter |
 *
 *          See <mf IStillImage::CreateDevice>.
 *
 *  @parm   IN RIID | riid |
 *
 *          The interface the application wants to create.  This will
 *          be  <i IStillImageDevice> .
 *          If the object is aggregated, then this parameter is ignored.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CStiObj_CreateDeviceHelper(
    PCStiObj    this,
    LPWSTR      pwszDeviceName,
    PPV         ppvObj,
    DWORD       dwMode,
    PUNK        punkOuter,
    RIID        riid)
{
    HRESULT hres = STIERR_INVALID_PARAM;

    EnterProc(CStiObj_CreateDeviceHelper,(_ "ppxG", this, pwszDeviceName, punkOuter, riid));

    hres = CStiDevice_New(punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres) && punkOuter == 0) {
        PSTIDEVICE pdev = *ppvObj;
        hres = IStiDevice_Initialize(pdev, g_hInst,pwszDeviceName,this->dwVersion,dwMode);
        if (SUCCEEDED(hres)) {
        } else {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpv(ppvObj);
    return hres;

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | CreateDevice |
 *
 *          Creates and initializes an instance of a device which is
 *          specified by the GUID and IID.
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm   REFGUID | rguid |
 *          Identifies the instance of the
 *          device for which the indicated interface
 *          is requested.  The <mf IStillImage::EnumDevices> method
 *          can be used to determine which instance GUIDs are supported by
 *          the system.
 *
 *  @parm   OUT LPSTIDEVICE * | lplpStillImageDevice |
 *          Points to where to return
 *          the pointer to the <i IStillImageDevice> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown
 *          for OLE aggregation, or 0 if the interface is not aggregated.
 *          Most callers will pass 0.
 *
 *  @comm   Calling this function with <p punkOuter> = NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_StillImageDevice, NULL,
 *          CLSCTX_INPROC_SERVER, <p riid>, <p lplpStillImageDevice>);
 *          then initializing it with <f Initialize>.
 *
 *          Calling this function with <p punkOuter> != NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_StillImageDevice, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_IUnknown, <p lplpStillImageDevice>).
 *          The aggregated object must be initialized manually.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c STIERR_NOINTERFACE> = <c E_NOINTERFACE>
 *          The specified interface is not supported by the object.
 *
 *          <c STIERR_DEVICENOTREG> = The device instance does not
 *          correspond to a device that is registered with StillImage.
 *
 *****************************************************************************/

STDMETHODIMP
CStiObj_CreateDeviceW(
    PV          pSti,
    LPWSTR      pwszDeviceName,
    DWORD       dwMode,
    PSTIDEVICE *ppDev,
    PUNK        punkOuter
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    EnterProcR(IStillImage::CreateDevice,(_ "ppp", pSti, pwszDeviceName, punkOuter));

    // Validate passed pointer to interface and obtain pointer to object instance
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);

        hres = CStiObj_CreateDeviceHelper(this, pwszDeviceName, (PPV)ppDev,dwMode,punkOuter, &IID_IStiDevice);
    }

    ExitOleProcPpv(ppDev);
    return hres;
}

STDMETHODIMP
CStiObj_CreateDeviceA(
    PV          pSti,
    LPCSTR      pszDeviceName,
    DWORD       dwMode,
    PSTIDEVICE *ppDev,
    PUNK        punkOuter
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;

    EnterProcR(IStillImage::CreateDevice,(_ "ppp", pSti, pszDeviceName, punkOuter));

    // Validate passed pointer to interface and obtain pointer to object instance
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

        PVOID   pBuffer = NULL;
        UINT    uiSize = (lstrlenA(pszDeviceName)+1)*sizeof(WCHAR);

        hres = AllocCbPpv(uiSize, &pBuffer);
        if (SUCCEEDED(hres)) {

            *((LPWSTR)pBuffer) = L'\0';
            AToU(pBuffer,uiSize,pszDeviceName);

            hres = CStiObj_CreateDeviceHelper(this,
                                              (LPWSTR)pBuffer,
                                              (PPV)ppDev,
                                              dwMode,
                                              punkOuter,
                                              &IID_IStiDevice);

            FreePpv(&pBuffer);
        }
    }

    ExitOleProcPpv(ppDev);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IStillImage | GetDeviceInfoHelper |
 *
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  No validation performed
 *
 *****************************************************************************/

BOOL INLINE
AddOneString(LPCWSTR pStart,LPCWSTR   pNew,LPWSTR *ppTarget)
{
    if (pStart + OSUtil_StrLenW(pNew) + 1 < *ppTarget ) {
        (*ppTarget)-= (OSUtil_StrLenW(pNew) + 1);
        OSUtil_lstrcpyW(*ppTarget,pNew);
        return TRUE;
    }

    return FALSE;
}

/*
BOOL INLINE
AddOneStringA(LPCSTR pStart,LPCSTR   pNew,LPSTR *ppTarget)
{
    if (pStart + lstrlenA(pNew) + 1 < *ppTarget ) {
        (*ppTarget)-= (lstrlenA(pNew) + 1);
        lstrcpyA(*ppTarget,pNew);
        return TRUE;
    }

    return FALSE;
}
*/

BOOL
PullFromRegistry(
    HKEY    hkeyDevice,
    LPWSTR  *ppwstrPointer,
    LPCWSTR lpwstrKey,
    LPCWSTR lpwstrBarrier,
    LPWSTR *ppwstrBuffer
    )
{
    BOOL    bReturn = TRUE;
    LPWSTR  pwstrNewString = NULL;

    ReadRegistryString(hkeyDevice,lpwstrKey,L"",FALSE,&pwstrNewString);

    *ppwstrPointer = NULL;

    if (pwstrNewString) {

        bReturn = AddOneString(lpwstrBarrier, pwstrNewString,ppwstrBuffer);

        FreePv(pwstrNewString);

        *ppwstrPointer = *ppwstrBuffer;
    }

    return  bReturn;
}


STDMETHODIMP
GetDeviceInfoHelper(
    LPWSTR  pszDeviceName,
    PSTI_DEVICE_INFORMATION *ppCurrentDevPtr,
    PWSTR *ppwszCurrentString
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;
    HKEY    hkeyDevice;

    PSTI_DEVICE_INFORMATION pDevPtr = *ppCurrentDevPtr;
    // PWSTR   pwszNewString = NULL;
    PWSTR   pwszBarrier;

    PWSTR   pwszTargetString =  *ppwszCurrentString;

    DWORD   dwMajorType,dwMinorType;

    // Open device registry key
    hres = OpenDeviceRegistryKey(pszDeviceName,NULL,&hkeyDevice);

    if (!SUCCEEDED(hres)) {
        return hres;
    }

    //
    // Read flags and strings
    //

    pDevPtr->dwSize     = cbX(STI_DEVICE_INFORMATION);

    dwMajorType = dwMinorType = 0;

    ZeroX(pDevPtr->DeviceCapabilities) ;
    ZeroX(pDevPtr->dwHardwareConfiguration) ;

    dwMajorType = (STI_DEVICE_TYPE)ReadRegistryDwordW( hkeyDevice,REGSTR_VAL_DEVICETYPE_W,StiDeviceTypeDefault);
    dwMinorType = (STI_DEVICE_TYPE)ReadRegistryDwordW( hkeyDevice,REGSTR_VAL_DEVICESUBTYPE_W,0);

    pDevPtr->DeviceCapabilities.dwGeneric = ReadRegistryDwordW( hkeyDevice,REGSTR_VAL_GENERIC_CAPS_W,0);

    pDevPtr->DeviceType = MAKELONG(dwMinorType,dwMajorType);

    pDevPtr->dwHardwareConfiguration = ReadRegistryDwordW( hkeyDevice,REGSTR_VAL_HARDWARE_W,0);

    OSUtil_lstrcpyW(pDevPtr->szDeviceInternalName,pszDeviceName);

    //
    // Add strings
    //
    pwszBarrier = (LPWSTR)((LPBYTE)pDevPtr + pDevPtr->dwSize);

    //
    // Add strings
    //
    pwszBarrier = (LPWSTR)((LPBYTE)pDevPtr + pDevPtr->dwSize);

    if  (
         !PullFromRegistry(hkeyDevice, &pDevPtr -> pszVendorDescription,
         REGSTR_VAL_VENDOR_NAME_W, pwszBarrier, &pwszTargetString) ||

         !PullFromRegistry(hkeyDevice, &pDevPtr->pszLocalName,
         REGSTR_VAL_FRIENDLY_NAME_W, pwszBarrier, &pwszTargetString) ||

         !PullFromRegistry(hkeyDevice, &pDevPtr->pszDeviceDescription,
         REGSTR_VAL_DEVICE_NAME_W, pwszBarrier, &pwszTargetString) ||

         !PullFromRegistry(hkeyDevice, &pDevPtr->pszPortName,
         REGSTR_VAL_DEVICEPORT_W, pwszBarrier, &pwszTargetString) ||

         //!PullFromRegistry(hkeyDevice, &pDevPtr->pszTwainDataSource,
         //REGSTR_VAL_TWAIN_SOURCE_W, pwszBarrier, &pwszTargetString) ||
         //!PullFromRegistry(hkeyDevice, &pDevPtr->pszEventList,
         //REGSTR_VAL_EVENTS_W, pwszBarrier, &pwszTargetString) ||

         !PullFromRegistry(hkeyDevice, &pDevPtr->pszPropProvider,
         REGSTR_VAL_PROP_PROVIDER_W, pwszBarrier, &pwszTargetString)) {

        //  we ran out of memory, somewhere
        RegCloseKey(hkeyDevice);
        return  E_OUTOFMEMORY;

    }

#ifdef DEAD_CODE
    ReadRegistryString(hkeyDevice,REGSTR_VAL_VENDOR_NAME_W,L"",FALSE,&pwszNewString);

    pDevPtr->pszVendorDescription = NULL;

    if (pwszNewString) {

        if (!AddOneString(pwszBarrier,pwszNewString,&pwszTargetString)) {
            // Not enough room for next string
            hres = E_OUTOFMEMORY;
            goto Cleanup;
        }

        FreePv(pwszNewString);
        pwszNewString = NULL;

        pDevPtr->pszVendorDescription = pwszTargetString;
    }

    ReadRegistryString(hkeyDevice,REGSTR_VAL_DEV_NAME_W,L"",FALSE,&pwszNewString);
    if (!pwszNewString || !*pwszNewString) {
        FreePv(pwszNewString);
        pwszNewString = NULL;

        ReadRegistryString(hkeyDevice,REGSTR_VAL_DRIVER_DESC_W,L"",FALSE,&pwszNewString);
    }

    pDevPtr->pszLocalName = NULL;

    if (pwszNewString) {

        if (!AddOneString(pwszBarrier,pwszNewString,&pwszTargetString)) {
            // Not enough room for next string
            hres = E_OUTOFMEMORY;
            goto Cleanup;
        }

        FreePv(pwszNewString);
        pwszNewString = NULL;

        pDevPtr->pszLocalName = pwszTargetString;
    }
#endif

    *ppCurrentDevPtr += 1;
    *ppwszCurrentString = pwszTargetString;

#ifdef DEAD_CODE
Cleanup:
    if (pwszNewString) {
        FreePv(pwszNewString);
    }
#endif

    RegCloseKey(hkeyDevice);

    return S_OK;

}

/**************************************************************************\
* GetDeviceInfoHelperWIA
*
*   get WIA info as well
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/6/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP
GetDeviceInfoHelperWIA(
    LPWSTR                       pszDeviceName,
    PSTI_WIA_DEVICE_INFORMATION *ppCurrentDevPtr,
    PWSTR                       *ppwszCurrentString
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;

    HKEY    hkeyDevice;
    HKEY    hkeyDeviceData;

    PSTI_WIA_DEVICE_INFORMATION pDevPtr = *ppCurrentDevPtr;
    PWSTR   pwszBarrier;

    PWSTR   pwszTargetString =  *ppwszCurrentString;

    DWORD   dwMajorType,dwMinorType;

    BOOL bRet;

    // Open device registry key

    hres = OpenDeviceRegistryKey(pszDeviceName,NULL,&hkeyDevice);

    if (!SUCCEEDED(hres)) {
        return hres;
    }

    //
    // open DeviceData field
    //

    hres = OpenDeviceRegistryKey(pszDeviceName,L"DeviceData",&hkeyDeviceData);

    if (!SUCCEEDED(hres)) {
        RegCloseKey(hkeyDevice);
        return hres;
    }

    //
    // Read flags and strings
    //

    pDevPtr->dwSize     = cbX(STI_WIA_DEVICE_INFORMATION);

    dwMajorType = dwMinorType = 0;

    ZeroX(pDevPtr->DeviceCapabilities) ;
    ZeroX(pDevPtr->dwHardwareConfiguration) ;

    dwMajorType = (STI_DEVICE_TYPE)ReadRegistryDwordW( hkeyDevice,REGSTR_VAL_DEVICETYPE_W,StiDeviceTypeDefault);
    dwMinorType = (STI_DEVICE_TYPE)ReadRegistryDwordW( hkeyDevice,REGSTR_VAL_DEVICESUBTYPE_W,0);

    pDevPtr->DeviceCapabilities.dwGeneric = ReadRegistryDwordW( hkeyDevice,REGSTR_VAL_GENERIC_CAPS_W,0);

    pDevPtr->DeviceType = MAKELONG(dwMinorType,dwMajorType);

    pDevPtr->dwHardwareConfiguration = ReadRegistryDwordW( hkeyDevice,REGSTR_VAL_HARDWARE_W,0);

    OSUtil_lstrcpyW(pDevPtr->szDeviceInternalName,pszDeviceName);

    //
    // Add strings
    //
    pwszBarrier = (LPWSTR)((LPBYTE)pDevPtr + pDevPtr->dwSize);

    bRet = PullFromRegistry(hkeyDevice, &pDevPtr ->pszVendorDescription,
                            REGSTR_VAL_VENDOR_NAME_W, pwszBarrier, &pwszTargetString);

    if (!bRet) {
        goto InfoCleanup;
    }

    bRet = PullFromRegistry(hkeyDevice, &pDevPtr->pszLocalName,
                            REGSTR_VAL_FRIENDLY_NAME_W, pwszBarrier, &pwszTargetString);

    if (!bRet) {
        goto InfoCleanup;
    }

    bRet = PullFromRegistry(hkeyDevice, &pDevPtr->pszDeviceDescription,
                            REGSTR_VAL_DEVICE_NAME_W, pwszBarrier, &pwszTargetString);
    if (!bRet) {
        goto InfoCleanup;
    }

    bRet = PullFromRegistry(hkeyDevice, &pDevPtr->pszPortName,
                            REGSTR_VAL_DEVICEPORT_W, pwszBarrier, &pwszTargetString);
    if (!bRet) {
        goto InfoCleanup;
    }

    bRet = PullFromRegistry(hkeyDevice, &pDevPtr->pszPropProvider,
                            REGSTR_VAL_PROP_PROVIDER_W, pwszBarrier, &pwszTargetString);
    if (!bRet) {
        goto InfoCleanup;
    }

    //
    // WIA VALUES
    //

    bRet = PullFromRegistry(hkeyDeviceData, &pDevPtr->pszServer,
                            WIA_DIP_SERVER_NAME_STR, pwszBarrier, &pwszTargetString);
    if (!bRet) {
        goto InfoCleanup;
    }

    *ppCurrentDevPtr += 1;
    *ppwszCurrentString = pwszTargetString;

    RegCloseKey(hkeyDeviceData);
    RegCloseKey(hkeyDevice);

    return S_OK;

InfoCleanup:

    //
    //  we ran out of memory, somewhere
    //

    RegCloseKey(hkeyDevice);
    RegCloseKey(hkeyDeviceData);
    return  E_OUTOFMEMORY;
}

/*
 * Setting device information helper
 *
 */
STDMETHODIMP
SetDeviceInfoHelper(
    PSTI_DEVICE_INFORMATION pDevPtr
    )
{
    HRESULT hres = S_OK;
    HKEY    hkeyDevice;

    PWSTR   pwszNewString = NULL;

    DWORD   dwHardwareConfiguration;
    DWORD   dwError;

    if (!pDevPtr || OSUtil_StrLenW(pDevPtr->szDeviceInternalName) > STI_MAX_INTERNAL_NAME_LENGTH) {
        return STIERR_INVALID_PARAM;
    }

    //
    // Open device registry key
    //
    hres = OpenDeviceRegistryKey(pDevPtr->szDeviceInternalName,NULL,&hkeyDevice);

    if (!SUCCEEDED(hres)) {
        return STIERR_INVALID_DEVICE_NAME;
    }

    ZeroX(dwHardwareConfiguration) ;
    dwHardwareConfiguration = ReadRegistryDwordW( hkeyDevice,REGSTR_VAL_HARDWARE_W,0);

    #ifdef NOT_IMPL
    //
    // Changing device information by caller is allowed only for Unknown device types
    // For all others settings are handled by setup and control panel
    //
    if (dwHardwareConfiguration != STI_HW_CONFIG_UNKNOWN ) {
        hres = STIERR_INVALID_HW_TYPE;
        goto Cleanup;
    }
    #endif

    //
    // Store new port name, and new FriendlyName
    //


    if (!IsBadStringPtrW(pDevPtr->pszPortName, MAX_PATH * sizeof(WCHAR))) {
        dwError = WriteRegistryStringW(hkeyDevice ,
                                       REGSTR_VAL_DEVICEPORT_W,
                                       pDevPtr->pszPortName,
                                       (OSUtil_StrLenW(pDevPtr->pszPortName)+1)*sizeof(WCHAR),
                                       REG_SZ
                                       );
        if ((dwError == ERROR_SUCCESS) &&
            !(IsBadStringPtrW(pDevPtr->pszLocalName, MAX_PATH * sizeof(WCHAR)))) {

            dwError = WriteRegistryStringW(hkeyDevice ,
                                       REGSTR_VAL_FRIENDLY_NAME_W,
                                       pDevPtr->pszLocalName,
                                       (OSUtil_StrLenW(pDevPtr->pszLocalName)+1)*sizeof(WCHAR),
                                       REG_SZ
                                       );
            if (dwError == ERROR_SUCCESS) {
                hres = S_OK;
            }
        }

        if (dwError != ERROR_SUCCESS) {
            hres = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);
        }
    }
    else {
        hres = STIERR_INVALID_PARAM;
        goto Cleanup;
    }


Cleanup:
    if (pwszNewString) {
        FreePv(pwszNewString);
    }

    RegCloseKey(hkeyDevice);

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IStillImage | IsStillImageDeviceRegistryNode |
 *
 *      Verifies if given enumeration registry node is associated with Still Image device
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @returns
 *
 *      TRUE if node is representing still image devie
 *
 *  No validation performed
 *
 *****************************************************************************/
BOOL  WINAPI
IsStillImageDeviceRegistryNode(
    LPTSTR   ptszDeviceKey
    )
{
    BOOL                fRet = FALSE;
    DWORD               dwError;

    HKEY                hkeyDevice = NULL;
    HKEY                hkeyDeviceParameters = NULL;

    TCHAR               szDevClass[64]; //  NOTE:  This technically shouldn't be a 
                                        //  hardcoded number, we should do a RegQueryValueEx
                                        //  to get the required size, allocate the memory,
                                        //  and then call RegQueryValueEx for the data.
                                        //  However, if either the class name or image name
                                        //  cannot fit into this buffer, we know it doesn't
                                        //  belong to us, so this is OK.
    TCHAR               szDevDriver[STI_MAX_INTERNAL_NAME_LENGTH];
    TCHAR               szDeviceKey[MAX_PATH];

    ULONG               cbData;

    //
    // Open enumeration registry key
    //
    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,         // hkey
                           ptszDeviceKey,              // reg entry string
                           0,                          // dwReserved
                           KEY_READ,                   // access
                           &hkeyDevice);               // pHkeyReturned.

    if (ERROR_SUCCESS != dwError) {
        return FALSE;
    }

    //
    // First check it's class . It should be equal to "Image"
    //
    cbData = sizeof(szDevClass);
    *szDevClass = TEXT('\0');
    if ((RegQueryValueEx(hkeyDevice,
                         REGSTR_VAL_CLASS,
                         NULL,
                         NULL,
                         (PBYTE)szDevClass,
                         &cbData) != ERROR_SUCCESS) ||
                        (lstrcmpi(szDevClass, CLASSNAME) != 0)) {
        fRet = FALSE;
        goto CleanUp;
    }

    //
    // Now we check subclass in one of two locations: either in enumeration subkey, or in
    // control subkey
    //
    cbData = sizeof(szDevClass);
    if (RegQueryValueEx(hkeyDevice,
                         REGSTR_VAL_SUBCLASS,
                         NULL,
                         NULL,
                         (PBYTE)szDevClass,
                         &cbData) == ERROR_SUCCESS) {

        fRet = (lstrcmpi(szDevClass, STILLIMAGE) == 0)  ? TRUE : FALSE;
        goto CleanUp;
    }

    cbData = sizeof(szDevDriver);
    dwError = RegQueryValueEx(hkeyDevice,
                        REGSTR_VAL_DRIVER,
                        NULL,
                        NULL,
                        (PBYTE)szDevDriver,
                        &cbData);
    if (ERROR_SUCCESS != dwError ) {
        goto CleanUp;
    }

    lstrcat(lstrcpy(szDeviceKey,
                    (g_NoUnicodePlatform) ? REGSTR_PATH_STIDEVICES : REGSTR_PATH_STIDEVICES_NT),
           TEXT("\\"));

    lstrcat(szDeviceKey,szDevDriver);

    dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                        szDeviceKey,
                        0L,
                        NULL,
                        0L,
                        KEY_READ,
                        NULL,
                        &hkeyDeviceParameters,
                        NULL
                        );
    if (ERROR_SUCCESS != dwError) {
        goto CleanUp;
    }

    cbData = sizeof(szDevClass);
    dwError = RegQueryValueEx(hkeyDeviceParameters,
                         REGSTR_VAL_SUBCLASS,
                         NULL,
                         NULL,
                         (PBYTE)szDevClass,
                         &cbData);
    if (ERROR_SUCCESS == dwError) {

        fRet = (lstrcmpi(szDevClass, STILLIMAGE) == 0)  ? TRUE : FALSE;
        goto CleanUp;
    }

CleanUp:
    if (hkeyDevice) {
        RegCloseKey(hkeyDevice);
        hkeyDevice = NULL;
    }

    if (hkeyDeviceParameters) {
        RegCloseKey(hkeyDeviceParameters);
        hkeyDeviceParameters = NULL;
    }

    return fRet;

} // endproc IsStillImageDeviceRegistryNode

/*
DWORD
EnumNextLevel(
    LPSTR   *ppCurrentDevPtr,
    LPWSTR  *ppwszCurrentString,
    DWORD   *pdwItemsReturned,
    BOOL    *pfAlreadyEnumerated,
    LPSTR   pszDeviceKey,
    int     Level
    )
{


    HKEY                hkeyDevice;

    char                szDevDriver[STI_MAX_INTERNAL_NAME_LENGTH];
    WCHAR               wszDeviceKey[MAX_PATH];

    ULONG               cbString;
    ULONG               cbData;
    DWORD               dwIndex;
    DWORD               dwError;
    DEVINST             dnDevNode;
    USHORT              cbEnumPath;
    HANDLE              hDevInfo;
    GUID                Guid;
    DWORD               dwRequired;
    DWORD               Idx;
    SP_DEVINFO_DATA     spDevInfoData;
    DWORD               dwConfigFlags;

    dwError = 0;

    if (Level == 0) {

        if(!IsStillImageDeviceRegistryNodeA(pszDeviceKey)) {
            //
            // Nobody there...continue with the enumeration
            //
            return 0;
        }

        dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,         // hkey
                               pszDeviceKey,               // reg entry string
                               0,                          // dwReserved
                               KEY_READ,                    // access
                               &hkeyDevice);               // pHkeyReturned.

        if (dwError != ERROR_SUCCESS) {
            return 0;
        }

        dnDevNode = 0;

        cbEnumPath = ((g_NoUnicodePlatform) ? lstrlen(REGSTR_PATH_ENUM) : lstrlen(REGSTR_PATH_NT_ENUM_A)) + 1;

        CM_Locate_DevNode (&dnDevNode, pszDeviceKey + cbEnumPath, 0);

        if (dnDevNode == 0 && *pfAlreadyEnumerated == FALSE) {

            #ifdef NODEF
            //
            //  This is dead code, it should be removed.
            //

            //
            // Try to locate this devnode by forcing a re-enumeration.
            //
            if (SetupDiClassGuidsFromName (REGSTR_KEY_SCSI_CLASS, &Guid, sizeof(GUID), &dwRequired)) {

                hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, 0);

                if (hDevInfo != INVALID_HANDLE_VALUE) {

                    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);

                    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

                        CM_Reenumerate_DevNode (spDevInfoData.DevInst, CM_REENUMERATE_SYNCHRONOUS);

                    }

                }

                SetupDiDestroyDeviceInfoList (hDevInfo);
            }
            #endif

            //
            // Try again to locate our devnode.
            //

            *pfAlreadyEnumerated = TRUE;

            CM_Locate_DevNode (&dnDevNode, pszDeviceKey + cbEnumPath, 0);

            if (dnDevNode == 0) {

                //
                // Skip this one.
                //
                RegCloseKey(hkeyDevice);
                return 0;
            }
        }

        //
        // Check that this device is in the current hardware profile
        //

        dwConfigFlags = 0;

        CM_Get_HW_Prof_Flags (pszDeviceKey + cbEnumPath, 0, &dwConfigFlags, 0);

        if (dwConfigFlags & CSCONFIGFLAG_DO_NOT_CREATE) {

            //
            // Skip this one.
            //
            RegCloseKey(hkeyDevice);
            return 0;
        }

        cbData = sizeof(szDevDriver);
        if ((RegQueryValueEx(hkeyDevice, REGSTR_VAL_DRIVER, NULL, NULL, szDevDriver,
                          &cbData) == ERROR_SUCCESS)) {

            //
            // Got one device - add it to the buffer
            //
            AToU(wszDeviceKey,sizeof(wszDeviceKey)/sizeof(WCHAR),szDevDriver);
            dwError = (DWORD)GetDeviceInfoHelper(wszDeviceKey,
                                    (PSTI_DEVICE_INFORMATION *)ppCurrentDevPtr,
                                    ppwszCurrentString);
            if (!SUCCEEDED(dwError)) {

                RegCloseKey(hkeyDevice);

                //
                //  Return value is HRESULT, we should return a Win32 error
                //
                if (dwError == E_OUTOFMEMORY) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    return ERROR_INVALID_DATA;
                }
            }

            (*pdwItemsReturned)++;
            RegCloseKey(hkeyDevice);
            return 0;

        }

        RegCloseKey(hkeyDevice);
        return 0;
    }

    cbString = lstrlen(pszDeviceKey);

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,         // hkey
                           pszDeviceKey,               // reg entry string
                           0,                          // dwReserved
                           KEY_READ,                   // access
                           &hkeyDevice);               // pHkeyReturned.

    for (dwIndex = 0; dwError == ERROR_SUCCESS; dwIndex++) {

        *(pszDeviceKey + cbString) = '\\';
        cbData = MAX_PATH - cbString - 1;

        dwError = RegEnumKey(hkeyDevice,
                             dwIndex,
                             &pszDeviceKey[cbString+1],
                             cbData);

        if (dwError == ERROR_SUCCESS) {
            if ((dwError = EnumNextLevel (ppCurrentDevPtr,
                                          ppwszCurrentString,
                                          pdwItemsReturned,
                                          pfAlreadyEnumerated,
                                          pszDeviceKey,
                                          Level - 1)) != ERROR_SUCCESS) {

                RegCloseKey(hkeyDevice);
                pszDeviceKey[cbString] = '\0';
                return (dwError);

            }
        }
    }

    RegCloseKey(hkeyDevice);
    pszDeviceKey[cbString] = '\0';
    return(0);
}
*/

DWORD
EnumFromSetupApi(
    LPSTR   *ppCurrentDevPtr,
    LPWSTR  *ppwszCurrentString,
    DWORD   *pdwItemsReturned
    )
{

    HANDLE                  hDevInfo;
    GUID                    Guid = GUID_DEVCLASS_IMAGE;
    DWORD                   dwRequired;
    DWORD                   Idx;
    SP_DEVINFO_DATA         spDevInfoData;
    SP_DEVICE_INTERFACE_DATA   spDevInterfaceData;
    HKEY                    hKeyDevice;
    char                    szDevDriver[STI_MAX_INTERNAL_NAME_LENGTH];
    TCHAR                   tszDevClass[32];
    WCHAR                   wszDeviceKey[MAX_PATH];
    ULONG                   cbData;
    DWORD                   dwError;
    DWORD                   dwReturn;
    DWORD                   dwType;
    DWORD                   dwKeyType;

    BOOL                    fRet;
    LONG                    lRet;

    PWIA_DEVKEYLIST         pWiaDevKeyList;

    dwRequired  = 0;
    dwError     = ERROR_SUCCESS;
    dwReturn    = ERROR_NO_MATCH;
    
    pWiaDevKeyList  = NULL;

    //
    // Get the class device list
    //

    pWiaDevKeyList = WiaCreateDeviceRegistryList(TRUE);
    if(NULL != pWiaDevKeyList){

        for (Idx = 0; Idx < pWiaDevKeyList->dwNumberOfDevices; Idx++) {

            //
            // Check whether we have space for this device inside the device list.
            // NOTE:  This will change when the device list size becomes dynamic
            //

            if (((Idx + 1) * max(DEVICE_INFO_SIZE, WIA_DEVICE_INFO_SIZE)) > DEVICE_LIST_SIZE) {
                break;
            }

            //
            //  Now get all the device info
            //
            
            cbData = sizeof(szDevDriver);
            *szDevDriver = '\0';
            dwError = RegQueryValueExA(pWiaDevKeyList->Dev[Idx].hkDeviceRegistry,
                                       REGSTR_VAL_DEVICE_ID_A,
//                                       REGSTR_VAL_FRIENDLY_NAME_A,
                                       NULL,
                                       NULL,
                                       (LPBYTE)szDevDriver,
                                       &cbData);
            if(ERROR_SUCCESS == dwError){

                AToU(wszDeviceKey,sizeof(wszDeviceKey)/sizeof(WCHAR),szDevDriver);

                dwError = (DWORD)GetDeviceInfoHelper(wszDeviceKey,
                                                     (PSTI_DEVICE_INFORMATION *)ppCurrentDevPtr, 
                                                     ppwszCurrentString);
                if (!SUCCEEDED(dwError)) {

                    //
                    //  dwError is an HRESULT, we should return a Win32 error
                    //
                    if (dwError == E_OUTOFMEMORY) {
                        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                    } else {
                        dwReturn = ERROR_INVALID_DATA;
                    }
                    break;
                } else {
                    
                    //
                    // At least one device passed.
                    //
                    
                    dwReturn = ERROR_SUCCESS;
                }

                (*pdwItemsReturned)++;
            } else { // if(ERROR_SUCCESS == dwError)

            } // if(ERROR_SUCCESS == dwError)
        } // for (Idx = 0; pWiaDevKeyList->dwNumberOfDevices; Idx++) 
    } // if(NULL != pWiaDevKeyList)

    //
    // Free device registry list.
    //
        
    if(NULL != pWiaDevKeyList){
        WiaDestroyDeviceRegistryList(pWiaDevKeyList);
    }

    return (dwReturn);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IStillImage | BuildDeviceListHelper |
 *
 *          Fills passed buffer with list of available still image devices
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

// BUGBUG does not honor filter flags

STDMETHODIMP
BuildDeviceListHelper(
    DWORD   dwType,
    DWORD   dwFlags,
    DWORD   *pdwItemsReturned,
    LPVOID  *ppBuffer
    )
{

    HRESULT                 hres;
    DWORD                   dwError;
    LPSTR                   pCurrentDevPtr;
    LPWSTR                  pwszCurrentString;
    BOOL                    fAlreadyEnumerated;

    *pdwItemsReturned = 0;
    *ppBuffer = NULL;
    hres = S_OK;

    // Get initial buffer for return data
    hres = AllocCbPpv(DEVICE_LIST_SIZE, ppBuffer);
    if (!SUCCEEDED(hres)) {
        return E_OUTOFMEMORY;
    }

    hres = S_OK;

    //
    // Re-enumerate parallel device if it's installed and not detected on OS boot.
    //

    if(0 == dwFlags){
        
        //
        // Enumerate LPT port via WIA service.
        //

        SC_HANDLE       hSCM;
        SC_HANDLE       hService;
        SERVICE_STATUS  ServiceStatus;

        __try  {

            //
            // Open Service Control Manager.
            //

            hSCM = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT);
            if (!hSCM) {
                dwError = GetLastError();
                __leave;
            }

            //
            // Open WIA service.
            //

            hService = OpenService(
                                hSCM,
                                STI_SERVICE_NAME,
                                SERVICE_USER_DEFINED_CONTROL
                                );
            if (!hService) {
                dwError = GetLastError();
                __leave;
            }
            
            //
            // Post custom service control message.
            //

            ControlService(hService, STI_SERVICE_CONTROL_LPTENUM, &ServiceStatus);

            //
            // Close service handle.
            //
            
            CloseServiceHandle(hService);
        } // __try  
        __finally {
            if(NULL != hSCM){
                CloseServiceHandle( hSCM );
            } // if(NULL != hSCM)
        } // __finally
    } // if(0 == dwFlags)


    //
    // NOTE: DEVICE_LIST_SIZE is hard coded for the time being.  Checks are done in
    // EnumFromSetupApi to ensure we never overrun this buffer.
    //

    pCurrentDevPtr = *ppBuffer;
    pwszCurrentString = (LPWSTR)(pCurrentDevPtr + DEVICE_LIST_SIZE);
    fAlreadyEnumerated = FALSE;

    dwError = EnumFromSetupApi (&pCurrentDevPtr,
                                &pwszCurrentString,
                                pdwItemsReturned);

    if (dwError != NOERROR) {
        hres = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);
        FreePpv(ppBuffer);
    }

    return hres;

}

BOOL
TranslateDeviceInfo(
    PSTI_DEVICE_INFORMATIONA pDest,
    LPSTR                   *pCurrentStringDest,
    PSTI_DEVICE_INFORMATIONW pSrc
    )
{

    LPSTR   pStringDest = *pCurrentStringDest;

    pDest->dwSize = cbX(STI_DEVICE_INFORMATIONA);
    pDest->DeviceType = pSrc->DeviceType;
    pDest->DeviceCapabilities = pSrc->DeviceCapabilities;
    pDest->dwHardwareConfiguration = pSrc->dwHardwareConfiguration;

    UToA(pDest->szDeviceInternalName,STI_MAX_INTERNAL_NAME_LENGTH,pSrc->szDeviceInternalName);

    UToA(pStringDest,MAX_PATH,pSrc->pszVendorDescription);
    pDest->pszVendorDescription = pStringDest;
    pStringDest+=lstrlenA(pStringDest)+sizeof(CHAR);

    UToA(pStringDest,MAX_PATH,pSrc->pszDeviceDescription);
    pDest->pszDeviceDescription = pStringDest;
    pStringDest+=lstrlenA(pStringDest)+sizeof(CHAR);

    UToA(pStringDest,MAX_PATH,pSrc->pszPortName);
    pDest->pszPortName  = pStringDest;
    pStringDest+=lstrlenA(pStringDest)+sizeof(CHAR);

    UToA(pStringDest,MAX_PATH,pSrc->pszPropProvider);
    pDest->pszPropProvider  = pStringDest;
    pStringDest+=lstrlenA(pStringDest)+sizeof(CHAR);

    UToA(pStringDest,MAX_PATH,pSrc->pszLocalName);
    pDest->pszLocalName = pStringDest;
    pStringDest+=lstrlenA(pStringDest)+sizeof(CHAR);

    *pCurrentStringDest = pStringDest;

    return TRUE;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | GetDeviceList |
 *
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c STIERR_NOINTERFACE> = <c E_NOINTERFACE>
 *          The specified interface is not supported by the object.
 *
 *          <c STIERR_DEVICENOTREG> = The device instance does not
 *          correspond to a device that is registered with StillImage.
 *
 *****************************************************************************/

STDMETHODIMP
CStiObj_GetDeviceListW(
    PV      pSti,
    DWORD   dwType,
    DWORD   dwFlags,
    DWORD   *pdwItemsReturned,
    LPVOID  *ppBuffer
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;

    EnterProcR(IStillImage::GetDeviceList,(_ "pp", pSti,ppBuffer ));

    // Validate passed pointer to interface and obtain pointer to object instance
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);

        if ( SUCCEEDED(hres = hresFullValidPdwOut_(ppBuffer, s_szProc, 5)) &&
             SUCCEEDED(hres = hresFullValidPdwOut_(pdwItemsReturned, s_szProc, 4))
             ) {
            hres = BuildDeviceListHelper(dwType,dwFlags,pdwItemsReturned,ppBuffer);

            if (!SUCCEEDED(hres) ) {
                FreePpv(ppBuffer);
            }
        }
    }

    ExitOleProc();
    return hres;
}


STDMETHODIMP
CStiObj_GetDeviceListA(
    PV    pSti,
    DWORD   dwType,
    DWORD   dwFlags,
    DWORD   *pdwItemsReturned,
    LPVOID  *ppBuffer
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;

    EnterProcR(IStillImage::GetDeviceList,(_ "pp", pSti,ppBuffer ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

        if ( SUCCEEDED(hres = hresFullValidPdwOut_(ppBuffer, s_szProc, 5)) &&
             SUCCEEDED(hres = hresFullValidPdwOut_(pdwItemsReturned, s_szProc, 4))
             ) {

            LPVOID      pvTempBuffer = NULL;
            UINT        uiSize;

            hres = BuildDeviceListHelper(dwType,dwFlags,pdwItemsReturned,&pvTempBuffer);

            if (SUCCEEDED(hres) ) {

                LPSTR   pStringDest;
                PSTI_DEVICE_INFORMATIONA pDest;
                PSTI_DEVICE_INFORMATIONW pSrc;
                UINT uiIndex;

                //
                // Allocate new buffer , transform data into ANSI and free scratch
                //

                uiSize = (UINT)LocalSize(pvTempBuffer);
                if (uiSize > 0 && pdwItemsReturned > 0) {

                    hres = AllocCbPpv(uiSize, ppBuffer);
                    if (SUCCEEDED(hres)) {

                        pDest = *ppBuffer;
                        pSrc = pvTempBuffer;
                        pStringDest = (LPSTR)(pDest+ *pdwItemsReturned);

                        for (uiIndex = 0;
                             uiIndex < *pdwItemsReturned;
                             uiIndex++) {

                            TranslateDeviceInfo(pDest,&pStringDest,pSrc);

                            pDest++, pSrc++;
                        }
                    }
                }

                FreePpv(&pvTempBuffer);
            }
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | GetDeviceInfo |
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm   REFGUID | rguid |
 *          Identifies the instance of the
 *          device for which the indicated interface
 *          is requested.  The <mf IStillImage::EnumDevices> method
 *          can be used to determine which instance GUIDs are supported by
 *          the system.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

STDMETHODIMP
CStiObj_GetDeviceInfoW(
    PV    pSti,
    LPWSTR  pwszDeviceName,
    LPVOID  *ppBuffer
    )
{

    HRESULT hres= STIERR_INVALID_PARAM;

    PSTI_DEVICE_INFORMATION pCurrentDevPtr;
    LPWSTR                  pwszCurrentString;

    EnterProcR(IStillImage::GetDeviceInfo,(_ "ppp", pSti,pwszDeviceName,ppBuffer ));

    // Validate passed pointer to interface and obtain pointer to object instance
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);

        // Get initial buffer for return data
        hres = AllocCbPpv(DEVICE_INFO_SIZE, ppBuffer);
        if (!SUCCEEDED(hres)) {
            return E_OUTOFMEMORY;
        }

        // Get information on this device calling helper routine
        pCurrentDevPtr = (PSTI_DEVICE_INFORMATION)*ppBuffer;
        pwszCurrentString = (LPWSTR)((LPBYTE)*ppBuffer+DEVICE_INFO_SIZE);

        hres=GetDeviceInfoHelper(pwszDeviceName,&pCurrentDevPtr,&pwszCurrentString);

        if (!SUCCEEDED(hres)) {
            FreePpv(ppBuffer);
        }

    }

    ExitOleProc();
    return hres;
}


STDMETHODIMP
CStiObj_GetDeviceInfoA(
    PV      pSti,
    LPCSTR  pszDeviceName,
    LPVOID  *ppBuffer
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;

    EnterProcR(IStillImage::GetDeviceInfo,(_ "ppp", pSti,pszDeviceName,ppBuffer ));

    // Validate passed pointer to interface and obtain pointer to object instance
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

        WCHAR   wszDeviceName[STI_MAX_INTERNAL_NAME_LENGTH] = {L'\0'};
        PVOID   pBuffer;

        AToU(wszDeviceName,STI_MAX_INTERNAL_NAME_LENGTH,pszDeviceName);

        hres = CStiObj_GetDeviceInfoW(pSti,wszDeviceName,&pBuffer);
        if (SUCCEEDED(hres)) {

            hres = AllocCbPpv(DEVICE_INFO_SIZE, ppBuffer);

            if (SUCCEEDED(hres)) {

                LPSTR   pStringDest = (LPSTR)*ppBuffer+sizeof(STI_DEVICE_INFORMATIONA);

                TranslateDeviceInfo((PSTI_DEVICE_INFORMATIONA)*ppBuffer,
                                    &pStringDest,
                                    (PSTI_DEVICE_INFORMATIONW)pBuffer);

                FreePpv(&pBuffer);
            }
        }
    }

    ExitOleProc();
    return hres;
}


/**************************************************************************\
* PrivateGetDeviceInfoW
*
*   Private server entry point to get WIA device info
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/7/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP
StiPrivateGetDeviceInfoHelperW(
    LPWSTR  pwszDeviceName,
    LPVOID  *ppBuffer
    )
{
    HRESULT hres = STIERR_INVALID_PARAM;
    LPWSTR  pwszCurrentString;

    PSTI_WIA_DEVICE_INFORMATION pCurrentDevPtr;

    //
    // Get initial buffer for return data
    //

    hres = AllocCbPpv(WIA_DEVICE_INFO_SIZE, ppBuffer);

    if (!SUCCEEDED(hres)) {
        return E_OUTOFMEMORY;
    }

    //
    // Get information on this device calling helper routine
    //

    pCurrentDevPtr = (PSTI_WIA_DEVICE_INFORMATION)*ppBuffer;
    pwszCurrentString = (LPWSTR)((LPBYTE)*ppBuffer+WIA_DEVICE_INFO_SIZE);

    hres=GetDeviceInfoHelperWIA(pwszDeviceName, &pCurrentDevPtr,&pwszCurrentString);

    if (!SUCCEEDED(hres)) {
        FreePpv(ppBuffer);
        *ppBuffer = NULL;
    } else
    {
        if (*ppBuffer) {
            if (OSUtil_StrLenW(((PSTI_WIA_DEVICE_INFORMATION) *ppBuffer)->pszServer) == 0)
            {
                //
                //  Assume that this is not a WIA device, since server name is
                //  blank.
                //

                FreePpv(ppBuffer);
                *ppBuffer = NULL;
            } else
            {
                //
                // set size of buffer so buffers can be chained independently
                //

                if (pCurrentDevPtr) {
                    pCurrentDevPtr->dwSize =  WIA_DEVICE_INFO_SIZE;
                }
            }
        }
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | SetDeviceValue |
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

STDMETHODIMP
CStiObj_SetDeviceValueW(
    PV    pSti,
    LPWSTR  pwszDeviceName,
    LPWSTR  pwszValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;
    HKEY    hkeyDevice;
    LONG    dwError;

    EnterProcR(IStillImage::SetDeviceValue,(_ "ppp", pSti,pwszDeviceName,pData ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);

        //
        // Open device registry key
        //
        hres = OpenDeviceRegistryKey(pwszDeviceName,REGSTR_VAL_DATA_W,&hkeyDevice);

        if (!SUCCEEDED(hres)) {
            return hres;
        }

        //
        // Implement set value
        //
        dwError = OSUtil_RegSetValueExW(hkeyDevice,
                                    pwszValueName,
                                    Type,
                                    pData,
                                    cbData,
                                    (this->dwVersion & STI_VERSION_FLAG_UNICODE) ? TRUE : FALSE);
        if (hkeyDevice) {
            RegCloseKey(hkeyDevice);
        }

        hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);

    }

    ExitOleProc();
    return hres;
}

STDMETHODIMP
CStiObj_SetDeviceValueA(
    PV      pSti,
    LPCSTR  pszDeviceName,
    LPCSTR  pszValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
    )
{

    HRESULT hres;
    HKEY    hkeyDevice;
    LONG    dwError;

    EnterProcR(IStillImage::SetDeviceValue,(_ "ppp", pSti,pszDeviceName,pData ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

        WCHAR   wszDeviceName[STI_MAX_INTERNAL_NAME_LENGTH] = {L'\0'};
        WCHAR   wszValueName[MAX_PATH] = {L'\0'};

        AToU(wszDeviceName,STI_MAX_INTERNAL_NAME_LENGTH,pszDeviceName);
        AToU(wszValueName,MAX_PATH,pszValueName);

        //
        // Open device registry key
        //
        hres = OpenDeviceRegistryKey(wszDeviceName,REGSTR_VAL_DATA_W,&hkeyDevice);

        if (SUCCEEDED(hres)) {

            //
            // Implement set value
            //
            dwError = OSUtil_RegSetValueExW(hkeyDevice,
                                        wszValueName,
                                        Type,
                                        pData,
                                        cbData,
                                        (this->dwVersion & STI_VERSION_FLAG_UNICODE) ? TRUE : FALSE);
            if (hkeyDevice) {
                RegCloseKey(hkeyDevice);
            }

            hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);
        }


    }

    ExitOleProc();
    return hres;
}

/****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | GetDeviceValue |
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

STDMETHODIMP
CStiObj_GetDeviceValueW(
    PV    pSti,
    LPWSTR  pwszDeviceName,
    LPWSTR  pwszValueName,
    LPDWORD pType,
    LPBYTE  pData,
    LPDWORD pcbData
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;

    HKEY    hkeyDevice;
    LONG    dwError;

    EnterProcR(IStillImage::GetDeviceValue,(_ "ppp", pSti,pwszDeviceName,pData ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);

        //
        // Open device registry key
        //
        hres = OpenDeviceRegistryKey(pwszDeviceName,REGSTR_VAL_DATA_W,&hkeyDevice);

        if (!SUCCEEDED(hres)) {
            return hres;
        }

        //
        // Implement get value
        //
        dwError = OSUtil_RegQueryValueExW(hkeyDevice,
                                    pwszValueName,
                                    pType,
                                    pData,
                                    pcbData,
                                    (this->dwVersion & STI_VERSION_FLAG_UNICODE) ? TRUE : FALSE);
        if (hkeyDevice) {
            RegCloseKey(hkeyDevice);
        }

        hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);

    }

    ExitOleProc();
    return hres;
}

STDMETHODIMP
CStiObj_GetDeviceValueA(
    PV    pSti,
    LPCSTR  pszDeviceName,
    LPCSTR  pszValueName,
    LPDWORD pType,
    LPBYTE  pData,
    LPDWORD pcbData
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;
    HKEY    hkeyDevice;
    LONG    dwError;


    EnterProcR(IStillImage::GetDeviceValue,(_ "ppp", pSti,pszDeviceName,pData ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

        LPWSTR  pwszDevName  = NULL;

        hres = OSUtil_GetWideString(&pwszDevName,pszDeviceName);
        if (SUCCEEDED(hres)) {

            //
            // Open device registry key
            //
            hres = OpenDeviceRegistryKey(pwszDevName,REGSTR_VAL_DATA_W,&hkeyDevice);

            if (SUCCEEDED(hres)) {

                //
                // Implement get value
                //
                dwError = RegQueryValueExA(hkeyDevice,
                                          pszValueName,
                                          0,
                                          pType,
                                          pData,
                                          pcbData);
                if (hkeyDevice) {
                    RegCloseKey(hkeyDevice);
                }

                hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);
            }
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | GetSTILaunchInformation |
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

STDMETHODIMP
CStiObj_GetSTILaunchInformationW(
    PV    pSti,
    WCHAR   *pwszDeviceName,
    DWORD   *pdwEventCode,
    WCHAR   *pwszEventName
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;

    EnterProcR(IStillImage::GetSTILaunchInformation,(_ "pppp", pSti,pwszDeviceName,pdwEventCode,pwszEventName ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);

        //
        // Parse process command line to check if there is STI information
        //
        hres = ExtractCommandLineArgumentW("StiDevice",pwszDeviceName);
        if (SUCCEEDED(hres) ) {
            hres = ExtractCommandLineArgumentW("StiEvent",pwszEventName);
        }
    }

    ExitOleProc();
    return hres;
}

STDMETHODIMP
CStiObj_GetSTILaunchInformationA(
    PV    pSti,
    LPSTR  pszDeviceName,
    DWORD   *pdwEventCode,
    LPSTR   pszEventName
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;

    EnterProcR(IStillImage::GetSTILaunchInformation,(_ "pppp", pSti,pszDeviceName,pdwEventCode,pszEventName ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

        hres = ExtractCommandLineArgumentA("StiDevice",pszDeviceName);
        if (SUCCEEDED(hres) ) {
            hres = ExtractCommandLineArgumentA("StiEvent",pszEventName);
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | RegisterLaunchApplication |
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

static WCHAR    szSTICommandLineTail[] = {L" /StiDevice:%1 /StiEvent:%2"};
static CHAR     szSTICommandLineTail_A[] = {" /StiDevice:%1 /StiEvent:%2"};

STDMETHODIMP
CStiObj_RegisterLaunchApplicationW(
    PV    pSti,
    LPWSTR  pwszAppName,
    LPWSTR  pwszCommandLine
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwErr = 0;

    DWORD   dwCommandLineLength, cbNewLength;

    LPWSTR  pszWide = NULL;

    HKEY    hkeyApps;
    CHAR    szAppName[MAX_PATH] = {'\0'};
    CHAR    szCmdLine[MAX_PATH] = {'\0'};

    EnterProcR(IStillImage::RegisterLaunchApplication,(_ "ppp", pSti,pwszAppName,pwszCommandLine ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);

        if (pwszCommandLine && *pwszCommandLine &&
            pwszAppName && *pwszAppName
           ) {

            //
            // Add STI formatiing tail to the command line
            //

            dwCommandLineLength = OSUtil_StrLenW(pwszCommandLine);
            cbNewLength = ((dwCommandLineLength+1) + OSUtil_StrLenW(szSTICommandLineTail) + 1)*sizeof(WCHAR) ;

            hres = AllocCbPpv(cbNewLength, (PPV)&pszWide);

            if (pszWide) {

                HRESULT hresCom ;

                // Need to initialize COM apartment to call WIA event registration
                hresCom = CoInitialize(NULL);

                OSUtil_lstrcpyW(pszWide,pwszCommandLine);
                OSUtil_lstrcatW(pszWide,szSTICommandLineTail);

                dwErr = OSUtil_RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                                    REGSTR_PATH_REG_APPS_W,
                                    0L,
                                    NULL,
                                    0L,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hkeyApps,
                                    NULL
                                    );

                if (NOERROR == dwErr ) {

                    WriteRegistryStringW(hkeyApps,
                                         pwszAppName ,
                                         pszWide,
                                         cbNewLength,
                                         REG_SZ);

                    RegCloseKey(hkeyApps);
                }

                //
                // Register for standard WIA events on all devices , setting as non default
                //

                if (WideCharToMultiByte(CP_ACP,
                                    0,
                                    pwszAppName,
                                    -1,
                                    szAppName,
                                    MAX_PATH,
                                    NULL,
                                    NULL)) {
                    if (WideCharToMultiByte(CP_ACP,
                                    0,
                                    pszWide,
                                    -1,
                                    szCmdLine,
                                    MAX_PATH,
                                    NULL,
                                    NULL)) {

                        hres = RunRegisterProcess(szAppName, szCmdLine);
                    } else {
                        hres = E_FAIL;
                    }
                } else {
                    hres = E_FAIL;
                }
                
                


                FreePpv(&pszWide);

                // Balance apartment initiazation
                if ((S_OK == hresCom) || (S_FALSE == hresCom)) {
                    CoUninitialize();
                }

                hres = (dwErr == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwErr);

            }
            else {
                DebugOutPtszV(DbgFl, TEXT("Could not get unicode string -- out of memory"));
                hres =  E_OUTOFMEMORY;
            }
        }
        else {
            hres = STIERR_INVALID_PARAM;
        }
    }

    ExitOleProc();
    return hres;
}

STDMETHODIMP
CStiObj_RegisterLaunchApplicationA(
    PV      pSti,
    LPCSTR  pszAppName,
    LPCSTR  pszCommandLine
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwErr = 0;

    DWORD   dwCommandLineLength, cbNewLength;

    LPWSTR  pszWide = NULL;

    HKEY    hkeyApps;

    EnterProcR(IStillImage::RegisterLaunchApplication,(_ "ppp", pSti,pszAppName,pszCommandLine ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

            // Add STI formatiing tail to the command line
            //
        if (pszCommandLine && *pszCommandLine &&
            pszAppName && *pszAppName
           ) {

            LPSTR   pszBuffer;

            // Add STI formatiing tail to the command line
            //
            dwCommandLineLength = lstrlenA(pszCommandLine);
            cbNewLength = ((dwCommandLineLength+1) + OSUtil_StrLenW(szSTICommandLineTail) + 1)*sizeof(WCHAR) ;

            hres = AllocCbPpv(cbNewLength, (PPV)&pszBuffer);

            if (pszBuffer) {

                lstrcpyA(pszBuffer,pszCommandLine);
                UToA(pszBuffer+lstrlenA(pszBuffer),
                     (cbNewLength - dwCommandLineLength),
                     szSTICommandLineTail);

                dwErr = RegCreateKeyExA(HKEY_LOCAL_MACHINE,
                                    REGSTR_PATH_REG_APPS_A,
                                    0L,
                                    NULL,
                                    0L,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hkeyApps,
                                    NULL
                                    );

                if (NOERROR == dwErr ) {

                    WriteRegistryStringA(hkeyApps,
                                         pszAppName ,
                                         pszBuffer,
                                         lstrlenA(pszBuffer)+1,
                                         REG_SZ);

                    RegCloseKey(hkeyApps);
                }

                {
                    //
                    // Register for standard WIA events on all devices , setting as non default
                    //
                    PVOID   pWideCMDLine = NULL;
                    UINT    uiSize = (lstrlenA(pszBuffer)+1)*sizeof(WCHAR);
                    CHAR    szCmdLine[MAX_PATH] = {'\0'};

                    //
                    // Make sure we wont overrun our buffer
                    //
                    if ((lstrlenA(szCmdLine) + lstrlenA(szSTICommandLineTail_A) + lstrlenA(" ") + sizeof('\0')) 
                        < (MAX_PATH)) {

                        lstrcatA(szCmdLine, pszCommandLine);
                        lstrcatA(szCmdLine, " ");
                        lstrcatA(szCmdLine, szSTICommandLineTail_A);
                        dwErr = (DWORD) RunRegisterProcess((LPSTR)pszAppName, szCmdLine);
                    } else {
                        dwErr = (DWORD) E_INVALIDARG;
                    }
                }

                FreePpv(&pszBuffer);

                hres = (dwErr == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwErr);

            }
            else {
                DebugOutPtszV(DbgFl,TEXT("Could not get unicode string -- out of memory"));
                hres =  E_OUTOFMEMORY;
            }
        }
        else {
            hres = STIERR_INVALID_PARAM;
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | RegisterLaunchApplication |
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

STDMETHODIMP
CStiObj_UnregisterLaunchApplicationW(
    PV    pSti,
    LPWSTR  pwszAppName
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwErr;

    HKEY    hkeyApps;

    EnterProcR(IStillImage::UnregisterLaunchApplication,(_ "pp", pSti,pwszAppName ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);


        dwErr = OSUtil_RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                REGSTR_PATH_REG_APPS_W,
                                0L,
                                KEY_ALL_ACCESS,
                                &hkeyApps
                                );

        if (NOERROR == dwErr ) {

            OSUtil_RegDeleteValueW(hkeyApps,pwszAppName);

            RegCloseKey(hkeyApps);
        }

        hres = (dwErr == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwErr);

    }

    ExitOleProc();
    return hres;
}


STDMETHODIMP
CStiObj_UnregisterLaunchApplicationA(
    PV      pSti,
    LPCSTR  pszAppName
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwErr;

    HKEY    hkeyApps;

    EnterProcR(IStillImage::UnregisterLaunchApplication,(_ "pp", pSti,pszAppName ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

        dwErr = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                              REGSTR_PATH_REG_APPS_A,
                              0L,
                              KEY_ALL_ACCESS,
                              &hkeyApps
                              );

        if (NOERROR == dwErr ) {

            RegDeleteValueA(hkeyApps,pszAppName);

            RegCloseKey(hkeyApps);
        }

        hres = (dwErr == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwErr);


    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | LaunchApplicationForDevice |
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

STDMETHODIMP
CStiObj_LaunchApplicationForDeviceW(
    PV      pSti,
    LPWSTR  pwszDeviceName,
    LPWSTR  pwszAppName,
    LPSTINOTIFY    pStiNotify
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwError ;

    EnterProcR(IStillImage::LaunchApplicationForDevice,(_ "pp", pSti,pwszAppName ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);

        dwError = RpcStiApiLaunchApplication(NULL,
                                      pwszDeviceName,
                                      pwszAppName,
                                      pStiNotify
                                      );

        hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);
    }

    ExitOleProc();
    return hres;
}

STDMETHODIMP
CStiObj_LaunchApplicationForDeviceA(
    PV    pSti,
    LPCSTR  pszDeviceName,
    LPCSTR  pszApplicationName,
    LPSTINOTIFY    pStiNotify
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwError;

    EnterProcR(IStillImage::LaunchApplicationForDevice,(_ "pp", pSti,pszApplicationName ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

        LPWSTR  pwszDevName  = NULL;
        LPWSTR  pwszAppName  = NULL;

        hres = OSUtil_GetWideString(&pwszDevName,pszDeviceName);
        if (SUCCEEDED(hres)) {
            hres = OSUtil_GetWideString(&pwszAppName,pszApplicationName);
            if (SUCCEEDED(hres)) {

                dwError = RpcStiApiLaunchApplication(NULL,
                                              pwszDevName,
                                              pwszAppName,
                                              pStiNotify
                                              );

                hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);
            }
        }

        FreePpv(&pwszAppName);
        FreePpv(&pwszDevName);
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | SetupDeviceParameters |
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/
STDMETHODIMP
CStiObj_SetupDeviceParametersW(
    PV          pSti,
    PSTI_DEVICE_INFORMATIONW pDevInfo
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;

    EnterProcR(IStillImage::SetupDeviceParameters,(_ "pp", pSti, pDevInfo));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);

        hres = SetDeviceInfoHelper(pDevInfo);
    }

    ExitOleProc();
    return hres;
}

STDMETHODIMP
CStiObj_SetupDeviceParametersA(
    PV  pSti,
    PSTI_DEVICE_INFORMATIONA pDevInfo
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;

    EnterProcR(IStillImage::SetupDeviceParameters,(_ "pp", pSti, pDevInfo));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

        hres = STIERR_UNSUPPORTED;
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | SetupDeviceParameters |
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/
STDMETHODIMP
CStiObj_WriteToErrorLogW(
    PV      pSti,
    DWORD   dwMessageType,
    LPCWSTR pwszMessage
    )
{

    HRESULT hres = S_OK;

    EnterProcR(IStillImage::WriteToErrorLog,(_ "pp", pSti, pwszMessage));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);

        //
        // Validate parameters here
        //
        if (SUCCEEDED(hres = hresFullValidReadPvCb(pwszMessage,2, 3))) {

#ifndef UNICODE
            //
            // Since we're ANSI, the ReportStiLogMessage is expecting an ANSI string,
            // but our message is UNICODE, so we must convert.
            // NOTE:  We never expect CStiObj_WriteToErrorLogW to be called if we're compiling
            //        ANSI, but just in case...
            //
            LPSTR   lpszANSI = NULL;

            if ( SUCCEEDED(OSUtil_GetAnsiString(&lpszANSI,pwszMessage))) {
                ReportStiLogMessage(g_hStiFileLog,
                                    dwMessageType,
                                    lpszANSI
                                    );
                FreePpv(&lpszANSI);
            }
#else
            ReportStiLogMessage(g_hStiFileLog,
                                dwMessageType,
                                pwszMessage      
                                );
#endif
        }

    }

    ExitOleProc();
    return hres;
}

STDMETHODIMP
CStiObj_WriteToErrorLogA(
    PV      pSti,
    DWORD   dwMessageType,
    LPCSTR  pszMessage
    )
{
    HRESULT hres = S_OK;

    EnterProcR(IStillImage::WriteToErrorLog,(_ "pp", pSti, pszMessage));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

        //
        // Validate parameters here
        //
        if (SUCCEEDED(hres = hresFullValidReadPvCb(pszMessage,2, 3))) {

#ifndef UNICODE
            ReportStiLogMessage(g_hStiFileLog,
                                dwMessageType,
                                pszMessage      
                                );
#else
            //
            // Since we're UNICODE, the ReportStiLogMessage is expecting a WideString,
            // but our message is ANSI, so we must convert.
            // NOTE:  We never expect CStiObj_WriteToErrorLogA to be called if we're compiling
            //        UNICODE, but just in case...
            //
            LPWSTR   lpwszWide = NULL;

            if ( SUCCEEDED(OSUtil_GetWideString(&lpwszWide,pszMessage))) {
                ReportStiLogMessage(g_hStiFileLog,
                                    dwMessageType,
                                    lpwszWide
                                    );
                FreePpv(&lpwszWide);
            }
#endif
        }

    }

    ExitOleProc();
    return hres;
}



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage |  |
 *
 *
 * To control state of notification handling. For polled devices this means state of monitor
 * polling, for true notification devices means enabling/disabling notification flow
 * from monitor to registered applications
 *
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

STDMETHODIMP
CStiObj_EnableHwNotificationsW(
    PV      pSti,
    LPCWSTR pwszDeviceName,
    BOOL    bNewState)
{

    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwError = NOERROR;

    EnterProcR(IStillImage::CStiObj_EnableHwNotifications,(_ "pp", pSti,pwszDeviceName ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);

        dwError = RpcStiApiEnableHwNotifications(NULL,
                                      pwszDeviceName,
                                      bNewState);

        hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);
    }

    ExitOleProc();
    return hres;
}

STDMETHODIMP
CStiObj_EnableHwNotificationsA(
    PV      pSti,
    LPCSTR  pszDeviceName,
    BOOL    bNewState)
{

    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwError = NOERROR;

    EnterProcR(IStillImage::CStiObj_EnableHwNotifications,(_ "pp", pSti,pszDeviceName ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

        LPWSTR pwszDeviceName=NULL ;

        hres = OSUtil_GetWideString(&pwszDeviceName,pszDeviceName);

        if (SUCCEEDED(hres)) {

            dwError = RpcStiApiEnableHwNotifications(NULL,
                                          pwszDeviceName,
                                          bNewState);

            hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);
        }

        FreePpv(&pwszDeviceName);
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage |  |
 *
 *
 * To control state of notification handling. For polled devices this means state of monitor
 * polling, for true notification devices means enabling/disabling notification flow
 * from monitor to registered applications
 *
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

STDMETHODIMP
CStiObj_GetHwNotificationStateW(
    PV      pSti,
    LPCWSTR pwszDeviceName,
    BOOL*   pbCurrentState)
{

    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwError  = NOERROR;

    EnterProcR(IStillImage::CStiObj_GetHwNotificationState,(_ "pp", pSti,pwszDeviceName ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);

        dwError = RpcStiApiGetHwNotificationState(NULL,
                                      pwszDeviceName,
                                      pbCurrentState);

        hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);

    }

    ExitOleProc();
    return hres;
}


STDMETHODIMP
CStiObj_GetHwNotificationStateA(
    PV      pSti,
    LPCSTR  pszDeviceName,
    BOOL*   pbCurrentState)
{

    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwError  = NOERROR;

    EnterProcR(IStillImage::CStiObj_GetHwNotificationState,(_ "pp", pSti,pszDeviceName ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

        LPWSTR pwszDeviceName=NULL ;

        hres = OSUtil_GetWideString(&pwszDeviceName,pszDeviceName);

        if (SUCCEEDED(hres)) {

            dwError = RpcStiApiGetHwNotificationState(NULL,
                                          pwszDeviceName,
                                          pbCurrentState);

            hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);
        }

        FreePpv(&pwszDeviceName);
    }

    ExitOleProc();
    return hres;
}



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | RefreshDeviceBus |
 *
 *
 *  When device is installed but not accessible, application may request bus refresh
 *  which in some cases will make device known. This is mainly used for nonPnP buses
 *  like SCSI, when device was powered on after PnP enumeration
 *
 *
 *
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

HRESULT
WINAPI
RefreshDeviceParentHelper(
    LPCWSTR     pwszDeviceName
    )
{

    HRESULT                 hres;
    DWORD                   dwError  = NOERROR;
    CONFIGRET               cmRetCode = CR_SUCCESS ;

    HANDLE                  hDevInfo;
    DEVINST                 hdevParent;

    GUID                    Guid = GUID_DEVCLASS_IMAGE;
    DWORD                   dwRequired;
    DWORD                   Idx;
    SP_DEVINFO_DATA         spDevInfoData;

    WCHAR                   szDevDriver[STI_MAX_INTERNAL_NAME_LENGTH];

    ULONG                   cbData;

    BOOL                    fRet;
    BOOL                    fFoundDriverNameMatch;

    dwRequired = 0;
    dwError = 0;

    //
    // Navigating through Setup API set
    // As we don't have reverse search to retrive device info handle , based on
    // driver name, we do exsaustive search. Number of imaging devices for given class ID
    // is never as large to make a problem.
    //
    //
    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_PRESENT | DIGCF_PROFILE);

    fFoundDriverNameMatch = FALSE;

    hres = STIERR_INVALID_DEVICE_NAME;

    if (hDevInfo != INVALID_HANDLE_VALUE) {

        spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);

        for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

            //
            //  Compare driver name
            //

            *szDevDriver = L'\0';
            fRet = SetupDiGetDeviceRegistryPropertyW (hDevInfo,
                                                     &spDevInfoData,
                                                     SPDRP_DRIVER,
                                                     NULL,
                                                     (LPBYTE)szDevDriver,
                                                     sizeof (szDevDriver),
                                                     &cbData
                                                     );


            if (fRet && !lstrcmpiW(szDevDriver,pwszDeviceName)) {

                fFoundDriverNameMatch = TRUE;
                break;

            }

        }

        if(fFoundDriverNameMatch) {

            //
            // Found instance for the device with matching driver name
            //

            hdevParent = 0;

            cmRetCode = CM_Get_Parent(&hdevParent,
                                      spDevInfoData.DevInst,
                                      0);

            dwError = GetLastError();

            if((CR_SUCCESS == cmRetCode) && hdevParent) {

                CM_Reenumerate_DevNode(hdevParent,CM_REENUMERATE_NORMAL );
                dwError = GetLastError();
            }

            hres = (dwError == NOERROR) ? S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,dwError);

        }
        else {
            hres = STIERR_INVALID_DEVICE_NAME;
        }

        //
        SetupDiDestroyDeviceInfoList (hDevInfo);

    }
    else {

        hres = STIERR_INVALID_DEVICE_NAME;

    }

    return hres;

}

STDMETHODIMP
CStiObj_RefreshDeviceBusW(
    PV          pSti,
    LPCWSTR     pwszDeviceName
    )
{

    HRESULT                 hres = STIERR_INVALID_PARAM;
    DWORD                   dwErr  = NOERROR;
    CONFIGRET               cmRetCode = CR_SUCCESS ;

    EnterProcR(IStillImage::CStiObj_RefreshDeviceBus,(_ "pp", pSti,pwszDeviceName ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {
        PCStiObj this = _thisPvNm(pSti, stiW);

        hres = RefreshDeviceParentHelper(pwszDeviceName);

    }

    ExitOleProc();
    return hres;
}

STDMETHODIMP
CStiObj_RefreshDeviceBusA(
    PV      pSti,
    LPCSTR  pszDeviceName
    )
{

    HRESULT hres = STIERR_INVALID_PARAM;
    DWORD   dwError  = NOERROR;

    EnterProcR(IStillImage::CStiObj_RefreshDeviceBus,(_ "pp", pSti,pszDeviceName ));

    //
    // Validate passed pointer to interface and obtain pointer to object instance
    //
    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {
        PCStiObj this = _thisPvNm(pSti, stiA);

        LPWSTR pwszDeviceName=NULL ;

        hres = OSUtil_GetWideString(&pwszDeviceName,pszDeviceName);

        if (SUCCEEDED(hres)) {
            if (pwszDeviceName) {
                hres = RefreshDeviceParentHelper(pwszDeviceName);
                FreePpv(&pwszDeviceName);
            }
        }
    }

    ExitOleProc();
    return hres;
}


////////////////////////////////////////////////////////////////////////////////


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IStillImage | Initialize |
 *
 *          Initialize a StillImage object.
 *
 *          The <f StillImageCreate> method automatically
 *          initializes the StillImage object device after creating it.
 *          Applications normally do not need to call this function.
 *
 *  @cwrap  LPStillImage | lpStillImage
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the StillImage object.
 *
 *          StillImage uses this value to determine whether the
 *          application or DLL has been certified.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *          This value must be <c StillImage_VERSION>.
 *
 *          StillImage uses this value to determine what version of
 *          StillImage the application or DLL was designed for.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *****************************************************************************/

STDMETHODIMP
CStiObj_InitializeW(
    PV          pSti,
    HINSTANCE   hinst,
    DWORD       dwVersion
    )
{
    HRESULT hres;
    EnterProcR(IStillImage::Initialize, (_ "pxx", pSti, hinst, dwVersion));

    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceW))) {

        PCStiObj this = _thisPv(pSti);

        if (SUCCEEDED(hres = hresValidInstanceVer(hinst, dwVersion))) {
            this->dwVersion = dwVersion;
        }

    }

    ExitOleProc();
    return hres;
}

STDMETHODIMP
CStiObj_InitializeA(
    PV          pSti,
    HINSTANCE   hinst,
    DWORD       dwVersion
    )
{
    HRESULT hres;
    EnterProcR(IStillImage::Initialize, (_ "pxx", pSti, hinst, dwVersion));

    if (SUCCEEDED(hres = hresPvI(pSti, ThisInterfaceA))) {

        PCStiObj this = _thisPv(pSti);

        if (SUCCEEDED(hres = hresValidInstanceVer(hinst, dwVersion))) {
            this->dwVersion = dwVersion;
        }

    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CStiObj_Finalize |
 *
 *          Releases the resources of a STI object
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CStiObj_Finalize(PV pvObj)
{

    PCStiObj    this  = pvObj;

    //
    // Free COM libraries if connected to them
    //
    DllUnInitializeCOM();

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | StiCreateHelper |
 *
 *          <bnew>This function creates a new StillImage object
 *          which supports the <i IStillImage> COM interface.
 *
 *          On success, the function returns a pointer to the new object in
 *          *<p lplpSti>.
 *          <enew>
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the Sti object.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the sti.h header file that was used.
 *          This value must be <c STI_VERSION>.
 *
 *  @parm   OUT PPV | ppvObj |
 *          Points to where to return
 *          the pointer to the <i ISti> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown.
 *
 *  @parm   RIID | riid |
 *
 *          The interface the application wants to create.
 *
 *          If the object is aggregated, then this parameter is ignored.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM>
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

STDMETHODIMP
StiCreateHelper(
    HINSTANCE hinst,
    DWORD dwVer,
    PPV ppvObj,
    PUNK punkOuter,
    RIID riid)
{
    HRESULT hres;
    EnterProc(StiCreateHelper,
              (_ "xxxG", hinst, dwVer, punkOuter, riid));

    hres = CStiObj_New(punkOuter,punkOuter ? &IID_IUnknown : riid, ppvObj);

    if (SUCCEEDED(hres) && punkOuter == 0) {
        PSTI psti = *ppvObj;
        hres = psti->lpVtbl->Initialize(psti, hinst, dwVer);
        if (SUCCEEDED(hres)) {
        } else {
            Invoke_Release(ppvObj);
        }
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | IStillImage | New |
 *
 *          Create a new instance of an IStillImage object.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *          Output pointer for new object.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CStiObj_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IStillImage::CreateInstance, (_ "Gp", riid, ppvObj));

    hres = Common_NewRiid(CStiObj, punkOuter, riid, ppvObj);

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA


#define CStiObj_Signature        (DWORD)'STI'

Interface_Template_Begin(CStiObj)
    Primary_Interface_Template(CStiObj,TFORM(ThisInterfaceT))
    Secondary_Interface_Template(CStiObj, SFORM(ThisInterfaceT))
Interface_Template_End(CStiObj)

Primary_Interface_Begin(CStiObj, TFORM(ThisInterfaceT))
    TFORM(CStiObj_Initialize),
    TFORM(CStiObj_GetDeviceList),
    TFORM(CStiObj_GetDeviceInfo),
    TFORM(CStiObj_CreateDevice),
    TFORM(CStiObj_GetDeviceValue),
    TFORM(CStiObj_SetDeviceValue),
    TFORM(CStiObj_GetSTILaunchInformation),
    TFORM(CStiObj_RegisterLaunchApplication),
    TFORM(CStiObj_UnregisterLaunchApplication),
    TFORM(CStiObj_EnableHwNotifications),
    TFORM(CStiObj_GetHwNotificationState),
    TFORM(CStiObj_RefreshDeviceBus),
    TFORM(CStiObj_LaunchApplicationForDevice),
    TFORM(CStiObj_SetupDeviceParameters),
    TFORM(CStiObj_WriteToErrorLog)
Primary_Interface_End(CStiObj, TFORM(ThisInterfaceT))

Secondary_Interface_Begin(CStiObj,SFORM(ThisInterfaceT), SFORM(sti))
    SFORM(CStiObj_Initialize),
    SFORM(CStiObj_GetDeviceList),
    SFORM(CStiObj_GetDeviceInfo),
    SFORM(CStiObj_CreateDevice),
    SFORM(CStiObj_GetDeviceValue),
    SFORM(CStiObj_SetDeviceValue),
    SFORM(CStiObj_GetSTILaunchInformation),
    SFORM(CStiObj_RegisterLaunchApplication),
    SFORM(CStiObj_UnregisterLaunchApplication),
    SFORM(CStiObj_EnableHwNotifications),
    SFORM(CStiObj_GetHwNotificationState),
    SFORM(CStiObj_RefreshDeviceBus),
    SFORM(CStiObj_LaunchApplicationForDevice),
    SFORM(CStiObj_SetupDeviceParameters),
    SFORM(CStiObj_WriteToErrorLog)
Secondary_Interface_End(CStiObj,SFORM(ThisInterfaceT), SFORM(sti))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\stilog.cpp ===
/*++
   Copyright    (c)    1997        Microsoft Corporation

   Module Name:

        stilog.cpp

   Abstract:

        Class to handle file based logging

   Author:

        Vlad Sadovsky   (VladS)    01-Sep-1997

   History:


--*/


//
//  Include Headers
//

#include "cplusinc.h"
#include "sticomm.h"

//
// Static definitions and variables
//
static const TCHAR  szDefaultName[] = TEXT("Sti_Trace.log");
static const TCHAR  szDefaultTracerName[] = TEXT("STI");
static const TCHAR  szMutexNamePrefix[] = TEXT("StiTraceMutex");
static const TCHAR  szColumns[] =  TEXT("Severity TracerName [Process::ThreadId] Time MessageText\r\n\r\n");
static const TCHAR  szOpenedLog[] =  TEXT("\n****** Opened file log at %s %s .Tracer (%s) , called from [%#s::%#lx]\n");
static const TCHAR  szClosedLog[] = TEXT("\n******Closed trace log on %s %s Tracer (%s) , called from [%#s::%#lx]\n");

//
// Functions
//
//
inline BOOL
FormatStdTime(
    IN const SYSTEMTIME * pstNow,
    IN OUT TCHAR *    pchBuffer,
    IN  int          cbBuffer
    )
{
    return ( GetTimeFormat( LOCALE_SYSTEM_DEFAULT,
                            ( LOCALE_NOUSEROVERRIDE | TIME_FORCE24HOURFORMAT|
                              TIME_NOTIMEMARKER),
                            pstNow, NULL, pchBuffer, cbBuffer)
             != 0);

} // FormatStdTime()


inline BOOL
FormatStdDate( IN const SYSTEMTIME * pstNow,
               IN OUT TCHAR *    pchBuffer,
               IN  int          cbBuffer)
{
    return ( GetDateFormat( LOCALE_SYSTEM_DEFAULT, LOCALE_NOUSEROVERRIDE,
                            pstNow, NULL, pchBuffer, cbBuffer)
             != 0);
} // FormatStdDate()


inline  TCHAR
TraceFlagToLetter(
    IN  DWORD   dwType
    )
{
    if (dwType & STI_TRACE_ERROR) {
        return TEXT('e');
    }
    else if (dwType & STI_TRACE_WARNING) {
        return TEXT('w');
    }
    else if (dwType & STI_TRACE_INFORMATION) {
        return TEXT('i');
    }
    else {
        return TEXT('t');
    }
}

STI_FILE_LOG::STI_FILE_LOG(
    IN  LPCTSTR lpszTracerName,
    IN  LPCTSTR lpszLogName,
    IN  DWORD   dwFlags,         // = 0
    IN  HMODULE hMessageModule   // =NULL
    ) :
    m_hMutex(INVALID_HANDLE_VALUE)

/*++

   Description

     Constructor function for given log object.

   Arguments:

      lpszSource: file name for log. Relative to Windows directory

   Note:

--*/
{
    LPCTSTR  lpActualLogName;
    TCHAR   szTempName[MAX_PATH];
    LPTSTR  pszFilePart;

    DWORD   dwError;
    DWORD   cbName;
    DWORD   dwLevel;
    DWORD   dwMode;

    BOOL    fTruncate = FALSE;

    m_dwSignature = SIGNATURE_FILE_LOG;

    lpActualLogName = szDefaultName;

    m_hLogWindow = NULL;
    m_lWrittenHeader = FALSE;
    m_hDefaultMessageModule = hMessageModule ? hMessageModule : GetModuleHandle(NULL);

    dwLevel = STI_TRACE_ERROR;
    dwMode =  STI_TRACE_ADD_TIME | STI_TRACE_ADD_THREAD;

    m_hLogFile = INVALID_HANDLE_VALUE;
    *m_szLogFilePath = TEXT('\0');
    m_dwMaxSize = STI_MAX_LOG_SIZE;

    ReportError(NO_ERROR);

    //
    // Read global settings from the registry
    //
    RegEntry    re(REGSTR_PATH_STICONTROL REGSTR_PATH_LOGGING,HKEY_LOCAL_MACHINE);

    if (re.IsValid()) {

        m_dwMaxSize  = re.GetNumber(REGSTR_VAL_LOG_MAXSIZE,STI_MAX_LOG_SIZE);

        //
        // If we need to check append flag, read it from the registry
        //
        if (dwFlags & STIFILELOG_CHECK_TRUNCATE_ON_BOOT) {
            fTruncate  = re.GetNumber(REGSTR_VAL_LOG_TRUNCATE_ON_BOOT,FALSE);
        }

    }

    //
    // Open file for logging
    //
    if (lpszLogName && *lpszLogName ) {
        lpActualLogName  = lpszLogName;
    }

    //
    // lpszTracerName is ANSI.
    //

    if (lpszTracerName && *lpszTracerName ) {
        lstrcpyn(m_szTracerName,lpszTracerName,sizeof(m_szTracerName) / sizeof(m_szTracerName[0]));
        m_szTracerName[sizeof(m_szTracerName) / sizeof(m_szTracerName[0]) -1] = TEXT('\0');
    }
    else {
        lstrcpy(m_szTracerName,szDefaultTracerName);
    }

    //
    // Approximate process name with name of the executable binary used to create process
    //
    *szTempName = TEXT('\0');
    ::GetModuleFileName(NULL,szTempName,sizeof(szTempName) / sizeof(szTempName[0]));

    pszFilePart = _tcsrchr(szTempName,TEXT('\\'));

    pszFilePart = (pszFilePart && *pszFilePart) ? ::CharNext(pszFilePart) : szTempName;

    lstrcpyn(m_szProcessName,pszFilePart,sizeof(m_szProcessName)/sizeof(TCHAR));
    m_szProcessName[sizeof(m_szProcessName)/sizeof(TCHAR) - 1] = TEXT('\0');

    //
    // Read flags for this logger
    //
    re.MoveToSubKey(lpszTracerName);

    if (re.IsValid()) {
         dwLevel = re.GetNumber(REGSTR_VAL_LOG_LEVEL,STI_TRACE_ERROR)
                    & STI_TRACE_MESSAGE_TYPE_MASK;

         dwMode  = re.GetNumber(REGSTR_VAL_LOG_MODE,STI_TRACE_ADD_THREAD)
                   & STI_TRACE_MESSAGE_FLAGS_MASK;
    }

    m_dwReportMode = dwLevel | dwMode;

    //
    // Open log file
    //
    cbName = ::GetWindowsDirectory(m_szLogFilePath,sizeof(m_szLogFilePath)/sizeof(m_szLogFilePath[0]));
    if (( cbName == 0) || !*m_szLogFilePath ) {
        ReportError(::GetLastError());
        return;
    }

    lstrcat(lstrcat(m_szLogFilePath,TEXT("\\")),lpActualLogName);

    m_hLogFile = ::CreateFile(m_szLogFilePath,
                              GENERIC_WRITE,
                              FILE_SHARE_WRITE | FILE_SHARE_READ,
                              NULL,       // security attributes
                              OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);      // template file handle

    // if (  m_hLogFile!= INVALID_HANDLE_VALUE) {
    if (IS_VALID_HANDLE(m_hLogFile)) {

        if(fTruncate) {
            ::SetFilePointer( m_hLogFile, 0, NULL, FILE_BEGIN );
            ::SetEndOfFile( m_hLogFile );
        }

        ::SetFilePointer( m_hLogFile, 0, NULL, FILE_END);

        lstrcpy(szTempName,szMutexNamePrefix);
        lstrcat(szTempName,lpActualLogName);

        m_hMutex = ::CreateMutex(NULL,
                                 FALSE,
                                 szTempName
                                 );

        if (  !IS_VALID_HANDLE(m_hMutex ) ) {
            // ASSERT
        }
    }

    if (!IS_VALID_HANDLE(m_hLogFile) || !IS_VALID_HANDLE(m_hMutex )) {
        ReportError(::GetLastError());
    }
    else {
        //
        // Success
        //
    }


} /* STI_FILE_LOG::STI_FILE_LOG() */


STI_FILE_LOG::~STI_FILE_LOG( VOID)
/*++

    Description:

        Destructor function for given STI_FILE_LOG object.

--*/
{

    SYSTEMTIME  stCurrentTime;
    TCHAR       szFmtDate[20];
    TCHAR       szFmtTime[32];
    TCHAR       szTextBuffer[128];

    if(m_lWrittenHeader) {

        GetLocalTime(&stCurrentTime);
        FormatStdDate( &stCurrentTime, szFmtDate, 15);
        FormatStdTime( &stCurrentTime, szFmtTime, sizeof(szFmtTime) / sizeof(szFmtTime[0]));

        ::wsprintf(szTextBuffer,szClosedLog,
                   szFmtDate,szFmtTime,
                   m_szTracerName,
                   m_szProcessName,
                   ::GetCurrentThreadId()
                   );

        WriteStringToLog(szTextBuffer);

    }

    if (IS_VALID_HANDLE(m_hMutex)) {
        ::CloseHandle(m_hMutex);
        m_hMutex = INVALID_HANDLE_VALUE;
    }

    if (IS_VALID_HANDLE(m_hLogFile)) {
        ::FlushFileBuffers( m_hLogFile);
        ::CloseHandle(m_hLogFile);
        m_hLogFile = INVALID_HANDLE_VALUE;
    }

    m_dwSignature = SIGNATURE_FILE_LOG_FREE;

} /* STI_FILE_LOG::~STI_FILE_LOG() */

//
// IUnknown methods. Used only for reference counting
//
STDMETHODIMP
STI_FILE_LOG::QueryInterface( REFIID riid, LPVOID * ppvObj)
{
    return E_FAIL;
}

STDMETHODIMP_(ULONG)
STI_FILE_LOG::AddRef( void)
{
    ::InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG)
STI_FILE_LOG::Release( void)
{
    LONG    cNew;

    if(!(cNew = ::InterlockedDecrement(&m_cRef))) {
        delete this;
    }

    return cNew;
}

void
STI_FILE_LOG::
WriteLogSessionHeader(
    VOID
    )
/*++

   Description


   Arguments:

   Note:

--*/
{
    SYSTEMTIME  stCurrentTime;
    TCHAR       szFmtDate[32];
    TCHAR       szFmtTime[32];
    TCHAR       szTextBuffer[128];

    GetLocalTime(&stCurrentTime);
    FormatStdDate( &stCurrentTime, szFmtDate, sizeof(szFmtDate) / sizeof(szFmtDate[0]));
    FormatStdTime( &stCurrentTime, szFmtTime, sizeof(szFmtTime) / sizeof(szFmtTime[0]));

    ::wsprintf(szTextBuffer,szOpenedLog,
               szFmtDate,szFmtTime,
               m_szTracerName,
               m_szProcessName,
               ::GetCurrentThreadId()
               );

    WriteStringToLog(szTextBuffer);
    WriteStringToLog(szColumns);
}

void
STI_FILE_LOG::
ReportMessage(
    DWORD   dwType,
    LPCTSTR pszMsg,
    ...
    )
/*++

   Description


   Arguments:

   Note:

--*/
{
    va_list list;
    TCHAR    *pchBuff = NULL;
    DWORD   cch;

    va_start (list, pszMsg);

    pchBuff = NULL;

    cch = ::FormatMessage(FORMAT_MESSAGE_MAX_WIDTH_MASK |
                           FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_FROM_STRING,
                           pszMsg,
                           0,
                           0,
                           (LPTSTR) &pchBuff,
                           1024,
                           &list
                           );

    vReportMessage(dwType,pszMsg,list);

    va_end(list);
}

void
STI_FILE_LOG::
ReportMessage(
    DWORD   dwType,
    DWORD   idMessage,
    ...
    )
/*++

   Description


   Arguments:

   Note:

--*/
{
    va_list list;
    TCHAR    *pchBuff = NULL;
    DWORD   cch;

    va_start (list, idMessage);

    //
    // Read message and add inserts
    //
    pchBuff = NULL;

    cch = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_MAX_WIDTH_MASK |
                           FORMAT_MESSAGE_FROM_HMODULE,
                           m_hDefaultMessageModule ,
                           idMessage,
                           0,
                           (LPTSTR) &pchBuff,
                           1024,
                           &list
                           );

    if (pchBuff && cch) {
        vReportMessage(dwType,pchBuff,list);
        LocalFree(pchBuff);
    }

    va_end(list);

}

void
STI_FILE_LOG::
vReportMessage(
    DWORD   dwType,
    LPCTSTR pszMsg,
    va_list arglist
    )
/*++

   Description


   Arguments:

   Note:

--*/
{
    TCHAR   achTextBuffer[1024];
    DWORD   dwReportMode;


    if ((QueryError() != NOERROR) ||
        (!m_hLogFile || m_hLogFile == INVALID_HANDLE_VALUE)) {
        return;
    }

    // Do we need to display this message ?
    if (!((dwType & m_dwReportMode) & STI_TRACE_MESSAGE_TYPE_MASK)) {
        return;
    }

    // Start message with type
    *achTextBuffer = TraceFlagToLetter(dwType);
    *(achTextBuffer+1) = TEXT(' ');
    *(achTextBuffer+2) = TEXT('\0');

    // Add name of tracer source
    lstrcat(lstrcat(achTextBuffer,m_szTracerName),TEXT(" "));;

    dwReportMode = m_dwReportMode | (dwType & STI_TRACE_MESSAGE_FLAGS_MASK);

    //
    // Prepare header if needed
    //
    if (dwReportMode & STI_TRACE_MESSAGE_FLAGS_MASK ) {

        if (dwReportMode & STI_TRACE_ADD_THREAD ) {
            //
            // Add process::thread ID
            //
            TCHAR   szThreadId[40];

            ::wsprintf(szThreadId,TEXT("[%#s::%#lx] "),m_szProcessName,::GetCurrentThreadId());
            ::lstrcat(::lstrcat(achTextBuffer,szThreadId),TEXT(" "));
        }

        if (dwReportMode & STI_TRACE_ADD_TIME ) {
            // Add current time
            SYSTEMTIME  stCurrentTime;
            TCHAR       szFmtTime[32];

            *szFmtTime = TEXT('\0');

            ::GetLocalTime(&stCurrentTime);
            FormatStdTime( &stCurrentTime, szFmtTime, 15);

            lstrcat(lstrcat(achTextBuffer,szFmtTime),TEXT(" "));;
        }
    }

    lstrcat(achTextBuffer,TEXT("\t"));

    //
    // Now add message text itself
    //
    ::wvsprintf(achTextBuffer+::lstrlen(achTextBuffer), pszMsg, arglist);
    ::lstrcat(achTextBuffer , TEXT("\r\n"));

    //
    // Write to the file, flushing buffers if message type is ERROR
    //
    WriteStringToLog(achTextBuffer,(dwType & STI_TRACE_MESSAGE_TYPE_MASK) & STI_TRACE_ERROR);

}

VOID
STI_FILE_LOG::
WriteStringToLog(
    LPCTSTR pszTextBuffer,
    BOOL    fFlush          // = FALSE
    )
{

    DWORD   dwcbWritten;
    LONG    lHeaderWrittenFlag;

    //
    //  Integrity check.  Make sure the mutex and file handles are valid - if not,
    //  then bail.
    //
    if (!(IS_VALID_HANDLE(m_hMutex) && IS_VALID_HANDLE(m_hLogFile))) {
        #ifdef DEBUG
        //OutputDebugString(TEXT("STILOG File or Mutex handle is invalid. "));
        #endif
        return ;
    }

    //
    // If had not done yet, write session header here. Note this is recursive call
    // and flag marking header should be set first.
    //
    lHeaderWrittenFlag = InterlockedExchange(&m_lWrittenHeader,1L);

    if (!lHeaderWrittenFlag) {
        WriteLogSessionHeader();
    }

    TAKE_MUTEX t(m_hMutex);

    //
    // Check that log file size is not exceeding the limit. Assuming log file size is set to fit
    // into 32bit field, so we don't bother looking at high dword.
    //
    // Nb: We are not saving backup copy of the log, expecting that it never grows that large
    //

    BY_HANDLE_FILE_INFORMATION  fi;

    if (!GetFileInformationByHandle(m_hLogFile,&fi)) {
        #ifdef DEBUG
        OutputDebugString(TEXT("STILOG could not get file size for log file. "));
        #endif
        return ;
    }

    if ( fi.nFileSizeHigh !=0 || (fi.nFileSizeLow > m_dwMaxSize) ){

        ::SetFilePointer( m_hLogFile, 0, NULL, FILE_BEGIN );
        ::SetEndOfFile( m_hLogFile );

        ::GetFileInformationByHandle(m_hLogFile,&fi);
    }

    #ifdef USE_FILE_LOCK
    ::LockFile(m_hLogFile,fi.nFileSizeLow,fi.nFileSizeHigh,4096,0);
    #endif

    ::SetFilePointer( m_hLogFile, 0, NULL, FILE_END);

#ifdef _UNICODE
    UINT len = lstrlen(pszTextBuffer);
    CHAR *ansiBuffer = (CHAR *)alloca(len + 2);
    
    if(ansiBuffer) {
        ::WideCharToMultiByte(CP_ACP, 
                              0, 
                              pszTextBuffer, 
                              -1, 
                              ansiBuffer,
                              len + 1,
                              NULL,
                              NULL);
        ::WriteFile(m_hLogFile,
                    ansiBuffer,
                    len,
                    &dwcbWritten,
                    NULL);
    }

#else
    ::WriteFile(m_hLogFile,
                pszTextBuffer,
                lstrlen(pszTextBuffer),
                &dwcbWritten,
                NULL);
#endif
    #ifdef USE_FILE_LOCK
    ::UnlockFile(m_hLogFile,fi.nFileSizeLow,fi.nFileSizeHigh,4096,0);
    #endif

    if (fFlush) {
        // Flush buffers to disk
        FlushFileBuffers(m_hLogFile);
    }

    if(QueryReportMode()  & STI_TRACE_LOG_TOUI) {

        ULONG_PTR dwResult;


        SendMessageTimeout(m_hLogWindow,
                    STIMON_MSG_LOG_MESSAGE,
                    0,
                    (LPARAM)pszTextBuffer,
                    0,
                    100,
                    &dwResult
                    );
    }

    #ifdef DEBUG
    ::OutputDebugString(pszTextBuffer);
    #endif
}

//
// C-APIs
//
HANDLE
WINAPI
CreateStiFileLog(
    IN  LPCTSTR lpszTracerName,
    IN  LPCTSTR lpszLogName,
    IN  DWORD   dwReportMode
    )
/*++

   Description


   Arguments:

   Note:

--*/
{

    HANDLE      hRet = INVALID_HANDLE_VALUE;
    STI_FILE_LOG*   pStiFileLog = NULL;

    pStiFileLog = new STI_FILE_LOG(lpszTracerName,lpszLogName);

    if(pStiFileLog){
        if (pStiFileLog->IsValid()) {
            hRet = static_cast<HANDLE>(pStiFileLog);
            pStiFileLog->SetReportMode(pStiFileLog->QueryReportMode() | dwReportMode);
        } else {

            //
            // Notice that we delete this object rather than calling
            // CloseStiFileLog.  We do this because it the filelog is
            // not valid (maybe it had an internal creation error), 
            // CloseStiFileLog won't try to delete it, hence we delete
            // it here.
            //
            delete pStiFileLog;

            pStiFileLog = NULL;
            hRet        = INVALID_HANDLE_VALUE;
        }
    } else {
        ::SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return hRet;
}

DWORD
WINAPI
CloseStiFileLog(
    IN  HANDLE  hFileLog
    )
{
    STI_FILE_LOG*   pStiFileLog = NULL;

    pStiFileLog = static_cast<STI_FILE_LOG*>(hFileLog);

    if (IsBadWritePtr(pStiFileLog,sizeof(STI_FILE_LOG)) ||
        !pStiFileLog->IsValid()) {
        ::SetLastError(ERROR_INVALID_HANDLE);
        return ERROR_INVALID_HANDLE;
    }

    delete pStiFileLog;

    return NOERROR;
}

DWORD
WINAPI
ReportStiLogMessage(
    IN  HANDLE  hFileLog,
    IN  DWORD   dwType,
    IN  LPCTSTR psz,
    ...
    )
{
    STI_FILE_LOG*   pStiFileLog = NULL;

    pStiFileLog = static_cast<STI_FILE_LOG*>(hFileLog);

    if (IsBadWritePtr(pStiFileLog,sizeof(STI_FILE_LOG)) ||
        !pStiFileLog->IsValid()) {
        ::SetLastError(ERROR_INVALID_HANDLE);
        return ERROR_INVALID_HANDLE;
    }

    va_list list;

    va_start (list, psz);

    pStiFileLog->vReportMessage(dwType,psz,list);

    va_end(list);

    return NOERROR;
}


/********************************* End of File ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\stivalid.c ===
/*****************************************************************************
 *
 *  Valid.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Validate services.  On a validation error that would not have
 *      been caught in retail, we throw an exception.
 *
 *  Contents:
 *
 *      fFullValidPhwnd
 *      fFullValidPpdw
 *      fFullValidPpfn
 *      fFullValidReadPx
 *      fFullValidWritePx
 *
 *****************************************************************************/

/*
#include "wia.h"
#include <stilog.h>
#include <stiregi.h>

#include <sti.h>
#include <stierr.h>
#include <stiusd.h>
#include "stipriv.h"
#include "debug.h"
*/
#include "sticomm.h"


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresValidInstanceVer |
 *
 *          Check the <t HINSTANCE> and version number received from
 *          an application.
 *
 *  @parm   HINSTANCE | hinst |
 *
 *          Purported module instance handle.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version the application is asking for.
 *
 *****************************************************************************/

HRESULT EXTERNAL
hresValidInstanceVer_(HINSTANCE hinst, DWORD dwVersion, LPCSTR s_szProc)
{
    HRESULT hres = S_OK;
    TCHAR tszScratch[MAX_PATH];
    DWORD   dwRealVersion = (dwVersion & ~STI_VERSION_FLAG_MASK);

    if (GetModuleFileName(hinst, tszScratch, cA(tszScratch) - 1)) {
        if (( dwRealVersion <= STI_VERSION) &&(dwRealVersion >= STI_VERSION_MIN_ALLOWED)){
            hres = S_OK;
        } else {
            hres = STIERR_OLD_VERSION;
        }
    } else {
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidHwnd |
 *
 *          Validate a window handle completely.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window handle to validate.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_HANDLE> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidHwnd_(HWND hwnd, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (IsWindow(hwnd)) {
        hres = S_OK;
    } else {
        // RPF("ERROR %s: arg %d: not a window handle", s_szProc, iarg);
        hres = E_HANDLE;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresValidHandle |
 *
 *          Validate a generic handle completely.
 *
 *  @parm   HANDLE | handle |
 *
 *          Handle to validate.
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_HANDLE> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresValidHandle(HANDLE handle)
{
    HANDLE  hTemp;
    HRESULT hres;

    hres = S_OK;
    hTemp = INVALID_HANDLE_VALUE;

    // Validate the handle by calling DuplicateHandle.  This function
    // shouldn't change the state of the handle at all (except some
    // internal ref count or something).  So if it succeeds, then we
    // know we have a valid handle, otherwise, we will call it invalid.
    if(!DuplicateHandle(GetCurrentProcess(), handle,
                        GetCurrentProcess(), &hTemp,
                        DUPLICATE_SAME_ACCESS,
                        FALSE,
                        DUPLICATE_SAME_ACCESS)) {
        hres =  E_HANDLE;
    }

    // Now close our duplicate handle
    CloseHandle(hTemp);
    return hres;


}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPvCb_ |
 *
 *          Validate that a buffer is readable or writeable.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   PFNBAD | pfnBad |
 *
 *          Function that determines whether the buffer is bad.
 *          Should be <f IsBadReadPtr> or <f IsBadWritePtr>.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *          High word indicates how many bytes should not be
 *          scrambled.
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

typedef BOOL (WINAPI *PFNBAD)(PCV pv, UINT_PTR cb);

#ifndef MAXDEBUG

#define hresFullValidPvCb_(pv, cb, pfnBad, z, i)                    \
       _hresFullValidPvCb_(pv, cb, pfnBad)                          \

#endif

STDMETHODIMP
hresFullValidPvCb_(PCV pv, UINT cb, PFNBAD pfnBad, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (!pfnBad(pv, cb)) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", "", LOWORD(iarg));
        hres = E_POINTER;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWritePvCb_ |
 *
 *          Validate that a buffer is writeable.  Also scrambles it
 *          if special goo doesn't need to be done.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWritePvCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    hres = hresFullValidPvCb_(pv, cb, (PFNBAD)IsBadWritePtr, s_szProc, iarg);
#ifdef MAXDEBUG
    if (SUCCEEDED(hres) && HIWORD(iarg) == 0) {
        ScrambleBuf(pv, cb);
    }
#endif
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadPvCb_ |
 *
 *          Validate that a buffer is readable.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadPvCb_(PCV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    return hresFullValidPvCb_(pv, cb, (PFNBAD)IsBadReadPtr, s_szProc, iarg);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPxCb_ |
 *
 *          Validate that a sized structure is readable or writeable.
 *
 *  @parm   PCV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.  If the structure is being validated for
 *          writing, then all fields beyond the <p dwSize> are scrambled
 *          in MAXDEBUG.
 *
 *  @parm   UINT | cb |
 *
 *          Expected size of the structure.
 *
 *  @parm   STRUCTPROC | pfnStruct |
 *
 *          Function which validates that a structure is readable or writable.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not readable or writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

typedef STDMETHOD(STRUCTPROC)(PCV pv, UINT cb
                                   RD(comma LPCSTR s_szProc comma int iarg));

#ifndef MAXDEBUG

#define hresFullValidPxCb_(pv, cb, pfnStruct, z, i)                 \
        _hresFullValidPxCb_(pv, cb, pfnStruct)                       \

#endif

STDMETHODIMP
hresFullValidPxCb_(PCV pv, UINT cb, STRUCTPROC pfnStruct,
                   LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    hres = pfnStruct(pv, cb RD(comma s_szProc comma iarg));
    if (SUCCEEDED(hres)) {
        if (*(LPDWORD)pv == cb) {
            if (HIWORD(iarg)) {
                ScrambleBuf(pvAddPvCb(pv, HIWORD(iarg)), cb - HIWORD(iarg));
            }
        } else {
            //RPF("ERROR %s: arg %d: invalid dwSize", s_szProc, LOWORD(iarg));
            hres = E_INVALIDARG;
        }
    }
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWritePxCb_ |
 *
 *          Validate that a sized structure is writeable.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cb |
 *
 *          Expected size of the structure.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWritePxCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    /*
     *  We need to distinguish hresFullValidWritePvCb_ and
     *  _hresFullValidWritePvCb_ manually, because the preprocessor
     *  gets confused.
     *
     *  We also need to put a cbX(DWORD) into the high word of the iarg
     *  so that the size field won't get demolished.
     */
#ifdef MAXDEBUG
    return hresFullValidPxCb_(pv, cb, (STRUCTPROC)hresFullValidWritePvCb_,
                                      s_szProc, MAKELONG(iarg, cbX(DWORD)));
#else
    return hresFullValidPxCb_(pv, cb, (STRUCTPROC)_hresFullValidWritePvCb_,
                                      s_szProc, iarg);
#endif
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadPxCb_ |
 *
 *          Validate that a sized structure is readable.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cb |
 *
 *          Expected size of the structure.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not readable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadPxCb_(PCV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    /*
     *  We need to distinguish hresFullValidReadPvCb_ and
     *  _hresFullValidReadPvCb_ manually, because the preprocessor
     *  gets confused.
     */
#ifdef MAXDEBUG
    return hresFullValidPxCb_(pv, cb, hresFullValidReadPvCb_, s_szProc, iarg);
#else
    return hresFullValidPxCb_(pv, cb, _hresFullValidReadPvCb_, s_szProc, iarg);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidFl_ |
 *
 *          Validate that no invalid flags are passed.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags passed by the caller.
 *
 *  @parm   DWORD | flV |
 *
 *          Flags which are valid.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidFl_(DWORD fl, DWORD flV, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if ((fl & ~flV) == 0) {
        hres = S_OK;
    } else {
        //RPF("ERROR %s: arg %d: invalid flags", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPfn_ |
 *
 *          Validate that the parameter is a valid code pointer.
 *
 *          Actually, <f IsValidCodePtr> on Win32 is broken, but
 *          tough.
 *
 *  @parm   FARPROC | pfn |
 *
 *          Procedure to "validate".
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPfn_(FARPROC pfn, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (!IsBadCodePtr(pfn)) {
        hres = S_OK;
    } else {
        //RPF("ERROR %s: arg %d: invalid callback address", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPitf_ |
 *
 *          Validate that the parameter is an interface pointer.
 *
 *          We don't look at it very hard.
 *
 *  @parm   PUNK | punk |
 *
 *          <i IUnknown> to "validate".
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the pointer itself is bogus.
 *
 *          <c E_INVALIDARG> if something inside the pointer is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPitf_(PUNK punk, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    if (!IsBadReadPtr(punk, cbX(DWORD))) {
        IUnknownVtbl *pvtbl = punk->lpVtbl;
        if (!IsBadReadPtr(pvtbl, 3 * cbX(DWORD))) {
            if (!IsBadCodePtr((FARPROC)pvtbl->QueryInterface) &&
                !IsBadCodePtr((FARPROC)pvtbl->AddRef) &&
                !IsBadCodePtr((FARPROC)pvtbl->Release)) {
                hres = S_OK;
            } else {
                //RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
                hres = E_INVALIDARG;
            }
        } else {
            //RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
            hres = E_INVALIDARG;
        }
    } else {
        //RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
        hres = E_POINTER;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPdwOut_ |
 *
 *          Validate that the parameter is a valid place to stick an
 *          output result.  We also smas it to zero.
 *
 *  @parm   PV | pdw |
 *
 *          Pointer to "validate".
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the pointer itself is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPdwOut_(PV pdw, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (!IsBadWritePtr(pdw, 4)) {
        *(LPDWORD)pdw = 0;
        hres = S_OK;
    } else {
        //RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
        hres = E_POINTER;
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\string.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    string.cpp

Abstract:

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

//
// Normal includes only for this module to be active
//

#include "cplusinc.h"
#include "sticomm.h"

//
//  Private Definations
//

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128

//
//  Converts a value between zero and fifteen to the appropriate hex digit
//
#define HEXDIGIT( nDigit )                              \
    (TCHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'A'                           \
        : (nDigit) + '0')

//
//  Converts a single hex digit to its decimal equivalent
//
#define TOHEX( ch )                                     \
    ((ch) > '9' ?                                       \
        (ch) >= 'a' ?                                   \
            (ch) - 'a' + 10 :                           \
            (ch) - 'A' + 10                             \
        : (ch) - '0')





//
//  Private Globals
//

WCHAR STR::_pszEmptyString[] = L"";

//
// Construction/Destruction
//
STR::STR( const CHAR  * pchInit )
{
    AuxInit( (PBYTE) pchInit, FALSE );
}

STR::STR( const WCHAR * pwchInit )
{
    AuxInit( (PBYTE) pwchInit, TRUE );
}

STR::STR( const STR & str )
{
    AuxInit( (PBYTE) str.QueryPtr(), str.IsUnicode() );
}

VOID STR::AuxInit( PBYTE pInit, BOOL fUnicode )
{
    BOOL fRet;

    _fUnicode = fUnicode;
    _fValid   = TRUE;

    if ( pInit )
    {
        INT cbCopy = fUnicode ? (::wcslen( (WCHAR *) pInit ) + 1) * sizeof(WCHAR) :
                                (::strlen( (CHAR *)  pInit ) + 1) * sizeof(CHAR);

        fRet = Resize( cbCopy );


        if ( !fRet )
        {
            _fValid = FALSE;
            return;
        }

        ::memcpy( QueryPtr(), pInit, cbCopy );
    }
}


//
// Appends the string onto this one.
//

BOOL STR::Append( const CHAR  * pchStr )
{
    if ( pchStr )
    {
        ASSERT( !IsUnicode() );

        return AuxAppend( (PBYTE) pchStr, ::strlen( pchStr ) );
    }

    return TRUE;
}

BOOL STR::Append( const WCHAR * pwchStr )
{
    if ( pwchStr )
    {
        ASSERT( IsUnicode() );

        return AuxAppend( (PBYTE) pwchStr, ::wcslen( pwchStr ) * sizeof(WCHAR) );
    }

    return TRUE;
}

BOOL STR::Append( const STR   & str )
{
    if ( str.IsUnicode() )
        return Append( (const WCHAR *) str.QueryStrW() );
    else
        return Append( (const CHAR *) str.QueryStrA() );
}

BOOL STR::AuxAppend( PBYTE pStr, UINT cbStr, BOOL fAddSlop )
{
    ASSERT( pStr != NULL );

    UINT cbThis = QueryCB();

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    if ( QuerySize() < cbThis + cbStr + sizeof(WCHAR) )
    {
        if ( !Resize( cbThis + cbStr + (fAddSlop ? STR_SLOP : sizeof(WCHAR) )) )
            return FALSE;
    }

    memcpy( (BYTE *) QueryPtr() + cbThis,
            pStr,
            cbStr + (IsUnicode() ? sizeof(WCHAR) : sizeof(CHAR)) );

    return TRUE;
}

//
// Convert in place
//
BOOL STR::ConvertToW(VOID)
{
    if (IsUnicode()) {
        return TRUE;
    }

    UINT cbNeeded = (QueryCB()+1)*sizeof(WCHAR);

    //
    //  Only resize when we have to.
    //
    if ( QuerySize() < cbNeeded ) {
        if ( !Resize( cbNeeded)) {
            return FALSE;
        }
    }

    BUFFER  buf(cbNeeded);

    if (!buf.QueryPtr()) {
        return FALSE;
    }

    int iRet;
    int cch;

    cch = QueryCCH() + 1;

    iRet = MultiByteToWideChar( CP_ACP,
                                MB_PRECOMPOSED,
                                QueryStrA(),
                                -1,
                                (WCHAR *)buf.QueryPtr(),
                                cch);

    if ( iRet == 0 ) {

        //
        // Error in conversion.
        //
        return FALSE;
    }

    memcpy( (BYTE *) QueryPtr(),
            buf.QueryPtr(),
            cbNeeded);

    SetUnicode(TRUE);

    return TRUE;
}

BOOL STR::ConvertToA(VOID)
{
    if (!IsUnicode()) {
        return TRUE;
    }

    UINT cbNeeded = (QueryCB()+1)*sizeof(CHAR);
    BUFFER  buf(cbNeeded);

    if (!buf.QueryPtr()) {
        return FALSE;
    }

    int iRet;
    int cch;

    cch = cbNeeded;

    iRet = WideCharToMultiByte(CP_ACP,
                               0L,
                               QueryStrW(),
                               -1,
                               (CHAR *)buf.QueryPtr(),
                               cch,
                               NULL,
                               NULL
                               );

    if ( iRet == 0 ) {

        //
        // Error in conversion.
        //
        return FALSE;
    }

    // Careful here , there might be DBCS characters in resultant buffer
    memcpy( (BYTE *) QueryPtr(),
            buf.QueryPtr(),
            iRet);

    SetUnicode(FALSE);

    return TRUE;

}


//
//    Copies the string into this one.
//


BOOL STR::Copy( const CHAR  * pchStr )
{
    _fUnicode = FALSE;

    if ( QueryPtr() )
        *(QueryStrA()) = '\0';

    if ( pchStr )
    {
        return AuxAppend( (PBYTE) pchStr, ::strlen( pchStr ), FALSE );
    }

    return TRUE;
}

BOOL STR::Copy( const WCHAR * pwchStr )
{
    _fUnicode = TRUE;

    if ( QueryPtr() )
        *(QueryStrW()) = TEXT('\0');

    if ( pwchStr )
    {
        return AuxAppend( (PBYTE) pwchStr, ::wcslen( pwchStr ) * sizeof(WCHAR), FALSE );
    }

    return TRUE;
}

BOOL STR::Copy( const STR   & str )
{
    _fUnicode = str.IsUnicode();

    if ( str.IsEmpty() && QueryPtr() == NULL) {

        // To avoid pathological allocation of small chunk of memory
        return ( TRUE);
    }

    if ( str.IsUnicode() )
        return Copy( str.QueryStrW() );
    else
        return Copy( str.QueryStrA() );
}

//
// Resizes or allocates string memory, NULL terminating if necessary
//

BOOL STR::Resize( UINT cbNewRequestedSize )
{
    BOOL fTerminate =  QueryPtr() == NULL;

    if ( !BUFFER::Resize( cbNewRequestedSize ))
        return FALSE;

    if ( fTerminate && cbNewRequestedSize > 0 )
    {
        if ( IsUnicode() )
        {
            ASSERT( cbNewRequestedSize > 1 );
            *QueryStrW() = TEXT('\0');
        }
        else
            *QueryStrA() = '\0';
    }

    return TRUE;
}

//
//   Loads a string resource from this module's string table
//   or from the system string table
//
//   dwResID - System error or module string ID
//   lpszModuleName - name of the module from which to load.
//   If NULL, then load the string from system table.
//
//
BOOL STR::LoadString( IN DWORD dwResID,
                      IN LPCTSTR lpszModuleName // Optional
                     )
{
    BOOL fReturn = FALSE;
    INT  cch;

    //
    //  If lpszModuleName is NULL, load the string from system's string table.
    //

    if ( lpszModuleName == NULL) {

        BYTE * pchBuff = NULL;

        //
        //  Call the appropriate function so we don't have to do the Unicode
        //  conversion
        //

        if ( IsUnicode() ) {

            cch = ::FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                    FORMAT_MESSAGE_IGNORE_INSERTS  |
                                    FORMAT_MESSAGE_MAX_WIDTH_MASK  |
                                    FORMAT_MESSAGE_FROM_SYSTEM,
                                    NULL,
                                    dwResID,
                                    0,
                                    (LPWSTR) &pchBuff,
                                    1024,
                                    NULL );
            if ( cch ) {

                fReturn = Copy( (LPCWSTR) pchBuff );
             }

        }
        else
          {
            cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                   FORMAT_MESSAGE_IGNORE_INSERTS  |
                                   FORMAT_MESSAGE_MAX_WIDTH_MASK  |
                                   FORMAT_MESSAGE_FROM_SYSTEM,
                                   NULL,
                                   dwResID,
                                   0,
                                   (LPSTR) &pchBuff,
                                   1024,
                                   NULL );

            if ( cch ) {

                fReturn = Copy( (LPCSTR) pchBuff );
            }
        }

        //
        //  Free the buffer FormatMessage allocated
        //

        if ( cch )
        {
            ::LocalFree( (VOID*) pchBuff );
        }

    } else   {

        WCHAR ach[STR_MAX_RES_SIZE];

        if ( IsUnicode() )
        {
            cch = ::LoadStringW( GetModuleHandle( lpszModuleName),
                                 dwResID,
                                 (WCHAR *) ach,
                                 sizeof(ach));

            if ( cch )
            {
                fReturn = Copy( (LPWSTR) ach );
            }
        }
        else
        {
            cch = ::LoadStringA( GetModuleHandle( lpszModuleName),
                                 dwResID,
                                 (CHAR *) ach,
                                 sizeof(ach));
            if ( cch )
            {
                fReturn =  Copy( (LPSTR) ach );
            }
        }
    }

    return ( fReturn);

} // STR::LoadString()


BOOL STR::LoadString( IN DWORD  dwResID,
                      IN HMODULE hModule
                     )
{
    BOOL fReturn = FALSE;
    INT  cch;
    WCHAR ach[STR_MAX_RES_SIZE];

    if ( IsUnicode()) {

        cch = ::LoadStringW(hModule,
                            dwResID,
                            (WCHAR *) ach,
                            sizeof(ach));

        if ( cch ) {

            fReturn = Copy( (LPWSTR) ach );
        }

    } else {

        cch = ::LoadStringA(hModule,
                            dwResID,
                            (CHAR *) ach,
                            sizeof(ach));
        if ( cch ) {

            fReturn =  Copy( (LPSTR) ach );
        }
    }

    return ( fReturn);

} // STR::LoadString()


BOOL
STR::FormatStringV(
    IN LPCTSTR lpszModuleName,
    ...
    )
{
    DWORD   cch;
    LPSTR   pchBuff;
    BOOL    fRet = FALSE;
    DWORD   dwErr;

    va_list va;

    va_start(va,lpszModuleName);

    cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_STRING,
                            QueryStrA(),
                            0L,
                            0,
                            (LPSTR) &pchBuff,
                            1024,
                            &va);

    dwErr = ::GetLastError();

    if ( cch )  {
        fRet = Copy( (LPCSTR) pchBuff );

        ::LocalFree( (VOID*) pchBuff );
    }

    return fRet;
}

BOOL
STR::FormatString(
    IN DWORD   dwResID,
    IN LPCTSTR apszInsertParams[],
    IN LPCTSTR lpszModuleName
    )
{
    DWORD cch;
    LPSTR pchBuff;
    BOOL  fRet;

    if (!dwResID) {
        cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY  |
                                FORMAT_MESSAGE_FROM_STRING,
                                QueryStrA(),
                                dwResID,
                                0,
                                (LPSTR) &pchBuff,
                                1024,
                                (va_list *) apszInsertParams );
    }
    else {
        cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY  |
                                FORMAT_MESSAGE_FROM_HMODULE,
                                GetModuleHandle( lpszModuleName ),
                                dwResID,
                                0,
                                (LPSTR) &pchBuff,
                                1024,
                                (va_list *) apszInsertParams );
    }

    if ( cch )
    {
        fRet = Copy( (LPCSTR) pchBuff );

        ::LocalFree( (VOID*) pchBuff );
    }

    return fRet;
}


#if 1
CHAR * STR::QueryStrA( VOID ) const
 {
    ASSERT( !IsUnicode() );
    ASSERT( *_pszEmptyString == TEXT('\0') );

    return (QueryPtr() ? (CHAR *) QueryPtr() : (CHAR *) _pszEmptyString);
}

WCHAR * STR::QueryStrW( VOID ) const
{
    ASSERT( IsUnicode() );
    ASSERT( *_pszEmptyString == TEXT('\0') );

    return (QueryPtr() ? (WCHAR *) QueryPtr() : (WCHAR *) _pszEmptyString);
}
#endif //DBG



BOOL STR::CopyToBuffer( WCHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the WCHAR buffer passed in if the buffer
        is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
        to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to WCHAR buffer which on return contains
                        the UNICODE version of string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in *lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    if ( *lpcch == 0) {

            //
            //  Inquiring the size of buffer alone
            //
            *lpcch = QueryCCH() + 1;    // add one character for terminating null
    } else {

        //
        // Copy data to buffer
        //
        if ( IsUnicode()) {

            //
            // Do plain copy of the data.
            //
            if ( *lpcch >= QueryCCH()) {

                wcscpy( lpszBuffer, QueryStrW());
            } else {

                SetLastError( ERROR_INSUFFICIENT_BUFFER);
                fReturn = FALSE;
            }

        } else {

            //
            // Copy after conversion from ANSI to Unicode
            //
            int  iRet;
            iRet = MultiByteToWideChar( CP_ACP,   MB_PRECOMPOSED,
                                        QueryStrA(),  QueryCCH() + 1,
                                        lpszBuffer, (int )*lpcch);

            if ( iRet == 0 || iRet != (int ) *lpcch) {

                //
                // Error in conversion.
                //
                fReturn = FALSE;
            }
        }
    }

    return ( fReturn);
} // STR::CopyToBuffer()


BOOL STR::CopyToBufferA( CHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the CHAR buffer passed in if the buffer
        is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
        to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to CHAR buffer which on return contains
                        the MBCS version of string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in *lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    if ( *lpcch == 0) {

            //
            //  Inquiring the size of buffer alone
            //
            *lpcch = 2*(QueryCCH() + 1);    // add one character for terminating null and on pessimistic side
                                            // ask for largest possible buffer
    } else {

        //
        // Copy data to buffer
        //
        if ( !IsUnicode()) {
            lstrcpyA( lpszBuffer, QueryStrA());
        } else {

            //
            // Copy after conversion from Unicode to MBCS
            //
            int  iRet;

            iRet = WideCharToMultiByte(CP_ACP,
                                       0L,
                                       QueryStrW(),
                                       QueryCCH()+1,
                                       lpszBuffer,
                                       *lpcch,
                                       NULL,NULL
                                        );

            if ( iRet == 0 || *lpcch < (DWORD)iRet) {
                *lpcch = iRet;
                fReturn = FALSE;
            }
        }
    }

    return ( fReturn);
} // STR::CopyToBuffer()


/*
  STRArray class implementation- this isn't very efficient, as
  we'll copy every string over again whenever we grow the array, but
  then again, that part of the code may never even get executed, anyway
*/
void    STRArray::Grow() {

    //  We need to add some more strings to the array

    STR *pcsNew = new STR[m_ucMax += m_uGrowBy];

    if  (!pcsNew) {
        //  We recover gracelessly by replacing the final
        //  string.

        m_ucMax -= m_uGrowBy;
        m_ucItems--;
        return;
    }

    for (unsigned u = 0; u < m_ucItems; u++)
        pcsNew[u] = (LPCTSTR) m_pcsContents[u];

    delete[]  m_pcsContents;
    m_pcsContents = pcsNew;
}

STRArray::STRArray(unsigned uGrowBy) {

    m_uGrowBy = uGrowBy ? uGrowBy : 10;

    m_ucItems = m_ucMax = 0;

    m_pcsContents = NULL;
}

STRArray::~STRArray() {
    if  (m_pcsContents)
        delete[]  m_pcsContents;
}

void    STRArray::Add(LPCSTR lpstrNew) {
    if  (m_ucItems >= m_ucMax)
        Grow();

    m_pcsContents[m_ucItems++].Copy(lpstrNew);
}

void    STRArray::Add(LPCWSTR lpstrNew) {
    if  (m_ucItems >= m_ucMax)
        Grow();

    m_pcsContents[m_ucItems++].Copy(lpstrNew);
}

void    STRArray::Tokenize(LPCTSTR lpstrIn, TCHAR tcSplitter) {

    if  (m_pcsContents) {
        delete[]  m_pcsContents;
        m_ucItems = m_ucMax = 0;
        m_pcsContents = NULL;
    }

    if  (!lpstrIn || !*lpstrIn)
        return;

    while   (*lpstrIn) {

        //  First, strip off any leading blanks

        while   (*lpstrIn && *lpstrIn == _TEXT(' '))
            lpstrIn++;

        for (LPCTSTR lpstrMoi = lpstrIn;
             *lpstrMoi && *lpstrMoi != tcSplitter;
             lpstrMoi++)
            ;
        //  If we hit the end, just add the whole thing to the array
        if  (!*lpstrMoi) {
            if  (*lpstrIn)
                Add(lpstrIn);
            return;
        }

        //  Otherwise, just add the string up to the splitter

        TCHAR       szNew[MAX_PATH];
        SIZE_T      uiLen = (SIZE_T)(lpstrMoi - lpstrIn);

        if (uiLen < (sizeof(szNew)/sizeof(szNew[0])) - 1) {

            lstrcpyn(szNew,lpstrIn,(UINT)uiLen);
            szNew[uiLen] = TCHAR('\0');

            Add((LPCTSTR) szNew);
        }

        lpstrIn = lpstrMoi + 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\valid.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    valid.cpp

Abstract:

Author:

    Vlad Sadovsky   (vlads) 26-Jun-1997

Revision History:

    26-Jun-1997     VladS       created

--*/

#include "cplusinc.h"
#include "sticomm.h"



//
//  Validation code
//


BOOL
IsValidHWND(
    HWND hwnd)
{
    /* Ask User if this is a valid window. */

    return(IsWindow(hwnd));
}


BOOL
IsValidHMENU(
    HMENU hmenu)
{
    return IsMenu(hmenu);
}


BOOL
IsValidHANDLE(
    HANDLE hnd)
{
    return(NULL != hnd && INVALID_HANDLE_VALUE != hnd);
}


BOOL
IsValidHANDLE2(
    HANDLE hnd)
{
    return(hnd != INVALID_HANDLE_VALUE);
}


BOOL
IsValidShowCmd(
    int nShow)
{
    BOOL bResult;

    switch (nShow)
    {
       case SW_HIDE:
       case SW_SHOWNORMAL:
       case SW_SHOWMINIMIZED:
       case SW_SHOWMAXIMIZED:
       case SW_SHOWNOACTIVATE:
       case SW_SHOW:
       case SW_MINIMIZE:
       case SW_SHOWMINNOACTIVE:
       case SW_SHOWNA:
       case SW_RESTORE:
       case SW_SHOWDEFAULT:
          bResult = TRUE;
          break;

       default:
          bResult = FALSE;
          //TraceMsg(TF_ERROR, "IsValidShowCmd(): Invalid show command %d.",nShow);
          break;
    }

    return(bResult);
}


BOOL
IsValidPathA(
    LPCSTR pcszPath)
{
    return(IS_VALID_STRING_PTRA(pcszPath, MAX_PATH) &&
           ((UINT)lstrlenA(pcszPath) < MAX_PATH));
}

BOOL
IsValidPathW(
    LPCWSTR pcszPath)
{
    return(IS_VALID_STRING_PTRW(pcszPath, MAX_PATH) &&
           ((UINT)lstrlenW(pcszPath) < MAX_PATH));
}


BOOL
IsValidPathResultA(
    HRESULT hr,
    LPCSTR pcszPath,
    UINT cchPathBufLen)
{
    return((hr == S_OK &&
           (IsValidPathA(pcszPath)) &&
            ((UINT)lstrlenA(pcszPath) < cchPathBufLen)) ||
           (hr != S_OK &&
            (! cchPathBufLen ||
                 ! pcszPath ||
                 ! *pcszPath)));
}

BOOL
IsValidPathResultW(
    HRESULT hr,
    LPCWSTR pcszPath,
    UINT cchPathBufLen)
{
    return((hr == S_OK &&
            (IsValidPathW(pcszPath)) &&
            ((UINT)lstrlenW(pcszPath) < cchPathBufLen)) ||
           (hr != S_OK &&
            (! cchPathBufLen ||
                 ! pcszPath ||
                 ! *pcszPath)));
}


BOOL
IsValidExtensionA(
    LPCSTR pcszExt)
{
    return(IS_VALID_STRING_PTRA(pcszExt, MAX_PATH) &&
           (lstrlenA(pcszExt) < MAX_PATH) &&
           (*pcszExt == '.'));
}

BOOL
IsValidExtensionW(
    LPCWSTR pcszExt)
{
    return(IS_VALID_STRING_PTRW(pcszExt, MAX_PATH) &&
           (lstrlenW(pcszExt) < MAX_PATH) &&
           (*pcszExt == L'.'));
}


BOOL
IsValidIconIndexA(
    HRESULT hr,
    LPCSTR pcszIconFile,
    UINT cchIconFileBufLen,
    int niIcon)
{
    return((IsValidPathResultA(hr, pcszIconFile, cchIconFileBufLen)) &&
           (hr == S_OK ||
                ! niIcon));
}

BOOL
IsValidIconIndexW(
    HRESULT hr,
    LPCWSTR pcszIconFile,
    UINT cchIconFileBufLen,
    int niIcon)
{
    return((IsValidPathResultW(hr, pcszIconFile, cchIconFileBufLen)) &&
           (hr == S_OK ||
                ! niIcon));
}


BOOL IsStringContainedA(LPCSTR pcszBigger, LPCSTR pcszSuffix)
{
    ASSERT(IS_VALID_STRING_PTRA(pcszBigger, -1));
    ASSERT(IS_VALID_STRING_PTRA(pcszSuffix, -1));

    return (pcszSuffix >= pcszBigger &&
            pcszSuffix <= pcszBigger + lstrlenA(pcszBigger));
}


BOOL IsStringContainedW(LPCWSTR pcszBigger, LPCWSTR pcszSuffix)
{
    ASSERT(IS_VALID_STRING_PTRW(pcszBigger, -1));
    ASSERT(IS_VALID_STRING_PTRW(pcszSuffix, -1));

    return (pcszSuffix >= pcszBigger &&
            pcszSuffix <= pcszBigger + lstrlenW(pcszBigger));
}


BOOL
AfxIsValidString(
    LPCWSTR     lpsz,
    int         nLength
    )
{
    if (lpsz == NULL)
        return FALSE;

    return ::IsBadStringPtrW(lpsz, nLength) == 0;
}

BOOL
AfxIsValidString(
    LPCSTR  lpsz,
    int     nLength
    )
{
    if (lpsz == NULL)
        return FALSE;

    return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL
AfxIsValidAddress(
    const void* lp,
    UINT nBytes,
    BOOL bReadWrite
    )
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\wiaguid\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     wiaguid.lib    - GUIDS for WIA interfaces, events, etc..
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiaguid
TARGETTYPE=LIBRARY
TARGETPATH=$(OBJ_DIR)

# There's nothing special about the chicago .lib file - only build/publish one.
PASS1_PUBLISH= \
    {$(O)\wiaguid.lib=$(SDK_LIB_PATH)\wiaguid.lib;$(DDK_LIB_PATH)\wiaguid.lib}

# prevent system headers from being included.  They are not needed just to
# process a bunch of DEFINE_GUIDs anyhow.  Excluding them generates a much
# smaller library too.

C_DEFINES=$(C_DEFINES) /D_MIDL_USE_GUIDDEF_ /DGUID_DEFS_ONLY

SOURCES=  \
        ..\wiaevent.c         \
        ..\wia_guids.c        \
        ..\wiamindr_guids.c   \
        ..\wiascr_guids.c     \
        ..\wiapriv_guids.c    \
        ..\wiavideo_guids.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\wiaguid\wiaevent.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997-1999
*
*  TITLE:       WiaEvent.C
*
*  VERSION:     2.0
*
*  AUTHOR:      VladS
*
*  DATE:        1 June, 1999
*
*  DESCRIPTION:
*   Declaration and definitions for the WIA events and commands.
*
*******************************************************************************/

#define INITGUID
#include <sti.h>
#include <guiddef.h>

#include "wia.h"
#include "wiadevd.h"
#include "wiadevdp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\wialog.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       WiaLog.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      CoopP
*
*  DATE:        20 Aug, 1999
*
*  DESCRIPTION:
*   Class implementation for WIA Logging.
*
*******************************************************************************/

#include "cplusinc.h"
#include "sticomm.h"

static const TCHAR  szServiceName[]    = TEXT("WIASERVC");
static const TCHAR  szDefaultName[]    = TEXT("WIASERVC.LOG");
static const TCHAR  szDefaultKeyName[] = TEXT("WIASERVC");
static const TCHAR  szDefaultDLLName[] = TEXT("noname.dll");
static const TCHAR  szOpenedLog[]      = TEXT("[%s] Opened log at %s %s");
static const TCHAR  szClosedLog[]      = TEXT("[%s] Closed log on %s %s");
static const WCHAR  szFormatSignature[]= L"F9762DD2679F";

//#define DEBUG_WIALOG

/**************************************************************************\
* CWiaLog::CreateInstance
*
*   Create the CWiaLog object.
*
* Arguments:
*
*   iid    - iid of Logging interface
*   ppv    - return interface pointer
*
* Return Value:
*
*   status
*
* History:
*
*    8/20/1999 Original Version
*
\**************************************************************************/

HRESULT CWiaLog::CreateInstance(const IID& iid, void** ppv)
{
    HRESULT hr;

    //
    // Create the WIA Logging component.
    //

    CWiaLog* pWiaLog = new CWiaLog();

    if (!pWiaLog) {
        return E_OUTOFMEMORY;
    }

    //
    // Initialize the WIA logging component.
    //

    hr = pWiaLog->Initialize();
    if (FAILED(hr)) {
        delete pWiaLog;
        return hr;
    }

    //
    // Get the requested interface from the logging component.
    //

    hr = pWiaLog->QueryInterface(iid, ppv);
    if (FAILED(hr)) {
#ifdef DEBUG_WIALOG
    OutputDebugString(TEXT("CWiaLog::CreateInstance, Unkown interface\n"));
#endif
        delete pWiaLog;
        return hr;
    }
#ifdef DEBUG_WIALOG
    OutputDebugString(TEXT("CWiaLog::CreateInstance, Created WiaLog\n"));
#endif

    return hr;
}

/**************************************************************************\
*  QueryInterface
*  AddRef
*  Release
*
*    CWiaLog IUnknown Interface
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    8/20/1999 Original Version
*
\**************************************************************************/

HRESULT __stdcall  CWiaLog::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if ((iid == IID_IUnknown) || (iid == IID_IWiaLog)) {
        *ppv = (IWiaLog*) this;
    } else if (iid == IID_IWiaLogEx) {
        *ppv = (IWiaLogEx*) this;
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG __stdcall CWiaLog::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    //DPRINTF(DM_TRACE,TEXT("CWiaLog::AddRef() m_cRef = %d"),m_cRef);
    return m_cRef;
}


ULONG __stdcall CWiaLog::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) {
        //DPRINTF(DM_TRACE,TEXT("CWiaLog::Release() m_cRef = %d"),m_cRef);
        delete this;
        return 0;
    }
    //DPRINTF(DM_TRACE,TEXT("CWiaLog::Release() m_cRef = %d"),m_cRef);
    return ulRefCount;
}

/*******************************************************************************
*
* CWiaLog
* ~CWiaLog
*
*   CWiaLog Constructor/Initialize/Destructor Methods.
*
* History:
*
*    8/20/1999 Original Version
*
\**************************************************************************/

CWiaLog::CWiaLog():m_cRef(0)
{
   m_cRef               = 0;                 // Initialize Reference count to zero
   m_pITypeInfo         = NULL;              // Initialize InfoType to NULL
   m_dwReportMode       = 0;                 // Initialize Report Type to zero
   m_dwMaxSize          = WIA_MAX_LOG_SIZE;  // Initialize File Max size to default
   m_hLogFile           = NULL;              // Initialize File handle to NULL
   m_lDetail            = 0;                 // Initialize TRACE detail level to zero (off)
   m_bLogToDebugger     = FALSE;             // Initialize Logging to DEBUGGER to FALSE
   m_bLoggerInitialized = FALSE;             // Initialize Logger to UNINITIALIZED
   m_bTruncate          = FALSE;             // Initialize Truncation to FALSE
   m_bClear             = TRUE;              // Initialize Clear Log file to TRUE (Don't want to make huge log files for no reason :) )

   ZeroMemory(m_szLogFilePath,               // Initialize Path buffer
              sizeof(m_szLogFilePath));

   ZeroMemory(m_szModeText,                  // Initialize formatted mode text buffer
              sizeof(m_szModeText));

}

CWiaLog::~CWiaLog()
{
   //DPRINTF(DM_TRACE,TEXT("CWiaLog::Destroy"));

   if (m_pITypeInfo != NULL) {
       m_pITypeInfo->Release();
   }

   //
   // Flush buffers to disk
   //

   //DPRINTF(DM_TRACE,TEXT("Flushing final buffers"));
   FlushFileBuffers(m_hLogFile);

   //
   // close log file on destruction of log object
   //

   //DPRINTF(DM_TRACE,TEXT("Closing file handle"));
   CloseHandle(m_hLogFile);

   //
   // mark handle as invalid
   //

   m_hLogFile = INVALID_HANDLE_VALUE;

}

////////////////////////////////////////////////////////////////////////////////////
//                IWiaLog private methods (exposed to the client)                 //
////////////////////////////////////////////////////////////////////////////////////


/**************************************************************************\
* CWiaLog::InitializeLog
*
*   Initializes the Logging component
*
* Arguments:
*
*   none
*
* Return Value:
*
*   status
*
* History:
*
*    8/20/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaLog::InitializeLog (LONG hInstance)
{
    HRESULT hr = S_OK;

    //
    // set instance handle
    //

    m_hInstance = (HINSTANCE) ULongToPtr(hInstance);

    //
    // set DLL's name
    //

    if(!FormatDLLName(m_hInstance,m_szFmtDLLName,sizeof(m_szFmtDLLName))) {

        //
        // if this there is no DLL name created, use a default one
        //

        lstrcpy(m_szFmtDLLName, szDefaultDLLName);
        hr = E_INVALIDARG;
    }

    //
    // Create Registry Key name
    //

    lstrcpy(m_szKeyName,m_szFmtDLLName);

    //
    // open log file
    //

    if (OpenLogFile()) {
        if (m_hLogFile != NULL) {

            //
            // query logging settings from registry, to
            // setup logging system
            //

            QueryLoggingSettings();
            if(m_bTruncate) {
                ProcessTruncation();
            }
            if(m_bClear) {

                //
                // clear log file
                //

                ::SetFilePointer(m_hLogFile, 0, NULL, FILE_BEGIN );
                ::SetEndOfFile(m_hLogFile );
            }
            WriteLogSessionHeader();

            m_bLoggerInitialized = TRUE;
        }
    } else {

        //
        // Log file failed to Open... this is really bad
        //

        hr = E_FAIL;
    }

    return hr;
}

/**************************************************************************\
* CWiaLog::InitializeLogEx
*
*   Initializes the Logging component.
*
* Arguments:
*
*   hInstance   -   Handle of the caller's HINSTANCE
*
* Return Value:
*
*   status
*
* History:
*
*    3/28/2000 Original Version
*
\**************************************************************************/
HRESULT _stdcall CWiaLog::InitializeLogEx(BYTE* hInstance)
{
    HRESULT hr = S_OK;

    //
    // set instance handle
    //

    m_hInstance = (HINSTANCE) hInstance;

    //
    // set DLL's name
    //

    if(!FormatDLLName(m_hInstance,m_szFmtDLLName,sizeof(m_szFmtDLLName))) {

        //
        // if this there is no DLL name created, use a default one
        //

        lstrcpy(m_szFmtDLLName, szDefaultDLLName);
        hr = E_INVALIDARG;
    }

    //
    // Create Registry Key name
    //

    lstrcpy(m_szKeyName,m_szFmtDLLName);

    //
    // open log file
    //

    if (OpenLogFile()) {
        if (m_hLogFile != NULL) {

            //
            // query logging settings from registry, to
            // setup logging system
            //

            QueryLoggingSettings();
            if(m_bTruncate) {
                ProcessTruncation();
            }
            if(m_bClear) {

                //
                // clear log file
                //

                ::SetFilePointer(m_hLogFile, 0, NULL, FILE_BEGIN );
                ::SetEndOfFile(m_hLogFile );
            }
            WriteLogSessionHeader();

            m_bLoggerInitialized = TRUE;
        }
    } else {

        //
        // Log file failed to Open... this is really bad
        //

        hr = E_FAIL;
    }

    return hr;
}

/**************************************************************************\
*  Log()
*
*    Handles Logging, TRACE,ERROR,and WARNING optional call logging
*
* Arguments:
*
*    lFlags - Flag to determine which type of logging to use
*    hInstance - Instance of the calling module
*    lResID - Resource ID of the wiaservc.dll resource file
*    lDetail - Logging detail level
*    bstrText - string for display
*
*
* Return Value:
*
*    status
*
* History:
*
*    8/20/1999 Original Version
*
\**************************************************************************/
HRESULT __stdcall CWiaLog::Log (LONG lFlags, LONG lResID, LONG lDetail, BSTR bstrText)
{
    HRESULT hr = E_FAIL;
    if (m_bLoggerInitialized) {
        //  Find another way of updating the settings without querying the
        //  Registry every time
        //  QueryLoggingSettings();

        //
        // check string for 'free signature'.
        //

        BOOL bFreeString = NeedsToBeFreed(&bstrText);

        /*

        //
        // NOTE: revisit this, How can you load a string resource ID from the service,
        //       if you don't have the service's HINSTANCE?????
        //

        if(lResID != WIALOG_NO_RESOURCE_ID) {
            if (lResID < 35000) {

                //
                // Load the resource string from caller's resource
                //

                if (LoadString(g_hInstance,lResID,pBuffer, sizeof(pBuffer)) != 0) {
                    bstrText = SysAllocString(pBuffer);
                    bFreeString = TRUE;
                }
            } else {

                //
                // pull string from service's resource
                //

            }
        }
        */

        switch (lFlags) {
        case WIALOG_ERROR:
            if(m_dwReportMode & WIALOG_ERROR)
                hr = Error(bstrText);
            break;
        case WIALOG_WARNING:
            if(m_dwReportMode & WIALOG_WARNING)
                hr = Warning(bstrText);
            break;
        case WIALOG_TRACE:
        default:
            if(m_dwReportMode & WIALOG_TRACE)
                hr = Trace(bstrText,lDetail);
            break;
        }
        if(bFreeString)
            SysFreeString(bstrText);
    }
    return hr;
}

/**************************************************************************\
*  LogEx()
*
*    Handles Logging, TRACE,ERROR,and WARNING optional call logging.  This
*    is almost the same as the Log() call, but it contains a MethodId which
*    can be used for more specific filtering.
*
* Arguments:
*
*    lMethodId - Integer indicating the uniqeu ID associated with the 
*                calling method.
*    lFlags - Flag to determine which type of logging to use
*    hInstance - Instance of the calling module
*    lResID - Resource ID of the wiaservc.dll resource file
*    lDetail - Logging detail level
*    bstrText - string for display
*
*
* Return Value:
*
*    status
*
* History:
*
*    3/28/2000 Original Version
*
\**************************************************************************/
HRESULT _stdcall CWiaLog::LogEx(LONG lMethodId, LONG lFlags, LONG lResID, LONG lDetail, BSTR bstrText)
{
    HRESULT hr = E_FAIL;
    if (m_bLoggerInitialized) {
        //
        // check string for 'free signature'.
        //

        BOOL bFreeString = NeedsToBeFreed(&bstrText);

        switch (lFlags) {
        case WIALOG_ERROR:
            if(m_dwReportMode & WIALOG_ERROR)
                hr = Error(bstrText, lMethodId);
            break;
        case WIALOG_WARNING:
            if(m_dwReportMode & WIALOG_WARNING)
                hr = Warning(bstrText, lMethodId);
            break;
        case WIALOG_TRACE:
        default:
            if(m_dwReportMode & WIALOG_TRACE)
                hr = Trace(bstrText,lDetail, lMethodId);
            break;
        }
        if(bFreeString)
            SysFreeString(bstrText);
    }
    return hr;
}

/**************************************************************************\
*  hResult()
*
*    Handles hResult translating for Error call logging
*
* Arguments:
*
*    hInstance - Instance of the calling module
*    hr - HRESULT to be translated
*
* Return Value:
*
*    status
*
* History:
*
*    8/20/1999 Original Version
*
\**************************************************************************/
HRESULT __stdcall CWiaLog::hResult (HRESULT hr)
{
    HRESULT hRes = E_FAIL;
    if (m_bLoggerInitialized) {
        //  Find another way of updating the settings without querying the
        //  Registry every time
        //  QueryLoggingSettings();

        //
        // we are initialized, so set the return to S_OK
        //

        hRes = S_OK;

        if (m_dwReportMode & WIALOG_ERROR) {
#define NUM_CHARS_FOR_HRESULT   150
            TCHAR szhResultText[NUM_CHARS_FOR_HRESULT];
            ULONG ulLen = 0;

            memset(szhResultText, 0, sizeof(szhResultText));

            ulLen = ::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
                                    NULL,
                                    hr,
                                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                    (LPTSTR)&szhResultText,
                                    NUM_CHARS_FOR_HRESULT,
                                    NULL);
            if (ulLen) {
                szhResultText[NUM_CHARS_FOR_HRESULT - 1] = TEXT('\0');
                memset(m_szTextBuffer,0,sizeof(m_szTextBuffer));
                ConstructText();
                ::wsprintf(m_szTextBuffer,TEXT("%s  HRESULT: %s"),
                           m_szModeText,
                           szhResultText);
                WriteStringToLog(m_szTextBuffer, FLUSH_STATE);
            }
        }
    }
    return hRes;
}

HRESULT _stdcall CWiaLog::hResultEx(LONG lMethodId, HRESULT hr)
{
    HRESULT hRes = E_FAIL;
    if (m_bLoggerInitialized) {
        //  Find another way of updating the settings without querying the
        //  Registry every time
        //  QueryLoggingSettings();

        //
        // we are initialized, so set the return to S_OK
        //

        hRes = S_OK;

        if (m_dwReportMode & WIALOG_ERROR) {
#define NUM_CHARS_FOR_HRESULT   150
            TCHAR szhResultText[NUM_CHARS_FOR_HRESULT];
            ULONG ulLen = 0;

            memset(szhResultText, 0, sizeof(szhResultText));

            ulLen = ::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
                                    NULL,
                                    hr,
                                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                    (LPTSTR)&szhResultText,
                                    NUM_CHARS_FOR_HRESULT,
                                    NULL);
            if (ulLen) {
                szhResultText[NUM_CHARS_FOR_HRESULT - 1] = TEXT('\0');
                memset(m_szTextBuffer,0,sizeof(m_szTextBuffer));
                ConstructText();
                ::wsprintf(m_szTextBuffer,TEXT("#0x%08X %s  HRESULT: %s"),
                           lMethodId,
                           m_szModeText,
                           szhResultText);
                WriteStringToLog(m_szTextBuffer, FLUSH_STATE);
            }
        }
    }
    return hRes;
}

HRESULT _stdcall CWiaLog::UpdateSettingsEx(LONG lCount, LONG *plMethodIds)
{
    return E_NOTIMPL;
}

HRESULT _stdcall CWiaLog::ExportMappingTableEx(MappingTable **ppTable)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////////
//             IWiaLog private methods (not exposed to the client)                //
////////////////////////////////////////////////////////////////////////////////////

/**************************************************************************\
* CWiaLog::Initialize
*
*   Initializes the CWiaLog class object (does nothing at the moment)
*
* Arguments:
*
*   none
*
* Return Value:
*
*   status
*
* History:
*
*    8/20/1999 Original Version
*
\**************************************************************************/

HRESULT CWiaLog::Initialize()
{
   //DPRINTF(DM_TRACE,TEXT("CWiaLog::Initialize"));
   return S_OK;
}

/**************************************************************************\
*  Trace()
*
*    Handles Trace call logging
*
* Arguments:
*
*    hInstance - Instance of the calling module
*    lResID - Resource ID of the wiaservc.dll resource file
*    bstrText - string for display
*    lDetail - Logging detail level
*
* Return Value:
*
*    status
*
* History:
*
*    8/20/1999 Original Version
*
\**************************************************************************/
HRESULT CWiaLog::Trace  (BSTR bstrText, LONG lDetail, LONG lMethodId)
{
    memset(m_szTextBuffer,0,sizeof(m_szTextBuffer));

    //
    // Turn off if lDetail level is zero
    // TODO:  Only don't log if both detail level = 0, and the lMethodId doesn't
    //        match one in our list
    //

    if(m_lDetail == 0) {
        return S_OK;
    }

    if (lDetail <= m_lDetail) {
        ConstructText();
        ::wsprintf(m_szTextBuffer,TEXT("#0x%08X %s    TRACE: %ws"),
                   lMethodId,
                   m_szModeText,
                   bstrText);
        WriteStringToLog(m_szTextBuffer, FLUSH_STATE);
    }
    return S_OK;
}

/**************************************************************************\
*  Warning()
*
*    Handles Warning call logging
*
* Arguments:
*
*    hInstance - Instance of the calling module
*    lResID - Resource ID of the wiaservc.dll resource file
*    bstrText - string for display
*
* Return Value:
*
*    status
*
* History:
*
*    8/20/1999 Original Version
*
\**************************************************************************/
HRESULT CWiaLog::Warning(BSTR bstrText, LONG lMethodId)
{
    memset(m_szTextBuffer,0,sizeof(m_szTextBuffer));
    ConstructText();
    ::wsprintf(m_szTextBuffer,TEXT("#0x%08X %s  WARNING: %ws"),
               lMethodId,
               m_szModeText,
               bstrText);
    WriteStringToLog(m_szTextBuffer, FLUSH_STATE);
    return S_OK;
}

/**************************************************************************\
*  Error()
*
*    Handles Error call logging
*
* Arguments:
*
*    hInstance - Instance of the calling module
*    lResID - Resource ID of the wiaservc.dll resource file
*    bstrText - string for display
*
* Return Value:
*
*    status
*
* History:
*
*    8/20/1999 Original Version
*
\**************************************************************************/
HRESULT CWiaLog::Error  (BSTR bstrText, LONG lMethodId)
{
    memset(m_szTextBuffer,0,sizeof(m_szTextBuffer));
    ConstructText();
    ::wsprintf(m_szTextBuffer,TEXT("#0x%08X %s    ERROR: %ws"),
               lMethodId,
               m_szModeText,
               bstrText);
    WriteStringToLog(m_szTextBuffer, FLUSH_STATE);
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////
//             IWiaLog private helpers (not exposed to the client)                //
////////////////////////////////////////////////////////////////////////////////////

/**************************************************************************\
* OpenLogFile()
*
*   Open the log file for logging
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    status
*
* History:
*
*    8/23/1999 Original Version
*
\**************************************************************************/
BOOL CWiaLog::OpenLogFile()
{
    //
    // Open log file
    //

    DWORD dwLength = 0;
    TCHAR *szName = NULL;

    m_hLogFile = INVALID_HANDLE_VALUE;

    //
    // Get Windows Directory
    //

    dwLength = ::GetWindowsDirectory(m_szLogFilePath,sizeof(m_szLogFilePath));
    if (( dwLength == 0) || !*m_szLogFilePath ) {
        //DPRINTF(DM_TRACE,TEXT("Could not GetWindowsDirectory()"));
        return FALSE;
    }

    //
    // Add log file name to Windows Directory
    //

    szName = lstrcat(m_szLogFilePath,TEXT("\\"));
    if (szName) {
        lstrcat(szName,TEXT("wiaservc.log"));

        //
        // Create / open Log file
        //

        m_hLogFile = ::CreateFile(m_szLogFilePath,
                                  GENERIC_WRITE | GENERIC_READ,
                                  FILE_SHARE_WRITE | FILE_SHARE_READ,
                                  NULL,       // security attributes
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);      // template file handle
    }


    if (m_hLogFile == INVALID_HANDLE_VALUE)
        return FALSE;
    return TRUE;
}

/**************************************************************************\
* WriteStringToLog()
*
*   Writed formatted TEXT to a log file
*
*
* Arguments:
*
*    pszTextBuffer - Buffer of TEXT to write to file
*    fFlush - TRUE  = FLUSH file on write,
*             FALSE = DON'T FLUSH file on write
*
* Return Value:
*
*    status
*
* History:
*
*    8/23/1999 Original Version
*
\**************************************************************************/
VOID CWiaLog::WriteStringToLog(LPTSTR pszTextBuffer,BOOL fFlush)
{
    DWORD   dwcbWritten;

    BY_HANDLE_FILE_INFORMATION  fi;

    if (!GetFileInformationByHandle(m_hLogFile,&fi)) {
        //DPRINTF(DM_TRACE,TEXT("WIALOG could not get file size for log file. "));
        return;
    }

    //
    // check to see if our log file has exceeded it's MAX SIZE
    // If it has, reset the file pointer, and start writing from the
    // TOP.
    //

    //if ( fi.nFileSizeHigh !=0 || (fi.nFileSizeLow > m_dwMaxSize) ){
    //    ::SetFilePointer( m_hLogFile, 0, NULL, FILE_END);
    //    ::SetEndOfFile( m_hLogFile );
    //    ::GetFileInformationByHandle(m_hLogFile,&fi);
    //}

#ifdef USE_FILE_LOCK
    ::LockFile(m_hLogFile,
               fi.nFileSizeLow,
               fi.nFileSizeHigh,
               NUM_BYTES_TO_LOCK_LOW,
               NUM_BYTES_TO_LOCK_HIGH);
#endif

    ::SetFilePointer( m_hLogFile, 0, NULL, FILE_END);

#ifdef UNICODE

    //
    // convert to ANSI if we are UNICODE, and write string to log.
    //

    CHAR buffer[MAX_PATH];
    WideCharToMultiByte(CP_ACP,WC_NO_BEST_FIT_CHARS,pszTextBuffer,-1,buffer,MAX_PATH,NULL,NULL);
    ::WriteFile(m_hLogFile,
                buffer,
                lstrlen(pszTextBuffer),
                &dwcbWritten,
                NULL);
#else

    //
    // we are ANSI so write string to log.
    //

    ::WriteFile(m_hLogFile,
                pszTextBuffer,
                lstrlen(pszTextBuffer),
                &dwcbWritten,
                NULL);
#endif

    ::WriteFile(m_hLogFile,
                "\r\n",
                2,
                &dwcbWritten,
                NULL);

#ifdef USE_FILE_LOCK
    ::UnlockFile(m_hLogFile,
                 fi.nFileSizeLow,
                 fi.nFileSizeHigh,
                 NUM_BYTES_TO_LOCK_LOW,
                 NUM_BYTES_TO_LOCK_HIGH);
#endif

    //
    // Flush buffers to disk if requested (should always be TRUE on Millenium)
    //

    if (fFlush) {
        FlushFileBuffers(m_hLogFile);
    }

    //
    // Log to a Debugger
    //

    if (m_bLogToDebugger) {
        ::OutputDebugString(pszTextBuffer);
        ::OutputDebugString(TEXT("\n"));
    }

    //
    // Log to a Window / UI
    //

    if (m_bLogToUI) {

        //
        // Log to some window...or UI
        //
    }
}
/**************************************************************************\
* FormatStdTime()
*
*   Formats the TIME to be added to a LOG file
*
*
* Arguments:
*
*   pstNow - System Time NOW
*   pchBuffer - buffer for the formatted time
*   cbBuffer - Buffer size
*
*
* Return Value:
*
*    status
*
* History:
*
*    8/23/1999 Original Version
*
\**************************************************************************/
BOOL CWiaLog::FormatStdTime(const SYSTEMTIME *pstNow,TCHAR *pchBuffer)
{
    ::wsprintf(pchBuffer,
               TEXT("%02d:%02d:%02d.%03d"),
               pstNow->wHour,
               pstNow->wMinute,
               pstNow->wSecond,
               pstNow->wMilliseconds);

    return TRUE;
}
/**************************************************************************\
* FormatStdDate()
*
*   Formats the DATE to be added to a LOG file
*
*
* Arguments:
*
*   pstNow - System TIME NOW
*   pchBuffer - buffer for the formatted time
*   cbBuffer - Buffer size
*
*
* Return Value:
*
*    status
*
* History:
*
*    8/23/1999 Original Version
*
\**************************************************************************/
inline BOOL FormatStdDate(const SYSTEMTIME *pstNow,TCHAR *pchBuffer,INT cbBuffer)
{
    return (GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                          LOCALE_NOUSEROVERRIDE,
                          pstNow,
                          NULL,
                          pchBuffer,
                          cbBuffer)!= 0);
}

/**************************************************************************\
* WriteLogSessionHeader()
*
*   Writes a header to the log file
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    void
*
* History:
*
*    8/23/1999 Original Version
*
\**************************************************************************/
VOID CWiaLog::WriteLogSessionHeader()
{
    SYSTEMTIME  stCurrentTime;
    TCHAR       szFmtDate[32];
    TCHAR       szFmtTime[32];
    TCHAR       szTextBuffer[128];

    //
    // Format TIME and DATE
    //

    GetLocalTime(&stCurrentTime);
    FormatStdDate( &stCurrentTime, szFmtDate, sizeof(szFmtDate));
    FormatStdTime( &stCurrentTime, szFmtTime);

    //
    // write formatted data to TEXT buffer
    //

    ::wsprintf(szTextBuffer,
               szOpenedLog,
               m_szFmtDLLName,
               szFmtDate,
               szFmtTime);

    //
    // write TEXT buffer to log
    //

    WriteStringToLog(szTextBuffer, FLUSH_STATE);
}

/**************************************************************************\
* QueryLoggingSettings()
*
*   Read the registry and set the logging settings.
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    status
*
* History:
*
*    8/23/1999 Original Version
*
\**************************************************************************/
BOOL CWiaLog::QueryLoggingSettings()
{
    DWORD dwLevel = 0;
    DWORD dwMode  = 0;

    //
    // read settings from the registry
    //

    RegEntry re(REGSTR_PATH_STICONTROL REGSTR_PATH_LOGGING,HKEY_LOCAL_MACHINE);

    if (re.IsValid()) {
        m_dwMaxSize  = re.GetNumber(REGSTR_VAL_LOG_MAXSIZE,WIA_MAX_LOG_SIZE);
    }

    //
    // read report mode flags
    //

    re.MoveToSubKey(m_szKeyName);

    if (re.IsValid()) {
        dwLevel = re.GetNumber(REGSTR_VAL_LOG_LEVEL,WIALOG_ERROR)
                  & WIALOG_MESSAGE_TYPE_MASK;

        dwMode  = re.GetNumber(REGSTR_VAL_LOG_MODE,WIALOG_ADD_THREAD|WIALOG_ADD_MODULE)
                  & WIALOG_MESSAGE_FLAGS_MASK;

        m_lDetail = re.GetNumber(REGSTR_VAL_LOG_DETAIL,WIALOG_NO_LEVEL);

        //
        // set truncate log on boot options
        //

        DWORD dwTruncate = -1;
        dwTruncate = re.GetNumber(REGSTR_VAL_LOG_TRUNCATE_ON_BOOT,FALSE);

        if (dwTruncate == 0)
            m_bTruncate = FALSE;
        else
            m_bTruncate = TRUE;

        //
        // set clear log on boot options
        //

        DWORD dwClear = -1;

        dwClear = re.GetNumber(REGSTR_VAL_LOG_CLEARLOG_ON_BOOT,TRUE);

        if (dwClear == 0)
            m_bClear = FALSE;
        else
            m_bClear = TRUE;

        //
        // set debugger logging options
        //

        DWORD dwDebugLogging = -1;
        dwDebugLogging = re.GetNumber(REGSTR_VAL_LOG_TO_DEBUGGER,FALSE);

        if (dwDebugLogging == 0)
            m_bLogToDebugger = FALSE;
        else
            m_bLogToDebugger = TRUE;

    }

    //
    // set report mode
    //

    m_dwReportMode = dwLevel | dwMode;

    //
    // set UI (window) logging options
    //

    if(m_dwReportMode & WIALOG_UI)
        m_bLogToUI = TRUE;
    else
        m_bLogToUI = FALSE;
    return TRUE;
}
/**************************************************************************\
* ConstructText()
*
*   Constructs TEXT according to Logging settings
*
*
* Arguments:
*
*   pchBuffer - buffer for the formatted text
*   cbBuffer - Buffer size
*
*
* Return Value:
*
*    status
*
* History:
*
*    8/23/1999 Original Version
*
\**************************************************************************/
VOID CWiaLog::ConstructText()
{
    //
    // set string constructor to zero
    //

    TCHAR szHeader[MAX_PATH];
    TCHAR szbuffer[40];
    memset(m_szModeText,0,sizeof(m_szModeText));
    memset(szHeader,0,sizeof(szHeader));

    //
    // add thread id
    //

    if(m_dwReportMode & WIALOG_ADD_THREAD) {
        ::wsprintf(szbuffer,TEXT("[%08X] "),::GetCurrentThreadId());
        ::lstrcat(m_szModeText,szbuffer);
        ::lstrcat(szHeader,TEXT("[ Thread ] "));
    }

    //
    // add module name
    //

    if(m_dwReportMode & WIALOG_ADD_MODULE) {
        ::wsprintf(szbuffer,TEXT("%s "),m_szFmtDLLName);
        ::lstrcat(m_szModeText,szbuffer);
        ::lstrcat(szHeader,TEXT("[  Module  ] "));
    }

    //
    // add time
    //

    if(m_dwReportMode & WIALOG_ADD_TIME) {
        SYSTEMTIME  stCurrentTime;
        TCHAR       szFmtTime[40];
        GetLocalTime(&stCurrentTime);
        FormatStdTime(&stCurrentTime, szFmtTime);
        ::wsprintf(szbuffer,TEXT("  %s "),szFmtTime);
        ::lstrcat(m_szModeText,szbuffer);
        ::lstrcat(szHeader,TEXT("[ HH:MM:SS.ms ] "));
    }

    //
    // add column header if needed
    //

    if(lstrcmp(szHeader,m_szColumnHeader) != 0) {
        lstrcpy(m_szColumnHeader,szHeader);
        WriteStringToLog(TEXT(" "), FLUSH_STATE);
        WriteStringToLog(TEXT("============================================================================="), FLUSH_STATE);
        WriteStringToLog(m_szColumnHeader, FLUSH_STATE);
        WriteStringToLog(TEXT("============================================================================="), FLUSH_STATE);
        WriteStringToLog(TEXT(" "), FLUSH_STATE);
    }
}
/**************************************************************************\
* FormatDLLName()
*
*   Formats the DLL name to be added to a LOG file
*
*
* Arguments:
*
*   hInstance - Instance of the calling DLL
*   pchBuffer - buffer for the formatted name
*   cbBuffer - Buffer size
*
*
* Return Value:
*
*    status
*
* History:
*
*    8/23/1999 Original Version
*
\**************************************************************************/
BOOL CWiaLog::FormatDLLName(HINSTANCE hInstance,TCHAR *pchBuffer,INT cbBuffer)
{
    TCHAR lpfullpath[255];
    DWORD dwLength = 0;
    dwLength = GetModuleFileName(hInstance,lpfullpath,sizeof(lpfullpath)/sizeof(lpfullpath[0]));
    if(dwLength == 0)
        return FALSE;

    //
    // extract the file name from the full path
    //

    _tsplitpath(lpfullpath, NULL, NULL, pchBuffer, NULL);

    return TRUE;
}

/**************************************************************************\
* NeedsToBeFreed()
*
*   Determines if the logger should free the allocated string.
*   If the signature is found, it is stripped off the beginning of the string
*   and the return of TRUE is set.
*
* Arguments:
*
*   pBSTR - buffer for BSTRING
*
*
* Return Value:
*
*    status
*
* History:
*
*    8/23/1999 Original Version
*
\**************************************************************************/
BOOL CWiaLog::NeedsToBeFreed(BSTR* pBSTR)
{
    //
    //  NOTE:  MAX_SIG_LEN *must* be larger than the string length of
    //         the signature!!!
    //
    WCHAR wszSig[MAX_SIG_LEN];

    //
    // check string to see if it is NULL, user may want to use a resource ID instead
    //

    if(*pBSTR == NULL) {
        return FALSE;
    }

    //
    // extract a possible signature from the beginning of the BSTR
    //

    wcsncpy(wszSig, *pBSTR, wcslen(szFormatSignature));
    wszSig[wcslen(szFormatSignature)] = '\0';

    //
    // do they match?
    //

    if(wcscmp(wszSig,szFormatSignature) == 0) {

        //
        // They match, so strip off the signature from the BSTR, and
        // return TRUE, (string can be freed by us).
        //

        wcscpy(*pBSTR,*pBSTR + wcslen(szFormatSignature));
        return TRUE;
    }

    //
    // signature did not match, must not be allocated by US
    //
    return FALSE;
}

/**************************************************************************\
* ProcessTruncation()
*
*   Determines if the logger should truncate the file.
*   The bottom part of the log file is copied, and copied back to the log file
*   after the file has been truncated.
*
*
* Arguments:
*
*   none
*
*
* Return Value:
*
*    void
*
* History:
*
*    9/09/1999 Original Version
*
\**************************************************************************/
VOID CWiaLog::ProcessTruncation()
{
    //
    // determine file size
    //

    DWORD dwFileSize = 0;
    BY_HANDLE_FILE_INFORMATION  fi;

    if (!GetFileInformationByHandle(m_hLogFile,&fi)) {
        //DPRINTF(DM_TRACE,TEXT("WIALOG could not get file size for log file. "));
        return;
    }

    dwFileSize = fi.nFileSizeLow;
    if (dwFileSize > MAX_TRUNCATE_SIZE) {

        //
        // Allocate a temporary buffer
        //

        BYTE *pBuffer = NULL;
        DWORD dwBytesRead = 0;
        DWORD dwBytesWritten = 0;
        pBuffer = (BYTE*)LocalAlloc(LPTR,MAX_TRUNCATE_SIZE);
        if (pBuffer != NULL) {

            BOOL bRead = FALSE;

            //
            // read buffered data
            //

            ::SetFilePointer(m_hLogFile,dwFileSize - MAX_TRUNCATE_SIZE,NULL,FILE_BEGIN);

            bRead = ::ReadFile(m_hLogFile,(VOID*)pBuffer,MAX_TRUNCATE_SIZE,&dwBytesRead,NULL);

            //
            // nuke existing file
            //

            ::SetFilePointer(m_hLogFile, 0, NULL, FILE_BEGIN );
            ::SetEndOfFile(m_hLogFile );

            if (bRead) {
                //
                // Write buffer to file
                //

                ::WriteFile(m_hLogFile,pBuffer,MAX_TRUNCATE_SIZE,&dwBytesWritten,NULL);

                //
                // Write Truncation Header
                //

                WriteStringToLog(TEXT(" "), FLUSH_STATE);
                WriteStringToLog(TEXT("============================================================================="), FLUSH_STATE);
                TCHAR szHeader[MAX_PATH];
                lstrcpy(szHeader,m_szFmtDLLName);
                lstrcat(szHeader,TEXT(" REQUESTED A FILE TRUNCATION"));
                WriteStringToLog(TEXT("          (Data above this marker is saved from a previous session)"), FLUSH_STATE);
                WriteStringToLog(TEXT("============================================================================="), FLUSH_STATE);
                WriteStringToLog(TEXT(" "), FLUSH_STATE);
            }

            LocalFree(pBuffer);
        }
    } else {

        //
        // File is too small, and does not need to be truncated
        //

        return;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\svcinfo.cpp ===
/*++

Copyright    (c)    1997    Microsoft Corporation

Module  Name :

    svcinfo.cpp

Abstract:

    This module contains the common code for the sti services which involves the
    Service Controller dispatch functions.

Author:

    Vlad Sadovsky (vlads)   22-Sep-1997


Environment:

    User Mode - Win32

Revision History:

    22-Sep-1997     VladS       created

--*/

//
//  Include Headers
//

#include "cplusinc.h"
#include "sticomm.h"

#include <svcinfo.h>

BOOL              g_fIgnoreSC = TRUE;

SVC_INFO::SVC_INFO(
    IN  LPCTSTR                          lpszServiceName,
    IN  TCHAR *                           lpszModuleName,
    IN  PFN_SERVICE_SPECIFIC_INITIALIZE  pfnInitialize,
    IN  PFN_SERVICE_SPECIFIC_CLEANUP     pfnCleanup,
    IN  PFN_SERVICE_SPECIFIC_PNPPWRHANDLER pfnPnpPower
    )
/*++
    Desrcription:

        Contructor for SVC_INFO class.
        This constructs a new service info object for the service specified.

    Arguments:

        lpszServiceName
            name of the service to be created.

        lpszModuleName
            name of the module for loading string resources.

        pfnInitialize
            pointer to function to be called for initialization of
             service specific data

        pfnCleanup
            pointer to function to be called for cleanup of service
             specific data

--*/
{

    ASSERT( pfnInitialize != NULL && pfnCleanup    != NULL && pfnPnpPower!=NULL);

    m_sServiceName.Copy(lpszServiceName) ;
    m_sModuleName.Copy(lpszModuleName);

    //
    //  Initialize the service status structure.
    //

    m_svcStatus.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    m_svcStatus.dwCurrentState            = SERVICE_STOPPED;
    m_svcStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP
                                              | SERVICE_ACCEPT_PAUSE_CONTINUE
                                              | SERVICE_ACCEPT_SHUTDOWN;
    m_svcStatus.dwWin32ExitCode           = NO_ERROR;
    m_svcStatus.dwServiceSpecificExitCode = NO_ERROR;
    m_svcStatus.dwCheckPoint              = 0;
    m_svcStatus.dwWaitHint                = 0;

    //
    //  Initialize Call back functions
    //

    m_pfnInitialize = pfnInitialize;
    m_pfnCleanup    = pfnCleanup;
    m_pfnPnpPower   = pfnPnpPower;

    m_dwSignature = SIGNATURE_SVC;

    m_hShutdownEvent= NULL;

    return;

} // SVC_INFO::SVC_INFO()


SVC_INFO::~SVC_INFO( VOID)
/*++

    Description:

        Cleanup the SvcInfo object. If the service is not already
         terminated, it terminates the service before cleanup.

    Arguments:
        None

    Returns:
        None

--*/
{
    if ( m_hShutdownEvent != NULL) {

        ::CloseHandle( m_hShutdownEvent);
    }

    m_dwSignature = SIGNATURE_SVC_FREE;

} // SVC_INFO::~SVC_INFO()


DWORD
SVC_INFO::StartServiceOperation(
    IN  PFN_SERVICE_CTRL_HANDLER         pfnCtrlHandler
    )
/*++
    Description:

        Starts the operation of service instantiated in the given
           Service Info Object.


    Arguments:

        pfnCtrlHandler
            pointer to a callback function for handling dispatch of
            service controller requests. A separate function is required
            since Service Controller call back function does not send
            context information.

    Returns:

        NO_ERROR on success and Win32 error code if any failure.
--*/
{

    DWORD err;
    DWORD cbBuffer;
    BOOL  fInitCalled = FALSE;

    if ( !IsValid()) {

        //
        // Not successfully initialized.
        //

        return ( ERROR_INVALID_FUNCTION);
    }

    if ( !g_fIgnoreSC ) {

        m_hsvcStatus = RegisterServiceCtrlHandler(
                            QueryServiceName(),
                            pfnCtrlHandler
                            );

        //
        //  Register the Control Handler routine.
        //

        if( m_hsvcStatus == NULL_SERVICE_STATUS_HANDLE ) {

            err = GetLastError();
            goto Cleanup;
        }
    } else {
        m_hsvcStatus = NULL_SERVICE_STATUS_HANDLE;
    }

    //
    //  Update the service status.
    //

    err = UpdateServiceStatus( SERVICE_START_PENDING,
                               NO_ERROR,
                               1,
                               SERVICE_START_WAIT_HINT );

    if( err != NO_ERROR ) {
        goto Cleanup;
    }

    //
    //  Initialize the service common components
    //
    #ifdef BUGBUG
    if ( !InitializeNTSecurity()) {
        err = GetLastError();
        goto Cleanup;
    }
    #endif

    //
    //  Initialize the various service specific components.
    //

    err = ( *m_pfnInitialize)( this);
    fInitCalled = TRUE;

    if( err != NO_ERROR ) {
        goto Cleanup;
    }

    //
    //  Create shutdown event.
    //

    m_hShutdownEvent = CreateEvent( NULL,           //  lpsaSecurity
                                    TRUE,           //  fManualReset
                                    FALSE,          //  fInitialState
                                    NULL );         //  lpszEventName

    if( m_hShutdownEvent == NULL )
    {
        err = GetLastError();
        goto Cleanup;
    }



    //
    //  Update the service status.
    //

    err = UpdateServiceStatus( SERVICE_RUNNING,
                               NO_ERROR,
                               0,
                               0 );

    if( err != NO_ERROR ) {
        goto Cleanup;
    }


    //
    //  Wait for the shutdown event.
    //

    err = WaitForSingleObject( m_hShutdownEvent,
                               INFINITE );

    if ( err != WAIT_OBJECT_0) {

        //
        // Error. Unable to wait for single object.
        //
    }
    //
    //  Stop time.  Tell the Service Controller that we're stopping,
    //  then terminate the various service components.
    //

    UpdateServiceStatus( SERVICE_STOP_PENDING,
                         0,
                         1,
                         SERVICE_STOP_WAIT_HINT );


    //
    //  Destroy the shutdown event.
    //

    if( m_hShutdownEvent != NULL ) {

        if ( ! CloseHandle( m_hShutdownEvent ) ) {

            err = GetLastError();
        }

        m_hShutdownEvent = NULL;
    }

    //
    //  Update the service status.
    //
    //
    // Log successful start

    err = UpdateServiceStatus( SERVICE_RUNNING,
                               NO_ERROR,
                               0,
                               0 );

    if( err != NO_ERROR )
    {
        goto Cleanup;
    }

    return TRUE;

Cleanup:

    if ( fInitCalled) {
        //
        // Cleanup partially initialized modules
        //
        DWORD err1 = ( *m_pfnCleanup)( this);

        if ( err1 != NO_ERROR) {
            //
            // Compound errors possible
            //
            if ( err != NO_ERROR) {
            }
        }
    }

    //
    //  If we managed to actually connect to the Service Controller,
    //  then tell it that we're stopped.
    //

    if ( m_hsvcStatus != NULL_SERVICE_STATUS_HANDLE )
    {
        UpdateServiceStatus( SERVICE_STOPPED,
                             err,
                             0,
                             0 );
    }

    return ( err);

} // SVC_INFO::StartServiceOperation()


DWORD
SVC_INFO::UpdateServiceStatus(
        IN DWORD dwState,
        IN DWORD dwWin32ExitCode,
        IN DWORD dwCheckPoint,
        IN DWORD dwWaitHint )
/*++
    Description:

        Updates the local copy status of service controller status
         and reports it to the service controller.

    Arguments:

        dwState - New service state.

        dwWin32ExitCode - Service exit code.

        dwCheckPoint - Check point for lengthy state transitions.

        dwWaitHint - Wait hint for lengthy state transitions.

    Returns:

        NO_ERROR on success and returns Win32 error if failure.
        On success the status is reported to service controller.

--*/
{

    m_svcStatus.dwCurrentState  = dwState;
    m_svcStatus.dwWin32ExitCode = dwWin32ExitCode;
    m_svcStatus.dwCheckPoint    = dwCheckPoint;
    m_svcStatus.dwWaitHint      = dwWaitHint;

    if ( !g_fIgnoreSC ) {

        return ReportServiceStatus();

    } else {

        return ( NO_ERROR);
    }

} // SVC_INFO::UpdateServiceStatus()



DWORD
SVC_INFO::ReportServiceStatus( VOID)
/*++
    Description:

        Wraps the call to SetServiceStatus() function.
        Prints the service status data if need be

    Arguments:

        None

    Returns:

        NO_ERROR if successful. other Win32 error code on failure.
        If successfull the new status has been reported to the service
         controller.
--*/
{
    DWORD err = NO_ERROR;

    if ( !g_fIgnoreSC ) {

        if( !SetServiceStatus( m_hsvcStatus, &m_svcStatus ) ) {

            err = GetLastError();
        }

    } else {

        err = NO_ERROR;
    }

    return err;
}   // SVC_INFO::ReportServiceStatus()



VOID
SVC_INFO::ServiceCtrlHandler ( IN DWORD dwOpCode)
/*++
    Description:

        This function received control requests from the service controller.
        It runs in the context of service controller's dispatcher thread and
        performs the requested function.
        ( Note: Avoid time consuming operations in this function.)

    Arguments:

        dwOpCode
            indicates the requested operation. This should be
            one of the SERVICE_CONTROL_* manifests.


    Returns:
        None. If successful, then the state of the service might be changed.

    Note:
        if an operation ( especially SERVICE_CONTROL_STOP) is very lengthy,
         then this routine should report a STOP_PENDING status and create
         a worker thread to do the dirty work. The worker thread would then
         perform the necessary work and for reporting timely wait hints and
         final SERVICE_STOPPED status.

--*/
{
    //
    //  Interpret the opcode.
    //

    switch( dwOpCode )
    {
    case SERVICE_CONTROL_INTERROGATE :
        InterrogateService();
        break;

    case SERVICE_CONTROL_STOP :
        StopService();
        break;

    case SERVICE_CONTROL_PAUSE :
        PauseService();
        break;

    case SERVICE_CONTROL_CONTINUE :
        ContinueService();
        break;

    case SERVICE_CONTROL_SHUTDOWN :
        ShutdownService();
        break;

    default :
        ASSERTSZ(FALSE,TEXT("Unrecognized Service Opcode"));
        break;
    }

    //
    //  Report the current service status back to the Service
    //  Controller.  The workers called to implement the OpCodes
    //  should set the m_svcStatus.dwCurrentState field if
    //  the service status changed.
    //

    ReportServiceStatus();

}   // SVC_INFO::ServiceCtrlHandler()



VOID
SVC_INFO::InterrogateService( VOID )
/*++
    Description:

        This function interrogates with the service status.
        Actually, nothing needs to be done here; the
        status is always updated after a service control.
        We have this function here to provide useful
        debug info.

--*/
{
    return;

}   // SVC_INFO::InterrogateService()




VOID
SVC_INFO::StopService( VOID )
/*++
    Description:
        Stops the service. If the stop cannot be performed in a
        timely manner, a worker thread needs to be created to do the
        original cleanup work.

    Returns:
        None. If successful, then the service will be stopped.
        The final action of this function is signal the handle for
        shutdown event. This will release the main thread which does
        necessary cleanup work.

--*/
{
    m_svcStatus.dwCurrentState = SERVICE_STOP_PENDING;
    m_svcStatus.dwCheckPoint   = 0;

    SetEvent( m_hShutdownEvent);

    return;
}   // SVC_INFO::StopService()




VOID
SVC_INFO::PauseService( VOID )
/*++
    Description:

        This function pauses the service. When the service is paused,
        no new user sessions are to be accepted, but existing connections
        are not effected.

        This function must update the SERVICE_STATUS::dwCurrentState
         field before returning.

    Returns:

        None. If successful the service is paused.

--*/
{
    m_svcStatus.dwCurrentState = SERVICE_PAUSED;

    return;
}   // SVC_INFO::PauseService()



VOID
SVC_INFO::ContinueService( VOID )
/*++

    Description:
        This function restarts ( continues) a paused service. This
        will return the service to the running state.

        This function must update the m_svcStatus.dwCurrentState
         field to running mode before returning.

    Returns:
        None. If successful then the service is running.

--*/
{
    m_svcStatus.dwCurrentState = SERVICE_RUNNING;

    return;
}   // SVC_INFO::ContinueService()



VOID
SVC_INFO::ShutdownService( VOID )
/*++
    Description:

        This function performs the shutdown on a service.
        This is called during system shutdown.

        This function is time constrained. The service controller gives a
        maximum of 20 seconds for shutdown for all active services.
        Only timely operations should be performed in this function.

    Returns:

        None. If successful, the service is shutdown.
--*/
{
    DWORD   dwCurrentState;

    //
    // Verify state of the service
    //
    dwCurrentState = QueryCurrentServiceState();

    if ((dwCurrentState !=SERVICE_PAUSED) &&
        (dwCurrentState !=SERVICE_RUNNING) ) {

        ASSERT( FALSE);
        return;
    }

    m_svcStatus.dwCurrentState = SERVICE_STOP_PENDING;
    m_svcStatus.dwCheckPoint   = 0;

    SetEvent( m_hShutdownEvent);

    //
    //  Stop time.  Tell the Service Controller that we're stopping,
    //  then terminate the various service components.
    //

    UpdateServiceStatus( SERVICE_STOP_PENDING,
                         0,
                         1,
                         SERVICE_STOP_WAIT_HINT );


    DWORD err = ( *m_pfnCleanup)( this);

    UpdateServiceStatus( SERVICE_STOPPED,
                         err,
                         0,
                         0 );

    return;

}   // SVC_INFO::ShutdownService()


//
// IUnknown methods. Used only for reference counting
//
STDMETHODIMP
SVC_INFO::QueryInterface( REFIID riid, LPVOID * ppvObj)
{
    return E_FAIL;
}

STDMETHODIMP_(ULONG)
SVC_INFO::AddRef( void)
{
    ::InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG)
SVC_INFO::Release( void)
{
    LONG    cNew;

    if(!(cNew = ::InterlockedDecrement(&m_cRef))) {
        delete this;
    }

    return cNew;
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\wiaguid\wiapriv_guids.c ===
#include <wiapriv_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\stirt\wiaevent.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    wiaevent.c

Abstract:

    Implementation of STI registration logic over WIA event interface

Notes:

Author:

    Vlad Sadovsky   (VladS)    11/24/1999

Environment:

    User Mode - Win32

Revision History:

    11/24/1999      VladS       Created

--*/

//
// Include files
//


/*
#define COBJMACROS

#include "wia.h"
#include "wia.h"
#include <stiregi.h>

#include <sti.h>
#include <stierr.h>
#include <stiusd.h>
#include "stipriv.h"
#include "debug.h"
*/
#include "sticomm.h"

#define DbgFl DbgFlDevice

//
// Helper functions
//

CHAR* GetStringIntoBuf(CHAR* pInputString, CHAR* pBuf, DWORD dwBufSize)
{
    CHAR    *pCur       = pInputString;
    CHAR    EndChar     = ' ';
    CHAR    *pEndPos    = NULL;
    ULONG   ulIndex     = 0;

    if (pInputString) {
        pEndPos = pInputString + lstrlenA(pInputString);

        //
        // Eat leading white spaces
        //
        while ((*pCur == ' ') && (pCur < pEndPos)) {
            pCur++;
        }

        //
        // Look for string delimiter.  Default is space, but check for quote.
        //
        if (*pCur == '"') {
            EndChar = '"';
            if (pCur < pEndPos) {
                pCur++;
            }
        }

        while ((*pCur != EndChar) && (pCur < pEndPos)) {
            pBuf[ulIndex] = *pCur;
            if (ulIndex >= dwBufSize) {
                break;
            }
            ulIndex++;
            pCur++;
        }

        if (pCur < pEndPos) {
            pCur++;
        }
    }
    return pCur;
}

BOOL
GetEventInfoFromCommandLine(
                          LPSTR   lpszCmdLine,
                          WCHAR   *wszName,
                          WCHAR   *wszWide,
                          BOOL    *pfSetAsDefault
                          )
/*++

Routine Description:
    Helper function to parse command line

Arguments:

    pszWide         Command line to be launched
    fSetAsDefault   Set as default registered application callback

Return Value:

    Status

--*/
{
    HRESULT         hr                  = E_FAIL;
    CHAR            szName[MAX_PATH]    = {'\0'};
    CHAR            szWide[MAX_PATH]    = {'\0'};
    CHAR            szOut[MAX_PATH]     = {'\0'};
    CHAR            *pCur               = NULL;

    if (lpszCmdLine) {

        //
        // Get the App name
        //
        memset(szName, 0, sizeof(szName));
        pCur = GetStringIntoBuf(lpszCmdLine, szName, MAX_PATH);
        szName[MAX_PATH - 1] = '\0';

        //
        // Get the CommandLine
        //
        memset(szWide, 0, sizeof(szWide));
        pCur = GetStringIntoBuf(pCur, szWide, MAX_PATH);
        szWide[MAX_PATH - 1] = '\0';

        //
        // Get the bool indicating whether App is default event handler
        //
        if (pCur) {
            sscanf(pCur, "%d", pfSetAsDefault);
        } else {
            *pfSetAsDefault = FALSE;
        }
    }

    if (MultiByteToWideChar(CP_ACP,
                            0,
                            szName,
                            -1,
                            wszName,
                            MAX_PATH))
    {
        if (MultiByteToWideChar(CP_ACP,
                                0,
                                szWide,
                                -1,
                                wszWide,
                                MAX_PATH))
        {
            hr = S_OK;
        } else {
            hr = E_FAIL;
        }

    } else {
        hr = E_FAIL;
    }

    return hr;
}


//
// Public functions
//

VOID
EXTERNAL
RegSTIforWiaHelper(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    HRESULT             hr                  = E_FAIL;
    WCHAR               wszName[MAX_PATH]   = {L'\0'};
    WCHAR               wszWide[MAX_PATH]   = {L'\0'};
    BOOL                fSetAsDefault       = 0;

    hr = GetEventInfoFromCommandLine(lpszCmdLine, wszName, wszWide, &fSetAsDefault);
    if (SUCCEEDED(hr)) {
        if (RegisterSTIAppForWIAEvents(wszName, wszWide, fSetAsDefault)) {
            #ifdef MAXDEBUG
            OutputDebugStringA("* RegisterSTIAppForWIAEvents successful\n");
            #endif
        }
    }
}


BOOL
RegisterSTIAppForWIAEvents(
    WCHAR   *pszName,
    WCHAR   *pszWide,
    BOOL    fSetAsDefault)
/*++

Routine Description:

Arguments:

Return Value:

    TRUE    -   Success
    FALSE   -   Not

--*/
{
    HRESULT             hr;
    IWiaDevMgr         *pIDevMgr;
    BSTR                bstrName;
    BSTR                bstrDescription;
    BSTR                bstrIcon;
    BSTR                bstrDeviceID;
    IWiaItem           *pIRootItem;
    IEnumWIA_DEV_CAPS  *pIEnum;
    WIA_EVENT_HANDLER   wiaHandler;
    ULONG               ulFetched;
    BSTR                bstrProgram;

    hr = CoInitialize(NULL);
    if (FAILED(hr) && hr != RPC_E_CHANGED_MODE) {
        // Failed to initialize COM
        DebugOutPtszV(DbgFl,TEXT("CoInitializeFailed!!!"));
        return hr;
    }
    hr = CoCreateInstance(
                         &CLSID_WiaDevMgr,
                         NULL,
                         CLSCTX_LOCAL_SERVER,
                         &IID_IWiaDevMgr,
                         (void**)&pIDevMgr);

    if ( FAILED(hr) || !pIDevMgr ) {
        // Failed to get interface
        DebugOutPtszV(DbgFl,TEXT("Could not get access to WiaDevMgr interface"));
        CoUninitialize();
        return FALSE;
    }

    bstrProgram     = SysAllocString(pszWide);
    if ( pszName ) {
        bstrName        = SysAllocString(pszName);
    } else {
        bstrName        = SysAllocString(L"STI");
    }

    bstrDescription = SysAllocString(bstrName);
    bstrIcon        = SysAllocString(L"sti.dll,0");

    //
    // Register a program
    //
    if ( bstrDescription && bstrIcon && bstrName ) {

        hr = IWiaDevMgr_RegisterEventCallbackProgram(
                                                    pIDevMgr,
                                                    WIA_REGISTER_EVENT_CALLBACK,
                                                    NULL,
                                                    &WIA_EVENT_STI_PROXY,
                                                    bstrProgram,
                                                    bstrName,
                                                    bstrDescription,
                                                    bstrIcon);
    } else {
        DebugOutPtszV(DbgFl,TEXT("Could not get unicode strings for event registration, out of memory "));
        AssertF(FALSE);
    }

    if ( bstrDescription ) {
        SysFreeString(bstrDescription);bstrDescription=NULL;
    }
    if ( bstrIcon ) {
        SysFreeString(bstrIcon);bstrIcon=NULL;
    }
    if ( bstrName ) {
        SysFreeString(bstrName);bstrName=NULL;
    }

    IWiaDevMgr_Release(pIDevMgr);

    CoUninitialize();
    return TRUE;
}


VOID
WINAPI
MigrateSTIAppsHelper(
                                    HWND        hWnd,
                                    HINSTANCE   hInst,
                                    PTSTR       pszCommandLine,
                                    INT         iParam
                                    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    HRESULT     hr;

    DWORD       dwError;
    DWORD       dwIndex, dwType;
    DWORD       cbData,cbName;

    CHAR        szAppCmdLine[MAX_PATH];
    CHAR        szAppName[MAX_PATH];

    WCHAR       *pwszNameW = NULL;
    WCHAR       *pwszAppCmdLineW = NULL;

    HKEY        hkeySTIApps;

    hr = CoInitialize(NULL);

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,         // hkey
                           REGSTR_PATH_REG_APPS,       // reg entry string
                           0,                          // dwReserved
                           KEY_READ,                   // access
                           &hkeySTIApps);              // pHkeyReturned.

    if ( NOERROR == dwError ) {

        for ( dwIndex = 0; dwError == ERROR_SUCCESS; dwIndex++ ) {

            dwType = 0;

            *szAppCmdLine = TEXT('\0');
            *szAppName = TEXT('\0');

            cbData = sizeof(szAppCmdLine);
            cbName = sizeof(szAppName);

            dwError = RegEnumValueA(hkeySTIApps,
                                   dwIndex,
                                   szAppName,
                                   &cbName,
                                   NULL,
                                   &dwType,
                                   (LPBYTE)szAppCmdLine,
                                   &cbData);

            if ( ((dwType == REG_SZ ) ||(dwType == REG_EXPAND_SZ ))
                 && *szAppCmdLine ) {

                if ( SUCCEEDED(OSUtil_GetWideString(&pwszNameW,szAppName)) &&
                     SUCCEEDED(OSUtil_GetWideString(&pwszAppCmdLineW,szAppCmdLine))
                   ) {

                    RegisterSTIAppForWIAEvents(pwszNameW,pwszAppCmdLineW,FALSE);
                }

                FreePpv(&pwszNameW);
                FreePpv(&pwszAppCmdLineW);
            }
        }

        RegCloseKey(hkeySTIApps);

    }

    CoUninitialize();

    return ;
}

#define RUNDLL_NAME "\\rundll32.exe"
#define RUNDLL_CMD_LINE " sti.dll,RegSTIforWia"
HRESULT RunRegisterProcess(
    CHAR   *szAppName,
    CHAR   *szCmdLine)
{
    HRESULT hr = E_FAIL;
    CHAR    szRunDllName[MAX_PATH]  = {'\0'};
    CHAR    szCommandLine[MAX_PATH] = {'\0'};
    CHAR    szComdLine[MAX_PATH] = {'\0'};
    UINT    uiCharCount = 0;

    STARTUPINFOA            startupInfo;
    PROCESS_INFORMATION     processInfo;

    DWORD   dwWait = 0;

#ifdef WINNT
    uiCharCount = GetSystemDirectoryA(szRunDllName,
                                       MAX_PATH);
#else
    uiCharCount = GetWindowsDirectoryA(szRunDllName,
                                       MAX_PATH);
#endif

    if ((uiCharCount + lstrlenA(RUNDLL_NAME) + sizeof(CHAR)) >= MAX_PATH ) {
        return hr;
    }

    lstrcatA(szRunDllName, RUNDLL_NAME);
    if (szAppName) {
        wsprintfA(szCommandLine, "%s \"%s\" \"%s\" %d", RUNDLL_CMD_LINE, szAppName, szCmdLine, 0);
    } else {
        wsprintfA(szCommandLine, "%s STI \"%s\" %d", RUNDLL_CMD_LINE, szCmdLine, 0);
    }

    memset(&startupInfo, 0, sizeof(startupInfo));
    memset(&processInfo, 0, sizeof(processInfo));

    if (CreateProcessA(szRunDllName,
                       szCommandLine,
                       NULL,
                       NULL,
                       FALSE,
                       0,
                       NULL,
                       NULL,
                       &startupInfo,
                       &processInfo))
    {
        CloseHandle(processInfo.hThread);
        CloseHandle(processInfo.hProcess);
        hr = S_OK;
    } else {
        hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\wiaguid\wiascr_guids.c ===
#include <wiascr_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\wiaguid\wiamindr_guids.c ===
#include <wiamindr_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\wiaguid\wiavideo_guids.c ===
#include <wiavideo_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\rpc\imports.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created



--*/


#ifdef MIDL_PASS
#define WIN32_LEAN_AND_MEAN
#define _NO_COM
#endif

#include <windows.h>

#include <sti.h>
#include <stiapi.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPSTR [string] char*
#define BOOL DWORD
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\common\wiaguid\wia_guids.c ===
#include <wia_i.c>
#include <wiapriv_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\adddevice.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       AddDevice.cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      Marke
*
*  DATE:        9 Jan, 1998
*
*  DESCRIPTION:
*   Temp UI for adding Wia remote devices
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include <wiamindr.h>
#include <wiadbg.h>

#include "wiacfact.h"
#include "devmgr.h"
#include "devinfo.h"
#include "resource.h"
#include "helpers.h"

//
// global info
//

WIA_ADD_DEVICE  *gpAddDev;
IWiaDevMgr      *gpIWiaDevMgr;

extern HINSTANCE g_hInst;

#define REGSTR_PATH_STICONTROL_W            L"System\\CurrentControlSet\\Control\\StillImage"
#define REGSTR_PATH_STICONTROL_DEVLIST_W    L"System\\CurrentControlSet\\Control\\StillImage\\DevList"

#ifdef WINNT

/**************************************************************************\
* AddDeviceDlgProc
*
*   Dialog proc for add device dialog.
*
* Arguments:
*
*   hDlg    - window handle of the dialog box
*   message - type of message
*   wParam  - message-specific information
*   lParam  - message-specific information
*
* Return Value:
*
*    Status
*
* History:
*
*    1/11/1999 Original Version
*
\**************************************************************************/

INT_PTR
APIENTRY AddDeviceDlgProc(
   HWND     hDlg,
   UINT     message,
   WPARAM   wParam,
   LPARAM   lParam
)
{
    LPWSTR lpwstrName;
    UINT ui;
    UINT uButton;

    switch (message) {
    case WM_INITDIALOG:

        //
        // default is local
        //

        CheckRadioButton(hDlg,IDC_LOCAL,IDC_REMOTE,IDC_REMOTE);

        break;

        case WM_COMMAND:
            switch(wParam) {


                //
                // end function
                //

                case IDOK:

                    lpwstrName = &gpAddDev->wszServerName[0];

                    ui = GetDlgItemTextW(hDlg,IDC_DRIVER_NAME,lpwstrName,MAX_PATH);

                    uButton = (UINT)SendDlgItemMessage(hDlg,IDC_LOCAL,BM_GETCHECK,0,0);

                    if (uButton == 1) {
                        gpAddDev->bLocal = TRUE;
                    } else {
                        gpAddDev->bLocal = FALSE;
                    }

                    EndDialog(hDlg, FALSE);
                    return (TRUE);

               case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return (TRUE);
            }
            break;
    }
    return (FALSE);
}

/**************************************************************************\
* DevListDlgProc
*
*   Dialog proc for device list dialog.
*
* Arguments:
*
*   hDlg    - window handle of the dialog box
*   message - type of message
*   wParam  - message-specific information
*   lParam  - message-specific information
*
* Return Value:
*
*    Status
*
* History:
*
*    1/11/1999 Original Version
*
\**************************************************************************/

INT_PTR
APIENTRY DevListDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
    static LONG cDevice = 0;
    static BSTR bstrDevice[16];

    switch (message) {
    case WM_INITDIALOG:
        if (gpIWiaDevMgr != NULL) {

            IEnumWIA_DEV_INFO   *pWiaEnumDevInfo;
            HRESULT              hr;
            LONG                 cDevice = 0;

            //
            // get device list, only want to see local devices
            //

            hr = gpIWiaDevMgr->EnumDeviceInfo(WIA_DEVINFO_ENUM_LOCAL,&pWiaEnumDevInfo);

            if (hr == S_OK) {

                do
                {
                    IWiaPropertyStorage  *pIWiaPropStg;
                    ULONG cEnum;

                    //
                    // get next device
                    //

                    hr = pWiaEnumDevInfo->Next(1,&pIWiaPropStg,&cEnum);

                    if (hr == S_OK)
                    {
                        //
                        // read device name
                        //

                        PROPSPEC        PropSpec[2];
                        PROPVARIANT     PropVar[2];

                        memset(PropVar,0,sizeof(PropVar));

                        PropSpec[0].ulKind = PRSPEC_PROPID;
                        PropSpec[0].propid = WIA_DIP_DEV_ID;

                        PropSpec[1].ulKind = PRSPEC_PROPID;
                        PropSpec[1].propid = WIA_DIP_DEV_DESC;

                        hr = pIWiaPropStg->ReadMultiple(sizeof(PropSpec)/sizeof(PROPSPEC),
                                            PropSpec,
                                            PropVar);

                        if (hr == S_OK)
                        {
                            CHAR szTemp[ MAX_PATH ];

                            //
                            // make sure property is string based
                            //

                            if (PropVar[0].vt == VT_BSTR)
                            {

                                //WideCharToMultiByte(CP_ACP,
                                //          0,
                                //          PropVar[1].bstrVal,
                                //          -1,
                                //          szTemp,
                                //          MAX_PATH,
                                //          NULL,
                                //          NULL);
                                //
                                //SendDlgItemMessage(hDlg,IDC_COMBO1,CB_INSERTSTRING,cDevice,(long)szTemp);
                                //

                                SendDlgItemMessageW(hDlg,IDC_COMBO1,CB_INSERTSTRING,cDevice,(LONG_PTR)PropVar[1].bstrVal);

                                bstrDevice[cDevice] = ::SysAllocString(PropVar[0].bstrVal);
                                cDevice++;

                            }

                            FreePropVariantArray(sizeof(PropSpec)/sizeof(PROPSPEC),PropVar);
                        }
                        else {
                            ReportReadWriteMultipleError(hr, "DevListDlgProc", NULL, TRUE, sizeof(PropSpec)/sizeof(PROPSPEC), PropSpec);
                        }
                        pIWiaPropStg->Release();
                    }

                } while (hr == S_OK);

                SendDlgItemMessage(hDlg,IDC_COMBO1,CB_SETCURSEL,0,0);

                pWiaEnumDevInfo->Release();
            } else {
                TCHAR msg[MAX_PATH];

                wsprintf(msg,TEXT("Error code = 0x%lx"),hr);
                MessageBox(NULL,msg,TEXT("Error in EnumDeviceInfo"),MB_OK);
                EndDialog(hDlg, FALSE);
            }
        }

        break;

        case WM_COMMAND:
            switch(wParam) {


                //
                // end function
                //

                case IDOK:
                {

                    LRESULT lRet = SendDlgItemMessage(hDlg,IDC_COMBO1,CB_GETCURSEL,0,0);

                    if (lRet != CB_ERR) {

                        gpAddDev->bstrDeviceID = bstrDevice[lRet];

                        bstrDevice[lRet] = NULL;

                        for (int index=0;index<cDevice;index++) {
                            if (bstrDevice[index] != NULL) {
                                    SysFreeString(bstrDevice[index] );
                            }
                        }

                    }


                    EndDialog(hDlg, (lRet != CB_ERR));

                    return (TRUE);
                }

               case IDCANCEL:

                   for (int index=0;index<cDevice;index++) {
                        if (bstrDevice[index] != NULL) {
                                SysFreeString(bstrDevice[index] );
                        }
                    }

                    EndDialog(hDlg, FALSE);
                    return (TRUE);
            }
            break;
    }
    return (FALSE);
}


PROPID propidDev[WIA_NUM_DIP] =
{
    WIA_DIP_DEV_ID       ,
    WIA_DIP_VEND_DESC    ,
    WIA_DIP_DEV_DESC     ,
    WIA_DIP_DEV_TYPE     ,
    WIA_DIP_PORT_NAME    ,
    WIA_DIP_DEV_NAME     ,
    WIA_DIP_SERVER_NAME  ,
    WIA_DIP_REMOTE_DEV_ID,
    WIA_DIP_UI_CLSID
};

LPOLESTR pszPropName[WIA_NUM_DIP] =
{
    WIA_DIP_DEV_ID_STR,
    WIA_DIP_VEND_DESC_STR,
    WIA_DIP_DEV_DESC_STR,
    WIA_DIP_DEV_TYPE_STR,
    WIA_DIP_PORT_NAME_STR,
    WIA_DIP_DEV_NAME_STR,
    WIA_DIP_SERVER_NAME_STR,
    WIA_DIP_REMOTE_DEV_ID_STR,
    WIA_DIP_UI_CLSID_STR
};

DWORD pszPropType[WIA_NUM_DIP] =
{
    REG_SZ,
    REG_SZ,
    REG_SZ,
    REG_DWORD,
    REG_SZ,
    REG_SZ,
    REG_SZ,
    REG_SZ,
    REG_SZ
};

/**************************************************************************\
*  WriteDeviceProperties
*
*   Write all device information properties to registry.
*
* Arguments:
*
*   hKeySetup - Open registry key.
*   pAddDev   - Add device information data.
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT
WriteDeviceProperties(
    HKEY hKeySetup,
    WIA_ADD_DEVICE *pAddDev
    )
{
    DBG_FN(::WriteDeviceProperties);
    HRESULT hr = S_OK;
    HKEY    hKeyDevice;
    LONG    lResult;

    //
    // build device connection name as SERVER-INDEX
    //

    WCHAR wszTemp[MAX_PATH];
    WCHAR *wszServer = pAddDev->wszServerName;
    WCHAR *wszIndex  = pAddDev->bstrDeviceID;

    //
    // skip leading \\ if it is there
    //

    if (wszServer[0] == L'\\') {
        wszServer = &wszServer[2];
    }

    //
    // skip STI CLASS
    //

    wszIndex = &wszIndex[39];

    lstrcpyW(wszTemp,wszServer);
    lstrcatW(wszTemp,L"-");
    lstrcatW(wszTemp,wszIndex);

    //
    // try to create remote device
    //

    IWiaItem *pWiaItemRoot = NULL;

    hr = gpIWiaDevMgr->CreateDevice(pAddDev->bstrDeviceID, &pWiaItemRoot);

    if (hr == S_OK) {


        //
        // read device properties
        //

        IWiaPropertyStorage *piprop;

        hr = pWiaItemRoot->QueryInterface(IID_IWiaPropertyStorage,(void **)&piprop);

        if (hr == S_OK) {

            //
            // read dev info prop
            //

            PROPSPEC        PropSpec[WIA_NUM_DIP];
            PROPVARIANT     PropVar[WIA_NUM_DIP];

            memset(PropVar,0,sizeof(PropVar));

            for (int Index = 0;Index<WIA_NUM_DIP;Index++)
            {
                PropSpec[Index].ulKind = PRSPEC_PROPID;
                PropSpec[Index].propid = propidDev[Index];
            }

            hr = piprop->ReadMultiple(sizeof(PropSpec)/sizeof(PROPSPEC),
                                      PropSpec,
                                      PropVar);

            if (hr == S_OK) {

                //
                // create device registry entry
                //

                lResult = RegCreateKeyExW(
                                    hKeySetup,
                                    wszTemp,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKeyDevice,
                                    NULL) ;

                if (lResult != ERROR_SUCCESS) {
                    FreePropVariantArray(sizeof(PropSpec)/sizeof(PROPSPEC),PropVar);
                    piprop->Release();
                    pWiaItemRoot->Release();
                    return E_FAIL;
                }


                for (Index = 0;Index<WIA_NUM_DIP;Index++)
                {
                    //
                    // write dev info values to registry
                    //

                    if (pszPropType[Index] == REG_SZ) {

                        //
                        // write string prop
                        //

                        if (PropVar[Index].vt == VT_BSTR) {

                            RegSetValueExW(hKeyDevice,
                                  (LPCWSTR)pszPropName[Index],
                                  0,
                                  pszPropType[Index],
                                  (const UCHAR *)PropVar[Index].bstrVal,
                                  (lstrlenW(PropVar[Index].bstrVal)+1) * sizeof(WCHAR)) ;
                        }

                    } else {

                        //
                        // write int prop
                        //

                        RegSetValueExW(hKeyDevice,
                                  (LPCWSTR)pszPropName[Index],
                                  0,
                                  pszPropType[Index],
                                  (const UCHAR *)&PropVar[Index].lVal,
                                  sizeof(DWORD)) ;

                    }

                }

                //
                // server name must be remote server
                //

                RegSetValueExW(hKeyDevice,
                                  (LPCWSTR)WIA_DIP_SERVER_NAME_STR,
                                  0,
                                  REG_SZ,
                                  (LPBYTE)pAddDev->wszServerName,
                                  (lstrlenW(pAddDev->wszServerName)+1) * sizeof(WCHAR)) ;

                //
                // need a local device ID
                //

                {
                    WCHAR wszLocalID[MAX_PATH];


                    DWORD dwType = REG_SZ;
                    DWORD dwSize = MAX_PATH;

                    RegQueryValueExW(hKeyDevice,
                                               (LPCWSTR)WIA_DIP_DEV_ID_STR,
                                               0,
                                               &dwType,
                                               (LPBYTE)wszLocalID,
                                               &dwSize);
                    //
                    // copy dev id to remote dev id. This is used in calls to
                    // remote dev manager to create the device
                    //

                    RegSetValueExW(hKeyDevice,
                                  (LPCWSTR)WIA_DIP_REMOTE_DEV_ID_STR,
                                  0,
                                  REG_SZ,
                                  (LPBYTE)wszLocalID,
                                  (lstrlenW(wszLocalID)+1) * sizeof(WCHAR)) ;

                    //
                    // make local dev id unique
                    //

                    lstrcatW(wszLocalID,pAddDev->wszServerName);

                    RegSetValueExW(hKeyDevice,
                                  (LPCWSTR)WIA_DIP_DEV_ID_STR,
                                  0,
                                  REG_SZ,
                                  (LPBYTE)wszLocalID,
                                  (lstrlenW(wszLocalID)+1) * sizeof(WCHAR)) ;
                }

                RegCloseKey(hKeyDevice);

            }
            else {
                ReportReadWriteMultipleError(hr, "WriteDeviceProperties", NULL, TRUE, sizeof(PropSpec)/sizeof(PROPSPEC), PropSpec);
            }
            FreePropVariantArray(sizeof(PropSpec)/sizeof(PROPSPEC),PropVar);

            piprop->Release();
        }
        DBG_ERR(("WriteDeviceProperties, QI for IID_IWiaPropertyStorage failed"));
        pWiaItemRoot->Release();
    }
    else {
    }
    return hr;
}

/**************************************************************************\
* VerifyRemoteDeviceList
*
*   Open a registry key to the STI device list.
*
* Arguments:
*
*   phKey - Pointer to returned registry key.
*
* Return Value:
*
*    Status
*
* History:
*
*    3/2/1999 Original Version
*
\**************************************************************************/

HRESULT
VerifyRemoteDeviceList(HKEY *phKey)
{
    DBG_FN(::VerifyRemoteDeviceList);
    HRESULT hr;
    LONG    lResult;

    LPWSTR szKeyNameSTI = REGSTR_PATH_STICONTROL_W;
    LPWSTR szKeyNameDev = REGSTR_PATH_STICONTROL_DEVLIST_W;

    HKEY hKeySTI;
    HKEY hKeyDev;

    *phKey = NULL;


    //
    // try to open dev list
    //

    if (RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                      szKeyNameDev,
                      0,
                      KEY_READ | KEY_WRITE,
                      &hKeyDev) == ERROR_SUCCESS) {

        *phKey = hKeyDev;
        return S_OK;
    }

    //
    // open sti device control and create DevList Key
    //

    if (RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                      szKeyNameSTI,
                      0,
                      KEY_READ | KEY_WRITE,
                      &hKeySTI) == ERROR_SUCCESS) {

        //
        // try to create key
        //

        lResult = RegCreateKeyExW(
                            hKeySTI,
                            L"DevList",
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKeyDev,
                            NULL) ;

        if (lResult == ERROR_SUCCESS) {
            *phKey = hKeyDev;
            hr = S_OK;
        } else {
            DBG_ERR(("VerifyRemoteDeviceList: Couldn't create DevList Key"));
            hr = E_FAIL;
        }

        RegCloseKey(hKeySTI);

    } else {

        DBG_ERR(("VerifyRemoteDeviceList: Couldn't open STI DeviceControl Key"));
        hr = E_FAIL;
    }
    return(hr);
}




/**************************************************************************\
*  DisplayAddDlg
*
*   Put up the add device dialog.
*
* Arguments:
*
*   pAddDev   - Add device information data.
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT
DisplayAddDlg(WIA_ADD_DEVICE *pAddDev)
{
    DBG_FN(::DisplayAddDlg);
    if (pAddDev == NULL) {
        return E_INVALIDARG;
    }

    HRESULT         hr = S_OK;

    //
    // if reentrant then need semaphore
    //

    gpAddDev = pAddDev;

    INT_PTR iret = DialogBox(g_hInst,MAKEINTRESOURCE(IDD_ADD_DLG),pAddDev->hWndParent,AddDeviceDlgProc);

    if (iret == -1) {
        int err = GetLastError();
        return HRESULT_FROM_WIN32(err);
    }

    //
    // Remote or local
    //

    if (pAddDev->bLocal == FALSE) {

        //
        // try to connect to remote dev manager
        //

        COSERVERINFO    coServInfo;
        MULTI_QI        multiQI[1];

        multiQI[0].pIID = &IID_IWiaDevMgr;
        multiQI[0].pItf = NULL;

        coServInfo.pwszName    = gpAddDev->wszServerName;
        coServInfo.pAuthInfo   = NULL;
        coServInfo.dwReserved1 = 0;
        coServInfo.dwReserved2 = 0;

        //
        // create connection to dev mgr
        //

        hr = CoCreateInstanceEx(
                CLSID_WiaDevMgr,
                NULL,
                CLSCTX_REMOTE_SERVER,
                &coServInfo,
                1,
                &multiQI[0]
                );

        if (hr == S_OK) {

            gpIWiaDevMgr = (IWiaDevMgr*)multiQI[0].pItf;

            //
            // display list of devices on this server
            //

            INT_PTR iret = DialogBox(g_hInst,MAKEINTRESOURCE(IDD_DIALOG_DEVLIST),pAddDev->hWndParent,DevListDlgProc);

            if (iret != 0) {

                //
                // add device to auxillary list
                //

                HKEY hKeySetup;

                hr = VerifyRemoteDeviceList(&hKeySetup);

                if (hr == S_OK) {

                    //
                    // look for machine name
                    //

                    hr = WriteDeviceProperties(hKeySetup,pAddDev);

                    RegCloseKey(hKeySetup);
                }

            } else {
                hr = E_FAIL;
            }

            gpIWiaDevMgr->Release();

            gpIWiaDevMgr = NULL;
        }

    } else {

        //
        // local named driver
        //

        return E_NOTIMPL;
    }
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\callback.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       CallBack.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        4 Aug, 1998
*
*  DESCRIPTION:
*   Implementation of event callbacks for the WIA device class driver.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include "wiamindr.h"


#include "callback.h"

// Debugging interface, has DLL lifetime. Maintained by USD.

/*******************************************************************************
*
*  QueryInterface
*  AddRef
*  Release
*
*  DESCRIPTION:
*   CEventCallback IUnknown Interface.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall CEventCallback::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IWiaEventCallback) {
        *ppv = (IWiaEventCallback*) this;
    }
    else {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG   _stdcall CEventCallback::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CEventCallback::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/*******************************************************************************
*
*  CEventCallback
*  Initialize
*  ~CEventCallback
*
*  DESCRIPTION:
*   CEventCallback Constructor/Initialize/Destructor Methods.
*
*  PARAMETERS:
*
*******************************************************************************/

CEventCallback::CEventCallback()
{
    m_cRef                = 0;
}

HRESULT _stdcall CEventCallback::Initialize()
{
   return S_OK;
}

CEventCallback::~CEventCallback()
{
}

/*******************************************************************************
*
*  ImageEventCallback
*
*  DESCRIPTION:
*    Handles WIA events.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall CEventCallback::ImageEventCallback(
        const GUID   *pEventGUID,
        BSTR         bstrEventDescription,
        BSTR         bstrDeviceID,
        BSTR         bstrDeviceDescription,
        DWORD        dwDeviceType,
        BSTR         bstrFullItemName,
        ULONG        *plEventType,
        ULONG        ulReserved)
{
   // Update properties in response to WIA events.

   return S_OK;
}


/*******************************************************************************
*
*  RegisterForWIAEvents
*
*  DESCRIPTION:
*    Handles WIA events.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT RegisterForWIAEvents(IWiaEventCallback** ppIWiaEventCallback)
{
    DBG_FN(::RegisterForWIAEvents);
   HRESULT     hr;
   IWiaDevMgr  *pIWiaDevMgr;

   // Get a WIA device manager object.
   hr = CoCreateInstance(CLSID_WiaDevMgr,
                         NULL,
                         CLSCTX_LOCAL_SERVER,
                         IID_IWiaDevMgr,
                         (void**)&pIWiaDevMgr);

   if (SUCCEEDED(hr)) {
      // Register with WIA event monitor to receive event notification.
      CEventCallback* pCEventCB = new CEventCallback();

      if (pCEventCB) {
         hr = pCEventCB->QueryInterface(IID_IWiaEventCallback,(void **)ppIWiaEventCallback);
         if (SUCCEEDED(hr)) {
            pCEventCB->Initialize();

            // hr = pIWiaDevMgr->RegisterEventCallback(0, NULL, 0, *ppIWiaEventCallback);
         }
         else {
            DBG_ERR(("RegisterForWIAEvents, QI of IID_IWiaEventCallback failed"));
         }
      }
      else {
         DBG_ERR(("RegisterForWIAEvents, new CEventCallback failed"));
         hr =  E_OUTOFMEMORY;
      }
      pIWiaDevMgr->Release();
   }
   else {
      DBG_ERR(("RegisterForWIAEvents, CoCreateInstance of IID_IWiaDevMgr failed"));
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\conn.cpp ===
/*++
   Copyright    (c)    1997        Microsoft Corporation

   Module Name:

        conn.cpp

   Abstract:

        Code to maintain list of process connections for an active device

   Author:

        Vlad Sadovsky   (VladS)    11-Feb-1997

   History:


--*/


//
//  Include Headers
//
#include "precomp.h"
#include "stiexe.h"

#include "conn.h"


//
// Static variables
//
//

LONG        g_lGlobalConnectionId = 0;

LIST_ENTRY  g_ConnectionListHead;                //
LONG        g_lTotalOpenedConnections = 0;       //

CRIT_SECT   g_ConnectionListSync;              // Global sync object for linked list syncronization

//
// Static functions
//
STI_CONN   *
LocateConnectionByHandle(
    HANDLE    hConnection
    );


//
// Methods
//

STI_CONN::STI_CONN(
    IN  LPCTSTR pszDeviceName,
    IN  DWORD   dwMode,
    IN  DWORD   dwProcessId
    )
{
    BOOL    fRet;

    //
    // Initialize fields
    //
    m_dwSignature = CONN_SIGNATURE;

    m_dwProcessId = dwProcessId;
    m_pOpenedDevice = NULL;
    m_dwOpenMode = dwMode;

    strDeviceName.CopyString(pszDeviceName);

    m_dwNotificationMessage = 0L;
    m_hwndProcessWindow = NULL;
    m_hevProcessEvent = INVALID_HANDLE_VALUE;

    m_GlocalListEntry.Flink = m_GlocalListEntry.Blink = NULL;
    m_DeviceListEntry.Flink = m_DeviceListEntry.Blink = NULL;

    InitializeListHead( &m_NotificationListHead );

    m_hUniqueId = LongToPtr(InterlockedIncrement(&g_lGlobalConnectionId));

    __try {
        // Critical section for protecting interthread access to the device
        if(!InitializeCriticalSectionAndSpinCount(&m_CritSec, MINLONG)) {
            m_fValid = FALSE;
            return;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        // This is really bad - mark this connection as invalid
        m_fValid = FALSE;
        return;
    }

    SetFlags(0);

    //
    // Locate device incrementing it's ref count
    //
    m_pOpenedDevice = g_pDevMan->IsInList(DEV_MAN_IN_LIST_DEV_ID, pszDeviceName);
    if (!m_pOpenedDevice) {
        // Failed to connect to the device
        DBG_WRN(("Refused connection to non-existing device (%S)", pszDeviceName));
        return;
    }


    //
    // Establish link to the device object
    //
    fRet = m_pOpenedDevice->AddConnection(this);

    m_pOpenedDevice->Release();

    if (!fRet) {
        //
        // Failed to connect to the device, find out reason
        //
        DBG_WRN(("Refused connection to device (%S)", pszDeviceName));

        ReportError(::GetLastError());
        return;
    }

    m_fValid = TRUE;

    DBG_TRC(("Successfully created connection to device (%S) handle:(%x)",
                pszDeviceName,this));

}

STI_CONN::~STI_CONN()
{

    SetFlags(CONN_FLAG_SHUTDOWN);

    DBG_TRC(("Destroying connection(%X)",this));
    DumpObject();

#if 0
    DebugDumpScheduleList(TEXT("Conn DTOR enter"));
#endif

    EnterCrit();

    //
    // If there are items in notification queue - remove them
    //
    if (!IsListEmpty(&m_NotificationListHead )) {

    }

    LeaveCrit();

    //
    // Disconnect from the device
    //
    if (m_pOpenedDevice) {
        m_pOpenedDevice->RemoveConnection(this);
    }

    //
    // Remove from global list if still there
    //
    if (m_GlocalListEntry.Flink &&!IsListEmpty(&m_GlocalListEntry)) {

        RemoveEntryList(&m_GlocalListEntry);
    }

    //
    // We know we tried to initialize it, so it is safe to delete it.
    //
    DeleteCriticalSection(&m_CritSec);

    m_fValid = FALSE;

}
/*
 * Reference counting methods.  It is simpler to use COM ref counting , to looks the same
 * as COM objects, in spite of the fact we are not really supporting COM, because QI method is
 * not functional
*/
STDMETHODIMP
STI_CONN::QueryInterface( REFIID riid, LPVOID * ppvObj)
{
    return E_FAIL;
}

STDMETHODIMP_(ULONG)
STI_CONN::AddRef( void)
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
STI_CONN::Release( void)
{
    LONG    cNew;
    if(!(cNew = ::InterlockedDecrement(&m_cRef))) {
        delete this;
    }

    return cNew;
}

BOOL
STI_CONN::
SetSubscribeInfo(
    PLOCAL_SUBSCRIBE_CONTAINER  pSubscribe
    )
{

    BOOL    fRet = FALSE;

    DBG_TRC(("Subscribing to device on connection (%X)",this));

    ReportError(NOERROR);

    //
    // NULL means resetting subscribe info block
    //
    if (!pSubscribe) {

        m_dwSubscribeFlags = 0L;

        m_hwndProcessWindow = NULL;
        m_hevProcessEvent = INVALID_HANDLE_VALUE;
        fRet = TRUE;
    }
    else {

        //
        // Save information needed to notify process
        //
        m_dwSubscribeFlags = pSubscribe->dwFlags;

        if (pSubscribe->dwFlags & STI_SUBSCRIBE_FLAG_WINDOW) {

            if (IsWindow((HWND)pSubscribe->upLocalWindowHandle)) {
                m_hwndProcessWindow = (HWND)pSubscribe->upLocalWindowHandle;
                m_uiNotificationMessage = pSubscribe->uiNotificationMessage;

                fRet = TRUE;
            }
            else {
                ASSERT(("Invalid window handle passed", 0));
            }
        }
        else if (pSubscribe->dwFlags & STI_SUBSCRIBE_FLAG_EVENT) {

            HANDLE  hProcessMe = GetCurrentProcess();
            HANDLE  hProcessClient = NULL;

            hProcessClient = ::OpenProcess(PROCESS_DUP_HANDLE,
                                           FALSE,
                                           m_dwProcessId
                                           );

            if (IS_VALID_HANDLE(hProcessClient)) {

                if (::DuplicateHandle(hProcessClient,
                                      (HANDLE)pSubscribe->upLocalEventHandle,
                                      hProcessMe,
                                      &m_hevProcessEvent,
                                      EVENT_MODIFY_STATE,
                                      0,
                                      0)
                                      ) {
                    fRet = TRUE;
                    ReportError(NOERROR);
                }
                else {
                    DBG_WRN(("Subscribe handler failed to recognize client process on connection (%X)",this));
                    ReportError(::GetLastError());
                }

                ::CloseHandle(hProcessClient);
            }
            else {
                ReportError(::GetLastError());
            }
        }

    }

    return fRet;
}


BOOL
STI_CONN::
QueueNotificationToProcess(
    LPSTINOTIFY pStiNotification
    )
{

    BOOL    fRet;
    //
    // Validate notification block
    //

    //
    // Add to the tail of the list
    //
    STI_NOTIFICATION * pNotification = NULL;

    pNotification = new STI_NOTIFICATION(pStiNotification);

    if (pNotification && pNotification->IsValid()) {
        EnterCrit();
        InsertTailList(&m_NotificationListHead,&pNotification->m_ListEntry);
        LeaveCrit();
    }

    //
    // Notify process
    //
    if (m_dwSubscribeFlags & STI_SUBSCRIBE_FLAG_WINDOW) {
        ::PostMessage(m_hwndProcessWindow,m_uiNotificationMessage ,0,0L);
    }
    else if (m_dwSubscribeFlags & STI_SUBSCRIBE_FLAG_EVENT) {
        ::SetEvent(m_hevProcessEvent);
    }

    fRet = TRUE;

    return fRet;
}

DWORD
STI_CONN::
GetNotification(
    PVOID   pBuffer,
    DWORD   *pdwSize
    )
{

    STI_NOTIFICATION * pNotification = NULL;
    TAKE_STI_CONN   t(this);
    LIST_ENTRY      *pentry;

    if (IsListEmpty(&m_NotificationListHead)) {
        return ERROR_NO_DATA;
    }

    DBG_TRC(("Request to get last notification on connection (%X) ",this));

    //
    // Get size of the head
    //
    pentry = m_NotificationListHead.Flink;
    pNotification = CONTAINING_RECORD( pentry, STI_NOTIFICATION,m_ListEntry );

    if (*pdwSize < pNotification->QueryAllocSize() ) {
        *pdwSize = pNotification->QueryAllocSize();
        return ERROR_MORE_DATA;
    }

    //
    // Get head of the list ( and remove) and copy into user buffer
    //
    pentry = RemoveHeadList(&m_NotificationListHead);
    pNotification = CONTAINING_RECORD( pentry, STI_NOTIFICATION,m_ListEntry );

    memcpy(pBuffer,pNotification->QueryNotifyData(),pNotification->QueryAllocSize());

    delete pNotification;

    return NOERROR;

}


//
//  Create and initialize connection object
//
BOOL
CreateDeviceConnection(
    LPCTSTR pszDeviceName,
    DWORD   dwMode,
    DWORD   dwProcessId,
    HANDLE  *phConnection
    )
{

    STI_CONN        *pConn = NULL;
    BOOL            fRet = FALSE;
    DWORD           dwErr = NOERROR;

    DBG_TRC(("Request to add connection to device (%S) from process(%x) with mode (%x)",
                pszDeviceName, dwProcessId, dwMode));

    //
    // Create connection object
    //
    pConn = new STI_CONN(pszDeviceName,
                         dwMode,
                         dwProcessId);
    if (pConn)  {
        if(pConn->IsValid()) {
            *phConnection = (HANDLE)(pConn->QueryID());
            fRet = TRUE;
        }
        else {
            // Did not initialize properly
            dwErr = pConn->QueryError();
            delete pConn;
        }
    }
    else {
        // Could not allocate connectionobject
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // If succeeded - add created object to linked list head
    //
    if (fRet)
    // BEGIN PROTECTED CODE
    {
        TAKE_CRIT_SECT t(g_ConnectionListSync);
        InsertTailList(&g_ConnectionListHead,&pConn->m_GlocalListEntry);
    }
    // END PROTECTED CODE

    ::SetLastError(dwErr);

    return fRet;
}

//
//
// Remove connection object from the list
//
BOOL
DestroyDeviceConnection(
    HANDLE  hConnection,
    BOOL    fForce
    )
{
    //
    // Find connection by id
    //
    DBG_TRC(("Request to remove connection (%X) ",hConnection));

    STI_CONN   *pConnection = NULL;

    // BEGIN PROTECTED CODE
    {

        TAKE_CRIT_SECT t(g_ConnectionListSync);

        pConnection = LocateConnectionByHandle(hConnection);

        if (pConnection) {

            if (!fForce) {
                pConnection->Release();
            }
            else {
                delete pConnection;
            }
        }

    }
    // END PROTECTED CODE

#if 0
    DebugDumpScheduleList(TEXT("DestroyConnection"));
#endif

    return (!(pConnection == NULL));
}

//
// Find connection object by given handle by walking all devices and all connections
// for each device
//
BOOL
LookupConnectionByHandle(
    HANDLE    hConnection,
    STI_CONN   **ppConnectionObject
    )
{

    STI_CONN   *pConnection = NULL;

    *ppConnectionObject = NULL;

    // BEGIN PROTECTED CODE
    {
        TAKE_CRIT_SECT t(g_ConnectionListSync);

        pConnection = LocateConnectionByHandle(hConnection);

        if (pConnection) {
            *ppConnectionObject = pConnection;
            pConnection->AddRef();
        }

    }
    // END PROTECTED CODE

    return (!(*ppConnectionObject == NULL));
}

//
// Requires caller to synchronize access
//
STI_CONN   *
LocateConnectionByHandle(
    HANDLE    hConnection
    )
{

    LIST_ENTRY *pentry;
    LIST_ENTRY *pentryNext;

    STI_CONN   *pConnection = NULL;

    ULONG      ulInternalHandle = HandleToUlong(hConnection);

    for ( pentry  = g_ConnectionListHead.Flink;
          pentry != &g_ConnectionListHead;
          pentry  = pentryNext ) {

        pentryNext = pentry->Flink;

        pConnection = CONTAINING_RECORD( pentry, STI_CONN,m_GlocalListEntry );

        if ( !pConnection->IsValid()) {
            ASSERT(("Invalid connection signature", 0));
            break;
        }

        if ((ulInternalHandle == PtrToUlong(pConnection->QueryID())) &&
             !(pConnection->QueryFlags() & CONN_FLAG_SHUTDOWN)
            ) {
            return pConnection;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\debug.cpp ===
/*++


Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    DEBUG.CPP

Abstract:

    This is the debugging output

Author:

    Vlad  Sadovsky  (vlads)     12-20-96

Revision History:


--*/

#include "precomp.h"
#include "stiexe.h"

#include "resource.h"

void
__cdecl
StiMonWndDisplayOutput(
    LPTSTR pString,
    ...
    )
{
    va_list list;

    va_start(list,pString);

    vStiMonWndDisplayOutput(pString,list);

    va_end(list);
}

void
__cdecl
vStiMonWndDisplayOutput(
    LPTSTR pString,
    va_list arglist
    )
{
    if(g_fServiceInShutdown || !g_hLogWindow) {
        return;
    }

    TCHAR    Buffer[512];
    INT     iIndex;
    LRESULT lRet;

    ULONG_PTR    dwResult = 0;

    wvsprintf(Buffer,pString,arglist);

    DBG_TRC(("As MONUI: %s",Buffer));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\conn.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    conn.h

Abstract:

    Handling connection for applications, which open STI devices


Author:

    Vlad Sadovsky (vlads)   10-Feb-1997


Environment:

    User Mode - Win32

Revision History:

    26-Feb-1997     VladS       created

--*/

#ifndef _STI_CONN_H_
#define _STI_CONN_H_

#include <base.h>
#include <buffer.h>

#include "device.h"
#include "stirpc.h"

/***********************************************************
 *    Type Definitions
 ************************************************************/

#define CONN_SIGNATURE          (DWORD)'CONN'
#define CONN_SIGNATURE_FREE     (DWORD)'CONf'

#define NOTIFY_SIGNATURE          (DWORD)'NOTI'
#define NOTIFY_SIGNATURE_FREE     (DWORD)'NOTf'

class STI_NOTIFICATION {

public:

    STI_NOTIFICATION::STI_NOTIFICATION(IN LPSTINOTIFY pNotify)
    {
        Reset();

        if (pNotify) {
            m_uiAllocSize = pNotify->dwSize;
            m_pNotifyData = new BYTE[m_uiAllocSize];

            // ASSERT(m_pNotifyData);
            if (m_pNotifyData) {
                memcpy(m_pNotifyData,(LPBYTE)pNotify,m_uiAllocSize);
                m_dwSignature = NOTIFY_SIGNATURE;
                m_fValid = TRUE;
            }
        }
    }

    STI_NOTIFICATION::~STI_NOTIFICATION()
    {
        if (IsValid()) {
            if (m_pNotifyData) {
                delete [] m_pNotifyData;
            }
            Reset();
        }
    }

    inline BOOL
    IsValid(
        VOID
        )
    {
        return (m_fValid) && (m_dwSignature == NOTIFY_SIGNATURE);
    }

    inline VOID
    Reset(
        VOID
        )
    {
        m_ListEntry.Flink = m_ListEntry.Blink = NULL;
        m_uiAllocSize = 0;
        m_dwSignature = NOTIFY_SIGNATURE_FREE;
        m_fValid = FALSE;
    }

    inline UINT
    QueryAllocSize(
        VOID
        )
    {
        return m_uiAllocSize;
    }

    inline LPBYTE
    QueryNotifyData(
        VOID
        )
    {
        return m_pNotifyData;
    }

    LIST_ENTRY  m_ListEntry;

private:

    DWORD   m_dwSignature;
    BOOL    m_fValid;
    UINT    m_uiAllocSize;
    LPBYTE  m_pNotifyData;
};

//
// Flags for connection object
//
#define CONN_FLAG_SHUTDOWN  0x0001

class STI_CONN : public BASE {

friend class TAKE_STI_CONN;

public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    STI_CONN::STI_CONN(
        IN  LPCTSTR lpszDeviceName,
        IN  DWORD   dwMode,
        IN  DWORD   dwProcessId
        );

    STI_CONN::~STI_CONN() ;

    inline BOOL
    IsValid(
        VOID
        )
    {
        return (m_fValid) && (m_dwSignature == CONN_SIGNATURE);
    }

    inline void
    EnterCrit(VOID)
    {
        _try {
            EnterCriticalSection(&m_CritSec);
        }
        _except (EXCEPTION_EXECUTE_HANDLER) {
            // What do we do now?
        }
    }

    inline void
    LeaveCrit(VOID)
    {
        LeaveCriticalSection(&m_CritSec);
    }

       inline DWORD
    SetFlags(
        DWORD   dwNewFlags
        )
    {
        DWORD   dwTemp = m_dwFlags;
        m_dwFlags = dwNewFlags;
        return dwTemp;
    }

    inline DWORD
    QueryFlags(
        VOID
        )
    {
        return m_dwFlags;
    }

    inline HANDLE
    QueryID(
        VOID
        )
    {
        return m_hUniqueId;
    }

    inline DWORD
    QueryOpenMode(
        VOID
        )
    {
        return m_dwOpenMode;
    }



    BOOL
    SetSubscribeInfo(
        PLOCAL_SUBSCRIBE_CONTAINER  pSubscribe
        );

    BOOL
    QueueNotificationToProcess(
        LPSTINOTIFY pStiNotification
        );

    DWORD
    GetNotification(
        PVOID   pBuffer,
        DWORD   *pdwSize
        );

    VOID DumpObject(VOID)
    {
        /*  The cast (char*) m_dwSignature will cause problems in 64bit land. 
        DPRINTF(DM_TRACE,TEXT("Connection: Dumping itself:this(%X) Sign(%4c) DeviceListEntry(%X,%X,%X) \n  \
                GlocalListEntry(%X,%X,%X) Ser#(%d)"), \
                this,(char *)m_dwSignature,
                &m_DeviceListEntry,m_DeviceListEntry.Flink,m_DeviceListEntry.Blink,
                &m_GlocalListEntry,m_GlocalListEntry.Flink,m_GlocalListEntry.Blink,
                m_dwUniqueId);
        */
    }


    LIST_ENTRY  m_GlocalListEntry;
    LIST_ENTRY  m_DeviceListEntry;
    LIST_ENTRY  m_NotificationListHead;

    DWORD       m_dwSignature;

private:

    BOOL    m_fValid;

    CRITICAL_SECTION    m_CritSec;
    ACTIVE_DEVICE   *m_pOpenedDevice;

    HANDLE  m_hUniqueId;

    StiCString     strDeviceName;

    DWORD   m_dwFlags;
    DWORD   m_dwSubscribeFlags;
    DWORD   m_dwOpenMode;
    DWORD   m_dwProcessId;

    DWORD   m_dwNotificationMessage;
    HWND    m_hwndProcessWindow;
    HANDLE  m_hevProcessEvent;
    UINT    m_uiNotificationMessage;

};


//
// Take connection class
//
class TAKE_STI_CONN
{
private:
    STI_CONN*    m_pConn;

public:
    void Take(void) {m_pConn->EnterCrit();}
    void Release(void) {m_pConn->LeaveCrit();}
    TAKE_STI_CONN(STI_CONN* pconn) : m_pConn(pconn) { Take(); }
    ~TAKE_STI_CONN() { Release(); }
};

BOOL
CreateDeviceConnection(
    LPCTSTR pwszDeviceName,
    DWORD   dwMode,
    DWORD   dwProcessId,
    HANDLE  *phConnection
    );

//
// Find connection object by given handle
//
BOOL
LookupConnectionByHandle(
    HANDLE          hConnection,
    STI_CONN   **ppConnectionObject
    );

//
//
// Remove connection object from the list
//
BOOL
DestroyDeviceConnection(
    HANDLE  lUniqueId,
    BOOL    fForce
    );

#endif // _CONN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\callback.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       CallBack.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        4 Aug, 1998
*
*  DESCRIPTION:
*   Declarations and definitions for the WIA device class driver callbacks.
*
*******************************************************************************/

class CEventCallback : public IWiaEventCallback
{
public:

    // Constructor, initialization and destructor methods.
    CEventCallback();
    HRESULT _stdcall Initialize();
    ~CEventCallback();

    // IUnknown members that delegate to m_pUnkRef.
    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();
   
    HRESULT _stdcall ImageEventCallback(
        const GUID   *pEventGUID,
        BSTR         bstrEventDescription,
        BSTR         bstrDeviceID,
        BSTR         bstrDeviceDescription,
        DWORD        dwDeviceType,
        BSTR         bstrFullItemName,
        ULONG        *plEventType,
        ULONG        ulReserved);

private:
   ULONG           m_cRef;         // Object reference count.

};


// Public prototypes
HRESULT RegisterForWIAEvents(IWiaEventCallback** ppIWiaEventCallback);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\devinfo.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       DevInfo.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        9 Jan, 1998
*
*  DESCRIPTION:
*   Implementation for WIA device enumeration and information interface.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include "wiamindr.h"

#include "wia.h"

#include "devmgr.h"
#include "devinfo.h"
#include "helpers.h"

#define REGSTR_PATH_STICONTROL_DEVLIST_W    L"System\\CurrentControlSet\\Control\\StillImage\\DevList"
#define REGSTR_PATH_STI_CLASS_W             L"{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}"

typedef struct _WIA_REMOTE_DEVICE {
    HKEY    hKeyDevice;
    WCHAR   wszDevName[MAX_PATH];
}WIA_REMOTE_DEVICE,*PWIA_REMOTE_DEVICE;

/**************************************************************************\
* GetPropID
*
*   This method takes in a PROPSPEC and returns a PROPSPEC with the
*   whose ulKind field is always PRSPEC_PROPID.  So if the input PROPSPEC
*   is a PropID, then it is simply copied to the output parameter, else
*   if it is identified by a name, then the name is looked up and the
*   corresponding PropId is returned in the output parameter.
*
* Arguments:
*
*   pWiaPropStg     - The property storage to work from
*   pPropSpecIn     - A pointer to the input PROPSPEC containing the
*                     property name.
*   pPropSpecOut    - A pointer to a PROPSPEC where the corresponding
*                     PropID will be put.
*
* Return Value:
*
*    Status         -   An E_INVALIDARG will be returned if the property
*                       is not found.  If it is, then S_OK will be returned.
*                       If an error occurs getting the enumerator from the
*                       property storage, then that error is returned.
*
* History:
*
*    27/4/1998 Original Version
*
\**************************************************************************/

HRESULT GetPropID(
    IWiaPropertyStorage *pWiaPropStg,
    PROPSPEC            *pPropSpecIn,
    PROPSPEC            *pPropSpecOut)
{
    HRESULT             hr;
    IEnumSTATPROPSTG    *pIEnum;

    if (!pWiaPropStg) {
        DBG_ERR(("::GetPropIDFromName, property storage argument is NULL!"));
        return E_INVALIDARG;
    }

    //
    //  If pPropSpecIn is a PropID, simply copy to pPropSpecOut
    //

    if (pPropSpecIn->ulKind == PRSPEC_PROPID) {
        pPropSpecOut->ulKind = PRSPEC_PROPID;
        pPropSpecOut->propid = pPropSpecIn->propid;
        return S_OK;
    }

    hr = pWiaPropStg->Enum(&pIEnum);
    if (FAILED(hr)) {
        DBG_ERR(("::GetPropIDFromName, error getting IEnumSTATPROPSTG!"));
        return hr;
    }

    //
    //  Go through properties
    //

    STATPROPSTG statProp;
    ULONG       celtFetched;

    statProp.lpwstrName = NULL;
    for (celtFetched = 1; celtFetched > 0; pIEnum->Next(1, &statProp, &celtFetched)) {
        if (statProp.lpwstrName) {
            if ((wcscmp(statProp.lpwstrName, pPropSpecIn->lpwstr)) == 0) {

                //
                //  Found the right one, so get it's PropID
                //

                pPropSpecOut->ulKind = PRSPEC_PROPID;
                pPropSpecOut->propid = statProp.propid;

                pIEnum->Release();
                CoTaskMemFree(statProp.lpwstrName);
                return S_OK;
            }

            //
            //  Free the property name
            //

            CoTaskMemFree(statProp.lpwstrName);
            statProp.lpwstrName = NULL;
        }

    }

    pIEnum->Release();

    //
    //  Property not found
    //

    return E_INVALIDARG;
}

/**************************************************************************\
* EnumRemoteDevices
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/4/1999 Original Version
*
\**************************************************************************/

HRESULT
EnumRemoteDevices(DWORD *pnDevices,WIA_REMOTE_DEVICE **ppRemDev)
{
    DBG_FN(::EnumRemoteDevices);
    *pnDevices = 0;

    DWORD   numDev = 0;
    HRESULT hr = S_OK;

    //
    // find remote device entry in registry
    //

    LPWSTR szKeyName = REGSTR_PATH_STICONTROL_DEVLIST_W;

    HKEY hKeySetup,hKeyDevice;
    LONG lResult;

    if (RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                  szKeyName,
                  0,
                  KEY_READ | KEY_WRITE,
                  &hKeySetup) == ERROR_SUCCESS) {


        //
        // look for machine names
        //

        WCHAR wszTemp[MAX_PATH+1];

        LONG MachineIndex = 0;

        //
        // go through once to find number
        //

        do {

            lResult = RegEnumKeyW(hKeySetup,MachineIndex++,wszTemp,MAX_PATH+1);

            if (lResult == ERROR_SUCCESS) {
                numDev++;
            }

        } while (lResult == ERROR_SUCCESS);

        //
        // allocate array for return values
        //

        PWIA_REMOTE_DEVICE pRemDev = (PWIA_REMOTE_DEVICE)LocalAlloc(LPTR,numDev * sizeof(WIA_REMOTE_DEVICE));
        *ppRemDev = pRemDev;

        if (pRemDev == NULL) {
            RegCloseKey(hKeySetup);
            DBG_ERR(("EnumRemoteDevices: failed to allcate memory for Remote device"));
            return E_OUTOFMEMORY;
        }

        //
        // go through enumeration again, open key and copy name and key to buffer
        //

        MachineIndex = 0;

        do {

            lResult = RegEnumKeyW(hKeySetup,MachineIndex,wszTemp,MAX_PATH+1);

            if (lResult == ERROR_SUCCESS) {

                lResult = RegOpenKeyExW (hKeySetup,
                              wszTemp,
                              0,
                              KEY_READ | KEY_WRITE,
                              &hKeyDevice);

                if (lResult == ERROR_SUCCESS) {

                    (*pnDevices)++;

                    lstrcpyW(pRemDev[MachineIndex].wszDevName,wszTemp);

                    pRemDev[MachineIndex].hKeyDevice = hKeyDevice;

                    MachineIndex++;


                } else {
                    DBG_ERR(("EnumRemoteDevices: failed RegOpenKeyExW, status = %lx",lResult));
                }


            }

        } while (lResult == ERROR_SUCCESS);

    }
    return hr;
}

/**************************************************************************\
*  SetWIARemoteDevInfoProperties
*
*   Create a property storage on given stream and then write WIA and
*   STI device information into the device info properties.
*
* Arguments:
*
*   pSti - sti object
*   pStm - return stream
*   pSdi - sti information on current device
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT SetWIARemoteDevInfoProperties(
   LPSTREAM                pStm,
   PWIA_REMOTE_DEVICE      pRemoteDevice)
{
    DBG_FN(::SetWIARemoteDevInfoProperties);
   UINT              i;
   HRESULT           hr;
   LONG              lResult;
   IPropertyStorage  *pPropStg = NULL;
   PROPSPEC          propspec[WIA_NUM_DIP];
   PROPVARIANT       propvar[WIA_NUM_DIP];

   //
   // Create an IPropertyStorage on the stream.
   //

    hr = StgCreatePropStg(pStm,
                          FMTID_NULL,
                          &CLSID_NULL,
                          PROPSETFLAG_DEFAULT,
                          0,
                          &pPropStg);

    if (SUCCEEDED(hr)) {

        //
        // Set the property specifications and data. Order must match
        // the property order in devmangr.idl and wia.h.
        //

        memset(propspec, 0, sizeof(PROPSPEC) * WIA_NUM_DIP);
        memset(propvar,  0, sizeof(VARIANT) * WIA_NUM_DIP);

        DWORD dwType;
        DWORD dwSize;

        for (i = 0; i < WIA_NUM_DIP; i++) {

            PROPID propid = g_piDeviceInfo[i];

            propspec[i].ulKind = PRSPEC_PROPID;
            propspec[i].propid = propid;

            propvar[i].vt = VT_BSTR;

            switch (propid) {

                case WIA_DIP_DEV_ID:
                case WIA_DIP_SERVER_NAME:
                case WIA_DIP_VEND_DESC:
                case WIA_DIP_DEV_DESC:
                case WIA_DIP_PORT_NAME:
                case WIA_DIP_DEV_NAME:
                case WIA_DIP_REMOTE_DEV_ID:
                case WIA_DIP_UI_CLSID:
                case WIA_DIP_BAUDRATE:

                    WCHAR szTemp[MAX_PATH];

                    dwType = REG_SZ;
                    dwSize = MAX_PATH;

                    lResult =  RegQueryValueExW(pRemoteDevice->hKeyDevice,
                                                g_pszDeviceInfo[i],
                                                0,
                                                &dwType,
                                                (LPBYTE)szTemp,
                                                &dwSize);

                    if (lResult == ERROR_SUCCESS) {
                        propvar[i].bstrVal = SysAllocString(szTemp);

                        if (!propvar[i].bstrVal) {
                            DBG_ERR(("SetWIARemoteDevInfoProperties, unable to alloc dev info strings"));
                        }
                    }
                    else {
                        DBG_ERR(("SetWIARemoteDevInfoProperties, RegQueryValueExW failed"));
                        DBG_ERR(("  error: %d, propid = %li", lResult, propid));

                        hr = HRESULT_FROM_WIN32(lResult);
                        propvar[i].bstrVal = NULL;
                    }
                    break;

                case WIA_DIP_DEV_TYPE:
                    {
                        DWORD dwValue;
                        dwType = REG_DWORD;
                        dwSize = sizeof(DWORD);

                        lResult =  RegQueryValueExW(pRemoteDevice->hKeyDevice,
                                                    g_pszDeviceInfo[i],
                                                    0,
                                                    &dwType,
                                                    (LPBYTE)&dwValue,
                                                    &dwSize);

                        if (lResult == ERROR_SUCCESS) {
                            propvar[i].vt = VT_I4;
                            propvar[i].lVal = (LONG)dwValue;
                        }
                        else {
                            DBG_ERR(("SetWIARemoteDevInfoProperties, RegQueryValueExW failed"));
                            DBG_ERR(("  error: %d, propid = %li", lResult, propid));
                            hr = HRESULT_FROM_WIN32(lResult);
                        }
                    }
                    break;

                case WIA_DIP_HW_CONFIG:
                    {
                        DWORD dwValue;
                        dwType = REG_DWORD;
                        dwSize = sizeof(DWORD);

                        lResult =  RegQueryValueExW(pRemoteDevice->hKeyDevice,
                                                    REGSTR_VAL_HARDWARE_W,
                                                    0,
                                                    &dwType,
                                                    (LPBYTE)&dwValue,
                                                    &dwSize);

                        if (lResult == ERROR_SUCCESS) {
                            propvar[i].vt = VT_I4;
                            propvar[i].lVal = (LONG)dwValue;
                        }
                        else {
                            DBG_ERR(("SetWIARemoteDevInfoProperties, RegQueryValueExW failed"));
                            DBG_ERR(("  error: %d, propid = %li", lResult, propid));
                            hr = HRESULT_FROM_WIN32(lResult);
                        }
                    }
                    break;
                case WIA_DIP_STI_GEN_CAPABILITIES:
                    {
                        DWORD dwValue;
                        dwType = REG_DWORD;
                        dwSize = sizeof(DWORD);

                        lResult =  RegQueryValueExW(pRemoteDevice->hKeyDevice,
                                                    REGSTR_VAL_GENERIC_CAPS_W,
                                                    0,
                                                    &dwType,
                                                    (LPBYTE)&dwValue,
                                                    &dwSize);

                        if (lResult == ERROR_SUCCESS) {
                            propvar[i].vt = VT_I4;
                            propvar[i].lVal = (LONG)dwValue;
                        }
                        else {
                            DBG_ERR(("SetWIARemoteDevInfoProperties, RegQueryValueExW failed"));
                            DBG_ERR(("  error: %d, propid = %li", lResult, propid));
                            hr = HRESULT_FROM_WIN32(lResult);
                        }
                    }
                    break;

                default:
                    hr = E_FAIL;
                    DBG_ERR(("SetWIARemoteDevInfoProperties, Unknown device property"));
                    DBG_ERR(("  propid = %li",propid));
            }
        }

        //
        // Set the properties for a device
        //

        if (SUCCEEDED(hr)) {
            hr = pPropStg->WriteMultiple(WIA_NUM_DIP,
                                         propspec,
                                         propvar,
                                         WIA_DIP_FIRST);

            //
            // write property names
            //

            if (SUCCEEDED(hr)) {

                hr = pPropStg->WritePropertyNames(WIA_NUM_DIP,
                                                  g_piDeviceInfo,
                                                  g_pszDeviceInfo);
                if (FAILED(hr)) {
                    DBG_ERR(("SetWIARemoteDevInfoProperties, WritePropertyNames failed (0x%X)", hr));
                }
            }
            else {
                ReportReadWriteMultipleError(hr, "SetWIARemoteDevInfoProperties", NULL, FALSE, WIA_NUM_DIP, propspec);
            }
        }

        // Free the allocated BSTR's.
        FreePropVariantArray(WIA_NUM_DIP, propvar);

        pPropStg->Release();
    }
    else {
        DBG_ERR(("SetWIARemoteDevInfoProperties, StgCreatePropStg Failed"));
    }
    return hr;
}

/**************************************************************************\
*
* QueryInterface
* AddRef
* Release
*
* Arguments:
*
*   standard
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 original version
*
\**************************************************************************/

HRESULT _stdcall CEnumWIADevInfo::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumWIA_DEV_INFO) {
        *ppv = (IEnumWIA_DEV_INFO*) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG   _stdcall CEnumWIADevInfo::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CEnumWIADevInfo::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) {
        delete this;
        return 0;
    }
    return ulRefCount;
}


/**************************************************************************\
* CEnumWIADevInfo::CEnumWIADevInfo
*
*   Init basic class info
*
* Arguments:
*
*   none
*
* Return Value:
*
*   none
*
* History:
*
*    9/2/1998
*
\**************************************************************************/

CEnumWIADevInfo::CEnumWIADevInfo()
{
   m_cRef           = 0;
   m_lType          = 0;
   m_pIWiaPropStg   = NULL;
   m_cDevices       = 0;
   m_ulIndex        = 0;

   //
   // We're creating a component that exposes interfaces to clients, so
   // inform service to make sure service wont shutdown prematurely.
   //
   CWiaSvc::AddRef();
}

/**************************************************************************\
* CEnumWIADevInfo::Initialize
*
*   Get list of all devices from sti, then creat a stream for each device.
*   Write all the device info properties for each device into each stream.
*
* Arguments:
*
*   lType   -   type of device this enumerator is being created for
*   pSti    -   sti object
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998   initial version
*   07/06/1999  Changed to intialize entrie array of Dev. Info. storages
*
\**************************************************************************/

HRESULT CEnumWIADevInfo::Initialize(
    LONG lType)
{

    DBG_FN(CEnumWIADevInfo::Initialize);

    HRESULT hr              = E_FAIL;
    DWORD   cDevices        = 0;

    hr = g_pDevMan->GetDevInfoStgs(lType, &m_cDevices, &m_pIWiaPropStg);
    //  TBD:  What about remote devices?

    return hr;
}

/**************************************************************************\
* CEnumWIADevInfo::~CEnumWIADevInfo
*
*   Release and free the backing property streams for each device
*
* Arguments:
*
*   none
*
* Return Value:
*
*   none
*
* History:
*
*    9/2/1998
*
\**************************************************************************/

CEnumWIADevInfo::~CEnumWIADevInfo()
{
   DBG_FN(CEnumWIADevInfo::~CEnumWIADevInfo);

   if (m_pIWiaPropStg) {
       for (ULONG index = 0; index < m_cDevices; index++) {
          if (m_pIWiaPropStg[index]) {
             m_pIWiaPropStg[index]->Release();
             m_pIWiaPropStg[index] = NULL;
          }
       }

       delete[] m_pIWiaPropStg;
       m_pIWiaPropStg = NULL;
   }

   //
   // Component is destroyed, so no more interfaces are exposed from here.
   // Inform server by decrementing it's reference count.  This will allow
   // it to shutdown if it's no longer needed.
   //
   CWiaSvc::Release();
}

/**************************************************************************\
* CEnumWIADevInfo::Next
*
*   Get the next propstg(s) in the enumerator and return.
*   Next_Proxy ensures that last parameter is non-NULL.
*
* Arguments:
*
*   celt          - number of property storages requested
*   rgelt         - return propstg array
*   pceltFetched  - number of property storages returned
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998
*
\**************************************************************************/

HRESULT __stdcall CEnumWIADevInfo::Next(
    ULONG               celt,
    IWiaPropertyStorage **rgelt,
    ULONG               *pceltFetched)
{
    DBG_FN(CEnumWIADevInfo::Next);
    HRESULT     hr = S_FALSE;
    ULONG       ulCount;

    DBG_TRC(("CEnumWIADevInfo::Next, celt=%d ", celt));

    *pceltFetched = 0;

    //
    //  Validate parameters
    //

    if (celt == 0) {
        return(S_OK);
    }

    //
    //  Check whether any more elements exist to enumerate through.
    //

    if ((m_ulIndex >= m_cDevices)) {
        return S_FALSE;
    }

    //
    //  Check that the requested number of elements exist.  If not,
    //  set ulCount to the remaining number of elements.
    //

    if (celt > (m_cDevices - m_ulIndex)) {
        ulCount = m_cDevices - m_ulIndex;
    } else {
        ulCount = celt;
    }

    memset(rgelt, 0, sizeof(IWiaPropertyStorage*) * celt);

    //
    //  Return the requested elements
    //

    for (ULONG index = 0; index < ulCount; index++) {
        hr = m_pIWiaPropStg[m_ulIndex]->QueryInterface(IID_IWiaPropertyStorage,
                                                    (void**) &rgelt[index]);
        if (FAILED(hr)) {
            DBG_ERR(("CEnumWIADevInfo::Next, QI for IPropertyStorage failed"));
            break;
        }
        m_ulIndex++;
    }

    if (FAILED(hr)) {
        for (ULONG index = 0; index < ulCount; index++) {
            if (rgelt[index]) {
                rgelt[index]->Release();
                rgelt[index] = NULL;
            }
        }
    }

    *pceltFetched = ulCount;

    DBG_TRC(("CEnumWIADevInfo::Next exiting ulCount=%d *pceltFetched=%d hr=0x%X rgelt[0]=0x%lX",
            ulCount,*pceltFetched,hr,rgelt[0]));

    //
    //  Return S_FALSE if we returned less elements than requested
    //

    if (ulCount < celt) {
        hr = S_FALSE;
    }
    return hr;
}

/**************************************************************************\
* CEnumWIADevInfo::Skip
*
*   Skip a number of entries in the enumerator
*
* Arguments:
*
*   celt - number to skip
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998
*
\**************************************************************************/

HRESULT __stdcall CEnumWIADevInfo::Skip(ULONG celt)
{
    DBG_FN(CEnumWIADevInfo::Skip);
    //
    //  Check that we actually have a device list and that we don't
    //  exceed the number of elements
    //

    if((m_pIWiaPropStg) && ((m_ulIndex + celt) < m_cDevices)) {
       m_ulIndex += celt;
       return S_OK;
    }
    return S_FALSE;
}


/**************************************************************************\
* CEnumWIADevInfo::Reset
*
*   reset enumerator to first item
*
* Arguments:
*
*   none
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT __stdcall CEnumWIADevInfo::Reset(void)
{
    DBG_FN(CEnumWIADevInfo::Reset);
    m_ulIndex = 0;
    return S_OK;
}

/**************************************************************************\
* CEnumWIADevInfo::Clone
*
*   Create a new enumerator and start it at the same location
*   this enumerator is running
*
* Arguments:
*
*   ppenum return new enumerator interface
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT __stdcall CEnumWIADevInfo::Clone(IEnumWIA_DEV_INFO **ppenum)
{
    DBG_FN(CEnumWIADevInfo::Clone);
    HRESULT hr = S_OK;
    CEnumWIADevInfo* pClone=NULL;

    pClone = new CEnumWIADevInfo();

    if (!pClone) {
        return E_OUTOFMEMORY;
    }

    hr = pClone->Initialize(m_lType);
    if (FAILED(hr)) {
        delete pClone;
        return hr;
    }

    pClone->m_ulIndex = m_ulIndex;
    hr = pClone->QueryInterface(IID_IEnumWIA_DEV_INFO, (void**) ppenum);
    if (FAILED(hr)) {
        delete pClone;
        DBG_ERR(("CEnumWIADevInfo::Clone, QI for IWiaPropertyStorage failed"));
        return hr;
    }
    return S_OK;
}

/**************************************************************************\
* GetCount
*
*   Returns the number of elements stored in this enumerator.
*
* Arguments:
*
*   pcelt           - address of ULONG where to put the number of elements.
*
* Return Value:
*
*   Status          - S_OK if successful
*                     E_FAIL if failed
*
* History:
*
*    05/07/99 Original Version
*
\**************************************************************************/
HRESULT _stdcall CEnumWIADevInfo::GetCount(ULONG *pcelt)
{
    DBG_FN(CEnumWIADevInfo::GetCount);
    if (IsBadWritePtr(pcelt, sizeof(ULONG))) {
        return E_POINTER;
    } else {
        *pcelt = 0;
    }

    //
    //  Check that we actually have a list and that the count
    //  has a non-zero value.
    //

    if(m_cDevices && m_pIWiaPropStg) {

       *pcelt = m_cDevices;
    }
    return S_OK;
}

/**************************************************************************\
*
*  QueryInterface
*  AddRef
*  Release
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevInfo::QueryInterface(const IID& iid, void** ppv)
{
   *ppv = NULL;

   if (iid == IID_IUnknown || iid == IID_IWiaPropertyStorage) {
      *ppv = (IWiaPropertyStorage*) this;
   } else if (iid == IID_IPropertyStorage) {
      *ppv = (IPropertyStorage*) this;
   }
   else {
      return E_NOINTERFACE;
   }
   AddRef();
   return S_OK;
}

ULONG   _stdcall CWIADevInfo::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CWIADevInfo::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/**************************************************************************\
* CWIADevInfo::CWIADevInfo
*
*   init empty object
*
* Arguments:
*
*   none
*
* Return Value:
*
*   none
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

CWIADevInfo::CWIADevInfo()
{
    m_cRef        = 0;
    m_pITypeInfo  = NULL;
    m_pIPropStg   = NULL;
    m_pIStm       = NULL;

    //
    // We're creating a component that exposes interfaces to clients, so
    // inform service to make sure service wont shutdown prematurely.
    //
    CWiaSvc::AddRef();
}

/**************************************************************************\
* CopyItemProp
*
*   This helper method copies a single property from source to destination.
*
* Arguments:
*
*   pIPropStgSrc    -   The IPropertyStorage that contains the property to
*                       copy.
*   pIPropStgDst    -   The IPropertyStorage where the value is copied to.
*   pps             -   The PROPSPEC which specifies the source property.
*   pszErr          -   A string that will be printed out when an error
*                       occurs.
* Return Value:
*
*    Status         -   Returns HRESULT from ReadMultiple and WriteMultiple.
*
* History:
*
*    28/04/1999 Original Version
*
\**************************************************************************/

HRESULT CopyItemProp(
    IPropertyStorage    *pIPropStgSrc,
    IPropertyStorage    *pIPropStgDst,
    PROPSPEC            *pps,
    LPSTR               pszErr)
{
    DBG_FN(::CopyItemProp);
    PROPVARIANT pv[1];

    HRESULT hr = pIPropStgSrc->ReadMultiple(1, pps, pv);
    if (SUCCEEDED(hr)) {

        hr = pIPropStgDst->WriteMultiple(1, pps, pv, WIA_DIP_FIRST);
        if (FAILED(hr)) {
            ReportReadWriteMultipleError(hr,
                                         "CopyItemProp",
                                         pszErr,
                                         FALSE,
                                         1,
                                         pps);
        }
        PropVariantClear(pv);
    }
    else {
        ReportReadWriteMultipleError(hr,
                                     "CopyItemProp",
                                     pszErr,
                                     TRUE,
                                     1,
                                     pps);
    }
    return hr;
}

/**************************************************************************\
* CWIADevInfo::Initialize
*
*   Initialize DevInfo object with a stream, the stream must already be
*   filled out with device information properties
*
* Arguments:
*
*   pIStream - data stream for the device
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT CWIADevInfo::Initialize()
{
    DBG_FN(CWIADevInfo::Initialize);
    HRESULT hr;

    hr = CreateStreamOnHGlobal(NULL, TRUE, &m_pIStm);
    if (SUCCEEDED(hr)) {

        //
        // Open a property storage on the stream.
        //

        hr = StgCreatePropStg(m_pIStm,
                              FMTID_NULL,
                              &CLSID_NULL,
                              PROPSETFLAG_DEFAULT,
                              0,
                              &m_pIPropStg);

        if (FAILED(hr)) {
            DBG_ERR(("CWIADevInfo::Initialize, StgOpenPropStg failed (0x%X)", hr));
        }
    } else {
        DBG_ERR(("CWIADevInfo::Initialize, CreateStreamOnHGlobal failed (0x%X)", hr));
    }

    return hr;
}

/**************************************************************************\
* CWIADevInfo::~CWIADevInfo
*
*   release references to stream and typeInfo
*
* Arguments:
*
*   none
*
* Return Value:
*
*   none
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

CWIADevInfo::~CWIADevInfo()
{
    DBG_FN(CWIADevInfo::~CWIADevInfo);

   if (m_pIPropStg) {
       m_pIPropStg->Release();
       m_pIPropStg = NULL;
   }

   if (m_pIStm) {
       m_pIStm->Release();
       m_pIStm = NULL;
   }

   if (m_pITypeInfo) {
      m_pITypeInfo->Release();
   }

   //
   // Component is destroyed, so no more interfaces are exposed from here.
   // Inform server by decrementing it's reference count.  This will allow
   // it to shutdown if it's no longer needed.
   //
   CWiaSvc::Release();
}

/**************************************************************************\
* UpdateDeviceProperties
*
*   Helper function for CWIADevInfo::WriteMultiple.  It is used to change
*   the Device properties which are stored in the registry.
*
* Arguments:
*
*   cpspec      -   count of properties to write.
*   rgpspec     -   PROPSPEC identifying the properties to write.  Caller
*                   ensures that these are of type PRSPEC_PROPID.
*   rgpropvar   -   PROPVARIANT array containing the values to write.
*
* Return Value:
*
*   Status
*
* History:
*
*    26/08/1999 Original Version
*
\**************************************************************************/

HRESULT CWIADevInfo::UpdateDeviceProperties(
    ULONG           cpspec,
    const PROPSPEC  *rgpspec,
    const PROPVARIANT     *rgpropvar)
{
    DBG_FN(CWIADevInfo::UpdateDeviceProperties);
    ACTIVE_DEVICE               *pActiveDevice = NULL;
    DEVICE_INFO                 *pDeviceInfo   = NULL;
    PROPSPEC                    ps[1] = {{PRSPEC_PROPID, WIA_DIP_DEV_ID}};
    PROPVARIANT                 pvDevID[1];
    PSTI                        pSti;
    HRESULT                     hr;

    //
    //  Get the DeviceID
    //

    PropVariantInit(pvDevID);
    hr = ReadMultiple(1, ps, pvDevID);
    if (hr == S_OK) {

        //
        //  Use the DeviceID to get the corresponding ACTIVE_DEVICE
        //

        pActiveDevice = g_pDevMan->IsInList(DEV_MAN_IN_LIST_DEV_ID, pvDevID->bstrVal);
        if (pActiveDevice) {
            TAKE_ACTIVE_DEVICE  t(pActiveDevice);

            pDeviceInfo = pActiveDevice->m_DrvWrapper.getDevInfo();
            if (pDeviceInfo) {

                //
                //  Update the pDevInfo struct values to the new values from
                //  rgpropvar.  Inside this loop is where we update pDevInfo
                //  with all the fields we recognize.  So far, these are:
                //  WIA_DIP_DEV_NAME
                //  WIA_DIP_PORT_NAME
                //  WIA_DIP_BAUDRATE
                //

                for (ULONG index = 0; index < cpspec; index++) {

                    //
                    //  If the FriendlyName is being changed,
                    //  then set the local name in pDevInfo.
                    //  Make sure to free the old one before allocating the new one.
                    //

                    if (rgpspec[index].propid == WIA_DIP_DEV_NAME) {

                        //
                        //  Check the the friendly name is not blank or null
                        //

                        //
                        //  NOTE:  The Shell should check for blank names, not us.
                        //  However, it is safest to do it here...
                        //

                        if (rgpropvar[index].bstrVal) {

                            if (wcslen(rgpropvar[index].bstrVal) > 0) {

                                //
                                //  Set the new local name.  First free the old string, then
                                //  copy the new one
                                //

                                if (pDeviceInfo->wszLocalName) {
                                    delete pDeviceInfo->wszLocalName;
                                    pDeviceInfo->wszLocalName = NULL;
                                }
                                pDeviceInfo->wszLocalName = AllocCopyString(rgpropvar[index].bstrVal);
                                if (!pDeviceInfo->wszLocalName) {
                                    DBG_ERR(("CWIADevInfo::UpdateDeviceProperties, Out of memory"));
                                    hr = E_OUTOFMEMORY;
                                }
                            } else {
                                DBG_ERR(("CWIADevInfo::UpdateDeviceProperties, WIA_DIP_DEV_NAME is blank"));
                                hr = E_INVALIDARG;
                                break;
                            }
                        } else {
                            DBG_ERR(("CWIADevInfo::UpdateDeviceProperties, WIA_DIP_DEV_NAME is NULL"));
                            hr = E_INVALIDARG;
                            break;
                        }
                    }

                    //
                    //  If the port name is being changed, set it in pDeviceInfo.
                    //  Make sure to free the old one before allocating the new one.
                    //
                    if (rgpspec[index].propid == WIA_DIP_PORT_NAME) {

                        if (pDeviceInfo->wszPortName) {
                            delete pDeviceInfo->wszPortName;
                            pDeviceInfo->wszPortName = NULL;
                        }
                        pDeviceInfo->wszPortName = AllocCopyString(rgpropvar[index].bstrVal);
                        if (!pDeviceInfo->wszPortName) {
                            DBG_ERR(("CWIADevInfo::UpdateDeviceProperties, Out of memory"));
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    //
                    //  If the baudrate is being changed, set it in pDeviceInfo.
                    //  Make sure to free the old one before allocating the new one.
                    //
                    if (rgpspec[index].propid == WIA_DIP_BAUDRATE) {

                        if (pDeviceInfo->wszBaudRate) {
                            delete pDeviceInfo->wszBaudRate;
                            pDeviceInfo->wszBaudRate = NULL;
                        }
                        pDeviceInfo->wszBaudRate = AllocCopyString(rgpropvar[index].bstrVal);
                        if (!pDeviceInfo->wszBaudRate) {
                            DBG_ERR(("CWIADevInfo::UpdateDeviceProperties, Out of memory"));
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }

            }

            if (SUCCEEDED(hr)) {

                //
                //  Write the changes to the registry
                //
                hr = g_pDevMan->UpdateDeviceRegistry(pDeviceInfo);
            }

            //
            //  Release the ACTIVE_DEVICE since it was AddRef'd by IsInList(...)
            //
            pActiveDevice->Release();
        }

        //
        //  Free the propvariant data
        //
        PropVariantClear(pvDevID);
    } else {
        DBG_ERR(("CWIADevInfo::UpdateDeviceProperties, could not read the DeviceID (0x%X)", hr));
    }
    return hr;
}

/*******************************************************************************
*
*  ReadMultiple
*  WriteMultiple
*  DeleteMultiple
*  ReadPropertyNames
*  WritePropertyNames
*  DeletePropertyNames
*  Commit
*  Revert
*  Enum
*  SetTimes
*  SetClass
*  Stat
*
*   Pass-through implementation to IPropStg
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevInfo::ReadMultiple(
    ULONG           cpspec,
    const PROPSPEC  *rgpspec,
    PROPVARIANT     *rgpropvar)
{
    DBG_FN(CWIADevInfo::ReadMultiple);
    HRESULT hr = m_pIPropStg->ReadMultiple(cpspec, rgpspec, rgpropvar);

    if (FAILED(hr)) {
        ReportReadWriteMultipleError(hr, "CWIADevInfo::ReadMultiple", NULL, TRUE, cpspec, rgpspec);
    }
    return hr;
}

HRESULT _stdcall CWIADevInfo::WriteMultiple(
    ULONG               cpspec,
    const PROPSPEC      *rgpspec,
    const PROPVARIANT   *rgpropvar,
    PROPID              propidNameFirst)
{
    DBG_FN(CWIADevInfo::WriteMultiple);
    BOOL        bInvalidProp;
    PROPSPEC    *pPropSpec;
    HRESULT     hr = S_OK;

    //
    //  Attempt to update any properties to which access is allowed.
    //  Currently, only the FriendlyName may be changed, anything
    //  else returns E_INVALIDARG.
    //

    pPropSpec = (PROPSPEC*) LocalAlloc(LPTR, sizeof(PROPSPEC) * cpspec);
    if (pPropSpec) {

        //
        //  First, make a copy of the incoming PROPSPEC array, and convert
        //  any property names to PROPIDs.  While doing the conversion,
        //  make sure that access to those properties are allowed.
        //  This ensures that UpdateDeviceProperties receives only valid
        //  properties indicated by PROPIDs.
        //

        for (ULONG index = 0; index < cpspec; index++) {

            bInvalidProp = TRUE;
            pPropSpec[index].ulKind = PRSPEC_PROPID;

            if (SUCCEEDED(GetPropID(this, (PROPSPEC*)&rgpspec[index], &pPropSpec[index]))) {

                //
                //  Look for PropID matches here.  So far, we only recognize:
                //  WIA_DIP_DEV_NAME
                //  WIA_DIP_PORT_NAME
                //  WIA_DIP_BAUDRATE
                //

                switch (rgpspec[index].propid) {
                    case WIA_DIP_DEV_NAME :
                    case WIA_DIP_PORT_NAME :
                    case WIA_DIP_BAUDRATE :
                        bInvalidProp = FALSE;
                        break;

                    default:
                        bInvalidProp = TRUE;
                }
            }

            if (bInvalidProp) {
                DBG_ERR(("CWIADevInfo::WriteMultiple, property not allowed to be written"));
                hr = E_ACCESSDENIED;
                break;
            }
        }

        if (SUCCEEDED(hr)) {

            //
            //  Update the device properties stored in the registry
            //

            hr = UpdateDeviceProperties(cpspec, pPropSpec, rgpropvar);
            if (SUCCEEDED(hr)) {

                //
                //  Registry updated, so update the PropertyStorage to reflect
                //  the change.
                //

                hr = m_pIPropStg->WriteMultiple(cpspec,
                                                pPropSpec,
                                                rgpropvar,
                                                WIA_DIP_FIRST);
                if (FAILED(hr)) {
                    DBG_ERR(("CWIADevInfo::WriteMultiple, updated registry, but failed to update property storage"));
                }
            }
        }

        //
        //  Free our PropSpec array
        //

        LocalFree(pPropSpec);
    } else {
        DBG_ERR(("CWIADevInfo::WriteMultiple, out of memory"));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT _stdcall CWIADevInfo::ReadPropertyNames(
    ULONG           cpropid,
    const PROPID    *rgpropid,
    LPOLESTR        *rglpwstrName)
{
    DBG_FN(CWIADevInfo::ReadPropertyNames);
     return m_pIPropStg->ReadPropertyNames(cpropid,rgpropid,rglpwstrName);
}

HRESULT _stdcall CWIADevInfo::WritePropertyNames(
    ULONG           cpropid,
    const PROPID    *rgpropid,
    const LPOLESTR  *rglpwstrName)
{
    DBG_FN(CWIADevInfo::WritePropertyNames);
     return(E_ACCESSDENIED);
}

HRESULT _stdcall CWIADevInfo::Enum(
   IEnumSTATPROPSTG **ppenum)
{
    DBG_FN(CWIADevInfo::Enum);
     return m_pIPropStg->Enum(ppenum);
}

HRESULT _stdcall CWIADevInfo::GetPropertyAttributes(
    ULONG                   cPropSpec,
    PROPSPEC                *pPropSpec,
    ULONG                   *pulAccessFlags,
    PROPVARIANT             *ppvValidValues)
{
    DBG_FN(CWIADevInfo::GetPropertyAttributes);
    return E_ACCESSDENIED;
}

HRESULT _stdcall CWIADevInfo::GetCount(
    ULONG*      pulPropCount)
{
    DBG_FN(CWIADevInfo::GetCount);
    IEnumSTATPROPSTG    *pIEnum;
    STATPROPSTG         stg;
    ULONG               ulCount;
    HRESULT             hr = S_OK;

    stg.lpwstrName = NULL;

    hr = m_pIPropStg->Enum(&pIEnum);
    if (SUCCEEDED(hr)) {
        for (ulCount = 0; hr == S_OK; hr = pIEnum->Next(1, &stg, NULL)) {
            ulCount++;

            if(stg.lpwstrName) {
                CoTaskMemFree(stg.lpwstrName);
            }
        }
        if (SUCCEEDED(hr)) {
            hr = S_OK;
            *pulPropCount = ulCount;
        } else {
            DBG_ERR(("CWIADevInfo::GetCount, pIEnum->Next failed (0x%X)", hr));
        }
        pIEnum->Release();
    } else {
        DBG_ERR(("CWIADevInfo::GetCount, Enum failed"));
    }
    return hr;
}

HRESULT _stdcall CWIADevInfo::GetPropertyStream(GUID *pCompatibilityId, LPSTREAM *ppstmProp)
{
    DBG_FN(CWIADevInfo::GetPropertyStream);
    return E_NOTIMPL;
}

HRESULT _stdcall CWIADevInfo::SetPropertyStream(GUID *pCompatibilityId, LPSTREAM pstmProp)
{
    DBG_FN(CWIADevInfo::SetPropertyStream);
    return E_ACCESSDENIED;
}

/**************************************************************************\
*
*   Methods of IPropertyStorage not directly off IWiaPropertySTorage
*
*   DeleteMultiple
*   DeletePropertyNames
*   Commit
*   Revert
*   SetTimes
*   SetClass
*   Stat
*
*   9/3/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevInfo::DeleteMultiple(
    ULONG cpspec,
    const PROPSPEC __RPC_FAR rgpspec[])
{
    DBG_FN(CWIADevInfo::DeleteMultiple);
   return E_ACCESSDENIED;
}

HRESULT _stdcall CWIADevInfo::DeletePropertyNames(
    ULONG cpropid,
    const PROPID __RPC_FAR rgpropid[])
{
    DBG_FN(CWIADevInfo::DeletePropertyNames);
   return E_ACCESSDENIED;
}

HRESULT _stdcall CWIADevInfo::Commit(DWORD grfCommitFlags)
{
    DBG_FN(CWIADevInfo::Commit);

   return m_pIPropStg->Commit(grfCommitFlags);
}

HRESULT _stdcall CWIADevInfo::Revert(void)
{
    DBG_FN(CWIADevInfo::Revert);
   return m_pIPropStg->Revert();
}

HRESULT _stdcall CWIADevInfo::SetTimes(
    const FILETIME __RPC_FAR *pctime,
    const FILETIME __RPC_FAR *patime,
    const FILETIME __RPC_FAR *pmtime)
{
    DBG_FN(CWIADevInfo::SetTimes);
   return  m_pIPropStg->SetTimes(pctime,patime,pmtime);
}

HRESULT _stdcall CWIADevInfo::SetClass(REFCLSID clsid)
{
    DBG_FN(CWIADevInfo::SetClass);
   return E_ACCESSDENIED;
}

HRESULT _stdcall CWIADevInfo::Stat(STATPROPSETSTG *pstatpsstg)
{
    DBG_FN(CWIADevInfo::Stat);
   return m_pIPropStg->Stat(pstatpsstg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\device.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    device.h

Abstract:

    Handling opened device object on the monitor side

Author:

    Vlad Sadovsky (vlads)   10-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    26-Jan-1997     VladS       created

--*/

#ifndef _DEVICE_H_
#define _DEVICE_H_

#include <base.h>
#include <buffer.h>

class CWiaDrvItem;
//
// If this code is moved into dll, methods will need to be exported in order to instantiate
// objects of those classes outside module scope. Then we will need to replace line below
//
// #define dllexp __declspec( dllexport )
//
#undef  dllexp
#define dllexp
//

#define PRIVATE_FOR_NO_SERVICE_UI

//
// Type of syncronization for accessing device object
//
#define USE_CRITICAL_SECTION 1

/***********************************************************
 *    Type Definitions
 ************************************************************/

#define ADEV_SIGNATURE          (DWORD)'ADEV'
#define ADEV_SIGNATURE_FREE     (DWORD)'FDEV'

//
// Values for flags field for device object
//

#define STIMON_AD_FLAG_POLLING          0x000001    // Device requires polling
#define STIMON_AD_FLAG_OPENED_FOR_DATA  0x000002    // Device is opened for data access
#define STIMON_AD_FLAG_LAUNCH_PENDING   0x000004    // Auto launch is pending
#define STIMON_AD_FLAG_REMOVING         0x000008    // Device is being removed
#define STIMON_AD_FLAG_NOTIFY_ENABLED   0x000010    // Nobody disabled notifications
#define STIMON_AD_FLAG_NOTIFY_CAPABLE   0x000020    // Device is capable to notify
#define STIMON_AD_FLAG_NOTIFY_RUNNING   0x000040    // Currently monitor is receiving notificaitons from device
#define STIMON_AD_FLAG_MARKED_INACTIVE  0x000080    // Currently monitor is receiving notificaitons from device
#define STIMON_AD_FLAG_DELAYED_INIT     0x000100    // Currently monitor is receiving notificaitons from device


#define STIDEV_POLL_FAILURE_REPORT_COUNT    25      // Skip reporting errors on each polling attempt

#define STIDEV_DELAYED_INTIT_TIME       10          // No. of milliseconds to schedule delayed init

#define STIDEV_MIN_POLL_TIME    100                 // Shortest poll interval allowed

//
// Forward declarations
//
class STI_CONN;
class ACTIVE_DEVICE;
class FakeStiDevice;

//
// Device Event code structure.  A list of these is maintained for each
// active device.  This list is initialized from the registry when the
// device becomes active (in the ACTIVE_DEVICE constructor).
// Each even code structure contains an event code that the device
// can issue.  This event code is validated against this list.  If valid,
// the action assoicated with the event is triggered.
//
typedef struct _DEVICEEVENT {
    LIST_ENTRY m_ListEntry;
    GUID       m_EventGuid;
    StiCString m_EventSubKey;
    StiCString m_EventName;
    StiCString m_EventData;
    BOOL       m_fLaunchable;
} DEVICEEVENT, *PDEVICEEVENT;


//
// Container to pass parameters to auto launch thread
//
typedef struct _AUTO_LAUNCH_PARAM_CONTAINER {
    ACTIVE_DEVICE   *pActiveDevice;
    PDEVICEEVENT    pLaunchEvent;
    LPCTSTR         pAppName;
} AUTO_LAUNCH_PARAM_CONTAINER,*PAUTO_LAUNCH_PARAM_CONTAINER;


class ACTIVE_DEVICE : public BASE {

friend class TAKE_ACTIVE_DEVICE;

friend VOID CALLBACK
        DumpActiveDevicesCallback(
        ACTIVE_DEVICE   *pActiveDevice,
        VOID            *pContext
        );

public:

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    //
    ACTIVE_DEVICE(IN LPCTSTR lpszDeviceName, DEVICE_INFO *pInfo = NULL);

    ~ACTIVE_DEVICE( VOID ) ;

    inline BOOL
    IsValid(
        VOID
        )
    {
        return (m_fValid) && (m_dwSignature == ADEV_SIGNATURE);
    }

    inline BOOL
    EnterCrit(VOID)
    {
        return m_dwDeviceCritSec.Lock();
    }

    inline void
    LeaveCrit(VOID)
    {
        m_dwDeviceCritSec.Unlock();
    }

    inline DWORD
    SetFlags(
        DWORD   dwNewFlags
        )
    {
        DWORD   dwTemp = m_dwFlags;
        m_dwFlags = dwNewFlags;
        return dwTemp;
    }

    inline DWORD
    QueryFlags(
        VOID
        )
    {
        return m_dwFlags;
    }


    inline DWORD
    QueryPollingInterval(VOID)         // get current polling interval
    {
        return m_dwPollingInterval;
    }

    inline DWORD
    SetPollingInterval(
       IN DWORD dwNewInterval)         // Set new interval for polling
    {
        DWORD   dwTemp = m_dwPollingInterval;

        m_dwPollingInterval = dwNewInterval;

        return dwTemp;
    }

    inline BOOL
    IsConnectedTo(
        VOID
        )
    {
        return !IsListEmpty(&m_ConnectionListHead);
    }


    BOOL
    NotificationsNeeded(
        VOID
        )
    {
        if (!IsListEmpty(&m_ConnectionListHead)) {
            return TRUE;
        }

        //
        // If setup is running - block all events
        //
        if ( IsSetupInProgressMode() ) {
            return FALSE;
        }

        //
        // For async. notification devices always assume they need support for notificaitons
        // It is rather hacky , but all USB devices we have now, need to initialize notifications
        // support on startup, otherwise their initialization routines would not complete properly.
        // It is not expensive to monitor async events and do nothing when they arrive
        // For polled devices on the ontrary , it is quite expensive to keep monitoring
        // events ,when they are really not needed

        if ((QueryFlags() & STIMON_AD_FLAG_NOTIFY_CAPABLE) &&
            !(QueryFlags() & STIMON_AD_FLAG_POLLING) ) {
            return TRUE;
        }
        else {
            // If there are no connections, then check whether user does not want notifications or
            // event list is empty
            return ( !m_dwUserDisableNotifications && m_fLaunchableEventListNotEmpty );
        }
    }

    WCHAR* GetDeviceID() 
    {
        return m_DrvWrapper.getDeviceId();
    }

    HANDLE  GetNotificationsSink()
    {
        return m_hDeviceNotificationSink;
    }

    VOID
    GetDeviceSettings(
        VOID
        );

    //
    // Device notifications spport
    //
    BOOL
    BuildEventList(
        VOID
        );

    BOOL
    DestroyEventList(
        VOID
        );

    DWORD
    DisableDeviceNotifications(
        VOID
        );

    DWORD
    EnableDeviceNotifications(
        VOID
        );

    DWORD
    StopNotifications(
        VOID
        );

    DWORD
    StartRunningNotifications(
        VOID
        );

    BOOL
    FlushDeviceNotifications(
        VOID
        );

    BOOL
    DoPoll(
        VOID
        );

    BOOL
    DoAsyncEvent(
        VOID
        );

    BOOL
    ProcessEvent(
        STINOTIFY   *psNotify,
        BOOL        fForceLaunch=FALSE,
        LPCTSTR     pszAppName=NULL
    );

    BOOL
    AutoLaunch(
        PAUTO_LAUNCH_PARAM_CONTAINER pAutoContainer
    );

    BOOL
    RetrieveSTILaunchInformation(
        PDEVICEEVENT    pev,
        LPCTSTR         pAppName,
        STRArray&       saAppList,
        STRArray&       saCommandLine,
        BOOL            fForceSelection=FALSE
    );

    BOOL
    IsDeviceAvailable(
        VOID
        );

    BOOL
    RemoveConnection(
        STI_CONN    *pConnection
        );

    BOOL
    AddConnection(
        STI_CONN    *pConnection
        );

    STI_CONN   *
    FindMyConnection(
        HANDLE    hConnection
        );

    BOOL
    FillEventFromUSD(
        STINOTIFY *psNotify
    );

    BOOL
    SetHandleForUSD(
        HANDLE  hEvent
    );

    BOOL
    IsEventOnArrivalNeeded(
        VOID
        );

    //
    // Load/Unload STI device
    //
    BOOL
    LoadDriver(
        BOOL bReReadDevInfo = FALSE
        );

    BOOL
    UnLoadDriver(
        BOOL bForceUnload
        );

    //
    // PnP support methods
    //
    BOOL
    InitPnPNotifications(
        HWND    hwnd
        );

    BOOL
    StopPnPNotifications(
        VOID
        );

    BOOL IsRegisteredForDeviceRemoval(
        VOID
        );

    //
    //  Update WIA cached device information
    //

    BOOL UpdateDeviceInformation(
        VOID
        );

    VOID SetDriverItem(
        CWiaDrvItem *pRootDrvItem)
    {

        //
        //  Note:  Technically, we should follow proper ref-counting 
        //  procedure for this this object.  However, we should NEVER have
        //  the case where this object goes out of scope  (or otherwise 
        //  destroyed) without our knowledge, therefore there is no need.
        //  
        m_pRootDrvItem = pRootDrvItem;
    };

    //
    LIST_ENTRY  m_ListEntry;
    LIST_ENTRY  m_ConnectionListHead;
    DWORD       m_dwSignature;

    StiCString  m_strLaunchCommandLine;

    LONG        m_lDeviceId;

    PVOID       m_pLockInfo;
    DWORD       m_dwDelayedOpCookie;
    
    FakeStiDevice  *m_pFakeStiDevice;
    CDrvWrap       m_DrvWrapper;
    CWiaDrvItem    *m_pRootDrvItem;

private:

    BOOL        m_fValid;
    BOOL        m_fLaunchableEventListNotEmpty;
    BOOL        m_fRefreshedBusOnFailure;

    CRIT_SECT   m_dwDeviceCritSec;

    DWORD       m_dwFlags;
    DWORD       m_dwPollingInterval;
    DWORD       m_dwUserDisableNotifications;
    DWORD       m_dwSchedulerCookie;
    DWORD       m_dwLaunchEventTimeExpire;

    UINT        m_uiSubscribersCount;

    UINT        m_uiPollFailureCount;

    HANDLE      m_hDeviceEvent;
    HANDLE      m_hDeviceNotificationSink;
    HANDLE      m_hDeviceInterface;

    STI_DEVICE_STATUS   m_DevStatus;

    LIST_ENTRY  m_DeviceEventListHead;

    PDEVICEEVENT    m_pLastLaunchEvent;
};


//
// Take device class
//
class TAKE_ACTIVE_DEVICE
{
private:
    ACTIVE_DEVICE*    m_pDev;
    BOOL              m_bLocked;

public:

    inline TAKE_ACTIVE_DEVICE(ACTIVE_DEVICE* pdev) : m_pDev(pdev), m_bLocked(FALSE)
    {
        if (m_pDev) {
            m_bLocked = m_pDev->EnterCrit();
        }
    }

    inline ~TAKE_ACTIVE_DEVICE()
    {
        if (m_bLocked) {
            m_pDev->LeaveCrit();
        }
    }
};

//
// Linked list for active STI devices, known to monitor
//
extern    LIST_ENTRY  g_pDeviceListHead;

//
//
// Add/Remove device object from the list
//
BOOL
AddDeviceByName(
    LPCTSTR          pszDeviceName,
    BOOL        fPnPInitiated   = FALSE
    );

BOOL
RemoveDeviceByName(
    LPTSTR          pszDeviceName
    );

BOOL
MarkDeviceForRemoval(
    LPTSTR          pszDeviceName
    );

// Reload device list in response to PnP or ACPI notifications
//

VOID
RefreshDeviceList(
    WORD    wCommand,
    WORD    wFlags
    );

//
// Initialize/Terminate linked list
//
VOID
InitializeDeviceList(
    VOID
    );

VOID
TerminateDeviceList(
    VOID
    );

VOID
DebugDumpDeviceList(
    VOID
    );

BOOL
ResetAllPollIntervals(
    UINT   dwNewPollInterval
    );

//
// Enumerators with callbacks
//

typedef
VOID
(*PFN_DEVINFO_CALLBACK)(
    PSTI_DEVICE_INFORMATION pDevInfo,
    VOID                    *pContext
    );

typedef
VOID
(* PFN_ACTIVEDEVICE_CALLBACK)(
    ACTIVE_DEVICE           *pActiveDevice,
    VOID                    *pContext
    );
/*
VOID
WINAPI
EnumerateStiDevicesWithCallback(
    PFN_DEVINFO_CALLBACK    pfn,
    VOID                    *pContext
    );
*/

VOID
WINAPI
EnumerateActiveDevicesWithCallback(
    PFN_ACTIVEDEVICE_CALLBACK   pfn,
    VOID                    *pContext
    );
#endif // _DEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\devmgr.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       DevMgr.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        26 Dec, 1997
*
*  DESCRIPTION:
*   Declarations and definitions for the WIA device manager object.
*
*******************************************************************************/

#include <shobjidl.h>
#ifndef __WIA_NOTIFY_H_

#define __WIA_NOTIFY_H_

#define WM_NOTIFY_WIA_DEV_EVENT WM_USER+400

typedef struct _WIANOTIFY {
    LONG        lSize;
    BSTR        bstrDevId;
    STINOTIFY   stiNotify;
} WIANOTIFY, *PWIANOTIFY;

#endif


#ifndef WIANOTIFY_VOLUME_DEF

#define WM_NOTIFY_WIA_VOLUME_EVENT WM_USER+501

typedef struct _WIANOTIFY_VOLUME {
    LONG        lSize;
    DWORD       unitmask;
} WIANOTIFY_VOLUME, *PWIANOTIFY_VOLUME;

#define WIANOTIFY_VOLUME_DEF

#endif

//
//  MAX amount of time to wait for device enumeration, in milliseconds
//

#define DEVICE_LIST_WAIT_TIME 30000

class CFactory;

class CWiaDevMgr : public IWiaDevMgr,
                   public IWiaNotifyDevMgr,
                   public IHWEventHandler
{
public:
    static HRESULT CreateInstance(const IID& iid, void** ppv);

private:
    // IUnknown methods
    HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

    //
    // IHWEventHandler
    //

    HRESULT _stdcall Initialize( 
        LPCWSTR pszParams);

    HRESULT _stdcall HandleEvent( 
        LPCWSTR pszDeviceID,
        LPCWSTR pszAltDeviceID,
        LPCWSTR pszEventType);

    HRESULT _stdcall HandleEventWithContent(
        LPCWSTR pszDeviceID,
        LPCWSTR pszAltDeviceID,
        LPCWSTR pszEventType,
        LPCWSTR pszContentTypeHandler,
        IDataObject* pdataobject);
//
    // IWiaNotifyDevMgr Methods
    //

    HRESULT _stdcall NewDeviceArrival() 
    {
        //
        // Just refresh active list
        //
        ::StiPostMessage(NULL,
                         STIMON_MSG_REFRESH,
                         STIMON_MSG_REFRESH_REREAD,
                         STIMON_MSG_REFRESH_NEW | STIMON_MSG_PURGE_REMOVED);
//                         STIMON_MSG_REFRESH_NEW);
        return S_OK;
    };

    //
    // IWiaDevMgr methods
    //

    HRESULT _stdcall EnumDeviceInfo(
      LONG                       lFlag,
      IEnumWIA_DEV_INFO          **ppIEnum);

    HRESULT _stdcall CreateDevice(
      BSTR                       pbstrDeviceID,
      IWiaItem                   **ppItemRoot);

    HRESULT _stdcall SelectDeviceDlg(
      HWND                       hwndParent,
      LONG                       lDeviceType,
      LONG                       lFlags,
      BSTR                       *pbstrDeviceID,
      IWiaItem                   **ppItemRoot);

    HRESULT _stdcall SelectDeviceDlgID(
      HWND                       hwndParent,
      LONG                       lDeviceType,
      LONG                       lFlags,
      BSTR                       *pbstrDeviceID );

    HRESULT _stdcall GetImageDlg(
      HWND                       hwndParent,
      LONG                       lDeviceType,
      LONG                       lFlags,
      LONG                       lIntent,
      IWiaItem                   *pItemRoot,
      BSTR                       bstrFilename,
      GUID                       *pguidFormat);

    HRESULT _stdcall RegisterEventCallbackProgram(
      LONG                       lFlags,
      BSTR                       bstrDeviceID,
      const GUID                 *pEventGUID,
      BSTR                       bstrCommandline,
      BSTR                       bstrName,
      BSTR                       bstrDescription,
      BSTR                       bstrIcon);

    HRESULT _stdcall RegisterEventCallbackInterface(
      LONG                       lFlags,
      BSTR                       bstrDeviceID,
      const GUID                 *pEventGUID,
      IWiaEventCallback          *pIWIAEventCallback,
      IUnknown                   **ppIEvent);

    HRESULT _stdcall RegisterEventCallbackCLSID(
      LONG                       lFlags,
      BSTR                       bstrDeviceID,
      const GUID                 *pEventGUID,
      const GUID                 *pClsID,
      BSTR                       bstrName,
      BSTR                       bstrDescription,
      BSTR                       bstrIcon);

    HRESULT _stdcall AddDeviceDlg(
      HWND                       hWndParent,
      LONG                       lFlags);

    //
    // helper functins
    //

    HRESULT FindMatchingDevice(
        BSTR                    bstrDeviceID,
        IWiaPropertyStorage     **ppIWiaPropStg);


    HRESULT FindFileSystemDriver(
        LPCWSTR                 pszAltDeviceID,
        BSTR                    *pbstrDeviceId);

    HRESULT RunAcquisitionManager(
        BSTR                    bstrDeviceId);


    friend CFactory;

    CWiaDevMgr();
    HRESULT Initialize();
    ~CWiaDevMgr();

    //
    // member variables
    //

    ULONG      m_cRef;              // Reference count for this object.
    ITypeInfo* m_pITypeInfo;        // Pointer to type information.
};


/**************************************************************************\
*
*   Add Device Dilaog return
*
*
*
* History:
*
*    12/22/1998 Original Version
*
\**************************************************************************/

typedef struct _WIA_ADD_DEVICE {
    char  szServerName[MAX_PATH];
    WCHAR wszServerName[MAX_PATH];
    BSTR  bstrDeviceID;
    BOOL  bLocal;
    HWND  hWndParent;
}WIA_ADD_DEVICE,*PWIA_ADD_DEVICE;

HRESULT DisplayAddDlg(PWIA_ADD_DEVICE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\devinfo.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       DevInfo.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        26 Dec, 1997
*
*  DESCRIPTION:
*   Declaration and definitions for WIA device enumerator and
*   WIA device information objects.
*
*******************************************************************************/

class CEnumWIADevInfo : public IEnumWIA_DEV_INFO
{
public:
    // IUnknown methods
    HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

private:
   // IEnumWIA_DEV_INFO methods
   HRESULT __stdcall Next(
        ULONG               celt,
        IWiaPropertyStorage **rgelt,
        ULONG               *pceltFetched);

   HRESULT __stdcall Skip(ULONG celt);
   HRESULT __stdcall Reset(void);
   HRESULT __stdcall Clone(IEnumWIA_DEV_INFO **ppIEnum);
   HRESULT __stdcall GetCount(ULONG*);

   // Helpers

   
public:
   // Constructor, initialization and destructor methods.
   CEnumWIADevInfo();
   HRESULT Initialize(LONG lFlags);
   ~CEnumWIADevInfo();

private:
   ULONG                m_cRef;           // Reference count for this object.
   LONG                 m_lType;          // Original enumeration device type.
   IWiaPropertyStorage  **m_pIWiaPropStg; // Pointers Dev. Info. property storages
   ULONG                m_cDevices;       // Number of WIA devices.
   ULONG                m_ulIndex;        // Index for IEnumWIA_DEV_INFO methods.
};

class CWIADevInfo : public IWiaPropertyStorage
{
public:
    // IUnknown methods
    HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

public:
   // IWiaPropertyStorage methods
    HRESULT _stdcall ReadMultiple(
        ULONG                   cpspec,
        const PROPSPEC          rgpspec[],
        PROPVARIANT             rgpropvar[]);    
                
    HRESULT _stdcall WriteMultiple(
        ULONG                   cpspec,
        const PROPSPEC          rgpspec[],
        const PROPVARIANT       rgpropvar[],
        PROPID                  propidNameFirst);    
        
    HRESULT _stdcall ReadPropertyNames(
        ULONG                   cpropid,
        const PROPID            rgpropid[],
        LPOLESTR                rglpwstrName[]);
        
    HRESULT _stdcall WritePropertyNames(
        ULONG                   cpropid,
        const PROPID            rgpropid[],
        const LPOLESTR          rglpwstrName[]);
        
    HRESULT _stdcall Enum(
        IEnumSTATPROPSTG        **ppenum);    
        
    HRESULT _stdcall GetPropertyAttributes(
        ULONG                   cpspec,
        PROPSPEC                rgpspec[],
        ULONG                   rgflags[],
        PROPVARIANT             rgpropvar[]);    
            
    HRESULT _stdcall GetCount(
        ULONG                   *pulNumProps);

    HRESULT _stdcall GetPropertyStream(
        GUID                    *pCompatibilityId,
        IStream                 **ppIStream);

    HRESULT _stdcall SetPropertyStream(
        GUID                    *pCompatibilityId,
        IStream                *pIStream);

    HRESULT _stdcall DeleteMultiple(
         ULONG cpspec,
         PROPSPEC const rgpspec[]);
    
    HRESULT _stdcall DeletePropertyNames(
         ULONG cpropid,
         PROPID const rgpropid[]);
    
    HRESULT _stdcall SetClass(
         REFCLSID clsid);
    
    HRESULT _stdcall Commit(
         DWORD  grfCommitFlags);
    
    HRESULT _stdcall Revert();
    
    HRESULT _stdcall Stat(
         STATPROPSETSTG *pstatpsstg);
    
    HRESULT _stdcall SetTimes(
         FILETIME const * pctime,
         FILETIME const * patime,
         FILETIME const * pmtime);

private:
    // Helpers
    HRESULT UpdateDeviceProperties(
        ULONG               cpspec,
        const PROPSPEC      *rgpspec,
        const PROPVARIANT   *rgpropvar);


public:
    // Constructor, initialization and destructor methods.
    CWIADevInfo();
    HRESULT Initialize();
    ~CWIADevInfo();
    IPropertyStorage *m_pIPropStg;        // Device info. property storage.


private:
    ULONG            m_cRef;              // Reference count for this object.
    ITypeInfo*       m_pITypeInfo;        // Pointer to type information.
    IStream          *m_pIStm;            // Pointer to a property stream
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\drvwrap.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       drvwrap.h
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        6 Nov, 2000
*
*  DESCRIPTION:
*   Declarations and definitions for the WIA driver wrapper class.
*   It faciliates JIT loading/unloading of drivers and provides an extra layer
*   of abstraction for WIA server components - they don't deal directly with
*   driver interfaces.  This is to make us more robust and implement smart
*   driver handling.
*
*******************************************************************************/

//
// Device types, Copied from stipriv.h
//
#define HEL_DEVICE_TYPE_WDM          1
#define HEL_DEVICE_TYPE_PARALLEL     2
#define HEL_DEVICE_TYPE_SERIAL       3

//
// "Internal" device states.  This is used to mark what state we think the device 
//  is in, mainly to tell the difference between active and inactive devices.
//  We need to mark this state in case it changes, so we can generate the
//  appropriate event (e.g. if state changes from inactive to active, we'd want to
//  generate a connect event).
//  NOTE:  If any flags get added here, be sure to update the 
//  MapCMStatusToDeviceState(..) function in wiadevman.cpp to carry over any needed
//  bits from the old state to the new one.
//
#define DEV_STATE_DISABLED              0x00000001
#define DEV_STATE_REMOVED               0x00000002
#define DEV_STATE_ACTIVE                0x00000004
#define DEV_STATE_CON_EVENT_WAS_THROWN  0x00000008

//
// "Internal" device types.  Notice that mass storage cameras are represented 
//  differently to other mass storage devices.  These "normal" mass storage
//  devices (like card readers), are marked with the INTERNAL_DEV_TYPE_VOL
//  flag, whereas the MSC cameras are marked with INTERNAL_DEV_TYPE_MSC_CAMERA.
//
#define INTERNAL_DEV_TYPE_REAL          0x00000001
#define INTERNAL_DEV_TYPE_VOL           0x00000002
#define INTERNAL_DEV_TYPE_INTERFACE     0x00000004
#define INTERNAL_DEV_TYPE_WIA           0x00000010
#define INTERNAL_DEV_TYPE_LOCAL         0x00000020
#define INTERNAL_DEV_TYPE_MSC_CAMERA    0x00000040

//
//  This struct is a member of CDrvWrapper object
//
typedef struct _DEVICE_INFO {
    // Indicates whether the information in this struct is valid.  For example,
    // if we failed to read wszPortName, we would mark this as invalid.
    // wszDeviceInternalName is always assumed to be valid.
    BOOL            bValid;

    // PnP ID for this device
    //WCHAR*          wszPnPId;

    // Alternate Device ID, e.g. for volumes, it will be the mount point.  For most
    // real WIA devices, this will be NULL.
    WCHAR*          wszAlternateID;

    // State of the device to indicate enabled/disabled, plugged in/unplugged etc.
    DWORD           dwDeviceState;

    // Type of the hardware imaging device
    STI_DEVICE_TYPE DeviceType;

    // Internal Device type
    DWORD           dwInternalType;

    // Lock Holding Time - Only used for those drivers who want "cached" locking
    DWORD           dwLockHoldingTime;

    // Poll Interval
    DWORD           dwPollTimeout;

    // User disable notifications
    DWORD           dwDisableNotifications;

    // Set of capabilities flags
    STI_USD_CAPS    DeviceCapabilities;

    // This includes bus type
    DWORD           dwHardwareConfiguration;

    // Device identifier for reference when creating device object
    WCHAR*          wszUSDClassId;

    // Device identifier for reference when creating device object
    WCHAR*          wszDeviceInternalName;

    // Remote Device identifier for reference when creating remote device object for WIA
    WCHAR*          wszDeviceRemoteName;

    // Vendor description string
    WCHAR*          wszVendorDescription;

    // Device description , provided by vendor
    WCHAR*          wszDeviceDescription;

    // String , representing port on which device is accessible.
    WCHAR*          wszPortName;

    // Control panel propery provider
    WCHAR*          wszPropProvider;

    // Local specific ("friendly") name of the device, mainly used for showing in the UI
    WCHAR*          wszLocalName;

    // Name of server for this device - WIA only entry
    WCHAR*          wszServer;

    // Baud rate - Serial devices only
    WCHAR*          wszBaudRate;

    // UI CLSID
    WCHAR*          wszUIClassId;

    // SP_DEVINFO_DATA which uniquely identifies this device in WIA dev man's info set
    //  Instead of storing this, we could store interface name instead?
    SP_DEVINFO_DATA spDevInfoData;

    // SP_DEVICE_INTERFACE_DATA which uniquely identifies this device in WIA dev man's info set
    //  Same as above, except for interfaces devices instead of devnoe devices
    SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;

} DEVICE_INFO, *PDEVICE_INFO;

//
// This class is a wrapper for the USD (a similar idea to IStiDevice on STI 
//  client-side).  This provides a layer of abstraction for the higher level
//  classes, so that they don't deal with direct USD Insterfaces.  There are 
//  several advantages to this:
//  1.  It provides for greater stability.  If the driver goes away, we
//  cannot always notify components that rely on talking to the USD that
//  it is no longer present or valid.  However, by making all USD access go 
//  through this wrapper, we are guaranteed that when the USD is gone,
//  all components which attempt to use it will get the appropriate
//  error retunred by the wrapper.
//  2.  It provides greater flexibility.  For example, this class can 
//  load/unload the corresponding USD on the fly, providing for JIT
//  loading.  The higher level classes don't worry about such details;
//  they simply use the wrapper.  The wrapper will then check whether the
//  driver is already loaded, and if not, will take the appropriate steps.
//
class CDrvWrap : public IUnknown {
public:
    CDrvWrap();
    ~CDrvWrap();

    HRESULT Initialize();

    //
    //  IUnknown methods.  Note:  this class is not a real COM object!  It does not
    //  follow any of the COM rules for life-time control (e.g. it will not destroy itself
    //  if ref count is 0).
    //

    HRESULT _stdcall QueryInterface(
        const IID& iid, 
        void** ppv);
    ULONG   _stdcall AddRef(void);
    ULONG   _stdcall Release(void);

    HRESULT LoadInitDriver(HKEY hKeyDeviceParams = NULL);   // This will load and initialize the driver
                                                            //  enabling it for use
    HRESULT UnLoadDriver();                                 // This releases the USD interface pointers
                                                            //  and unloads the driver
    BOOL    IsValid();          // Valid means that we call makes calls down to driver. 
                                //  This may still be true even if driver is not loaded.  It will
                                //  only be false if we know that driver calls will fail even if
                                //  driver was loaded (e.g. USB device was unplugged)
    BOOL    IsDriverLoaded();   // Indicates whether the driver is loaded and initialized
    BOOL    IsWiaDevice();      // Indicates whether this driver is WIA capable
    BOOL    IsWiaDriverLoaded();// Indicates whether this driver's IWiaMiniDrv interface is valid
    BOOL    IsPlugged();        // Indicates whether the device is currently plugged in
    BOOL    IsVolumeDevice();   // Indicates whether this is one of our volume devices
    BOOL    PrepForUse(                     // This method is called before calling down to the driver.  It      
                BOOL        bForWiaCall,    //  ensures the driver is loaded and initalized appropriately.       
                IWiaItem    *pItem = NULL); //  TDB: pItem parameter is no longer needed 
        
    //
    //  Accessor methods
    //
    WCHAR*          getPnPId();
    WCHAR*          getDeviceId();
    DWORD           getLockHoldingTime();
    DWORD           getGenericCaps();
    DWORD           getPollTimeout();
    DWORD           getDisableNotificationsValue();
    DWORD           getHWConfig();
    DWORD           getDeviceState();
    HRESULT         setDeviceState(DWORD dwNewState);
    DEVICE_INFO*    getDevInfo();
    HRESULT         setDevInfo(
        DEVICE_INFO *pInfo);
    ULONG           getInternalType();

    VOID            setJITLoading(BOOL bJITLoading);
    BOOL            getJITLoading();
    LONG            getWiaClientCount();

    BOOL            wasConnectEventThrown();
    VOID            setConnectEventState(BOOL bEventState);

    //
    //  Wrapper methods for IStiUSD
    //

    HRESULT STI_Initialize(
        IStiDeviceControl   *pHelDcb,
        DWORD               dwStiVersion,
        HKEY                hParametersKey);
    HRESULT STI_GetCapabilities(
        STI_USD_CAPS        *pDevCaps);
    HRESULT STI_GetStatus(
        STI_DEVICE_STATUS   *pDevStatus);
    HRESULT STI_GetNotificationData(
        STINOTIFY           *lpNotify);
    HRESULT STI_SetNotificationHandle(
        HANDLE              hEvent);
    HRESULT STI_DeviceReset();
    HRESULT STI_Diagnostic(
        STI_DIAG    *pDiag);
    HRESULT STI_LockDevice();
    HRESULT STI_UnLockDevice();
    HRESULT STI_Escape( 
        STI_RAW_CONTROL_CODE    EscapeFunction,
        LPVOID                  lpInData,
        DWORD                   cbInDataSize,
        LPVOID                  pOutData,
        DWORD                   dwOutDataSize,
        LPDWORD                 pdwActualData);

    //
    //  Wrapper methods for IWiaMiniDrv
    //

    HRESULT WIA_drvInitializeWia(
        BYTE        *pWiasContext,
        LONG        lFlags,
        BSTR        bstrDeviceID,
        BSTR        bstrRootFullItemName,
        IUnknown    *pStiDevice,
        IUnknown    *pIUnknownOuter,
        IWiaDrvItem **ppIDrvItemRoot,
        IUnknown    **ppIUnknownInner,
        LONG        *plDevErrVal);

    HRESULT WIA_drvGetDeviceErrorStr(
        LONG     lFlags,
        LONG     lDevErrVal,
        LPOLESTR *ppszDevErrStr,
        LONG     *plDevErr);

    HRESULT WIA_drvDeviceCommand(
        BYTE        *pWiasContext,
        LONG        lFlags,
        const GUID  *plCommand,
        IWiaDrvItem **ppWiaDrvItem,
        LONG        *plDevErrVal);

    HRESULT WIA_drvAcquireItemData(
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    HRESULT WIA_drvInitItemProperties(
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    HRESULT WIA_drvValidateItemProperties(
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    HRESULT WIA_drvWriteItemProperties(
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    HRESULT WIA_drvReadItemProperties(
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    HRESULT WIA_drvLockWiaDevice(
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    HRESULT WIA_drvUnLockWiaDevice(
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    HRESULT WIA_drvAnalyzeItem(
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    HRESULT WIA_drvDeleteItem(
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    HRESULT WIA_drvFreeDrvItemContext(
        LONG lFlags,
        BYTE *pSpecContext,
        LONG *plDevErrVal);

    HRESULT WIA_drvGetCapabilities(
        BYTE            *pWiasContext,
        LONG            ulFlags,
        LONG            *pcelt,
        WIA_DEV_CAP_DRV **ppCapabilities,
        LONG            *plDevErrVal);

    HRESULT WIA_drvGetWiaFormatInfo(
        BYTE            *pWiasContext,
        LONG            lFlags,
        LONG            *pcelt,
        WIA_FORMAT_INFO **ppwfi,
        LONG            *plDevErrVal);

    HRESULT WIA_drvNotifyPnpEvent(
        const GUID *pEventGUID,
        BSTR       bstrDeviceID,
        ULONG      ulReserved);

    HRESULT WIA_drvUnInitializeWia(
        BYTE *pWiasContext);

private:

    HRESULT CreateDeviceControl();  // This method attempts to create a new IStiDevice control to
                                    //  hand down to the driver.  This object is released in
                                    //  UnloadDriver
    HRESULT InternalClear();        // This method clears and frees internal data members, so that the
                                    //  state of the object is the same as if it was just created and initialized
    HRESULT ReportMiniDriverError(  // This method translates the a driver error code into an error string
        LONG        lDevErr,        //  and writes it to the log.
    LPOLESTR        pszWhat);

    HINSTANCE           m_hDriverDLL;       //  Handle to driver's DLL, so we can manually unload
    HANDLE              m_hInternalMutex;   //  Internal sync object - currently unused
    DEVICE_INFO         *m_pDeviceInfo;     //  Internal Device information cache
    IUnknown            *m_pUsdIUnknown;    //  USD's IUnknown
    IStiUSD             *m_pIStiUSD;        //  USD's IStiUSD
    IWiaMiniDrv         *m_pIWiaMiniDrv;    //  USD's IWiaMiniDrv
    IStiDeviceControl   *m_pIStiDeviceControl;  // Device control handed down to USD during initialize
    BOOL                m_bJITLoading;          // Indicates whether driver should be loaded JIT
    LONG                m_lWiaTreeCount;        // Keeps track of outstanding App. Item trees (i.e. app. 
                                                //  connections).  Useful for JIT.
    BOOL                m_bPreparedForUse;      // Indicates whether driver is ready for use
    BOOL                m_bUnload;              // Indicates whether driver should be unloaded.  Used for JIT, 
                                                //  and is set when it has been determined that the driver is no 
                                                //  longer in use (inside WIA_drvUnInitializeWia and is checked
                                                //  by WIA_drvUnlockWiaDevice).
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\devmgr.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       DevMgr.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        26 Dec, 1997
*
*  DESCRIPTION:
*   Class implementation for WIA device manager.
*   07/12/2000  -   Added support for shell's Hardware Event notification to
*                   receive volume arrival notification and start the WIA Wizard.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include "wiacfact.h"

#include "wiamindr.h"

#include "devmgr.h"
#include "devinfo.h"
#include "helpers.h"
#include "wiaevntp.h"

#include "wiapriv.h"
#include "device.h"
#include "lockmgr.h"
#include "fstidev.h"
#define INITGUID
#include "initguid.h"

//
// Acquisition Manager's class ID {D13E3F25-1688-45A0-9743-759EB35CDF9A}
// NOTE:  We shouldn't really use this.  Rather GetCLSIDFromProgID and use the
//        version independant AppID name.
//

DEFINE_GUID(
    CLSID_Manager,
    0xD13E3F25, 0x1688, 0x45A0, 0x97, 0x43, 0x75, 0x9E, 0xB3, 0x5C, 0xDF, 0x9A);

/***************************************************************************
*
* RegisterEventAccessCheck
*
*   This function does an access check on the caller.  
*   We don't want to allow any user to be able to register any event 
*   handler.  For example:  consider a Guest user registering a malicious 
*   program for the Scan Button Event.  If the Admin presses the scan 
*   button, this malicious program is run under the Admin's account!
*   
*   This only applies to our Persistent event cases, not Live Interface
*   registration.  Since live interface registration is simply an interface
*   callback, there is no security risk because the calling application
*   is already running in the correct security context (we don't start
*   it up).  Also, clients cannot impersonate us when we call them back,
*   so even if the App. stayed resident, it wouldn't be a problem.
*   
* Arguments:
*
*   None
*
* Return Value:
*
*   status
*
* History:
*
*    10/05/2001 Original Version
*
\**************************************************************************/

HRESULT RegisterEventAccessCheck()
{
    //
    // We must use client token.
    //

    HRESULT hr = CoImpersonateClient();
    if (FAILED(hr)) {
        DBG_ERR(("RegisterEventAccessCheck, CoImpersonateClient failed (0x%X)", hr));
        return hr;
    }

    //
    // Since we're acting as the client, we can now verify that they have
    //  the required level of access to this machine.  Our check here is 
    //  the same as "well-behaved" NT applications - check to see whether
    //  we can open the SCM with ALL_ACCESS.  
    //  If we can, then this person can install applications, 
    //  start/stop services etc., so we will allow them to change the WIA 
    //  event registration.
    // Otherwise, return an error.
    //
    SC_HANDLE   hSCM    = NULL;
    DWORD       dwError = 0;
    hSCM = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if (hSCM) {

        CloseServiceHandle(hSCM);
        hSCM = NULL;

        //
        // This caller has the required permissions.
        //
        hr = S_OK;
    } else {

        dwError = GetLastError();

        //
        // In cases where caller does not have the appropriate privileges,
        //  this will return E_ACCESS_DENIED.
        //  
        hr = HRESULT_FROM_WIN32(dwError);
    }

    //
    //  Revert back to ourselves.
    //
    CoRevertToSelf();

    return hr;
}

/**************************************************************************\
* CWiaDevMgr::CreateInstance
*
*   Create the CWiaDevMgr object.
*
* Arguments:
*
*   iid    - iid of dev manager
*   ppv    - return interface pointer
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT CWiaDevMgr::CreateInstance(const IID& iid, void** ppv)
{
    DBG_FN(CWiaDevMgr::CreateInstance);
    HRESULT hr;

    if ((iid == IID_IWiaDevMgr) || (iid == IID_IUnknown) || (iid == IID_IHWEventHandler)) {

        // Create the WIA device manager component.

        CWiaDevMgr* pDevMgr = new CWiaDevMgr();

        if (!pDevMgr) {
            DBG_ERR(("CWiaDevMgr::CreateInstance, Out of Memory"));
            return E_OUTOFMEMORY;
        }

        // Initialize the WIA device manager component.

        hr = pDevMgr->Initialize();
        if (FAILED(hr)) {
            delete pDevMgr;
            DBG_ERR(("CWiaDevMgr::CreateInstance, Initialize failed"));
            return hr;
        }

        // Get the requested interface from the device manager component.

        hr = pDevMgr->QueryInterface(iid, ppv);
        if (FAILED(hr)) {
            delete pDevMgr;
            DBG_ERR(("CWiaDevMgr::CreateInstance, QI failed"));
            return hr;
        }

        DBG_TRC(("CWiaDevMgr::CreateInstance, Created WiaDevMgr"));
    }
    else {
       hr = E_NOINTERFACE;
       DBG_ERR(("CWiaDevMgr::CreateInstance, Unknown interface (0x%X)", hr));
    }
    return hr;
}

/**************************************************************************\
*  QueryInterface
*  AddRef
*  Release
*
*    CWiaDevMgr IUnknown Interface
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT __stdcall  CWiaDevMgr::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if ((iid == IID_IUnknown) || (iid == IID_IWiaDevMgr)) {
        *ppv = (IWiaDevMgr*) this;
    } else if (iid == IID_IWiaNotifyDevMgr) {
        *ppv = (IWiaNotifyDevMgr*) this;
    } else if (iid == IID_IHWEventHandler) {
        *ppv = (IHWEventHandler*) this;
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG __stdcall CWiaDevMgr::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}


ULONG __stdcall CWiaDevMgr::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/*******************************************************************************
*
* CWiaDevMgr
* ~CWiaDevMgr
*
*   CWiaDevMgr Constructor/Initialize/Destructor Methods.
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

CWiaDevMgr::CWiaDevMgr():m_cRef(0)
{
   m_cRef         = 0;
   m_pITypeInfo   = NULL;

   //
   // We're creating a component that exposes interfaces to clients, so
   // inform service to make sure service wont shutdown prematurely.
   //
   CWiaSvc::AddRef();
}

CWiaDevMgr::~CWiaDevMgr()
{
   DBG_FN(CWiaDevMgr::~CWiaDevMgr);

   if (m_pITypeInfo != NULL) {
       m_pITypeInfo->Release();
   }

   //
   // Component is destroyed, so no more interfaces are exposed from here.
   // Inform server by decrementing it's reference count.  This will allow
   // it to shutdown if it's no longer needed.
   //
   CWiaSvc::Release();
}

/**************************************************************************\
* CWiaDevMgr::Initialize
*
*   Create global sti instance
*
* Arguments:
*
*   none
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT CWiaDevMgr::Initialize()
{
   DBG_FN(CWiaDevMgr::Initialize);
   HRESULT  hr = S_OK;

   return hr;
}

/**************************************************************************\
* EnumWIADevInfo
*
*   Create an WIA device information enumerator object.
*
* Arguments:
*
*   lFlag   - type of device to enumerate
*   ppIEnum - return enumerator
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaDevMgr::EnumDeviceInfo(
    LONG                      lFlag,
    IEnumWIA_DEV_INFO**   ppIEnum)
{
    DBG_FN(CWiaDevMgr::EnumDeviceInfo);
    HRESULT hr      = S_OK;
    DWORD   dwWait  = 0;

    //
    // Make sure that refreshing of the device list has completed.  If 
    // it hasn't, we'll wait up to DEVICE_LIST_WAIT_TIME, before proceeding 
    // anyway.  This will ensure the device list is not empty because
    // WIA device enumeration was called too soon after start-up (e.g.
    // app's CoCreateInstance call started the service).
    //

    //
    // Enumerate LPT if necessary.
    //

    EnumLpt();

    dwWait = WaitForSingleObject(g_hDevListCompleteEvent, DEVICE_LIST_WAIT_TIME);
    if (dwWait != WAIT_OBJECT_0) {
        DBG_WRN(("CWiaDevMgr::EnumDeviceInfo, Device list was not complete before enumeration call..."));
    }

    *ppIEnum = NULL;

    CEnumWIADevInfo* pEnum = new CEnumWIADevInfo;

    if (!pEnum) {
        DBG_ERR(("CWiaDevMgr::EnumDeviceInfo, Out of Memory"));
        return E_OUTOFMEMORY;
    }

    hr = pEnum->Initialize(lFlag);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaDevMgr::EnumDeviceInfo, Initialize failed"));
        delete pEnum;
        return hr;
    }

    hr = pEnum->QueryInterface(IID_IEnumWIA_DEV_INFO,
                               (void**) ppIEnum);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaDevMgr::EnumDeviceInfo, QI for IWiaPropertyStorage failed"));
        delete pEnum;
        return E_UNEXPECTED;
    }
    return S_OK;
}


/**************************************************************************\
* FindMatchingDevice
*
*   search enumeration info for named device
*
* Arguments:
*
*   ppIPropStg
*   pbstrDeviceID
*
* Return Value:
*
*    Status
*
* History:
*
*    9/3/1998 Original Version
*
\**************************************************************************/

HRESULT CWiaDevMgr::FindMatchingDevice(
    BSTR                    pbstrDeviceID,
    IWiaPropertyStorage     **ppIWiaPropStg)
{
    DBG_FN(CWiaDevMgr::FindMatchingDevice);
    // Enumerate the WIA devices, getting a IWIADevInfo
    // pointer for each. Use this interface to query the registry
    // based properties for each installed device.

    HRESULT            hr;
    ULONG              ul, ulFound = 0;
    BSTR               bstrDevId;
    IEnumWIA_DEV_INFO *pIEnum;

    //
    //  Notice that we specify DEV_MAN_ENUM_TYPE_ALL here.
    //
    hr = EnumDeviceInfo(DEV_MAN_ENUM_TYPE_ALL,&pIEnum);

    if (SUCCEEDED(hr)) {

        ul = 1;

        while ((hr = pIEnum->Next(1, ppIWiaPropStg, &ul)) == S_OK) {

            DBG_TRC(("# Found device candidate"));

            hr = ReadPropStr(WIA_DIP_DEV_ID, *ppIWiaPropStg, &bstrDevId);

            if (SUCCEEDED(hr)) {

                DBG_TRC(("# \tDevice Name: %S", bstrDevId));
                ulFound = !lstrcmpiW(bstrDevId, pbstrDeviceID);
                SysFreeString(bstrDevId);

                if (ulFound) {
                    break;
                }
            } 
            else {
                DBG_ERR(("FindMatchingDevice, ReadPropStr of WIA_DIP_DEV_ID failed"));
            }

            (*ppIWiaPropStg)->Release();
            *ppIWiaPropStg = NULL;
        }

        pIEnum->Release();
    }
    else {
        DBG_ERR(("FindMatchingDevice:Failed to create enumerator"));
    }
    if (SUCCEEDED(hr)) {
        if (!ulFound) {
            hr = S_FALSE;
        }
    }
    return hr;
}

#ifdef WINNT

/**************************************************************************\
* IsDeviceRemote
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    TRUE if device is remote, caller must free server name.
*
* History:
*
*    1/5/1999 Original Version
*
\**************************************************************************/

BOOL IsDeviceRemote(
    IWiaPropertyStorage    *pIWiaPropStg,
    BSTR                *pbstrServer)
{
    DBG_FN(::IsDeviceRemote);
    HRESULT hr;

    hr = ReadPropStr(WIA_DIP_SERVER_NAME, pIWiaPropStg, pbstrServer);

    if ((SUCCEEDED(hr)) && (**pbstrServer)) {
        if (lstrcmpiW(*pbstrServer, L"local") != 0) {
            return TRUE;
        }
    }
    else {
        DBG_ERR(("IsDeviceRemote, ReadPropStr of WIA_DIP_SERVER_NAME failed"));
        DBG_ERR(("Registry value DeviceData\\Server may not have been set during installation"));
    }
    if (*pbstrServer) {
        SysFreeString(*pbstrServer);
    }
    return FALSE;
}

/**************************************************************************\
* CreateRemoteDevice
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/5/1999 Original Version
*
\**************************************************************************/

HRESULT CreateRemoteDevice(
    BSTR                bstrServer,
    IWiaPropertyStorage    *pIWiaPropStg,
    IWiaItem            **ppWiaDevice
    )
{
    DBG_FN(::CreateRemoteDevice);
    *ppWiaDevice = NULL;

    if (!bstrServer || !*bstrServer) {
        DBG_ERR(("CreateRemoteDevice, bad remote server name"));
        return E_INVALIDARG;
    }

    //
    // must use client
    //

    HRESULT hr = CoImpersonateClient();
    if (FAILED(hr)) {
        DBG_ERR(("CreateRemoteDevice, CoImpersonateClient failed (0x%X)", hr));
        return hr;
    }

    COSERVERINFO    coServInfo;
    MULTI_QI        multiQI[1];

    multiQI[0].pIID = &IID_IWiaDevMgr;
    multiQI[0].pItf = NULL;

    coServInfo.pwszName    = bstrServer;
    coServInfo.pAuthInfo   = NULL;
    coServInfo.dwReserved1 = 0;
    coServInfo.dwReserved2 = 0;

    //
    // create connection to dev mgr
    //

    hr = CoCreateInstanceEx(
            CLSID_WiaDevMgr,
            NULL,
            CLSCTX_REMOTE_SERVER,
            &coServInfo,
            1,
            &multiQI[0]
            );


    if (hr == S_OK) {

        BSTR        bstrRemoteDevId;
        BSTR        bstrDevId;


        IWiaDevMgr  *pIWiaDevMgr = (IWiaDevMgr*)multiQI[0].pItf;
        IWiaItem    *pIWiaItem;

        //
        // use remote dev id to create
        //

        hr = ReadPropStr(WIA_DIP_DEV_ID, pIWiaPropStg, &bstrDevId);

        if (hr == S_OK) {

            hr = ReadPropStr(WIA_DIP_REMOTE_DEV_ID, pIWiaPropStg, &bstrRemoteDevId);
        }

        if (hr == S_OK) {

            //
            // create remote device
            //

            hr = pIWiaDevMgr->CreateDevice(bstrRemoteDevId, &pIWiaItem);

            if (hr == S_OK) {

                *ppWiaDevice = pIWiaItem;

                //
                // set devinfo props for remote access
                //

                IWiaPropertyStorage *pIPropDev;

                hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,
                                               (void **)&pIPropDev);

                if (hr == S_OK) {

                    //
                    // set copy of devinfo to contain correct Remote DEVID, DEVID and server name
                    //

                    PROPSPEC        PropSpec[3];
                    PROPVARIANT     PropVar[3];

                    memset(PropVar,0,sizeof(PropVar));

                    // server name

                    PropSpec[0].ulKind = PRSPEC_PROPID;
                    PropSpec[0].propid = WIA_DIP_SERVER_NAME;

                    PropVar[0].vt      = VT_BSTR;
                    PropVar[0].bstrVal = bstrServer;

                    // DEVID

                    PropSpec[1].ulKind = PRSPEC_PROPID;
                    PropSpec[1].propid = WIA_DIP_DEV_ID;

                    PropVar[1].vt      = VT_BSTR;
                    PropVar[1].bstrVal = bstrDevId;

                    //Remote DEVID

                    PropSpec[2].ulKind = PRSPEC_PROPID;
                    PropSpec[2].propid = WIA_DIP_REMOTE_DEV_ID;

                    PropVar[2].vt      = VT_BSTR;
                    PropVar[2].bstrVal = bstrRemoteDevId;


                    hr = pIPropDev->WriteMultiple(sizeof(PropVar)/sizeof(PROPVARIANT),
                                                 PropSpec,
                                                 PropVar,
                                                 WIA_DIP_FIRST);
                    if (FAILED(hr)) {
                        ReportReadWriteMultipleError(hr, "CreateRemoteDevice", NULL, FALSE, sizeof(PropVar)/sizeof(PROPVARIANT), PropSpec);
                    }

                    //
                    // !!! hack to fix device over-checking
                    //

                    hr = S_OK;

                    pIPropDev->Release();
                }
                else {
                    DBG_ERR(("CreateRemoteDevice, remote QI of IID_IWiaPropertyStorage failed (0x%X)", hr));
                }
            } else {
                DBG_ERR(("CreateRemoteDevice, Remote CreateDevice call failed (0x%X)", hr));
            }
        } else {
            DBG_ERR(("CreateRemoteDevice, Read propeties for BSTRDevID failed (0x%X)", hr));
        }

        pIWiaDevMgr->Release();
    }
    else {
        DBG_ERR(("CreateRemoteDevice, remote CoCreateInstanceEx failed (0x%X)", hr));
    }

    CoRevertToSelf();
    return hr;
}

#endif

/**************************************************************************\
* CreateLocalDevice
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/5/1999 Original Version
*
\**************************************************************************/

HRESULT CreateLocalDevice(
    BSTR                  bstrDeviceID,
    IWiaPropertyStorage   *pIWiaPropStg,
    IWiaItem              **ppWiaItemRoot)
{
    DBG_FN(::CreateLocalDevice);
USES_CONVERSION;
    *ppWiaItemRoot = NULL;

    //
    // Build the root full item name.
    //

    WCHAR       szTmp[32], *psz;
    BSTR        bstrRootFullItemName;

#ifdef WINNT
    psz = wcsstr(bstrDeviceID, L"}\\");
#else
    psz = wcsstr(bstrDeviceID, L"\\");
#endif

    if (!psz) {
        //This is no longer true
        //DBG_ERR(("CreateLocalDevice, parse of device ID failed"));
        //return E_INVALIDARG;
        psz = bstrDeviceID;
    } else {
#ifdef WINNT
    psz += 2;
#else
    psz += 1;
#endif
    }

    wcscpy(szTmp, psz);
    wcscat(szTmp, L"\\Root");
    bstrRootFullItemName = SysAllocString(szTmp);

    if (!bstrRootFullItemName) {
        DBG_ERR(("CreateLocalDevice, unable to allocate property stream device name"));
        return E_OUTOFMEMORY;
    }

    //
    // Get an interface pointer to the STI USD object.
    //

    HRESULT         hr              = E_FAIL;
    ACTIVE_DEVICE   *pActiveDevice  = NULL;
    PSTIDEVICE      pFakeStiDevice  = NULL;
    CWiaItem        *pWiaItemRoot   = NULL;

    pActiveDevice = g_pDevMan->IsInList(DEV_MAN_IN_LIST_DEV_ID, bstrDeviceID); 
    if (pActiveDevice) {

        //
        //  Make sure driver is loaded
        //
        pActiveDevice->LoadDriver();


        //
        // Create the FakeStiDevice if we don't have one
        //
        if (!pActiveDevice->m_pFakeStiDevice) {
            pActiveDevice->m_pFakeStiDevice = new FakeStiDevice();
        }

        if (pActiveDevice->m_pFakeStiDevice) {
            pActiveDevice->m_pFakeStiDevice->Init(pActiveDevice);
            
            hr = pActiveDevice->m_pFakeStiDevice->QueryInterface(IID_IStiDevice, (VOID**)&pFakeStiDevice);
            if (SUCCEEDED(hr)) {

                //
                // Get a pointer to the WIA mini driver interface.
                //
        
                //
                // Create the root item.
                //
    
                pWiaItemRoot = new CWiaItem;
    
                if (pWiaItemRoot) {
    
                    //
                    // Query the root item for the IWiaItem interface.
                    //
    
                    hr = pWiaItemRoot->QueryInterface(IID_IWiaItem,
                                                      (void**)ppWiaItemRoot);
    
                    if (SUCCEEDED(hr)) {
    
                        //
                        // Initialize the USD.
                        //
    
                        IUnknown    *pIUnknownInner = NULL;
                        IWiaDrvItem *pIDrvItemRoot  = NULL;
                        LONG        lFlags = 0;
    
                        //
                        //  Call Sti Lock Manager to lock the device.  Before
                        //  drvInitializeWia is called, drivers wont have their
                        //  IStiDevice pointer yet, so we can't call
                        //  drvLockWiaDevice.
                        //
    
                        hr = g_pStiLockMgr->RequestLock(pActiveDevice, STIMON_AD_DEFAULT_WAIT_LOCK);
                        if (SUCCEEDED(hr)) {
                        
                            _try {
    
                                pWiaItemRoot->m_bInitialized = TRUE;
                                DBG_WRN(("=> drvInitializeWia <="));
                                //DPRINTF(DM_TRACE, TEXT("=> drvInitializeWia <=\n"));
                                hr = pActiveDevice->m_DrvWrapper.WIA_drvInitializeWia(
                                                                    (BYTE*)*ppWiaItemRoot,
                                                                    lFlags,
                                                                    bstrDeviceID,
                                                                    bstrRootFullItemName,
                                                                    (IUnknown *)pFakeStiDevice,
                                                                    *ppWiaItemRoot,
                                                                    &pIDrvItemRoot,
                                                                    &pIUnknownInner,
                                                                    &(pWiaItemRoot->m_lLastDevErrVal));
                                DBG_WRN(("=> Returned from drvInitializeWia <="));
                            } _except(EXCEPTION_EXECUTE_HANDLER){
                                DBG_ERR(("CreateLocalDevice, exception in drvInitializeWia: %X", GetExceptionCode()));
                                hr = E_FAIL;
                            }
                            pWiaItemRoot->m_bInitialized = FALSE;
                            g_pStiLockMgr->RequestUnlock(pActiveDevice);
                        }
                        
                        if (SUCCEEDED(hr) && pIDrvItemRoot) {
    
                            if (pIUnknownInner) {
                                DBG_TRC(("CreateLocalDevice driver provided optional inner component"));
                            }

                            //
                            // Store the root to the driver item tree for later use.
                            //
                            pActiveDevice->SetDriverItem((CWiaDrvItem*) pIDrvItemRoot);
    
                            //
                            // Initialize the root item.
                            //
    
                            hr = pWiaItemRoot->Initialize(pWiaItemRoot,
                                                          pIWiaPropStg,
                                                          pActiveDevice,
                                                          (CWiaDrvItem *)pIDrvItemRoot,
                                                          pIUnknownInner);
    
                            if (SUCCEEDED(hr)) {

                                //
                                //  AddRef the ActiveDevice since we're keeping it
                                //
    
                                pActiveDevice->AddRef();
                            } else {
                                DBG_ERR(("CreateLocalDevice Initialize of root item failed"));
                                pWiaItemRoot = NULL;
                            }
                        }
                        else {
                            DBG_ERR(("CreateLocalDevice drvInitializeWia failed. lDevErrVal: 0x%08X hr: 0x%X", pWiaItemRoot->m_lLastDevErrVal, hr));
                        }
                    }
                    else {
                        DBG_ERR(("CreateLocalDevice unable to QI item for its IWIaItem interface"));
                    }
                }
                else {
                    DBG_ERR(("CreateLocalDevice unable to allocate root item"));
                    hr = E_OUTOFMEMORY;
                }
            } else {
                DBG_ERR(("CreateLocalDevice, QI for fake STI device failed"));
            }
        } else {
            DBG_ERR(("CreateLocalDevice, unable to allocate fake device"));
            hr = E_OUTOFMEMORY;
        }
    }
    else {
        DBG_ERR(("CreateLocalDevice, unable to find active STI USD device object"));
        hr = WIA_S_NO_DEVICE_AVAILABLE;
    }

    //
    //  Failure cleanup
    //
    if (FAILED(hr)) {
        *ppWiaItemRoot = NULL;
        if (pWiaItemRoot) {
            delete pWiaItemRoot;
            pWiaItemRoot = NULL;
        }
    }

    //
    // Other cleanup
    //

    if (pActiveDevice) {
        pActiveDevice->Release();
        pActiveDevice = NULL;
    }
    SysFreeString(bstrRootFullItemName);
    return hr;
}

/**************************************************************************\
* CWiaDevMgr::CreateDevice
*
*   Create a WIA device from pbstrDeviceID
*
* Arguments:
*
*   pbstrDeviceID - device ID
*   ppWiaItemRoot      - return interface
*
* Return Value:
*
*    Status
*
* History:
*
*    9/3/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaDevMgr::CreateDevice(
   BSTR         bstrDeviceID,
   IWiaItem     **ppWiaItemRoot)
{
    DBG_FN(CWiaDevMgr::CreateDevice);
    HRESULT hr;

    // Validate parameters.

    if (bstrDeviceID == NULL) {
        DBG_ERR(("CWiaDevMgr::CreateDevice: invalid bstrDeviceID"));
        return E_INVALIDARG;
    }

    if (ppWiaItemRoot == NULL) {
        DBG_ERR(("CWiaDevMgr::CreateDevice: invalid ppWiaItemRoot"));
        return E_INVALIDARG;
    }

    *ppWiaItemRoot = NULL;
    // try to find a device matching pbstrDeviceID

    IWiaPropertyStorage    *pIWiaPropStg      = NULL;

    hr = FindMatchingDevice(bstrDeviceID, &pIWiaPropStg);
    if (hr != S_OK) {
        //
        //  Do a full refresh.
        //
        g_pDevMan->ReEnumerateDevices(DEV_MAN_FULL_REFRESH | DEV_MAN_GEN_EVENTS);

        hr = FindMatchingDevice(bstrDeviceID, &pIWiaPropStg);
    }

    if (hr == S_OK) {
        //
        // find out if this is a remote device
        //

#ifdef WINNT
        BOOL    bRemote = FALSE;
        BSTR    bstrServer;

        bRemote = IsDeviceRemote(pIWiaPropStg, &bstrServer);

        if (bRemote) {

            hr = CreateRemoteDevice(bstrServer, pIWiaPropStg, ppWiaItemRoot);

            SysFreeString(bstrServer);

        } else {

            hr = CreateLocalDevice(bstrDeviceID, pIWiaPropStg, ppWiaItemRoot);

        }
#else
        hr = CreateLocalDevice(bstrDeviceID, pIWiaPropStg, ppWiaItemRoot);
#endif

        pIWiaPropStg->Release();
    }
    else {
        DBG_ERR(("CWiaDevMgr::CreateDevice Failed to find device: %ls", bstrDeviceID));
        hr = WIA_S_NO_DEVICE_AVAILABLE;
    }
    return hr;
}

/*******************************************************************************
*
* SelectDevice
*
*   Never called. This method executes completely on the client side.
*
* History:
*
*    9/2/1998 Original Version
*
*******************************************************************************/

HRESULT _stdcall CWiaDevMgr::SelectDeviceDlg(
    HWND       hwndParent,
    LONG       lDeviceType,
    LONG       lFlags,
    BSTR       *pbstrDeviceID,
    IWiaItem **ppWiaItemRoot)
{
    DBG_FN(CWiaDevMgr::SelectDeviceDlg);
    DBG_ERR(("CWiaDevMgr::SelectDeviceDlg, Illegal server call, bad proxy"));
    
    return E_UNEXPECTED;
}

/*******************************************************************************
*
* SelectDevice
*
*   Never called. This method executes completely on the client side.
*
* History:
*
*    9/2/1998 Original Version
*
*******************************************************************************/

HRESULT _stdcall CWiaDevMgr::SelectDeviceDlgID(
    HWND       hwndParent,
    LONG       lDeviceType,
    LONG       lFlags,
    BSTR       *pbstrDeviceID )
{
    DBG_FN(CWiaDevMgr::SelectDeviceDlgID);
    DBG_ERR(("CWiaDevMgr::SelectDeviceDlgID, Illegal server call, bad proxy"));
    return E_UNEXPECTED;
}

/*******************************************************************************
*
* AddDeviceDlg
*
*   Never called. This method executes completely on the client side.
*
* History:
*
*    9/2/1998 Original Version
*
*******************************************************************************/

HRESULT _stdcall CWiaDevMgr::AddDeviceDlg(
    HWND       hwndParent,
    LONG       lFlags)
{
    DBG_FN(CWiaDevMgr::AddDeviceDlg);
    HRESULT hres = E_NOTIMPL;

    return hres;
}

/*******************************************************************************
*
* GetImage
*
*   Never called. This method executes completely on the client side.
*
* History:
*
*    9/2/1998 Original Version
*
*******************************************************************************/

HRESULT _stdcall CWiaDevMgr::GetImageDlg(
        HWND                            hwndParent,
        LONG                            lDeviceType,
        LONG                            lFlags,
        LONG                            lIntent,
        IWiaItem                        *pItemRoot,
        BSTR                            bstrFilename,
        GUID                            *pguidFormat)
{
    DBG_FN(CWiaDevMgr::GetImageDlg);
    DBG_ERR(("CWiaDevMgr::GetImageDlg, Illegal server call, bad proxy"));

    return E_UNEXPECTED;
}

/*******************************************************************************
*
* CWiaDevMgr::RegisterEventCallbackProgram
*
*   Register an WIA destination application
*
* Arguments:
*
*   lFlags          -
*   bstrDeviceID    -
*   pEventGUID      -
*   bstrCommandline -
*   bstrName        -
*   bstrDescription -
*   bstrIcon        -
*
* Return Value:
*
*   status
*
* History:
*
*    10/14/1999 Original Version
*
*******************************************************************************/

HRESULT _stdcall CWiaDevMgr::RegisterEventCallbackProgram(
    LONG                            lFlags,
    BSTR                            bstrDeviceID,
    const GUID                     *pEventGUID,
    BSTR                            bstrCommandline,
    BSTR                            bstrName,
    BSTR                            bstrDescription,
    BSTR                            bstrIcon)
{
    DBG_FN(CWiaDevMgr::RegisterEventCallbackProgram);

    HRESULT                         hr;
#ifndef UNICODE
    CHAR                            szCommandline[MAX_PATH];
#endif
    WCHAR                          *pPercentSign;

    //
    //  Do security check.
    //
    hr = RegisterEventAccessCheck();
    if (FAILED(hr)) {
        DBG_ERR(("CWiaDevMgr::RegisterEventCallbackProgram, client failed access check"));
        return hr;
    }

    //
    // Basic sanity check
    //

    if (! pEventGUID) {
        DBG_ERR(("CWiaDevMgr::RegisterEventCallbackProgram, bad pEventGUID"));
        return (E_INVALIDARG);
    }

    if (! bstrCommandline) {
        DBG_ERR(("CWiaDevMgr::RegisterEventCallbackProgram, bad bstrCommandline"));
        return (E_INVALIDARG);
    }

    //
    // Check the commandline, there are either 2 % or 0
    //

    pPercentSign = wcschr(bstrCommandline, L'%');
    if (pPercentSign) {
        if ((*(pPercentSign + 1) < L'0') || (*(pPercentSign + 1) > L'9')) {
            return (E_INVALIDARG);
        }

        pPercentSign = wcschr(pPercentSign + 1, L'%');
        if (! pPercentSign) {
            return (E_INVALIDARG);
        }

        if ((*(pPercentSign + 1) < L'0') || (*(pPercentSign + 1) > L'9')) {
            return (E_INVALIDARG);
        }
    }

    if ((lFlags != WIA_REGISTER_EVENT_CALLBACK) &&
        (lFlags != WIA_SET_DEFAULT_HANDLER) &&
        (lFlags != WIA_UNREGISTER_EVENT_CALLBACK)) {
        DBG_ERR(("CWiaDevMgr::RegisterEventCallbackProgram, bad lFlags"));
        return (E_INVALIDARG);
    }

#ifndef UNICODE
    WideCharToMultiByte(CP_ACP,
                        0,
                        bstrCommandline,
                        -1,
                        szCommandline,
                        MAX_PATH,
                        NULL,
                        NULL);

    hr = g_eventNotifier.RegisterEventCallback(
                             lFlags,
                             bstrDeviceID,
                             pEventGUID,
                             NULL,              // No CLSID available
                             szCommandline,
                             bstrName,
                             bstrDescription,
                             bstrIcon);
#else

    hr = g_eventNotifier.RegisterEventCallback(
                             lFlags,
                             bstrDeviceID,
                             pEventGUID,
                             NULL,              // No CLSID available
                             bstrCommandline,
                             bstrName,
                             bstrDescription,
                             bstrIcon);
#endif

    return (hr);
}


/***************************************************************************
*
* RegisterEventCallbackInterface
*
*   Registers an WIA Event Callback
*
* Arguments:
*
*   lFlags             -
*   pWiaItemRoot            -
*   llEvents           -
*   pClsID             - app can register using clsid or interface
*   pIWIAEventCallback - app can register using clsid or interface
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaDevMgr::RegisterEventCallbackInterface(
   LONG                 lFlags,
   BSTR                 bstrDeviceID,
   const GUID          *pEventGUID,
   IWiaEventCallback   *pIWIAEventCallback,
   IUnknown           **ppIEventObj)
{
    DBG_FN(CWiaDevMgr::RegisterEventCallbackInterface);
    HRESULT             hr;

    //
    //  Notice that no security accesscheck is necessary for this case.
    //  See comments in RegisterEventAccessCheck().
    //

    //
    // Validate params
    //

    if (pEventGUID == NULL) {
        DBG_ERR(("CWiaDevMgr::RegisterEventCallbackInterface, bad pEventGUID"));
        return (E_INVALIDARG);
    }

    if (pIWIAEventCallback == NULL) {
        DBG_ERR(("CWiaDevMgr::RegisterEventCallbackInterface, bad pIWIAEventCallback"));
        return (E_INVALIDARG);
    }

    if (ppIEventObj == NULL) {
        DBG_ERR(("CWiaDevMgr::RegisterEventCallbackInterface, bad ppIEventObj"));
        return (E_INVALIDARG);
    }

    //
    // lFlags is ignored, register the callback always
    //

    //
    // Register event
    //

    hr = g_eventNotifier.RegisterEventCallback(
                             lFlags,
                             bstrDeviceID,
                             pEventGUID,
                             pIWIAEventCallback,
                             ppIEventObj);
    return (hr);
}

/***************************************************************************
*
* RegisterEventCallbackCLSID
*
*   Registers an WIA Event Callback
*
* Arguments:
*
*   lFlags             -
*   bstrDeviceID       -
*   pEventGUID         -
*   pClsID             - app can register using clsid or interface
*   bstrDescription    -
*   bstrIcon           -
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaDevMgr::RegisterEventCallbackCLSID(
   LONG             lFlags,
   BSTR             bstrDeviceID,
   const GUID      *pEventGUID,
   const GUID      *pClsID,
   BSTR             bstrName,
   BSTR             bstrDescription,
   BSTR             bstrIcon)
{
    DBG_FN(CWiaDevMgr::RegisterEventCallbackCLSID);
    HRESULT  hr;

    //
    //  Do security check.
    //
    hr = RegisterEventAccessCheck();
    if (FAILED(hr)) {
        DBG_ERR(("CWiaDevMgr::RegisterEventCallbackCLSID, client failed access check"));
        return hr;
    }

    //
    // Validate params
    //

    if (pEventGUID == NULL) {
        DBG_ERR(("CWiaDevMgr::RegisterEventCallbackCLSID, bad pEventGUID"));
        return (E_INVALIDARG);
    }

    if (pClsID == NULL) {
        DBG_ERR(("CWiaDevMgr::RegisterEventCallbackCLSID, bad pClsID"));
        return (E_INVALIDARG);
    }

    if (lFlags == WIA_REGISTER_EVENT_CALLBACK) {
        DBG_TRC(("CWiaDevMgr::RegisterEventCallback"));
    } else {

        if (lFlags == WIA_UNREGISTER_EVENT_CALLBACK) {
            DBG_TRC(("CWiaDevMgr::UnregisterEventCallback"));
        } else {

            if (lFlags == WIA_SET_DEFAULT_HANDLER) {
                DBG_TRC(("CWiaDevMgr::SetDefaultHandler"));
            } else {
                DBG_ERR(("CWiaDevMgr::RegisterEventCallbackCLSID, Invalid operation"));
                return (HRESULT_FROM_WIN32(ERROR_INVALID_OPERATION));
            }
        }
    }

    //
    // register event
    //

    hr = g_eventNotifier.RegisterEventCallback(
                             lFlags,
                             bstrDeviceID,
                             pEventGUID,
                             pClsID,
                             NULL,      // No commandline necessary
                             bstrName,
                             bstrDescription,
                             bstrIcon);
    return (hr);
}

/***************************************************************************
*
* Initialize
*
*   This is the first call received from the Shell's Hardware event 
*   notification.
*
* Arguments:
*
*   pszParams   -   The parameter string we wrote in our registration.
*                   Currently, we don't specify a parameter string, so this
*                   will be empty.
*
* Return Value:
*
*   status
*
* History:
*
*    07/12/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaDevMgr::Initialize( 
    LPCWSTR pszParams)
{
    HRESULT hr = E_FAIL;

    //
    //  Initialize the device manager here.  This is so that when HandleEvent gets
    //  processed, we can successfully enumerate the WIA devices.
    //

    hr = Initialize();
    if (FAILED(hr)) {
        DBG_ERR(("CWiaDevMgr::Initialize(string), Initialize() call failed"));
    }
    return hr;
}

/***************************************************************************
*
* HandleEventWithContent
*
*   This is the second call received from the Shell's Hardware event 
*   notification.  This tells us the driver letter of the volume that
*   just arrived.  Our action is to find the appropriate file system driver
*   and launch the WIA Wizard.
*
* Arguments:
*
*   pszDeviceID           -   The PnP device id.  Ignored.
*   pszAltDeviceID        -   Alternate device id.  For volume arrivals,
*                             this is the drive letter.
*   pszEventType          -   String signifying the event type.   Ignored.
*   pszContentTypeHandler -   Content that triggered this event
*   pdataobject           -   IDataObject to get an HDROP to enumerate
*                             the files found
*
* Return Value:
*
*   status
*
* History:
*
*    08/04/2000 Original Version
*
\**************************************************************************/
HRESULT _stdcall CWiaDevMgr::HandleEventWithContent(
        LPCWSTR pszDeviceID,
        LPCWSTR pszAltDeviceID,
        LPCWSTR pszEventType,
        LPCWSTR /*pszContentTypeHandler*/,
        IDataObject* pdataobject)
{
    HRESULT hres = E_INVALIDARG;
    BSTR    bstrDeviceId = NULL;

    // No need for this object
    // NOTE: Appears to be a shell bug here - if I release it then it
    //  faults - looks like a double release.
    //pdataobject->Release();
    //pdataobject = NULL;

    if (pszAltDeviceID)
    {
        hres = FindFileSystemDriver(pszAltDeviceID, &bstrDeviceId);
        if (hres != S_OK) {
            if (bstrDeviceId) {
                SysFreeString(bstrDeviceId);
                bstrDeviceId = NULL;
            }

            //
            //  Get the DeviceId of the file system driver
            //
            WCHAR       wszDevId[STI_MAX_INTERNAL_NAME_LENGTH];

            memset(wszDevId, 0, sizeof(wszDevId));

            //
            //  Construct Device ID.  Device ID looks like:
            //  {MountPoint}
            //  e.g. {e:\}
            //
            lstrcpyW(wszDevId, L"{");

            //
            //  We don't want to overrun our internal name length constarint, so we first check
            //  to see whether the string length of pszAltDeviceID is short enough to allow concatenation
            //  of {, }, pszAltDeviceID and NULL terminator, and still fit all this into a string of
            //  length STI_MAX_INTERNAL_NAME_LENGTH.
            //  Note the space after the brackets in sizeof(L"{} ").
            //
            if (lstrlenW(pszAltDeviceID) > (STI_MAX_INTERNAL_NAME_LENGTH - (sizeof(L"{} ") / sizeof(WCHAR)))) {
                //
                //  The name is too long, so we just insert our own name instead
                //
                lstrcatW(wszDevId, L"NameTooLong");
            } else {
                lstrcatW(wszDevId, pszAltDeviceID);
            }
            lstrcatW(wszDevId, L"}");

            bstrDeviceId = SysAllocString(wszDevId);

        }
        //
        //  Run the Acquisition Manager on the file system driver.
        //

        hres = RunAcquisitionManager(bstrDeviceId);
        if (bstrDeviceId) {
            SysFreeString(bstrDeviceId);
            bstrDeviceId = NULL;
        }
    }

    return hres;
}

/***************************************************************************
*
* HandleEvent
*
*   This should never be called.  WIA does not register for it.
*
* Arguments:
*
*   pszDeviceID     -   The PnP device id.  Ignored.
*   pszAltDeviceID  -   Alternate device id.  For volume arrivals, this is 
*                       the drive letter.
*   pszEventType    -   String signifying the event type.   Ignored.
*
* Return Value:
*
*   status
*
* History:
*
*    07/12/2000 Original Version
*    08/04/2000 Replaced by HandleEventWithContent
*
\**************************************************************************/

HRESULT _stdcall CWiaDevMgr::HandleEvent( 
    LPCWSTR pszDeviceID,
    LPCWSTR pszAltDeviceID,
    LPCWSTR pszEventType)
{
    return E_NOTIMPL;
}

HRESULT CWiaDevMgr::FindFileSystemDriver(
    LPCWSTR pszAltDeviceID, 
    BSTR    *pbstrDeviceId)
{
    HRESULT         hr              = S_OK;
    WCHAR           *wszDevId       = NULL;
    ACTIVE_DEVICE   *pActiveDevice  = NULL;
    DEVICE_INFO     *pDeviceInfo    = NULL;


    *pbstrDeviceId = NULL;

    //
    //  Do a full refresh.
    //
    hr = g_pDevMan->ReEnumerateDevices(DEV_MAN_FULL_REFRESH | DEV_MAN_GEN_EVENTS);
    pActiveDevice = g_pDevMan->IsInList(DEV_MAN_IN_LIST_ALT_ID, pszAltDeviceID);

    //
    //  Let's check whether we found the device - a full refresh would have been done
    //  by this point if it was not found initially.
    //
    if (pActiveDevice) {

        //
        //  Update the device information
        //
        pDeviceInfo = pActiveDevice->m_DrvWrapper.getDevInfo();
        if (pDeviceInfo) {
            RefreshDevInfoFromMountPoint(pDeviceInfo, (WCHAR*)pszAltDeviceID);
        }

        wszDevId = pActiveDevice->GetDeviceID();
        pActiveDevice->Release();
    } else {
        DBG_WRN(("CWiaDevMgr::FindFileSystemDriver, File system driver not available for this mount point"));
        hr = E_FAIL;
    }

    if (wszDevId) {
        *pbstrDeviceId = SysAllocString(wszDevId);
        if (!*pbstrDeviceId) {
            DBG_WRN(("CWiaDevMgr::FindFileSystemDriver, Out of memory!"));
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT CWiaDevMgr::RunAcquisitionManager(BSTR bstrDeviceId)
{
    HRESULT             hr          = E_FAIL;
    IWiaEventCallback   *pCallback  = NULL;

    //
    //  CoCreate the Wia Acquisition Manager
    //

    hr = _CoCreateInstanceInConsoleSession (CLSID_Manager,
                                            NULL,
                                            CLSCTX_LOCAL_SERVER,
                                            IID_IWiaEventCallback,
                                            (void**)(&pCallback));
    if (SUCCEEDED(hr)) {

        //
        //  Send a Device_Connected event for the file system driver, indicating
        //  StiDeviceTypeDigitalCamera, so Acquisition Manager will show it's 
        //  camera UI.
        //

        ULONG ulEventType = 0;
        hr = pCallback->ImageEventCallback(&WIA_EVENT_DEVICE_CONNECTED,
                                           NULL,                      
                                           bstrDeviceId,
                                           NULL,                 
                                           StiDeviceTypeDigitalCamera,
                                           NULL,
                                           &ulEventType,
                                           0);
        if FAILED(hr) {
            DBG_ERR(("CWiaDevMgr::RunAcquisitionManager, ImageEventCallback failed"));
        }
        pCallback->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\drvwrap.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       drvwrap.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        6 Nov, 2000
*
*  DESCRIPTION:
*   Declarations and definitions for the WIA driver wrapper class.
*   It faciliates JIT loading/unloading of drivers and provides an extra layer
*   of abstraction for WIA server components - they don't deal directly with
*   driver interfaces.  This is to make us more robust and implement smart
*   driver handling.
*
*******************************************************************************/

#include "precomp.h"
#include "stiexe.h"
#include "lockmgr.h"

/**************************************************************************\
* CDrvWrap::CDrvWrap
*
*   Constructor for driver wrapper.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   None.
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
CDrvWrap::CDrvWrap()
{
    m_hDriverDLL            = NULL;
    m_hInternalMutex        = NULL;
    m_pDeviceInfo           = NULL;
    m_pUsdIUnknown          = NULL;
    m_pIStiUSD              = NULL;
    m_pIWiaMiniDrv          = NULL;
    m_pIStiDeviceControl    = NULL;
    m_bJITLoading           = FALSE;
    m_lWiaTreeCount         = 0;
    m_bPreparedForUse       = FALSE;
    m_bUnload               = FALSE;
}

/**************************************************************************\
* CDrvWrap::~CDrvWrap
*
*   Desctructor for driver wrapper.  Calls internal clear to make sure
*   driver is unloaded if it hasn't been already.  Releases any
*   resources help by the wrapper that needs to live accross driver
*   loading/unloading, such as the DEVICE_INFO
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   None.
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
CDrvWrap::~CDrvWrap()
{
    //
    //  Release driver interfaces and unload driver
    //
    InternalClear();

    if (m_hInternalMutex) {
        CloseHandle(m_hInternalMutex);
        m_hInternalMutex = NULL;
    }

    if (m_pDeviceInfo) {
        DestroyDevInfo(m_pDeviceInfo);
        m_pDeviceInfo    = NULL;
    }
}

/**************************************************************************\
* CDrvWrap::Initialize
*
*   Initializes any object members that could not be set in the constructor,
*   such as allocating resources that may fail.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   Status
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
HRESULT CDrvWrap::Initialize()
{
    HRESULT hr = E_FAIL;

    m_hInternalMutex = CreateMutex(NULL, FALSE, NULL);
    m_pDeviceInfo = (DEVICE_INFO*) LocalAlloc(LPTR, sizeof(DEVICE_INFO));
    if (!m_hInternalMutex || !m_pDeviceInfo) {

        DBG_ERR(("CDrvWrap::Initialize, out of memory!"));
        hr = E_OUTOFMEMORY;
    } else {
        hr = S_OK;
    }

    if (FAILED(hr)) {
        if (m_hInternalMutex) {
            CloseHandle(m_hInternalMutex);
            m_hInternalMutex = NULL;
        }
        if (m_pDeviceInfo) {
            LocalFree(m_pDeviceInfo);
            m_pDeviceInfo          = NULL;
        }
    }
    return hr;
}

/**************************************************************************\
* CDrvWrap::QueryInterface
*
*   This QI will return it's own "this" pointer for IUnknown, but will
*   delegate down to the USD for any other interface.
*
* Arguments:
*
*   iid -   The interface ID of the requested interface.
*   ppv -   Pointer to variable receiving the interface pointer.
*
* Return Value:
*
*   Status
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
HRESULT _stdcall CDrvWrap::QueryInterface(const IID& iid, void** ppv)
{
    HRESULT hr = E_NOINTERFACE;

    //
    //  Always delegate down to USD, unless asking for IUnknown
    //

    if (iid == IID_IUnknown) {
        *ppv = (IUnknown*) this;
        AddRef();
        hr = S_OK;
    } else {
        if (PrepForUse(FALSE)) {
            if (m_pUsdIUnknown) {
                hr = m_pUsdIUnknown->QueryInterface(iid, ppv);
            } else {
                DBG_TRC(("CDrvWrap::QueryInterface, m_pUsdIUnknown == NULL"))
            }
        } else {
            DBG_WRN(("CDrvWrap::QueryInterface, attempting to call IStiUSD::QueryInterface when driver is not loaded"));
        }

    }

    return hr;
}

/**************************************************************************\
* CDrvWrap::AddRef
*
*   Notice that this method simply returns 2.  We don't want to subject the
*   lifetime of this object to ref-counting.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   2
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
ULONG   _stdcall CDrvWrap::AddRef(void)
{
    ULONG ulCount = 2;

    //
    //  Since we plan to manually load/unload the driver, we don't really want
    //  to honor any AddRef/Release calls.
    //

    return ulCount;
}

/**************************************************************************\
* CDrvWrap::Release
*
*   Notice that this method simply returns 1.  We don't want to subject the
*   lifetime of this object to ref-counting.
*
* Arguments:
*
*
*
* Return Value:
*
*   1
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
ULONG   _stdcall CDrvWrap::Release(void)
{
    ULONG ulCount = 1;

    //
    //  We don't want this object to be controlled with refcounting - the
    //  DEVICE_OBJECT will manually delete us when it's done.  Also, since
    //  we want to manually load/unload the driver, we don't really want
    //  to honor any AddRef/Release calls down to it..
    //

    return ulCount;
}

/**************************************************************************\
* CDrvWrap::LoadInitDriver
*
*   Load the USD and initialize it appropriately.
*
* Arguments:
*
*   hKeyDeviceParams    - The device registry key.  This is handed down to the
*                         driver during intialization.  If it is NULL, we will
*                         attempt to find the real one to hand down to the
*                         driver.  For volume devices, there is no registry
*                         key and NULL will be handed down.
*
* Return Value:
*
*   Status
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
HRESULT CDrvWrap::LoadInitDriver(HKEY hKeyDeviceParams)
{
    HRESULT         hr          = E_UNEXPECTED;
    IUnknown        *pThisUnk   = NULL;
    BOOL            bOpenedKey  = FALSE;

    if (!m_pDeviceInfo) {
        DBG_WRN(("CDrvWrap::LoadInitDriver, can't load driver with no Device Information"));
        return hr;
    }

    if (!m_pDeviceInfo->bValid) {
        DBG_WRN(("CDrvWrap::LoadInitDriver, called with invalid Device Information"));
        return hr;
    }

    //
    //  Create a new IStiDeviceControl object.  This needs to be handed down to the
    //  driver during initialization.  If we can't create it, then bail, since we
    //  wont be able to initialize the driver properly.
    //

    hr = CreateDeviceControl();
    if (FAILED(hr)) {
        DBG_WRN(("CDrvWrap::LoadInitDriver, could not create IStiDeviceControl object.  Aborting driver loading"));
        return hr;
    }

    //
    //  If the hKeyDeviceParams is NULL, see if it is a real WIA device.  If not, then
    //  it is supposed to be NULL, else see if we can get it from our DevMan, using
    //  this device's DevInfoData.
    //


    if ((hKeyDeviceParams == NULL) && (m_pDeviceInfo->dwInternalType & INTERNAL_DEV_TYPE_REAL)) {

        //
        //  Check whether device is interface or devnode type device.  Grab the
        //  HKey from the appropriate place
        //

        hKeyDeviceParams = g_pDevMan->GetDeviceHKey(m_pDeviceInfo->wszDeviceInternalName, NULL);
        bOpenedKey = TRUE;
    }

    //
    //  We always create the USD object as aggregated, so first we get our IUnknown
    //  pointer to pass it it during CoCreate.
    //

    hr = QueryInterface(IID_IUnknown, (void**) &pThisUnk);
    if (SUCCEEDED(hr)) {

        //
        //  Call our own version of CoCreate.  This is to facilitate manual loading/unloading
        //  of drivers.
        //
        hr = MyCoCreateInstanceW(m_pDeviceInfo->wszUSDClassId,
                                 pThisUnk,
                                 IID_IUnknown,
                                 (PPV) &m_pUsdIUnknown,
                                 &m_hDriverDLL);
        if (SUCCEEDED(hr)) {

            //
            //  QI for the IStiUSD interface.  Notice that we can call our own
            //  QueryInterface since it delegates down to the driver via m_pUsdIUnknown.
            //
            hr = m_pUsdIUnknown->QueryInterface(IID_IStiUSD, (void**) &m_pIStiUSD);
            if (SUCCEEDED(hr)) {

                //
                //  If this is a WIA device, QI for IWiaMiniDrv
                //
                if (IsWiaDevice()) {
                    hr = m_pUsdIUnknown->QueryInterface(IID_IWiaMiniDrv, (void**) &m_pIWiaMiniDrv);
                    if (FAILED(hr)) {
                        DBG_WRN(("CDrvWrap::LoadInitDriver, WIA driver did not return IWiaMiniDrv interface for device (%ws)", getDeviceId()));

                        //
                        //  Change hr here to indicate success.  Even if WIA portoin of driver
                        //  doesn't work, the STI portion does so far.  Any WIA calls down to this
                        //  driver will result in a E_NOINTERFACE error returned by the wrapper.
                        //
                        hr = S_OK;
                    }
                }

                //
                //  We now have the Sti USD, so let's initialize it
                //

                hr = STI_Initialize(m_pIStiDeviceControl,
                                    STI_VERSION_REAL,
                                    hKeyDeviceParams);
                if (SUCCEEDED(hr)) {

                    //
                    // Now get capabilities of the USD and verify version
                    //

                    STI_USD_CAPS    DeviceCapabilities;
                    hr = STI_GetCapabilities(&DeviceCapabilities);
                    if (SUCCEEDED(hr)) {
                        if (STI_VERSION_MIN_ALLOWED <= DeviceCapabilities.dwVersion) {
                            //
                            //  Everything's fine, we've loaded the USD.  Do any post
                            //  initialization steps e.g. for MSC devices, make sure
                            //  we tell the driver what drive/mount point is should
                            //  be attached to.
                            //

                        } else {

                            //
                            //  Driver version is too old, driver will probably not work, so unload it.
                            //

                            DBG_WRN(("CDrvWrap::LoadInitDriver, driver version is incompatible (too old)"));
                            hr = STIERR_OLD_VERSION;
                        }
                    } else {
                        DBG_WRN(("CDrvWrap::LoadInitDriver, STI_GetCapabilities failed"));
                    }
                } else {
                    DBG_WRN(("CDrvWrap::LoadInitDriver, STI_Initialize failed"));
                }

            } else {
                DBG_WRN(("CDrvWrap::LoadInitDriver, QI to driver failed to return IStiUSD"));
            }
        } else {
            DBG_WRN(("CDrvWrap::LoadInitDriver, failed to CoCreate driver, hr = 0x%08X", hr));
        }

        //
        //  If anything failed, call UnloadDriver to clean up.
        //

        if (FAILED(hr)) {
            DBG_WRN(("CDrvWrap::LoadInitDriver, Aborting driver loading"));
            pThisUnk->Release();
            UnLoadDriver();
        }
    } else {
        DBG_ERR(("CDrvWrap::LoadInitDriver, could not get this IUnknown  to hand to driver for aggregation"));
    }

    //
    //  If we had to open the key, make sure we close it.  We don't want to close the key
    //  if it was handed to us.
    //
    if(hKeyDeviceParams && bOpenedKey) RegCloseKey(hKeyDeviceParams);

    return hr;
}


/**************************************************************************\
* CDrvWrap::UnLoadDriver
*
*   This method will unload the driver.  NOTE assumption:  This method
*   assumes all WIA item references have already been released when this
*   is called.  The reason is that drvUnInitializeWia needs to be called for
*   each WIA Item tree.
*   TBD:
*   One possible way to get around this is:  Keep a list of WIA items
*   attached to this device.  Then, if we get here, call drvUnitializeWia,
*   passing the root of each item tree.  Another, much better way: store
*   the driver item tree in the wrapper.  Then destroy the tree either when
*   asked, or when unloading the driver.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   Status
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/

HRESULT CDrvWrap::UnLoadDriver()
{
    HRESULT         hr = E_UNEXPECTED;

    //
    //  Release all driver interfaces we're holding
    //

    if (m_pIWiaMiniDrv) {
        m_pIWiaMiniDrv->Release();
        m_pIWiaMiniDrv           = NULL;
    }
    if (m_pIStiUSD) {
        m_pIStiUSD->Release();
        m_pIStiUSD              = NULL;
    }
    if (m_pUsdIUnknown) {
        m_pUsdIUnknown->Release();
        m_pUsdIUnknown          = NULL;
    }

    //
    //  Release the device control object
    //

    if (m_pIStiDeviceControl) {
        m_pIStiDeviceControl->Release();
        m_pIStiDeviceControl    = NULL;
    }

    //
    //  Unload the driver DLL.  We load/unload the DLL manually to ensure the driver
    //  DLL is released when requested e.g. when the user wants to update the driver.
    //

    if (m_hDriverDLL) {
        FreeLibrary(m_hDriverDLL);
        m_hDriverDLL = NULL;
    }

    m_lWiaTreeCount         = 0;
    m_bPreparedForUse       = FALSE;
    m_bUnload               = FALSE;

    //
    //  Notice that we don't clear m_pDeviceInfo.  This information is needed if we
    //  decide to reload the driver.
    //

    return hr;
}

/**************************************************************************\
* CDrvWrap::IsValid
*
*   This object is considered valid if there is nothing preventing it from
*   loading the driver.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   Status
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
BOOL CDrvWrap::IsValid()
{
    //
    //  This object is considered valid if there is nothing preventing
    //  it from loading the driver.
    //  We should be able to load the driver if:
    //  - We have a non-NULL DeviceInfo struct
    //  - The DeviceInfo struct contains valid data
    //  - The device is marked as active
    //

    if (m_pDeviceInfo) {
        if (m_pDeviceInfo->bValid && (m_pDeviceInfo->dwDeviceState & DEV_STATE_ACTIVE)) {
            return TRUE;
        }
    }

    return FALSE;
}

/**************************************************************************\
* CDrvWrap::IsDriverLoaded
*
*   Checks whether driver is loaded
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   True    - driver is loaded
*   False   - driver is not loaded
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
BOOL CDrvWrap::IsDriverLoaded()
{
    HRESULT         hr = E_UNEXPECTED;

    //
    //  We know driver is loaded if we have a valid interface pointer to it.
    //

    if (m_pUsdIUnknown) {
        return TRUE;
    }

    return FALSE;
}

/**************************************************************************\
* CDrvWrap::IsWiaDevice
*
*   This method looks at the capabilities to decide whether a driver is
*   WIA capable or not.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   TRUE    - Is a WIA device
*   FALSE   - Not a WIA device
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
BOOL CDrvWrap::IsWiaDevice()
{
    if (m_pDeviceInfo) {

        //
        //  Drivers report that they're WIA capable in their STI capabilties
        //  entry.
        //

        return (m_pDeviceInfo->dwInternalType & INTERNAL_DEV_TYPE_WIA);
    }

    //
    //  If we don't know for sure it's a WIA device, then assume it isn't
    //

    return FALSE;
}

/**************************************************************************\
* CDrvWrap::IsWiaDriverLoaded
*
*   This method looks at the IWIaMiniDrv interface pointer from the driver
*   and returns whether it is valid or not.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   TRUE    - WIA portion of driver is loaded
*   FALSE   - WIA portion of driver is not loaded
*
* History:
*
*    12/15/2000 Original Version
*
\**************************************************************************/
BOOL CDrvWrap::IsWiaDriverLoaded()
{
    if (m_pIWiaMiniDrv) {

        //
        //  If this interface is non-NULL, it means we successfully QI'd
        //  for it during initialization.  Therefore the driver is loaded
        //  and is WIA capable.
        //

        return TRUE;
    }

    return FALSE;
}

/**************************************************************************\
* CDrvWrap::IsPlugged
*
*   Checks the DEVICE_INFO to see whether the device has been marked as
*   active.  Devies on a PnP bus like USB are inactive if not plugged in.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   TRUE    - Device is active, and is considered plugged
*   FALSE   - Device is inactive, and is not considered to be plugged in.
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
BOOL CDrvWrap::IsPlugged()
{
    if (m_pDeviceInfo) {

        //
        //  Check the device state
        //
        return (m_pDeviceInfo->dwDeviceState & DEV_STATE_ACTIVE);
    }

    //
    //  If we don't know for sure it's plugged in, then assume it isn't
    //

    return FALSE;
}

/**************************************************************************\
* CDrvWrap::IsVolumeDevice
*
*   Checks the DEVICE_INFO to see whether the device is marked as a volume
*   device.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   TRUE    - Device is a volume device
*   FALSE   - Device is not a volume device
*
* History:
*
*    12/13/2000 Original Version
*
\**************************************************************************/
BOOL CDrvWrap::IsVolumeDevice()
{
    if (m_pDeviceInfo) {

        //
        //  Check the device internal type
        //

        return (m_pDeviceInfo->dwInternalType & INTERNAL_DEV_TYPE_VOL);
    }

    //
    //  If we don't know for sure it's a volume device, then assume it isn't
    //

    return FALSE;
}


/**************************************************************************\
* CDrvWrap::PrepForUse
*
*   This method is generally called just before making a call down to the
*   driver.  It checks to see whether the driver is loaded, and if it isn't,
*   will attempt to load it.
*
* Arguments:
*
*   bForWiaCall -   Indicates whether this is being called because a WIA
*                   call is about to be made.  This will check that the
*                   IWiaMiniDrv interface is valid.
*   pRootItem   -   not used
*
* Return Value:
*
*   TRUE    - Device is ready to be used
*   FALSE   - Device cannot be used (driver could not be loaded/initialized)
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/

BOOL CDrvWrap::PrepForUse(BOOL bForWiaCall, IWiaItem *pRootItem)
{
    HRESULT         hr = S_OK;

    if (!m_bPreparedForUse || (bForWiaCall && !m_pIWiaMiniDrv)) {

        //
        //  Only attempt to load if the device is marked as ACTIVE
        //
        if (m_pDeviceInfo->dwDeviceState & DEV_STATE_ACTIVE) {
            if (!IsDriverLoaded()) {
                hr = LoadInitDriver();
            }

            if (SUCCEEDED(hr)) {
                if (m_pDeviceInfo) {

                    if (bForWiaCall) {
                        //
                        //  For WIA devices, check that we have a valid IWiaMiniDrv interface
                        //
                        if (IsWiaDevice()) {
                            if (!m_pIWiaMiniDrv) {

                                //
                                //  Attempt to Q.I. for IWiaMiniDrv again.
                                //
                                hr = m_pUsdIUnknown->QueryInterface(IID_IWiaMiniDrv,
                                                                    (VOID**) &m_pIWiaMiniDrv);
                                if (FAILED(hr) || !m_pIWiaMiniDrv) {
                                    DBG_WRN(("CDrvWrap::PrepForUse, attempting to use WIA driver which doesn't have IWiaMiniDrv interface"));
                                    hr = E_NOINTERFACE;
                                }
                            }
                        }
                    }
                } else {
                    DBG_WRN(("CDrvWrap::PrepForUse, attempting to use driver with NULL DeviceInfo"));
                    hr = E_UNEXPECTED;
                }

                if (SUCCEEDED(hr)) {
                    m_bPreparedForUse = TRUE;
                }
            } else {
                DBG_ERR(("CDrvWrap::PrepForUse, LoadInitDriver() failed (%x)", hr));
            }
        }
    }

    if (!m_bPreparedForUse) {
        DBG_TRC(("CDrvWrap::PrepForUse, Driver could NOT be loaded!"));
    }

    return m_bPreparedForUse;
}

/*****************************************************************************/
//
//  Accessor methods
//

WCHAR* CDrvWrap::getPnPId()
{
    if (m_pDeviceInfo) {
        //TBD:
        //return m_pDeviceInfo->wszPnPId;
    }

    return NULL;
}

WCHAR* CDrvWrap::getDeviceId()
{
    if (m_pDeviceInfo) {
        return m_pDeviceInfo->wszDeviceInternalName;
    }

    return NULL;
}

DWORD CDrvWrap::getLockHoldingTime()
{
    if (m_pDeviceInfo) {
        return m_pDeviceInfo->dwLockHoldingTime;
    }
    return 0;
}

DWORD CDrvWrap::getGenericCaps()
{
    if (m_pDeviceInfo) {
        return m_pDeviceInfo->DeviceCapabilities.dwGenericCaps;
    }
    return 0;
}

DWORD CDrvWrap::getPollTimeout()
{
    if (m_pDeviceInfo) {
        return m_pDeviceInfo->dwPollTimeout;
    }
    return 0;
}

DWORD CDrvWrap::getDisableNotificationsValue()
{
    if (m_pDeviceInfo) {
        return m_pDeviceInfo->dwDisableNotifications;
    }
    return 0;
}

DWORD CDrvWrap::getHWConfig()
{
    if (m_pDeviceInfo) {
        return m_pDeviceInfo->dwHardwareConfiguration;
    }
    return 0;
}

DWORD CDrvWrap::getDeviceState()
{
    if (m_pDeviceInfo) {
        return m_pDeviceInfo->dwDeviceState;
    }
    return 0;
}

HRESULT CDrvWrap::setDeviceState(
    DWORD dwNewDevState)
{
    if (m_pDeviceInfo) {
        m_pDeviceInfo->dwDeviceState = dwNewDevState;
        return S_OK;
    }
    DBG_WRN(("CDrvWrap::setDeviceState, attempting to set device state when DeviceInfo is NULL"));
    return E_UNEXPECTED;
}

DEVICE_INFO* CDrvWrap::getDevInfo()
{
    return m_pDeviceInfo;
}

HRESULT CDrvWrap::setDevInfo(DEVICE_INFO *pInfo)
{
    HRESULT         hr = E_UNEXPECTED;

    if (pInfo) {
        //
        //  Caller allocates pInfo.  We release it when we're done.
        //  DeviceInfo must be set before driver can be loaded.
        //
        m_pDeviceInfo = pInfo;
    } else {
        DBG_ERR(("CDrvWrap::setDevInfo, attempting to set DeviceInfo to invalid value (NULL)"));
    }

    return hr;
}

ULONG CDrvWrap::getInternalType()
{
    if (m_pDeviceInfo) {
        return m_pDeviceInfo->dwInternalType;
    }

    return 0;
}

VOID CDrvWrap::setJITLoading(BOOL bJITLoading)
{
    m_bJITLoading = bJITLoading;
}

BOOL CDrvWrap::getJITLoading()
{
    return m_bJITLoading;
}

LONG CDrvWrap::getWiaClientCount()
{
    return m_lWiaTreeCount;
}

BOOL CDrvWrap::wasConnectEventThrown()
{
    if (m_pDeviceInfo) {
        return (m_pDeviceInfo->dwDeviceState & DEV_STATE_CON_EVENT_WAS_THROWN);
    }
    return FALSE;
}

VOID CDrvWrap::setConnectEventState(
    BOOL    bEventState)
{
    if (m_pDeviceInfo) {
        if (bEventState) {

            //
            //  Set the bit to indicate that connect event was thrown
            //
            m_pDeviceInfo->dwDeviceState = (m_pDeviceInfo->dwDeviceState | DEV_STATE_CON_EVENT_WAS_THROWN);
        } else {

            //
            //  Clear the bit that indicated the connect event was thrown
            //
            m_pDeviceInfo->dwDeviceState = (m_pDeviceInfo->dwDeviceState & (~DEV_STATE_CON_EVENT_WAS_THROWN));
        }
    }
}

//
//  End of accessor methods
//
/*****************************************************************************/

/*****************************************************************************/
//
//  Wrapper methods for IStiUSD
//

HRESULT CDrvWrap::STI_Initialize(
    IStiDeviceControl   *pHelDcb,
    DWORD               dwStiVersion,
    HKEY                hParametersKey)
{
    HRESULT hr = WIA_ERROR_OFFLINE;

    if (PrepForUse(FALSE)) {
        //
        // Initialize USD object
        //
        __try {
            hr = m_pIStiUSD->Initialize(pHelDcb,
                                        dwStiVersion,
                                        hParametersKey);
        }
        __except(EXCEPTION_EXECUTE_HANDLER ) {
            DBG_WRN(("CDrvWrap::STI_Initialize, exception in driver calling IStiUSD::Initialize"));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::STI_Initialize, attempting to call IStiUSD::Initialize when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::STI_GetCapabilities(STI_USD_CAPS *pDevCaps)
{
    HRESULT hr = WIA_ERROR_OFFLINE;

    if (PrepForUse(FALSE)) {
        //
        // Get STI capabilities from USD object
        //
        __try {
            hr = m_pIStiUSD->GetCapabilities(pDevCaps);
        }
        __except(EXCEPTION_EXECUTE_HANDLER ) {
            DBG_WRN(("CDrvWrap::STI_GetCapabilities, exception in driver calling IStiUSD::GetCapabilities"));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::STI_GetCapabilities, attempting to call IStiUSD::GetCapabilities when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::STI_GetStatus(
        STI_DEVICE_STATUS   *pDevStatus)
{
    HRESULT hr = WIA_ERROR_OFFLINE;

    if (PrepForUse(FALSE)) {
        //
        // Get status from USD object
        //
        __try {
            hr = m_pIStiUSD->GetStatus(pDevStatus);
        }
        __except(EXCEPTION_EXECUTE_HANDLER ) {
            DBG_WRN(("CDrvWrap::STI_GetStatus, exception in driver calling IStiUSD::GetStatus"));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::STI_GetStatus, attempting to call IStiUSD::GetStatus when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::STI_GetNotificationData(
      STINOTIFY           *lpNotify)
{
    HRESULT hr = WIA_ERROR_OFFLINE;

    if (PrepForUse(FALSE)) {
        //
        // Get event data from USD object
        //
        __try {
            hr = m_pIStiUSD->GetNotificationData(lpNotify);
        }
        __except(EXCEPTION_EXECUTE_HANDLER ) {
            DBG_WRN(("CDrvWrap::STI_GetNotificationData, exception in driver calling IStiUSD::GetNotificationData"));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::STI_GetNotificationData, attempting to call IStiUSD::GetNotificationData when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::STI_SetNotificationHandle(
        HANDLE              hEvent)
{
    HRESULT hr = WIA_ERROR_OFFLINE;

    if (PrepForUse(FALSE)) {
        //
        // Set notification handle for USD object
        //
        __try {
            hr = m_pIStiUSD->SetNotificationHandle(hEvent);
        }
        __except(EXCEPTION_EXECUTE_HANDLER ) {
            DBG_WRN(("CDrvWrap::STI_SetNotificationHandle, exception in driver calling IStiUSD::SetNotificationHandle"));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::STI_SetNotificationHandle, attempting to call IStiUSD::SetNotificationHandle when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::STI_DeviceReset()
{
    HRESULT hr = WIA_ERROR_OFFLINE;

    if (PrepForUse(FALSE)) {
        //
        // Get status from USD object
        //
        __try {
            hr = m_pIStiUSD->DeviceReset();
            if (FAILED(hr)) {
                DBG_ERR(("CDrvWrap::STI_DeviceReset, driver returned failure with hr = 0x%08X", hr));
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::STI_DeviceReset, exception in driver calling IStiUSD::DeviceReset"));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::STI_DeviceReset, attempting to call IStiUSD::DeviceReset when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::STI_Diagnostic(
        STI_DIAG    *pDiag)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(FALSE)) {
        __try {
            hr = m_pIStiUSD->Diagnostic(pDiag);
            if (FAILED(hr)) {
                DBG_ERR(("CDrvWrap::STI_Diagnostic, driver returned failure with hr = 0x%08X", hr));
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::STI_Diagnostic, exception in Diagnostic: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::STI_Diagnostic, attempting to call IStiUSD::Diagnostic when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::STI_LockDevice()
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(FALSE)) {
        __try {
            hr = m_pIStiUSD->LockDevice();
            if (FAILED(hr)) {
                DBG_ERR(("CDrvWrap::STI_LockDevice, driver returned failure with hr = 0x%08X", hr));
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::STI_LockDevice, exception in LockDevice: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::STI_LockDevice, attempting to call IStiUSD::LockDevice when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::STI_UnLockDevice()
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(FALSE)) {
        __try {
            hr = m_pIStiUSD->UnLockDevice();
            if (FAILED(hr)) {
                DBG_ERR(("CDrvWrap::STI_UnLockDevice, driver returned failure with hr = 0x%08X", hr));
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::STI_UnLockDevice, exception in UnLockDevice: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::STI_UnlockDevice, attempting to call IStiUSD::UnLockDevice when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::STI_Escape(
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID                  lpInData,
    DWORD                   cbInDataSize,
    LPVOID                  pOutData,
    DWORD                   dwOutDataSize,
    LPDWORD                 pdwActualData)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(FALSE)) {
        __try {
            hr = m_pIStiUSD->Escape(EscapeFunction,
                                    lpInData,
                                    cbInDataSize,
                                    pOutData,
                                    dwOutDataSize,
                                    pdwActualData);
            if (FAILED(hr)) {
                DBG_ERR(("CDrvWrap::STI_Escape, driver returned failure with hr = 0x%08X", hr));
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::STI_Escape, exception in Escape: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::STI_Escape, attempting to call IStiUSD::Escape when driver is not loaded"));
    }

    return hr;
}

//
//  End of IStiUSD wrapper methods
//
/*****************************************************************************/

/*****************************************************************************/
//
//  Wrapper methods for IWiaMiniDrv.  All mini-driver wrapper methods call PrepForUse(...) to make sure
//  the driver is loaded before using.
//

HRESULT CDrvWrap::WIA_drvInitializeWia(
    BYTE        *pWiasContext,
    LONG        lFlags,
    BSTR        bstrDeviceID,
    BSTR        bstrRootFullItemName,
    IUnknown    *pStiDevice,
    IUnknown    *pIUnknownOuter,
    IWiaDrvItem **ppIDrvItemRoot,
    IUnknown    **ppIUnknownInner,
    LONG        *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvInitializeWia(pWiasContext,
                lFlags,
                bstrDeviceID,
                bstrRootFullItemName,
                pStiDevice,
                pIUnknownOuter,
                ppIDrvItemRoot,
                ppIUnknownInner,
                plDevErrVal);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvInitializeWia, Error calling driver: drvInitializeWia failed with hr = 0x%08X", hr));
                ReportMiniDriverError(*plDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::WIA_drvInitializeWia, exception in drvInitializeWia: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvInitializeWia, attempting to call IWiaMiniDrv::drvInitializeWia when driver is not loaded"));
    }
    if (SUCCEEDED(hr)) {
        //  TBD:  Take a sync primitive?
        InterlockedIncrement(&m_lWiaTreeCount);
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvGetDeviceErrorStr(
    LONG     lFlags,
    LONG     lDevErr,
    LPOLESTR *ppszDevErrStr,
    LONG     *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvGetDeviceErrorStr(lFlags,
                lDevErr,
                ppszDevErrStr,
                plDevErrVal);
            if (FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvGetDeviceErrorStr, call to driver's drvGetDeviceErrorStr failed (0x%08X)", hr));
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::WIA_drvGetDeviceErrorStr, attempting to call IWiaMiniDrv::drvGetDeviceErrorStr when driver is not loaded"));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvDeviceCommand(
    BYTE        *pWiasContext,
    LONG        lFlags,
    const GUID  *plCommand,
    IWiaDrvItem **ppWiaDrvItem,
    LONG        *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvDeviceCommand(pWiasContext, lFlags, plCommand, ppWiaDrvItem, plDevErrVal);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvDeviceCommand, Error calling driver: drvDeviceCommand failed with hr = 0x%08X", hr));
                ReportMiniDriverError(*plDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::WIA_drvDeviceCommand, exception in drvDeviceCommand: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }

    } else {
        DBG_WRN(("CDrvWrap::WIA_drvDeviceCommand, attempting to call IWiaMiniDrv::drvDeviceCommand when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvAcquireItemData(
    BYTE                      *pWiasContext,
    LONG                      lFlags,
    PMINIDRV_TRANSFER_CONTEXT pmdtc,
    LONG                      *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvAcquireItemData(pWiasContext, lFlags, pmdtc, plDevErrVal);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvAcquireItemData, Error calling driver : drvAcquireItemData failed with hr = 0x%08X", hr));
                ReportMiniDriverError(*plDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::WIA_drvAcquireItemData, exception in drvAcquireItemData: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvAcquireItemData, attempting to call IWiaMiniDrv::drvAcquireItemData when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvInitItemProperties(
    BYTE *pWiasContext,
    LONG lFlags,
    LONG *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvInitItemProperties(pWiasContext,lFlags, plDevErrVal);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvInitItemProperties, Error calling driver: drvInitItemProperties failed with hr = 0x%08X", hr));
                ReportMiniDriverError(*plDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::WIA_drvInitItemProperties, exception in drvInitItemProperties: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvInitItemProperties, attempting to call IWiaMiniDrv::drvInitItemProperties when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvValidateItemProperties(
    BYTE           *pWiasContext,
    LONG           lFlags,
    ULONG          nPropSpec,
    const PROPSPEC *pPropSpec,
    LONG           *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvValidateItemProperties(pWiasContext,
                                                           lFlags,
                                                           nPropSpec,
                                                           pPropSpec,
                                                           plDevErrVal);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvValidateItemProperties, Error calling driver: drvValidateItemProperties with hr = 0x%08X (This is normal if the app wrote an invalid value)", hr));
                ReportMiniDriverError(*plDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::WIA_drvValidateItemProperties, exception in drvValidateItemProperties: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvValidateItemProperties, attempting to call IWiaMiniDrv::drvValidateItemProperties when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvWriteItemProperties(
    BYTE                      *pWiasContext,
    LONG                      lFlags,
    PMINIDRV_TRANSFER_CONTEXT pmdtc,
    LONG                      *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvWriteItemProperties(pWiasContext,
                                                        lFlags,
                                                        pmdtc,
                                                        plDevErrVal);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvWriteItemProperties, error calling driver: drvWriteItemProperties failed with hr = 0x%08X", hr));
                ReportMiniDriverError(*plDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::WIA_drvWriteItemProperties, exception in drvWriteItemProperties: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvWriteItemProperties, attempting to call IWiaMiniDrv::drvWriteItemProperties when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvReadItemProperties(
    BYTE           *pWiasContext,
    LONG           lFlags,
    ULONG          nPropSpec,
    const PROPSPEC *pPropSpec,
    LONG           *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvReadItemProperties(pWiasContext,
                                                       lFlags,
                                                       nPropSpec,
                                                       pPropSpec,
                                                       plDevErrVal);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvReadItemProperties, Error calling driver: drvReadItemProperties failed with hr = 0x%08X", hr));
                ReportMiniDriverError(*plDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::WIA_drvReadItemProperties, exception in drvReadItemProperties: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvReadItemProperties, attempting to call IWiaMiniDrv::drvReadItemProperties when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvLockWiaDevice(
    BYTE *pWiasContext,
    LONG lFlags,
    LONG *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {

        //
        //  We request a lock on the device here.  This is to ensure we don't
        //  make calls down to the driver, which then turns around and
        //  makes a call to us e.g. via the Fake Sti Device.
        //  We no longer require driver to use the Fake Sti Device for
        //  mutally exclusive locking - this way we do it automatically.
        //
        hr = g_pStiLockMgr->RequestLock(((CWiaItem*) pWiasContext)->m_pActiveDevice, WIA_LOCK_WAIT_TIME);
        if (SUCCEEDED(hr)) {
            __try {
                hr = m_pIWiaMiniDrv->drvLockWiaDevice(pWiasContext, lFlags, plDevErrVal);

                if(FAILED(hr)) {
                    DBG_ERR(("CDrvWrap::WIA_drvLockWiaDevice, driver returned failure with hr = 0x%08X", hr));
                    ReportMiniDriverError(*plDevErrVal, NULL);
                }
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                DBG_ERR(("CDrvWrap::WIA_drvLockWiaDevice, exception in drvLockWiaDevice: 0x%X", GetExceptionCode()));
                hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
            }
        } else {
            DBG_WRN(("CDrvWrap::WIA_drvLockWiaDevice, could not get device lock"));
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvLockWiaDevice, attempting to call IWiaMiniDrv::drvLockWiaDevice when driver is not loaded"));
    }
    return hr;
}

HRESULT CDrvWrap::WIA_drvUnLockWiaDevice(
    BYTE *pWiasContext,
    LONG lFlags,
    LONG *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    //
    //  Note that we only want to call if the driver is loaded, therefore we don't
    //  call PrepForUse.  PrepForUse will attempt to load the driver if it wasn't
    //  already loaded.
    //

    if (IsDriverLoaded()) {

        //
        //  Request to unlock the device for mutally exclusive access.
        //  Ignore the return, we must still call the drvUnlockWiaDevice entry 
        //  point.
        //
        __try {
            hr = m_pIWiaMiniDrv->drvUnLockWiaDevice(pWiasContext, lFlags, plDevErrVal);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvUnLockWiaDevice, driver returned failure with hr = 0x%08X", hr));
                ReportMiniDriverError(*plDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::WIA_drvUnLockWiaDevice, exception in drvUnLockWiaDevice: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
        hr = g_pStiLockMgr->RequestUnlock(((CWiaItem*) pWiasContext)->m_pActiveDevice);

        if (SUCCEEDED(hr) && m_bUnload) {
            UnLoadDriver();
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvUnLockWiaDevice, attempting to call IWiaMiniDrv::drvUnLockWiaDevice when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvAnalyzeItem(
    BYTE *pWiasContext,
    LONG lFlags,
    LONG *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvAnalyzeItem(pWiasContext, lFlags, plDevErrVal);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvAnalyzeItem, Error calling driver: drvAnalyzeItem failed with hr = 0x%08X", hr));
                ReportMiniDriverError(*plDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::WIA_drvAnalyzeItem, exception in drvAnalyzeItem: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvAnalyzeItem, attempting to call IWiaMiniDrv::drvAnalyzeItem when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvDeleteItem(
    BYTE *pWiasContext,
    LONG lFlags,
    LONG *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvDeleteItem(pWiasContext, lFlags, plDevErrVal);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvDeleteItem, Error calling driver: drvDeleteItem failed with hr = 0x%08X", hr));
                ReportMiniDriverError(*plDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR( ("CDrvWrap::WIA_drvDeleteItem, exception in drvDeleteItem: %0xX", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvDeleteItem, attempting to call IWiaMiniDrv::drvDeleteItem when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvFreeDrvItemContext(
    LONG lFlags,
    BYTE *pSpecContext,
    LONG *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvFreeDrvItemContext(lFlags, pSpecContext, plDevErrVal);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvFreeDrvItemContext, Error calling driver: drvFreeDrvItemContext failed with hr = 0x%08X", hr));
                ReportMiniDriverError(*plDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR( ("CDrvWrap::WIA_drvFreeDrvItemContext, exception in drvFreeDrvItemContext: %0xX", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvFreeDrvItemContext, attempting to call IWiaMiniDrv::drvFreeDrvItemContext when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvGetCapabilities(
    BYTE            *pWiasContext,
    LONG            ulFlags,
    LONG            *pcelt,
    WIA_DEV_CAP_DRV **ppCapabilities,
    LONG            *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvGetCapabilities(pWiasContext, ulFlags, pcelt, ppCapabilities, plDevErrVal);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvGetCapabilities, driver returned failure with hr = 0x%08X", hr));
                ReportMiniDriverError(*plDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::WIA_drvGetCapabilities, exception in drvGetCapabilities: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvGetCapabilities, attempting to call IWiaMiniDrv::drvGetCapabilities when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvGetWiaFormatInfo(
    BYTE            *pWiasContext,
    LONG            lFlags,
    LONG            *pcelt,
    WIA_FORMAT_INFO **ppwfi,
    LONG            *plDevErrVal)
{
    HRESULT hr          = WIA_ERROR_OFFLINE;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvGetWiaFormatInfo(pWiasContext,
                                                     lFlags,
                                                     pcelt,
                                                     ppwfi,
                                                     plDevErrVal);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvGetWiaFormatInfo, Error calling driver : drvGetWiaFormatInfo failed with hr = 0x%08X", hr));
                ReportMiniDriverError(*plDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR( ("CDrvWrap::WIA_drvGetWiaFormatInfo, exception in drvGetWiaFormatInfo: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvGetWiaFormatInfo, attempting to call IWiaMiniDrv::drvGetWiaFormatInfo when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvNotifyPnpEvent(
    const GUID *pEventGUID,
    BSTR       bstrDeviceID,
    ULONG      ulReserved)
{
    HRESULT hr              = WIA_ERROR_OFFLINE;
    LONG    lDevErrVal      = 0;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvNotifyPnpEvent(pEventGUID, bstrDeviceID, ulReserved);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvNotifyPnpEvent, driver returned failure with hr = 0x%08X", hr));
                ReportMiniDriverError(lDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::WIA_drvNotifyPnpEvent, exception in drvNotifyPnpEvent: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvNotifyPnpEvent, attempting to call IWiaMiniDrv::drvNotifyPnpEvent when driver is not loaded"));
    }

    return hr;
}

HRESULT CDrvWrap::WIA_drvUnInitializeWia(
    BYTE *pWiasContext)
{
    HRESULT hr              = WIA_ERROR_OFFLINE;
    LONG    lDevErrVal      = 0;

    if (PrepForUse(TRUE)) {
        __try {
            hr = m_pIWiaMiniDrv->drvUnInitializeWia(pWiasContext);

            if(FAILED(hr)) {
                DBG_ERR(("CDrvWrap::WIA_drvUnInitializeWia, Error calling driver: drvUnInitializeWia failed with hr = 0x%08X", hr));
                ReportMiniDriverError(lDevErrVal, NULL);
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("CDrvWrap::WIA_drvUnInitializeWia, exception in drvUnInitializeWia: 0x%X", GetExceptionCode()));
            hr = WIA_ERROR_EXCEPTION_IN_DRIVER;
        }
    } else {
        DBG_WRN(("CDrvWrap::WIA_drvUnInitializeWia, attempting to call IWiaMiniDrv::drvUnInitializeWia when driver is not loaded"));
    }
    if (SUCCEEDED(hr)) {

        //  TBD:  Take a sync primitive?
        if(InterlockedDecrement(&m_lWiaTreeCount) == 0) {
            //  No item trees left.
            //  Note that we can't unload now, since the device still needs to
            //  be unlocked, therefore simply mark it to be unloaded by
            //  WIA_drvUnlockWiaDevice.
            if (m_bJITLoading) {
                m_bUnload = TRUE;
            }
        }
    }

    return hr;
}
//
//  End of wrapper methods for IWiaMiniDrv
//
/*****************************************************************************/

//
//  Private methods
//

/**************************************************************************\
* CDrvWrap::CreateDeviceControl
*
*   Creates a IStiDeviceControl object to hand down to the driver during
*   its initialization.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   Status
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
HRESULT CDrvWrap::CreateDeviceControl()
{
    HRESULT hr = E_FAIL;

    if (m_pDeviceInfo) {

        DWORD   dwBusType           = 0;
        DWORD   dwControlTypeType   = 0;

        //
        //  Bus type is retrieved from dwHardwareConfiguration in the DeviceInformation struct
        //  Use this to determine ControlTypeType
        //

        dwBusType = m_pDeviceInfo->dwHardwareConfiguration;

        //
        //  Convert STI bit flags for device mode into HEL_ bit mask
        //

        if (dwBusType & (STI_HW_CONFIG_USB | STI_HW_CONFIG_SCSI)) {
            dwControlTypeType = HEL_DEVICE_TYPE_WDM;
        }
        else if (dwBusType & STI_HW_CONFIG_PARALLEL) {
            dwControlTypeType = HEL_DEVICE_TYPE_PARALLEL;
        }
        else if (dwBusType & STI_HW_CONFIG_SERIAL) {
            dwControlTypeType = HEL_DEVICE_TYPE_SERIAL;
        }
        else {
            DBG_WRN(("CDrvWrap::CreateDeviceControl, Cannot determine device control type, resorting to WDM"));
            dwControlTypeType = HEL_DEVICE_TYPE_WDM;
        }

        hr = NewDeviceControl(dwControlTypeType,
                              (STI_DEVICE_CREATE_STATUS | STI_DEVICE_CREATE_FOR_MONITOR),
                              m_pDeviceInfo->wszPortName,
                              0,
                              &m_pIStiDeviceControl);
        if (FAILED(hr)) {
            m_pIStiDeviceControl = NULL;
            DBG_WRN(("CDrvWrap::CreateDeviceControl, failed to create new device control object"));
        }
    } else {
        DBG_WRN(("CDrvWrap::CreateDeviceControl, can't create IStiDeviceControl with NULL device information"));
    }

    return hr;
}

/**************************************************************************\
* CDrvWrap::InternalClear
*
*   This will unload the driver, if it is loaded, and clear member
*   variables associated with the loaded driver state.
*
* Arguments:
*
*   InternalClear
*
* Return Value:
*
*   Status
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
HRESULT CDrvWrap::InternalClear()
{
    HRESULT         hr = S_OK;

    if (IsDriverLoaded()) {
        hr = UnLoadDriver();
        if (FAILED(hr)) {
            DBG_ERR(("CDrvWrap::InternalClear, Error unloading driver"));
        }
    }
    m_hDriverDLL            = NULL;
    m_pUsdIUnknown          = NULL;
    m_pIStiUSD              = NULL;
    m_pIWiaMiniDrv          = NULL;
    m_pIStiDeviceControl    = NULL;
    m_bJITLoading           = FALSE;
    m_lWiaTreeCount         = 0;
    m_bPreparedForUse       = FALSE;
    m_bUnload               = FALSE;

    return hr;
}

/**************************************************************************\
* CDrvWrap::::ReportMiniDriverError
*
*   Report a mini driver error.  The caller is responsible for
*   locking/unlocking the device.  In most cases, the driver is already
*   locked when ReportMiniDriverError is called, so there is no need to lock
*   is again here.
*
* Arguments:
*
*   lDevErr     - Error value returned from the mini driver.
*   pszWhat     - What the class driver was doing when the error ocured.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/20/1998 Original Version
*
\**************************************************************************/

HRESULT CDrvWrap::ReportMiniDriverError(
   LONG     lDevErr,
   LPOLESTR pszWhat)
{
    DBG_FN(CDrvWrap::ReportMiniDriverError);
    HRESULT hr = S_OK;
    LONG    lFlags = 0;
    LONG    lDevErrVal;

    if (lDevErr) {
        LPOLESTR pszErr = NULL;

        WIA_drvGetDeviceErrorStr(lFlags, lDevErr, &pszErr, &lDevErrVal);

        _try {
            if (FAILED(hr)) {
                pszErr = NULL;
            }

            if (pszWhat) {
                DBG_ERR(("Device error during %ws", pszWhat));
            }

            if (pszErr) {
                DBG_ERR(("  %ws", pszErr));
            }
        }
        _finally {
        };
    }
    else {
        hr = S_FALSE;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\fstidev.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       fstidev.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        7 Dec, 1999
*
*  DESCRIPTION:
*   Implmentation for fake StiDevice which gets handed down to WIA
*   driver.
*
*******************************************************************************/
#include "precomp.h"

#include "stiexe.h"
#include "device.h"
#include "assert.h"
#include "wiapriv.h"
#include "lockmgr.h"
#include "fstidev.h"

//
//  Default constructor
//

FakeStiDevice::FakeStiDevice() 
{
    m_cRef      = 0;
    m_pDevice   = NULL;
}
                                               
//
//  Constructor which takes in the device name and returns a pointer to this
//  IStiDevice interface
//

FakeStiDevice::FakeStiDevice(BSTR bstrDeviceName, IStiDevice **ppStiDevice)
{
    if (SUCCEEDED(Init(bstrDeviceName))) {
        QueryInterface(IID_IStiDevice, (VOID**)ppStiDevice);
    } else {
        *ppStiDevice = NULL;
    }    
}

//
//  Destructor
//

FakeStiDevice::~FakeStiDevice()
{
    m_cRef = 0;
}

//
//  Initialization methods
//

HRESULT FakeStiDevice::Init(ACTIVE_DEVICE  *pDevice)
{
    m_pDevice = pDevice;

    if (pDevice) {
        return S_OK;
    } else {
        return E_POINTER;
    }
}

HRESULT FakeStiDevice::Init(BSTR bstrDeviceName)
{
    HRESULT         hr = S_OK;

    /*  This is all dead code.  The Fake STI Device object implementation
        is no longer needed for ensuring mutually exclusive locking - it is
        now done automatically by the wrapper.
    ACTIVE_DEVICE   *pDevice;

USES_CONVERSION;
    pDevice = g_pDevMan->IsInList(DEV_MAN_IN_LIST_DEV_ID, bstrDeviceName);
    if(pDevice) {
        m_pDevice = pDevice;

        //
        //  We don't need to maintain a ref count on pDevice,
        //  since we're only used while the ACTIVE_DEVICE
        //  lives.
        //

        pDevice->Release();
    } else {
        hr = E_FAIL;
    }
    */
    return hr;
}

//
//  IUnknown methods.  Note:  This object cannot be delegated and
//  does not use aggregation.
//

HRESULT _stdcall FakeStiDevice::QueryInterface(const IID& iid, void** ppv)
{
    if (ppv != NULL) {
        *ppv = NULL;
    }

    if (iid == IID_IUnknown) {
        *ppv = (IUnknown*) this;
    } else if (iid == IID_IStiDevice) {
        *ppv = (IStiDevice*) this;
    } else {
        return E_NOINTERFACE;
    }
    AddRef();

    return S_OK;
}

ULONG   _stdcall FakeStiDevice::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

ULONG   _stdcall FakeStiDevice::Release(void)
{
    LONG    cRef = m_cRef;

    InterlockedDecrement(&m_cRef);

    return cRef;
}

//
//  IStiDevice Methods.  The only methods implemented are:
//
//      LockDevice
//      UnLockDevice
//
//  All other methods return E_NOTIMPL
//

HRESULT _stdcall FakeStiDevice::LockDevice( DWORD dwTimeOut)
{
    HRESULT hr = S_OK;

    /*  This is all dead code.  The Fake STI Device object implementation
        is no longer needed for ensuring mutually exclusive locking - it is
        now done automatically by the wrapper.
    if (m_pDevice) {

        //
        //  AddRef the ACTIVE_DEVICE so it doesn't attempt to
        //  unload us while we're in use.
        //

        m_pDevice->AddRef();
        hr = g_pStiLockMgr->RequestLock(m_pDevice, 60000);
        if (FAILED(hr)) {
            m_pDevice->Release();
        }
    }
   */
    return hr;
}

HRESULT _stdcall FakeStiDevice::UnLockDevice( )
{
    HRESULT hr = S_OK/*E_FAIL*/;

    /*  This is all dead code.  The Fake STI Device object implementation
        is no longer needed for ensuring mutually exclusive locking - it is
        now done automatically by the wrapper.
    if (m_pDevice) {
        hr = g_pStiLockMgr->RequestUnlock(m_pDevice);
        m_pDevice->Release();
    }
    */
   
    return hr;
}

HRESULT _stdcall FakeStiDevice::Initialize(HINSTANCE hinst,LPCWSTR pwszDeviceName,DWORD dwVersion,DWORD  dwMode)
{
    return E_NOTIMPL;
}

HRESULT _stdcall FakeStiDevice::GetCapabilities( PSTI_DEV_CAPS pDevCaps)
{
    return E_NOTIMPL;
}

HRESULT _stdcall FakeStiDevice::GetStatus( PSTI_DEVICE_STATUS pDevStatus)
{
    return E_NOTIMPL;
}

HRESULT _stdcall FakeStiDevice::DeviceReset( )
{
    return E_NOTIMPL;
}

HRESULT _stdcall FakeStiDevice::Diagnostic( LPSTI_DIAG pBuffer)
{
    return E_NOTIMPL;
}

HRESULT _stdcall FakeStiDevice::Escape( STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData)
{
    return E_NOTIMPL;
}


HRESULT _stdcall FakeStiDevice::GetLastError( LPDWORD pdwLastDeviceError)
{
    return E_NOTIMPL;
}

HRESULT _stdcall FakeStiDevice::RawReadData( LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)
{
    return E_NOTIMPL;
}

HRESULT _stdcall FakeStiDevice::RawWriteData( LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)
{
    return E_NOTIMPL;
}

HRESULT _stdcall FakeStiDevice::RawReadCommand( LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)
{
    return E_NOTIMPL;
}

HRESULT _stdcall FakeStiDevice::RawWriteCommand( LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)
{
    return E_NOTIMPL;
}

HRESULT _stdcall FakeStiDevice::Subscribe( LPSTISUBSCRIBE lpSubsribe)
{
    return E_NOTIMPL;
}

HRESULT _stdcall FakeStiDevice::GetLastNotificationData(LPSTINOTIFY   lpNotify)
{
    return E_NOTIMPL;
}

HRESULT _stdcall FakeStiDevice::UnSubscribe( )
{
    return E_NOTIMPL;
}

HRESULT _stdcall FakeStiDevice::GetLastErrorInfo( STI_ERROR_INFO *pLastErrorInfo)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\fstidev.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       fstidev.h
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        7 Dec, 1999
*
*  DESCRIPTION:
*   Header for fake StiDevice implementation which gets handed down to WIA
*   driver.
*
*******************************************************************************/

class FakeStiDevice : public IStiDevice 
{
public:
    FakeStiDevice();
    FakeStiDevice(BSTR bstrDeviceName, IStiDevice **ppStiDevice);
    ~FakeStiDevice();
    HRESULT Init(ACTIVE_DEVICE  *pDevice);
    HRESULT Init(BSTR bstrDeviceName);


    /*** IUnknown methods ***/
    HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
    ULONG   _stdcall AddRef(void);
    ULONG   _stdcall Release(void);

    /*** IStiDevice methods ***/
    HRESULT _stdcall Initialize(HINSTANCE hinst,LPCWSTR pwszDeviceName,DWORD dwVersion,DWORD  dwMode);

    HRESULT _stdcall GetCapabilities( PSTI_DEV_CAPS pDevCaps);

    HRESULT _stdcall GetStatus( PSTI_DEVICE_STATUS pDevStatus);

    HRESULT _stdcall DeviceReset( );
    HRESULT _stdcall Diagnostic( LPSTI_DIAG pBuffer);

    HRESULT _stdcall Escape( STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData) ;

    HRESULT _stdcall GetLastError( LPDWORD pdwLastDeviceError);

    HRESULT _stdcall LockDevice( DWORD dwTimeOut);
    HRESULT _stdcall UnLockDevice( );

    HRESULT _stdcall RawReadData( LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped);
    HRESULT _stdcall RawWriteData( LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped);

    HRESULT _stdcall RawReadCommand( LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped);
    HRESULT _stdcall RawWriteCommand( LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped);

    HRESULT _stdcall Subscribe( LPSTISUBSCRIBE lpSubsribe);
    HRESULT _stdcall GetLastNotificationData(LPSTINOTIFY   lpNotify);
    HRESULT _stdcall UnSubscribe( );

    HRESULT _stdcall GetLastErrorInfo( STI_ERROR_INFO *pLastErrorInfo);

private:

    LONG            m_cRef;     // Ref count
    ACTIVE_DEVICE   *m_pDevice; // Pointer to ACTIVE_DEVICE node
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\extras.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       Extras.Cpp
*
*  DESCRIPTION:
*   Implementation of IWiaItemExtras methods
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"


HRESULT CWiaItem::GetExtendedErrorInfo(BSTR *bstrRet)
{
    HRESULT hr          = S_OK;
    WCHAR   *pDevErrStr = NULL;

    LONG    lDevErrVal = 0;

    if (bstrRet) {
        *bstrRet = NULL;

        //
        //  Call the driver to give us an error string
        //
        hr = m_pActiveDevice->m_DrvWrapper.WIA_drvGetDeviceErrorStr(
                                            0,
                                            m_lLastDevErrVal,
                                            &pDevErrStr,
                                            &lDevErrVal);
        //
        //  Overwrite the device error value with the new one.
        //
        m_lLastDevErrVal = lDevErrVal;
        if (SUCCEEDED(hr)) {

            //
            //  Make a BSTR out of the returned string
            //
            if (pDevErrStr) {
                *bstrRet = SysAllocString(pDevErrStr);
                if (!(*bstrRet)) {
                    DBG_ERR(("CWiaItem::GetExtendedErrorInfo, out of memory!"));
                    hr = E_OUTOFMEMORY;
                }

                //
                //  Free the returned string
                //
                CoTaskMemFree(pDevErrStr);
                pDevErrStr = NULL;
            } else {
                DBG_ERR(("CWiaItem::GetExtendedErrorInfo, Driver's drvGetDeviceErrorStr return success, but failed to return a string!"));
                hr = WIA_ERROR_INVALID_DRIVER_RESPONSE;
            }

        }
    } else {
        DBG_WRN(("CWiaItem::GetExtendedErrorInfo, NULL argument passed"));
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CWiaItem::Escape(
    DWORD                   EscapeFunction,
    LPBYTE                  lpInData,
    DWORD                   cbInDataSize,
    LPBYTE                  pOutData,
    DWORD                   dwOutDataSize,
    LPDWORD                 pdwActualData)
{
    DBG_FN(CWiaItem::Escape);
    HRESULT hr = E_UNEXPECTED;

    //
    //  Do some parameter validation.  This shouldn't be necessary since
    //  COM should have done it for us, but this is a paranoid check in
    //  case we call it internally somewhere (and so skip COM validation).
    //

    if (IsBadReadPtr(lpInData, cbInDataSize)) {
        DBG_WRN(("CWiaItem::Escape, Input buffer is a bad read pointer (could not read cbInDataSize bytes)"));
        return E_INVALIDARG;
    }
    if (IsBadWritePtr(pOutData, dwOutDataSize)) {
        DBG_WRN(("CWiaItem::Escape, Output buffer is a bad write pointer (cannot write dwOutDataSize bytes)"));
        return E_INVALIDARG;
    }

    //
    //  Everything OK so far, so make the Escape call
    //

    if (m_pActiveDevice) {
        LOCK_WIA_DEVICE _LWD(this, &hr);

        if(SUCCEEDED(hr)) {
            hr = m_pActiveDevice->m_DrvWrapper.STI_Escape(EscapeFunction,
                lpInData,
                cbInDataSize,
                pOutData,
                dwOutDataSize,
                pdwActualData);
        }
    }

    return hr;
}

HRESULT CWiaItem::CancelPendingIO()
{
    HRESULT hr = S_OK;

    //
    // Driver interface must be valid.
    //

    if (!m_pActiveDevice) {
        DBG_ERR(("CWiaItem::CancelPendingIO, bad mini driver interface"));
        return E_FAIL;
    }

    //
    //  Corresponding driver item must be valid.
    //

    hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::CancelPendingIO, ValidateWiaDrvItemAccess failed (0x%X)", hr));
        return hr;
    }

    //
    // no need to take any locks -- this method should be fully
    // asynchronous.
    //

    hr = m_pActiveDevice->m_DrvWrapper.WIA_drvNotifyPnpEvent(&WIA_EVENT_CANCEL_IO, NULL, 0);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::CancelPendingIO, drvNotifyPnpEvent failed (0x%X)", hr));
        return hr;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\handler.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       handler.h
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   Declarations and definitions for the WIA messsage handler class.
*   This class gets called from the Service control function on PnP and Power 
*   event notifications, and informas the device manager to take the appropriate 
*   action.
*
*******************************************************************************/
#pragma once

class CMsgHandler {
public:
    HRESULT HandlePnPEvent(
        DWORD   dwEventType,
        PVOID   pEventData);

    DWORD HandlePowerEvent(
        DWORD   dwEventType,
        PVOID   pEventData);

    HRESULT HandleCustomEvent(
        DWORD   dwEventType);

    HRESULT Initialize();

private:

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\globals.cpp ===
/*++


Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    GLOBALS.CPP

Abstract:

    Placeholder for global data definitions and routines to
    initialize/save global information

Author:

    Vlad  Sadovsky  (vlads)     12-20-96

Revision History:



--*/
#include "precomp.h"

//
// Headers
//

#define DEFINE_GLOBAL_VARIABLES
#define DEFINE_WIA_PROPID_TO_NAME
#define WIA_DECLARE_DEVINFO_PROP_ARRAY
#define WIA_DECLARE_MANAGED_PROPS

#include    "stiexe.h"

#include <statreg.h>
#include <atlconv.h>

#include <atlimpl.cpp>
#include <statreg.cpp>


#include <wiadef.h>

//#include <atlconv.cpp>

#include <ks.h>
#include <ksmedia.h>

//
// Array of device interface IDs we listen on.
//
const GUID  g_pguidDeviceNotificationsGuidArray[NOTIFICATION_GUIDS_NUM]  =
{
    STATIC_KSCATEGORY_VIDEO,
    STATIC_PINNAME_VIDEO_STILL,
    STATIC_KSCATEGORY_CAPTURE,
    STATIC_GUID_NULL
};

HDEVNOTIFY  g_phDeviceNotificationsSinkArray[NOTIFICATION_GUIDS_NUM] ;

WCHAR g_szWEDate[MAX_PATH];
WCHAR g_szWETime[MAX_PATH];
WCHAR g_szWEPageCount[MAX_PATH];
WCHAR g_szWEDay[10];
WCHAR g_szWEMonth[10];                                                  
WCHAR g_szWEYear[10];                                        


WIAS_ENDORSER_VALUE  g_pwevDefault[] = {WIA_ENDORSER_TOK_DATE, g_szWEDate,
                                        WIA_ENDORSER_TOK_TIME, g_szWETime,
                                        WIA_ENDORSER_TOK_PAGE_COUNT, g_szWEPageCount,
                                        WIA_ENDORSER_TOK_DAY, g_szWEDay,
                                        WIA_ENDORSER_TOK_MONTH, g_szWEMonth,
                                        WIA_ENDORSER_TOK_YEAR, g_szWEYear,
                                        NULL, NULL};

//
//  Static variables used for WIA Managed properties
//

PROPID s_piItemNameType[] = {
    WIA_IPA_ITEM_NAME,
    WIA_IPA_FULL_ITEM_NAME,
    WIA_IPA_ITEM_FLAGS,
    WIA_IPA_ICM_PROFILE_NAME,
};

LPOLESTR s_pszItemNameType[] = {
    WIA_IPA_ITEM_NAME_STR,
    WIA_IPA_FULL_ITEM_NAME_STR,
    WIA_IPA_ITEM_FLAGS_STR,
    WIA_IPA_ICM_PROFILE_NAME_STR,
};
PROPSPEC s_psItemNameType[] = {
   {PRSPEC_PROPID, WIA_IPA_ITEM_NAME},
   {PRSPEC_PROPID, WIA_IPA_FULL_ITEM_NAME},
   {PRSPEC_PROPID, WIA_IPA_ITEM_FLAGS},
   {PRSPEC_PROPID, WIA_IPA_ICM_PROFILE_NAME}
};

//
// Default DCOM AccessPermission for WIA Device Manager
//
//  The string is in SDDL format.
//  NOTE:  For COM objects, CC which is "Create Child" permission, is used to
//  denote access to that object i.e. if CC is in the rights field, then that
//  user/group may instantiate the COM object.
//

WCHAR   wszDefaultDaclForDCOMAccessPermission[] = 
            L"O:BAG:BA"             //  Owner is built-in admins, as is Group
            L"D:(A;;CC;;;BA)"     //  Built-in Admins have Generic All and Object Access rights
              L"(A;;CC;;;SY)"     //  System has Generic All and Object Access rights
              L"(A;;CC;;;IU)";       //  Interactive User has Object Access rights.
           
//
// Code section
//

DWORD
InitGlobalConfigFromReg(VOID)
/*++
  Loads the global configuration parameters from registry and performs start-up checks

  Returns:
    Win32 error code. NO_ERROR on success

--*/
{
    DWORD   dwError = NO_ERROR;

    DWORD   dwMask = -1;

    RegEntry    re(REGSTR_PATH_STICONTROL,HKEY_LOCAL_MACHINE);

    g_fUIPermitted = re.GetNumber(REGSTR_VAL_DEBUG_STIMONUI,0);

#if 0   
#ifdef DEBUG
    dwMask         = re.GetNumber(REGVAL_STR_STIMON_DEBUGMASK,(DWORD) (DM_ERROR | DM_ASSERT));

    StiSetDebugMask(dwMask & ~DM_LOG_FILE);
    StiSetDebugParameters(TEXT("STISVC"),TEXT(""));
#endif
#endif  

    //
    // Initialize list of non Image device interfaces we will listen on
    // This is done to allow STI service data structures to be refreshed when
    // device events occur and we don't subscribe to notifications on StillImage
    // interface, exposed by WDM driver ( like video or storage).
    //

    for (UINT uiIndex = 0;uiIndex < NOTIFICATION_GUIDS_NUM; uiIndex++)
    {
        g_phDeviceNotificationsSinkArray[uiIndex] = NULL;
    }

    return dwError;

} // InitGlobalConfigFromReg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\handler.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       handler.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   Declarations and definitions for the WIA messsage handler class.
*   This class gets called from the Service control function on PnP and Power 
*   event notifications, and informas the device manager to take the appropriate 
*   action.
*
*******************************************************************************/

#include "precomp.h"
#include "stiexe.h"

HRESULT CMsgHandler::HandlePnPEvent(
    DWORD   dwEventType,
    PVOID   pEventData)
{
    HRESULT                 hr              = S_OK;
    PDEV_BROADCAST_HDR      pDevHdr         = (PDEV_BROADCAST_HDR)pEventData;
    ACTIVE_DEVICE           *pActiveDevice  = NULL;
    DEV_BROADCAST_HEADER    *psDevBroadcast = NULL;
    DEVICE_BROADCAST_INFO   *pdbiDevice     = NULL;
    BOOL                    bFound          = FALSE;

USES_CONVERSION;

    DBG_TRC(("CMsgHandler::HandlePnPEvent, dwEventType = 0x%08X", dwEventType));
    DBG_WRN(("==> CMsgHandler::HandlePnPEvent"));
    //
    // Trace that we are here. For all messages, not intended for StillImage devices , we should refresh
    // device list if we are running on WIndows NT and registered for device interfaces other than StillImage
    //

    PDEV_BROADCAST_DEVNODE              pDevNode      = (PDEV_BROADCAST_DEVNODE)pDevHdr;
    PDEV_BROADCAST_DEVICEINTERFACE      pDevInterface = (PDEV_BROADCAST_DEVICEINTERFACE)pDevHdr;

    switch (dwEventType) {
        case DBT_DEVICEREMOVECOMPLETE:
        case DBT_DEVICEQUERYREMOVE:
        case DBT_DEVICEREMOVEPENDING:
            DBG_TRC(("CMsgHandler::HandlePnPEvent, "
                     "DBT_DEVICEQUERYREMOVE | DBT_DEVICEREMOVEPENDING | DBT_DEVICEREMOVECOMPLETE, "
                     "dwEventType = %lu", dwEventType));

            if (IsStillImagePnPMessage(pDevHdr)) {

                //
                // Get device name and store along with the broadacast structure
                //

                pdbiDevice = new DEVICE_BROADCAST_INFO;
                if (!pdbiDevice) {
                    DBG_WRN(("CMsgHandler::HandlePnPEvent, out of memory"));
                    return E_OUTOFMEMORY;
                }

                //
                // Fill in information we have
                //
                pdbiDevice->m_uiDeviceChangeMessage = dwEventType;
                pdbiDevice->m_strBroadcastedName.CopyString(pDevInterface->dbcc_name) ;
                pdbiDevice->m_dwDevNode             = pDevNode->dbcd_devnode;

                //
                // Try to find our internal device name for this device if it exists in
                // our internal set.
                //
                bFound = GetDeviceNameFromDevBroadcast((DEV_BROADCAST_HEADER *)pDevHdr,pdbiDevice);
                DBG_WRN(("==> GetDeviceNameFromDevBroadcast returned DeviceID (%ws)", (WCHAR*)(LPCWSTR)pdbiDevice->m_strDeviceName));
                if (bFound) {
                    //
                    //  Mark that this device has been removed and throw disconnect event.
                    //
                    hr = g_pDevMan->ProcessDeviceRemoval((WCHAR*)(LPCWSTR)pdbiDevice->m_strDeviceName);
                }
                else {
                    DBG_TRC(("CMsgHandler::HandlePnPEvent, - failed to get device name from broadcast"));
                }
            } else {
                //
                //  Not exactly one of ours, but we are registered for it, so re-enumerate
                //

                g_pDevMan->ReEnumerateDevices(DEV_MAN_GEN_EVENTS);
            }
            break;

        case DBT_DEVICEARRIVAL:

            DBG_TRC(("CMsgHandler::HandlePnPEvent - DBT_DEVICEARRIVAL"));

            //
            //  Device has arrived (not installed).  We simply find out which of
            //  our devices has changed state.
            //
            hr = g_pDevMan->ProcessDeviceArrival();
            if (FAILED(hr)) {
                DBG_WRN(("::CMsgHandler::HandlePnPEvent, unable to enumerate devices"));
            }
            break;

        default:
            DBG_TRC(("::CMsgHandler::HandlePnPEvent, Default case"));
            break;
    }

    //
    //  Cleanup
    //
    if (pdbiDevice) {
        delete pdbiDevice;
    }

    return hr;
}

DWORD CMsgHandler::HandlePowerEvent(
    DWORD   dwEventType,
    PVOID   pEventData)
{
    DWORD   dwRet = NO_ERROR;
    UINT    uiTraceMessage = 0;

#ifdef DEBUG
static LPCTSTR pszPwrEventNames[] = {
    TEXT("PBT_APMQUERYSUSPEND"),             // 0x0000
    TEXT("PBT_APMQUERYSTANDBY"),             // 0x0001
    TEXT("PBT_APMQUERYSUSPENDFAILED"),       // 0x0002
    TEXT("PBT_APMQUERYSTANDBYFAILED"),       // 0x0003
    TEXT("PBT_APMSUSPEND"),                  // 0x0004
    TEXT("PBT_APMSTANDBY"),                  // 0x0005
    TEXT("PBT_APMRESUMECRITICAL"),           // 0x0006
    TEXT("PBT_APMRESUMESUSPEND"),            // 0x0007
    TEXT("PBT_APMRESUMESTANDBY"),            // 0x0008
//  TEXT("  PBTF_APMRESUMEFROMFAILURE"),     //   0x00000001
    TEXT("PBT_APMBATTERYLOW"),               // 0x0009
    TEXT("PBT_APMPOWERSTATUSCHANGE"),        // 0x000A
    TEXT("PBT_APMOEMEVENT"),                 // 0x000B
    TEXT("PBT_UNKNOWN"),                     // 0x000C
    TEXT("PBT_UNKNOWN"),                     // 0x000D
    TEXT("PBT_UNKNOWN"),                     // 0x000E
    TEXT("PBT_UNKNOWN"),                     // 0x000F
    TEXT("PBT_UNKNOWN"),                     // 0x0010
    TEXT("PBT_UNKNOWN"),                     // 0x0011
    TEXT("PBT_APMRESUMEAUTOMATIC"),          // 0x0012
};

   UINT uiMsgIndex;

   uiMsgIndex = (dwEventType < (sizeof(pszPwrEventNames) / sizeof(TCHAR *) )) ?
                (UINT) dwEventType : 0x0010;

   DBG_TRC(("Still image APM Broadcast Message:%S Code:%x ",
               pszPwrEventNames[uiMsgIndex],dwEventType));
#endif

    switch(dwEventType)
    {
        case PBT_APMQUERYSUSPEND:
            //
            // Request for permission to suspend
            //
            if(g_NumberOfActiveTransfers > 0) {
                
                //
                // Veto suspend while any transfers are in progress
                //
                dwRet = BROADCAST_QUERY_DENY;
            } else {

                //
                // Notify drivers that we're about to enter a power suspend state
                //
                g_pDevMan->NotifyRunningDriversOfEvent(&WIA_EVENT_POWER_SUSPEND);

                SchedulerSetPauseState(TRUE);
            }
            break;

        case PBT_APMQUERYSUSPENDFAILED:
            //
            // Suspension request denied - unpause the scheduler
            //
            SchedulerSetPauseState(FALSE);
            //
            // Notify drivers that we can resume
            //
            g_pDevMan->NotifyRunningDriversOfEvent(&WIA_EVENT_POWER_RESUME);

            break;

        case PBT_APMSUSPEND:

            //
            // Set the service state to paused
            //
            StiServicePause();
            uiTraceMessage = MSG_TRACE_PWR_SUSPEND;

            break;

        case PBT_APMRESUMECRITICAL:
        case PBT_APMRESUMEAUTOMATIC:
            // Operation resuming after critical suspension
            // Fall through

        case PBT_APMRESUMESUSPEND:
            //
            // Operation resuming after suspension
            // Restart all services which were active at the moment of suspend
            //

            //
            // ReEnumerate devices.  NOTE: we should generate notification only events
            //
            g_pDevMan->ReEnumerateDevices(DEV_MAN_FULL_REFRESH | DEV_MAN_GEN_EVENTS);
            StiServiceResume();
            //
            // Notify drivers that we can resume
            //
            g_pDevMan->NotifyRunningDriversOfEvent(&WIA_EVENT_POWER_RESUME);

            uiTraceMessage = MSG_TRACE_PWR_RESUME;
            g_fFirstDevNodeChangeMsg = TRUE;
            break;

        default:

            //
            // This is a message we either don't know about, or have nothing to do.  
            // In either case, we must return NO_ERROR, else the PnP Manager
            // will assume we're veto'ing the power request.
            //
            dwRet =  NO_ERROR;
    }

    return dwRet;
}

HRESULT CMsgHandler::HandleCustomEvent(
    DWORD   dwEventType)
{
    HRESULT hr = S_OK;

    switch (dwEventType) {
        case STI_SERVICE_CONTROL_EVENT_REREAD :
            //
            //  For each AVTICE_DEVICE we have, re-read the device settings
            //
            hr = g_pDevMan->ForEachDeviceInList(DEV_MAN_OP_DEV_REREAD, 0);
            if (FAILED(hr)) {
                DBG_WRN(("::CMsgHandler::HandleCustomEvent, unable to re-read device settings"));
            }
            break;
        default:
            //
            //  Default case is to refresh our device list
            //
            hr = g_pDevMan->ReEnumerateDevices(DEV_MAN_FULL_REFRESH | DEV_MAN_GEN_EVENTS);
            if (FAILED(hr)) {
                DBG_WRN(("::CMsgHandler::HandleCustomEvent, unable to enumerate devices"));
            }
    }

    return hr;
}

HRESULT CMsgHandler::Initialize()
{
    //
    //  Nothing to do for now
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\globals.h ===
/*++


Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    GLOBALS.H

Abstract:

    Global defines and data.
    Variables and string , located in global scope are defined here
    and memory for them will be allocated in no more than one source
    module, containing definition of DEFINE_GLOBAL_VARIABLES before
    including this file

Author:

    Vlad  Sadovsky  (vlads)     12-20-96

Revision History:



--*/

#ifndef WINVER
#define WINVER  0x0500      /* version 5.0 */
#else

#endif /* !WINVER */

// Use class guid to identify device events, as opposed to global
#define USE_CLASS_GUID_FORPNP_EVENTS    1


#include <windows.h>
#include <winuser.h>

#include <stilog.h>
#include <eventlog.h>
#include <wialog.h>

#include <infoset.h>

#include <devguid.h>
#include <wia.h>
#include "handler.h"


#ifndef USE_CLASS_GUID_FORPNP_EVENTS
#include <pnpmgr.h>
#endif

//
//  Required forward declarations
//

class CWiaDevMan;   // Class defined in wiadevman.h

//
// Following line should be disabled for release
//

//#pragma message("**Attn**: Following line should be disabled for release ")
// #define BETA_PRODUCT    1

#ifdef BETA_PRODUCT
#define BETA_LIMIT_YEAR     1997
#define BETA_LIMIT_MONTH    12
#endif

//
// Global variables are defined in one module, which has definition of
// DEFINE_GLOBAL_VARIABLES before including this  header file.
//

#ifdef DEFINE_GLOBAL_VARIABLES

// #pragma message("STIMON: Defining global variables should be done only once")

#undef  ASSIGN
#define ASSIGN(value) =value

#undef EXTERN
#define EXTERN

#else

#define ASSIGN(value)
#if !defined(EXTERN)
#define EXTERN  extern
#endif

#endif


//
// General char values
//

#define     COLON_CHAR          TEXT(':')    // Native syntax delimiter
#define     DOT_CHAR            TEXT('.')
#define     SLASH_CHAR          TEXT('/')
#define     BACKSLASH_CHAR      TEXT('\\')
#define     STAR_CHAR           TEXT('*')

#define     EQUAL_CHAR          TEXT('=')
#define     COMMA_CHAR          TEXT(',')
#define     WHITESPACE_CHAR     TEXT(' ')
#define     DOUBLEQUOTE_CHAR    TEXT('"')
#define     SINGLEQUOTE_CHAR    TEXT('\'')
#define     TAB_CHAR            TEXT('\t')

#define     DEADSPACE(x) (((x)==WHITESPACE_CHAR) || ((x)==DOUBLEQUOTE_CHAR) )
#define     IS_EMPTY_STRING(pch) (!(pch) || !(*(pch)))

//
// Default DCOM AccessPermission for WIA Device Manager
//
extern WCHAR wszDefaultDaclForDCOMAccessPermission[];


//
// Macros
//
#define TEXTCONST(name,text) extern const TCHAR name[] ASSIGN(text)
#define EXT_STRING(name)     extern const TCHAR name[]

//
// Trace strings should not appear in retail builds, thus define following macro
//
#ifdef DEBUG
#define DEBUG_STRING(s) (s)
#else
#define DEBUG_STRING(s) (NULL)
#endif

//
// Various defines
//
//
// Information extracted from PnP device broadcast.
// We can not keep broadcast structure itself for too long, because it expires .
//

#ifndef _DEVICE_BROADCAST_INFO_
#define _DEVICE_BROADCAST_INFO_
class DEVICE_BROADCAST_INFO {
public:
    UINT    m_uiDeviceChangeMessage;
    DWORD   m_dwDevNode;
    StiCString     m_strDeviceName;
    StiCString     m_strBroadcastedName;
};
#endif

typedef DEVICE_BROADCAST_INFO *PDEVICE_BROADCAST_INFO;

//
// Show verbose UI window
//
#define SHOWMONUI               1

//
//
// STI Device specific values
//
#ifdef DEBUG
#define STIMON_AD_DEFAULT_POLL_INTERVAL       10000             // 10s
#else
#define STIMON_AD_DEFAULT_POLL_INTERVAL       1000              // 1s
#endif


#define STIMON_AD_DEFAULT_WAIT_LOCK           100               // 100ms
#define STIMON_AD_DEFAULT_WAIT_LAUNCH         5000              // 5s

//
// External references to  GLOBAL DATA
//

//
// Server process instance
//
EXTERN    HINSTANCE     g_hInst      ASSIGN(NULL);

//
// Global pointer to STI access object
//
//EXTERN PSTI     g_pSti    ASSIGN(NULL);


//
// Handle of main window
//
EXTERN HWND     g_hMainWindow    ASSIGN(NULL);    ;

//
// Handle of debug verbose window
//
EXTERN HWND     g_hLogWindow    ASSIGN(NULL);    ;

//
// Default timeout for pollable devices
//
EXTERN UINT     g_uiDefaultPollTimeout ASSIGN(STIMON_AD_DEFAULT_POLL_INTERVAL);

//
// Trace UI is visible
//
EXTERN BOOL     g_fUIPermitted ASSIGN(FALSE);


//
//
//
EXTERN BOOL     g_fRefreshDeviceList ASSIGN(FALSE);

//
// Attempt to refresh device controller in case of repeated failures
//
EXTERN BOOL     g_fRefreshDeviceControllerOnFailures ASSIGN(FALSE);


//
// Platform type
//
EXTERN BOOL     g_fIsWindows9x ASSIGN(FALSE);

//
// Setup in progress flag
//
EXTERN BOOL     g_fIsSetupInProgress ASSIGN(FALSE);

//
//
//
EXTERN DWORD    g_dwCurrentState  ASSIGN(0);

//
// Reentrancy flag for timeout selection
//
EXTERN BOOL     g_fTimeoutSelectionDialog ASSIGN(FALSE);

//
// Results of command line parsing
//
EXTERN BOOL        g_fInstallingRequest ASSIGN(FALSE);
EXTERN BOOL        g_fRemovingRequest ASSIGN(FALSE);

//
// Running as a service
//
EXTERN BOOL        g_fRunningAsService ASSIGN(TRUE);

//
// Shutdown in process
//
EXTERN BOOL        g_fServiceInShutdown ASSIGN(FALSE);

//
// Number of active transfers (used to veto powerdown)
//
EXTERN LONG        g_NumberOfActiveTransfers ASSIGN(0);

//
// Event indicating refreshing the device list
//
EXTERN HANDLE      g_hDevListCompleteEvent ASSIGN(NULL);

//
// Global pointer to event log class for process
//
EXTERN EVENT_LOG*  g_EventLog    ASSIGN(NULL);

//
// Global pointer for STI logging
//
EXTERN  STI_FILE_LOG*   g_StiFileLog      ASSIGN(NULL);
EXTERN  IWiaLogEx*        g_pIWiaLog      ASSIGN(NULL);

//
// Handle of the message pump thread
//
EXTERN  DWORD       g_dwMessagePumpThreadId ASSIGN(0);
EXTERN  HANDLE      g_hMessageLoopThread  ASSIGN(NULL);

//
//  Global flag indicating whether this is the first DEVNODE_CHANGE message
//  received after coming out of StandBy
//

EXTERN BOOL        g_fFirstDevNodeChangeMsg ASSIGN(FALSE);

//
//  Global pointer for Device Manager object
//

EXTERN CWiaDevMan*  g_pDevMan   ASSIGN(NULL);

//
//  Global msg/event handler for PnP and Power management
//

EXTERN CMsgHandler* g_pMsgHandler ASSIGN(NULL);
//
//  Globals used for endorser string parsing
//

EXTERN  WCHAR g_szWEDate[];
EXTERN  WCHAR g_szWETime[];
EXTERN  WCHAR g_szWEPageCount[];
EXTERN  WCHAR g_szWEDay[];
EXTERN  WCHAR g_szWEMonth[];
EXTERN  WCHAR g_szWEYear[];

EXTERN  WIAS_ENDORSER_VALUE  g_pwevDefault[];

#define NUM_WIA_MANAGED_PROPS 4
#define PROFILE_INDEX 3

EXTERN PROPID s_piItemNameType[];
EXTERN LPOLESTR s_pszItemNameType[];
EXTERN PROPSPEC s_psItemNameType[];


//
// Monitored GUID for device notifications
//
// ( should really be GUID_DEVCLASS_IMAGE always)
//
#ifndef USE_CLASS_GUID_FORPNP_EVENTS
EXTERN  const GUID        *g_pguidDeviceNotificationsGuid ASSIGN(&GUID_DEVNODE_CHANGE);
#else
EXTERN  const GUID        *g_pguidDeviceNotificationsGuid ASSIGN(&GUID_DEVCLASS_IMAGE);
#endif

//
// Globally visible device info set
//
EXTERN DEVICE_INFOSET  *g_pDeviceInfoSet    ASSIGN(NULL);

//
// Strings
//

TEXTCONST(g_szBACK, TEXT("\\"));
TEXTCONST(g_szClassValueName,TEXT("ClassGUID"));
TEXTCONST(g_szSubClassValueName, TEXT("SubClass"));
TEXTCONST(g_szTitle,TEXT("STI Monitor"));
TEXTCONST(STIStartedEvent_name,TEXT("STIExeStartedEvent"));
TEXTCONST(g_szFiction,TEXT("noskileFaneL"));

// Default settings

// When baud rate is not set for serial device driver , we will populate it's property with
// this default setting.
#define DEF_BAUD_RATE_STR    L"115200"


//
// FS driver related
//
#define FS_USD_CLSID        L"{D2923B86-15F1-46FF-A19A-DE825F919576}"
#define FS_UI_CLSID         L"{D2923B86-15F1-46FF-A19A-DE825F919576}"
#define DEF_UI_CLSID_STR    L"{00000000-0000-0000-0000-000000000000}"
#define FS_UI_DLL           L""
#define FS_VEDNOR_DESC      L"WIA File System"
#define FS_DEVICE_DESC      L"Removable drive"

//
// Class name for the services hidden window
//
TEXTCONST(g_szStiSvcClassName,STISVC_WINDOW_CLASS);
TEXTCONST(g_szClass,STIMON_WINDOW_CLASS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\helpers.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       Helpers.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        12 Mar, 1999
*
*  DESCRIPTION:
*   Helpers for WIA device manager.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include <wiadef.h>
#include <icm.h>

#include "wiamindr.h"
#include "devinfo.h"

#define WIA_DECLARE_MANAGED_PROPS
#include "helpers.h"
#include "shpriv.h"
#include "sticfunc.h"

extern "C"
{
//
// From Terminal services
//
#include <winsta.h>
#include <syslib.h>
}

/**************************************************************************\
* LockWiaDevice
*
*  Wrapper to request Lock Manager to lock device.
*
* Arguments:
*
*   pIWiaMiniDrv - Pointer to mini-driver interface.
*   pIWiaItem     - Pointer to the wia item
*
* Return Value:
*
*    Status
*
* History:
*
*    3/1/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall LockWiaDevice(IWiaItem *pIWiaItem)
{
    DBG_FN(::LockWiaDevice);

    HRESULT     hr = WIA_ERROR_OFFLINE;
    LONG        lFlags = 0;
    CWiaItem    *pItem = (CWiaItem*) pIWiaItem;

    if (pItem->m_pActiveDevice) {
        hr = pItem->m_pActiveDevice->m_DrvWrapper.WIA_drvLockWiaDevice(
                                                    (BYTE*) pItem,
                                                    lFlags,
                                                    &(pItem->m_lLastDevErrVal));
    }
    return hr;
}

/**************************************************************************\
* UnLockWiaDevice
*
*  Wrapper to request Lock Manager to unlock device.
*
* Arguments:
*
*   pIWiaMiniDrv - Pointer to mini-driver interface.
*   pIWiaItem     - Pointer to the wia item
*
* Return Value:
*
*    Status
*
* History:
*
*    3/1/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall UnLockWiaDevice(IWiaItem *pIWiaItem)
{
    DBG_FN(::UnLockWiaDevice);

    HRESULT     hr = WIA_ERROR_OFFLINE;
    LONG        lFlags = 0;
    LONG        lDevErrVal;
    CWiaItem    *pItem = (CWiaItem*) pIWiaItem;

    if (pItem->m_pActiveDevice) {
        hr = pItem->m_pActiveDevice->m_DrvWrapper.WIA_drvUnLockWiaDevice(
                                                    (BYTE*) pItem,
                                                    lFlags,
                                                    &(pItem->m_lLastDevErrVal));
    }

    return hr;
}

/**************************************************************************\
* ValidateWiaItem
*
*  Validate a CWiaItem.
*
* Arguments:
*
*
* Return Value:
*
*    None
*
* History:
*
*    3/1/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall ValidateWiaItem(
    IWiaItem             *pIWiaItem)
{
    DBG_FN(::ValidateWiaItem);
    HRESULT hr = E_POINTER;

    if (pIWiaItem) {

        CWiaItem *pWiaItem = (CWiaItem*)pIWiaItem;

        if (!IsBadReadPtr(pWiaItem, sizeof(CWiaItem))) {
            if (pWiaItem->m_ulSig == CWIAITEM_SIG) {
                return S_OK;
            }
            else {
                DBG_ERR(("ValidateWiaItem, invalid signature: %X", pWiaItem->m_ulSig));
                hr = E_INVALIDARG;
            }
        }
        else {
            DBG_ERR(("ValidateWiaItem, NULL WIA item pointer"));
        }
    }
    else {
        DBG_ERR(("ValidateWiaItem, NULL WIA item pointer"));
    }
    return hr;
}

/**************************************************************************\
* ValidateWiaDrvItemAccess
*
*  Validate a CWiaDrvItem.
*
* Arguments:
*
*
* Return Value:
*
*    None
*
* History:
*
*    3/1/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall ValidateWiaDrvItemAccess(
    CWiaDrvItem             *pWiaDrvItem)
{
    DBG_FN(::ValidateWiaDrvItemAccess);
    HRESULT hr = S_OK;

    if (pWiaDrvItem) {

        //
        // Verify access to the driver item.
        //
        if (IsBadReadPtr(pWiaDrvItem, sizeof(CWiaDrvItem))) {
            DBG_ERR(("ValidateWiaDrvItemAccess, bad pointer, pWiaDrvItem: %X", pWiaDrvItem));
            return E_INVALIDARG;
        }

        //
        // Get the driver item flags.
        //

        LONG lItemFlags;

        pWiaDrvItem->GetItemFlags(&lItemFlags);

        //
        // Verify the item has been initialized and was inserted in the
        // driver item tree at one time.
        //

        if (lItemFlags == WiaItemTypeFree) {
            DBG_ERR(("ValidateWiaDrvItemAccess, application attempting access of unintialized or free item: %0x08X", pWiaDrvItem));
            return E_INVALIDARG;
        }

        if (lItemFlags & WiaItemTypeDeleted) {
            DBG_ERR(("ValidateWiaDrvItemAccess, application attempting access of deleted item: %0x08X", pWiaDrvItem));
            return WIA_ERROR_ITEM_DELETED;
        }

        if (lItemFlags & WiaItemTypeDisconnected) {
            DBG_ERR(("ValidateWiaDrvItemAccess, application attempting access of disconnected item: %0x08X", pWiaDrvItem));
            return WIA_ERROR_OFFLINE;
        }

        hr = S_OK;
    }
    else {
        DBG_ERR(("ValidateWiaDrvItemAccess, Bad pWiaDrvItem pointer"));
        hr = E_INVALIDARG;
    }
    return hr;
}

/**************************************************************************\
* GetNameFromWiaPropId
*
*  Map a WIA property ID to it's corresponding string name.
*
* Arguments:
*
*
* Return Value:
*
*    None
*
* History:
*
*    3/1/1999 Original Version
*
\**************************************************************************/

#define MAP_SIZE (sizeof(g_wiaPropIdToName) / sizeof(WIA_PROPID_TO_NAME))

LPOLESTR GetNameFromWiaPropId(PROPID propid)
{
    for (INT i = 0; g_wiaPropIdToName[i].propid != 0; i++) {
        if (propid  == g_wiaPropIdToName[i].propid) {
            return g_wiaPropIdToName[i].pszName;
        }
    }

    return g_wiaPropIdToName[i].pszName;
}


/**************************************************************************\
* ReportReadWriteMultipleError
*
*  Report errors that occur during ReadMultiple and WriteMultiple calls.
*
* Arguments:
*
*   hr          - Result from ReadMultiple or WriteMultiple call.
*   pszWhere    - Where the API was called from (function/method name).
*   pszWhat     - Optional, which Read/WriteMultiple, used if more than
*                 one Read/WriteMultiple called in function/method.
*   bRead       - TRUE for ReadMultiple.
*   cpspec      - Count of PROPSPEC's in rgpspec.
*   rgpspec     - Array of PROPSPEC's.
*
* Return Value:
*
*    None
*
* History:
*
*    3/1/1999 Original Version
*
\**************************************************************************/

void _stdcall ReportReadWriteMultipleError(
    HRESULT         hr,
    LPSTR           pszWhere,
    LPSTR           pszWhat,
    BOOL            bRead,
    ULONG           cpspec,
    const PROPSPEC  propspec[])
{
    DBG_FN(::ReportReadWriteMultipleError);
    if (SUCCEEDED(hr)) {
        if (hr == S_FALSE) {
            if (bRead) {
                if (pszWhat) {
                    DBG_ERR(("%s, ReadMultiple property not found, %s", pszWhere, pszWhat));
                }
                else {
                    DBG_ERR(("%s, ReadMultiple property not found", pszWhere));
                }
            }
            else {
                if (pszWhat) {
                    DBG_ERR(("%s, WriteMultiple returned S_FALSE, %s", pszWhere, pszWhat));
                }
                else {
                    DBG_ERR(("%s, WriteMultiple returned S_FALSE", pszWhere));
                }
            }
        }
        else {
            return;     // No error.
        }
    }
    else {
        if (bRead) {
            DBG_ERR(("%s, ReadMultiple failed, %s Error 0x%X", pszWhere, pszWhat ? pszWhat : "(null)", hr));
        }
        else {
            DBG_ERR(("%s, WriteMultiple failed, %s Error 0x%X", pszWhere, pszWhat ? pszWhat : "(null)", hr));
        }
    }

    //
    // Output specification information.
    //

    if (cpspec == 0) {
        DBG_ERR(("  count of PROPSPEC's is zero"));
    }
    else if (cpspec == 1) {
        if (propspec[0].ulKind == PRSPEC_PROPID) {
            DBG_ERR(("  property ID: %d, property name: %S", propspec[0].propid, GetNameFromWiaPropId(propspec[0].propid)));
        }
        else if (propspec[0].ulKind == PRSPEC_LPWSTR) {
            DBG_ERR(("  property name: %S", propspec[0].lpwstr));
        }
        else {
            DBG_ERR(("  bad property specification"));
        }
    }
    else {
        DBG_ERR(("  count of PROPSPEC's is: %d", cpspec));
        for (UINT i = 0; i < cpspec; i++) {
            if (propspec[i].ulKind == PRSPEC_PROPID) {
                DBG_ERR(("  property ID: %d, property name: %S", propspec[i].propid, GetNameFromWiaPropId(propspec[i].propid)));
            }
            else if (propspec[i].ulKind == PRSPEC_LPWSTR) {
                DBG_ERR(("  index: %d,  property name: %S", i, propspec[i].lpwstr));
            }
            else {
                DBG_ERR(("  index: %d,  bad property specification", i));
            }
        }
    }
}

/*******************************************************************************
*
*  ReadPropStr
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall ReadPropStr(
   PROPID               propid,
   IPropertyStorage     *pIPropStg,
   BSTR                 *pbstr)
{
    DBG_FN(::ReadPropStr);
    HRESULT     hr;
    PROPSPEC    PropSpec[1];
    PROPVARIANT PropVar[1];
    UINT        cbSize;

    *pbstr = NULL;
    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;
    hr = pIPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hr)) {
        if (PropVar[0].pwszVal) {
            *pbstr = SysAllocString(PropVar[0].pwszVal);
        }
        else {
            *pbstr = SysAllocString(L"");
        }
        if (*pbstr == NULL) {
            DBG_ERR(("ReadPropStr, SysAllocString failed"));
            hr = E_OUTOFMEMORY;
        }
        PropVariantClear(PropVar);
    }
    else {
        DBG_ERR(("ReadPropStr, ReadMultiple of propid: %d, failed", propid));
    }
    return hr;
}

HRESULT _stdcall ReadPropStr(
   PROPID               propid,
   IWiaPropertyStorage  *pIWiaPropStg,
   BSTR                 *pbstr)
{
    DBG_FN(::ReadPropStr);
    HRESULT     hr;
    PROPSPEC    PropSpec[1];
    PROPVARIANT PropVar[1];
    UINT        cbSize;

    *pbstr = NULL;
    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;
    hr = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hr)) {
        if (PropVar[0].pwszVal) {
            *pbstr = SysAllocString(PropVar[0].pwszVal);
        }
        else {
            *pbstr = SysAllocString(L"");
        }
        if (*pbstr == NULL) {
            DBG_ERR(("ReadPropStr, SysAllocString failed"));
            hr = E_OUTOFMEMORY;
        }
        PropVariantClear(PropVar);
    }
    else {
        DBG_ERR(("ReadPropStr, ReadMultiple of propid: %d, failed", propid));
    }
    return hr;
}

HRESULT _stdcall ReadPropStr(IUnknown *pDevice, PROPID propid, BSTR *pbstr)
{
    DBG_FN(::ReadPropStr);
   HRESULT              hr;
   PROPVARIANT          pv[1];
   PROPSPEC             ps[1];
   IWiaPropertyStorage  *pIWiaPropStg;

   *pbstr = NULL;
   hr = pDevice->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropStg);
   if (SUCCEEDED(hr)) {
        PropVariantInit(pv);
        ps[0].ulKind = PRSPEC_PROPID;
        ps[0].propid = propid;

        hr = pIWiaPropStg->ReadMultiple(1, ps, pv);
        if (hr == S_OK) {
            *pbstr = SysAllocString(pv[0].pwszVal);
        } else {
            DBG_ERR(("ReadPropStr, ReadMultiple for propid: %d, failed", propid));
        }
        PropVariantClear(pv);
        pIWiaPropStg->Release();
   } else {
       DBG_ERR(("ReadPropStr, QI for IWiaPropertyStorage failed"));
   }
   return hr;
}

/*******************************************************************************
*
*  ReadPropLong
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall ReadPropLong(PROPID propid, IPropertyStorage  *pIPropStg, LONG *plval)
{
    DBG_FN(::ReadPropLong);
   HRESULT           hr;
   PROPSPEC          PropSpec[1];
   PROPVARIANT       PropVar[1];
   UINT              cbSize;

   memset(PropVar, 0, sizeof(PropVar));
   PropSpec[0].ulKind = PRSPEC_PROPID;
   PropSpec[0].propid = propid;
   hr = pIPropStg->ReadMultiple(1, PropSpec, PropVar);
   if (SUCCEEDED(hr)) {
      *plval = PropVar[0].lVal;
   }
   else {
      DBG_ERR(("ReadPropLong, ReadMultiple of propid: %d, failed", propid));

   }
   return hr;
}

HRESULT _stdcall ReadPropLong(IUnknown *pDevice, PROPID propid, LONG *plval)
{
    DBG_FN(::ReadPropLong);
   HRESULT              hr;
   PROPVARIANT          pv[1];
   PROPSPEC             ps[1];
   IWiaPropertyStorage  *pIWiaPropStg;

   *plval = 0;

   hr = pDevice->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropStg);
   if (SUCCEEDED(hr)) {
        PropVariantInit(pv);
        ps[0].ulKind = PRSPEC_PROPID;
        ps[0].propid = propid;

        hr = pIWiaPropStg->ReadMultiple(1, ps, pv);
        if (hr == S_OK) {
            *plval = pv[0].lVal;
        } else {
            DBG_ERR(("ReadPropLong, ReadMultiple of propid: %d, failed", propid));
        }
        pIWiaPropStg->Release();
   }
   else {
      DBG_ERR(("ReadPropLong, QI of IID_IWiaPropertyStorage failed"));
   }
   return hr;
}

/**************************************************************************\
* WritePropStr
*
*  Writes a string property to the specified property storage.  This is an
*  overloaded function.
*
* Arguments:
*
*   propid      -   propid of the property
*   pIPropStg   -   a pointer to the property storage
*   bstr        -   the string to write
*
* Return Value:
*
*    Status
*
* History:
*
*    10/5/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall WritePropStr(PROPID propid, IPropertyStorage  *pIPropStg, BSTR bstr)
{
    DBG_FN(::WritePropStr);
   HRESULT     hr;
   PROPSPEC    propspec[1];
   PROPVARIANT propvar[1];

   propspec[0].ulKind = PRSPEC_PROPID;
   propspec[0].propid = propid;

   propvar[0].vt      = VT_BSTR;
   propvar[0].pwszVal = bstr;

   hr = pIPropStg->WriteMultiple(1, propspec, propvar, 2);
   if (FAILED(hr)) {
       ReportReadWriteMultipleError( hr,
                                     "Helpers WritePropStr",
                                     NULL,
                                     FALSE,
                                     1,
                                     propspec);
   }
   return hr;
}


/**************************************************************************\
* WritePropStr
*
*   Writes a string property.  This is an overloaded function which calls
*   the other WritePropStr.
*
*
* Arguments:
*
*   pDevice     -   A pointer to a device item which will be queried for
*                   it's IWiaPropertyStorage.
*   propid      -   propid of the property
*   bstr        -   the string to write
*
* Return Value:
*
*    Status
*
* History:
*
*    10/5/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall WritePropStr(IUnknown *pDevice, PROPID propid, BSTR bstr)
{
    DBG_FN(::WritePropStr);
   HRESULT              hr;
   PROPVARIANT          pv[1];
   PROPSPEC             ps[1];
   IWiaPropertyStorage  *pIWiaPropStg;

   PropVariantInit(pv);

   hr = pDevice->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropStg);
   if (SUCCEEDED(hr)) {
        ps[0].ulKind = PRSPEC_PROPID;
        ps[0].propid = propid;

        pv[0].vt = VT_BSTR;
        pv[0].pwszVal = bstr;

        hr = pIWiaPropStg->WriteMultiple(1, ps, pv, 2);
        if (FAILED(hr)) {
            ReportReadWriteMultipleError( hr,
                                          "Helpers WritePropStr",
                                          NULL,
                                          FALSE,
                                          1,
                                          ps);
        }

        pIWiaPropStg->Release();
   }
   else {
      DBG_ERR(("WritePropStr, QI of IID_IWiaPropertyStorage failed"));
   }
   return hr;
}

/**************************************************************************\
* WritePropLong
*
*  Writes a long property to the specified property storage.  This is an
*  overloaded function.
*
* Arguments:
*
*   propid      -   propid of the property
*   pIPropStg   -   a pointer to the property storage
*   lVal        -   the LONG value to write
*
* Return Value:
*
*    Status
*
* History:
*
*    10/5/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall WritePropLong(PROPID propid, IPropertyStorage *pIPropStg, LONG lVal)
{
    DBG_FN(::WritePropLong);
   HRESULT     hr;
   PROPSPEC    propspec[1];
   PROPVARIANT propvar[1];

   propspec[0].ulKind = PRSPEC_PROPID;
   propspec[0].propid = propid;

   propvar[0].vt   = VT_I4;
   propvar[0].lVal = lVal;

   hr = pIPropStg->WriteMultiple(1, propspec, propvar, 2);
   if (FAILED(hr)) {
       ReportReadWriteMultipleError( hr,
                                     "Helpers WritePropLong",
                                     NULL,
                                     FALSE,
                                     1,
                                     propspec);
   }
   return hr;
}

/**************************************************************************\
* WritePropLong
*
*   Writes a long property.  This is an overloaded function which calls
*   the other WritePropLong.
*
*
* Arguments:
*
*   pDevice     -   A pointer to a device item which will be queried for
*                   it's IWiaPropertyStorage.
*   propid      -   propid of the property
*   lVal        -   the LONG value to write
*
* Return Value:
*
*    Status
*
* History:
*
*    10/5/1999 Original Version
*
\**************************************************************************/
HRESULT _stdcall WritePropLong(IUnknown *pDevice, PROPID propid, LONG lVal)
{
   DBG_FN(::WritePropLong);
   HRESULT              hr;
   PROPVARIANT          pv[1];
   PROPSPEC             ps[1];
   IWiaPropertyStorage  *pIWiaPropStg;

   hr = pDevice->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropStg);
   if (SUCCEEDED(hr)) {
        PropVariantInit(pv);
        ps[0].ulKind = PRSPEC_PROPID;
        ps[0].propid = propid;

        pv[0].vt = VT_I4;
        pv[0].lVal = lVal;

        hr = pIWiaPropStg->WriteMultiple(1, ps, pv, 2);
        if (FAILED(hr)) {
            ReportReadWriteMultipleError( hr,
                                          "Helpers WritePropLong",
                                          NULL,
                                          FALSE,
                                          1,
                                          ps);
        }
        pIWiaPropStg->Release();
   }
   else {
      DBG_ERR(("WritePropLong, QI of IID_IWiaPropertyStorage failed"));
   }
   return hr;
}

/**************************************************************************\
* InitMiniDrvContext
*
*   Initialize a mini driver context from an items properties.
*
* Arguments:
*
*   pItem - Pointer to the wia item
*   pmdtc - pointer to mini driver context
*
* Return Value:
*
*    Status
*
* History:
*
*    6/16/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall InitMiniDrvContext(
    IWiaItem                    *pItem,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    DBG_FN(::InitMiniDrvContext);
    //
    // Get a property storage from the item.
    //

    HRESULT             hr;
    IPropertyStorage    *pIPropStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIPropStg, NULL, NULL, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // Setup the minidriver transfer context. Fill in transfer context
    // members which derive from item properties.
    //

    memset(pmdtc, 0, sizeof(MINIDRV_TRANSFER_CONTEXT));

    pmdtc->lSize = sizeof(MINIDRV_TRANSFER_CONTEXT);

    #define NUM_IMAGE_SPEC 9

    static PROPSPEC PropSpec[NUM_IMAGE_SPEC] =
    {
         {PRSPEC_PROPID, WIA_IPA_PIXELS_PER_LINE},
         {PRSPEC_PROPID, WIA_IPA_NUMBER_OF_LINES},
         {PRSPEC_PROPID, WIA_IPA_DEPTH},
         {PRSPEC_PROPID, WIA_IPS_XRES},
         {PRSPEC_PROPID, WIA_IPS_YRES},
         {PRSPEC_PROPID, WIA_IPA_COMPRESSION},
         {PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
         {PRSPEC_PROPID, WIA_IPA_FORMAT},
         {PRSPEC_PROPID, WIA_IPA_TYMED}
    };

    PROPVARIANT       PropVar[NUM_IMAGE_SPEC];

    memset(PropVar, 0, sizeof(PropVar));

    hr = pIPropStg->ReadMultiple(NUM_IMAGE_SPEC, PropSpec, PropVar);
    if (SUCCEEDED(hr)) {

        pmdtc->lWidthInPixels      = PropVar[0].lVal;
        pmdtc->lLines              = PropVar[1].lVal;
        pmdtc->lDepth              = PropVar[2].lVal;
        pmdtc->lXRes               = PropVar[3].lVal;
        pmdtc->lYRes               = PropVar[4].lVal;
        pmdtc->lCompression        = PropVar[5].lVal;
        pmdtc->lItemSize           = PropVar[6].lVal;
        pmdtc->guidFormatID        = *PropVar[7].puuid;
        pmdtc->tymed               = PropVar[8].lVal;

        FreePropVariantArray(NUM_IMAGE_SPEC, PropVar);
    }
    else {
        ReportReadWriteMultipleError(hr, "InitMiniDrvContext", NULL, TRUE, NUM_IMAGE_SPEC, PropSpec);
    }
    return hr;
}

/**************************************************************************\
* GetPropertyAttributesHelper
*
*   Get the access flags and valid values for a property.  Used by
*   GetPropertyAttributes in the service and by WIA Items.  Parameter
*   validation is done beforehand by caller.
*
* Arguments:
*
*   pItem          - Pointer to WIA item
*   cPropSpec      - The number of properties
*   pPropSpec      - array of property specification.
*   pulAccessFlags - array of LONGs access flags.
*   ppvValidValues - Pointer to returned valid values.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*   05/14/1999 Updated to return multiple attribute values
*   30/06/1999 Parameter validation removed,
*
\**************************************************************************/

HRESULT _stdcall GetPropertyAttributesHelper(
   IWiaItem                      *pItem,
   LONG                          cPropSpec,
   PROPSPEC                      *pPropSpec,
   ULONG                         *pulAccessFlags,
   PROPVARIANT                   *ppvValidValues)
{
    DBG_FN(::GetPropertyAttributesHelper);
    HRESULT hr;

    memset(pulAccessFlags, 0, sizeof(ULONG) * cPropSpec);
    memset(ppvValidValues, 0, sizeof(PROPVARIANT) * cPropSpec);

    //
    //  Get the item's internal property storage pointers.
    //

    IPropertyStorage *pIPropAccessStg;
    IPropertyStorage *pIPropValidStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(NULL,
                                                &pIPropAccessStg,
                                                &pIPropValidStg,
                                                NULL);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Get the Access flags for the properties.  Use pPropVar as
    //  temporary storage.
    //

    hr = pIPropAccessStg->ReadMultiple(cPropSpec, pPropSpec, ppvValidValues);
    if (SUCCEEDED(hr)) {

        //
        //  Fill in the returned access flags
        //

        for (int flagIndex = 0; flagIndex < cPropSpec; flagIndex++) {
            pulAccessFlags[flagIndex] = ppvValidValues[flagIndex].ulVal;
        }

        //
        //  Get the valid values
        //

        hr = pIPropValidStg->ReadMultiple(cPropSpec, pPropSpec, ppvValidValues);
        if (FAILED(hr)) {
            DBG_ERR(("GetPropertyAttributesHelper, ReadMultiple failed, could not get valid values (0x%X)", hr));
        }
    } else {
        DBG_ERR(("GetPropertyAttributesHelper, ReadMultiple failed, could not get access flags (0x%X)", hr));
    }

    if (FAILED(hr)) {

        //
        //  Was not successful, so clear the return values and report
        //  which properties caused the error.
        //

        FreePropVariantArray(cPropSpec, ppvValidValues);
        memset(pulAccessFlags, 0, sizeof(ULONG) * cPropSpec);

        ReportReadWriteMultipleError(hr, "GetPropertyAttributesHelper",
                                     NULL,
                                     TRUE,
                                     cPropSpec,
                                     pPropSpec);
    }
    return hr;
}


/**************************************************************************\
* GetMinAndMaxLong
*
*   This helper method is called to get the Min and Max values for a
*   WIA_PROP_RANGE property of type VT_I4.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context
*   propid          -   identifies the property we're interested in.
*   plMin           -   the address of a LONG to receive the min value
*   plMax           -   the address of a LONG to receive the max value
*
* Return Value:
*
*    Status
*
* History:
*
*    04/04/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall GetMinAndMaxLong(
    BYTE*       pWiasContext,
    PROPID      propid,
    LONG        *plMin,
    LONG        *plMax)
{
    DBG_FN(::GetMinAndMaxLong);
    IPropertyStorage    *pIValidStg;
    PROPSPEC            ps[1];
    PROPVARIANT         pv[1];
    HRESULT             hr;

    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = propid;

    PropVariantInit(pv);

    hr = ((CWiaItem*) pWiasContext)->GetItemPropStreams(NULL,
                                                        NULL,
                                                        &pIValidStg,
                                                        NULL);
    if (SUCCEEDED(hr)) {
        hr = pIValidStg->ReadMultiple(1, ps, pv);
        if (SUCCEEDED(hr)) {
            if (plMin) {
                *plMin = pv[0].cal.pElems[WIA_RANGE_MIN];
            };
            if (plMax) {
                *plMax = pv[0].cal.pElems[WIA_RANGE_MAX];
            };
        } else {
            DBG_ERR(("GetMinAndMaxLong, Reading property %d (%ws) failed",propid,GetNameFromWiaPropId(propid)));
        };
    } else {
        DBG_ERR(("GetMinAndMaxLong, Could not get valid property stream"));
    }
    return hr;
}

/**************************************************************************\
* CheckXResAndUpdate
*
*   This helper method is called to check whether WIA_IPS_XRES property
*   is changed.  When this property changes, other dependant
*   properties and their valid values must also be changed.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext        -   a pointer to the property context (which indicates
*                       which properties are being written).
*   lWidth          -   the width of the maximum scan area in one thousandth's
*                       of an inch.  Generally, this would be the horizontal
*                       bed size.
*
* Return Value:
*
*    Status
*
* History:
*
*    04/04/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CheckXResAndUpdate(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext,
    LONG                    lWidth)
{
    DBG_FN(::CheckXResAndUpdate);

    LONG                    lMinXExt, lMaxXExtOld, lMaxXPosOld;
    LONG                    lMax, lExt;
    WIAS_CHANGED_VALUE_INFO cviXRes, cviXPos, cviXExt;
    HRESULT                 hr = S_OK;

    //
    //  Call wiasGetChangedValue for XResolution. XResolution is checked first
    //  since it's not dependant on any other property.  All properties in
    //  this method that follow are dependant properties of XResolution.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 FALSE,
                                 WIA_IPS_XRES,
                                 &cviXRes);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Call wiasGetChangedValue for XPos. XPos is a dependant property of
    //  XResolution whose valid value changes according to what the current
    //  value of XResolution is.  This is so that when the resoltuion changes,
    //  the XPos will be in the same relative position.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 cviXRes.bChanged,
                                 WIA_IPS_XPOS,
                                 &cviXPos);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Get the minimum and maximum extent values
    //

    hr = GetMinAndMaxLong(pWiasContext, WIA_IPS_XEXTENT, &lMinXExt, &lMaxXExtOld );
    if (FAILED(hr)) {
        return hr;
    }

    hr = GetMinAndMaxLong(pWiasContext, WIA_IPS_XPOS, NULL, &lMaxXPosOld );
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  lMax is the maximum horizontal position (in pixels) that XPos can be
    //  set to. lXRes is DPI, lWidth is in one thousandth's of an inch,
    //  and lMinXExt is in pixels.
    //

    lMax = ((cviXRes.Current.lVal * lWidth) / 1000) - lMinXExt;

    if (cviXRes.bChanged) {

        //
        //  XRes changed, so calc and set new XPos valid values.
        //

        hr = wiasSetValidRangeLong(pWiasContext, WIA_IPS_XPOS, 0, 0, lMax, 1);
        if (SUCCEEDED(hr)) {

            //
            //  If XPos is not one of the properties being written, then fold
            //  it's current value.
            //

            if (!cviXPos.bChanged) {

                cviXPos.Current.lVal = (cviXPos.Old.lVal * lMax) / lMaxXPosOld;
                hr = wiasWritePropLong(pWiasContext, WIA_IPS_XPOS, cviXPos.Current.lVal);
                if (FAILED(hr)) {
                    DBG_ERR(("CheckXResAndUpdate, could not write value for WIA_IPS_XPOS"));
                }
            }
        }
    }
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Call wiasGetChangedValue for XExtent. XExtent is a dependant property of
    //  both XResolution and XPos.  The extent should be the same relative
    //  size no matter what the resolution.  However, if the resolution changes
    //  or if the XPos is set, then the extent has the possibility of being
    //  too large and so must be folded to a valid value.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                         pContext,
                         cviXRes.bChanged || cviXPos.bChanged,
                         WIA_IPS_XEXTENT,
                         &cviXExt);
    if (FAILED(hr)) {
        return hr;
    }

    lExt = cviXExt.Current.lVal;

    if (cviXRes.bChanged || cviXPos.bChanged) {

        //
        //  XRes or XPos changed, so calc and set new XExtent valid values.
        //  The maximum valid value for XExtent is the maximum width allowed,
        //  starting at XPos.
        //

        lExt = (lMax - cviXPos.Current.lVal) + lMinXExt;

        hr = wiasSetValidRangeLong(pWiasContext, WIA_IPS_XEXTENT, lMinXExt, lExt, lExt, 1);
        if (SUCCEEDED(hr)) {

            //
            //  If XExtent is not one of the properties being written, then fold
            //  it's current value.
            //

            if (!cviXExt.bChanged) {
                LONG lXExtScaled;

                //
                //  First scale the extent and then check whether it has to be
                //  truncated.  The old extent should be scaled to keep the
                //  same relative size.  If the resolution has not changed,
                //  then the scaling simply keeps the extent the same size.
                //

                lXExtScaled = (cviXExt.Old.lVal * lExt) / lMaxXExtOld;
                if (lXExtScaled > lExt) {

                    //
                    //  The extent is too large, so clip it.
                    //

                    lXExtScaled = lExt;
                }
                hr = wiasWritePropLong(pWiasContext, WIA_IPS_XEXTENT, lXExtScaled);
                if (FAILED(hr)) {
                    DBG_ERR(("CheckXResAndUpdate, could not write value for WIA_IPS_XEXTENT"));
                }
            }
        }
    }
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Update read-only property : PIXELS_PER_LINE.  The width in pixels
    //  of the scanned image is the same size as the XExtent.
    //

    hr = wiasReadPropLong(pWiasContext, WIA_IPS_XEXTENT, &lExt, NULL, TRUE);
    if (SUCCEEDED(hr)) {
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, lExt);
    }
    return hr;
}

/**************************************************************************\
* CheckYResAndUpdate
*
*   This helper method is called to check whether WIA_IPS_YRES property
*   is changed.  When this property changes, other dependant
*   properties and their valid values must also be changed.  This is
*   similar to the CheckXResAndUpdateChanged function.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext        -   a pointer to the property context (which indicates
*                       which properties are being written).
*   lHeight         -   the height of the maximum scan area in one
*                       thousandth's of an inch.  Generally, this would be
*                       the vertical bed size.
*
* Return Value:
*
*    Status
*
* History:
*
*    04/04/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CheckYResAndUpdate(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext,
    LONG                    lHeight)
{
    DBG_FN(::CheckYResAndUpdate);
    LONG                    lMinYExt, lMaxYExtOld, lMaxYPosOld;
    LONG                    lMax, lExt;
    WIAS_CHANGED_VALUE_INFO cviYRes, cviYPos, cviYExt;
    HRESULT                 hr = S_OK;

    //
    //  Call wiasGetChangedValue for YResolution. YResolution is checked first
    //  since it's not dependant on any other property.  All properties in
    //  this method that follow are dependant properties of YResolution.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 FALSE,
                                 WIA_IPS_YRES,
                                 &cviYRes);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Call wiasGetChangedValue for YPos. YPos is a dependant property of
    //  YResolution whose valid value changes according to what the current
    //  value of YResolution is.  This is so that when the resoltuion changes,
    //  the YPos will be in the same relative position.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 cviYRes.bChanged,
                                 WIA_IPS_YPOS,
                                 &cviYPos);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Get the minimum and maximum pos and extent values
    //

    hr = GetMinAndMaxLong(pWiasContext, WIA_IPS_YEXTENT, &lMinYExt, &lMaxYExtOld);
    if (FAILED(hr)) {
        return hr;
    }

    hr = GetMinAndMaxLong(pWiasContext, WIA_IPS_YPOS, NULL, &lMaxYPosOld);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  lMax is the maximum vertical position (in pixels) that YPos can be
    //  set to. lYRes is DPI, lPageHeight is in one thousandth's of an inch,
    //  and lMinYExt is in pixels.
    //

    lMax = ((cviYRes.Current.lVal * lHeight) / 1000) - lMinYExt;

    if (cviYRes.bChanged) {

        //
        //  YRes changed, so calc and set new YPos valid values.
        //

        hr = wiasSetValidRangeLong(pWiasContext, WIA_IPS_YPOS, 0, 0, lMax, 1);
        if (SUCCEEDED(hr)) {

            //
            //  If YPos is not one of the properties being written, then fold
            //  it's current value.
            //

            if (!cviYPos.bChanged) {

                cviYPos.Current.lVal = (cviYPos.Old.lVal * lMax) / lMaxYPosOld;
                hr = wiasWritePropLong(pWiasContext, WIA_IPS_YPOS, cviYPos.Current.lVal);
                if (FAILED(hr)) {
                    DBG_ERR(("CheckYResAndUpdate, could not write value for WIA_IPS_YPOS"));
                }
            }
        }
    }
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Call wiasGetChangedValue for YExtent. YExtent is a dependant property of
    //  both YResolution and YPos.  The extent should be the same relative
    //  size no matter what the resolution.  However, if the resolution changes
    //  or if the YPos is set, then the extent has the possibility of being
    //  too large and so must be folded to a valid value.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                         pContext,
                         cviYRes.bChanged || cviYPos.bChanged,
                         WIA_IPS_YEXTENT,
                         &cviYExt);
    if (FAILED(hr)) {
        return hr;
    }
    lExt = cviYExt.Current.lVal;

    if (cviYRes.bChanged || cviYPos.bChanged) {

        //
        //  YRes or YPos changed, so calc and set new YExtent valid values.
        //  The maximum valid value for YExtent is the maximum height allowed,
        //  starting at YPos.
        //

        lExt = (lMax - cviYPos.Current.lVal) + lMinYExt;

        hr = wiasSetValidRangeLong(pWiasContext, WIA_IPS_YEXTENT, lMinYExt, lExt, lExt, 1);
        if (SUCCEEDED(hr)) {

            //
            //  If YExtent is not one of the properties being written, then fold
            //  it's current value.
            //

            if (!cviYExt.bChanged) {
                LONG lYExtScaled;

                //
                //  First scale the extent and then check whether it has to be
                //  truncated.  The old extent should be scaled to keep the
                //  same relative size.  If the resolution has not changed,
                //  then the scaling simply keeps the extent the same size.
                //

                lYExtScaled = (cviYExt.Old.lVal * lExt) / lMaxYExtOld;
                if (lYExtScaled > lExt) {

                    //
                    //  The extent is too large, so clip it.
                    //

                    lYExtScaled = lExt;
                }
                hr = wiasWritePropLong(pWiasContext, WIA_IPS_YEXTENT, lYExtScaled);
                if (FAILED(hr)) {
                    DBG_ERR(("CheckYResAndUpdate, could not write value for WIA_IPS_YEXTENT"));
                }
            }
        }
    }
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Update read-only property : NUMBER_OF_LINES.  The number of lines in the scanned
    //  image is the same as the vertical (Y) extent.
    //

    hr = wiasReadPropLong(pWiasContext, WIA_IPS_YEXTENT, &lExt, NULL, TRUE);
    if (SUCCEEDED(hr)) {
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_NUMBER_OF_LINES, lExt);
    }
    return hr;
}

/**************************************************************************\
* AreWiaInitializedProps
*
*   This helper method is called to check whether a given set of propspecs
*   identifies only the WIA managed properties.  It is used to help
*   performance with lazy intialization.
*
* Arguments:
*
*   cPropSpec   -   count of propecs in the array
*   pPropSpec   -   the propspec array
*
* Return Value:
*
*   TRUE    -   if all properties in the propspec array are WIA managed ones.
*   FALSE   -   if at least one property is not a WIA managed one.
*
* History:
*
*    10/10/1999 Original Version
*
\**************************************************************************/
BOOL _stdcall AreWiaInitializedProps(
    ULONG       cPropSpec,
    PROPSPEC    *pPropSpec)
{
    DBG_FN(::AreWiaInitializedProps);
    ULONG   index;
    ULONG   propIndex;
    BOOL    bFoundProp  = FALSE;

    for (index = 0; index < cPropSpec;  index++) {
        bFoundProp = FALSE;

        for (propIndex = 0; propIndex < NUM_WIA_MANAGED_PROPS; propIndex++) {

            if (pPropSpec[index].ulKind == PRSPEC_LPWSTR) {
                if (wcscmp(s_pszItemNameType[propIndex], pPropSpec[index].lpwstr) == 0) {
                    bFoundProp = TRUE;
                    break;
                }
            } else if (s_piItemNameType[propIndex] == pPropSpec[index].propid) {
                bFoundProp = TRUE;
                break;
            }
        }

        if (!bFoundProp) {
            break;
        }
    }

    return bFoundProp;
}

HRESULT _stdcall SetValidProfileNames(
    BYTE        *pbData,
    DWORD       dwSize,
    IWiaItem    *pIWiaItem)
{
    DBG_FN(::StripProfileNames);
    HRESULT hr;
    ULONG   ulNumStrings        = 0;
    LPTSTR  szProfileName       = (LPTSTR) pbData;
    BSTR    bstrDefault         = NULL;
    BSTR    *bstrValidProfiles  = NULL;
    ULONG   ulIndex             = 0;

USES_CONVERSION;

    //
    //  Count number of strings
    //

    while ((BYTE*)szProfileName < (pbData + dwSize)) {
        if (szProfileName[0] != TEXT('\0')) {
            ulNumStrings++;
            szProfileName += lstrlen(szProfileName);
        }
        szProfileName++;
    }

    if (ulNumStrings == 0) {
        DBG_ERR(("StripProfileNames, No profile names!"));
        return E_FAIL;
    }

    //
    //  Allocate memory for the string array
    //

    szProfileName = (LPTSTR)pbData;

    bstrDefault = SysAllocString(T2W(szProfileName));
    bstrValidProfiles = (BSTR*) LocalAlloc(LPTR, ulNumStrings * sizeof(BSTR));
    if (!bstrValidProfiles || !bstrDefault) {
        DBG_ERR(("StripProfileNames, could not allocate memory!"));
        hr = E_OUTOFMEMORY;
    } else {
        memset(bstrValidProfiles, 0, ulNumStrings * sizeof(BSTR));
    }

    if (SUCCEEDED(hr)) {

        //
        //  Set the string values.
        //

        for (ulIndex = 0; ulIndex < ulNumStrings; ulIndex++) {
            if (szProfileName[0] != TEXT('\0')) {
                bstrValidProfiles[ulIndex] = SysAllocString(T2W(szProfileName));
                if (!bstrValidProfiles[ulIndex]) {
                    DBG_ERR(("StripProfileNames, could not allocate strings!"));
                    hr = E_OUTOFMEMORY;
                    break;
                }
                szProfileName += (lstrlen(szProfileName) + 1);
            }
        }

        //
        //  Set the valid values and the current value
        //

        if (SUCCEEDED(hr)) {
            hr = wiasSetValidListStr((BYTE*) pIWiaItem,
                                     WIA_IPA_ICM_PROFILE_NAME,
                                     ulNumStrings,
                                     bstrDefault,
                                     bstrValidProfiles);
            if (SUCCEEDED(hr)) {
                hr = wiasWritePropStr((BYTE*) pIWiaItem,
                                      WIA_IPA_ICM_PROFILE_NAME,
                                      bstrDefault);
                if (FAILED(hr)) {
                    DBG_ERR(("StripProfileNames, could not set default color profiles!"));
                }

            } else {
                DBG_ERR(("StripProfileNames, could not set valid list of color profiles!"));
            }
        }
    }

    //
    //  Free memory
    //

    if (bstrDefault) {
        SysFreeString(bstrDefault);
        bstrDefault = NULL;
    }

    if (bstrValidProfiles) {
        for (ulIndex = 0; ulIndex < ulNumStrings; ulIndex++) {
            if (bstrValidProfiles[ulIndex]) {
                SysFreeString(bstrValidProfiles[ulIndex]);
            }
        }
        LocalFree(bstrValidProfiles);
        bstrValidProfiles = NULL;
    }

    return hr;
}

/**************************************************************************\
* FillICMPropertyFromRegistry
*
*   This helper method is called to fill the item properties with the ICM
*   color profile names from a specified device's registry entries.
*   NOTE:  This function assumes this is called on a Root before it's called
*          on its children!
*
* Arguments:
*
*   IWiaItem    -   WIA item
*
* Return Value:
*
*   Status
*
* History:
*
*    10/10/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall FillICMPropertyFromRegistry(
    IWiaPropertyStorage *pDevInfoProps,
    IWiaItem            *pIWiaItem)
{
    DBG_FN(::FillICMPropertyFromRegistry);
    PROPSPEC    pspec[1]    = {{PRSPEC_PROPID, WIA_DIP_DEV_ID}};
    PROPVARIANT pvName[1];
    HRESULT     hr          = E_FAIL;
    BYTE        *pbData     = NULL;
    DWORD       dwType      = 0;
    DWORD       dwSize      = 0;
    LONG        lItemType   = 0;

    CWiaItem            *pRoot          =   NULL;

USES_CONVERSION;

    //
    //  Check whether this is the root item.  If it is, read the ICM values from the
    //  registry, and cache it.
    //  NOTE:  This should be moved into the STI_WIA_DEVICE_INFORMATION member of
    //         ACTIVE_DEVICE, and filled in when STI_WIA_DEVICE_INFORMATION is
    //         filled for the first time.  This should increase performance.
    //  If it isn't the root item, then get the cached ICM values from the root, and
    //  fill them in.
    //

    hr = pIWiaItem->GetItemType(&lItemType);
    if (SUCCEEDED(hr)) {

        if (lItemType & WiaItemTypeRoot) {

            //
            //  This is a root item, so cache the ICM values.
            //  Start by getting the device name...
            //

            pRoot = (CWiaItem*) pIWiaItem;

            if (pDevInfoProps) {
                //
                //  Get the color profile names.  First get the size, then get the value.
                //
                hr = g_pDevMan->GetDeviceValue(pRoot->m_pActiveDevice,
                                               STI_DEVICE_VALUE_ICM_PROFILE,
                                               &dwType,
                                               NULL,
                                               &dwSize);
                if (SUCCEEDED(hr)) {

                    pbData = (BYTE*) LocalAlloc(LPTR, dwSize);
                    if (pbData) {
                        dwType = REG_BINARY;
                        hr = g_pDevMan->GetDeviceValue(pRoot->m_pActiveDevice,
                                                       STI_DEVICE_VALUE_ICM_PROFILE,
                                                       &dwType,
                                                       pbData,
                                                       &dwSize);
                        if (SUCCEEDED(hr)) {

                            //
                            //  Store the ICM value with this root item.
                            //

                            pRoot->m_pICMValues = pbData;
                            pRoot->m_lICMSize   = dwSize;

                        } else {
                            DBG_WRN(("FillICMPropertyFromRegistry, could not get ICM profile value!"));
                            LocalFree(pbData);
                        }
                    } else {
                        hr = E_OUTOFMEMORY;
                        DBG_ERR(("FillICMPropertyFromRegistry, not enough memory for ICM values!"));
                    }
                } else {
                    DBG_WRN(("FillICMPropertyFromRegistry, could not get ICM profile size!"));
                }
            } else {
                DBG_ERR(("FillICMPropertyFromRegistry, no property stream provided!"));
            }

            //
            //  Always set the return to S_OK if this is the root.  Even if the color profile could not
            //  be read, when it comes time for the child items to have their profile property filled in,
            //  they'll simply get the standard sRGB one instead.
            //

            hr = S_OK;
        } else {

            //
            //  This is not a root item, so get the cached ICM values from the root
            //  and fill in the ICM property.
            //

            hr = pIWiaItem->GetRootItem((IWiaItem**) &pRoot);
            if (SUCCEEDED(hr)) {

                //
                //  Check whether a cached ICM profile list exists.  Get a standard one if it doesn't, else
                //  just set the property.
                //

                if (!pRoot->m_pICMValues || 
                    FAILED(hr = SetValidProfileNames(pRoot->m_pICMValues, pRoot->m_lICMSize, pIWiaItem)))
                {
                    TCHAR   szSRGB[MAX_PATH] = {TEXT('\0')};

                    dwSize = sizeof(szSRGB);
                    if (GetStandardColorSpaceProfile(NULL,
                                                     LCS_sRGB,
                                                     szSRGB,
                                                     &dwSize))
                    {
                        hr = SetValidProfileNames((BYTE*)szSRGB, dwSize, pIWiaItem);
                        DBG_TRC(("FillICMPropertyFromRegistry, using default color space profile"));

                    } else {
                        DBG_ERR(("FillICMPropertyFromRegistry, GetStandardColorSpaceProfile failed!"));
                        hr = E_FAIL;
                    }
                }

                pRoot->Release();
            } else {
                DBG_ERR(("FillICMPropertyFromRegistry, could not get root item!"));
            }
        }
    } else {
        DBG_ERR(("FillICMPropertyFromRegistry, could not get item type!"));
    }
    return hr;
}

/**************************************************************************\
* GetParentItem
*
*   Returns the item's parent
*
* Arguments:
*
*   pItem   -   WIA item
*   ppItem  -   address to store the parent item.
*
* Return Value:
*
*   Status
*
* History:
*
*    01/14/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall GetParentItem(CWiaItem *pItem, CWiaItem **ppParent)
{
    DBG_FN(::GetParentItem);
    CWiaTree    *pTree, *pParentTree;
    HRESULT     hr = S_OK;

    pTree = pItem->GetTreePtr();
    if (pTree) {

        hr = pTree->GetParentItem(&pParentTree);
        if (SUCCEEDED(hr)) {

            if (hr == S_OK) {
                pParentTree->GetItemData((VOID**) ppParent);
            }
        } else {
            DBG_ERR(("GetParentItem, could not get root item tree!"));
        }
    } else {
        DBG_ERR(("GetParentItem, item's tree ptr is NULL!"));
        hr = E_INVALIDARG;
    }

    return hr;
}

/**************************************************************************\
* GetBufferValues
*
*   Fills in the buffer size properties of the WIA_EXTENDED_TRANSFER_INFO
*   struct.
*
* Arguments:
*
*   pCWiaItem   -   WIA item
*   pTransInfo  -   Pointer to the extended transfer information struct.
*
* Return Value:
*
*   Status
*
* History:
*
*    01/23/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall GetBufferValues(
    CWiaItem                    *pCWiaItem,
    PWIA_EXTENDED_TRANSFER_INFO pTransInfo)
{
    DBG_FN(::GetBufferValues);
    HRESULT             hr          = S_OK;
    IPropertyStorage    *pIValidStg = NULL;
    PROPSPEC            ps[1]       =   {{PRSPEC_PROPID, WIA_IPA_BUFFER_SIZE}};
    PROPVARIANT         pv[1];

    //
    //  Get the valid values for the WIA_IPA_BUFFER_SIZE property.
    //  NOTE:  The WIA_IPA_BUFFER_SIZE property used to be the
    //         WIA_IPA_MIN_BUFFER_SIZE property.  If we can't
    //         read the valid values for WIA_IPA_BUFFER_SIZE,
    //         we must read the current value of WIA_IP_MIN_BUFFER_SIZE
    //         and "guess" the other values instead.
    //  This is to facilitate drivers that were made with early versions
    //  of the WIA DDK.
    //

    hr = pCWiaItem->GetItemPropStreams(NULL, NULL, &pIValidStg, NULL);
    if (SUCCEEDED(hr)) {

        PropVariantInit(pv);

        hr = pIValidStg->ReadMultiple(1, ps, pv);
        if (hr == S_OK) {

            //
            //  Check that the returned property really has enough elements
            //  to specify min, max and nominal values.  If not, set hr to
            //  fail so that we catch our attempt to reach MIN_BUFFER_SIZE
            //  instead.
            //

            if (pv[0].cal.cElems == WIA_RANGE_NUM_ELEMS) {

                //
                //  Valid values for WIA_IPA_BUFFER_SIZE found, so
                //  set the returns.

                pTransInfo->ulMinBufferSize     = pv[0].cal.pElems[WIA_RANGE_MIN];
                pTransInfo->ulOptimalBufferSize = pv[0].cal.pElems[WIA_RANGE_NOM];
                pTransInfo->ulMaxBufferSize     = pv[0].cal.pElems[WIA_RANGE_MAX];
            } else {

                hr = E_FAIL;
            }
        }

        if (hr != S_OK) {

            //
            //  Attempt to read the current value of WIA_IPA_MIN_BUFFER_SIZE,
            //  since we couldn't find the values we wanted under
            //  WIA_IPA_BUFFER_SIZE.
            //

            IPropertyStorage    *pICurrentStg = NULL;

            PropVariantClear(pv);

            hr = pCWiaItem->GetItemPropStreams(&pICurrentStg, NULL, NULL, NULL);
            if (SUCCEEDED(hr)) {

                //
                //  Note that we can re-use ps, since the propid's of
                //  MIN_BUFFER_SIZE and BUFFER_SIZE are the same.
                //

                hr = pICurrentStg->ReadMultiple(1, ps, pv);
                if (hr == S_OK) {

                    //
                    //  Current value for WIA_IPA_MIN_BUFFER_SIZE found, so
                    //  set the returns.

                    pTransInfo->ulMinBufferSize     = pv[0].lVal;
                    pTransInfo->ulOptimalBufferSize = pv[0].lVal;
                    pTransInfo->ulMaxBufferSize     = LONG_MAX;
                } else {
                    DBG_ERR(("GetBufferValues, Could not read (valid) WIA_IPA_BUFFER_SIZE or (current) WIA_IPA_MIN_BUFFER_SIZE!"));
                    hr = E_INVALIDARG;
                }
            } else {
                DBG_ERR(("GetBufferValues, Could not get item prop streams!"));
            }
        }
        PropVariantClear(pv);
    } else {
        DBG_ERR(("GetBufferValues, failed to get item prop streams!"));
    }
    return hr;
}

/**************************************************************************\
* BQADScale
*
*   This routine implements Byron's Quick And Dirty scaling algorithm.  This
*   specific implementation is meant for 1, 8, or 24bit only.  Caller
*   is responsible for all parameter checks!
*
*   Please note:  this is assumed to scale a band of BITMAP data.  As such,
*   the source should contain DWORD aligned pixel data, and the ouput buffer
*   will contain DWORD aligned pixel data upon return.
*
* Arguments:
*
*   pSrcBuffer  - Pointer to the source buffer
*   lSrcWidth   - the source data width in pixels
*   lSrcHeight  - the source data height in pixels
*   lSrcDepth   - the bit depth of the source data
*   pDestBuffer - Pointer to the destination buffer
*   lDestWidth  - the resultant width in pixels
*   lDestHeight - the resultant height in pixels
*
* Return Value:
*
*   Status
*
* History:
*
*    08/28/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall BQADScale(BYTE* pSrcBuffer,
                           LONG  lSrcWidth,
                           LONG  lSrcHeight,
                           LONG  lSrcDepth,
                           BYTE* pDestBuffer,
                           LONG  lDestWidth,
                           LONG  lDestHeight)
{
    //
    //  We only deal with 1, 8 and 24 bit data
    //

    if ((lSrcDepth != 8) && (lSrcDepth != 1) && (lSrcDepth != 24)) {
        DBG_ERR(("BQADScale, We only scale 1bit, 8bit or 24bit data right now, data is %dbit\n", lSrcDepth));
        return E_INVALIDARG;
    }

    //
    // Make adjustments so we also work in all supported bit depths.  We can get a performance increase
    // by having separate implementations of all of these, but for now, we stick to a single generic
    // implementation.
    //

    LONG    lBytesPerPixel = (lSrcDepth + 7) / 8;                 // This is the ceiling of the number of
                                                                  //  bytes needed to hold a single pixel
    ULONG   lSrcRawWidth = ((lSrcWidth * lSrcDepth) + 7) / 8;     // This is the width in bytes
    ULONG   lSrcWidthInBytes;                                     // This is the DWORD-aligned width
    ULONG   lDestWidthInBytes;                                    // This is the DWORD-aligned width

    //
    // We need to work out the DWORD aligned width in bytes.  Normally we would do this in one step
    // using the supplied lSrcDepth, but we avoid arithmetic overflow conditions that happen
    // in 24bit if we do it in 2 steps like this instead.
    //

    if (lSrcDepth == 1) {
        lSrcWidthInBytes    = (lSrcWidth + 7) / 8;
        lDestWidthInBytes   = (lDestWidth + 7) / 8;
    } else {
        lSrcWidthInBytes    = (lSrcWidth * lBytesPerPixel);
        lDestWidthInBytes   = (lDestWidth * lBytesPerPixel);
    }
    lSrcWidthInBytes    += (lSrcWidthInBytes % sizeof(DWORD)) ? (sizeof(DWORD) - (lSrcWidthInBytes % sizeof(DWORD))) : 0;
    lDestWidthInBytes   += (lDestWidthInBytes % sizeof(DWORD)) ? (sizeof(DWORD) - (lDestWidthInBytes % sizeof(DWORD))) : 0;

    //
    //  Define local variables and do the initial calculations needed for
    //  the scaling algorithm
    //

    BYTE    *pDestPixel     = NULL;
    BYTE    *pSrcPixel      = NULL;
    BYTE    *pEnd           = NULL;
    BYTE    *pDestLine      = NULL;
    BYTE    *pSrcLine       = NULL;
    BYTE    *pEndLine       = NULL;

    LONG    lXEndSize = lBytesPerPixel * lDestWidth;

    LONG    lXNum = lSrcWidth;      // Numerator in X direction
    LONG    lXDen = lDestWidth;     // Denomiator in X direction
    LONG    lXInc = (lXNum / lXDen) * lBytesPerPixel;  // Increment in X direction

    LONG    lXDeltaInc = lXNum % lXDen;     // DeltaIncrement in X direction
    LONG    lXRem = 0;              // Remainder in X direction

    LONG    lYNum = lSrcHeight;     // Numerator in Y direction
    LONG    lYDen = lDestHeight;    // Denomiator in Y direction
    LONG    lYInc = (lYNum / lYDen) * lSrcWidthInBytes; // Increment in Y direction
    LONG    lYDeltaInc = lYNum % lYDen;     // DeltaIncrement in Y direction
    LONG    lYDestInc = lDestWidthInBytes;
    LONG    lYRem = 0;              // Remainder in Y direction

    pSrcLine    = pSrcBuffer;       // This is where we start in the source
    pDestLine   = pDestBuffer;      // This is the start of the destination buffer
                                    // This is where we end overall
    pEndLine    = pDestBuffer + (lDestWidthInBytes * lDestHeight);

    while (pDestLine < pEndLine) {  // Start LoopY (Decides where the src and dest lines start)

        pSrcPixel   = pSrcLine;     // We're starting at the beginning of a new line
        pDestPixel  = pDestLine;
                                    // Calc. where we end the line
        pEnd = pDestPixel + lXEndSize;
        lXRem = 0;                  // Reset the remainder for the horizontal direction

        while (pDestPixel < pEnd) {     // Start LoopX (puts pixels in the destination line)

                                        // Put the pixel
            if (lBytesPerPixel > 1) {
                pDestPixel[0] = pSrcPixel[0];
                pDestPixel[1] = pSrcPixel[1];
                pDestPixel[2] = pSrcPixel[2];
            } else {
                *pDestPixel = *pSrcPixel;
            }
                                        // Move the destination pointer to the next pixel
            pDestPixel += lBytesPerPixel;
            pSrcPixel += lXInc;         // Move the source pointer over by the horizontal increment
            lXRem += lXDeltaInc;        // Increase the horizontal remainder - this decides when we "overflow"

            if (lXRem >= lXDen) {       // This is our "overflow" condition.  It means we're now one
                                        // pixel off.
                                        // In Overflow case, we need to shift one pixel over
                pSrcPixel += lBytesPerPixel;
                lXRem -= lXDen;         // Decrease the remainder by the X denominator.  This is essentially
                                        // lXRem MOD lXDen.
            }
        }                               // End LoopX   (puts pixels in the destination line)

        pSrcLine += lYInc;          // We've finished a horizontal line, time to move to the next one
        lYRem += lYDeltaInc;        // Increase our vertical remainder.  This decides when we "overflow"

        if (lYRem > lYDen) {        // This is our vertical overflow condition.
                                    // We need to move to the next line down
            pSrcLine += lSrcWidthInBytes;
            lYRem -= lYDen;         // Decrease the remainder by the Y denominator.    This is essentially
                                    // lYRem MOD lYDen.
        }
        pDestLine += lYDestInc;     // Move the destination pointer to the start of the next line in the
                                    // destination buffer
    }                               // End LoopY   (Decides where the src and dest lines start)
    return S_OK;
}

/**************************************************************************\
* AllocReadRegistryString
*
*   This function reads a REG_SZ value from the registry.  The memory for
*   the srting value ius allocated with new.  The caller should use
*   "delete" when it is finished with it.
*
* Arguments:
*
*   hKey                - Registry key to read from
*   *wszValueName       - Value to read
*   **pwszReturnValue   - Addess of pointer that will receive the allocated
*                           string
*
* Return Value:
*
*   Status.
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
HRESULT AllocReadRegistryString(
    HKEY    hKey,
    WCHAR   *wszValueName,
    WCHAR   **pwszReturnValue)
{
    HRESULT hr      = S_OK;
    DWORD   dwError = 0;
    DWORD   cbData  = 0;
    DWORD   dwType  = REG_SZ;

    if (!wszValueName || !pwszReturnValue) {
        DBG_WRN(("::AllocReadRegistryString, NULL parameter"));
        return E_INVALIDARG;
    }

    *pwszReturnValue = NULL;

    //
    //  Get the number of bytes neded to store the string value.
    //
    dwError = RegQueryValueExW(hKey,
                               wszValueName,
                               NULL,
                               &dwType,
                               NULL,
                               &cbData);
    if (dwError == ERROR_SUCCESS) {

        //
        //  Allocate the correct number of bytes (leave space for terminator)
        //
        *pwszReturnValue = (WCHAR*) new BYTE[cbData + sizeof(L"\0")];
        if (*pwszReturnValue) {
            memset(*pwszReturnValue, 0, cbData + sizeof(L"\0"));

            //
            //  Get the string
            //
            dwError = RegQueryValueExW(hKey,
                                       wszValueName,
                                       NULL,
                                       &dwType,
                                       (LPBYTE)(*pwszReturnValue),
                                       &cbData);
            if (dwError == ERROR_SUCCESS) {
            } else {
                DBG_WRN(("::AllocReadRegistryString, second RegQueryValueExW returned %d", dwError));
                hr = HRESULT_FROM_WIN32(dwError);
            }
        } else {
            DBG_WRN(("::AllocReadRegistryString, Out of memory!"));
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = S_FALSE;
    }

    if (hr != S_OK) {
        if (*pwszReturnValue) {
            delete[] *pwszReturnValue;
        }
        *pwszReturnValue = NULL;
    }

    return hr;
}

/**************************************************************************\
* AllocCopyString
*
*   This function copies a widestring.  The memory for the string is
*   allocated with new.  The caller should use "delete" to free the string
*   when it is finished with it.
*
* Arguments:
*
*   wszString   -   WideString to copy.
*
* Return Value:
*
*   Pointer to newly allocated string.   Null otherwise.
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
WCHAR*  AllocCopyString(
    WCHAR*  wszString)
{
    WCHAR   *wszOut = NULL;
    ULONG   ulLen   = 0;

    //
    //  Get length of string including terminating NULL
    //
    ulLen = lstrlenW(wszString) + 2;

    //
    //  Allocate memory for the string
    //
    wszOut = new WCHAR[ulLen];
    if (wszOut) {

        //
        //  Copy it
        //
        lstrcpynW(wszOut, wszString, ulLen);
    }
    return wszOut;
}

/**************************************************************************\
* AllocCatString
*
*   This function concatenates 2 strings.  The memory for the string is
*   allocated with new.  The caller should use "delete []" to free the string
*   when it is finished with it.
*
* Arguments:
*
*   wszString1   -   First WideString.
*   wszString2   -   Second WideString to add to first.
*
* Return Value:
*
*   Pointer to newly allocated string.   Null otherwise.
*
* History:
*
*    16/02/2001 Original Version
*
\**************************************************************************/
WCHAR*  AllocCatString(WCHAR* wszString1, WCHAR* wszString2)
{
    WCHAR   *wszOut = NULL;
    ULONG   ulLen   = 0;

    //ASSERT (!wszString1 && !wszString2)
    //
    //  Get length of string including terminating NULL
    //
    ulLen = lstrlenW(wszString1) + lstrlenW(wszString2) + 1;

    //
    //  Allocate memory for the string
    //
    wszOut = new WCHAR[ulLen];
    if (wszOut) {

        //
        //  Copy 1st string
        //
        lstrcpynW(wszOut, wszString1, ulLen);

        //
        //  Concatenate the strings
        //
        lstrcpynW(wszOut + lstrlenW(wszOut), wszString2, ulLen - lstrlenW(wszOut));

        //
        //  Always terminate the string
        //
        wszOut[ulLen - 1] = L'\0';
    }
    return wszOut;
}

/**************************************************************************\
* ReadRegistryDWORD
*
*   This function reads a dword value from the registry.
*
* Arguments:
*
*   hKey            -   Registry key to read from
*   wszValueName    -   Value to read from key
*   pdwReturnValue  -   Address of variable to receive the data
*
* Return Value:
*
*   Status
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
HRESULT ReadRegistryDWORD(
    HKEY    hKey,
    WCHAR   *wszValueName,
    DWORD   *pdwReturnValue)
{
    HRESULT hr      = S_OK;
    DWORD   dwError = 0;
    DWORD   cbData  = sizeof(DWORD);
    DWORD   dwType  = REG_DWORD;

    if (!pdwReturnValue || !wszValueName) {
        DBG_WRN(("::ReadRegistryDWORD called with NULL"));
        return E_UNEXPECTED;
    }

    *pdwReturnValue = 0;
    dwError = RegQueryValueExW(hKey,
                               wszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)pdwReturnValue,
                               &cbData);
    if (dwError != ERROR_SUCCESS) {

        DBG_TRC(("::ReadRegistryDWORD, RegQueryValueExW returned %d", dwError));
        hr = HRESULT_FROM_WIN32(dwError);
    }
    if (FAILED(hr)) {
        *pdwReturnValue = 0;
    }

    return hr;
}

/**************************************************************************\
* CreateDevInfoFromHKey
*
*   This function creates and fills out a DEVICE_INFO struct.  Most of
*   the information is read from the registry.  This is called for Devnode
*   and interface devices (volume devices don't have registry entries)
*
* Arguments:
*
*   hKeyDev             - Device registry key
*   dwDeviceState       - The device state
*   pspDevInfoData      - The devnode data
*   pspDevInterfaceData - The interface data - will be NULL for devnode
*                           devices.
* Return Value:
*
*   Pointer to newly created DEVICE_INFO struct.  NULL if one could not
*   be allocated.
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
DEVICE_INFO* CreateDevInfoFromHKey(
    HKEY                        hKeyDev,
    DWORD                       dwDeviceState,
    SP_DEVINFO_DATA             *pspDevInfoData,
    SP_DEVICE_INTERFACE_DATA    *pspDevInterfaceData)
{
    HRESULT     hr              = E_OUTOFMEMORY;
    DEVICE_INFO *pDeviceInfo    = NULL;
    HKEY        hDeviceDataKey  = NULL;
    DWORD       dwMajorType     = 0;
    DWORD       dwMinorType     = 0;
    BOOL        bFatalError     = FALSE;

    DWORD dwTemp;
    WCHAR *wszTemp = NULL;


    pDeviceInfo = new DEVICE_INFO;
    if (!pDeviceInfo) {
        DBG_WRN(("CWiaDevMan::CreateDevInfoFromHKey, Out of memory"));
        return NULL;
    }
    memset(pDeviceInfo, 0, sizeof(DEVICE_INFO));
    pDeviceInfo->bValid         = FALSE;
    pDeviceInfo->dwDeviceState  = dwDeviceState;
    //
    //  Copy the SP_DEVINFO_DATA and SP_DEVICE_INTERFACE_DATA
    //
    if (pspDevInfoData) {
        memmove(&pDeviceInfo->spDevInfoData, pspDevInfoData, sizeof(SP_DEVINFO_DATA));
        if (pspDevInterfaceData) {
            memmove(&pDeviceInfo->spDevInterfaceData, pspDevInterfaceData, sizeof(SP_DEVICE_INTERFACE_DATA));
        }
    }

    //
    //  NOTE:  To avoid any alignment faults, we read into &wszTemp, then assign wszTemp to
    //  the appropriate structure member.
    //
    hr = AllocReadRegistryString(hKeyDev, REGSTR_VAL_DEVICE_ID_W, &wszTemp);
    if (FAILED(hr)) {
        DBG_WRN(("::CreateDevInfoFromHKey, Failed to read %ws, fatal for this device (NULL name)", REGSTR_VAL_DEVICE_ID_W));
        bFatalError = TRUE;
    } else {
        pDeviceInfo->wszDeviceInternalName = wszTemp;
    }
    hr = AllocReadRegistryString(hKeyDev, REGSTR_VAL_DEVICE_ID_W, &wszTemp);
    if (FAILED(hr)) {
        DBG_WRN(("::CreateDevInfoFromHKey, Failed to read %ws (remote), fatal for this device (NULL name)", REGSTR_VAL_DEVICE_ID_W));
        bFatalError = TRUE;
    } else {
        pDeviceInfo->wszDeviceRemoteName = wszTemp;
    }
    hr = AllocReadRegistryString(hKeyDev, REGSTR_VAL_USD_CLASS_W, &wszTemp);
    if (FAILED(hr)) {
        DBG_WRN(("::CreateDevInfoFromHKey, Failed to read %ws, fatal for this device (%ws)", REGSTR_VAL_USD_CLASS_W, pDeviceInfo->wszDeviceInternalName));
        bFatalError = TRUE;
    } else {
        pDeviceInfo->wszUSDClassId = wszTemp;
    }
    hr = AllocReadRegistryString(hKeyDev, REGSTR_VAL_VENDOR_NAME_W, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", REGSTR_VAL_VENDOR_NAME_W, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->wszVendorDescription = wszTemp;
    }
    hr = AllocReadRegistryString(hKeyDev, REGSTR_VAL_DEVICE_NAME_W, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", REGSTR_VAL_DEVICE_NAME_W, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->wszDeviceDescription = wszTemp;
    }
    hr = AllocReadRegistryString(hKeyDev, REGSTR_VAL_DEVICEPORT_W, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", REGSTR_VAL_DEVICEPORT_W, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->wszPortName = wszTemp;
    }
    hr = AllocReadRegistryString(hKeyDev, REGSTR_VAL_PROP_PROVIDER_W, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", REGSTR_VAL_PROP_PROVIDER_W, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->wszPropProvider = wszTemp;
    }
    hr = AllocReadRegistryString(hKeyDev, REGSTR_VAL_FRIENDLY_NAME_W, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", REGSTR_VAL_FRIENDLY_NAME_W, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->wszLocalName = wszTemp;
    }
    hr = ReadRegistryDWORD(hKeyDev, REGSTR_VAL_HARDWARE_W, &dwTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", REGSTR_VAL_HARDWARE_W, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->dwHardwareConfiguration = dwTemp;
    }
    hr = ReadRegistryDWORD(hKeyDev, REGSTR_VAL_DEVICETYPE_W, &dwMajorType);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", REGSTR_VAL_DEVICETYPE_W, pDeviceInfo->wszDeviceInternalName));
    }
    hr = ReadRegistryDWORD(hKeyDev, REGSTR_VAL_DEVICESUBTYPE_W, &dwMinorType);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", REGSTR_VAL_DEVICESUBTYPE_W, pDeviceInfo->wszDeviceInternalName));
    }
    pDeviceInfo->DeviceType = MAKELONG(dwMinorType,dwMajorType);
    hr = ReadRegistryDWORD(hKeyDev, REGSTR_VAL_GENERIC_CAPS_W, &dwTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", REGSTR_VAL_GENERIC_CAPS_W, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->DeviceCapabilities.dwGenericCaps = dwTemp;
    }

    //
    // Set the Internal Device type
    //

    pDeviceInfo->dwInternalType = INTERNAL_DEV_TYPE_REAL;
    if (pDeviceInfo->DeviceCapabilities.dwGenericCaps & STI_GENCAP_WIA) {
        pDeviceInfo->dwInternalType |= INTERNAL_DEV_TYPE_WIA;
    }
    if (pspDevInterfaceData) {
        pDeviceInfo->dwInternalType |= INTERNAL_DEV_TYPE_INTERFACE;
    }

    //
    //  Read everything we can from DeviceData section under Device Registry Key
    //

    hr = RegCreateKeyExW(hKeyDev, REGSTR_VAL_DATA_W, NULL, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                         NULL, &hDeviceDataKey, NULL);
    hr = AllocReadRegistryString(hDeviceDataKey, WIA_DIP_SERVER_NAME_STR, &wszTemp);
    if (FAILED(hr)) {
        DBG_WRN(("::CreateDevInfoFromHKey, Failed to read %ws, fatal for device (%ws)", WIA_DIP_SERVER_NAME_STR, pDeviceInfo->wszDeviceInternalName));
        bFatalError = TRUE;
    } else {
        pDeviceInfo->wszServer = wszTemp;
        if (!pDeviceInfo->wszServer) {
            pDeviceInfo->wszServer = AllocCopyString(LOCAL_DEVICE_STR);
        }
        if (pDeviceInfo->wszServer) {
            if (lstrcmpiW(pDeviceInfo->wszServer, LOCAL_DEVICE_STR) == 0) {
                //
                //  Mark this device as being local
                //
                pDeviceInfo->dwInternalType |= INTERNAL_DEV_TYPE_LOCAL;
            }
        }
    }
    hr = AllocReadRegistryString(hDeviceDataKey, WIA_DIP_UI_CLSID_STR, &wszTemp);
    if (FAILED(hr)) {
        DBG_WRN(("::CreateDevInfoFromHKey, Failed to read %ws, fatal for device (%ws)", WIA_DIP_SERVER_NAME_STR, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->wszUIClassId = wszTemp;
        if (!pDeviceInfo->wszUIClassId) {
            pDeviceInfo->wszUIClassId = AllocCopyString(DEF_UI_CLSID_STR);
        }
    }
    hr = AllocReadRegistryString(hDeviceDataKey, REGSTR_VAL_BAUDRATE, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", REGSTR_VAL_BAUDRATE, pDeviceInfo->wszDeviceInternalName));
    } else {

        if (( pDeviceInfo->dwHardwareConfiguration & STI_HW_CONFIG_SERIAL ) &&
            (hr == S_FALSE)) {
                //
                // Only for serial devices we need to set default baud rate in case it is not set in the
                // registry.
                pDeviceInfo->wszBaudRate =  AllocCopyString(DEF_BAUD_RATE_STR);
        } else {
            pDeviceInfo->wszBaudRate = wszTemp;
        }
        DBG_TRC(("::CreateDevInfoFromHKey, Read baud rate %ws ",pDeviceInfo->wszBaudRate));
    }
    hr = ReadRegistryDWORD(hDeviceDataKey, STI_DEVICE_VALUE_HOLDINGTIME_W, &dwTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", STI_DEVICE_VALUE_HOLDINGTIME_W, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->dwLockHoldingTime = dwTemp;
    }
    hr = ReadRegistryDWORD(hDeviceDataKey, STI_DEVICE_VALUE_TIMEOUT, &dwTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", STI_DEVICE_VALUE_TIMEOUT, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->dwPollTimeout = dwTemp;
    }
    hr = ReadRegistryDWORD(hDeviceDataKey, STI_DEVICE_VALUE_DISABLE_NOTIFICATIONS, &dwTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", STI_DEVICE_VALUE_DISABLE_NOTIFICATIONS, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->dwDisableNotifications = dwTemp;
    }
    RegCloseKey(hDeviceDataKey);

    if (!bFatalError) {
        pDeviceInfo->bValid = TRUE;
    } else {
        DBG_WRN(("::CreateDevInfoFromHKey, marking device info. as invalid"));
    }

    return pDeviceInfo;
}

/**************************************************************************\
* RefreshDevInfoFromHKey
*
*   This function refreshes fields that are subject to change
*
* Arguments:
*
*   pDeviceInfo         - Pointer to the DEVICE_INFO struct to update
*   hKeyDev             - Device registry key
*   dwDeviceState       - The new device state
*   pspDevInfoData      - The devnode data
*   pspDevInterfaceData - The interface data - will be NULL for devnode
*                           devices.
*
* Return Value:
*
*   True    -   Everything successfully updated
*   False   -   Could not update
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
BOOL RefreshDevInfoFromHKey(
    DEVICE_INFO                 *pDeviceInfo,
    HKEY                        hKeyDev,
    DWORD                       dwDeviceState,
    SP_DEVINFO_DATA             *pspDevInfoData,
    SP_DEVICE_INTERFACE_DATA    *pspDevInterfaceData)
{
    HRESULT     hr              = E_OUTOFMEMORY;
    BOOL        Succeeded       = TRUE;

    WCHAR       *wszTemp        = NULL;

    //
    //  Set new device state
    //
    pDeviceInfo->dwDeviceState  = dwDeviceState;

    //
    //  Copy the SP_DEVINFO_DATA and SP_DEVICE_INTERFACE_DATA
    //

    if (pspDevInfoData) {
        memcpy(&pDeviceInfo->spDevInfoData, pspDevInfoData, sizeof(SP_DEVINFO_DATA));
        if (pspDevInterfaceData) {
            memcpy(&pDeviceInfo->spDevInterfaceData, pspDevInterfaceData, sizeof(SP_DEVICE_INTERFACE_DATA));
        }
    }

    //
    //  Set new port name.  First free the old one if it exists
    //
    if (pDeviceInfo->wszPortName) {
        delete [] pDeviceInfo->wszPortName;
        pDeviceInfo->wszPortName = NULL;
    }
    hr = AllocReadRegistryString(hKeyDev, REGSTR_VAL_DEVICEPORT_W, &wszTemp);
    if (FAILED(hr)) {
        DBG_WRN(("::RefreshDevInfoFromHKey, Failed to update %ws, may be fatal for device (%ws)", REGSTR_VAL_DEVICEPORT_W, pDeviceInfo->wszDeviceInternalName));
        Succeeded = FALSE;
    } else {
        pDeviceInfo->wszPortName = wszTemp;
    }

    //
    //  Grab new Local name.  First free the old one...
    //
    if (pDeviceInfo->wszLocalName) {
        delete [] pDeviceInfo->wszLocalName;
        pDeviceInfo->wszLocalName = NULL;
    }
    hr = AllocReadRegistryString(hKeyDev, REGSTR_VAL_FRIENDLY_NAME_W, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::RefreshDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", REGSTR_VAL_FRIENDLY_NAME_W, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->wszLocalName = wszTemp;
    }

    //
    //  Grab new Device Description.  First free the old one...
    //
    if (pDeviceInfo->wszDeviceDescription) {
        delete [] pDeviceInfo->wszDeviceDescription;
        pDeviceInfo->wszDeviceDescription = NULL;
    }
    hr = AllocReadRegistryString(hKeyDev, REGSTR_VAL_DEVICE_NAME_W, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::RefreshDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", REGSTR_VAL_DEVICE_NAME_W, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->wszDeviceDescription = wszTemp;
    }

    return Succeeded;
}

/**************************************************************************\
* RefreshDevInfoFromMountPoint
*
*   This function refreshes fields that are subject to change for volume
*   devices.
*
* Arguments:
*
*   pDeviceInfo         - Pointer to the DEVICE_INFO struct to update
*
* Return Value:
*
*   True    -   Everything successfully updated
*   False   -   Could not update
*
* History:
*
*    16/03/2001 Original Version
*
\**************************************************************************/
BOOL RefreshDevInfoFromMountPoint(
    DEVICE_INFO                 *pDeviceInfo,
    WCHAR                       *wszMountPoint)
{
    HRESULT     hr              = E_OUTOFMEMORY;
    BOOL        Succeeded       = TRUE;

    WCHAR       wszLabel[MAX_PATH];

    //
    //  Grab the friendly name of the FS device
    //

    hr = GetMountPointLabel(wszMountPoint, wszLabel, sizeof(wszLabel) / sizeof(wszLabel[0]));
    if (FAILED(hr)) {
        DBG_WRN(("RefreshDevInfoFromMountPoint, GetMountPointLabel failed - could not get display name - using mount point instead"));
        lstrcpynW(wszLabel, wszMountPoint, sizeof(wszLabel) / sizeof(wszLabel[0]));
    }

    //
    //  Update the appropriate fields that rely on the display name.
    //
    if (pDeviceInfo->wszVendorDescription) {
        delete [] pDeviceInfo->wszVendorDescription;
        pDeviceInfo->wszVendorDescription = NULL;
    }
    if (pDeviceInfo->wszDeviceDescription) {
        delete [] pDeviceInfo->wszDeviceDescription;
        pDeviceInfo->wszDeviceDescription = NULL;
    }
    if (pDeviceInfo->wszLocalName) {
        delete [] pDeviceInfo->wszLocalName;
        pDeviceInfo->wszLocalName = NULL;
    }

    pDeviceInfo->wszVendorDescription   = AllocCopyString(wszLabel);
    pDeviceInfo->wszDeviceDescription   = AllocCopyString(wszLabel);
    pDeviceInfo->wszLocalName           = AllocCopyString(wszLabel);

    return Succeeded;
}


/**************************************************************************\
* CreateDevInfoForFSDriver
*
*   Create a device info struct containing all the relevant info for our
*   volume devices.
*
* Arguments:
*
*   wszMountPoint   - The mount point of this volume
*
* Return Value:
*
*   Pointer to a newly created DEVICE_INFO.  NULL on error.
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
DEVICE_INFO* CreateDevInfoForFSDriver(WCHAR *wszMountPoint)
{
    HRESULT     hr              = E_OUTOFMEMORY;
    DEVICE_INFO *pDeviceInfo    = NULL;
    BOOL        bFatalError     = FALSE;
    DWORD       dwMajorType     = StiDeviceTypeDigitalCamera;
    DWORD       dwMinorType     = 1;

    WCHAR       wszDevId[STI_MAX_INTERNAL_NAME_LENGTH];
    WCHAR       wszLabel[MAX_PATH];

    pDeviceInfo = new DEVICE_INFO;
    if (!pDeviceInfo) {
        DBG_WRN(("CWiaDevMan::CreateDevInfoForFSDriver, Out of memory"));
        return NULL;
    }
    memset(pDeviceInfo, 0, sizeof(DEVICE_INFO));
    memset(wszDevId, 0, sizeof(wszDevId));

    //
    //  Grab the friendly name of the FS device
    //

    hr = GetMountPointLabel(wszMountPoint, wszLabel, sizeof(wszLabel) / sizeof(wszLabel[0]));
    if (FAILED(hr)) {
        DBG_WRN(("CWiaDevMan::CreateDevInfoForFSDriver, GetMountPointLabel failed - could not get display name - using mount point instead"));
        lstrcpynW(wszLabel, wszMountPoint, sizeof(wszLabel) / sizeof(wszLabel[0]));
    }

    pDeviceInfo->bValid         = FALSE;
    pDeviceInfo->dwDeviceState  = 0;

    pDeviceInfo->wszAlternateID         = AllocCopyString(wszMountPoint);
    if (!pDeviceInfo->wszAlternateID) {
        DBG_WRN(("::CreateDevInfoForFSDriver, out of memory allocating wszAlternateID"));
        bFatalError = TRUE;
    }

    //
    //  Construct Device ID.  Device ID looks like:
    //  {MountPoint}
    //  e.g. {e:\}
    //

    lstrcpyW(wszDevId, L"{");
    //
    //  We don't want to overrun our internal name length constarint, so we first check
    //  to see whether the string length of wszMountPoint is short enough to allow concatenation
    //  of {, }, wszMountPoint and NULL terminator, and still fit all this into a string of
    //  length STI_MAX_INTERNAL_NAME_LENGTH.
    //  Note the space after the brackets in sizeof(L"{} ").
    //
    if (lstrlenW(wszMountPoint) > (STI_MAX_INTERNAL_NAME_LENGTH - (sizeof(L"{} ") / sizeof(WCHAR)))) {
        //
        //  The name is too long, so we just insert our own name instead
        //
        lstrcatW(wszDevId, L"NameTooLong");
    } else {
        lstrcatW(wszDevId, wszMountPoint);
    }
    lstrcatW(wszDevId, L"}");

    pDeviceInfo->wszDeviceInternalName  = AllocCopyString(wszDevId);
    if (!pDeviceInfo->wszAlternateID) {
        DBG_WRN(("::CreateDevInfoForFSDriver, out of memory allocating wszDeviceInternalName"));
        bFatalError = TRUE;
    }
    pDeviceInfo->wszDeviceRemoteName  = AllocCopyString(wszDevId);
    if (!pDeviceInfo->wszDeviceRemoteName) {
        DBG_WRN(("::CreateDevInfoForFSDriver, out of memory allocating wszDeviceRemoteName"));
        bFatalError = TRUE;
    }
    pDeviceInfo->wszPortName            = AllocCopyString(wszMountPoint);
    if (!pDeviceInfo->wszPortName) {
        DBG_WRN(("::CreateDevInfoForFSDriver, out of memory allocating wszPortName"));
        bFatalError = TRUE;
    }
    pDeviceInfo->wszUSDClassId          = AllocCopyString(FS_USD_CLSID);
    if (!pDeviceInfo->wszUSDClassId) {
        DBG_WRN(("::CreateDevInfoForFSDriver, out of memory allocating wszUSDClassId"));
        bFatalError = TRUE;
    }

    //
    //  We can't get the manufacturer string for these devices, so
    //  load our standard Manufacturer resource string
    //  (something like "(Not available)").
    //
    WCHAR   wszManufacturer[32];

    INT  iRet = LoadStringW(g_hInst,
                           IDS_MSC_MANUFACTURER_STR,
                           wszManufacturer,
                           sizeof(wszManufacturer)/sizeof(wszManufacturer[0]));
    if (iRet) {
        pDeviceInfo->wszVendorDescription   = AllocCopyString(wszManufacturer);
    } else {
        //
        //  Can't load it, so give it an empty string
        //
        pDeviceInfo->wszVendorDescription   = AllocCopyString(L"");
    }
    pDeviceInfo->wszDeviceDescription   = AllocCopyString(wszLabel);
    pDeviceInfo->wszLocalName           = AllocCopyString(wszLabel);
    pDeviceInfo->wszServer              = AllocCopyString(LOCAL_DEVICE_STR);
    pDeviceInfo->wszBaudRate            = NULL;
    pDeviceInfo->wszUIClassId           = AllocCopyString(FS_UI_CLSID);

    pDeviceInfo->dwDeviceState                      = DEV_STATE_ACTIVE;
    pDeviceInfo->DeviceType                         = MAKELONG(dwMinorType,dwMajorType);
    pDeviceInfo->dwLockHoldingTime                  = 0;
    pDeviceInfo->dwPollTimeout                      = 0;
    pDeviceInfo->dwDisableNotifications             = 0;
    pDeviceInfo->DeviceCapabilities.dwVersion       = STI_VERSION_REAL;
    pDeviceInfo->DeviceCapabilities.dwGenericCaps   = STI_GENCAP_WIA;
    pDeviceInfo->dwHardwareConfiguration            = HEL_DEVICE_TYPE_WDM;
    pDeviceInfo->dwInternalType                     = INTERNAL_DEV_TYPE_WIA | INTERNAL_DEV_TYPE_LOCAL;
    //
    //  Check whther this volume is really a camera device representing
    //  itself as a volume...
    //
    if (IsMassStorageCamera(wszMountPoint)) {
        pDeviceInfo->dwInternalType                     |= INTERNAL_DEV_TYPE_MSC_CAMERA;

        //
        //  Here is a good time to set up the Device's registry entries.  We'll call
        //  g_pDevMan->GetHKeyFromMountPoint(..), since this has the effect of creating
        //  the keys if the don't exist.
        //
        HKEY hKeyDev = g_pDevMan->GetHKeyFromMountPoint(wszMountPoint);
        if (hKeyDev) {
            RegCloseKey(hKeyDev);
        }
    } else {
        pDeviceInfo->dwInternalType                     |= INTERNAL_DEV_TYPE_VOL;
    }

    if (!bFatalError) {
        pDeviceInfo->bValid = TRUE;
    } else {
        pDeviceInfo->bValid = FALSE;
    }

    return pDeviceInfo;
}


/**************************************************************************\
* CreateDevInfoForRemoteDevice
*
*   Create a device info struct containing all the relevant info for our
*   remote devices.
*
* Arguments:
*
*   hKeyDev             - Device registry key
*
* Return Value:
*
*   Pointer to a newly created DEVICE_INFO.  NULL on error.
*
* History:
*
*    15/02/2001 Original Version
*
\**************************************************************************/
DEVICE_INFO* CreateDevInfoForRemoteDevice(
    HKEY    hKeyDev)
{
    HRESULT     hr              = E_OUTOFMEMORY;
    DEVICE_INFO *pDeviceInfo    = NULL;
    BOOL        bFatalError     = FALSE;

    DWORD dwTemp;
    WCHAR *wszTemp = NULL;


    pDeviceInfo = new DEVICE_INFO;
    if (!pDeviceInfo) {
        DBG_WRN(("::CreateDevInfoForRemoteDevice, Out of memory"));
        return NULL;
    }
    memset(pDeviceInfo, 0, sizeof(DEVICE_INFO));
    pDeviceInfo->bValid         = FALSE;

    //
    //  Always assume remote devices are ACTIVE
    //
    pDeviceInfo->dwDeviceState  = DEV_STATE_ACTIVE;


    //
    //  NOTE:  To avoid any alignment faults, we read into &wszTemp, then assign wszTemp to
    //  the appropriate structure member.
    //
    hr = AllocReadRegistryString(hKeyDev, WIA_DIP_SERVER_NAME_STR, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, fatal for device (%ws)", WIA_DIP_SERVER_NAME_STR, pDeviceInfo->wszServer));
        bFatalError = TRUE;
    } else {
        pDeviceInfo->wszServer = wszTemp;
    }
    hr = AllocReadRegistryString(hKeyDev, WIA_DIP_REMOTE_DEV_ID_STR, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, fatal for device (%ws)", WIA_DIP_REMOTE_DEV_ID_STR, pDeviceInfo->wszDeviceRemoteName));
        bFatalError = TRUE;
    } else {
        pDeviceInfo->wszDeviceRemoteName = wszTemp;
    }
    pDeviceInfo->wszDeviceInternalName = AllocCatString(pDeviceInfo->wszServer, pDeviceInfo->wszDeviceRemoteName);
    if (!pDeviceInfo->wszDeviceInternalName) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed allocate memory for Device Name, fatal for device (%ws)", pDeviceInfo->wszDeviceInternalName));
        bFatalError = TRUE;
    }
    hr = AllocReadRegistryString(hKeyDev, WIA_DIP_VEND_DESC_STR, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", WIA_DIP_VEND_DESC_STR, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->wszVendorDescription = wszTemp;
    }
    hr = AllocReadRegistryString(hKeyDev, WIA_DIP_DEV_NAME_STR, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", WIA_DIP_DEV_NAME_STR, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->wszLocalName = wszTemp;
    }
    hr = AllocReadRegistryString(hKeyDev, WIA_DIP_DEV_DESC_STR, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", WIA_DIP_DEV_DESC_STR, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->wszDeviceDescription = wszTemp;
    }
    hr = AllocReadRegistryString(hKeyDev, WIA_DIP_PORT_NAME_STR, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", WIA_DIP_PORT_NAME_STR, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->wszPortName = wszTemp;
    }
    hr = AllocReadRegistryString(hKeyDev, WIA_DIP_UI_CLSID_STR, &wszTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", WIA_DIP_UI_CLSID_STR, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->wszUIClassId = wszTemp;
    }
    hr = ReadRegistryDWORD(hKeyDev, WIA_DIP_DEV_TYPE_STR, &dwTemp);
    if (FAILED(hr)) {
        DBG_TRC(("::CreateDevInfoFromHKey, Failed to read %ws, non-fatal for device (%ws)", WIA_DIP_DEV_TYPE_STR, pDeviceInfo->wszDeviceInternalName));
    } else {
        pDeviceInfo->DeviceType = dwTemp;
    }
    pDeviceInfo->DeviceCapabilities.dwGenericCaps = STI_GENCAP_WIA;

    //
    // Set the Internal Device type
    //

    pDeviceInfo->dwInternalType = INTERNAL_DEV_TYPE_REAL | INTERNAL_DEV_TYPE_WIA;

    if (!bFatalError) {
        pDeviceInfo->bValid = TRUE;
    } else {

        //
        //  If it's not valid, free the memory
        //  TDB:  Remove the bValid field
        //
        DestroyDevInfo(pDeviceInfo);
        pDeviceInfo = NULL;
    }

    return pDeviceInfo;
}


/**************************************************************************\
* DestroyDevInfo
*
*   Frees up any resources help by the DEVICE_INFO struct (like strings).
*   It will then delete the structure itsself.
*
* Arguments:
*
*   pInfo   - Pointer to DEVICE_INFO struct
*
* Return Value:
*
*   None.
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
VOID DestroyDevInfo(DEVICE_INFO *pInfo)
{
    if (pInfo) {

        //
        //  Free struct members first
        //

        if (pInfo->wszAlternateID) {
            delete [] pInfo->wszAlternateID;
            pInfo->wszAlternateID = NULL;
        }
        if (pInfo->wszUSDClassId) {
            delete [] pInfo->wszUSDClassId;
            pInfo->wszUSDClassId = NULL;
        }
        if (pInfo->wszDeviceInternalName) {
            delete [] pInfo->wszDeviceInternalName;
            pInfo->wszDeviceInternalName = NULL;
        }
        if (pInfo->wszDeviceRemoteName) {
            delete [] pInfo->wszDeviceRemoteName;
            pInfo->wszDeviceRemoteName = NULL;
        }
        if (pInfo->wszVendorDescription) {
            delete [] pInfo->wszVendorDescription;
            pInfo->wszVendorDescription = NULL;
        }
        if (pInfo->wszDeviceDescription) {
            delete [] pInfo->wszDeviceDescription;
            pInfo->wszDeviceDescription = NULL;
        }
        if (pInfo->wszPortName) {
            delete [] pInfo->wszPortName;
            pInfo->wszPortName = NULL;
        }
        if (pInfo->wszPropProvider) {
            delete [] pInfo->wszPropProvider;
            pInfo->wszPropProvider = NULL;
        }
        if (pInfo->wszLocalName) {
            delete [] pInfo->wszLocalName;
            pInfo->wszLocalName = NULL;
        }
        if (pInfo->wszServer) {
            delete [] pInfo->wszServer;
            pInfo->wszServer = NULL;
        }
        if (pInfo->wszBaudRate) {
            delete [] pInfo->wszBaudRate;
            pInfo->wszBaudRate = NULL;
        }
        if (pInfo->wszUIClassId) {
            delete [] pInfo->wszUIClassId;
            pInfo->wszUIClassId = NULL;
        }

        //
        //  Now free the struct itsself.  NOTE:  The caller must
        //  not attempt to use this pointer again!
        //

        delete pInfo;

    }
}

/**************************************************************************\
* DumpDevInfo
*
*   Used for debugging, this dumps a few members of the DEVICE_INFO struct.
*
* Arguments:
*
*   pInfo   - Pointer to DEVICE_INFO struct
*
* Return Value:
*
*   None.
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
VOID DumpDevInfo(DEVICE_INFO *pInfo)
{
    if (pInfo) {
        DBG_PRT(("------------------------------------------------", pInfo));
        DBG_PRT(("::DumpDevInfo (0x%08X)", pInfo));
        //
        //  Output field values we're interested in
        //

        DBG_PRT(("\t\t bValid (%d)", pInfo->bValid));
        DBG_PRT(("\t\t wszLocalName \t(%ws)", pInfo->wszLocalName));
        DBG_PRT(("\t\t wszInternalName \t(%ws)", pInfo->wszDeviceInternalName));
        DBG_PRT(("\t\t wszRemoteName \t(%ws)", pInfo->wszDeviceRemoteName));
        DBG_PRT(("\t\t wszAlternateID \t(%ws)", pInfo->wszAlternateID));
        DBG_PRT(("\t\t wszPortName \t(%ws)", pInfo->wszPortName));
        DBG_PRT(("\t\t dwInternalType \t(%d)", pInfo->dwInternalType));
        DBG_PRT(("------------------------------------------------", pInfo));
    }
}

/**************************************************************************\
* CreateDevInfoStg
*
*   This helper method takes a DEVICE_INFO struct and creates an
*   IWiaPropertyStorage filled with the appropriate entries.
*
* Arguments:
*
*   pInfo   - Pointer to DEVICE_INFO struct
*
* Return Value:
*
*   Pointer to IWiaPropertyStorage.  Will be NULL on error.
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
IWiaPropertyStorage* CreateDevInfoStg(DEVICE_INFO *pInfo)
{
    CWIADevInfo *pWiaDevInfo    = NULL;
    HRESULT     hr              = E_FAIL;
    ULONG       ulIndex         = 0;
    WCHAR       *wszTmp         = NULL;
    PROPID      propid          = 0;
    PROPSPEC    propspec[WIA_NUM_DIP];
    PROPVARIANT propvar[WIA_NUM_DIP];
    WCHAR       wszVer[MAX_PATH];

    IWiaPropertyStorage *pIWiaPropStg = NULL;

    //
    //  Create the CWIADevInfo class
    //

    pWiaDevInfo = new CWIADevInfo();
    if (!pWiaDevInfo) {
        return NULL;
    }

    hr = pWiaDevInfo->Initialize();
    if (SUCCEEDED(hr)) {
        //
        //  Insert the properties
        //
        // Set the property specifications and data. Order must match DEVMANGR.IDL
        memset(propspec, 0, sizeof(PROPSPEC) * WIA_NUM_DIP);
        memset(propvar,  0, sizeof(VARIANT)  * WIA_NUM_DIP);
        memset(wszVer   ,0, sizeof(wszVer));

        for (ulIndex = 0; ulIndex < WIA_NUM_DIP; ulIndex++) {

            propid = g_piDeviceInfo[ulIndex];
            wszTmp = NULL;

            // Setup property specification.
            propspec[ulIndex].ulKind = PRSPEC_PROPID;
            propspec[ulIndex].propid = propid;

            propvar[ulIndex].vt      = VT_BSTR;
            propvar[ulIndex].bstrVal = NULL;

            switch (propid) {

                case WIA_DIP_DEV_ID:
                    wszTmp = pInfo->wszDeviceInternalName;
                    break;

                case WIA_DIP_REMOTE_DEV_ID:
                    wszTmp = pInfo->wszDeviceRemoteName;
                    break;

                case WIA_DIP_SERVER_NAME:
                    wszTmp = pInfo->wszServer;
                    break;

                case WIA_DIP_VEND_DESC:
                    wszTmp = pInfo->wszVendorDescription;
                    break;

                case WIA_DIP_DEV_DESC:
                    wszTmp = pInfo->wszDeviceDescription;
                    break;

                case WIA_DIP_DEV_TYPE:
                    propvar[ulIndex].vt = VT_I4;
                    propvar[ulIndex].lVal = (LONG) pInfo->DeviceType;
                    break;

                case WIA_DIP_PORT_NAME:
                    wszTmp = pInfo->wszPortName;
                    break;

                case WIA_DIP_DEV_NAME:
                    wszTmp = pInfo->wszLocalName;
                    break;

                case WIA_DIP_UI_CLSID:
                    wszTmp = pInfo->wszUIClassId;
                    break;

                case WIA_DIP_HW_CONFIG:
                    propvar[ulIndex].vt = VT_I4;
                    propvar[ulIndex].lVal = (LONG) pInfo->dwHardwareConfiguration;
                    break;

                case WIA_DIP_BAUDRATE:
                    wszTmp = pInfo->wszBaudRate;
                    break;

                case WIA_DIP_STI_GEN_CAPABILITIES:
                    propvar[ulIndex].vt = VT_I4;
                    propvar[ulIndex].lVal = (LONG) pInfo->DeviceCapabilities.dwGenericCaps;
                    break;

                case WIA_DIP_WIA_VERSION:
                    wsprintf(wszVer,L"%d.%d",LOWORD(STI_VERSION_REAL),HIWORD(STI_VERSION_REAL));
                    wszTmp = wszVer;
                    break;

                case WIA_DIP_DRIVER_VERSION:
                    if(FALSE == GetDriverDLLVersion(pInfo,wszVer,sizeof(wszVer))){
                        DBG_WRN(("GetDriverDLLVersion, unable to alloc get driver version resource information, defaulting to 0.0.0.0"));
                        lstrcpyW(wszVer,L"0.0.0.0");
                    }
                    wszTmp = wszVer;
                    break;

                default:
                    hr = E_FAIL;
                    DBG_ERR(("CreateDevInfoStg, Unknown device property"));
                    DBG_ERR(("  propid = %li",propid));
            }

            // Allocate and assign BSTR's.
            if (propvar[ulIndex].vt == VT_BSTR) {
                if (wszTmp) {
                    propvar[ulIndex].bstrVal = SysAllocString(wszTmp);
                    if (!propvar[ulIndex].bstrVal) {
                        DBG_WRN(("CreateDevInfoStg, unable to alloc dev info strings"));
                    }
                } else {
                    DBG_TRC(("CreateDevInfoStg, NULL device property string"));
                    DBG_TRC(("  propid = %li",propid));
                    propvar[ulIndex].bstrVal = SysAllocString(L"Empty");
                }
            }
        }

        IPropertyStorage *pIPropStg = pWiaDevInfo->m_pIPropStg;

        if (pIPropStg) {
            // Set the device information properties.
            hr = pIPropStg->WriteMultiple(WIA_NUM_DIP,
                                          propspec,
                                          propvar,
                                          WIA_DIP_FIRST);
            // Write the property names.
            if (SUCCEEDED(hr)) {
                hr = pIPropStg->WritePropertyNames(WIA_NUM_DIP,
                                                   g_piDeviceInfo,
                                                   g_pszDeviceInfo);
                if (SUCCEEDED(hr)) {
                    hr = pWiaDevInfo->QueryInterface(IID_IWiaPropertyStorage, (void**) &pIWiaPropStg);
                } else {
                    DBG_WRN(("CreateDevInfoStg, WritePropertyNames Failed (0x%X)", hr));
                }
            }
            else {
                ReportReadWriteMultipleError(hr, "CreateDevInfoStg", NULL, FALSE, WIA_NUM_DIP, propspec);
            }
        } else {
            DBG_WRN(("CreateDevInfoStg, IPropertyStorage is NULL"));
            hr = E_UNEXPECTED;
        }

        // Free the allocated BSTR's.
        FreePropVariantArray(WIA_NUM_DIP, propvar);
    }


    //
    //  On failure, delete pWiaDevInfo
    //
    if (FAILED(hr)) {
        if (pWiaDevInfo) {
            delete pWiaDevInfo;
            pWiaDevInfo = NULL;
            pIWiaPropStg = NULL;
        }
    }
    return pIWiaPropStg;
}

/**************************************************************************\
* _CoCreateInstanceInConsoleSession
*
*   This helper function acts the same as CoCreateInstance, but will launch
*   a out-of-process COM server on the correct user's desktop, taking
*   fast user switching into account. (Normal CoCreateInstance will
*   launch it on the first logged on user's desktop, instead of the currently
*   logged on one).
*
*   This code was taken with permission from the Shell's Hardware
*   Notification service, on behalf of StephStm.
*
* Arguments:
*
*  rclsid,      // Class identifier (CLSID) of the object
*  pUnkOuter,   // Pointer to controlling IUnknown
*  dwClsContext // Context for running executable code
*  riid,        // Reference to the identifier of the interface
*  ppv          // Address of output variable that receives
*               //  the interface pointer requested in riid
*
* Return Value:
*
*   Status
*
* History:
*
*    03/01/2001 Original Version
*
\**************************************************************************/

HRESULT _CoCreateInstanceInConsoleSession(REFCLSID rclsid,
                                          IUnknown* punkOuter,
                                          DWORD dwClsContext,
                                          REFIID riid,
                                          void** ppv)
{
    IBindCtx    *pbc    = NULL;
    HRESULT     hr      = CreateBindCtx(0, &pbc);   // Create a bind context for use with Moniker

    //
    // Set the return
    //
    *ppv = NULL;

    if (SUCCEEDED(hr)) {
        WCHAR wszCLSID[39];

        //
        // Convert the riid to GUID string for use in binding to moniker
        //
        if (StringFromGUID2(rclsid, wszCLSID, sizeof(wszCLSID)/sizeof(wszCLSID[0]))) {
            ULONG       ulEaten     = 0;
            IMoniker*   pmoniker    = NULL;
            WCHAR       wszDisplayName[sizeof(SESSION_MONIKER)/sizeof(WCHAR) + sizeof(wszCLSID)/sizeof(wszCLSID[0]) + 2] = SESSION_MONIKER;

            //
            // We want something like: "Session:Console!clsid:760befd0-5b0b-44d7-957e-969af35ce954"
            // Notice that we don't want the leading and trailing brackets {..} around the GUID.
            // So, first get rid of trailing bracket by overwriting it with termintaing '\0'
            //
            wszCLSID[lstrlenW(wszCLSID) - 1] = L'\0';

            //
            // Form display name string.  To get rid of the leading bracket, we pass in the
            // address of the next character as the start of the string.
            //
            if (lstrcatW(wszDisplayName, &(wszCLSID[1]))) {

                //
                // Parse the name and get a moniker:
                //

                hr = MkParseDisplayName(pbc, wszDisplayName, &ulEaten, &pmoniker);
                if (SUCCEEDED(hr)) {
                    IClassFactory *pcf = NULL;

                    //
                    // Attempt to get the class factory
                    //
                    hr = pmoniker->BindToObject(pbc, NULL, IID_IClassFactory, (void**)&pcf);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Attempt to create the object
                        //
                        hr = pcf->CreateInstance(punkOuter, riid, ppv);

                        DBG_TRC(("_CoCreateInstanceInConsoleSession, pcf->CreateInstance returned: hr = 0x%08X", hr));
                        pcf->Release();
                    } else {

                        DBG_WRN(("_CoCreateInstanceInConsoleSession, pmoniker->BindToObject returned: hr = 0x%08X", hr));
                    }
                    pmoniker->Release();
                } else {
                    DBG_WRN(("_CoCreateInstanceInConsoleSession, MkParseDisplayName returned: hr = 0x%08X", hr));
                }
            } else {
                DBG_WRN(("_CoCreateInstanceInConsoleSession, string concatenation failed"));
                hr = E_INVALIDARG;
            }
        } else {
            DBG_WRN(("_CoCreateInstanceInConsoleSession, StringFromGUID2 failed"));
            hr = E_INVALIDARG;
        }

        pbc->Release();
    } else {
        DBG_WRN(("_CoCreateInstanceInConsoleSession, CreateBindCtxt returned: hr = 0x%08X", hr));
    }

    return hr;
}

/**************************************************************************\
* GetUserTokenForConsoleSession
*
*   This helper function will grab the currently logged on interactive
*   user's token, which can be used in a call to CreateProcessAsUser.
*   Caller is responsible for closing this Token handle.
*
*   It first grabs the impersontaed token from the current session (our
*   service runs in session 0, but with Fast User Switching, the currently
*   active user may be in a different session).  It then creates a
*   primary token from the impersonated one.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   HANDLE to Token for logged on user in the currently active session.
*   NULL otherwise.
*
* History:
*
*    03/05/2001 Original Version
*
\**************************************************************************/

HANDLE GetUserTokenForConsoleSession()
{
    HANDLE  hImpersonationToken = NULL;
    HANDLE  hTokenUser = NULL;


    //
    // Get interactive user's token
    //

    if (GetWinStationUserToken(GetCurrentSessionID(), &hImpersonationToken)) {

        //
        // Maybe nobody is logged on, so do a check first.
        //

        if (hImpersonationToken) {

            //
            //  We duplicate the token, since the returned token is an
            //  impersonated one, and we need it to be primary for
            //  use in CreateProcessAsUser.
            //
            if (!DuplicateTokenEx(hImpersonationToken,
                                  0,
                                  NULL,
                                  SecurityImpersonation,
                                  TokenPrimary,
                                  &hTokenUser)) {
                DBG_WRN(("CEventNotifier::StartCallbackProgram, DuplicateTokenEx failed!  GetLastError() = 0x%08X", GetLastError()));
            }
        } else {
            DBG_PRT(("CEventNotifier::StartCallbackProgram, No user appears to be logged on..."));
        }

    } else {
        DBG_WRN(("CEventNotifier::StartCallbackProgram, GetWinStationUserToken failed!  GetLastError() = 0x%08X", GetLastError()));
    }

    //
    //  Close the impersonated token, since we no longer need it.
    //
    if (hImpersonationToken) {
        CloseHandle(hImpersonationToken);
    }

    return hTokenUser;
}

/**************************************************************************\
* IsMassStorageCamera
*
*   This helper function will use the shell's CustomDeviceProperty API
*   to check whether a given volume device (represented by it's mount point)
*   reports itsself as a digital camera.
*
* Arguments:
*
*   wszMountPoint   - The mount point for a specified volume.
*
* Return Value:
*
*   TRUE  - The custom device property says this device is really a camera
*   FALSE - This device is not reported as a camera
*
* History:
*
*    03/08/2001 Original Version
*
\**************************************************************************/

BOOL IsMassStorageCamera(
    WCHAR   *wszMountPoint)
{
    HRESULT                     hr                          = E_FAIL;
    IHWDeviceCustomProperties   *pIHWDeviceCustomProperties = NULL;
    BOOL                        bIsCamera                   = FALSE;

    //
    //  CoCreate the CLSID_HWDeviceCustomProperties and grab the
    //  IHWDeviceCustomProperties interface.
    //
    hr = CoCreateInstance(CLSID_HWDeviceCustomProperties,
                          NULL,
                          CLSCTX_LOCAL_SERVER,
                          IID_IHWDeviceCustomProperties,
                          (VOID**)&pIHWDeviceCustomProperties);
    if (SUCCEEDED(hr))
    {

        //
        //  Make sure we initialize the device property interface, so it
        //  will know which device we're talking about.
        //
        hr = pIHWDeviceCustomProperties->InitFromDeviceID(wszMountPoint,
                                                          HWDEVCUSTOMPROP_USEVOLUMEPROCESSING);
        if (SUCCEEDED(hr)) {

            //
            //  Check whether this mass storage device is really a camera
            //
            DWORD   dwVal = 0;

            hr = pIHWDeviceCustomProperties->GetDWORDProperty(IS_DIGITAL_CAMERA_STR,
                                                              &dwVal);
            if (SUCCEEDED(hr) && (dwVal == IS_DIGITAL_CAMERA_VAL)) {
                bIsCamera = TRUE;
            }
        } else {
            DBG_WRN(("IsMassStorageCamera, Initialize failed with (0x%08X)", hr));
        }

        pIHWDeviceCustomProperties->Release();
    } else {
        DBG_WRN(("IsMassStorageCamera, CoCreateInstance failed with (0x%08X)", hr));
    }

    //
    //  Log whether we think this device is a camera or not
    //
    DBG_PRT(("IsMassStorageCamera, Returning %ws for drive (%ws)", bIsCamera ? L"TRUE" : L"FALSE", wszMountPoint));

    return bIsCamera;
}

/**************************************************************************\
* GetMountPointLabel
*
*   This helper function is a replacement for SHGetFileInfoW.  It will
*   fill in the label string of the specified mountpoint.
*
* Arguments:
*
*   wszMountPoint   - The mount point for a specified volume.
*   pszLabel        - Pointer to a caller allocated buffer
*   cchLabel        - Number of characters available in pszLabel
*
* Return Value:
*
*   Status
*
* History:
*
*    03/08/2001 Original Version
*
\**************************************************************************/

HRESULT GetMountPointLabel(WCHAR* wszMountPoint, LPTSTR pszLabel, DWORD cchLabel)
{
    HRESULT hr = S_OK;
    BOOL fFoundIt = FALSE;
    UINT uDriveType = GetDriveTypeW(wszMountPoint);

    if (!wszMountPoint) {
        DBG_WRN(("GetMountPointLabel, called with NULL string"));
        return E_INVALIDARG;
    }

    if (!fFoundIt)
    {
        //
        //  Grab "Label" property, if it exists
        //
        //
        //  CoCreate the CLSID_HWDeviceCustomProperties and grab the
        //  IHWDeviceCustomProperties interface.
        //

        IHWDeviceCustomProperties *pIHWDeviceCustomProperties = NULL;
        hr = CoCreateInstance(CLSID_HWDeviceCustomProperties,
                              NULL,
                              CLSCTX_LOCAL_SERVER,
                              IID_IHWDeviceCustomProperties,
                              (VOID**)&pIHWDeviceCustomProperties);
        if (SUCCEEDED(hr))
        {

            //
            //  Make sure we initialize the device property interface, so it
            //  will know which device we're talking about.
            //

            hr = pIHWDeviceCustomProperties->InitFromDeviceID(wszMountPoint,
                                                              HWDEVCUSTOMPROP_USEVOLUMEPROCESSING);
            if (SUCCEEDED(hr)) {

                //
                //  Check whether this mass storage device is really a camera
                //
                LPWSTR   pwszLabel = NULL;

                hr = pIHWDeviceCustomProperties->GetStringProperty(L"Label",
                                                                   &pwszLabel);
                if (SUCCEEDED(hr)) {
                    lstrcpynW(pszLabel, pwszLabel, cchLabel);
                    CoTaskMemFree(pwszLabel);

                    fFoundIt = TRUE;    
                }
            } else {
                DBG_WRN(("GetMountPointLabel, Initialize failed with (0x%08X)", hr));
            }

            pIHWDeviceCustomProperties->Release();
        } else {
            DBG_WRN(("GetMountPointLabel, CoCreateInstance failed with (0x%08X)", hr));
        }

        //
        //  Make sure to set hr to S_OK, since it is not a problem if we can't get the
        //  custom label (one might not exist).
        //
        hr = S_OK;
    }

    if (!fFoundIt)
    {
        //
        //  If the drive is REMOVABLE, and the mountpoint begins with 'A' or 'B', then it is considered
        //  a floppy drive.  We only want to call GetVolumeInformationW(..) if it is NOT a floppy...
        //
        if (!((uDriveType == DRIVE_REMOVABLE) && ((towupper(wszMountPoint[0]) == L'A') || (towupper(wszMountPoint[0]) == L'B')))) {

            //
            //  This is not a floppy, so find out its volume info.
            //
            if (!GetVolumeInformationW(wszMountPoint,
                                       pszLabel,
                                       cchLabel,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0))
            {
                //
                //  Failure case
                //
                *pszLabel = 0;
            } else {
                fFoundIt = TRUE;
            }
        }
    }

    if (!fFoundIt)
    {
        UINT uResId     = 0;
        INT  iRet       = 0;

        switch (uDriveType)
        {
            case DRIVE_REMOVABLE:
                 uResId = IDS_DRIVES_REMOVABLE_STR;
                break;
            case DRIVE_CDROM:
                uResId = IDS_DRIVES_CDROM_STR;
                break;
            case DRIVE_FIXED:
            default:
                uResId = IDS_DRIVES_FIXED_STR;
                break;
        }
        iRet = LoadString(g_hInst,
                          uResId,
                          pszLabel,
                          cchLabel);
        if (iRet) {

            fFoundIt = TRUE;
        } else {
            hr = E_FAIL;
        }
    }

    if (fFoundIt) {

        int iLabelLen = lstrlenW(pszLabel);
        if ((iLabelLen + (sizeof(L" ()") / sizeof(WCHAR)) + lstrlenW(wszMountPoint)) < cchLabel)
        {
            int iLenToChopOff = 1;

            lstrcatW(pszLabel, L" (");
            lstrcatW(pszLabel, wszMountPoint);
            lstrcpy(&pszLabel[lstrlenW(pszLabel) - iLenToChopOff], L")");
        }
    }
    return hr;
}

/**************************************************************************\
* GetDriverDLLVersion
*
*   This helper function is for reading a DLL version resource
*   fill in the label string of the specified mountpoint.
*
* Arguments:
*
*   wszMountPoint   - The mount point for a specified volume.
*   pszLabel        - Pointer to a caller allocated buffer
*   cchLabel        - Number of characters available in pszLabel
*
* Return Value:
*
*   TRUE  - The custom device property says this device is really a camera
*   FALSE - This device is not reported as a camera
*
* History:
*
*    03/08/2001 Original Version
*
\**************************************************************************/
BOOL GetDriverDLLVersion(DEVICE_INFO *pDeviceInfo, WCHAR *wszVersion, UINT uiSize)
{
    BOOL bSuccess = FALSE;
    if((NULL == wszVersion)||(NULL == pDeviceInfo)){
        return bSuccess;
    }

    //
    // clear the version string buffer
    //

    memset(wszVersion,0,uiSize);

    //
    // get COM DLL path from registry
    //

    CLSID clsid;
    memset(&clsid,0,sizeof(clsid));

    if (SUCCEEDED(CLSIDFromString(pDeviceInfo->wszUSDClassId, &clsid))) {

        HKEY  hk   = NULL;
        LONG  lRet = 0;
        WCHAR wszKey[MAX_PATH + 40];

        //
        //  Look up the CLSID in HKEY_CLASSES_ROOT.
        //

        swprintf(wszKey, L"CLSID\\%s\\InProcServer32", pDeviceInfo->wszUSDClassId);

        lRet = RegOpenKeyExW(HKEY_CLASSES_ROOT, wszKey, 0, KEY_QUERY_VALUE, &hk);
        if (lRet == ERROR_SUCCESS) {

            WCHAR wszDll[MAX_PATH];
            memset(wszDll,0,sizeof(wszDll));

            LONG cb = 0;

            cb   = cbX(wszDll);
            lRet = RegQueryValueW(hk, 0, wszDll, &cb);

            if (lRet == ERROR_SUCCESS) {

                //
                // get version information size
                //

                DWORD dwFileInfoVersionSize = GetFileVersionInfoSizeW(wszDll,NULL);
                if (dwFileInfoVersionSize > 0) {

                    //
                    // allocate version information buffer
                    //

                    void *pFileVersionData = LocalAlloc(LPTR,dwFileInfoVersionSize);
                    if (pFileVersionData) {
                        memset(pFileVersionData,0,(dwFileInfoVersionSize));

                        //
                        // fill version information buffer
                        //

                        if (GetFileVersionInfoW(wszDll,NULL,dwFileInfoVersionSize, pFileVersionData)) {
                            VS_FIXEDFILEINFO *pFileVersionInfo = NULL;
                            UINT uLen = 0;

                            //
                            // extract file version from version information buffer
                            //

                            if (VerQueryValue(pFileVersionData,TEXT("\\"),(LPVOID*)&pFileVersionInfo, &uLen)) {

                                //
                                // write the dll version resource into the string buffer
                                //

                                wsprintf(wszVersion,L"%d.%d.%d.%d",
                                         HIWORD(pFileVersionInfo->dwFileVersionMS),
                                         LOWORD(pFileVersionInfo->dwFileVersionMS),
                                         HIWORD(pFileVersionInfo->dwFileVersionLS),
                                         LOWORD(pFileVersionInfo->dwFileVersionLS));
                                bSuccess = TRUE;
                            } else {
                                DBG_WRN(("GetDriverDLLVersion, VerQueryValue Failed"));
                            }
                        } else {
                            DBG_WRN(("GetDriverDLLVersion, GetFileVersionInfoW Failed"));
                        }

                        //
                        // free allocated memory
                        //

                        LocalFree(pFileVersionData);
                        pFileVersionData = NULL;
                    } else {
                        DBG_WRN(("GetDriverDLLVersion, Could not allocate memory for file version information"));
                    }
                } else {
                    DBG_WRN(("GetDriverDLLVersion, File Version Information Size is < 0 (File may be missing version resource)"));
                }
            } else {
                DBG_WRN(("GetDriverDLLVersion, No InprocServer32"));
            }

            //
            // close registry KEY
            //

            RegCloseKey(hk);

        } else {
            DBG_WRN(("GetDriverDLLVersion, CLSID not registered"));
        }
    } else {
        DBG_WRN(("GetDriverDLLVersion, Invalid CLSID string"));
    }

    return bSuccess;
}

/**************************************************************************\
* CreateMSCRegEntries
*
*   This helper function creates the registry sub-keys and value entries for
*   an MSC Camera device.
*
* Arguments:
*
*   hDevRegKey      - The relevent key under MSCDevList, which specifies
*                     which device key we're initializing.
*   wszMountPoint   - The mount point for a specified volume.
*
* Return Value:
*
*   Status
*
* History:
*
*    04/07/2001 Original Version
*
\**************************************************************************/

HRESULT CreateMSCRegEntries(
    HKEY    hDevRegKey,
    WCHAR   *wszMountPoint)
{
    HRESULT hr = S_OK;

    if (hDevRegKey && wszMountPoint) {
        DWORD   dwError         = 0;
        DWORD   dwDisposition   = 0;
        HKEY    hKey            = NULL;

        //
        //  Write the DeviceID.  This is used to retsore event handlers for this device.
        //

        WCHAR   wszInternalName[STI_MAX_INTERNAL_NAME_LENGTH];

        //
        //  Make sure that there is enough space to enclose the mount point in {}.
        //
        if (lstrlenW(wszMountPoint) < (STI_MAX_INTERNAL_NAME_LENGTH - lstrlenW(L"{}"))) {
            wsprintf(wszInternalName, L"{%ws}", wszMountPoint);

            dwError = RegSetValueEx(hDevRegKey,
                                    REGSTR_VAL_DEVICE_ID_W,
                                    0,
                                    REG_SZ,
                                    (BYTE*)wszInternalName,
                                    sizeof(wszInternalName));
        }

        //
        //  Create the DeviceData sub-key
        //
        dwError = RegCreateKeyExW(hDevRegKey,
                                  REGSTR_VAL_DATA_W,
                                  0,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKey,
                                  &dwDisposition);
        if (dwError == ERROR_SUCCESS) {
            //
            //  We created the DeviceData sub-key.  We need to add
            //  color profile entry
            //

            WCHAR   wszSRGB[MAX_PATH];
            DWORD   dwSize = 0;

            //
            //  We insert sRGB as the color profile.  We don't hardcode the
            //  name, so call the API to get it...  Notice
            //  that the entry is a double NULL terminated list, so we
            //  set the size parameter to exclude the last 2 characters,
            //  so we're guaranteed to have 2 NULLs at the end.
            //
            memset(wszSRGB, 0, sizeof(wszSRGB));
            dwSize = sizeof(wszSRGB) - sizeof(L"\0\0");
            if (GetStandardColorSpaceProfileW(NULL,
                                              LCS_sRGB,
                                              wszSRGB,
                                              &dwSize))
            {
                //
                //  We must calculate the number of bytes in this string,
                //  remembering to include the size for two terminating NULLs.
                //
                dwSize = (lstrlenW(wszSRGB) * sizeof(wszSRGB[0])) + sizeof("\0\0");

                //
                //  Let's write the color profile entry.  
                //
                dwError = RegSetValueEx(hKey,
                                        NULL,
                                        0,
                                        REG_BINARY,
                                        (BYTE*)wszSRGB,
                                        dwSize);
            } else {
                DBG_WRN(("CreateMSCRegEntries, GetStandardColorSpaceProfile failed!"));
            }

            //
            //  Nothing left to do with this key, so close it.
            //
            RegCloseKey(hKey);
            hKey            = NULL;
            dwDisposition   = 0;
        }

        //
        //  Create the Events sub-key
        //
        dwError = RegCreateKeyExW(hDevRegKey,
                                  EVENTS,
                                  0,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKey,
                                  &dwDisposition);
        if (dwError == ERROR_SUCCESS) {

            //
            //  We created the Events sub-key.  Let's fill in some event info
            //
            WCHAR   wszCLSID[39];   // {GUID} is 38 characters long, 39 including NULL
            HKEY    hKeyTemp        = NULL;

            if (StringFromGUID2(WIA_EVENT_DEVICE_CONNECTED, wszCLSID, sizeof(wszCLSID) / sizeof(wszCLSID[0]))) {


                //
                //  Create the entry for WIA_EVENT_DEVICE_CONNECTED
                //
                dwError = RegCreateKeyExW(hKey,
                                          WIA_EVENT_DEVICE_CONNECTED_STR,
                                          0,
                                          NULL,
                                          REG_OPTION_NON_VOLATILE,
                                          KEY_ALL_ACCESS,
                                          NULL,
                                          &hKeyTemp,
                                          &dwDisposition);
                if (dwError == ERROR_SUCCESS) {

                    //
                    //  Fill in the values for the sub-key.
                    //  The result is as follows:
                    //      [Device connected]
                    //          Default:            "Device connected"
                    //          GUID:               "{a28bbade-x64b6-11d2-a231-00c0-4fa31809}"
                    //          LaunchApplications: "*"
                    //
                    //  Note that we don't care about error returns.
                    //
                    dwError = RegSetValueEx(hKeyTemp,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (BYTE*)WIA_EVENT_DEVICE_CONNECTED_STR,
                                            sizeof(WIA_EVENT_DEVICE_CONNECTED_STR));
                    dwError = RegSetValueEx(hKeyTemp,
                                            REGSTR_VAL_GUID_W,
                                            0,
                                            REG_SZ,
                                            (BYTE*)wszCLSID,
                                            sizeof(wszCLSID));
                    dwError = RegSetValueEx(hKeyTemp,
                                            REGSTR_VAL_LAUNCH_APPS_W,
                                            0,
                                            REG_SZ,
                                            (BYTE*)L"*",
                                            sizeof(L"*"));
                    RegCloseKey(hKeyTemp);
                    hKeyTemp = NULL;
                }
            } else {
                DBG_WRN(("::CreateMSCRegEntries, StringFromGUID2 for WIA_EVENT_DEVICE_CONNECTED failed!"));
            }

            RegCloseKey(hKey);
            hKey            = NULL;
            dwDisposition   = 0;
        }
    } else {
        DBG_WRN(("::CreateMSCRegEntries, Can't have NULL parameters!"));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\helpers.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       Helpers.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        12 Mar, 1999
*
*  DESCRIPTION:
*   Declarations and definitions for WIA device manager object helpers.
*
*******************************************************************************/

#pragma once

class CWiaDrvItem;


//
// Helper functions to build/destroy DEVICE_INFO structs
//

DEVICE_INFO* CreateDevInfoFromHKey(HKEY hKeyDev, DWORD dwDeviceState, SP_DEVINFO_DATA *pspDevInfoData, SP_DEVICE_INTERFACE_DATA *pspDevInterfaceData = NULL);
DEVICE_INFO* CreateDevInfoForFSDriver(WCHAR *wszMountPoint);
DEVICE_INFO* CreateDevInfoForRemoteDevice(HKEY hKeyDev);

BOOL RefreshDevInfoFromHKey(DEVICE_INFO *pDeviceInfo,HKEY hKeyDev, DWORD dwDeviceState, SP_DEVINFO_DATA *pspDevInfoData, SP_DEVICE_INTERFACE_DATA *pspDevInterfaceData);
BOOL RefreshDevInfoFromMountPoint(DEVICE_INFO *pDeviceInfo, WCHAR *wszMountPoint);

VOID DestroyDevInfo(DEVICE_INFO *pInfo);
VOID DumpDevInfo(DEVICE_INFO *pInfo);
IWiaPropertyStorage* CreateDevInfoStg(DEVICE_INFO *pInfo);

WCHAR*  AllocCopyString(WCHAR*  wszString);
WCHAR*  AllocCatString(WCHAR* wszString1, WCHAR* wszString2);
HRESULT AllocReadRegistryString(HKEY hKey, WCHAR *wszValueName, WCHAR **pwszReturnValue);
HRESULT ReadRegistryDWORD(HKEY hKey, WCHAR *wszValueName, DWORD *pdwReturnValue);
BOOL    GetDriverDLLVersion(DEVICE_INFO *pDeviceInfo, WCHAR *wszVersion, UINT uiSize);

//
// Exception handling covers for mini-driver entry points.
//

HRESULT _stdcall LockWiaDevice(IWiaItem*);
HRESULT _stdcall UnLockWiaDevice(IWiaItem*);

//
// Validation helper functions.
//

HRESULT _stdcall ValidateWiaItem(IWiaItem*);
HRESULT _stdcall ValidateWiaDrvItemAccess(CWiaDrvItem*);

//
// Error reporting helper functions.
//

LPOLESTR GetNameFromWiaPropId(PROPID propid);
void    _stdcall ReportReadWriteMultipleError(HRESULT, LPSTR, LPSTR, BOOL, ULONG, const PROPSPEC[]);

//
//  Item navigation helpers
//

HRESULT _stdcall GetParentItem(CWiaItem *pItem, CWiaItem **ppParent);

//
//  Property heplers
//

HRESULT _stdcall ReadPropStr(PROPID propid, IPropertyStorage  *pIPropStg, BSTR *pbstr);
HRESULT _stdcall ReadPropStr(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg, BSTR *pbstr);
HRESULT _stdcall ReadPropStr(IUnknown *pDevice, PROPID propid, BSTR *pbstr);
HRESULT _stdcall ReadPropLong(PROPID propid, IPropertyStorage  *pIPropStg, LONG *plval);
HRESULT _stdcall ReadPropLong(IUnknown *pDevice, PROPID propid, LONG *plval);

HRESULT _stdcall WritePropStr(PROPID propid, IPropertyStorage  *pIPropStg, BSTR bstr);
HRESULT _stdcall WritePropStr(IUnknown *pDevice, PROPID propid, BSTR bstr);
HRESULT _stdcall WritePropLong(PROPID propid, IPropertyStorage  *pIPropStg, LONG lval);
HRESULT _stdcall WritePropLong(IUnknown *pDevice, PROPID propid, LONG lval);

HRESULT _stdcall GetPropertyAttributesHelper(IWiaItem*, LONG, PROPSPEC*, ULONG*, PROPVARIANT*);

HRESULT _stdcall CheckXResAndUpdate(BYTE*, WIA_PROPERTY_CONTEXT*, LONG);
HRESULT _stdcall CheckYResAndUpdate(BYTE*, WIA_PROPERTY_CONTEXT*, LONG);

BOOL _stdcall AreWiaInitializedProps(ULONG, PROPSPEC*);

HRESULT _stdcall FillICMPropertyFromRegistry(IWiaPropertyStorage *pDevInfoProps, IWiaItem *pIWiaItem);

HRESULT _stdcall GetBufferValues(CWiaItem*, PWIA_EXTENDED_TRANSFER_INFO);

HRESULT _stdcall BQADScale(BYTE* pSrcBuffer,
                           LONG  lSrcWidth,
                           LONG  lSrcHeight,
                           LONG  lSrcDepth,
                           BYTE* pDestBuffer,
                           LONG  lDestWidth,
                           LONG  lDestHeight);

HANDLE GetUserTokenForConsoleSession();

BOOL IsMassStorageCamera(WCHAR   *wszMountPoint);
HRESULT GetMountPointLabel(WCHAR *wszMountPoint, LPTSTR pszLabel, DWORD cchLabel);
HRESULT CreateMSCRegEntries(HKEY hDevRegKey,     WCHAR  *wszMountPoint);



//
// Mini driver context helper functions.
//

HRESULT _stdcall InitMiniDrvContext(IWiaItem*, PMINIDRV_TRANSFER_CONTEXT );

//
// COM helper functions
//
#define SESSION_MONIKER TEXT("Session:Console!clsid:")

HRESULT _CoCreateInstanceInConsoleSession(REFCLSID rclsid,
                                          IUnknown* punkOuter,
                                          DWORD dwClsContext,
                                          REFIID riid,
                                          void** ppv);

#ifndef __WAITCURS_H_INCLUDED
#define __WAITCURS_H_INCLUDED

class CWaitCursor
{
private:
    HCURSOR m_hCurOld;
public:
    CWaitCursor(void)
    {
        m_hCurOld = SetCursor( LoadCursor( NULL, IDC_WAIT ) );
    }
    ~CWaitCursor(void)
    {
        SetCursor(m_hCurOld);
    }
};

#endif

extern CRITICAL_SECTION g_semDeviceMan;

/**************************************************************************\
* class CWiaCritSect
*
*   Dev Manager auto-exiting critical section
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    4/8/1999 Original Version
*
\**************************************************************************/

class CWiaCritSect {

private:
    CRITICAL_SECTION    *m_pSect;
    BOOL                bSucceeded;

public:

    CWiaCritSect(CRITICAL_SECTION* pSect) {
        bSucceeded = FALSE;
        m_pSect = pSect;

        _try {
            EnterCriticalSection(m_pSect);
        }
        _except (EXCEPTION_EXECUTE_HANDLER) {
            #ifdef DEBUG
                OutputDebugString(TEXT("CWiaCritSect, could not grab critical section!!!!\n"));
            #endif
            return;
        }
        bSucceeded = TRUE;
    }

    ~CWiaCritSect() {
        if (bSucceeded) {
            LeaveCriticalSection(m_pSect);
        }
    }

    inline BOOL Succeeded() {
        return bSucceeded;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\idrvitem.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       IDrvItem.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      marke
*
*  DATE:        30 Aug, 1998
*
*  DESCRIPTION:
*   Implementation of the WIA test camera item methods.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include "linklist.h"
#include "wiamindr.h"

#include "ienumitm.h"
#include "helpers.h"
#include "lockmgr.h"

VOID WINAPI FreeDrvItemContextCallback(VOID *pData);
VOID WINAPI ReleaseDrvItemCallback(VOID *pData);

/**************************************************************************\
* CWiaDrvItem::QueryInterface
*
*   Standard COM method.
*
* Arguments:
*
*   iid - Interface ID to query
*   ppv - Pointer to returned interface.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaDrvItem::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if ((iid == IID_IUnknown) || (iid == IID_IWiaDrvItem)) {
        *ppv = (IWiaDrvItem*) this;
    } else {
       return E_NOINTERFACE;
    }
    AddRef();
    return (S_OK);
}

ULONG   _stdcall CWiaDrvItem::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CWiaDrvItem::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) {
        delete this;
        return 0;
    }
    return ulRefCount;
}


/**************************************************************************\
* CWiaDrvItem
*
*   CWiaDrvItem constructor.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

CWiaDrvItem::CWiaDrvItem()
{
    m_ulSig            = CWIADRVITEM_SIG;
    m_cRef             = 0;

    m_pbDrvItemContext = NULL;
    m_pIWiaMiniDrv     = NULL;
    m_pCWiaTree        = NULL;

    m_pActiveDevice    = NULL;

    InitializeListHead(&m_leAppItemListHead);
}


/**************************************************************************\
* Initialize
*
*   Initializ a new CWiaDrvItem.
*
* Arguments:
*
*   lFlags              - Object flags for new item.
*   bstrItemName        - Item name.
*   bstrFullItemName    - Full item name, including path.
*   pIWiaMiniDrv        - Pointer to the device object.
*   cbDevSpecContext    - Number of bytes to allocate for device
*                         specific context.
*   ppDevSpecContext    - Pointer to returned device specific context.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaDrvItem::Initialize(
    LONG            lFlags,
    BSTR            bstrItemName,
    BSTR            bstrFullItemName,
    IWiaMiniDrv     *pIWiaMiniDrv,
    LONG            cbDevSpecContext,
    BYTE            **ppDevSpecContext
    )
{
    DBG_FN(CWiaDrvItem::Initialize);

    DBG_TRC(("CWiaDrvItem::Initialize: 0x%08X, %S", this, bstrItemName));

    HRESULT hr = S_OK;

    if (pIWiaMiniDrv == NULL) {
        DBG_ERR(("CWiaDrvItem::Initialize, bad pIWiaMiniDrv parameter"));
        return E_INVALIDARG;
    }

    m_pCWiaTree = new CWiaTree;

    if (m_pCWiaTree) {
        hr = m_pCWiaTree->Initialize(lFlags,
                                     bstrItemName,
                                     bstrFullItemName,
                                     (void*)this);
        if (SUCCEEDED(hr)) {

            m_pIWiaMiniDrv = pIWiaMiniDrv;

            //
            // alloc device specific context
            //

            if (cbDevSpecContext > 0) {
                hr = AllocDeviceSpecContext(cbDevSpecContext, ppDevSpecContext);
            }
        }

        if (FAILED(hr)) {
            delete m_pCWiaTree;
            m_pCWiaTree = NULL;
        }
    }
    else {
        DBG_ERR(("CWiaDrvItem::Initialize, new CWiaTree failed"));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

/**************************************************************************\
* ~CWiaDrvItem
*
*   CWiaDrvItem destructor
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

CWiaDrvItem::~CWiaDrvItem()
{
    DBG_TRC(("CWiaDrvItem::~CWiaDrvItem, (destroy)"));

    //
    // Release the backing tree item.
    //

    if (m_pCWiaTree) {
        delete m_pCWiaTree;
        m_pCWiaTree = NULL;
    }

    //
    // free device driver references
    //

    if (m_pbDrvItemContext != NULL) {

        FreeDrvItemContextCallback((VOID*)this);

//        DBG_ERR(("CWiaDrvItem destroy, device specific context not empty"));
    }

    //
    // Unlink the app item list.
    //

    LIST_ENTRY          *pEntry;
    PAPP_ITEM_LIST_EL   pElem;

    while (!IsListEmpty(&m_leAppItemListHead)) {
        pEntry = RemoveHeadList(&m_leAppItemListHead);
        if (pEntry) {
            pElem = CONTAINING_RECORD( pEntry, APP_ITEM_LIST_EL, ListEntry );
            if (pElem) {
                LocalFree(pElem);
            }
        }
    }

    //
    // clear all members
    //

    if (m_pActiveDevice) {

        //
        //  If the ACTIVE_DEVICE is pointing to us, make sure
        //  we set its Driver Item pointer to NULL since we're going away...
        //
        if (m_pActiveDevice->m_pRootDrvItem == this) {
            m_pActiveDevice->SetDriverItem(NULL);
        }
        m_pActiveDevice = NULL;
    }

    m_ulSig            = 0;
    m_pbDrvItemContext = NULL;
    m_pIWiaMiniDrv     = NULL;
}

/**************************************************************************\
* CWiaDrvItem::AddItemToFolder
*
*   Add a CWiaDrvItem to the driver item tree.
*
* Arguments:
*
*   pIParent - Parent of the driver item.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaDrvItem::AddItemToFolder(IWiaDrvItem *pIParent)
{
    DBG_FN(CWiaDrvItem::AddItemToFolder);
    HRESULT hr = S_OK;

    if (!pIParent) {
        DBG_ERR(("CWiaDrvItem::AddItemToFolder, NULL parent"));
        return E_INVALIDARG;
    }

    //
    // Get temporary parent object.
    //

    CWiaDrvItem *pParent = (CWiaDrvItem *)pIParent;

    //
    // Use tree method to add item.
    //

    hr = m_pCWiaTree->AddItemToFolder(pParent->m_pCWiaTree);
    if (SUCCEEDED(hr)) {

        //
        // Inc ref count of this (child) item since we're giving out
        // a reference for it to parent.
        //
        this->AddRef();

        //
        // If the parent of this drv item has corresponding app items,
        // run down the list and add a new child app item to each tree.
        //

        {
            CWiaCritSect    CritSect(&g_semDeviceMan);
            PLIST_ENTRY     pEntry = pParent->m_leAppItemListHead.Flink;

            while (pEntry != &pParent->m_leAppItemListHead) {

                PAPP_ITEM_LIST_EL pElem;

                pElem = CONTAINING_RECORD(pEntry, APP_ITEM_LIST_EL, ListEntry);

                CWiaItem *pCWiaItem = pElem->pCWiaItem;

                hr = pCWiaItem->UpdateWiaItemTree(ADD_ITEM, this);
                if (FAILED(hr)) {
                    break;
                }

                pEntry = pEntry->Flink;
            }
        }
    }

    return hr;
}

/**************************************************************************\
* RemoveItemFromFolder
*
*   Remove a CWiaDrvItem from the driver item tree and mark it so that
*   no device access can be done through it.
*
* Arguments:
*
*   lReason - Reason for removal of CWiaDrvItem.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaDrvItem::RemoveItemFromFolder(LONG lReason)
{
    DBG_FN(CWiaDrvItem::RemoveItemFromFolder);
    HRESULT hr = S_OK;

    //
    // Use tree method to remove item.
    //

    hr = m_pCWiaTree->RemoveItemFromFolder(lReason);
    if (SUCCEEDED(hr)) {

        //
        // If this drv item has corresponding app items, run down the
        // list and unlink the app item from each tree.
        //

        {
            CWiaCritSect    CritSect(&g_semDeviceMan);
            PLIST_ENTRY     pEntry = m_leAppItemListHead.Flink;

            while (pEntry != &m_leAppItemListHead) {

                PAPP_ITEM_LIST_EL pElem;

                pElem = CONTAINING_RECORD(pEntry, APP_ITEM_LIST_EL, ListEntry);

                CWiaItem *pCWiaItem = pElem->pCWiaItem;

                pCWiaItem->UpdateWiaItemTree(DELETE_ITEM, this);

                pEntry = pEntry->Flink;
            }
        }

        //
        // Free device specific context.
        //

        FreeDrvItemContextCallback((VOID*)this);
    }

    //
    // release reference
    //

    this->Release();

    return S_OK;
}

HRESULT _stdcall CWiaDrvItem::CallDrvUninitializeForAppItems(
    ACTIVE_DEVICE   *pActiveDevice)
{
    //
    // If this drv item has corresponding app items, run down the
    // list and call drvUnInitializeWia for each App. Item.
    //

    if (pActiveDevice) {
        PLIST_ENTRY     pEntry = m_leAppItemListHead.Flink;

        while (pEntry != &m_leAppItemListHead) {

            PLIST_ENTRY         pEntryNext = pEntry->Flink;
            PAPP_ITEM_LIST_EL   pElem;

            pElem = CONTAINING_RECORD(pEntry, APP_ITEM_LIST_EL, ListEntry);

            CWiaItem *pCWiaItem = pElem->pCWiaItem;

            HRESULT         hr              = E_FAIL;
            LONG            lDevErrVal      = 0;

            if (pCWiaItem) {

                //
                //  Only call drvUninitializeWia if it has not been called for this item
                //  already...
                //
                if (!(pCWiaItem->m_lInternalFlags & ITEM_FLAG_DRV_UNINITIALIZE_THROWN)) {
                    hr = g_pStiLockMgr->RequestLock(pActiveDevice, WIA_LOCK_WAIT_TIME, FALSE);

                    if(SUCCEEDED(hr)) {

                        hr = pActiveDevice->m_DrvWrapper.WIA_drvUnInitializeWia((BYTE*)pCWiaItem);
                        if (FAILED(hr)) {
                            DBG_WRN(("CWiaDrvItem::CallDrvUninitializeForAppItems, drvUnitializeWia failed"));
                        }
                        pCWiaItem->m_lInternalFlags |= ITEM_FLAG_DRV_UNINITIALIZE_THROWN;

                        g_pStiLockMgr->RequestUnlock(pActiveDevice, FALSE);
                    }
                }
            }

            pEntry = pEntryNext;
        }
        DBG_TRC(("Done calling drvUnInitializeWia for all items..."));
    } else {
        ASSERT(("CWiaDrvItem::CallDrvUninitializeForAppItems , called with NULL - this should never happen!", pActiveDevice));
    }
    
    //
    //  We don't care what happened - always return S_OK
    //
    return S_OK;
}


/**************************************************************************\
* GetDeviceSpecContext
*
*   Get the device specific context from a driver item.
*
* Arguments:
*
*   ppSpecContext - Pointer to a pointer to receive the device
*                   specific context pointer.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaDrvItem::GetDeviceSpecContext(PBYTE *ppSpecContext)
{
    DBG_FN(CWiaDrvItem::GetDeviceSpecContext);
    if (ppSpecContext == NULL) {
        DBG_ERR(("GetDeviceSpecContext, NULL ppSpecContext pointer"));
        return E_POINTER;
    }

    *ppSpecContext = m_pbDrvItemContext;

    if (!m_pbDrvItemContext) {
        DBG_ERR(("GetDeviceSpecContext, NULL device specific context"));
        return E_INVALIDARG;
    }

    return S_OK;
}

/**************************************************************************\
* AllocDeviceSpecContext
*
*   Allocate the device specific context from a driver item.
*
* Arguments:
*
*   cbDevSpecContext    - Number of bytes to allocate for device
*                         specific context.
*   ppDevSpecContext    - Pointer to returned device specific context.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaDrvItem::AllocDeviceSpecContext(
    LONG    cbSize,
    PBYTE   *ppSpecContext)
{
    DBG_FN(CWiaDrvItem::AllocDeviceSpecContext);
    //
    // validate size, may want to set max
    //

    if ((cbSize < 0) || (cbSize > WIA_MAX_CTX_SIZE)) {
        DBG_ERR(("CWiaDrvItem::AllocDeviceSpecContext, request > WIA_MAX_CTX_SIZE"));
        return E_INVALIDARG;
    }

    //
    // if a spec context already exists then fail
    //

    if (m_pbDrvItemContext != NULL) {
        DBG_ERR(("CWiaDrvItem::AllocDeviceSpecContext, Context already exists!"));
        return E_INVALIDARG;
    }

    //
    // attempt to alloc
    //

    m_pbDrvItemContext = (PBYTE)LocalAlloc(LPTR, cbSize);

    if (m_pbDrvItemContext == NULL) {
        DBG_ERR(("CWiaDrvItem::AllocDeviceSpecContext, unable to allocate %d bytes", cbSize));
        return E_OUTOFMEMORY;
    }

    //
    // return ctx if pointer supplied
    //

    if (ppSpecContext != NULL) {
        *ppSpecContext = m_pbDrvItemContext;
    }

    return S_OK;
}

/**************************************************************************\
* FreeDeviceSpecContext
*
*   Free device specific context
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaDrvItem::FreeDeviceSpecContext(void)
{
    DBG_FN(CWiaDrvItem::FreeDeviceSpecContext);
    if (m_pbDrvItemContext != NULL) {
        LocalFree(m_pbDrvItemContext);
        m_pbDrvItemContext = NULL;
    }

    return S_OK;
}

/**************************************************************************\
* GetItemFlags
*
*   Return the driver item flags.
*
* Arguments:
*
*   plFlags - Pointer to a value to receive the driver item flags.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaDrvItem::GetItemFlags(LONG *plFlags)
{
    DBG_FN(CWiaDrvItem::GetItemFlags);
    return m_pCWiaTree->GetItemFlags(plFlags);
}

/**************************************************************************\
* LinkToDrvItem
*
*   Adds the passed in CWiaItem to the driver items list of corresponding
*   application items.
*
* Arguments:
*
*   pCWiaItem - Pointer to application item.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaDrvItem::LinkToDrvItem(CWiaItem *pCWiaItem)
{
    DBG_FN(CWiaDrvItem::LinkToDrvItem);
    CWiaCritSect        CritSect(&g_semDeviceMan);
    PAPP_ITEM_LIST_EL   pElem;

    pElem = (PAPP_ITEM_LIST_EL) LocalAlloc(0, sizeof(APP_ITEM_LIST_EL));
    if (pElem) {
        pElem->pCWiaItem = pCWiaItem;
        InsertHeadList(&m_leAppItemListHead, &pElem->ListEntry);
        return S_OK;
    }
    else {
        DBG_ERR(("CWiaDrvItem::LinkToDrvItem alloc of APP_ITEM_LIST_EL failed"));
        return E_OUTOFMEMORY;
    }
}

/**************************************************************************\
* UnlinkFromDrvItem
*
*   Removes the passed in CWiaItem from the driver items list of
*   corresponding application items.
*
* Arguments:
*
*   pCWiaItem - Pointer to application item.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaDrvItem::UnlinkFromDrvItem(CWiaItem *pCWiaItem)
{
    DBG_FN(CWiaDrvItem::UnlinkFromDrvItem);
    CWiaCritSect    CritSect(&g_semDeviceMan);
    PLIST_ENTRY     pEntry = m_leAppItemListHead.Flink;

    while (pEntry != &m_leAppItemListHead) {

        PAPP_ITEM_LIST_EL pElem;

        pElem = CONTAINING_RECORD(pEntry, APP_ITEM_LIST_EL, ListEntry);

        if (pElem->pCWiaItem == pCWiaItem) {
            RemoveEntryList(pEntry);
            LocalFree(pElem);
            return S_OK;
        }

        pEntry = pEntry->Flink;
    }
    DBG_ERR(("CWiaDrvItem::UnlinkFromDrvItem, app item not found: 0x%08X", pCWiaItem));
    return S_FALSE;
}

/**************************************************************************\
* CWiaDrvItem::GetFullItemName
*
*   Allocates and fills in a BSTR with this items full name. The full item
*   name includes item path information.
*
* Arguments:
*
*   pbstrFullItemName - Pointer to returned full item name.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaDrvItem::GetFullItemName(BSTR *pbstrFullItemName)
{
    DBG_FN(CWiaDrvItem::GetFullItemName);
    return m_pCWiaTree->GetFullItemName(pbstrFullItemName);
}

/**************************************************************************\
* CWiaDrvItem::GetItemName
*
*   Allocates and fills in a BSTR with this items name. The item name
*   does not include item path information.
*
* Arguments:
*
*   pbstrItemName - Pointer to returned item name.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaDrvItem::GetItemName(BSTR *pbstrItemName)
{
    DBG_FN(CWiaDrvItem::GetItemName);
    return m_pCWiaTree->GetItemName(pbstrItemName);
}

/**************************************************************************\
* CWiaDrvItem::DumpItemData
*
*   Allocate buffer and dump formatted private CWiaDrvItem data into it.
*   This method is debug only. Free component returns E_NOTIMPL.
*
* Arguments:
*
*   bstrDrvItemData - Pointer to allocated buffer. Caller must free.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaDrvItem::DumpItemData(BSTR *bstrDrvItemData)
{
    DBG_FN(CWiaDrvItem::DumpItemData);
#ifdef ITEMDEBUG

#define TREE_BUF_SIZE 1024
#define BUF_SIZE      512  + TREE_BUF_SIZE
#define LINE_SIZE     128

    WCHAR       szTemp[BUF_SIZE], szTreeTmp[TREE_BUF_SIZE];
    LPOLESTR    psz = szTemp;

    wcscpy(szTemp, L"");

    psz+= wsprintfW(psz, L"Drv item, CWiaDrvItem: %08X\r\n\r\n", this);
    psz+= wsprintfW(psz, L"Address      Member              Value\r\n");
    psz+= wsprintfW(psz, L"%08X     m_ulSig:            %08X\r\n", &m_ulSig,            m_ulSig);
    psz+= wsprintfW(psz, L"%08X     m_cRef:             %08X\r\n", &m_cRef,             m_cRef);
    psz+= wsprintfW(psz, L"%08X     m_pIWiaMiniDrv:     %08X\r\n", &m_pIWiaMiniDrv,     m_pIWiaMiniDrv);
    psz+= wsprintfW(psz, L"%08X     m_pbDrvItemContext: %08X\r\n", &m_pbDrvItemContext, m_pbDrvItemContext);
    psz+= wsprintfW(psz, L"%08X     m_leAppItemListHead:%08X\r\n", &m_leAppItemListHead,m_leAppItemListHead);

    psz+= wsprintfW(psz, L"\r\n");

    BSTR bstrTree;

    HRESULT hr = m_pCWiaTree->DumpTreeData(&bstrTree);
    if (SUCCEEDED(hr)) {
        psz+= wsprintfW(psz, L"%ls", bstrTree);
        SysFreeString(bstrTree);
    }

    psz+= wsprintfW(psz, L"\r\n");

    if (psz > (szTemp + (BUF_SIZE - LINE_SIZE))) {
        DBG_ERR(("CWiaDrvItem::DumpDrvItemData buffer too small"));
    }

    *bstrDrvItemData = SysAllocString(szTemp);
    if (*bstrDrvItemData) {
        return S_OK;
    }
    return E_OUTOFMEMORY;
#else
    return E_NOTIMPL;
#endif
}

/**************************************************************************\
* CWiaDrvItem::UnlinkItemTree
*
*   This method unlinks the tree. Must be called on the root
*   driver item.
*
* Arguments:
*
*   lReason - Reason for unlinking the tree.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/21/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaDrvItem::UnlinkItemTree(LONG lReason)
{
    DBG_FN(CWiaDrvItem::UnlinkItemTree);

    //
    //  AddRef this item, since ReleaseDrvItemCallback will call release
    //  and we don't want to destroy this object.
    //
    AddRef();
    return m_pCWiaTree->UnlinkItemTree(lReason,
                                       (PFN_UNLINK_CALLBACK)ReleaseDrvItemCallback);
}

/**************************************************************************\
* CWiaDrvItem::FindItemByName
*
*   Locate a driver item by it's full item name.
*
* Arguments:
*
*   lFlags           - Operation flags.
*   bstrFullItemName - Requested item name.
*   ppItem           - Pointer to returned item, if found.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/27/1999 Original Version
*
\**************************************************************************/

HRESULT CWiaDrvItem::FindItemByName(
    LONG            lFlags,
    BSTR            bstrFullItemName,
    IWiaDrvItem     **ppItem)
{
    DBG_FN(CWiaDrvItem::FindItemByName);
    if (ppItem) {
        *ppItem = NULL;
    }
    else {
        DBG_ERR(("CWiaDrvItem::FindItemByName NULL ppItem"));
        return E_INVALIDARG;
    }

    CWiaTree *pCWiaTree;

    HRESULT hr = m_pCWiaTree->FindItemByName(lFlags, bstrFullItemName, &pCWiaTree);
    if (hr == S_OK) {

        pCWiaTree->GetItemData((void**)ppItem);

        if (*ppItem) {
            (*ppItem)->AddRef();
        }
    }
    return hr;
}

/**************************************************************************\
* CWiaDrvItem::FindChildItemByName
*
*   Locate a child item by it's item name.
*
* Arguments:
*
*   bstrItemName - Requested item name.
*   ppIChildItem - Pointer to returned item, if found.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/27/1999 Original Version
*
\**************************************************************************/

HRESULT CWiaDrvItem::FindChildItemByName(
    BSTR            bstrItemName,
    IWiaDrvItem     **ppIChildItem)
{
    DBG_FN(CWiaDrvItem::FindChildItemName);
    CWiaTree *pCWiaTree;

    HRESULT hr = m_pCWiaTree->FindChildItemByName(bstrItemName, &pCWiaTree);
    if (hr == S_OK) {

        pCWiaTree->GetItemData((void**)ppIChildItem);

        if (*ppIChildItem) {
            (*ppIChildItem)->AddRef();
        }
    }
    return hr;
}

/**************************************************************************\
* CWiaDrvItem::GetParent
*
*   Get parent of this item.
*
* Arguments:
*
*   ppIParentItem - Pointer to returned parent, if found.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/27/1999 Original Version
*
\**************************************************************************/

HRESULT CWiaDrvItem::GetParentItem(IWiaDrvItem **ppIParentItem)
{
    DBG_FN(CWiaDrvItem::GetParentItem);
    CWiaTree *pCWiaTree;

    HRESULT hr = m_pCWiaTree->GetParentItem(&pCWiaTree);
    if (hr == S_OK) {
        pCWiaTree->GetItemData((void**)ppIParentItem);
    }
    else {
        *ppIParentItem = NULL;
    }
    return hr;
}


/**************************************************************************\
* CWiaDrvItem::GetFirstChild
*
*   Return the first child item of this folder.
*
* Arguments:
*
*   ppIChildItem - Pointer to returned child item, if found.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/27/1999 Original Version
*
\**************************************************************************/

HRESULT CWiaDrvItem::GetFirstChildItem(IWiaDrvItem **ppIChildItem)
{
    DBG_FN(CWiaDrvItem::GetFirstChildItem);
    CWiaTree *pCWiaTree;

    HRESULT hr = m_pCWiaTree->GetFirstChildItem(&pCWiaTree);
    if (hr == S_OK) {
        pCWiaTree->GetItemData((void**)ppIChildItem);
    }
    else {
        *ppIChildItem = NULL;
    }
    return hr;
}

/**************************************************************************\
* CWiaDrvItem::GetNextSiblingItem
*
*   Find the next sibling of this item.
*
* Arguments:
*
*   ppSiblingItem - Pointer to the returned sibling item, if found.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/27/1999 Original Version
*
\**************************************************************************/

HRESULT CWiaDrvItem::GetNextSiblingItem(
    IWiaDrvItem  **ppSiblingItem)
{
    DBG_FN(CWiaDrvItem::GetNextSiblingItem);
    CWiaTree *pCWiaTree;

    HRESULT hr = m_pCWiaTree->GetNextSiblingItem(&pCWiaTree);
    if (hr == S_OK) {
        pCWiaTree->GetItemData((void**)ppSiblingItem);
    }
    else {
        *ppSiblingItem = NULL;
    }
    return hr;
}

/**************************************************************************\
* FreeDrvItemContextCallback
*
*   Callback function to free the driver item context.  Called by
*   CWiaTree::UnlinkItemTree(...) for each node in the tree.
*
* Arguments:
*
*   pData     - payload data for the tree node.  We know that this will be
*               a driver item, since only a driver item specifies this
*               callback (see CWiaDrvItem::UnlinkItemTree(...))
*
* Return Value:
*
*    Status
*
* History:
*
*    10/20/1998 Original Version
*
\**************************************************************************/

VOID WINAPI FreeDrvItemContextCallback(
    VOID *pData)
{
    DBG_FN(::FreeDrvItemContextCallback);

    CWiaDrvItem *pDrvItem = (CWiaDrvItem*) pData;
    HRESULT     hr = S_OK;

    if (pDrvItem) {

        //
        // Free device specific context, if it exists.
        //

        LONG    lFlags = 0;
        LONG    lDevErrVal;

        if (pDrvItem->m_pbDrvItemContext != NULL) {

            __try {
                if (pDrvItem->m_pIWiaMiniDrv) {
                    hr = pDrvItem->m_pIWiaMiniDrv->drvFreeDrvItemContext(lFlags,
                        pDrvItem->m_pbDrvItemContext,
                        &lDevErrVal);
                }
                if (FAILED(hr)) {
                    DBG_ERR(("FreeDrvItemContextCallback, drvFreeDrvItemContext failed 0x%X", hr));
                }
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                DBG_WRN(("FreeDrvItemContextCallback, exception calling drvFreeDrvItemContext (this is expected)"));
            }

            LocalFree(pDrvItem->m_pbDrvItemContext);
            pDrvItem->m_pbDrvItemContext = NULL;
        } else {
            DBG_TRC(("FreeDrvItemContextCallback, Context is NULL!  Nothing to free..."));
        }
    }
}

VOID WINAPI ReleaseDrvItemCallback(
    VOID *pData)
{
    DBG_FN(::ReleaseDrvItemCallback);

    CWiaDrvItem *pDrvItem = (CWiaDrvItem*) pData;
    HRESULT     hr = S_OK;

    if (pDrvItem) {

        //
        // First, free the driver item context
        //

        FreeDrvItemContextCallback(pData);

        //
        // Call release on the driver item
        //

        pDrvItem->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\ienumwfi.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       IEnumWFI.Cpp
*
*  VERSION:     2.1
*
*  AUTHOR:      ByronC
*
*  DATE:        20 Mar, 1998
*               08/10/1999 - Converted from IEnumWiaFormatInfo to IEnumWIA_FORMAT_INFO
*
*  DESCRIPTION:
*   Implementation of IEnumWIA_FORMAT_INFO interface for
*   WIA device class driver server.
*
*******************************************************************************/
#include "precomp.h"

#include "stiexe.h"

#include "wiamindr.h"
#include "coredbg.h"

#include "ienumwfi.h"

#include "helpers.h"


/********************************************************************************\
*
*  AllocCopyWFI
*
*  DESCRIPTION:
*   Allocates and copies an array of WIA_FORMAT_INFO structures.
*
*  Arguments:
*
*   ulCount         -   the number of elements to copy
*   pwfiIn          -   pointer to the WIA_FORMAT_INFO structures
*
* Return Value:
*
*   Pointer to the newly created array.
* History:
*
*    10/04/99 Original Version
*
\********************************************************************************/
WIA_FORMAT_INFO *AllocCopyWFI(
    ULONG               ulCount,
    WIA_FORMAT_INFO     *pwfiIn)
{
    DBG_FN(::AllocCopyWFI);

    if (!ulCount) {
        return NULL;
    }

    WIA_FORMAT_INFO *pwfi = (WIA_FORMAT_INFO*) CoTaskMemAlloc(sizeof(WIA_FORMAT_INFO) * ulCount);

    if (pwfi) {

        for (ULONG i = 0; i < ulCount; i++) {

            //
            //  Copy the structure
            //

            memcpy(&pwfi[i], &pwfiIn[i], sizeof(WIA_FORMAT_INFO));
        }
    }
    else {
        DBG_ERR(("CEnumWiaFormatInfo : AllocCopyFe, unable to allocate WIA_FORMAT_INFO buffer"));
    }

    return pwfi;
}

/*******************************************************************************
*
*  CEnumWiaFormatInfo
*
*  DESCRIPTION:
*   CEnumWiaFormatInfo Constructor.
*
* History:
*
*    10/04/99 Original Version
*
\********************************************************************************/

CEnumWiaFormatInfo::CEnumWiaFormatInfo()

{
    m_cRef          = 0;
    m_iCur          = 0;
    m_cFormatInfo   = 0;
    m_pFormatInfo   = NULL;
    m_pCWiaItem     = NULL;
}


/********************************************************************************\
*
*  Initialize
*
*  DESCRIPTION:
*   Sets up the enumerator.  It makes a call down to the driver for the
*   information needed for the enumeration.
*
*  Arguments:
*
*   pWiaItem        -   A pointer to the calling item.
*   pWiaMiniDrv     -   A pointer to the corresponding mini driver
*   lFlags          -   flags
*
* Return Value:
*
*   status
*
* History:
*
*    10/04/99 Original Version
*
\********************************************************************************/

HRESULT CEnumWiaFormatInfo::Initialize(
                                  CWiaItem    *pWiaItem)
{
    DBG_FN(CEnumWiaFormatInfo::Initialize);

    HRESULT         hr = E_FAIL;
    WIA_FORMAT_INFO *pFormat;

    m_iCur          = 0;
    m_cFormatInfo   = 0;
    m_pCWiaItem     = pWiaItem;

    //
    //  Make call to driver.  Driver returns an array of WIA_FORMAT_INFO.
    //

    LONG    lFlags = 0;

    {
        LOCK_WIA_DEVICE _LWD(pWiaItem, &hr);

        if(SUCCEEDED(hr)) {
            hr = m_pCWiaItem->m_pActiveDevice->m_DrvWrapper.WIA_drvGetWiaFormatInfo((BYTE*)pWiaItem,
                lFlags,
                &m_cFormatInfo,
                &pFormat,
                &(pWiaItem->m_lLastDevErrVal));
        }
    }

    if (SUCCEEDED(hr)) {
        if (m_cFormatInfo <= 0) {
            m_cFormatInfo = 0;
            DBG_ERR(("CEnumWiaFormatInfo::Initialize, drvGetWiaFormatInfo returned invalid count"));
            return E_FAIL;
        }

        //
        //  Check whether pointer received is valid
        //

        if (IsBadReadPtr(pFormat, sizeof(WIA_FORMAT_INFO)*m_cFormatInfo)) {
            DBG_ERR(("CEnumWiaFormatInfo::Initialize, drvGetWiaFormatInfo returned invalid pointer"));
            return E_POINTER;
        }

        //
        // Make a local copy in case minidriver goes away.
        //

        m_pFormatInfo = AllocCopyWFI(m_cFormatInfo, pFormat);
    } else {
        DBG_ERR(("CEnumWiaFormatInfo::Initialize, Error calling driver: drvGetWiaFormatInfo failed"));
    }

    return hr;
}

/********************************************************************************\
*
*  ~CEnumWiaFormatInfo
*
* DESCRIPTION:
*
*   Destructor.  Frees up the m_prgfe structure, if it was allocated
*
* History:
*
*    10/04/99 Original Version
*
\********************************************************************************/

CEnumWiaFormatInfo::~CEnumWiaFormatInfo()
{
    DBG_FN(CEnumWiaFormatInfo::~CEnumWiaFormatInfo);
    if (NULL!=m_pFormatInfo) {

        //
        //  Free our local copy of the device's WIA_FORMAT_INFOs
        //

        CoTaskMemFree(m_pFormatInfo);
    }
    m_cRef          = 0;
    m_iCur          = 0;
    m_cFormatInfo   = 0;
    m_pFormatInfo   = NULL;
    m_pCWiaItem     = NULL;
}



/*******************************************************************************
*
*  QueryInterface
*  AddRef
*  Release
*
*  DESCRIPTION:
*   CEnumWiaFormatInfo IUnknown Interface.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall CEnumWiaFormatInfo::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumWIA_FORMAT_INFO) {
        *ppv = (IEnumWIA_FORMAT_INFO*) this;
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG   _stdcall CEnumWiaFormatInfo::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CEnumWiaFormatInfo::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/**************************************************************************\
* Next
*
*   Device capability enumerator, this enumerator returns an array of
*   WIA_FORMAT_INFO structs.
*   Next_Proxy ensures that last parameter is non-NULL.
*
* Arguments:
*
*   cwfi            - number requested.
*   pwfi            - WIA_FORMAT_INFO returned in this array
*   pcwfi           - returned number of entries written.  NULLs are
*                    ignored.
*
* Return Value:
*
*   Status
*
* History:
*
*    10/04/99 Original Version
*
\**************************************************************************/

HRESULT _stdcall CEnumWiaFormatInfo::Next(
                                     ULONG              cwfi,
                                     WIA_FORMAT_INFO    *pwfi,
                                     ULONG              *pcwfi)
{
    DBG_FN(CEnumWiaFormatInfo::Next);

    HRESULT hr;
    ULONG   ulCount;
    ULONG   cReturn = 0L;

    //
    //  Parameter validation.
    //

    if (NULL == m_pFormatInfo) {
        return S_FALSE;
    }

    *pcwfi = 0L;

    //
    //  Check if the current index indicates that we've already been through
    //  all the elements.
    //

    if (m_iCur >= (ULONG)m_cFormatInfo) {
        return S_FALSE;
    }

    //
    //  Check that the requested number of elements exist.  If not,
    //  set ulCount to the remaining number of elements.
    //

    if (cwfi > (m_cFormatInfo - m_iCur)) {
        ulCount = m_cFormatInfo - m_iCur;
    } else {
        ulCount = cwfi;
    }

    //
    //  Copy the structres into the return
    //

    for (ULONG i = 0; i < ulCount; i++) {

        //
        //  Make the copy
        //

        memcpy(&pwfi[i], &m_pFormatInfo[m_iCur++], sizeof(WIA_FORMAT_INFO));
    }

    *pcwfi = ulCount;

    //
    //  Return S_FALSE if we returned less elements than requested
    //

    if (ulCount < cwfi) {
        return S_FALSE;
    }

    return S_OK;
}

/**************************************************************************\
* Skip
*
*   Skips WIA_FORMAT_INFOs in the enumeration.
*
* Arguments:
*
*   celt           - number of items to skip.
*
* Return Value:
*
*   status
*
* History:
*
*    12/04/99 Original Version
*
\**************************************************************************/

HRESULT _stdcall CEnumWiaFormatInfo::Skip(ULONG cwfi)
{
    DBG_FN(CEnumWiaFormatInfo::Skip);

    if ((((m_iCur + cwfi) >= (ULONG)m_cFormatInfo))
        || (NULL == m_pFormatInfo)) {
        return S_FALSE;
    }

    m_iCur+= cwfi;

    return S_OK;
}

/**************************************************************************\
* EnumDC::Reset
*
*   Resets the enumeration to the first element
*
* Arguments:
*
*
* Return Value:
*
*   status
*
* History:
*
*    16/03/99 Original Version
*
\**************************************************************************/

HRESULT _stdcall CEnumWiaFormatInfo::Reset(void)
{
    DBG_FN(CEnumWiaFormatInfo::Reset);
    m_iCur = 0;
    return S_OK;
}

/**************************************************************************\
* Clone
*
*   Creates another IEnumWIA_FORMAT_INFO enumeration object and returns an
*   interface pointer to it.
*
* Arguments:
*
*   ppIEnum -   Address that receives the new enumeration object
*
* Return Value:
*
*
* History:
*
*    16/03/99 Original Version
*
\**************************************************************************/

HRESULT _stdcall CEnumWiaFormatInfo::Clone(IEnumWIA_FORMAT_INFO **ppIEnum)
{
    DBG_FN(CEnumWiaFormatInfo::Clone);
    HRESULT             hr;
    CEnumWiaFormatInfo  *pClone;

    *ppIEnum = NULL;

    //
    // Create the clone
    //

    pClone = new CEnumWiaFormatInfo();

    if (!pClone) {
        return E_OUTOFMEMORY;
    }

    hr = pClone->Initialize(m_pCWiaItem);
    if (SUCCEEDED(hr)) {
        pClone->AddRef();
        pClone->m_iCur = m_iCur;
        *ppIEnum = pClone;
    } else {
        DBG_ERR(("CEnumWiaFormatInfo::Clone, Initialization failed"));
        delete pClone;
    }
    return hr;
}

/**************************************************************************\
* GetCount
*
*   Returns the number of elements stored in this enumerator.
*
* Arguments:
*
*   pcelt           - address of ULONG where to put the number of elements.
*
* Return Value:
*
*   Status          - S_OK if successful
*                     E_FAIL if failed
*
* History:
*
*    05/07/99 Original Version
*
\**************************************************************************/
HRESULT _stdcall CEnumWiaFormatInfo::GetCount(ULONG *pcelt)
{
    DBG_FN(CEnumWiaFormatInfo::GetCount);

    *pcelt = 0;

    //
    //  Check that we actually have a FORMAETC list and that the count
    //  has a non-zero value.
    //

    if(m_cFormatInfo && m_pFormatInfo) {

       *pcelt = m_cFormatInfo;
       return S_OK;
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\ienumdc.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       IEnumDC.h
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        16 March, 1999
*
*  DESCRIPTION:
*   Declaration and definitions for the CEnumDC class, which implements the
*   IEnumWIA_DEV_CAPS interface.
*
*******************************************************************************/
HRESULT CopyCaps(ULONG, WIA_DEV_CAP*, WIA_DEV_CAP*);

class CEnumDC : public IEnumWIA_DEV_CAPS
{
private:

    ULONG                   m_ulFlags;               // flag, indicating commands or events or both
    ULONG                   m_cRef;                  // Object reference count.
    ULONG                   m_ulIndex;               // Current element.
    LONG                    m_lCount;                // Number of items.
    WIA_DEV_CAP             *m_pDeviceCapabilities;  // Array descibing the capabilities
    ACTIVE_DEVICE           *m_pActiveDevice;        // Device object
    CWiaItem                *m_pCWiaItem;            // Parent mini drv

public:

    //
    // Constructor, initialization and destructor methods.
    //

    CEnumDC();
    HRESULT Initialize(ULONG, CWiaItem*);
    HRESULT Initialize(LONG, WIA_EVENT_HANDLER *);
    ~CEnumDC();

    //
    // IUnknown methods.
    //

    HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

    //
    // IEnumWIA_DEV_CAPS methods
    //
    
    HRESULT __stdcall Next(
        ULONG                celt,
        WIA_DEV_CAP          *rgelt,
        ULONG                *pceltFetched);

    HRESULT __stdcall Skip(ULONG celt);
    HRESULT __stdcall Reset(void);
    HRESULT __stdcall Clone(IEnumWIA_DEV_CAPS **ppIEnum);
    HRESULT __stdcall GetCount(ULONG *pcelt);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\ienumdc.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       IEnumDC.Cpp
*
*  VERSION:     1.01
*
*  AUTHOR:      ByronC
*
*  DATE:        16 March, 1999
*
*  DESCRIPTION:
*   Implementation of CEnumWIA_DEV_CAPS for the WIA device class driver.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include "wiamindr.h"


#include "ienumdc.h"
#include "helpers.h"

/*******************************************************************************\
*
*  QueryInterface
*  AddRef
*  Release
*
*  DESCRIPTION:
*   IUnknown Interface.
*
*  PARAMETERS:
*
\*******************************************************************************/

HRESULT _stdcall CEnumDC::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumWIA_DEV_CAPS) {
        *ppv = (IEnumWIA_DEV_CAPS*) this;
    } else {
       return E_NOINTERFACE;
    }

    AddRef();
    return (S_OK);
}

ULONG   _stdcall CEnumDC::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CEnumDC::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/**************************************************************************\
* CEnumWiaDC::CEnumDC
*
*   Constructor.  Initializes the member fields to 0.
*
* Arguments:
*
*
* Return Value:
*
*
* History:
*
*    16/03/99 Original Version
*
\**************************************************************************/
CEnumDC::CEnumDC()
{
   m_cRef                = 0;
   m_ulIndex             = 0;
   m_pActiveDevice       = NULL;
   m_pDeviceCapabilities = NULL;
}


/**************************************************************************\
* CEnumWiaDC::Initialize
*
*   Initializes the enumerator by querying the device for it's capabilities
*   and then keeping a local copy in m_pDeviceCapabilities.
*
* Arguments:
*
*   ulFlags         -   indicates Capability type: WIA_DEVICE_COMMANDS or
*                       WIA_DEVICE_EVENTS or both
*   pActiveDevice   -   pointer to the device's MiniDriver Interface
*   pCWiaItem       -   pointer to the wia item
*
* Return Value:
*
*
* History:
*
*    16/03/99 Original Version
*
\**************************************************************************/
HRESULT CEnumDC::Initialize(
    ULONG           ulFlags,
    CWiaItem        *pCWiaItem)
{
    DBG_FN(CEnumDC::Initialize);
    HRESULT         hr = S_OK;
    WIA_DEV_CAP_DRV *pDevCap = NULL;
    LONG            cIndex = 0;

    //
    // Validate parameters
    //

    if ((!pCWiaItem)) {
        DBG_ERR(("CEnumDC::Initialize, NULL input parameter"));
        return E_POINTER;
    }

    m_ulFlags           = ulFlags;
    m_pCWiaItem         = pCWiaItem;
    m_ulIndex           = 0;

    //
    // Ask minidriver for Capabilities supported
    //
    {
        LOCK_WIA_DEVICE _LWD(m_pCWiaItem, &hr);

        if(SUCCEEDED(hr)) {
            hr = m_pCWiaItem->m_pActiveDevice->m_DrvWrapper.WIA_drvGetCapabilities(
                (BYTE*)pCWiaItem,
                ulFlags,
                &m_lCount,
                &pDevCap,
                &(m_pCWiaItem->m_lLastDevErrVal));
        }
    }

    if (FAILED(hr)) {
        DBG_ERR(("CEnumDC::Initialize, Error calling driver: drvGetCapabilities failed"));
        return hr;
    }

    if (m_lCount <= 0) {
        m_lCount = 0;
        DBG_ERR(("CEnumDC::Initialize, drvGetCapabilities returned invalid count"));
        return WIA_ERROR_INVALID_DRIVER_RESPONSE;
    }

    //
    //  Check whether pointer received is valid
    //

    if (IsBadReadPtr(pDevCap, sizeof(WIA_DEV_CAP_DRV) * m_lCount)) {
        DBG_ERR(("CEnumDC::Initialize, drvGetFormatEtc returned invalid pointer"));
        return E_POINTER;
    }

    //
    // Make a local copy in case minidriver goes away.
    //

    m_pDeviceCapabilities = (WIA_DEV_CAP*) LocalAlloc(LPTR, sizeof(WIA_DEV_CAP) * m_lCount);
    if (m_pDeviceCapabilities) {

        memset(m_pDeviceCapabilities, 0, sizeof(WIA_DEV_CAP) * m_lCount);
        while (cIndex < m_lCount) {
            memcpy(&m_pDeviceCapabilities[cIndex].guid, pDevCap[cIndex].guid, sizeof(GUID));
            m_pDeviceCapabilities[cIndex].ulFlags = pDevCap[cIndex].ulFlags;

            m_pDeviceCapabilities[cIndex].bstrDescription = SysAllocString(pDevCap[cIndex].wszDescription);
            m_pDeviceCapabilities[cIndex].bstrName = SysAllocString(pDevCap[cIndex].wszName);
            m_pDeviceCapabilities[cIndex].bstrIcon = SysAllocString(pDevCap[cIndex].wszIcon);

            //
            // Check that the strings were actually allocated
            //

            if ((! (m_pDeviceCapabilities[cIndex].bstrDescription)) ||
                (! (m_pDeviceCapabilities[cIndex].bstrName)) ||
                (! (m_pDeviceCapabilities[cIndex].bstrIcon))) {
                DBG_ERR(("CEnumDC::Initialize, unable to allocate names buffer"));
                LocalFree(m_pDeviceCapabilities);
                return E_OUTOFMEMORY;
            }
            cIndex++;
        }
    }
    else {
        DBG_ERR(("CEnumDC::Initialize, unable to allocate capabilities buffer"));
        return E_OUTOFMEMORY;
    }
    return hr;
}


/**************************************************************************\
* CEnumWiaDC::Initialize
*
*   Initializes the enumerator, caller is responsible for allocating memory
*
* Arguments:
*
*   lCount      -   total number of event handlers
*   pEventInfo  -   persistent event handler information
*
* Return Value:
*
*
* History:
*
*    16/03/99 Original Version
*
\**************************************************************************/
HRESULT CEnumDC::Initialize(
    LONG               lCount,
    WIA_EVENT_HANDLER  *pHandlerInfo)

{
    DBG_FN(CEnumDC::Initialize);
    m_pActiveDevice = NULL;
    m_pCWiaItem     = NULL;
    m_ulFlags       = 0;
    m_ulIndex       = 0;

    m_pDeviceCapabilities = (WIA_DEV_CAP *)pHandlerInfo;
    m_lCount              = lCount;

    return S_OK;
}


/********************************************************************************\
*
*  CopyCaps
*
*  DESCRIPTION:
*   Copies an array of WIA_DEV_CAP structures.
*
*  Arguments:
*
*   ulCount         -   the number of elements to copy
*   pwdcIn          -   a pointer to the capabilities source array
*   pwdcOut         -   a pointer to the capabilities dest array
*
* Return Value:
*
*   Status.         -   E_POINTER if pwdcIn or pwdcOut are bad read pointers
*                   -   S_OK if successful.
*
*
* History:
*
*    16/03/99 Original Version
*
\********************************************************************************/
HRESULT CopyCaps(
    ULONG           ulCount,
    WIA_DEV_CAP     *pwdcIn,
    WIA_DEV_CAP     *pwdcOut)
{
    DBG_FN(::CopyCaps);
    HRESULT         hr = S_OK;
    ULONG           i;

    if (ulCount == 0) {
        return (hr);
    }

    memset(pwdcOut, 0, sizeof(WIA_DEV_CAP) * ulCount);
    for (i = 0; i < ulCount; i++) {

        memcpy(&pwdcOut[i].guid, &pwdcIn[i].guid, sizeof(GUID));

        pwdcOut[i].ulFlags         = pwdcIn[i].ulFlags;

        if (pwdcIn[i].bstrName) {
            pwdcOut[i].bstrName        = SysAllocString(pwdcIn[i].bstrName);
            if (!pwdcOut[i].bstrName) {
                hr = E_OUTOFMEMORY;
            }
        }
        if (pwdcIn[i].bstrDescription) {
            pwdcOut[i].bstrDescription = SysAllocString(pwdcIn[i].bstrDescription);
            if (!pwdcOut[i].bstrDescription) {
                hr = E_OUTOFMEMORY;
            }
        }
        if (pwdcIn[i].bstrIcon) {
            pwdcOut[i].bstrIcon        = SysAllocString(pwdcIn[i].bstrIcon);
            if (!pwdcOut[i].bstrIcon) {
                hr = E_OUTOFMEMORY;
            }
        }
        if (pwdcIn[i].bstrCommandline) {
            pwdcOut[i].bstrCommandline = SysAllocString(pwdcIn[i].bstrCommandline);
            if (!pwdcOut[i].bstrCommandline) {
                hr = E_OUTOFMEMORY;
            }
        }

        if (FAILED(hr)) {
            break;
        }
    }

    if (hr == S_OK) {
        return (hr);
    } else {

        //
        // Unwind the partial result
        //

        for (ULONG j = 0; j <= i; j++) {

            if (pwdcOut[i].bstrDescription) {
                SysFreeString(pwdcOut[i].bstrDescription);
            }

            if (pwdcOut[i].bstrName) {
                SysFreeString(pwdcOut[i].bstrName);
            }

            if (pwdcOut[i].bstrIcon) {
                SysFreeString(pwdcOut[i].bstrIcon);
            }

            if (pwdcOut[i].bstrCommandline) {
                SysFreeString(pwdcOut[i].bstrCommandline);
            }
        }
        return (hr);
    }
}


/**************************************************************************\
* CEnumWiaDC::~CEnumDC
*
*   Destructor for CEnumDC.  It frees up the m_pDeviceCapabilities structure
*   that was allocated in the constructor.
*
* Arguments:
*
*
* Return Value:
*
*
* History:
*
*    16/03/99 Original Version
*
\**************************************************************************/
CEnumDC::~CEnumDC()
{
    DBG_FN(CEnumDC::~CEnumDC);

    LONG cIndex = 0;

    if (m_pDeviceCapabilities) {
        while(cIndex < m_lCount) {

            if (m_pDeviceCapabilities[cIndex].bstrName) {
                SysFreeString(m_pDeviceCapabilities[cIndex].bstrName);
            }

            if (m_pDeviceCapabilities[cIndex].bstrDescription) {
                SysFreeString(m_pDeviceCapabilities[cIndex].bstrDescription);
            }

            if (m_pDeviceCapabilities[cIndex].bstrIcon) {
                SysFreeString(m_pDeviceCapabilities[cIndex].bstrIcon);
            }

            if (m_pDeviceCapabilities[cIndex].bstrCommandline) {
                SysFreeString(m_pDeviceCapabilities[cIndex].bstrCommandline);
            }

            cIndex++;
        }

        LocalFree(m_pDeviceCapabilities);
        m_pDeviceCapabilities = NULL;
    }
    m_cRef            = 0;
    m_ulIndex         = 0;
    m_pCWiaItem       = NULL;
}


/**************************************************************************\
* CEnumWiaDC::Next
*
*   Device capability enumerator, this enumerator returns an array of
*   WIA_DEV_CAP structs.
*   Next_Proxy ensures that last parameter is non-NULL.
*
* Arguments:
*
*   celt           - number requested.
*   rgelt          - capabilities returned in this array
*   pceltFetched   - returned number of entries written.  NULLs are
*                    ignored.
*
* Return Value:
*
*
* History:
*
*    16/03/99 Original Version
*
\**************************************************************************/

HRESULT _stdcall CEnumDC::Next(
   ULONG        celt,
   WIA_DEV_CAP  *rgelt,
   ULONG        *pceltFetched)
{
    DBG_FN(CEnumDC::Next);
    HRESULT hr;
    ULONG   ulCount;

    *pceltFetched = 0L;

    //
    //  Clear returned WIA_DEV_CAP structures
    //

    memset(rgelt, 0, sizeof(WIA_DEV_CAP) *celt);

    //
    //  Validate parameters
    //

    if (NULL == m_pDeviceCapabilities) {
        return (S_FALSE);
    }

    //
    //  Check whether any more elements exist to enumerate through.
    //

    if (m_ulIndex >= (ULONG)m_lCount) {
        return (S_FALSE);
    }

    //
    //  Check that the requested number of elements exist.  If not,
    //  set ulCount to the remaining number of elements.
    //

    if (celt > (m_lCount - m_ulIndex)) {
        ulCount = m_lCount - m_ulIndex;
    } else {
        ulCount = celt;
    }

    hr = CopyCaps(ulCount, &m_pDeviceCapabilities[m_ulIndex], rgelt);
    if (FAILED(hr)) {
        DBG_ERR(("CEnumDC::Next, could not copy capabilities!"));
        return (hr);
    }

    m_ulIndex+= ulCount;

    *pceltFetched = ulCount;

    //
    //  Return S_FALSE if we returned less elements than requested
    //

    if (ulCount < celt) {
        hr = S_FALSE;
    }

    return (hr);
}

/**************************************************************************\
* CEnumWiaDC::Skip
*
*   Skips device capabilities in the enumeration.
*
* Arguments:
*
*   celt           - number of items to skip.
*
* Return Value:
*
*
* History:
*
*    16/03/99 Original Version
*
\**************************************************************************/
HRESULT _stdcall CEnumDC::Skip(ULONG celt)
{
    DBG_FN(CEnumDC::Skip);
    //
    //  Check that we actually have a capabilities list and that we don't
    //  exceed the number of elements
    //

    if((m_pDeviceCapabilities != NULL) &&
       ((m_ulIndex + celt) < (ULONG)m_lCount)) {

       m_ulIndex += celt;
       return S_OK;
    }

    return S_FALSE;
}


/**************************************************************************\
* EnumDC::Reset
*
*   Resets the enumeration to the first element
*
* Arguments:
*
*
* Return Value:
*
*   status
*
* History:
*
*    16/03/99 Original Version
*
\**************************************************************************/

HRESULT _stdcall CEnumDC::Reset(void)
{
    DBG_FN(CEnumDC::Reset);
   m_ulIndex = 0;
   return S_OK;
}

/**************************************************************************\
* CEnumDC::Clone
*
*   Creates another IEnumWIA_DEV_CAPS enumeration object and returns an
*   interface pointer to it.
*
* Arguments:
*
*   ppIEnum -   Address that receives the new enumeration object
*
* Return Value:
*
*   Status
*
* History:
*
*    16/03/99 Original Version
*
\**************************************************************************/
HRESULT _stdcall CEnumDC::Clone(IEnumWIA_DEV_CAPS **ppIEnum)
{
    DBG_FN(CEnumDC::Clone);
    HRESULT     hr = S_OK;
    WIA_DEV_CAP *pDevCaps;
    CEnumDC     *pClone;

    *ppIEnum = NULL;

    //
    // Create the clone
    //

    pClone = new CEnumDC();

    if (!pClone) {
       DBG_ERR(("CEnumDC::Clone, new CEnumDC failed"));
       return E_OUTOFMEMORY;
    }

    //
    // Copy the registered event handler info
    //

    pDevCaps = (WIA_DEV_CAP *) LocalAlloc(LPTR, m_lCount * sizeof(WIA_DEV_CAP));
    if (! pDevCaps) {
        hr = E_OUTOFMEMORY;
    } else {
        hr = CopyCaps(m_lCount, m_pDeviceCapabilities, pDevCaps);
        if (SUCCEEDED(hr)) {

            //
            // Initialize other members of the clone
            //

            pClone->m_pCWiaItem    = NULL;
            pClone->m_ulFlags      = 0;
            pClone->m_lCount       = m_lCount;
            pClone->m_ulIndex      = m_ulIndex;
            pClone->m_pDeviceCapabilities = pDevCaps;
        } else {

            LocalFree(pDevCaps);
            pDevCaps = NULL;
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr)) {
       pClone->AddRef();
       *ppIEnum = pClone;
    } else {
        delete pClone;
    }
    return hr;
}

/**************************************************************************\
* CEnumWiaDC::GetCount
*
*   Returns the number of elements stored in this enumerator.
*
* Arguments:
*
*   pcelt           - address of ULONG where to put the number of elements.
*
* Return Value:
*
*   Status          - S_OK if successful
*                     E_FAIL if failed
*
* History:
*
*    05/07/99 Original Version
*
\**************************************************************************/
HRESULT _stdcall CEnumDC::GetCount(ULONG *pcelt)
{
    DBG_FN(CEnumDC::GetCount);

    if (pcelt) {
        *pcelt = 0;
    }

    //
    //  Check that we actually have a capabilities list.
    //

    if(m_pDeviceCapabilities) {

       *pcelt = m_lCount;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\ienumitm.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       IEnumItm.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        30 July, 1998
*
*  DESCRIPTION:
*   Implementation of CEnumWiaItem for the WIA device class driver.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include "wiamindr.h"


#include "ienumitm.h"

/*******************************************************************************
*
*  QueryInterface
*  AddRef
*  Release
*
*  DESCRIPTION:
*   IUnknown Interface.
*
*******************************************************************************/

HRESULT _stdcall CEnumWiaItem::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumWiaItem) {
        *ppv = (IEnumWiaItem*) this;
    } else {
       return E_NOINTERFACE;
    }

    AddRef();
    return (S_OK);
}

ULONG   _stdcall CEnumWiaItem::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CEnumWiaItem::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/**************************************************************************\
* CEnumWiaItem::CEnumWiaItem
*
*   CEnumWiaItem constructor method.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

CEnumWiaItem::CEnumWiaItem()
{
   m_cRef               = 0;
   m_ulIndex            = 0;
   m_pInitialFolder     = NULL;
   m_pCurrentItem       = NULL;
}

/**************************************************************************\
* CEnumWiaItem::Initialize
*
*   CEnumWiaItem initialization method.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT CEnumWiaItem::Initialize(CWiaItem *pInitialFolder)
{
    DBG_FN(CEnumWiaItem::Initialize);

    //
    // Validate parameters
    //

    if (!pInitialFolder) {
        DBG_ERR(("CEnumWiaItem::Initialize, NULL parameters"));
        return E_POINTER;
    }

    //
    // Verify that initial folder is a folder item.
    //

    LONG lFlags;

    pInitialFolder->GetItemType(&lFlags);
    if (!(lFlags & (WiaItemTypeFolder | WiaItemTypeHasAttachments))) {
        DBG_ERR(("CEnumWiaItem::Initialize, pInitialFolder is not a folder"));
        return E_INVALIDARG;
    }

    m_pInitialFolder = pInitialFolder;

    //
    // Get the initial folders tree entry.
    //

    CWiaTree *pCurFolderTree;

    pCurFolderTree = pInitialFolder->GetTreePtr();

    if (pCurFolderTree) {

        //
        // Get the first child item from the initial folder.
        //

        pCurFolderTree->GetFirstChildItem(&m_pCurrentItem);

        //
        // Ref count the root item.
        //

        m_pInitialFolder->AddRef();
    }
    else {
        DBG_ERR(("CEnumWiaItem::Initialize, initial folder doesn't have a tree entry"));
        return E_FAIL;
    }

    return S_OK;
}

/**************************************************************************\
* CEnumWiaItem::~CEnumWiaItem
*
*   CEnumWiaItem destructor method.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

CEnumWiaItem::~CEnumWiaItem()
{
    DBG_FN(CEnumWiaItem::~CEnumWiaItem);
    //
    // Decrement root item ref count.
    //

    if (m_pInitialFolder != NULL) {
        m_pInitialFolder->Release();
        m_pInitialFolder  = NULL;
    }

    //
    // Set other members to empty since we're done with this enumerator.
    //

    m_ulIndex           = 0;
    m_pInitialFolder        = NULL;
    m_pCurrentItem      = NULL;
}

/**************************************************************************\
* CEnumWiaItem::Next
*
*   Item enumerator, this enumerator only returns one item per call
*   Next_Proxy ensures that last parameter is non-NULL.
*
* Arguments:
*
*   cItem          - number requested
*   ppIWiaItem     - returned interface pointers
*   pcItemFetched  - returned number of objets (1 max)
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CEnumWiaItem::Next(
    ULONG       cItem,
    IWiaItem  **ppIWiaItem,
    ULONG      *pcItemFetched)
{
    DBG_FN(CEnumWiaItem::Next);
    HRESULT     hr;
    ULONG       i;

    //
    // Validate parameters
    //

    if (cItem == 0) {
        return S_OK;
    }

    if (! ppIWiaItem){
        DBG_ERR(("CEnumWiaItem::Next NULL input parameters"));
        return E_POINTER;
    }

    //
    // Clear the return values
    //

    *pcItemFetched = 0;
    ZeroMemory(ppIWiaItem, cItem * sizeof(IWiaItem *));

    //
    // Retrieve the requested items
    //

    for (i = 0; i < cItem; i++) {

        //
        // If m_pCurrentItem is NULL, then enumeration is complete
        //

        if (m_pCurrentItem == NULL) {
            hr = S_FALSE;
            break;
        }

        //
        // Get the next item from the tree and increment refernce count
        // before handing item pointer to the application.
        //

        hr = m_pCurrentItem->GetItemData((void **)(ppIWiaItem + i));
        if (hr == S_OK) {
            DBG_TRC(("CEnumWiaItem::Next, returning: 0x%08X", ppIWiaItem[i]));
            (ppIWiaItem[i])->AddRef();
            (*pcItemFetched)++;
        } else {

            break;
        }

        //
        // Advance item enumeration.
        //

        m_pCurrentItem->GetNextSiblingItem(&m_pCurrentItem);

    }

    if (FAILED(hr)) {

        //
        // Unwind from the error
        //

        for (i = 0; i < *pcItemFetched; i++) {
            ppIWiaItem[i]->Release();
            ppIWiaItem[i] = NULL;
        }
    }

    return hr;
}

/**************************************************************************\
* CEnumWiaItem::Skip
*
*   Skip to the next enumerated item.
*
* Arguments:
*
*   cItem          - number requested
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CEnumWiaItem::Skip(ULONG cItem)
{
    DBG_FN(CEnumWiaItem::Skip);
    CWiaTree *pOld;

    pOld = m_pCurrentItem;
    while (m_pCurrentItem && (cItem != 0)) {

        m_pCurrentItem->GetNextSiblingItem(&m_pCurrentItem);

        cItem--;
    }

    //
    //  If cItem != 0, then Skip request was too large, so restore
    //  m_pCurrentItem and return S_FALSE.
    //

    if (cItem) {
        m_pCurrentItem = pOld;
        return S_FALSE;
    }

    return S_OK;
}

/**************************************************************************\
* CEnumWiaItem::Reset
*
*   Reset to the first enumerated item.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CEnumWiaItem::Reset(void)
{
    DBG_FN(CEnumWiaItem::Reset);
    CWiaTree *pCurFolderTree;

    pCurFolderTree = m_pInitialFolder->GetTreePtr();

    if (pCurFolderTree) {

        //
        // Get the first child item from the initial folder.
        //

        pCurFolderTree->GetFirstChildItem(&m_pCurrentItem);
    }
    else {
        DBG_ERR(("CEnumWiaItem::reset, initial folder doesn't have a tree entry"));
        return E_FAIL;
    }

    return S_OK;
}

/**************************************************************************\
* CEnumWiaItem::Clone
*
*   Clone the enumerator
*
* Arguments:
*
*   ppIEnumWiaItem - Pointer to returned clone enumerator.
*
* Return Value:
*
*   status
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CEnumWiaItem::Clone(IEnumWiaItem **ppIEnumWiaItem)
{
    DBG_FN(CEnumWiaItem::Clone);
    HRESULT          hr;
    CEnumWiaItem   *pClone;

    *ppIEnumWiaItem = NULL;

    //
    // Create the clone
    //

    pClone = new CEnumWiaItem();

    if (!pClone) {
       DBG_ERR(("CEnumWiaItem::Clone new CEnumWiaItem failed"));
       return E_OUTOFMEMORY;
    }

    hr = pClone->Initialize(m_pInitialFolder);
    if (SUCCEEDED(hr)) {
       pClone->AddRef();
       pClone->m_pCurrentItem = m_pCurrentItem;
       *ppIEnumWiaItem = pClone;
    } else {
        delete pClone;
    }
    return hr;
}

/**************************************************************************\
* GetCount
*
*   Returns the number of elements stored in this enumerator.
*
* Arguments:
*
*   pcelt           - address of ULONG where to put the number of elements.
*
* Return Value:
*
*   Status          - S_OK if successful
*                     E_FAIL if failed
*
* History:
*
*    05/07/99 Original Version
*
\**************************************************************************/
HRESULT _stdcall CEnumWiaItem::GetCount(ULONG *pcelt)
{
    DBG_FN(CEnumWiaItem::GetCount);
    CWiaTree    *pCurFolderTree;
    CWiaTree    *pCurrentItem;
    ULONG       celt = 0;

    if (!m_pInitialFolder) {
        DBG_ERR(("CEnumWiaItem::GetCount, initial folder not set"));
        return E_POINTER;
    }

    pCurFolderTree = m_pInitialFolder->GetTreePtr();

    if (pCurFolderTree) {

        //
        //  Loop through the items
        //

        for (pCurFolderTree->GetFirstChildItem(&pCurrentItem);
             pCurrentItem;
             pCurrentItem->GetNextSiblingItem(&pCurrentItem)) {

            celt++;
        }
    }
    else {
        DBG_ERR(("CEnumWiaItem::GetCount, initial folder doesn't have a tree entry"));
        return E_FAIL;
    }

    *pcelt = celt;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\ienumwfi.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       IEnumWFI.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ByronC
*
*  DATE:        8 Aug, 1998
*               08/10/1999 - Converted from IEnumFormatEtc to IEnumWIA_FORMAT_INFO
*
*  DESCRIPTION:
*   Declaration and definitions for the CEnumFormatEtc class.
*
*******************************************************************************/

// IEnumWIA_FORMAT_INFO object is created from IWiaDataTransfer::idtEnumWIA_FORMAT_INFO.

class CEnumWiaFormatInfo : public IEnumWIA_FORMAT_INFO
{
private:
   ULONG           m_cRef;         // Object reference count.
   ULONG           m_iCur;         // Current element.
   LONG            m_cFormatInfo;  // Number of WIA_FORMAT_INFO in use.
   WIA_FORMAT_INFO *m_pFormatInfo; // Source of WIA_FORMAT_INFO.
   CWiaItem        *m_pCWiaItem;   // The WIA Item whose WIA_FORMAT_INFO is being requested
public:
    // Constructor, initialization and destructor methods.
   CEnumWiaFormatInfo();
   HRESULT Initialize(CWiaItem      *pWiaItem);
   ~CEnumWiaFormatInfo();

   //IUnknown members that delegate to m_pUnkRef.
   HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
   ULONG   _stdcall AddRef();
   ULONG   _stdcall Release();

   //IEnumWIA_FORMAT_INFO members
   HRESULT __stdcall Next(
      ULONG             cfi,
      WIA_FORMAT_INFO   *pfi,
      ULONG             *pcfi);

   HRESULT __stdcall Skip(ULONG cfi);
   HRESULT __stdcall Reset(void);
   HRESULT __stdcall Clone(IEnumWIA_FORMAT_INFO **ppIEnum);
   HRESULT __stdcall GetCount(ULONG *pcelt);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\ienumitm.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       IEnumItm.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        26 Dec, 1997
*
*  DESCRIPTION:
*   Declaration and definitions for the CEnumWiaItem class.
*
*******************************************************************************/

// IEnumWiaItem object is created from EnumChildItems methods.

class CWiaItem;

class CEnumWiaItem : public IEnumWiaItem
{
private:

    ULONG                   m_cRef;               // Object reference count.
    ULONG                   m_ulIndex;            // Current element.
    ULONG                   m_ulCount;            // Number of items.
    CWiaItem                *m_pInitialFolder;    // Initial enumeration folder.
    CWiaTree                *m_pCurrentItem;      // Current enumeration item.

public:

    //
    // Constructor, initialization and destructor methods.
    //

    CEnumWiaItem();
    HRESULT Initialize(CWiaItem*);
    ~CEnumWiaItem();

    //
    // IUnknown methods.
    //

    HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

    //
    // IEnumWiaItem methods
    //
    
    HRESULT __stdcall Next(
        ULONG                cItem,
        IWiaItem             **ppIWiaItem,
        ULONG                *pcItemFetched);

    HRESULT __stdcall Skip(ULONG cItem);
    HRESULT __stdcall Reset(void);
    HRESULT __stdcall Clone(IEnumWiaItem **ppIEnumWiaItem);
    HRESULT __stdcall GetCount(ULONG *pcelt);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\iitem.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       IItem.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        30 July, 1998
*
*  DESCRIPTION:
*   Implementation of CWiaItem for WIA scanner class driver.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#define WIA_DECLARE_DEVINFO_PROP_ARRAY
#include "wiamindr.h"
#include "wiapsc.h"
#define WIA_DECLARE_MANAGED_PROPS
#include "helpers.h"


#include "wiapropp.h"
#include "ienumdc.h"
#include "ienumitm.h"
#include "callback.h"
#include "devmgr.h"
#include "wiaevntp.h"

/**************************************************************************\
* CopyDrvItemToTreeItem
*
*   Create a CWiaTree object using a CWiaDrvItem as a template.
*
* Arguments:
*
*   lFlags          -
*   pCWiaDrvItemSrc -
*   ppCWiaTreeDst   -
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

CopyDrvItemToTreeItem(
    LONG            lFlags,
    CWiaDrvItem     *pCWiaDrvItemSrc,
    CWiaItem        *pCWiaItem,
    CWiaTree        **ppCWiaTreeDst)
{
    DBG_FN(::CopyDrvItemToTreeItem);
    HRESULT hr;

    *ppCWiaTreeDst = NULL;

    CWiaTree *pNewTreeItem = new CWiaTree;

    if (pNewTreeItem) {

        BSTR bstrItemName;

        hr = pCWiaDrvItemSrc->GetItemName(&bstrItemName);

        if (SUCCEEDED(hr)) {
            BSTR bstrFullItemName;

            hr = pCWiaDrvItemSrc->GetFullItemName(&bstrFullItemName);

            if (SUCCEEDED(hr)) {

                hr = pNewTreeItem->Initialize(lFlags,
                                              bstrItemName,
                                              bstrFullItemName,
                                              (void*)pCWiaItem);
                if (SUCCEEDED(hr)) {
                    *ppCWiaTreeDst = pNewTreeItem;
                }

                SysFreeString(bstrFullItemName);
            }
            SysFreeString(bstrItemName);
        }

        if (FAILED(hr)) {
            delete pNewTreeItem;
        }
    }
    else {
        DBG_ERR(("CopyDrvItemToTreeItem, new CWiaTree failed"));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

/**************************************************************************\
* UpdateWiaItemTree
*
*   Update the application item tree. Called on the
*   parent of the new child item or item to unlink.
*
* Arguments:
*
*   lFlag       - Action to preform.
*   pWiaDrvItem -
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::UpdateWiaItemTree(
    LONG                lFlag,
    CWiaDrvItem         *pWiaDrvItem)
{
    DBG_FN(CWiaItem::UpdateWiaItemTree);
    HRESULT hr = S_OK;

    if (lFlag == DELETE_ITEM) {

        //
        // Unlink the item from the app item tree.
        //

        hr = m_pCWiaTree->RemoveItemFromFolder(WiaItemTypeDeleted);
    }
    else if (lFlag == ADD_ITEM) {

        //
        // Create a CWiaItem for this driver item.
        //

        CWiaItem *pItem = new CWiaItem();

        if (!pItem) {
            DBG_ERR(("UpdateWiaItemTree new CWiaItem failed"));
            return E_OUTOFMEMORY;
        }

        hr = pItem->Initialize(m_pIWiaItemRoot, NULL, m_pActiveDevice, pWiaDrvItem);
        if (SUCCEEDED(hr)) {

            //
            // Create a CWiaTree object for this node and add it to the tree.
            //

            LONG lFlags;

            pWiaDrvItem->GetItemFlags(&lFlags);

            hr = CopyDrvItemToTreeItem(lFlags,
                                       pWiaDrvItem,
                                       pItem,
                                       &pItem->m_pCWiaTree);
            if (SUCCEEDED(hr)) {

                hr = pItem->m_pCWiaTree->AddItemToFolder(m_pCWiaTree);
                if (SUCCEEDED(hr)) {
                    return hr;
                }
            }
        }
        delete pItem;
    }
    else {
        DBG_ERR(("UpdateWiaItemTree unknown flag: 0x%08X", lFlag));
        hr = E_FAIL;
    }
    return hr;
}

/**************************************************************************\
* BuildWiaItemTreeHelper
*
*   Process the child items for BuildWiaItemTree.
*
* Arguments:
*
*   pWiaDrvItem -
*   pTreeParent -
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::BuildWiaItemTreeHelper(
    CWiaDrvItem         *pWiaDrvItem,
    CWiaTree            *pTreeParent)
{
    DBG_FN(CWiaItem::BuildWiaItemTreeHelper);
    //
    // Walk the child items.
    //

    CWiaDrvItem *pChildDrvItem;

    HRESULT hr = pWiaDrvItem->GetFirstChildItem((IWiaDrvItem**) &pChildDrvItem);

    while (hr == S_OK) {

        //
        // Create a CWiaItem for this node.
        //

        CWiaItem *pItem = new CWiaItem();

        if (!pItem) {
            DBG_ERR(("BuildWiaItemTreeHelper new CWiaItem failed"));
            hr =  E_OUTOFMEMORY;
            break;
        }

        hr = pItem->Initialize(m_pIWiaItemRoot, NULL, m_pActiveDevice, pChildDrvItem);
        if (SUCCEEDED(hr)) {

            //
            // Create a CWiaTree object for this node and add it to the tree.
            //

            LONG lFlags;

            pChildDrvItem->GetItemFlags(&lFlags);

            hr = CopyDrvItemToTreeItem(lFlags,
                                       pChildDrvItem,
                                       pItem,
                                       &pItem->m_pCWiaTree);
            if (SUCCEEDED(hr)) {

                hr = pItem->m_pCWiaTree->AddItemToFolder(pTreeParent);
                if (SUCCEEDED(hr)) {

                    if (lFlags & (WiaItemTypeFolder | WiaItemTypeHasAttachments)) {

                        //
                        // For folder items call BuildWiaItemTreeHelper recursively
                        // to process the folders child items.
                        //

                        hr = BuildWiaItemTreeHelper((CWiaDrvItem*)pChildDrvItem,
                                                    pItem->m_pCWiaTree);
                    }
                }
            }

            //
            // Process the next sibling driver item.
            //

            if (SUCCEEDED(hr)) {
                hr = pChildDrvItem->GetNextSiblingItem((IWiaDrvItem**) &pChildDrvItem);
            }
        }
        else {
            delete pItem;
        }
    }

    //
    //  Change S_FALSE to S_OK since S_FALSE simply means there are no more children to process.
    //

    if (hr == S_FALSE) {
        hr = S_OK;
    }
    return hr;
}

/**************************************************************************\
* BuildWiaItemTree
*
*   For root items, build a copy of the driver item tree and create a
*   CWiaItem for each node.
*
* Arguments:
*
*   pIWiaItemRoot   -
*   pIWiaMiniDrv    -
*   pWiaDrvItem     -
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::BuildWiaItemTree(IWiaPropertyStorage *pIWiaDevInfoProps)
{
    DBG_FN(CWiaItem::BuildWiaItemTree);

    //
    // Must be root item.
    //

    LONG lFlags;

    m_pWiaDrvItem->GetItemFlags(&lFlags);

    if (!(lFlags & WiaItemTypeRoot)) {
        DBG_ERR(("BuildWiaItemTree, caller doesn't have WiaItemTypeRoot set"));
        return E_INVALIDARG;
    }

    HRESULT hr = CopyDrvItemToTreeItem(lFlags, m_pWiaDrvItem, this,  &m_pCWiaTree);

    if (SUCCEEDED(hr)) {

        //
        // Since this is the root item, initialize the root item properties with a
        // mirror of the DEVINFOPROPS (WIA_DIP_* ID's).
        //

        hr = InitRootProperties(pIWiaDevInfoProps);
        if (FAILED(hr)) {
            DBG_TRC(("BuildWiaItemTree, InitRootProperties, about to unlink..."));
            UnlinkAppItemTree(WiaItemTypeDeleted);
            return hr;
        }

        //
        // Process the child items.
        //

        hr = BuildWiaItemTreeHelper(m_pWiaDrvItem,
                                    m_pCWiaTree);
        if (FAILED(hr)) {
            DBG_TRC(("BuildWiaItemTree, BuildWiaItemTreeHelper failed, about to unlink..."));
            UnlinkAppItemTree(WiaItemTypeDeleted);
        }
    }
    return hr;
}

/**************************************************************************\
* InitWiaManagedItemProperties
*
*   A private helper for CWiaItem::Initialize, which initializes the
*   WIA managed item properties based on the driver item values.
*
* Arguments:
*
*   None
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::InitWiaManagedItemProperties(
    IWiaPropertyStorage *pIWiaDevInfoProps)
{
    DBG_FN(CWiaItem::InitWiaManagedItemProperties);
    ULONG   ulNumProps;

    ulNumProps = (m_pIWiaItemRoot == this) ? NUM_WIA_MANAGED_PROPS - 1 : NUM_WIA_MANAGED_PROPS;
    //
    // WIA manages the item name and type properties, so set the
    // property names here.
    //

    HRESULT hr = wiasSetItemPropNames((BYTE*)this,
                                      ulNumProps,
                                      s_piItemNameType,
                                      s_pszItemNameType);

    //
    // Set the name and type properties attributes.
    //

    PROPVARIANT pv;
    ULONG       ulFlag;
    for (UINT i = 0; i < ulNumProps; i++) {

        if (i == PROFILE_INDEX) {
            pv.vt      = VT_BSTR | VT_VECTOR;
            ulFlag          = WIA_PROP_RW | WIA_PROP_CACHEABLE | WIA_PROP_LIST;
        } else {
            pv.vt      = VT_I4;
            ulFlag          = WIA_PROP_READ | WIA_PROP_CACHEABLE | WIA_PROP_NONE;
        }
        pv.ulVal   = 0;

        hr = wiasSetPropertyAttributes((BYTE*)this,
                                       1,
                                       &s_psItemNameType[i],
                                       &ulFlag,
                                       &pv);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::Initialize, wiasSetPropertyAttributes failed, index: %d", i));
            break;
        }
    }

    //
    // Get the item names and type from the driver item and set
    // them to the item properties.
    //

    BSTR        bstrItemName;
    BSTR        bstrFullItemName;

    hr = m_pWiaDrvItem->GetItemName(&bstrItemName);
    if (SUCCEEDED(hr)) {
        hr = m_pWiaDrvItem->GetFullItemName(&bstrFullItemName);
        if (SUCCEEDED(hr)) {

            LONG lFlags;

            m_pWiaDrvItem->GetItemFlags(&lFlags);  // Can't fail, except on param validate.

            //
            // Set the item names and type.
            //

            PROPVARIANT *propvar;

            propvar = (PROPVARIANT*) LocalAlloc(LPTR, sizeof(PROPVARIANT) * ulNumProps);
            if (propvar) {
                memset(propvar, 0, sizeof(PROPVARIANT) * ulNumProps);

                propvar[0].vt      = VT_BSTR;
                propvar[0].bstrVal = bstrItemName;
                propvar[1].vt      = VT_BSTR;
                propvar[1].bstrVal = bstrFullItemName;
                propvar[2].vt      = VT_I4;
                propvar[2].lVal    = lFlags;

                hr = (m_pPropStg->CurStg())->WriteMultiple(ulNumProps,
                                                           s_psItemNameType,
                                                           propvar,
                                                           WIA_DIP_FIRST);
                if (SUCCEEDED(hr)) {
                    //
                    //  Fill in ICM Profile information
                    //

                    hr = FillICMPropertyFromRegistry(pIWiaDevInfoProps, (IWiaItem*) this);
                }

                if (FAILED(hr)) {
                    ReportReadWriteMultipleError(hr, "CWiaItem::InitWiaManagedItemProperties",
                                                 NULL,
                                                 FALSE,
                                                 ulNumProps,
                                                 s_psItemNameType);
                }
                LocalFree(propvar);
            } else {
                DBG_ERR(("CWiaItem::InitWiaManagedItemProperties, Out of Memory!"));
                hr = E_OUTOFMEMORY;
            }
            SysFreeString(bstrFullItemName);

        }
        SysFreeString(bstrItemName);
    }
    return hr;
}

/**************************************************************************\
*
* InitRootProperties
*
*   A private helper for CWiaItem::Initialize, which initializes the
*   root item properties to a mirror of DEVINFOPROPS.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   status
*
* History:
*
*    9/3/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::InitRootProperties(IWiaPropertyStorage *pIWiaDevInfoProps)
{
    DBG_FN(CWiaItem::InitRootProperties);
    HRESULT hr = S_OK;

    //
    // Write the root item property names.
    //

    hr = WriteItemPropNames(NUMROOTITEMPROPS, g_piRootItem, g_pszRootItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::InitRootProperties, WritePropNames failed"));
        return hr;
    }

    //
    // Copy the device information properties from source to destination.
    //

    PROPVARIANT propvar[WIA_NUM_DIP];
    ULONG       ulIndex;

    memset(propvar, 0, sizeof(propvar));

    hr = pIWiaDevInfoProps->ReadMultiple(WIA_NUM_DIP,
                                         g_psDeviceInfo,
                                         propvar);

    if (SUCCEEDED(hr)) {
        hr = (m_pPropStg->CurStg())->WriteMultiple(WIA_NUM_DIP,
                                                   g_psDeviceInfo,
                                                   propvar,
                                                   WIA_DIP_FIRST);

        if (FAILED(hr)) {
            ReportReadWriteMultipleError(hr, "InitRootProperties", NULL, FALSE, WIA_NUM_DIP, g_psDeviceInfo);
        }

        FreePropVariantArray(WIA_NUM_DIP, propvar);
    }
    else {
        ReportReadWriteMultipleError(hr, "InitRootProperties", NULL, TRUE, WIA_NUM_DIP, g_psDeviceInfo);
        DBG_ERR(("CWiaItem::InitRootProperties failed"));
        return hr;
    }

    //
    // Write out the property info from our private array.
    //

    hr =  wiasSetItemPropAttribs((BYTE*)this,
                                 NUMROOTITEMPROPS,
                                 g_psRootItem,
                                 g_wpiRootItem);
    if (SUCCEEDED(hr) && m_pActiveDevice->m_DrvWrapper.IsVolumeDevice()) {
        //
        // This is a volume device.  We must add some volume specific properties
        //

        hr = AddVolumePropertiesToRoot(m_pActiveDevice);
    }
    return hr;
}

/*******************************************************************************
*
*  QueryInterface
*  AddRef
*  Release
*
*  DESCRIPTION:
*   IUnknown Interface. AddRef and Release mantain a global refernce count
*   of all device objects on the root item.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall CWiaItem::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IWiaItem) {
        *ppv = (IWiaItem*) this;
    } else if (iid == IID_IWiaPropertyStorage) {
        *ppv = (IWiaPropertyStorage*) this;
    } else if (iid == IID_IPropertyStorage) {
        *ppv = (IPropertyStorage*) this;
    } else if (iid == IID_IWiaDataTransfer) {
        *ppv = (IWiaDataTransfer*) this;
    } else if (iid == IID_IWiaItemInternal) {
        *ppv = (IWiaItemInternal*) this;
    } else if (iid == IID_IWiaItemExtras) {
        *ppv = (IWiaItemExtras*) this;
    } else {

        //
        // Blind aggregation to optional inner component.
        //

        if (m_pIUnknownInner) {
            return m_pIUnknownInner->QueryInterface(iid, ppv);
        }
        else {
            return E_NOINTERFACE;
        }
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return (S_OK);
}

ULONG   _stdcall CWiaItem::AddRef()
{
    DBG_FN(CWiaItem::AddRef);

    TAKE_ACTIVE_DEVICE  tad(m_pActiveDevice);

    LONG    lType   = 0;
    LONG    lRef    = 1;

    lRef = InterlockedIncrement((long*) &m_cLocalRef);
    GetItemType(&lType);
    if (!(lType & WiaItemTypeRemoved)) {
        lRef = InterlockedIncrement((long*) &(((CWiaItem*)m_pIWiaItemRoot)->m_cRef));
    }

    return lRef;
}

ULONG   _stdcall CWiaItem::Release()
{
    DBG_FN(CWiaItem::Release);

    LONG    lType = 0;
    ULONG   ulRef = InterlockedDecrement((long*)&m_cLocalRef);
    GetItemType(&lType);
    if (lType & WiaItemTypeRemoved) {

        if (ulRef == 0) {
            delete this;
            return 0;
        } else {
            return m_cLocalRef;
        }
    } else if (InterlockedDecrement((long*) &(((CWiaItem*)m_pIWiaItemRoot)->m_cRef)) == 0) {

        ulRef = ((CWiaItem*)m_pIWiaItemRoot)->m_cRef;

        //
        // If the combined refernce count of the root item goes to zero
        // first notify driver that client connection is being removed, then
        // unlink the tree and release all of the items.
        //

        HRESULT         hr              = E_FAIL;
        LONG            lDevErrVal      = 0;
        ACTIVE_DEVICE   *pActiveDevice  = m_pActiveDevice;

        //
        //  Call drvUnInitialize if it hasn't been called yet (could have been
        //  called if driver was unloaded).
        //  Note that we must check flags on the ROOT item.
        //
        if (!(((CWiaItem*)m_pIWiaItemRoot)->m_lInternalFlags & ITEM_FLAG_DRV_UNINITIALIZE_THROWN)) {

            {
                LOCK_WIA_DEVICE _LWD(this, &hr);

                if(SUCCEEDED(hr)) {
                    hr = m_pActiveDevice->m_DrvWrapper.WIA_drvUnInitializeWia((BYTE*)m_pIWiaItemRoot);
                }
                m_lInternalFlags |= ITEM_FLAG_DRV_UNINITIALIZE_THROWN;
            }
        }

        DBG_TRC(("CWiaItem::Release, m_cRef = 0, about to unlink..."));
        UnlinkAppItemTree(WiaItemTypeDeleted);

        if (pActiveDevice) {
            //
            // Release the ACTIVE_DEVICE object.  Notice that we release it AFTER
            // the item is through with it.
            //

            pActiveDevice->Release();
            pActiveDevice = NULL;
        }
    }

    return ulRef;
}

/**************************************************************************\
* CWiaItem::UnlinkChildAppItemTree
*
*   This method recursively unlinks the tree by calling
*   RemoveItemFromFolder on each item under the root.
*
* Arguments:
*
*   lReason - Reason for unlink of tree.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/21/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::UnlinkChildAppItemTree(LONG lReason)
{
    DBG_FN(CWiaItem::UnlinkChildAppItemTree);

    //
    //  Check that we have a valid tree
    //

    if (!m_pCWiaTree) {
        return S_FALSE;
    }

    //
    // Delete the childern.
    //

    CWiaTree *pChild, *pNext;

    HRESULT hr = m_pCWiaTree->GetFirstChildItem(&pChild);

    while (hr == S_OK) {

        //
        // Get a tree items associated app item.
        //

        CWiaItem *pChildAppItem;

        pChildAppItem = NULL;
        hr = pChild->GetItemData((void**)&pChildAppItem);
        if (hr == S_OK) {
            //
            // If the child is a folder then call
            // recursively to delete all childern under.
            //

            LONG lFlags;

            pChild->GetItemFlags(&lFlags);

            if (lFlags & (WiaItemTypeFolder | WiaItemTypeHasAttachments)) {
                hr = pChildAppItem->UnlinkChildAppItemTree(lReason);
                if (FAILED(hr)) {
                    break;
                }
            }
        }
        else {
            DBG_ERR(("CWiaItem::UnlinkChildAppItemTree no app item on tree item: %X", pChild));
        }

        hr = pChild->GetNextSiblingItem(&pNext);

        //
        // Remove item from tree.
        //

        pChild->RemoveItemFromFolder(lReason);

        //
        // Delete the child item.
        //

        if (pChildAppItem) {

            delete pChildAppItem;
        }

        pChild = pNext;
    }
    return hr;
}

/**************************************************************************\
* CWiaItem::UnlinkAppItemTree
*
*   This method unlinks the app item tree.
*
* Arguments:
*
*   lReason - Reason for unlinking the tree.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/21/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::UnlinkAppItemTree(LONG lReason)
{
    DBG_FN(CWiaItem::UnlinkAppItemTree);

    //
    // Work off of the root item.
    //

    CWiaItem *pRoot = (CWiaItem*) m_pIWiaItemRoot;

    //
    // Unlink any childern.
    //

    pRoot->UnlinkChildAppItemTree(lReason);

    //
    // Finally, delete the root item.
    //

    delete pRoot;
    return S_OK;
}

/**************************************************************************\
* CWiaItem::CWiaItem
*
*   CWiaItem Constructor Method.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status
*
* History:
*
*    11/11/1998 Original Version
*
\**************************************************************************/

CWiaItem::CWiaItem()
{
    m_ulSig             = CWIAITEM_SIG;
    m_cRef              = 0;
    m_cLocalRef         = 0;

    m_pWiaDrvItem       = NULL;
    m_pActiveDevice     = NULL;
    m_pIUnknownInner    = NULL;
    m_pCWiaTree         = NULL;
    m_pIWiaItemRoot     = this;
    m_bInitialized      = FALSE;
    m_pICMValues        = NULL;
    m_lICMSize          = 0;

    m_pPropStg          = NULL;

    m_hBandSection      = NULL;
    m_pBandBuffer       = NULL;
    m_lBandBufferLength = 0;
    m_ClientBaseAddress = 0;
    m_bMapSection       = FALSE;
    m_cwfiBandedTran    = 0;
    m_pwfiBandedTran    = NULL;
    m_pRemoteTransfer   = NULL;
    m_lLastDevErrVal    = 0;
    m_lInternalFlags    = 0;
}

/**************************************************************************\
* CWiaItem::Initialize
*
*   CWiaItem Initialize method.
*
* Arguments:
*
*   pIWiaItemRoot   -
*   pIWiaMiniDrv    -
*   pWiaDrvItem     -
*   pIUnknownInner  -
*
* Return Value:
*
*    Status
*
* History:
*
*    11/11/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::Initialize(
    IWiaItem                *pIWiaItemRoot,
    IWiaPropertyStorage     *pIWiaDevInfoProps,
    ACTIVE_DEVICE           *pActiveDevice,
    CWiaDrvItem             *pWiaDrvItem,
    IUnknown                *pIUnknownInner)
{
    DBG_FN(CWiaItem::Initialize);
#ifdef DEBUG
    BSTR bstr;
    if SUCCEEDED(pWiaDrvItem->GetItemName(&bstr)) {
        DBG_TRC(("CWiaItem::Initialize: 0x%08X, %S, drv item: 0x%08X", this, bstr, pWiaDrvItem));
        SysFreeString(bstr);
    }
#endif

    //
    // Validate parameters
    //

    if (!pActiveDevice || !pIWiaItemRoot || !pWiaDrvItem) {
        DBG_ERR(("CWiaItem::Initialize NULL input parameters"));
        return E_POINTER;
    }

    //
    // If optional inner component is present, save a pointer to it.
    //

    if (pIUnknownInner) {
        DBG_TRC(("CWiaItem::Initialize, pIUnknownInner: %X", pIUnknownInner));
        m_pIUnknownInner = pIUnknownInner;
    }

    //
    // Link to the items corresponding driver item.
    //

    m_pWiaDrvItem   = pWiaDrvItem;
    m_pIWiaItemRoot = pIWiaItemRoot;
    m_pActiveDevice = pActiveDevice;
    m_pWiaDrvItem->SetActiveDevice(pActiveDevice);

    HRESULT hr = pWiaDrvItem->LinkToDrvItem(this);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::Initialize, LinkToDrvItem failed"));
        return hr;
    }

    //
    // Create streams and property storage for item properties.
    //

    m_pPropStg = new CWiaPropStg();
    if (m_pPropStg) {
        hr = m_pPropStg->Initialize();
        if (FAILED(hr)) {
            delete m_pPropStg;
            m_pPropStg = NULL;
            DBG_ERR(("CWiaItem::Initialize, PropertyStorage Initialize failed"));
            return hr;
        }
    } else {
        DBG_ERR(("CWiaItem::Initialize, not enough memory to create CWiaPropStg"));
        hr = E_OUTOFMEMORY;
        return hr;
    }

    //
    //  Initialize the WIA managed item properties (name, full name, type, ...)
    //  from the driver item.  Must set m_bInitialized to TRUE so that
    //  InitWiaManagedProperties doesn't attempt to InitLazyProps()
    //

    m_bInitialized = TRUE;
    hr = InitWiaManagedItemProperties(pIWiaDevInfoProps);

    pWiaDrvItem->AddRef();

    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::Initialize, InitWiaManagedItemProperties failed"));
        m_bInitialized = FALSE;
        return hr;
    }
    //
    // If this is the root item, build a copy of the driver item tree
    // and create a CWiaItem for each node.
    //

    if (this == pIWiaItemRoot) {
        hr = BuildWiaItemTree(pIWiaDevInfoProps);
    }

    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::Initialize, BuildWiaItemTree failed"));
        return hr;
    }

    m_bInitialized = FALSE;
    return hr;
}

/**************************************************************************\
* CWiaItem::InitLazyProps
*
*   Helper used to implement lazy initialization.  Property initialization
*   is put off until the item is being accessed by an application for the
*   first time.
*
* Arguments:
*
*   bLockDevice -   bool value specifying whether a lock is needed.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/10/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::InitLazyProps(
    BOOL    bLockDevice)
{
    DBG_FN(CWiaItem::InitLazyProps);
    HRESULT hr = S_OK;

    LONG lFlags = 0;

    //
    //  Must set to TRUE before call to drvInitItemProperties
    //

    m_bInitialized = TRUE;

    //
    //  Call the device to initialize the item properties.
    //

    {
        LOCK_WIA_DEVICE _LWD(bLockDevice, this, &hr);

        if(SUCCEEDED(hr)) {                                                                        

            hr = m_pActiveDevice->m_DrvWrapper.WIA_drvInitItemProperties((BYTE*)this,lFlags, &m_lLastDevErrVal);
        }
    }

    if (FAILED(hr)) {
        m_bInitialized = FALSE;
    }

    return hr;
}


/**************************************************************************\
* CWiaItem::~CWiaItem
*
*   CWiaItem Destructor Method.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status
*
* History:
*
*    11/11/1998 Original Version
*
\**************************************************************************/

CWiaItem::~CWiaItem()
{
    DBG_FN(CWiaItem::~CWiaItem);
#ifdef ITEM_TRACE
    BSTR bstr;

    if (m_pWiaDrvItem && SUCCEEDED(m_pWiaDrvItem->GetItemName(&bstr))) {
        DBG_TRC(("CWiaItem destroy: %08X, %S", this, bstr));
        SysFreeString(bstr);
    }
    else {
        DBG_TRC(("CWiaItem destroy: %08X", this));
    }
#endif

    //
    // Delete the associated tree item.
    //

    if (m_pCWiaTree) {
        delete m_pCWiaTree;
        m_pCWiaTree = NULL;
    }

    //
    // Release WiaDrvItem. If ref count of m_pWiaDrvItem goes to zero
    // it will be destroyed at this time. For the ref count to be zero
    // no other CWiaItem object may have reference to it and it must be
    // disconnected from the device item tree.
    //

    if (m_pWiaDrvItem) {

        //
        // Unlink from the app item's corresponding driver item.
        //

        m_pWiaDrvItem->UnlinkFromDrvItem(this);

        m_pWiaDrvItem->Release();
        m_pWiaDrvItem = NULL;
    }

    //
    // Free the item property storage and streams.
    //

    if (m_pPropStg) {

        delete m_pPropStg;
        m_pPropStg = NULL;
    }

    //
    //  Free the cached ICM values
    //

    if (m_pICMValues) {
        LocalFree(m_pICMValues);
        m_pICMValues = NULL;
    }

    //
    // Set other members to empty since we're done with this item.
    //

    m_pWiaDrvItem       = NULL;
    m_pIUnknownInner    = NULL;
    m_pIWiaItemRoot     = NULL;
    m_bInitialized      = FALSE;
    m_lICMSize          = 0;


    m_hBandSection      = NULL;
    m_pBandBuffer       = NULL;
    m_lBandBufferLength = 0;
    m_ClientBaseAddress = 0;
    m_bMapSection       = FALSE;
    m_cwfiBandedTran    = 0;
    m_pwfiBandedTran    = NULL;
    m_lInternalFlags    = 0;
}

/**************************************************************************\
* CWiaItem::GetItemType
*
*   Get the item type from the corresponding driver item.
*
* Arguments:
*
*    pItemType - Pointer to the returned item type.
*
* Return Value:
*
*    Status
*
* History:
*
*    11/11/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::GetItemType(LONG *pItemType)
{
    DBG_FN(CWiaItem::GetItemType);
    LONG    lFlags  = 0;
    HRESULT hr      = S_FALSE;

    if (m_pWiaDrvItem) {

        //
        //  Get the driver item flags.  This is the flags basis for App. Items
        //  that were created as a result of copying the driver item tree i.e.
        //  non-generated items.
        //

        hr = m_pWiaDrvItem->GetItemFlags(&lFlags);
        if (SUCCEEDED(hr)) {

            //
            //  The App. item may have analysis-generated children, which the
            //  corresponding driver item wont have.  So check whether this
            //  item has children, and adjust the flags accordingly.
            //

            if (m_pCWiaTree) {
                if (m_pCWiaTree->GetFirstChildItem(NULL) == S_OK) {

                    //
                    //  Has children, so clear File flag and set Folder
                    //

                    if (!(lFlags & WiaItemTypeHasAttachments))
                    {
                        lFlags = (lFlags | WiaItemTypeFolder) & ~WiaItemTypeFile;
                    }
                }
            }

            *pItemType = lFlags;
        } else {
            DBG_ERR(("CWiaItem::GetItemType, Could not get the driver item flags!"));
        }
    }

    return hr;
}

/**************************************************************************\
* CWiaItem::EnumChildItems
*
*   Enumerate all child items under the current item, providing the
*   item is a folder
*
* Arguments:
*
*    ppIEnumWiaItem - return an IEnumWiaItem object to the caller
*
* Return Value:
*
*    Status
*
* History:
*
*    11/11/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::EnumChildItems(IEnumWiaItem **ppIEnumWiaItem)
{
    DBG_FN(CWiaItem::EnumChildItems);
    HRESULT hr;

    //
    // Corresponding driver item must be valid.
    //

    hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::EnumChildItems, ValidateWiaDrvItemAccess failed"));
        return hr;
    }

    //
    // Validate parameters
    //

    if (ppIEnumWiaItem ==  NULL) {
        DBG_ERR(("CWiaItem::EnumChildItems NULL input parameters"));
        return E_POINTER;
    }

    *ppIEnumWiaItem = NULL;

    //
    // Create the enumerator object.
    //

    CEnumWiaItem* pEnumWiaItem = new CEnumWiaItem();

    if (pEnumWiaItem != NULL) {

        //
        // Initialize the enumerator object.
        //

        hr = pEnumWiaItem->Initialize(this);

        if (SUCCEEDED(hr)) {

            //
            // get IID_IEnumWiaItem Interface
            //

            hr = pEnumWiaItem->QueryInterface(IID_IEnumWiaItem, (void **)ppIEnumWiaItem);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaItem::EnumChildItems, QI of IID_IEnumWiaItem failed"));
                delete pEnumWiaItem;
            }
        }
        else {
            delete pEnumWiaItem;
        }
    }
    else {
        DBG_ERR(("CWiaItem::EnumChildItems, new CEnumWiaItem failed"));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

/**************************************************************************\
* DeleteItem
*
*   Applications use this method to delete items.
*
* Arguments:
*
*   lFlags
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::DeleteItem(LONG lFlags)
{
    DBG_FN(CWiaItem::DeleteItem);
    LONG          lItemFlags;
    HRESULT       hr;
    IWiaDrvItem  *pIChildItem = NULL;
    LONG          lAccessRights;

    //
    // Corresponding driver item must be valid.
    //

    hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::DeleteItem, ValidateWiaDrvItemAccess failed"));
        return hr;
    }

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::DeleteItem, InitLazyProps failed"));
            return hr;
        }
    }

    GetItemType(&lItemFlags);

    //
    // Root item can not be deleted, the application needs it
    // in order to release the device.
    //

    if (lItemFlags & WiaItemTypeRoot) {
        DBG_ERR(("CWiaItem::DeleteItem, Deletion was attempted on a Root Item"));
        return (E_INVALIDARG);
    }

    //
    // Folder can be deleted only when it is empty
    //

    if (lItemFlags & (WiaItemTypeFolder | WiaItemTypeHasAttachments)) {

        if (m_pCWiaTree->GetFirstChildItem(NULL) == S_OK) {
            DBG_ERR(("CWiaItem::DeleteItem, Item still has children!"));
            return (E_INVALIDARG);
        }
    }

    //
    // Check whether the item can be deleted.  Generated items can always be
    // deleted regardless of AccessRights
    //

    hr = wiasReadPropLong((BYTE*)this, WIA_IPA_ACCESS_RIGHTS, &lAccessRights, NULL, false);
    if (hr == S_OK) {

        if (!((lAccessRights & WIA_ITEM_CAN_BE_DELETED) || (lItemFlags & WiaItemTypeGenerated))){
            DBG_ERR(("CWiaItem::DeleteItem, Item can not be deleted"));
            return (HRESULT_FROM_WIN32(ERROR_INVALID_ACCESS));
        }
    }

    //
    // If it's not a generated item, call the driver and ask it to remove
    // the item from it's tree.
    //

    if (!(lItemFlags & WiaItemTypeGenerated)) {
        //
        // Call the mini driver to delete the driver item.
        //

        {
            LOCK_WIA_DEVICE _LWD(this, &hr);

            if(SUCCEEDED(hr)) {
                hr = m_pActiveDevice->m_DrvWrapper.WIA_drvDeleteItem((BYTE*)this, lFlags, &m_lLastDevErrVal);
            }
        }

        if (SUCCEEDED(hr)) {

            //
            // Unlink the IWiaDrvItem from the device item tree.
            // This will also disable any device access through m_pWiaDrvItem
            // by setting the WiaItemTypeDeleted flag.
            //

            hr = m_pWiaDrvItem->RemoveItemFromFolder(WiaItemTypeDeleted | WiaItemTypeRemoved);
        }
    } else {

        //
        //  Since there is no corresponding driver item, manually remove this
        //  from the tree,
        //

        hr = m_pCWiaTree->RemoveItemFromFolder(WiaItemTypeDeleted | WiaItemTypeRemoved);
    }

    //
    //  Decrement the root item ref count by however much this local ref count 
    //  contributed to it.
    //
    for (ULONG i = 0; i < m_cLocalRef; i++) {
        m_pIWiaItemRoot->Release();    
    }
    
    return hr;
}

/*******************************************************************************
*
*  AnalyzeItem
*
*  DESCRIPTION:
*
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall CWiaItem::AnalyzeItem(LONG lFlags)
{
    DBG_FN(CWiaItem::AnalyzeItem);
    //
    //  Corresponding driver item must be valid.
    //

    HRESULT hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::AnalyzeItem, ValidateWiaDrvItemAccess failed"));
        return hr;
    }

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::AnalyzeItem, InitLazyProps failed"));
            return hr;
        }
    }

    //
    // call driver to implement this device dependent call
    //

    {
        LOCK_WIA_DEVICE _LWD(this, &hr);

        if(SUCCEEDED(hr)) {
            hr = m_pActiveDevice->m_DrvWrapper.WIA_drvAnalyzeItem((BYTE*)this, lFlags, &m_lLastDevErrVal);
        }
    }

    return hr;
}

/*******************************************************************************
*
*  CreateChildItem
*
*  DESCRIPTION:
*
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall CWiaItem::CreateChildItem(
    LONG        lFlags,
    BSTR        bstrItemName,
    BSTR        bstrFullItemName,
    IWiaItem    **ppNewItem)
{
    DBG_FN(CWiaItem::CreateChildItem);

    CGenWiaItem *pGenItem   = NULL;
    HRESULT     hr          = S_OK;

    *ppNewItem = NULL;

    //
    //  Create the new item
    //

    hr = wiasCreateChildAppItem((BYTE*) this,
                                lFlags,
                                bstrItemName,
                                bstrFullItemName,
                                (BYTE**) &pGenItem);
    if (SUCCEEDED(hr)) {

        //
        //  Get the driver to initialize the item.
        //

        hr = pGenItem->InitLazyProps(TRUE);
        if (SUCCEEDED(hr)) {

            //
            //  Return the IWiaItem interface to the calling App.
            //

            hr = pGenItem->QueryInterface(IID_IWiaItem,
                                          (VOID**)ppNewItem);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaItem::CreateChildItem, bad mini driver interface"));
            }
        } else {
            DBG_ERR(("CWiaItem::CreateChildItem, Error initializing the item properties"));
        }


        if (FAILED(hr)) {
            delete pGenItem;
        }
    } else {
        DBG_ERR(("CWiaItem::CreateChildItem, error creating generated item"));
    }
    return hr;
}

/**************************************************************************\
* DeviceCommand
*
*   Issue a device command.
*
* Arguments:
*
*   lFlags      -
*   plCommand   -
*   ppIWiaItem  -
*
* Return Value:
*
*    Status
*
* History:
*
*    11/12/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::DeviceCommand(
   LONG                             lFlags,
   const GUID                       *plCommand,
   IWiaItem                         **ppIWiaItem)
{
    DBG_FN(CWiaItem::DeviceCommand);
    IWiaDrvItem  *pIWiaDrvItem = NULL;
    HRESULT       hr;
    CWiaItem     *pItem;

    //
    // Driver interface must be valid.
    //

    if (!m_pActiveDevice) {
        DBG_ERR(("CWiaItem::DeviceCommand, bad mini driver interface"));
        return E_FAIL;
    }

    //
    //  Corresponding driver item must be valid.
    //

    hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::DeviceCommand, ValidateWiaDrvItemAccess failed"));
        return hr;
    }

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::DeviceCommand, InitLazyProps failed"));
            return hr;
        }
    }

    {
        LOCK_WIA_DEVICE _LWD(this, &hr);

        if(SUCCEEDED(hr)) {
            hr = m_pActiveDevice->m_DrvWrapper.WIA_drvDeviceCommand((BYTE*)this, lFlags, plCommand, &pIWiaDrvItem, &m_lLastDevErrVal);
        }
    }

    if ((!pIWiaDrvItem) || (!ppIWiaItem)) {
        return hr;
    }

    //
    // If we are here, the command has resulted in a drv item being added to
    // the drv and app item trees. Find and return the app item.
    //

    if (ppIWiaItem) {

        BSTR bstrName;

        *ppIWiaItem = NULL;

        hr = pIWiaDrvItem->GetFullItemName(&bstrName);
        if (SUCCEEDED(hr)) {
            hr = FindItemByName(0, bstrName, ppIWiaItem);
        }
        SysFreeString(bstrName);
    }
    return hr;
}

/*******************************************************************************
*
*  DeviceDlg
*
*  DESCRIPTION:
*   Executes only on the client side.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall CWiaItem::DeviceDlg(
    HWND                        hwndParent,
    LONG                        lFlags,
    LONG                        lIntent,
    LONG                        *plItemCount,
    IWiaItem                    ***pIWiaItems)
{
    DBG_FN(CWiaItem::DeviceDlg);
    DBG_ERR(("CWiaItem::DeviceDlg, Bad Proxy"));
    return E_FAIL;
}

/**************************************************************************\
* CWiaItem::GetRootItem
*
*   return interface to root item
*
* Arguments:
*
*    ppIWiaItem - return IWiaItem interface
*
* Return Value:
*
*    Status
*
* History:
*
*    10/20/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::GetRootItem(IWiaItem **ppIWiaItem)
{
    DBG_FN(CWiaItem::GetRootItem);
    HRESULT hr = S_OK;
    LONG    lDevErrVal;

    //
    // verify root is valid
    //

    if (m_pIWiaItemRoot != NULL) {

        m_pIWiaItemRoot->AddRef();
        *ppIWiaItem = m_pIWiaItemRoot;

    } else {
        DBG_ERR(("CWiaItem::GetRootItem: Bad Root item pointer"));
        hr = E_FAIL;
    }
    return hr;
}

/**************************************************************************\
* FindItemByName
*
*   Find an item based on its full name. Full name must be of the format.
*
*       DeviceID\RootDir\[sub-dirs]\ItemName
*
* Arguments:
*
*   lFalgs
*   bstrFullItemName
*   ppIWiaItem
*
* Return Value:
*
*    Status
*
* History:
*
*    10/9/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::FindItemByName(
   LONG     lFlags,
   BSTR     bstrFullItemName,
   IWiaItem **ppIWiaItem)
{
    DBG_FN(CWiaItem::FindItemByName);
    HRESULT hr;

    if (bstrFullItemName == NULL) {
        DBG_WRN(("CWiaItem::FindItemByName, bstrFullItemName parameter is NULL"));
        return E_INVALIDARG;
    }

    //
    // Corresponding driver item must be valid.
    //

    hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::FindItemByName, ValidateWiaDrvItemAccess failed"));
        return hr;
    }

    *ppIWiaItem = NULL;

    //
    // check for empty
    //

    if (wcscmp(bstrFullItemName, L"") == 0) {
        DBG_ERR(("CWiaItem::FindItemByName, Full Item Name is NULL"));
        return S_FALSE;
    }

    //
    // try to find matching driver item from linear list
    //

    CWiaTree  *pIChildItem;

    //
    //  Make Sure the tree doesn't get deleted, then search the tree.
    //

    AddRef();

    hr = m_pCWiaTree->FindItemByName(lFlags, bstrFullItemName, &pIChildItem);

    //
    //  If the item was found, get the app item pointer and addref.
    //

    if (hr == S_OK) {

        hr = pIChildItem->GetItemData((void**)ppIWiaItem);

        if (hr == S_OK) {
            (*ppIWiaItem)->AddRef();
        }
        else {
            DBG_ERR(("CWiaItem::FindItemByName, bad item data"));
        }
    } else {
        //DBG_WRN(("CWiaItem::FindItemByName, Item (%ws) not found in tree", bstrFullItemName));
    }

    Release();

    return hr;
}

/**************************************************************************\
* EnumDeviceCapabilities
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/15/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::EnumDeviceCapabilities(
    LONG                    lFlags,
    IEnumWIA_DEV_CAPS       **ppIEnum)
{
    DBG_FN(CWiaItem::EnumDeviceCapabilities);

    //
    // Corresponding driver item must be valid.
    //

    HRESULT hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::EnumDeviceCapabilities, ValidateWiaDrvItemAccess failed"));
        return hr;
    }

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::EnumDeviceCapabilities, InitLazyProps failed"));
            return hr;
        }
    }

    //
    // Add support for flags later.
    //

    CEnumDC     *pEnum = new CEnumDC();;

    if (!pEnum) {
       DBG_ERR(("CWiaItem::EnumDeviceCapabilities, new CEnumDC failed"));
       return E_OUTOFMEMORY;
    }

    hr = pEnum->Initialize(lFlags, this);
    if (SUCCEEDED(hr)) {

        hr = pEnum->QueryInterface(IID_IEnumWIA_DEV_CAPS, (void **) ppIEnum);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::EnumDeviceCapabilities, QI for IID_IEnumWIA_DEV_CAPS failed"));
            delete pEnum;
        }
    } else {
        DBG_ERR(("CWiaItem::EnumDeviceCapabilities, call to Initialize failed"));
        delete pEnum;
    }

    return hr;
}


/**************************************************************************\
* EnumRegisterEventInfo
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/15/1999 Original Version
*
\**************************************************************************/
HRESULT _stdcall CWiaItem::EnumRegisterEventInfo(
    LONG                    lFlags,
    const GUID              *pEventGUID,
    IEnumWIA_DEV_CAPS       **ppIEnumDevCap)
{
    DBG_FN(CWiaItem::EnumRegisterEventInfo);
    HRESULT                 hr;
    LONG                    lItemType;
    PROPSPEC                propSpec[1];
    PROPVARIANT             propVar[1];

    //
    // Retrieve the item type and check whether it is the root item
    //

    hr = m_pWiaDrvItem->GetItemFlags(&lItemType);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::EnumRegisterEventInfo() : Failed to get item type"));
        return (hr);
    }

    if (! (lItemType & WiaItemTypeRoot)) {
        DBG_ERR(("CWiaItem::EnumRegisterEventInfo() : Called on non-root item"));
        return (E_INVALIDARG);
    }

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::EnumRegisterEventInfo, InitLazyProps failed"));
            return hr;
        }
    }

    //
    // Retrieve the Device ID from root item's property
    //

    propSpec->ulKind = PRSPEC_PROPID;
    propSpec->propid = WIA_DIP_DEV_ID;
    hr = ReadMultiple(1, propSpec, propVar);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::EnumRegisterEventInfo() : Failed to get device id"));
        return (hr);
    }

    //
    // Ask the Event Notifier to create the enumerator
    //

    hr = g_eventNotifier.CreateEnumEventInfo(
                             propVar->bstrVal,
                             pEventGUID,
                             ppIEnumDevCap);

    //
    // Garbage collection
    //

    PropVariantClear(propVar);
    return (hr);
}

/**************************************************************************\
* CWiaItem::Diagnostic
*
*   Pass through to USD's diagnostic.
*
* Arguments:
*
*   ulSize      -   the size of the buffer in bytes
*   pBuffer     -   a pointer to the Diagnostic information buffer
*
* Return Value:
*
*    Status
*
* History:
*
*    12/14/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::Diagnostic(
    ULONG       ulSize,
    BYTE        *pBuffer)
{
    DBG_FN(CWiaItem::Diagnostic);
    IStiUSD *pIStiUSD;
    HRESULT hr = S_OK;

    hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::Diagnostic() : Driver Item not valid!"));
        return hr;
    }

    _try {

        //
        //  Get IStiUsd
        //

        if (m_pActiveDevice) {
            //
            //  Call diagnostic
            //

            {
                LOCK_WIA_DEVICE _LWD(this, &hr);

                if(SUCCEEDED(hr)) {
                    hr = m_pActiveDevice->m_DrvWrapper.STI_Diagnostic((STI_DIAG*)pBuffer);
                }
            }

        } else {
            DBG_ERR(("CWiaItem::Diagnostic() : invalid MiniDriver interface"));
            return E_INVALIDARG;
        }
    }
    _except(EXCEPTION_EXECUTE_HANDLER) {
        DBG_ERR(("CWiaItem::Diagnostic() : Exception in USD!"));
        hr = E_FAIL;
    }

    return hr;
}



/**************************************************************************\
* CWiaItem::DumpItemData
*
*   Allocate buffer and dump formated private CWiaItem data into it.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaItem::DumpItemData(BSTR *bstrItemData)
{
    DBG_FN(CWiaItem::DumpItemData);
#ifdef ITEMDEBUG

#define BUF_SIZE  2048
#define LINE_SIZE 128


    WCHAR       szTemp[BUF_SIZE];
    LPOLESTR    psz = szTemp;
    BSTR        bstr;

    psz+= wsprintfW(psz, L"App item, CWiaItem: %08X\r\n\r\n", this);
    psz+= wsprintfW(psz, L"Address      Member                   Value\r\n\r\n");
    psz+= wsprintfW(psz, L"%08X     m_ulSig:                 %08X\r\n", &m_ulSig,                 m_ulSig);
    psz+= wsprintfW(psz, L"%08X     m_cRef:                  %08X\r\n", &m_cRef,                  m_cRef);
    psz+= wsprintfW(psz, L"%08X     m_pWiaDrvItem:           %08X\r\n", &m_pWiaDrvItem,           m_pWiaDrvItem);
    psz+= wsprintfW(psz, L"%08X     m_pActiveDevice:         %08X\r\n", &m_pActiveDevice,         m_pActiveDevice);
    psz+= wsprintfW(psz, L"%08X     m_pIUnknownInner:        %08X\r\n", &m_pIUnknownInner,        m_pIUnknownInner);
    psz+= wsprintfW(psz, L"%08X     m_pCWiaTree:             %08X\r\n", &m_pCWiaTree,             m_pCWiaTree);
    psz+= wsprintfW(psz, L"%08X     m_pIWiaItemRoot:         %08X\r\n", &m_pIWiaItemRoot,         m_pIWiaItemRoot);
    psz+= wsprintfW(psz, L"%08X     m_pPropStg:              %08X\r\n", &m_pPropStg,              m_pPropStg);
    psz+= wsprintfW(psz, L"%08X     m_hBandSection:          %08X\r\n", &m_hBandSection,          m_hBandSection);
    psz+= wsprintfW(psz, L"%08X     m_pBandBuffer:           %08X\r\n", &m_pBandBuffer,           m_pBandBuffer);
    psz+= wsprintfW(psz, L"%08X     m_lBandBufferLength:     %08X\r\n", &m_lBandBufferLength,     m_lBandBufferLength);
    psz+= wsprintfW(psz, L"%08X     m_ClientBaseAddress:     %08X\r\n", &m_ClientBaseAddress,     m_ClientBaseAddress);
    psz+= wsprintfW(psz, L"%08X     m_bMapSection:           %08X\r\n", &m_bMapSection,           m_bMapSection);
    psz+= wsprintfW(psz, L"%08X     m_cfeBandedTran:         %08X\r\n", &m_cwfiBandedTran,        m_cwfiBandedTran);
    psz+= wsprintfW(psz, L"%08X     m_pfeBandedTran:         %08X\r\n", &m_pwfiBandedTran,        m_pwfiBandedTran);

    if (psz > (szTemp + (BUF_SIZE - LINE_SIZE))) {
        DBG_ERR(("CWiaItem::DumpItemData buffer too small"));
    }

    bstr = SysAllocString(szTemp);
    if (bstr) {
        *bstrItemData = bstr;
        return S_OK;
    }
    return E_OUTOFMEMORY;
#else
    return E_NOTIMPL;
#endif
}

/**************************************************************************\
* CWiaItem::DumpDrvItemData
*
*   Allocate buffer and dump formated private CWiaDrvItem data into it.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaItem::DumpDrvItemData(BSTR *bstrDrvItemData)
{
    DBG_FN(CWiaItem::DumpDrvItemData);
#ifdef DEBUG
    if (m_pWiaDrvItem) {
        return m_pWiaDrvItem->DumpItemData(bstrDrvItemData);
    }
    else {
        *bstrDrvItemData = SysAllocString(L"No linkage to driver item");
        if (*bstrDrvItemData) {
            return S_OK;
        }
        return E_OUTOFMEMORY;
    }
#else
    return E_NOTIMPL;
#endif
}

/**************************************************************************\
* CWiaItem::DumpTreeItemData
*
*   Allocate buffer and dump formated private CWiaTree data into it.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaItem::DumpTreeItemData(BSTR *bstrTreeItemData)
{
    DBG_FN(CWiaItem::DumpTreeItemData);
#ifdef DEBUG
    if (m_pCWiaTree) {
        return m_pCWiaTree->DumpTreeData(bstrTreeItemData);
    }
    else {
        *bstrTreeItemData = SysAllocString(L"No linkage to tree item");
        if (*bstrTreeItemData) {
            return S_OK;
        }
        return E_OUTOFMEMORY;
    }
#else
    return E_NOTIMPL;
#endif
}

/**************************************************************************\
* CWiaItem::GetTreePtr
*
*   Returns a pointer to an items corresponding tree entry.
*
* Arguments:
*
*   None
*
* Return Value:
*
*    Pointer to a tree item on success, null if failure.
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

CWiaTree* _stdcall CWiaItem::GetTreePtr(void)
{
    DBG_FN(CWiaItem::GetTreePtr);
    if (m_pCWiaTree) {
        return m_pCWiaTree;
    }
    else {
        DBG_ERR(("CWiaItem::GetTreePtr NULL tree item pointer for item: %X", this));
        return NULL;
    }
}

/**************************************************************************\
* CWiaItem::GetDrvItemPtr
*
*   Returns a pointer to an items corresponding driver item.
*
* Arguments:
*
*   None
*
* Return Value:
*
*    Pointer to a driver item on success, null if failure.
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

CWiaDrvItem* _stdcall CWiaItem::GetDrvItemPtr(void)
{
    DBG_FN(CWiaItem::GetDrvItemPtr);
    if (m_pWiaDrvItem) {
        return m_pWiaDrvItem;
    }
    else {
        DBG_ERR(("CWiaItem::GetDrvItemPtr NULL driver item pointer for item: %X", this));
        return NULL;
    }
}

/**************************************************************************\
* CWiaItem::WriteItemPropNames
*
*   Write property names to all internal property storage.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::WriteItemPropNames(
    LONG                cItemProps,
    PROPID              *ppId,
    LPOLESTR            *ppszNames)
{
    DBG_FN(CWiaItem::WriteItemPropNames);
    if (IsBadReadPtr(ppId, sizeof(PROPID) * cItemProps) ||
        IsBadReadPtr(ppszNames, sizeof(LPOLESTR) * cItemProps)) {
        DBG_ERR(("CWiaItem::WriteItemPropNames, NULL input pointer"));
        return E_INVALIDARG;
    }

    HRESULT hr = m_pPropStg->WriteItemPropNames(cItemProps,
                                                ppId,
                                                ppszNames);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::WriteItemPropNames, WritePropertyNames failed (0x%X)", hr));
        return hr;
    }
    return hr;
}

/**************************************************************************\
* CWiaItem::GetItemPropStreams
*
*   Get pointers to all internal property storage.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::GetItemPropStreams(
    IPropertyStorage **ppIPropStg,
    IPropertyStorage **ppIPropAccessStg,
    IPropertyStorage **ppIPropValidStg,
    IPropertyStorage **ppIPropOldStg)
{
    DBG_FN(CWiaItem::GetItemPropStreams);
    HRESULT hr;

    if (!m_pPropStg) {
        DBG_ERR(("CWiaItem::GetItemPropStreams, NULL internal property storage pointer"));
        return E_FAIL;
    }

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {

        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::GetItemPropStreams, InitLazyProps failed"));
            return hr;
        }
    }

    if (ppIPropStg) {
        *ppIPropStg = m_pPropStg->CurStg();
    }

    if (ppIPropAccessStg) {
        *ppIPropAccessStg = m_pPropStg->AccessStg();
    }

    if (ppIPropValidStg) {
        *ppIPropValidStg = m_pPropStg->ValidStg();
    }

    if (ppIPropOldStg) {
        *ppIPropOldStg = m_pPropStg->OldStg();
        if (!(*ppIPropOldStg)) {
            //
            //  Note that if the old property storage is NULL, we
            //  return the current value storage
            //
            *ppIPropOldStg = m_pPropStg->CurStg();
        }
    }
    return S_OK;
}

/**************************************************************************\
* CWiaItem::AddVolumePropertiesToRoot
*
*   This helper method takes a Root WiaItem and adds any volume specific
*   properties to it.  Note that this should only be called on the Root
*   item of Volume devices.
*
* Arguments:
*
*   pActiveDevice   -   Pointer to Root's active device object
*
* Return Value:
*
*   Status
*
* History:
*
*    12/13/2000 Original Version
*
\**************************************************************************/
HRESULT CWiaItem::AddVolumePropertiesToRoot(
    ACTIVE_DEVICE   *pActiveDevice)
{
    DBG_FN(AddVolumePropertiesToRoot);
    HRESULT hr = S_OK;

    //
    //  To add new FIle SYstem properties:
    //  Simply add the appropriate entries to
    //      piFileSystem
    //      psFileSystem
    //      pwszFileSystem
    //      pwszFileSystem
    //      wpiFileSystem
    //  Then, don't forget to add the current value entries to
    //      pvFileSystem
    //  before doing a WriteMultiple.  Notice that PropVariant arrays
    //  cannot be statically initialized (will give problems on 64bit)
    //
    PROPID   piFileSystem[]     = {WIA_DPF_MOUNT_POINT};
    PROPSPEC psFileSystem[]     = {
                                  {PRSPEC_PROPID, WIA_DPF_MOUNT_POINT}
                                  };
    LPOLESTR pwszFileSystem[]   = {WIA_DPF_MOUNT_POINT_STR};

    WIA_PROPERTY_INFO wpiFileSystem[] = {
                                        {WIA_PROP_RNC,  VT_BSTR, 0, 0, 0, 0},  // WIA_DPF_MOUNT_POINT
                                        };

    PROPVARIANT pvFileSystem[sizeof(piFileSystem) / sizeof(piFileSystem[0])];

    //
    // Write the File System property names.
    //

    hr = WriteItemPropNames(sizeof(piFileSystem) / sizeof(piFileSystem[0]),
                            piFileSystem,
                            pwszFileSystem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::AddVolumePropertiesToRoot, WritePropNames failed"));
        return hr;
    }

    //
    // Write the File System property values
    //

    ULONG       ulIndex;

    memset(pvFileSystem, 0, sizeof(pvFileSystem));

    BSTR        bstrMountPoint = NULL;
    DEVICE_INFO *pDevInfo      = pActiveDevice->m_DrvWrapper.getDevInfo();

    if (pDevInfo) {
        bstrMountPoint = SysAllocString(pDevInfo->wszAlternateID);
    }

    pvFileSystem[0].vt = VT_BSTR;
    pvFileSystem[0].bstrVal = bstrMountPoint;

    hr = (m_pPropStg->CurStg())->WriteMultiple(sizeof(piFileSystem) / sizeof(piFileSystem[0]),
                                               psFileSystem,
                                               pvFileSystem,
                                               WIA_DPF_FIRST);
    FreePropVariantArray(sizeof(piFileSystem) / sizeof(piFileSystem[0]),
                         pvFileSystem);
    if (FAILED(hr)) {
        ReportReadWriteMultipleError(hr, "CWiaItem::AddVolumePropertiesToRoot", NULL, FALSE, WIA_NUM_DIP, g_psDeviceInfo);
        DBG_ERR(("CWiaItem::AddVolumePropertiesToRoot failed"));
        return hr;
    }

    //
    // Write out the File System property attributes
    //

    hr =  wiasSetItemPropAttribs((BYTE*)this,
                                 sizeof(piFileSystem) / sizeof(piFileSystem[0]),
                                 psFileSystem,
                                 wpiFileSystem);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\infoset.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    infoset.h

Abstract:

    Handles setup API device infosets

Author:

    Vlad Sadovsky (vlads)   10-Jan-1999


Environment:

    User Mode - Win32

Revision History:

    6-Jan-1999     VladS       created

--*/

#ifndef _INFOSET_H_

    #define _INFOSET_H_

    #include <base.h>
    #include <buffer.h>

    #include <dbt.h>
    #include <setupapi.h>
    
class DEVICE_INFOSET {

public:

    DEVICE_INFOSET(IN GUID guidClass)
    {
        m_DeviceInfoSet = NULL;
        m_ClassGuid = guidClass;

        Initialize();

        m_fValid = TRUE;
    }

    ~DEVICE_INFOSET( VOID )
    {
        Reset();
    }

    inline BOOL
    IsValid(
           VOID
           )
    {
        return(m_fValid);
    }

    inline void
    EnterCrit(VOID)
    {
        m_dwCritSec.Lock();
    }

    inline void
    LeaveCrit(VOID)
    {
        m_dwCritSec.Unlock();
    }

    inline
    HDEVINFO
    QueryInfoSetHandle(VOID)
    {
        return(m_DeviceInfoSet);
    }

    //
    // Initialize info set for given class
    //
    BOOL
    Initialize(VOID)
    {

        HDEVINFO NewDeviceInfoSet;
        DWORD    dwErr;

        m_DeviceInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL);

        Refresh();

        #ifdef DEBUG
        Dump();
        #endif

        return (TRUE);
    }

    BOOL
    Refresh(VOID)
    {

        HDEVINFO NewDeviceInfoSet;
        DWORD    dwErr;

        if ( m_DeviceInfoSet && (m_DeviceInfoSet != INVALID_HANDLE_VALUE)) {

#ifdef WINNT

            //
            // Now we can retrieve the existing list of active device
            // interfaces into the device information set we created above.
            //

            NewDeviceInfoSet = SetupDiGetClassDevsEx(&(m_ClassGuid),
                                                     NULL,
                                                     NULL,
//                                                     DIGCF_PRESENT | DIGCF_DEVICEINTERFACE,
                                                     DIGCF_DEVICEINTERFACE,
                                                     m_DeviceInfoSet,
                                                     NULL,
                                                     NULL
                                                    );
            NewDeviceInfoSet = SetupDiGetClassDevsEx(&(m_ClassGuid),
                                                     NULL,
                                                     NULL,
//                                                     DIGCF_PRESENT | DIGCF_DEVICEINTERFACE,
                                                     0,
                                                     NewDeviceInfoSet,
                                                     NULL,
                                                     NULL
                                                    );

            if (NewDeviceInfoSet == INVALID_HANDLE_VALUE) {
                dwErr = ::GetLastError();
                DBG_ERR(("SetupDiGetClassDevsEx failed with 0x%lx\n", dwErr));
                return (FALSE);
            }
#else
    //
    // BUGBUG
    //
    #pragma message("Rewrite for Win98")
    return (FALSE);
#endif
            //
            // If SetupDiGetClassDevsEx succeeds and it was passed in an
            // existing device information set to be used, then the HDEVINFO
            // it returns is the same as the one it was passed in.  Thus, we
            // can just use the original DeviceInfoSet handle from here on.
            //
        }

        return (TRUE);
    }

    //
    //
    //
    BOOL
    Reset(VOID)
    {
        SetupDiDestroyDeviceInfoList(m_DeviceInfoSet);

        return (TRUE);
    }

    //
    // Look up driver name by interface name
    //
    BOOL
    LookupDriverNameFromInterfaceName(
                                     LPCTSTR pszInterfaceName,
                                     StiCString*    pstrDriverName
                                     )
    {

        BUFFER                      bufDetailData;

        SP_DEVINFO_DATA             spDevInfoData;
        SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;
        PSP_DEVICE_INTERFACE_DETAIL_DATA    pspDevInterfaceDetailData;

        TCHAR   szDevDriver[STI_MAX_INTERNAL_NAME_LENGTH];

        DWORD   cbData;
        DWORD   dwErr;

        HKEY    hkDevice        = (HKEY)INVALID_HANDLE_VALUE;
        LONG    lResult         = ERROR_SUCCESS;
        DWORD   dwType          = REG_SZ;

        BOOL    fRet            = FALSE;
        BOOL    fDataAcquired   = FALSE;

        bufDetailData.Resize(sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                             MAX_PATH * sizeof(TCHAR) +
                             16
                            );


        pspDevInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) bufDetailData.QueryPtr();

        if (!pspDevInterfaceDetailData) {
            return (CR_OUT_OF_MEMORY);
        }

        //
        // Locate this device interface in our device information set.
        //
        spDevInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        if (SetupDiOpenDeviceInterface(m_DeviceInfoSet,
                                       pszInterfaceName,
                                       DIODI_NO_ADD,
                                       &spDevInterfaceData)) {

            
            //
            // First try to open interface regkey.
            //
            
            hkDevice = SetupDiOpenDeviceInterfaceRegKey(m_DeviceInfoSet,
                                                        &spDevInterfaceData,
                                                        0,
                                                        KEY_READ);
            if(INVALID_HANDLE_VALUE != hkDevice){

                *szDevDriver = TEXT('\0');
                cbData = sizeof(szDevDriver);
                lResult = RegQueryValueEx(hkDevice,
                                          REGSTR_VAL_DEVICE_ID,
                                          NULL,
                                          &dwType,
                                          (LPBYTE)szDevDriver,
                                          &cbData);
                dwErr = ::GetLastError();
                RegCloseKey(hkDevice);
                hkDevice = (HKEY)INVALID_HANDLE_VALUE;

                if(ERROR_SUCCESS == lResult){
                    fDataAcquired = TRUE;
                } // if(ERROR_SUCCESS == lResult)
            } // if(INVALID_HANDLE_VALUE != hkDevice)

            if(!fDataAcquired){

                //
                // Try to open devnode regkey.
                //

                cbData = 0;
                pspDevInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                
                fRet = SetupDiGetDeviceInterfaceDetail(m_DeviceInfoSet,
                                                       &spDevInterfaceData,
                                                       pspDevInterfaceDetailData,
                                                       bufDetailData.QuerySize(),
                                                       &cbData,
                                                       &spDevInfoData);
                if(fRet){

                    //
                    // Get device interface registry key.
                    //

                    hkDevice = SetupDiOpenDevRegKey(m_DeviceInfoSet,
                                                    &spDevInfoData,
                                                    DICS_FLAG_GLOBAL,
                                                    0,
                                                    DIREG_DRV,
                                                    KEY_READ);
                    dwErr = ::GetLastError();
                } else {
                    DBG_ERR(("SetupDiGetDeviceInterfaceDetail() Failed Err=0x%x",GetLastError()));
                }

                if (INVALID_HANDLE_VALUE != hkDevice) {

                    *szDevDriver = TEXT('\0');
                    cbData = sizeof(szDevDriver);

                    lResult = RegQueryValueEx(hkDevice,
                                              REGSTR_VAL_DEVICE_ID,
                                              NULL,
                                              &dwType,
                                              (LPBYTE)szDevDriver,
                                              &cbData);
                    dwErr = ::GetLastError();
                    RegCloseKey(hkDevice);
                    hkDevice = (HKEY)INVALID_HANDLE_VALUE;

                    if(ERROR_SUCCESS == lResult){
                        fDataAcquired = TRUE;
                    } // if(ERROR_SUCCESS == lResult)
                } else { // if (INVALID_HANDLE_VALUE != hkDevice) 
                    DBG_ERR(("SetupDiOpenDevRegKey() Failed Err=0x%x",GetLastError()));
                    fRet = FALSE;
                } // if (INVALID_HANDLE_VALUE != hkDevice) 
            } // if(!fDataAcquired)

            if (fDataAcquired) {
                // Got it
                pstrDriverName->CopyString(szDevDriver);
                fRet =  TRUE;
            } // if (fDataAcquired) 
        } else {
            DBG_ERR(("SetupDiOpenDeviceInterface() Failed Err=0x%x",GetLastError()));
            fRet = FALSE;
        }

        return (fRet);

    }


    //
    // Look up device info data by driver name
    //
    BOOL
    LookupDeviceInfoFromDriverName(
                                 LPCTSTR pszDriverName,
                                 StiCString*    pstrInterfaceName,
                                 DEVINST*pDeviceInstance     = NULL
                                 )
    {
        SP_DEVINFO_DATA         spDevInfoData;
        SP_DEVICE_INTERFACE_DATA   spDevInterfaceData;
        PSP_DEVICE_INTERFACE_DETAIL_DATA    pspDevInterfaceDetailData;

        BUFFER                  bufDetailData;

        TCHAR                   szDevDriver[STI_MAX_INTERNAL_NAME_LENGTH];

        ULONG                   cbData;
        CONFIGRET               cmRet = CR_NO_SUCH_DEVINST;

        DWORD                   dwRequired;
        DWORD                   Idx;
        DWORD                   dwError;
        DWORD                   dwType;

        BOOL                    fRet            = FALSE;
        BOOL                    fFoundMatch     = FALSE;
        LONG                    lResult         = ERROR_SUCCESS;
        HKEY                    hkDevice        = (HKEY)INVALID_HANDLE_VALUE;

        Refresh();

        dwRequired = 0;
        ZeroMemory(&spDevInterfaceData,sizeof(spDevInterfaceData));

        bufDetailData.Resize(sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                             MAX_PATH * sizeof(TCHAR) +
                             16
                            );

        pspDevInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) bufDetailData.QueryPtr();

        if (!pspDevInterfaceDetailData) {
            ::SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return (FALSE);
        }

        if (m_DeviceInfoSet != INVALID_HANDLE_VALUE) {

            ZeroMemory(&spDevInfoData,sizeof(spDevInfoData));

            spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
            spDevInfoData.ClassGuid = m_ClassGuid;

            pspDevInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) bufDetailData.QueryPtr();

            for (Idx = 0; SetupDiEnumDeviceInfo (m_DeviceInfoSet, Idx, &spDevInfoData); Idx++) {

                //
                // Get driver name property
                //

                hkDevice = SetupDiOpenDevRegKey(m_DeviceInfoSet,
                                                &spDevInfoData,
                                                DICS_FLAG_GLOBAL,
                                                0,
                                                DIREG_DRV,
                                                KEY_READ);
                if(INVALID_HANDLE_VALUE != hkDevice){

                    *szDevDriver = TEXT('\0');
                    cbData = sizeof(szDevDriver);

                    lResult = RegQueryValueEx(hkDevice,
                                              REGSTR_VAL_DEVICE_ID,
                                              NULL,
                                              &dwType,
                                              (LPBYTE)szDevDriver,
                                              &cbData);

                    RegCloseKey(hkDevice);
                    hkDevice = (HKEY)INVALID_HANDLE_VALUE;

                    if(ERROR_SUCCESS == lResult){
                        if (lstrcmpi(pszDriverName,szDevDriver) == 0 ) {

                            //
                            // Get interface.
                            //

                            spDevInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
                            spDevInterfaceData.InterfaceClassGuid = m_ClassGuid;

                            fRet = SetupDiEnumDeviceInterfaces (m_DeviceInfoSet,
                                                                &spDevInfoData,
                                                                &(m_ClassGuid),
                                                                0,
                                                                &spDevInterfaceData);
                            if(!fRet){
                                DBG_ERR(("SetupDiEnumDeviceInterfaces() Failed Err=0x%x",GetLastError()));
                                fFoundMatch = FALSE;
                                continue;
                            }

                            //
                            // Found match ..
                            //

                            fFoundMatch = TRUE;

                            break;
                        } // if (lstrcmpi(pszDriverName,szDevDriver) == 0 ) 
                    } //if(ERROR_SUCCESS == lResult)
                } // if(INVALID_HANDLE_VALUE != hkDevice)
            } // for (Idx = 0; SetupDiEnumDeviceInfo (m_DeviceInfoSet, Idx, &spDevInfoData); Idx++) 

            if(!fFoundMatch){

                //
                // Try to get interface regkey.
                //

                spDevInterfaceData.InterfaceClassGuid = m_ClassGuid;
                spDevInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
                for(Idx = 0; SetupDiEnumDeviceInterfaces (m_DeviceInfoSet, NULL, &m_ClassGuid, Idx, &spDevInterfaceData); Idx++) {

                    hkDevice = SetupDiOpenDeviceInterfaceRegKey(m_DeviceInfoSet,
                                                                &spDevInterfaceData,
                                                                0,
                                                                KEY_READ);
                    if(INVALID_HANDLE_VALUE != hkDevice){

                        *szDevDriver = TEXT('\0');
                        cbData = sizeof(szDevDriver);

                        lResult = RegQueryValueEx(hkDevice,
                                                  REGSTR_VAL_DEVICE_ID,
                                                  NULL,
                                                  &dwType,
                                                  (LPBYTE)szDevDriver,
                                                  &cbData);

                        RegCloseKey(hkDevice);
                        hkDevice = (HKEY)INVALID_HANDLE_VALUE;

                        if(ERROR_SUCCESS == lResult){
                            if (lstrcmpi(pszDriverName,szDevDriver) == 0 ) {
                                //
                                // Found match ..
                                //

                                fFoundMatch = TRUE;
                                break;
                            } // if (lstrcmpi(pszDriverName,szDevDriver) == 0 ) 
                        } //if(ERROR_SUCCESS == lResult)
                    } // if(INVALID_HANDLE_VALUE != hkDevice)
                } // for(Idx = 0; SetupDiEnumDeviceInterfaces (m_DeviceInfoSet, NULL, &m_ClassGuid, Idx, &spDevInterfaceData); Idx++) 
            } // if(!fFoundMatch)

            if (fFoundMatch) {

                dwRequired = 0;
                pspDevInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

                fRet = SetupDiGetDeviceInterfaceDetail(m_DeviceInfoSet,
                                                       &spDevInterfaceData,
                                                       pspDevInterfaceDetailData,
                                                       bufDetailData.QuerySize(),
                                                       &dwRequired,
                                                       &spDevInfoData);
                dwError = ::GetLastError();

                if (fRet) {
                    pstrInterfaceName -> CopyString(pspDevInterfaceDetailData->DevicePath);
                    fRet = TRUE;
                } else {
                    // DPRINTF failed to get interface detail
                }
            } // if (fFoundMatch)
        } else {
            // DPRINTF - invalid dev info set handle

        }

        return (fRet);

    }

    //
    // Process refresh message
    //
    BOOL
    ProcessNewDeviceChangeMessage(
                                 IN  LPARAM lParam
                                 )
    {
        DWORD   dwErr;

        PDEV_BROADCAST_DEVICEINTERFACE pDevBroadcastDeviceInterface;
        SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;

        pDevBroadcastDeviceInterface = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;

        //
        // Open this new device interface into our device information
        // set.
        //
        if (!SetupDiOpenDeviceInterface(m_DeviceInfoSet,
                                        pDevBroadcastDeviceInterface->dbcc_name,
                                        0,
                                        NULL)) {
            dwErr = GetLastError();
        }

        #ifdef DEBUG
        Dump();
        #endif

        return (TRUE);

    }

    BOOL
    ProcessDeleteDeviceChangeMessage(
                                    IN  LPARAM lParam
                                    )
    {
        DBG_FN(ProcessDeleteDeviceChangeMessage);
        DWORD   dwErr;

        PDEV_BROADCAST_DEVICEINTERFACE pDevBroadcastDeviceInterface;
        SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;

        pDevBroadcastDeviceInterface = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;

        //
        // First, locate this device interface in our device information
        // set.
        //
        spDevInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        if (SetupDiOpenDeviceInterface(m_DeviceInfoSet,
                                       pDevBroadcastDeviceInterface->dbcc_name,
                                       DIODI_NO_ADD,
                                       &spDevInterfaceData)) {

            if (!SetupDiDeleteDeviceInterfaceData(m_DeviceInfoSet,
                                                  &spDevInterfaceData)) {

                dwErr = GetLastError();
            }
        }

        // Do we need to do refresh now ? BUGBUG
        Refresh();

        #ifdef DEBUG
        Dump();
        #endif
        return (TRUE);

    }


    VOID
    Dump(VOID)
    {

        SP_DEVINFO_DATA     spDevInfoData;
        UINT                Idx;

        ZeroMemory(&spDevInfoData,sizeof(spDevInfoData));

        spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
        spDevInfoData.ClassGuid = m_ClassGuid;

        for (Idx = 0; SetupDiEnumDeviceInfo (m_DeviceInfoSet, Idx, &spDevInfoData); Idx++) {
            Idx = Idx;
        }

    }


    //
    DWORD       m_dwSignature;

private:

    BOOL        m_fValid;

    CRIT_SECT   m_dwCritSec;
    DWORD       m_dwFlags;

    GUID        m_ClassGuid;
    HDEVINFO    m_DeviceInfoSet;
};


//
// Take device class
//
class TAKE_DEVICE_INFOSET {
private:

    DEVICE_INFOSET*    m_pInfoSet;

public:

    inline TAKE_DEVICE_INFOSET(DEVICE_INFOSET* pInfoSet) : m_pInfoSet(pInfoSet)
    {
        m_pInfoSet->EnterCrit();
    }

    inline ~TAKE_DEVICE_INFOSET()
    {
        m_pInfoSet->LeaveCrit();
    }
};

#endif // _INFOSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\ipropitm.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       IPropItm.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        19 Feb, 1998
*
*  DESCRIPTION:
*   Implementation of WIA item class server properties.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include <regstr.h>
#include <wiamindr.h>
// #include <wiadbg.h>

#include "wiapsc.h"
#include "helpers.h"

//
// Strings used to access the registry. REGSTR_* string constants can be
// found in sdk\inc\regstr.h
//

TCHAR g_szREGSTR_PATH_WIA[] = REGSTR_PATH_SETUP TEXT("\\WIA");

/*******************************************************************************
*
*  ReadMultiple
*  WriteMultiple
*  ReadPropertyNames
*  Enum
*  GetPropertyAttributes
*  GetCount
*
*  DESCRIPTION:
*   IWiaPropertyStorage methods.
*
*  PARAMETERS:
*
*******************************************************************************/

/**************************************************************************\
* CWiaItem::ReadMultiple
*
*   This method reads the specified number of properties from the item's
*   current value property storage.  This method conforms to that standard
*   OLE IPropertyStorage::ReadMultiple method.
*
* Arguments:
*
*    cpspec             -   Number of properties to read.
*    rgpspec            -   Array of PropSpec's specifying which properties
*                           are to be read.
*    rgpropvar          -   Array where the property values will be copied
*                           to.
*
* Arguments:
*
*    cpspec
*    rgpspec
*    rgpropvar
*
* Return Value:
*
*    status
*
* History:
*
*    9/3/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::ReadMultiple(
    ULONG cpspec,
    const PROPSPEC __RPC_FAR rgpspec[],
    PROPVARIANT __RPC_FAR rgpropvar[])
{
    DBG_FN(CWiaItem::ReadMultiple);
    HRESULT  hr;
    LONG     lFlags = 0;

    //
    // Corresponding driver item must be valid to talk with hardware.
    //

    hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // rgpropvar must be valid
    //

    if (IsBadWritePtr(rgpropvar, sizeof(PROPVARIANT) * cpspec)) {
        DBG_ERR(("CWiaItem::ReadMultiple, last parameter (rgpropvar) is invalid"));
        return E_INVALIDARG;
    }

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {

        //
        //  Check whether the properties being read are the WIA Managed properties.
        //  If they are, there is still no need to initialize the item.
        //

        if (AreWiaInitializedProps(cpspec, (PROPSPEC*) rgpspec)) {
            return (m_pPropStg->CurStg())->ReadMultiple(cpspec, rgpspec, rgpropvar);
        }

        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::ReadMultiple, InitLazyProps failed"));
            return hr;
        }
    }

    //
    // Check whether the properties requested are all cacheable
    //

    hr = (m_pPropStg->AccessStg())->ReadMultiple(cpspec, rgpspec, rgpropvar);
    if (FAILED(hr)) {

        ReportReadWriteMultipleError(hr, "CWiaItem::ReadMultiple", NULL, TRUE, cpspec, rgpspec);

        //
        // Property attributes are not required absolutely, continue without it.
        //

    } else {

        for (ULONG i = 0; i < cpspec; i++) {

            //
            // The client requests a property not read yet or non-cacheable
            //

            if ((rgpropvar[i].vt == VT_UI4) &&
                (! (rgpropvar[i].lVal & WIA_PROP_CACHEABLE))) {
                break;
            }
        }

        //
        // Clear the access flags from the rgpropvar
        //

        FreePropVariantArray(cpspec, rgpropvar);

        //
        // If all the properties are cacheable, then take the quick path
        //

        if (i == cpspec) {

            hr = (m_pPropStg->CurStg())->ReadMultiple(cpspec, rgpspec, rgpropvar);

            if (hr == S_OK) {

                //
                //  Check whether all the properties are retrieved correctly
                //  some properties might not have been read from the storage
                //

                for (ULONG i = 0; i < cpspec; i++) {

                    if (rgpropvar[i].vt == VT_EMPTY) {
                        break;
                    }
                }

                if (i == cpspec) {

                    //
                    // All the properties requested are found in cache
                    //

                    return (hr);
                } else {

                    FreePropVariantArray(cpspec, rgpropvar);
                }
            }

        }

    }

    if (SUCCEEDED(hr)) {

        //
        //  Make sure all PropSpecs are using PropID's.  This is so that
        //  drivers only have to deal with PropID's.  If some of the
        //  PropSpecs are using string names, then convert them.
        //

        PROPSPEC *pPropSpec = NULL;
        hr = m_pPropStg->NamesToPropIDs(cpspec, (PROPSPEC*) rgpspec, &pPropSpec);
        if (SUCCEEDED(hr)) {

            //
            // Give device mini driver a chance to update the device properties.
            //
            {
                LOCK_WIA_DEVICE _LWD(this, &hr);

                if(SUCCEEDED(hr)) {
                    hr = m_pActiveDevice->m_DrvWrapper.WIA_drvReadItemProperties((BYTE*)this,
                        lFlags,
                        cpspec,
                        (pPropSpec ? pPropSpec : rgpspec),
                        &m_lLastDevErrVal);
                }
            }

            if (pPropSpec) {
                LocalFree(pPropSpec);
                pPropSpec = NULL;
            }
        }

        if (SUCCEEDED(hr)) {
            hr = (m_pPropStg->CurStg())->ReadMultiple(cpspec, rgpspec, rgpropvar);
            if (FAILED(hr)) {
                ReportReadWriteMultipleError(hr,
                                             "CWiaItem::ReadMultiple",
                                             NULL,
                                             TRUE,
                                             cpspec,
                                             rgpspec);
            }
        }
    }

    return hr;
}

/**************************************************************************\
* CWiaItem::ReadPropertyNames
*
*   Returns the string name of the specified properties if they exist.
*   This conforms to the standard OLE IPropertyStorage::ReadPropertyNames
*   method.
*
* Arguments:
*
*   pstmProp - Pointer to property stream.
*
* Return Value:
*
*   Status
*
* History:
*
*    9/3/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::ReadPropertyNames(
    ULONG cpropid,
    const PROPID __RPC_FAR rgpropid[],
    LPOLESTR __RPC_FAR rglpwstrName[])
{
    DBG_FN(CWiaItem::ReadPropertyNames);
    HRESULT hr;

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::ReadPropertyNames, InitLazyProps failed"));
            return hr;
        }
    }

   return (m_pPropStg->CurStg())->ReadPropertyNames(cpropid,rgpropid,rglpwstrName);
}

/**************************************************************************\
* CWiaItem::WritePropertyNames
*
*   Returns the string name of the specified properties if they exist.
*   This conforms to the standard OLE IPropertyStorage::ReadPropertyNames
*   method.
*
* Arguments:
*
*   pstmProp - Pointer to property stream.
*
* Return Value:
*
*   Status
*
* History:
*
*    9/3/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::WritePropertyNames(
    ULONG           cpropid,
    const PROPID    rgpropid[],
    const LPOLESTR  rglpwstrName[])
{
    DBG_FN(CWiaItem::WritePropertyNames);
    PROPVARIANT *pv;
    PROPSPEC    *pspec;
    ULONG       index;
    HRESULT     hr;

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::WritePropertyNames, InitLazyProps failed"));
            return hr;
        }
    }

    pv = (PROPVARIANT*) LocalAlloc(LPTR, sizeof(PROPVARIANT) * cpropid);
    if (!pv) {
        DBG_ERR(("CWiaItem::WritePropertyNames, Out of memory"));
        return E_OUTOFMEMORY;
    }

    pspec = (PROPSPEC*) LocalAlloc(LPTR, sizeof(PROPSPEC) * cpropid);
    if (!pspec) {
        DBG_ERR(("CWiaItem::WritePropertyNames, Out of memory"));
        LocalFree(pv);
        return E_OUTOFMEMORY;
    }

    //
    //  Put PROPIDs into the PROPSPEC array.
    //

    for (index = 0; index < cpropid; index++) {
        pspec[index].ulKind = PRSPEC_PROPID;
        pspec[index].propid = rgpropid[index];
    }

    hr = (m_pPropStg->AccessStg())->ReadMultiple(cpropid,
                                                 pspec,
                                                 pv);
    if (SUCCEEDED(hr)) {

        //
        //  Make sure the properties are App. written properties.  If a valid
        //  access flag for a property exists, then it was written by the
        //  driver and not the App, so exit.
        //

        for (index = 0; index < cpropid; index++) {
            if (pv[index].vt != VT_EMPTY) {
                DBG_ERR(("CWiaItem::WritePropertyNames, not allowed to write prop: %d.",rgpropid[index]));
                hr = E_ACCESSDENIED;
                break;
            }
        }

        if (SUCCEEDED(hr)) {
            hr = (m_pPropStg->CurStg())->WritePropertyNames(cpropid,
                                                            rgpropid,
                                                            rglpwstrName);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaItem::WritePropertyNames, WritePropertyNames failed"));
            }
        }
    } else {
        DBG_ERR(("CWiaItem::WritePropertyNames, Reading Access values failed"));
    }

    LocalFree(pspec);
    LocalFree(pv);
    return hr;
}

/**************************************************************************\
* CWiaItem::Enum
*
*   Returns a IEnumSTATPROPSTG enumerator over the current value property
*   storage.  Conforms to the standard OLE IPRopertyStorage::Enum method.
*
* Arguments:
*
*   pstmProp - Pointer to property stream.
*
* Return Value:
*
*   Status
*
* History:
*
*    9/3/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::Enum(
   IEnumSTATPROPSTG __RPC_FAR *__RPC_FAR *ppenum)
{
    DBG_FN(CWiaItem::Enum);
    HRESULT hr;

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::Enum, InitLazyProps failed"));
            return hr;
        }
    }

    return (m_pPropStg->CurStg())->Enum(ppenum);
}

/**************************************************************************\
* CWiaItem::WriteMultiple
*
*   This method writes the specified number of properties into the item's
*   property storage.  Validation will be performed on those property
*   values. The properties will be restored to their old (valid) values
*   if validation fails.
*
* Arguments:
*
*    cpspec             -   Number of properties to write.
*    rgpspec            -   Array of PropSpec's specifying which properties
*                           are to be written.
*    rgpropvar          -   Array containing values that the properties
*                           will be set to.
*    propidNameFirst    -   Minimum value for property identifiers when
*                           they don't exist and must be allocated.
*
* Return Value:
*
*   Status              -   S_OK if writes and validation succeeded.
*                           E_INVALIDARG if validation failed due to an
*                           incorrect property value.
*                           Other error returns are from
*                           ValidateWiaDrvItemAccess, CheckPropertyAccess,
*                           CreatePropertyStorage and CopyProperties.
*
* History:
*
*    9/3/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::WriteMultiple(
    ULONG                        cpspec,
    const PROPSPEC __RPC_FAR     rgpspec[],
    const PROPVARIANT __RPC_FAR  rgpropvar[],
    PROPID                       propidNameFirst)
{
    DBG_FN(CWiaItem::WriteMultiple);
    HRESULT hr;

    //
    // Corresponding driver item must be valid.
    //

    hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::WriteMultiple, ValidateDrvItemAccess failed"));
        return hr;
    }

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::WriteMultiple, InitLazyProps failed"));
            return hr;
        }
    }

    //
    // there is no point in going further if there are no properties to
    // write
    //
    if(cpspec == 0) {
        return S_OK;
    }

    //
    // We do not want to fail users who erroneousely attempt to write
    // to write to read-only properties IF that the values they
    // are trying to write are the same as current values. To achive
    // this, we first current values of the properties they want to
    // write:
    //

    PROPVARIANT *curVals = (PROPVARIANT *) LocalAlloc(LPTR, sizeof(PROPVARIANT) * cpspec);
    PROPSPEC *newSpecs = (PROPSPEC *) LocalAlloc(LPTR, sizeof(PROPSPEC) * cpspec);
    PROPVARIANT *newVals = (PROPVARIANT *) LocalAlloc(LPTR, sizeof(PROPVARIANT) * cpspec);
    ULONG newcpspec = cpspec;

    if(curVals == NULL || newSpecs == NULL || newVals == NULL) {
        DBG_ERR(("CWiaItem::WriteMultiple, failed to allocate memory"));
        goto Cleanup;
    }

    CopyMemory(newSpecs, rgpspec, sizeof(PROPSPEC) * cpspec);
    CopyMemory(newVals, rgpropvar, sizeof(PROPVARIANT) * cpspec);

    memset(curVals, 0, sizeof(PROPVARIANT) * cpspec);
    hr = m_pPropStg->CurStg()->ReadMultiple(cpspec, rgpspec, curVals);
    if(SUCCEEDED(hr)) {
        //
        // Now for every property value they want to write we check if
        // it is the same as the current value
        //

        ULONG   ulNewEltIndex = 0;
        for(ULONG i = 0; i < cpspec; i++) {

            if(curVals[i].vt != rgpropvar[i].vt)
                continue;

            if(memcmp(curVals + i, rgpropvar + i, sizeof(PROPVARIANT)) == 0 ||
               (curVals[i].vt == VT_BSTR && !lstrcmp(curVals[i].bstrVal, rgpropvar[i].bstrVal)) ||
               (curVals[i].vt == VT_CLSID && IsEqualGUID(*curVals[i].puuid, *rgpropvar[i].puuid)))
            {
                // the value "matches", wipe it from both arrays.
                if(i != (cpspec - 1)) {

                    //
                    //  Move a block of values/propspecs.
                    //  The number of elements to move is 1 less than the
                    //  remaining number of elements we still have to check.
                    //  Move these elements up in the new value array - put
                    //  them after the elements we've decided to keep so far
                    //
                    MoveMemory(newVals + ulNewEltIndex,
                               newVals + ulNewEltIndex + 1,
                               (cpspec - i - 1) * sizeof(PROPVARIANT));
                    MoveMemory(newSpecs + ulNewEltIndex,
                               newSpecs + ulNewEltIndex + 1,
                               (cpspec - i - 1) * sizeof(PROPSPEC));
                }

                newcpspec--;
            } else {
                //
                //  We want to keep this element, so increase the element index.
                //
                ulNewEltIndex++;
            }
        }

        // It could happen that all values are the same, in which case we
        // don't want to write anything at all
        if(newcpspec == 0) {
            hr = S_OK;
            goto Cleanup;
        }
    }


    //
    //  Verify write access to all requested properties. If any of the
    //  properties are read ony, the call fails with access denied.
    //

    hr = m_pPropStg->CheckPropertyAccess(TRUE,
                                         newcpspec,
                                         (PROPSPEC*)newSpecs);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::WriteMultiple, CheckPropertyAccess failed"));
        goto Cleanup;
    }

    //
    //  First create the backup.
    //

    hr = m_pPropStg->Backup();
    if (SUCCEEDED(hr)) {

        //
        //  Write property values.
        //

        hr =  (m_pPropStg->CurStg())->WriteMultiple(newcpspec,
                                                    newSpecs,
                                                    newVals,
                                                    propidNameFirst);
        if (SUCCEEDED(hr)) {

            //
            //  Write was successful, so do validation
            //

            LONG    lFlags = 0;

            //
            //  Make sure all PropSpecs are using PropID's.  If some of the
            //  PropSpecs are using string names, then convert them.
            //  This is so that drivers only have to deal with PropID's.
            //

            PROPSPEC *pPropSpec = NULL;

            hr = m_pPropStg->NamesToPropIDs(newcpspec, (PROPSPEC*) newSpecs, &pPropSpec);
            if (SUCCEEDED(hr)) {

                //
                // Let the device mini driver know the properties have changed.
                // Device only gets propspec, must read prop values from item's
                // property stream.
                //
                {
                    LOCK_WIA_DEVICE _LWD(this, &hr);

                    if(SUCCEEDED(hr)) {
                        hr = m_pActiveDevice->m_DrvWrapper.WIA_drvValidateItemProperties((BYTE*)this,
                            lFlags,
                            newcpspec,
                            (pPropSpec ? pPropSpec : newSpecs),
                            &m_lLastDevErrVal);
                    }
                }

                if (pPropSpec) {
                    LocalFree(pPropSpec);
                    pPropSpec = NULL;
                }
            } else {
                DBG_ERR(("CWiaItem::WriteMultiple, conversion to PropIDs failed"));
            }

        } else {
            DBG_ERR(("CWiaItem::WriteMultiple, test write failed"));
        }

        HRESULT hresult;

        if (SUCCEEDED(hr)) {

            //
            //  Validation passed, so free the backups.  Use a new
            //  HRESULT, since we don't want to overwrite hr returned by
            //  drvValidateItemProperties.
            //

            hresult = m_pPropStg->ReleaseBackups();
            if (FAILED(hresult)) {
                DBG_ERR(("CWiaItem::WriteMultiple, ReleaseBackups failed, continuing anyway..."));
            }
        } else {

            //
            //  Didn't pass validation failed, so restore old values.  Use
            //  a new HRESULT, since we don't want to overwrite hr returned
            //  by drvValidateItemProperties.
            //

            hresult = m_pPropStg->Undo();
            if (FAILED(hresult)) {

                DBG_ERR(("CWiaItem::WriteMultiple, Undo() failed, could not restore invalid properties to their original values"));
            }
        }
    } else {
        DBG_ERR(("CWiaItem::WriteMultiple, couldn't make backup copy of properties"));
    }

Cleanup:
    if(curVals) {
        FreePropVariantArray(cpspec, curVals);
        LocalFree(curVals);
    }
    if(newVals) LocalFree(newVals);
    if(newSpecs) LocalFree(newSpecs);

    return hr;
}

/**************************************************************************\
* GetPropertyAttributes
*
*   Get the access flags and valid values for a property.
*
* Arguments:
*
*   pWiasContext   - Pointer to WIA item
*   cPropSpec      - The number of properties
*   pPropSpec      - array of property specification.
*   pulAccessFlags - array of LONGs access flags.
*   pPropVar       - Pointer to returned valid values.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/15/1999 Original Version
*   07/19/1999 Moved from iitem to ipropitm to implement IWiaPropertyStorage
*              interface.
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::GetPropertyAttributes(
    ULONG                   cPropSpec,
    PROPSPEC                pPropSpec[],
    ULONG                   pulAccessFlags[],
    PROPVARIANT             ppvValidValues[])
{
    DBG_FN(CWiaItem::GetPropertyAttributes);
    HRESULT hr;

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::GetPropertyAttributes, InitLazyProps failed"));
            return hr;
        }
    }

    //
    //  RPC has already done parameter validation for us, so call
    //  GetPropertyAttributesHelper to do the work.
    //
    return GetPropertyAttributesHelper(this,
                                       cPropSpec,
                                       pPropSpec,
                                       pulAccessFlags,
                                       ppvValidValues);
}

/**************************************************************************\
* CWiaItem::GetCount
*
*   Returns the number of properties stored in an item's current value
*   property storage.
*
* Arguments:
*
*   pulPropCount    - Address to store the property count.
*
* Return Value:
*
*   Status
*
* History:
*
*    9/3/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::GetCount(
    ULONG*      pulPropCount)
{
    DBG_FN(CWiaItem::GetCount);
    IEnumSTATPROPSTG    *pIEnum;
    STATPROPSTG         stg;
    ULONG               ulCount;
    HRESULT             hr = S_OK;

    if (pulPropCount == NULL) {
        DBG_ERR(("CWiaItem::GetCount, NULL parameter!"));
        return E_INVALIDARG;
    } else {
        *pulPropCount = 0;
    }

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::GetCount, InitLazyProps failed"));
            return hr;
        }
    }

    hr = (m_pPropStg->CurStg())->Enum(&pIEnum);
    if (SUCCEEDED(hr)) {
        ulCount = 0;

        while (pIEnum->Next(1, &stg, NULL) == S_OK) {
            ulCount++;

            if(stg.lpwstrName) {
                CoTaskMemFree(stg.lpwstrName);
            }
        }

        if (SUCCEEDED(hr)) {
            hr = S_OK;
            *pulPropCount = ulCount;
        } else {
            DBG_ERR(("CWiaItem::GetCount, pIEnum->Next failed (0x%X)", hr));
        }
        pIEnum->Release();
    } else {
        DBG_ERR(("CWiaItem::GetCount, Enum off CurStg failed (0x%X)", hr));
    }
    return hr;
}

/**************************************************************************\
* CWiaItem::GetPropertyStream
*
*   Get a copy of an items property stream. Caller must free returned
*   property stream.
*
* Arguments:
*
*   pCompatibilityId    - Address of GUID to receive the device's property
*                         stream CompatibilityId.
*   ppstmProp           - Pointer to returned property stream.
*
* Return Value:
*
*   Status
*
* History:
*
*   09/03/1998 Original Version
*   12/12/1999 Modified to use CompatibilityId
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::GetPropertyStream(
    GUID     *pCompatibilityId,
    LPSTREAM *ppstmProp)
{
    DBG_FN(CWiaItem::GetPropertyStream);

    HRESULT hr;

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::GetPropertyStream, InitLazyProps failed"));
            return hr;
        }
    }

    return m_pPropStg->GetPropertyStream(pCompatibilityId, ppstmProp);
}

/**************************************************************************\
* CWiaItem::SetPropertyStream
*
*   Set an items property stream.
*
* Arguments:
*
*   pCompatibilityId    - Pointer to a GUID representing the property
*                         stream CompatibilityId.
*   pstmProp            - Pointer to property stream.
*
* Return Value:
*
*   Status
*
* History:
*
*   09/03/1998  Original Version
*   12/12/1999  Modified to use CompatibilityId
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::SetPropertyStream(
    GUID        *pCompatibilityId,
    LPSTREAM    pstmProp)
{
    DBG_FN(CWiaItem::SetPropertyStream);
    HRESULT hr;

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::SetPropertyStream, InitLazyProps failed"));
            return hr;
        }
    }

    return m_pPropStg->SetPropertyStream(pCompatibilityId, this, pstmProp);
}

/**************************************************************************\
*
*   Methods of IPropertyStorage not directly off IWiaPropertySTorage
*
*   DeleteMultiple
*   DeletePropertyNames
*   Commit
*   Revert
*   SetTimes
*   SetClass
*   Stat
*
*   9/3/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::DeleteMultiple(
    ULONG cpspec,
    const PROPSPEC __RPC_FAR rgpspec[])
{
    DBG_FN(CWiaItem::DeleteMultiple);
   return E_ACCESSDENIED;
}

HRESULT _stdcall CWiaItem::DeletePropertyNames(
    ULONG cpropid,
    const PROPID __RPC_FAR rgpropid[])
{
    DBG_FN(CWiaItem::DeletePropertyNames);
   return E_ACCESSDENIED;
}

HRESULT _stdcall CWiaItem::Commit(DWORD grfCommitFlags)
{
    DBG_FN(CWiaItem::Commit);
    HRESULT hr;

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::Commit, InitLazyProps failed"));
            return hr;
        }
    }

    hr = (m_pPropStg->CurStg())->Commit(grfCommitFlags);
    return hr;
}

HRESULT _stdcall CWiaItem::Revert(void)
{
    DBG_FN(CWiaItem::Revert);
   HRESULT hr;

   //
   //  Check whether item properties have been initialized
   //

   if (!m_bInitialized) {
       hr = InitLazyProps();
       if (FAILED(hr)) {
           DBG_ERR(("CWiaItem::Revert, InitLazyProps failed"));
           return hr;
       }
   }

   hr = (m_pPropStg->CurStg())->Revert();
   return hr;
}

HRESULT _stdcall CWiaItem::SetTimes(
    const FILETIME __RPC_FAR *pctime,
    const FILETIME __RPC_FAR *patime,
    const FILETIME __RPC_FAR *pmtime)
{
    DBG_FN(CWiaItem::SetTimes);
   HRESULT hr;

   //
   //  Check whether item properties have been initialized
   //

   if (!m_bInitialized) {
       hr = InitLazyProps();
       if (FAILED(hr)) {
           DBG_ERR(("CWiaItem::SetTimes, InitLazyProps failed"));
           return hr;
       }
   }

   hr = (m_pPropStg->CurStg())->SetTimes(pctime,patime,pmtime);
   return hr;
}

HRESULT _stdcall CWiaItem::SetClass(REFCLSID clsid)
{
    DBG_FN(CWiaItem::SetClass);
    HRESULT hr;

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {
        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::SetClass, InitLazyProps failed"));
            return hr;
        }
    }
    return (m_pPropStg->CurStg())->SetClass(clsid);
}

HRESULT _stdcall CWiaItem::Stat(STATPROPSETSTG *pstatpsstg)
{
    DBG_FN(CWiaItem::Stat);
   HRESULT hr;

   //
   //  Check whether item properties have been initialized
   //

   if (!m_bInitialized) {
       hr = InitLazyProps();
       if (FAILED(hr)) {
           DBG_ERR(("CWiaItem::Stat, InitLazyProps failed"));
           return hr;
       }
   }

   hr = (m_pPropStg->CurStg())->Stat(pstatpsstg);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\lockmgr.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       WiaLock.Cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        15 November, 1999
*
*  DESCRIPTION:
*   Implementation of Lock Manager.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"


//
//  Include Headers
//

#include <time.h>
#include "device.h"
#include "wiamonk.h"
#include "wiapriv.h"
#include  "stiusd.h"

#define DECLARE_LOCKMGR
#include "lockmgr.h"

/**************************************************************************\
* StiLockMgr
*
*  Constructor for the lock manager.
*
* Arguments:
*
* Return Value:
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

StiLockMgr::StiLockMgr()
{
    DBG_FN(StiLockMgr::StiLockMgr);
    m_cRef = 0;
    m_dwCookie = 0;
    m_bSched = FALSE;
    m_lSchedWaitTime = 0;
}

/**************************************************************************\
* Initialize
*
*  Initializes the lock manager and registers this instance in the ROT.
*
* Arguments:
*
* Return Value:
*
*   Status
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

HRESULT StiLockMgr::Initialize()
{
    DBG_FN(StiLockMgr::Initialize);
    HRESULT             hr  =   S_OK;

    //
    // Artificially set ref count too high to prevent destruction from inside Release()
    //
    m_cRef = 2;

#ifdef USE_ROT

    CWiaInstMonk        *pInstMonk = new CWiaInstMonk();
    CHAR                szCookieName[MAX_PATH];
    IUnknown            *pUnk;
    IMoniker            *pIMoniker;
    IBindCtx            *pCtx;
    IRunningObjectTable *pTable;

USES_CONVERSION;

    //
    //  Make up a cookie name.  This will be stored in the registry.  This
    //  name uniquely identifies our lock manager on the system.
    //

    srand( (unsigned)time( NULL ) );
    sprintf(szCookieName, "%d_LockMgr_%d", rand(), rand());

    //
    //  Get our IUnknown interface
    //

    hr = QueryInterface(IID_IUnknown, (VOID**) &pUnk);
    if (SUCCEEDED(hr)) {

        //
        //  We need to register this object in the ROT, so that any STI clients
        //  will connect to this Lock Manager.  This way, we maintain consistent
        //  device lock information amongst multiple STI and WIA clients.
        //
        //  First create an instance Moniker.  Then get a pointer to the ROT.
        //  Register this named moniker with our Lock Manager.  Store the
        //  cookie so we can unregister upon destruction of the Lock Manager.
        //

        if (pInstMonk) {
            hr = pInstMonk->Initialize(A2W(szCookieName));
            if (SUCCEEDED(hr)) {
                hr = pInstMonk->QueryInterface(IID_IMoniker, (VOID**) &pIMoniker);
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    }



    if (SUCCEEDED(hr)) {

        hr = CreateBindCtx(0, &pCtx);
        if (SUCCEEDED(hr)) {

            hr = pCtx->GetRunningObjectTable(&pTable);
            if (SUCCEEDED(hr)) {

                //
                //  Register ourselves in the ROT
                //

                hr = pTable->Register(ROTFLAGS_ALLOWANYCLIENT,
                                      pUnk,
                                      pIMoniker,
                                      &m_dwCookie);

                ASSERT(hr == S_OK);

                //
                //  Write the cookie name to the registry, so clients will know
                //  the name of our lock manager.
                //

                if (hr == S_OK) {

                    hr = WriteCookieNameToRegistry(szCookieName);
                } else {
                    DBG_ERR(("StiLockMgr::Initialize, could not register Moniker"));
                    hr = (SUCCEEDED(hr)) ? E_FAIL : hr;
                }

                pTable->Release();
            } else {
                DBG_ERR(("StiLockMgr::Initialize, could not get Running Object Table"));
            }

            pCtx->Release();
        } else {
            DBG_ERR(("StiLockMgr::Initialize, could not create bind context"));
        }
    } else {
        DBG_ERR(("StiLockMgr::Initialize, problem creating Moniker"));
    }


    if (pInstMonk) {
        pInstMonk->Release();
    }
#endif
    return hr;
}

/**************************************************************************\
* ~StiLockMgr
*
*   Destructor - removes instance from the ROT that was resgistered in
*   Initialize.
*
* Arguments:
*
* Return Value:
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

StiLockMgr::~StiLockMgr()
{
    DBG_FN(StiLockMgr::~StiLockMgr);
    m_cRef = 0;

#ifdef USE_ROT
    if (m_dwCookie) {
        HRESULT             hr;
        IBindCtx            *pCtx;
        IRunningObjectTable *pTable;

        hr = CreateBindCtx(0, &pCtx);
        if (SUCCEEDED(hr)) {
            hr = pCtx->GetRunningObjectTable(&pTable);
            if (SUCCEEDED(hr)) {
                hr = pTable->Revoke(m_dwCookie);
            }
        }
        DeleteCookieFromRegistry();

        if (FAILED(hr)) {

            DBG_ERR(("StiLockMgr::~StiLockMgr, could not Unregister Moniker"));
        }

        m_dwCookie = 0;
    }
#endif

    m_bSched = FALSE;
    m_lSchedWaitTime = 0;
}

/**************************************************************************\
* IUnknown methods
*
*   QueryInterface
*   AddRef
*   Release
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall StiLockMgr::QueryInterface(
    const IID& iid,
    void** ppv)
{
    if (iid == IID_IUnknown) {
        *ppv = (IUnknown*) this;
    } else if (iid == IID_IStiLockMgr) {
        *ppv = (IStiLockMgr*) this;
    } else {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG   _stdcall StiLockMgr::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

ULONG   _stdcall StiLockMgr::Release(void)
{
    LONG    ref;

    InterlockedDecrement(&m_cRef);
    ref = m_cRef;

    if (ref == 0) {
        delete this;
    }

    return ref;
}

/**************************************************************************\
* RequestLock
*
*  Attempt to acquire a device lock.  NOTE:  Do not attempt this call from
*  inside an ACTIVE_DEVICE - it may lead to dealock.  Use
*  RequestLock(ACTIVE_DEVICE, ...) instead.
*
* Arguments:
*
*   pszDeviceName   -   The STI internal name of the device (same as WIA
*                       device ID)
*   ulTimeout       -   The max. amount of time to wait for a lock
*   bInServerProcess-   Indicates whether we're being called from within the
*                       server's process.
*
* Return Value:
*
*   Status
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall StiLockMgr::RequestLock(BSTR  pszDeviceName, ULONG ulTimeout, BOOL bInServerProcess, DWORD dwClientThreadId)
{
    DBG_FN(StiLockMgr::RequestLock);
    HRESULT         hr          = E_FAIL;
    ACTIVE_DEVICE   *pDevice    = NULL;

USES_CONVERSION;

    //
    //  Get the device specified by pszDeviceName
    //

    pDevice = g_pDevMan->IsInList(DEV_MAN_IN_LIST_DEV_ID, pszDeviceName);
    if(pDevice) {
        hr = RequestLockHelper(pDevice, ulTimeout, bInServerProcess, dwClientThreadId);

        //
        //  Release the device due to the AddRef made by the call to
        //  IsInList
        //

        pDevice->Release();
    } else {

        //
        //  Device not found, log error
        //

        DBG_ERR(("StiLockMgr::RequestLock, device name was not found"));
        hr = STIERR_INVALID_DEVICE_NAME;
    }

    return hr;
}

/**************************************************************************\
* RequestLock
*
*  Attempt to acquire a device lock.  This method is always called from
*  the server.
*
* Arguments:
*
*   pDevice     -   The STI ACTIVE_DEVICE object
*   ulTimeout   -   The max. amount of time to wait for a lock
*
* Return Value:
*
*   Status
*
* History:
*
*    12/06/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall StiLockMgr::RequestLock(ACTIVE_DEVICE *pDevice, ULONG ulTimeout, BOOL bOpenPort)
{
    DBG_FN(StiLockMgr::RequestLock);

    return RequestLockHelper(pDevice, ulTimeout, bOpenPort, GetCurrentThreadId());
}


/**************************************************************************\
* RequestLockHelper
*
*  Helper used to acquire a device lock.  It fills out the appropriate
*  lock information stored with the device.
*
* Arguments:
*
*   pDevice         -   A pointer to the STI device
*   ulTimeout       -   The max. amount of time to wait for a lock
*   bInServerProcess-   Indicates whether we're in the server process
*
* Return Value:
*
*   Status
*
* History:
*
*    12/06/1999 Original Version
*
\**************************************************************************/

HRESULT StiLockMgr::RequestLockHelper(ACTIVE_DEVICE *pDevice, ULONG ulTimeout, BOOL bInServerProcess, DWORD dwClientThreadId)
{
    DBG_FN(StiLockMgr::RequestLockHelper);
    HRESULT         hr          = S_OK;
    DWORD           dwWait      = 0;
    LockInfo        *pLockInfo  = NULL;
    DWORD           dwCurThread = 0;

    hr = CheckDeviceInfo(pDevice);
    if (FAILED(hr)) {
        return hr;
    }

    pLockInfo = (LockInfo*) pDevice->m_pLockInfo;

    //
    //  Check whether this is the same thread re-acquiring an active lock.
    //  If not, we must wait for device to become free.
    //

    dwCurThread = dwClientThreadId;
    if (InterlockedCompareExchange((LONG*)&pLockInfo->dwThreadId,
                                   dwCurThread,
                                   dwCurThread) == (LONG) dwCurThread) {

        pLockInfo->lInUse++;
        pLockInfo->lTimeLeft = pLockInfo->lHoldingTime;
    } else {

        dwWait = WaitForSingleObject(pLockInfo->hDeviceIsFree, ulTimeout);
        if (dwWait == WAIT_OBJECT_0) {
            //
            //  Check whether the driver is still loaded.
            //
            if (pDevice->m_DrvWrapper.IsDriverLoaded()) {
                //
                //  Update lock information
                //

                InterlockedExchange((LONG*) &pLockInfo->dwThreadId, dwCurThread);
                pLockInfo->lTimeLeft = pLockInfo->lHoldingTime;
                pLockInfo->lInUse++;

                //
                //  Only ask USD to open port if we're in the server process.
                //

                if (bInServerProcess) {
                    hr = LockDevice(pDevice);
                } else {
                    pLockInfo->bDeviceIsLocked = TRUE;
                }
            } else {
                //
                //  Driver not loaded, so clear the lock info.  This is the 
                //  case where an application was sitting on a request to 
                //  lock the device, but the service's control thread 
                //  was busy unloading it.  We want to stop it here, so
                //  we don't make the bogus call down to the driver
                //  which we know is not loaded.
                //
                ClearLockInfo(pLockInfo);
                hr = WIA_ERROR_OFFLINE;
            }

        } else {
            DBG_ERR(("StiLockMgr::RequestLockHelper, device is busy"));

            hr = WIA_ERROR_BUSY;
        }
    }
    return hr;
}

/**************************************************************************\
* RequestUnlock
*
*  Attempt to unlock a device.  NOTE:  Do not attempt this call from
*  inside an ACTIVE_DEVICE - it may lead to dealock.  Use
*  RequestUnlock(ACTIVE_DEVICE, ...) instead.
*
* Arguments:
*
*   pszDeviceName   -   The STI internal name of the device (same as WIA
*                       device ID)
*   bInServerProcess-   Indicates whether we're in the server process
*
* Return Value:
*
*   Status
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall StiLockMgr::RequestUnlock(BSTR  bstrDeviceName, BOOL bInServerProcess, DWORD dwClientThreadId)
{
    DBG_FN(StiLockMgr::RequestUnlock);
    HRESULT         hr                      = E_FAIL;
    ACTIVE_DEVICE   *pDevice                = NULL;

USES_CONVERSION;

    //
    //  Get the device specified by pszDeviceName
    //

    pDevice = g_pDevMan->IsInList(DEV_MAN_IN_LIST_DEV_ID, bstrDeviceName);
    if(pDevice) {

        hr = RequestUnlockHelper(pDevice, bInServerProcess, dwClientThreadId);

        //
        //  Release the device due to the AddRef made by the call to
        //  IsInList
        //

        pDevice->Release();
    } else {

        //
        //  Device not found, log error
        //

        DBG_ERR(("StiLockMgr::RequestUnlock, device name was not found"));
        hr = STIERR_INVALID_DEVICE_NAME;
    }

    return hr;
}

/**************************************************************************\
* RequestUnlock
*
*  Attempt to unlock a device.  This method is always called from within
*  the server.
*
* Arguments:
*
*   pDevice     -   The STI ACTIVE_DEVICE object
*
* Return Value:
*
*   Status
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall StiLockMgr::RequestUnlock(ACTIVE_DEVICE    *pDevice, BOOL bClosePort)
{
    DBG_FN(StiLockMgr::RequestUnlock);
    return RequestUnlockHelper(pDevice, bClosePort, GetCurrentThreadId());

}

/**************************************************************************\
* RequestUnlockHelper
*
*  Helper used to unlock a device lock.  It clears the appropriate
*  lock information stored with the device.
*
* Arguments:
*
*   pDevice         -   A pointer to the STI device
*   ulTimeout       -   The max. amount of time to wait for a lock
*   bInServerProcess-   Indicates whether we're in the server process
*
* Return Value:
*
*   Status
*
* History:
*
*    12/06/1999 Original Version
*
\**************************************************************************/

HRESULT StiLockMgr::RequestUnlockHelper(ACTIVE_DEVICE *pDevice, BOOL bInServerProcess, DWORD dwClientThreadId)
{
    DBG_FN(StiLockMgr::RequestUnlockHelper);
    HRESULT         hr                      = S_OK;
    LockInfo        *pLockInfo              = NULL;
    BOOL            bDidNotUnlock           = TRUE;


    hr = CheckDeviceInfo(pDevice);
    if (FAILED(hr)) {
        DBG_ERR(("StiLockMgr::RequestUnlockHelper, CheclDeviceInfo() failed with hr=%x", hr));
        return hr;
    }

    pLockInfo = (LockInfo*) pDevice->m_pLockInfo;

    //
    //  Special case exists if device has been marked for removal.  In this
    //  case, we want to unlock now (definitely not schedule for later).
    //

    if (pDevice->QueryFlags() & STIMON_AD_FLAG_REMOVING) {

        if (pLockInfo) {
            if (pLockInfo->bDeviceIsLocked) {
                UnlockDevice(pDevice);
            }

            hr = ClearLockInfo(pLockInfo);
            if (FAILED(hr)) {
                DBG_ERR(("StiLockMgr::RequestUnlockHelper, could not clear lock information"));
            }
        }
        return hr;
    }

    //
    //  Decrement the usage count.  If usage count == 0, then reset the
    //  lock information, but don't actually unlock.  (To improve (burst)
    //  performance, we will hold onto the lock for a maximum idle period
    //  specified by pLockInfo->lHoldingTime).  Only if lHoldingTime is 0,
    //  do we unlock straightaway.
    //

    if (pLockInfo->lInUse > 0) {
        pLockInfo->lInUse--;
    }

    if (pLockInfo->lInUse <= 0) {

        //
        //  Only unlock if holding is 0 and we're in the server process.
        //

        if ((pLockInfo->lHoldingTime == 0) && bInServerProcess) {
            UnlockDevice(pDevice);
            bDidNotUnlock = FALSE;
        }

        hr = ClearLockInfo(pLockInfo);
        if (FAILED(hr)) {
            DBG_ERR(("StiLockMgr::RequestUnlockHelper, failed to clear lock information"));
        }

        //
        //  If we're not in the server process, nothing left to do,
        //  so return.
        //

        if (!bInServerProcess) {
            pLockInfo->bDeviceIsLocked = FALSE;
            return hr;
        }

    }

    //
    //  If we did not unlock the device, then schedule the unlock
    //  callback to unlock it later.
    //

    if (bDidNotUnlock) {
        m_lSchedWaitTime = pLockInfo->lHoldingTime;

        if (!m_bSched) {

            if (ScheduleWorkItem((PFN_SCHED_CALLBACK) UnlockTimedCallback,
                                 this,
                                 m_lSchedWaitTime,
                                 NULL)) {
                m_bSched = TRUE;
            }
        }
    }
    return hr;
}

/**************************************************************************\
* CreateLockInfo
*
*  Allocates and initializes a new LockInfo struct.
*
* Arguments:
*
*   pDevice -   The STI ACTIVE_DEVICE object.
*
* Return Value:
*
*   Status
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

HRESULT StiLockMgr::CreateLockInfo(ACTIVE_DEVICE *pDevice)
{
    DBG_FN(StiLockMgr::CreateLockInfo);
    HRESULT     hr          = S_OK;
    LockInfo    *pLockInfo  = NULL;

USES_CONVERSION;

    //
    //  Allocate memory for the structure
    //

    pLockInfo = (LockInfo*) LocalAlloc(LPTR, sizeof(LockInfo));
    if (pLockInfo) {
        memset(pLockInfo, 0, sizeof(LockInfo));

        pLockInfo->hDeviceIsFree = CreateEvent(NULL, FALSE, TRUE, NULL);
        if (pLockInfo->hDeviceIsFree) {

            //
            //  Get any relevant lock information
            //

            pLockInfo->lHoldingTime = pDevice->m_DrvWrapper.getLockHoldingTime();
            DBG_TRC(("StiLockMgr::CreateLockInfo, Lock holding time set to %d for device %S",
                         pLockInfo->lHoldingTime,
                         pDevice->GetDeviceID()));

            pLockInfo->lTimeLeft = pLockInfo->lHoldingTime;

            //
            //  Everything's OK, so set the device's lock information
            //

            pDevice->m_pLockInfo = pLockInfo;

        } else {
            DBG_ERR(("StiLockMgr::CreateLockInfo, could not create event"));
            LocalFree(pLockInfo);
            hr = E_FAIL;
        }
    } else {
        DBG_ERR(("StiLockMgr::CreateLockInfo, out of memory"));
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

/**************************************************************************\
* ClearLockInfo
*
*   Clears information stored in a lockinfo struct.  Also signals that the
*   device is free.  Note:  it does not unlock the device.
*
* Arguments:
*
*   pLockInfo  -   a pointer to the device's LockInfo struct.
*
* Return Value:
*
*   Status
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

HRESULT StiLockMgr::ClearLockInfo(LockInfo *pLockInfo)
{
    DBG_FN(StiLockMgr::ClearLockInfo);

    //
    //  Note: As much lock information is reset as can be done without
    //  unlocking the device.  This method is only called when lInuse
    //  is 0, indicating that the device is no longer being actively used.
    //

    InterlockedExchange((LONG*)&pLockInfo->dwThreadId, 0);
    pLockInfo->lInUse = 0;

    //
    //  Signal the device is free.
    //

    if (SetEvent(pLockInfo->hDeviceIsFree)) {

        return S_OK;
    } else {
        DBG_ERR(("StiLockMgr::ClearLockInfo, could not signal event"));
        return E_FAIL;
    }
}

/**************************************************************************\
* LockDevice
*
*   Calls the USD to lock itsself and updates the relevant Lock information.
*
* Arguments:
*
*   pDevice -   pointer to the ACTIVE_DEVICE node
*
* Return Value:
*
*   Status
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

HRESULT StiLockMgr::LockDevice(ACTIVE_DEVICE *pDevice)
{
    DBG_FN(StiLockMgr::LockDevice);

    HRESULT     hr          = S_OK;
    LockInfo    *pLockInfo  = (LockInfo*)pDevice->m_pLockInfo;
    IStiUSD     *pIStiUSD   = NULL;

    __try {

        //
        //  Check whether device is currently locked.  We know that the device
        //  is not busy, so it is safe to simply keep the lock open.  This is how
        //  we improve "burst" performance.
        //

        if (!pLockInfo->bDeviceIsLocked) {

            hr = pDevice->m_DrvWrapper.STI_LockDevice();
        } else {
            DBG_TRC(("StiLockMgr::LockDevice, Device is already locked."));
        }

        if (hr == S_OK) {
            pLockInfo->bDeviceIsLocked = TRUE;
        } else {
            HRESULT hres = E_FAIL;

            pLockInfo->bDeviceIsLocked = FALSE;
            hres = ClearLockInfo(pLockInfo);

            DBG_ERR(("StiLockMgr::LockDevice, USD error locking the device (0x%X)", hr));
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)  {
        DBG_ERR(("StiLockMgr::LockDevice, exception"));
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }

    return hr;
}

/**************************************************************************\
* UnlockDevice
*
*   Calls the USD to unlock itsself and updates the relevant Lock
*   information.
*
* Arguments:
*
*   pDevice -   pointer to the ACTIVE_DEVICE node
*
* Return Value:
*
*   Status
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

HRESULT StiLockMgr::UnlockDevice(ACTIVE_DEVICE *pDevice)
{
    DBG_FN(StiLockMgr::UnlockDevice);
    HRESULT     hr          = S_OK;
    LockInfo    *pLockInfo  = (LockInfo*)pDevice->m_pLockInfo;
    IStiUSD     *pIStiUSD   = NULL;

    __try {

        //
        //  Unlock the device and mark that device has been unlocked.
        //

        hr = pDevice->m_DrvWrapper.STI_UnLockDevice();
        if (SUCCEEDED(hr)) {
            pLockInfo->bDeviceIsLocked = FALSE;
        }

        if (hr != S_OK) {
            pLockInfo->bDeviceIsLocked = TRUE;
            DBG_ERR(("StiLockMgr::UnlockDevice, USD error unlocking the device"));
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)  {
        DBG_ERR(("StiLockMgr::UnlockDevice, exception"));
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }

    return hr;
}

HRESULT StiLockMgr::CheckDeviceInfo(ACTIVE_DEVICE *pDevice)
{
    HRESULT hr  =   E_FAIL;

    TAKE_ACTIVE_DEVICE _tad(pDevice);

    if (!pDevice) {
        DBG_ERR(("StiLockMgr::CheckDeviceInfo, pDevice is NULL!"));
        return E_POINTER;
    }

    //
    //  Check whether the device is valid and is not being removed
    //

    if (pDevice->IsValid() && !(pDevice->QueryFlags() & STIMON_AD_FLAG_REMOVING)) {

        //
        //  Check whether lock information for this device exists yet.  If
        //  not, create a new LockInfo struct for this device.
        //

        if (pDevice->m_pLockInfo) {
            hr = S_OK;
        } else {
            hr = CreateLockInfo(pDevice);
        }
    } else {
        DBG_ERR(("StiLockMgr::CheckDeviceInfo, ACTIVE_DEVICE is not valid!"));
        hr = E_FAIL;
    }

    return hr;
}

#ifdef USE_ROT

/**************************************************************************\
* WriteCookieNameToRegistry
*
*   Writes the specified name to the registry.  This is so clients know what
*   name to bind to when trying to get this instance of the Lock Manager
*   from the ROT (see Initialize).
*
* Arguments:
*
*   szCookieName    -   string containing the cookie name
*
* Return Value:
*
*   Status
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

HRESULT StiLockMgr::WriteCookieNameToRegistry(CHAR    *szCookieName)
{
    HRESULT hr;
    HKEY    hKey;
    LONG    lErr;
    DWORD   dwType = REG_SZ;
    DWORD   dwSize = strlen(szCookieName) + 1;

    //
    //  Write Lock Manager instance name to the registry.
    //

    lErr = ::RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          REGSTR_PATH_STICONTROL,
                          0,
                          TEXT(""),
                          REG_OPTION_VOLATILE,
                          KEY_WRITE,
                          NULL,
                          &hKey,
                          NULL);
    if (lErr == ERROR_SUCCESS) {

        lErr = ::RegSetValueExA(hKey,
                               REGSTR_VAL_LOCK_MGR_COOKIE_A,
                               0,
                               dwType,
                               (BYTE*) szCookieName,
                               dwSize);
        if (lErr != ERROR_SUCCESS) {
            DBG_ERR(("StiLockMgr::WriteCookieNameToRegistry, could not write to registry"));
        } else {

            return S_OK;
        }

        RegCloseKey(hKey);
    }
    return E_FAIL;
}

/**************************************************************************\
* DeleteCookieFromRegistry
*
*   Delete the cookie name from the registry.  It is only needed while this
*   instance of the lock manager is running.
*
* Arguments:
*
* Return Value:
*
*   Status
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

VOID StiLockMgr::DeleteCookieFromRegistry()
{
    HRESULT hr;
    HKEY    hKey;
    LONG    lErr;

    //
    //  Remove Lock Manager instance name from registry.
    //

    lErr = ::RegOpenKeyEx(HKEY_DYN_DATA,
                          REGSTR_PATH_STICONTROL,
                          0,
                          KEY_WRITE,
                          &hKey);
    if (lErr == ERROR_SUCCESS) {

        lErr = ::RegDeleteValue(hKey,
                                REGSTR_VAL_LOCK_MGR_COOKIE);
        RegCloseKey(hKey);
    }
}

#endif


/**************************************************************************\
* AutoUnlock
*
*   Scans the device list to check whether any device's idle time has
*   expired and needs to be unlocked.
*
* Arguments:
*
* Return Value:
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

VOID StiLockMgr::AutoUnlock()
{
    EnumContext     Ctx;

    m_bSched = FALSE;

    //
    //  Enumerate through device list.  At each locked device, update it's
    //  lTimeLeft.  If lTimeLeft has expired, unlock the device.
    //  If not, mark that unlock callback needs to be scheduled.
    //
    //  This logic is done in the UpdateLockInfoStatus method called by the
    //  EnumDeviceCallback function on each device.
    //

    Ctx.This = this;
    Ctx.lShortestWaitTime = LONG_MAX;
    Ctx.bMustSchedule = FALSE;
    g_pDevMan->EnumerateActiveDevicesWithCallback(EnumDeviceCallback, &Ctx);

    //
    //  Schedule next callback, if needed
    //

    if (Ctx.bMustSchedule && !m_bSched) {

        m_bSched = TRUE;
        m_lSchedWaitTime = Ctx.lShortestWaitTime;
        if (ScheduleWorkItem((PFN_SCHED_CALLBACK) UnlockTimedCallback,
                             this,
                             m_lSchedWaitTime,
                             NULL)) {
            return;
        } else {
            DBG_ERR(("StiLockMgr::AutoUnlock, failed to schedule UnlockTimedCallback"));
        }
    }
}

/**************************************************************************\
* UpdateLockInfoStatus
*
*   Updates a device's lock information.  If the device's idle time has
*   expired, it is unlocked.  If it is still busy, it's amount of idle time
*   left is updated.
*
* Arguments:
*
*   pDevice         -   A pointer to the ACTIVE_DEVICE node.
*   pWaitTime       -   This is a pointer to the shortest wait time left.
*                       This is used as the time the AutoUnlock() method
*                       needs to re-schedule itsself.
*   pbMustSchedule  -   A pointer to a BOOL indicating whether the
*                       AutoUnlock() needs to be re-scheduled.
*
* Return Value:
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

VOID StiLockMgr::UpdateLockInfoStatus(ACTIVE_DEVICE *pDevice, LONG *pWaitTime, BOOL *pbMustSchedule)
{
    DBG_FN(UpdateLockInfoStatus);
    LockInfo    *pLockInfo  = NULL;
    DWORD       dwWait;
    HRESULT     hr          = S_OK;;

    //
    //  NOTE:  Do not modify pWaitTime or pbMustSchedule unless a new wait
    //         time is scheduled (see where pLockInfo->lTimeLeft < *pWaitTime)
    //

    //
    //  Get a pointer to the lock information
    //

    if (pDevice) {

        pLockInfo = (LockInfo*) pDevice->m_pLockInfo;
    }

    if (!pLockInfo) {
        return;
    }

    //
    //  Check whether device is free.  If the device is busy, don't bother
    //  scheduling a callback, since it will be rescheduled if needed when
    //  the call to RequestUnlock is made.
    //

    dwWait = WaitForSingleObject(pLockInfo->hDeviceIsFree, 0);
    if (dwWait == WAIT_OBJECT_0) {

        //
        //  Check whether device is locked (we're only interested in devices
        //  that are locked).
        //

        if (pLockInfo->bDeviceIsLocked) {

            //
            //  Decrease the amount of time left.  If lTimeLeft <= 0, then no
            //  idle time remains and device should be unlocked.
            //
            //  If time does remain, check whether it is smaller than
            //  the current wait time (pWaitTime).  If it is smaller, mark
            //  that this is the new wait time, and that the unlock callback
            //  must be scheduled to unlock this later.
            //

            pLockInfo->lTimeLeft -= m_lSchedWaitTime;
            if (pLockInfo->lTimeLeft <= 0) {

                pLockInfo->lTimeLeft = 0;

                hr = UnlockDevice(pDevice);
                if (SUCCEEDED(hr)) {

                    hr = ClearLockInfo(pLockInfo);
                    return;
                }
            } else {

                if (pLockInfo->lTimeLeft < *pWaitTime) {

                    *pWaitTime = pLockInfo->lTimeLeft;
                }
                *pbMustSchedule = TRUE;
            }
        }

        //
        //  We are finished updating the information, so re-signal
        //  that device is free.
        //

        SetEvent(pLockInfo->hDeviceIsFree);

    }
}

/**************************************************************************\
* EnumDeviceCallback
*
*   This function is called once for every device in the ACTIVE_DEVICE
*   enumeration.
*
* Arguments:
*
*   pDevice     -   A pointer to the ACTIVE_DEVICE node.
*   pContext    -   This is a pointer to an enumeration context.
*                   The context contains a pointer to the Lock Manager,
*                   the shortest wait time, and a bool indicating whether
*                   AutoUnlock needs to be re-scheduled.
*
* Return Value:
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

VOID WINAPI EnumDeviceCallback(ACTIVE_DEVICE *pDevice, VOID *pContext)
{
    DBG_FN(EnumDeviceCallback);
    EnumContext *pCtx = (EnumContext*) pContext;

    if (pCtx) {

        //
        //  Update the lock status on this device
        //

        pCtx->This->UpdateLockInfoStatus(pDevice,
                                         &pCtx->lShortestWaitTime,
                                         &pCtx->bMustSchedule);
    }
}

/**************************************************************************\
* UnlockTimedCallback
*
*   This function gets called when a lock is still active and may need to
*   be unlocked if the amount of idle time expires.
*
* Arguments:
*
*   pArg     -   A pointer to the Lock Manager.
*
* Return Value:
*
* History:
*
*    15/1/1999 Original Version
*
\**************************************************************************/

VOID WINAPI UnlockTimedCallback(VOID *pArg)
{
    DBG_FN(UnlockTimedCallback);
    StiLockMgr *pLockMgr = (StiLockMgr*) pArg;

    if (pLockMgr) {

        __try {
            pLockMgr->AutoUnlock();
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            #ifdef DEBUG
            OutputDebugStringA("Exception in UnlockTimedCallback");
            #endif
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\monui.cpp ===
/*++


Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MONUI.CPP

Abstract:

Author:

    Vlad  Sadovsky  (vlads)     12-20-96

Revision History:



--*/
#include "precomp.h"

//
// Headers
//
#include "stiexe.h"
#include "device.h"

#include <windowsx.h>
#include <mmsystem.h>

#include "resource.h"
#include "monui.h"

//
// Private defines
//
#define ELAPSE_TIME     20000

extern  UINT    g_uiDefaultPollTimeout;

CSetTimeout::CSetTimeout(
    int         DlgID,
    HWND        hWnd,
    HINSTANCE   hInst,
    UINT        uiTimeout
    )
    : BASECLASS(DlgID, hWnd, hInst),
    m_uiOrigTimeout(uiTimeout)
{
    m_uiNewTimeOut = m_uiOrigTimeout;
    m_fAllChange = FALSE;

    m_fValidChange = FALSE;
}

CSetTimeout::~CSetTimeout()
{
}

int CSetTimeout::OnCommand(UINT id,HWND    hwndCtl, UINT codeNotify)
{
    switch (id) {
        case IDOK:
        {
            CHAR    szTimeoutString[10] = {'\0'};
            int     uiNewValue;

            GetWindowTextA(GetDlgItem(IDC_TIMEOUT),szTimeoutString,sizeof(szTimeoutString));
            uiNewValue = ::atoi(szTimeoutString);
            if (uiNewValue != -1 ) {
                m_uiNewTimeOut = uiNewValue*1000;
                m_fValidChange = TRUE;
            }

            m_fAllChange = Button_GetCheck(GetDlgItem(IDC_CHECK_ALLDEVICES));
        }
        EndDialog(1);
        return 1;
        break;


        case IDCANCEL:
        EndDialog(0);
        return 1;
        break;
    }
    return 0;
}

void CSetTimeout::OnInit()
{
    TCHAR    szTimeoutString[10] = {'\0'};

    SendMessage(GetDlgItem(IDC_TIMEOUT), EM_LIMITTEXT, (sizeof(szTimeoutString) / sizeof(szTimeoutString[0])) -1, 0);
    wsprintf(szTimeoutString,TEXT("%6d"),g_uiDefaultPollTimeout/1000);
    Edit_SetText(GetDlgItem(IDC_TIMEOUT),szTimeoutString);

    Button_SetCheck(GetDlgItem(IDC_CHECK_ALLDEVICES),FALSE);
}

//
// Dialog for selecting event processor .
// It is invoked when monitor can not identify single event processor
//

CLaunchSelection::CLaunchSelection(
    int             DlgID,
    HWND            hWnd,
    HINSTANCE       hInst,
    ACTIVE_DEVICE  *pDev,
    PDEVICEEVENT    pEvent,
    STRArray       &saProcessors,
    StiCString     &strSelected
    )
    : BASECLASS(DlgID, hWnd, hInst,ELAPSE_TIME),
    m_saList(saProcessors),
    m_strSelected(strSelected),
    m_uiCurSelection(0),
    m_pDevice(pDev),
    m_pEvent(pEvent),
    m_hPreviouslyActiveWindow(NULL)
{
    //
    // Save currently active window and focus
    //
    m_hPreviouslyActiveWindow = ::GetForegroundWindow();


}

CLaunchSelection::~CLaunchSelection()
{
    // Restore previous window
    if (IsWindow(m_hPreviouslyActiveWindow)) {
        ::SetForegroundWindow(m_hPreviouslyActiveWindow);
    }
}

int CLaunchSelection::OnCommand(UINT id,HWND    hwndCtl, UINT codeNotify)
{
    LRESULT    lrSize;

    switch (id) {
        case  IDC_APP_LIST:
            //
            // Treat double-click on the list box item just like pressing OK button
            // Pass through to next case if notification is about it
            //
            if (codeNotify != LBN_DBLCLK) {
                return FALSE;
            }

        case IDOK:
        {

            //
            // Save currently selected string
            //
            m_uiCurSelection = ::SendDlgItemMessage(GetWindow(), IDC_APP_LIST, LB_GETCURSEL, 0, (LPARAM) 0);
            
            lrSize = ::SendDlgItemMessage(GetWindow(), IDC_APP_LIST, LB_GETTEXTLEN, m_uiCurSelection, (LPARAM) 0);
            if (lrSize) {
               ::SendDlgItemMessage(GetWindow(), IDC_APP_LIST, LB_GETTEXT, m_uiCurSelection, (LPARAM) m_strSelected.GetBufferSetLength((INT)lrSize+1));
            }

            EndDialog(1);

            return TRUE;
        }
        break;

        case IDCANCEL:
        {
            m_strSelected.GetBufferSetLength(0);
            EndDialog(0);

            return TRUE;
        }
        break;
    }
    return FALSE;

}

void CLaunchSelection::OnInit()
{

    INT    iCount;

    //
    // Set caption
    //
    StiCString     strCaption;
    DEVICE_INFO    *pDeviceInfo = m_pDevice->m_DrvWrapper.getDevInfo();
    WCHAR          *wszDesc     = NULL;

    //
    // Try to get the device's friendly name
    //
    if (pDeviceInfo) {
        wszDesc = pDeviceInfo->wszLocalName;
    }

    //
    // If we don't have a description string yet, use the the device ID
    //
    if (!wszDesc) {
        wszDesc = m_pDevice->GetDeviceID();
    }

    strCaption.FormatMessage(IDS_APP_CHOICE_CAPTION, wszDesc);
    ::SetWindowText(GetWindow(),(LPCTSTR)strCaption);

    //
    // Fill list box with possible selection
    //
    if (m_saList.GetSize()) {
        for (iCount = 0;iCount < m_saList.GetSize();iCount++) {
            ::SendDlgItemMessage( GetWindow(), IDC_APP_LIST, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>((LPCTSTR)*m_saList[iCount]) );
        }
    }

    HWND    hwndThis = GetWindow();

#ifdef WINNT
    DWORD dwProcessId;

    //
    // On Win2k we need to allow set foreground window
    //
    ::GetWindowThreadProcessId(hwndThis, &dwProcessId);
    ::AllowSetForegroundWindow(dwProcessId);
#endif

    //
    // Make window active and foreground
    //
    ::SetActiveWindow(hwndThis);
    ::SetForegroundWindow(hwndThis);
    ::SetFocus(hwndThis);

    //Check: On Win9x can we bring window to top?
    //::BringWindowToTop(hwndThis);

#ifdef WINNT

    //
    // Flash caption
    //
    FLASHWINFO  fwi;
    DWORD       dwError;

    fwi.cbSize = sizeof fwi;
    fwi.hwnd = GetWindow();
    fwi.dwFlags = FLASHW_ALL;
    fwi.uCount = 10;

    dwError = FlashWindowEx(&fwi);

#endif

    //
    // Attract user attention
    //
    #ifdef PLAYSOUND
    ::PlaySound("SystemQuestion",NULL,SND_ALIAS | SND_ASYNC | SND_NOWAIT | SND_NOSTOP);
    #endif

}


BOOL
CALLBACK
CLaunchSelection::DlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMessage) {
        case WM_TIMER:
        {
            return TRUE;
        }
        break;
    }
    return FALSE;
}


DWORD
DisplayPopup (
    IN  DWORD   dwMessageId,
    IN  DWORD   dwMessageFlags  // = 0
    )

/*++

Routine Description:

    Puts up a popup for the corresponding message ID.

Arguments:

    MessageId - the message ID to display.  It is assumed to be in a
        resource in this executable.

Return Value:

    None.

--*/

{

    DWORD   cch = NO_ERROR;
    LPTSTR  messageText = NULL;
    DWORD   dwError;

    StiCString     strCaption;

    strCaption.LoadString(STIEXE_EVENT_TITLE);

    cch = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_MAX_WIDTH_MASK |
                           FORMAT_MESSAGE_FROM_HMODULE,
                           ::GetModuleHandle(NULL) ,
                           dwMessageId,
                           0,
                           (LPTSTR) &messageText,
                           1024,
                           NULL
                           );

    dwError = GetLastError();

    if (!cch || !messageText || !strCaption.GetLength()) {
        return 0;
    }

    dwError = MessageBox(
                NULL,
                messageText,
                (LPCTSTR)strCaption,
                dwMessageFlags
                #ifdef WINNT
                | MB_DEFAULT_DESKTOP_ONLY | MB_SERVICE_NOTIFICATION
                #endif
                );

    LocalFree( messageText );

    return dwError;

} // DisplayPopup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\monui.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:


Abstract:


Author:

    Vlad Sadovsky (vlads)   10-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    26-Jan-1997     VladS       created

--*/

#include <cdlg.h>

extern
DWORD
DisplayPopup (
    IN  DWORD   dwMessageId,
    IN  DWORD   dwMessageFlags  = 0
    );


//
// Debugging UI class, describing dialog to enter new value of timeout
//
class CSetTimeout : public CDlg
{
public:

    typedef CDlg BASECLASS;

    CSetTimeout(int DlgID, HWND hWnd, HINSTANCE hInst,UINT uiTimeout);
    ~CSetTimeout();


    virtual int OnCommand(UINT id,HWND    hwndCtl, UINT codeNotify);
    virtual void OnInit();

    UINT    GetNewTimeout(VOID) {return m_uiNewTimeOut;};
    BOOL    IsAllChange(VOID)  {return m_fAllChange;};

    BOOL    m_fValidChange;

private:

    UINT    m_uiOrigTimeout;
    UINT    m_uiNewTimeOut;
    BOOL    m_fAllChange;
};

//
// Class for displaying UI selecting from list of available applications for device event
//
class CLaunchSelection : public CDlg
{
public:

    typedef CDlg BASECLASS;

    CLaunchSelection(int DlgID, HWND hWnd, HINSTANCE hInst,ACTIVE_DEVICE *pDev,PDEVICEEVENT pEvent,STRArray &saProcessors,StiCString& strSelected);
    ~CLaunchSelection();

    virtual
    BOOL
    CALLBACK
    CLaunchSelection::DlgProc(
        HWND hDlg,
        UINT uMessage,
        WPARAM wParam,
        LPARAM lParam
        );

    virtual
    int
    OnCommand(
        UINT id,
        HWND    hwndCtl,
        UINT codeNotify
        );

    virtual
    void
    OnInit();

private:

    StiCString  &m_strSelected;
    STRArray    &m_saList;


    PDEVICEEVENT    m_pEvent;
    ACTIVE_DEVICE*  m_pDevice;

    LRESULT m_uiCurSelection;
    HWND    m_hPreviouslyActiveWindow;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\lockmgr.h ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       LockMgr.h
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        15 November, 1999
*
*  DESCRIPTION:
*   Definition of Lock Manager Class.
*
******************************************************************************/

#pragma once

#ifndef _LOCKMGR_H_
#define _LOCKMGR_H_

#define WIA_LOCK_WAIT_TIME  60000

class StiLockMgr;   // defined later in this file

//
//  Lock information stored per device
//

typedef struct _LockInfo {

    HANDLE  hDeviceIsFree;          // Auto-Reset event object used to signal
                                    //  when device is free.
    BOOL    bDeviceIsLocked;        // Indicates whether device is currently
                                    //  locked.
    LONG    lInUse;                 // Indicates whether the device is actually
                                    //  in use i.e. we are in the middle of a
                                    //  request (e.g. a data transfer).
    DWORD   dwThreadId;             // The Id of the Thread which has device
                                    //  locked.
    LONG    lHoldingTime;           // The amount of idle time (milliseconds)
                                    //  to keep hold of lock.
    LONG    lTimeLeft;              // The amount of idle time remaining.
} LockInfo, *PLockInfo;

//
//  Info struct used during enumeration callbacks
//

typedef struct _EnumContext {
    StiLockMgr  *This;              // Pointer to the Lock Manager that
                                    //  requested the enumeration
    LONG        lShortestWaitTime;  // Value indicating the shortest wait time
                                    //  till next unlock.
    BOOL        bMustSchedule;      // Indicates whether the unlock callback
                                    //  must be scheduled.
} EnumContext, *PEnumContext;

//
//  Class definition for the lock manager.  It is used by both STI and WIA.
//

class StiLockMgr : IUnknown {

public:

    //
    //  Constructor, Initialize, Destructor
    //

    StiLockMgr();
    HRESULT Initialize();
    ~StiLockMgr();

    //
    //  IUnknown methods
    //

    HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
    ULONG   _stdcall AddRef(void);
    ULONG   _stdcall Release(void);

    //
    //  Lock/Unlock Request methods
    //

    HRESULT _stdcall RequestLock(BSTR pszDeviceName, ULONG ulTimeout, BOOL bInServerProcess, DWORD dwClientThreadId);
    HRESULT _stdcall RequestLock(ACTIVE_DEVICE *pDevice, ULONG ulTimeOut, BOOL bOpenPort = TRUE);
    HRESULT _stdcall RequestUnlock(BSTR pszDeviceName, BOOL bInServerProcess, DWORD dwClientThreadId);
    HRESULT _stdcall RequestUnlock(ACTIVE_DEVICE *pDevice, BOOL bClosePort = TRUE);

    HRESULT _stdcall LockDevice(ACTIVE_DEVICE *pDevice);
    HRESULT _stdcall UnlockDevice(ACTIVE_DEVICE *pDevice);

    VOID AutoUnlock();
    VOID UpdateLockInfoStatus(ACTIVE_DEVICE *pDevice, LONG *pWaitTime, BOOL *pbMustSchedule);
    HRESULT ClearLockInfo(LockInfo *pLockInfo);
private:

    //
    //  Private helpers
    //

    HRESULT RequestLockHelper(ACTIVE_DEVICE *pDevice, ULONG ulTimeOut, BOOL bInServerProcess, DWORD dwClientThreadId);
    HRESULT RequestUnlockHelper(ACTIVE_DEVICE *pDevice, BOOL bInServerProcess, DWORD dwClientThreadId);
    HRESULT CreateLockInfo(ACTIVE_DEVICE *pDevice);
    HRESULT CheckDeviceInfo(ACTIVE_DEVICE *pDevice);
#ifdef USE_ROT
    HRESULT WriteCookieNameToRegistry(CHAR *szCookieName);
    VOID    DeleteCookieFromRegistry();
#endif

    //
    //  Private Data
    //

    LONG    m_cRef;             //  Ref count
    DWORD   m_dwCookie;         //  Cookie identifying location in ROT
    BOOL    m_bSched;           //  Indicates whether the UnlockCallback has
                                //   been scheduled
    LONG    m_lSchedWaitTime;   //  Amount of time we told Scheduler to wait
                                //   before calling us back
};

#ifdef DECLARE_LOCKMGR
StiLockMgr  *g_pStiLockMgr;
#else
extern StiLockMgr  *g_pStiLockMgr;
#endif


//
//  Callback functions
//

VOID WINAPI UnlockTimedCallback(VOID *pCallbackInfo);
VOID WINAPI EnumDeviceCallback(ACTIVE_DEVICE *pDevice, VOID *pContext);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\precomp.h ===
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER

#ifndef WINVER
#define WINVER 0x0500
#endif

#ifdef WINNT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#endif

#include <windows.h>
#include <stdlib.h>
#include <coredbg.h>
#include <sti.h>
#include <stiregi.h>
#include <stilib.h>
#include <stiapi.h>
#include <stisvc.h>
#include <stiusd.h>

//#include <stistr.h>
#include <regentry.h>

#include <eventlog.h>
#include <lock.h>

#include <validate.h>

#define ATL_APARTMENT_FREE

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

#include <atlbase.h>
extern CComModule _Module;

#include <atlcom.h>
#include <atlapp.h>
#include <atltmp.h>

#include "simlist.h"
#include "simstr.h"
#include "SimpleTokenReplacement.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by stimon.rc
//
#define STIEXE_EVENT_TITLE              1

#define IDS_STIEXE_DEFAULT_APP          2
#define IDS_APP_CHOICE_CAPTION          3
#define IDS_SERVICE_DISPLAY_NAME        4
#define IDS_DRIVES_REMOVABLE_STR        5
#define IDS_DRIVES_CDROM_STR            6
#define IDS_DRIVES_FIXED_STR            7
#define IDS_MSC_MANUFACTURER_STR        8

#define IDR_MENU                        102
#define IDD_APP_CHOICE                  103
#define IDD_SETTIMEOUT                  104
#define IDD_ADD_DLG                     105
#define IDD_DIALOG_DEVLIST              106

#define IDI_STILL_IMAGE                 201
#define IDI_STATUS_ICON                 202
#define IDI_ICON                        203

//
#define IDC_APP_LIST                    1002
#define IDC_TIMEOUT                     1003
#define IDC_CHECK_ALLDEVICES            1004
#define IDC_CHOICE_PROMPT               1005
#define IDC_SCANNER_ICON                1006
#define IDD_STATUSDIALOG                1007
#define IDC_STATUSTEXT                  1008
#define IDC_STATUSCONTROL               1009
#define IDC_STATUS_CONTROL_TOP          1011
#define IDC_STATUS_CONTROL_BOTTOM       1012
#define IDC_STATUS_TEXT_TOP             1013
#define IDC_STATUS_TEXT_BOTTOM          1014

//
#define IDC_LOCAL                       1025
#define IDC_REMOTE                      1026
#define IDC_DRIVER_NAME                 1027
#define IDC_COMBO1                      1028
#define IDC_STATIC1                     1029
#define IDC_STATIC2                     1030
#define IDC_STATIC3                     1031

//
#define IDM_TOOLS_REFRESH               40001
#define IDM_TOOLS_DEVLIST               40002
#define IDM_TOOLS_TIMEOUT               40003
#define IDM_TOOLS_REMOVEALL             40005

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40006
#define _APS_NEXT_CONTROL_VALUE         1032
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\rpcsupp.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rpcsvr.c

Abstract:

    RPC server routines

Author:

    Vlad Sadovsky (vlads)   10-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    26-Jan-1997     VladS       created

--*/

#include "precomp.h"
#include "stiexe.h"

#include "device.h"
#include "conn.h"
#include "wiapriv.h"
#include "lockmgr.h"

#include <apiutil.h>
#include <stiapi.h>
#include <stirpc.h>

//
// External prototypes
//


DWORD
WINAPI
StiApiAccessCheck(
    IN  ACCESS_MASK DesiredAccess
    );


DWORD
WINAPI
R_StiApiGetVersion(
    LPCWSTR  pszServer,
    DWORD   dwReserved,
    DWORD   *pdwVersion
    )
{

    DWORD   dwErr;

    dwErr = StiApiAccessCheck(STI_GENERIC_READ);
    if (NOERROR != dwErr ) {
        return dwErr;
    }

    if (!pdwVersion) {
        return ERROR_INVALID_PARAMETER;
    }

    STIMONWPRINTF(TEXT("RPC SUPP: ApiGetVersion called"));

    *pdwVersion = STI_VERSION;

    return NOERROR;
}

DWORD
WINAPI
R_StiApiOpenDevice(
    LPCWSTR  pszServer,
    LPCWSTR  pszDeviceName,
    DWORD    dwMode,
    DWORD    dwAccessRequired,
    DWORD    dwProcessId,
    STI_DEVICE_HANDLE *pHandle
)
{
USES_CONVERSION;

    BOOL    fRet;
    DWORD   dwErr;

    dwErr = StiApiAccessCheck(STI_GENERIC_READ);
    if (NOERROR != dwErr ) {
        return dwErr;
    }

    if (!pHandle || !pszDeviceName) {
        return ERROR_INVALID_PARAMETER;
    }

    // STIMONWPRINTF(TEXT("RPC SUPP: Open device called"));

    //
    // Create connection object and get it's handle
    //
    fRet = CreateDeviceConnection(W2CT(pszDeviceName),
                                  dwMode,
                                  dwProcessId,
                                  pHandle
                                  );
    if (fRet && *pHandle) {
        return NOERROR;
    }

    *pHandle = INVALID_HANDLE_VALUE;

    return ::GetLastError();

}

DWORD
WINAPI
R_StiApiCloseDevice(
    LPCWSTR  pszServer,
    STI_DEVICE_HANDLE hDevice
    )
{

    STIMONWPRINTF(TEXT("RPC SUPP: Close device called"));

    DWORD   dwErr;

    dwErr = StiApiAccessCheck(STI_GENERIC_READ);
    if (NOERROR != dwErr ) {
        return dwErr;
    }

#ifdef DEBUG
    DebugDumpScheduleList(TEXT("RPC CLose enter"));
#endif

    if (DestroyDeviceConnection(hDevice,FALSE) ) {
#ifdef DEBUG
        DebugDumpScheduleList(TEXT("RPC CLose exit"));
#endif
        return NOERROR;
    }

#ifdef DEBUG
    DebugDumpScheduleList(TEXT("RPC CLose exit"));
#endif

    return GetLastError();

}

VOID
STI_DEVICE_HANDLE_rundown(
    STI_DEVICE_HANDLE hDevice
)
{
    STIMONWPRINTF(TEXT("RPC SUPP: rundown device called"));

    if (DestroyDeviceConnection(hDevice,TRUE) ) {
        return;
    }

    return ;

}

DWORD
WINAPI
R_StiApiSubscribe(
    STI_DEVICE_HANDLE   Handle,
    LOCAL_SUBSCRIBE_CONTAINER    *lpSubscribe
    )
{

    STI_CONN   *pConnectionObject;
    BOOL        fRet;


    DWORD       dwErr;

    dwErr = StiApiAccessCheck(STI_GENERIC_READ);
    if (NOERROR != dwErr ) {
        return dwErr;
    }

    //
    // Validate contents of subscribe request
    //
    // For this call we need to impersonate , because we will need
    // access to client process handle
    //

    dwErr = ::RpcImpersonateClient( NULL ) ;

    if( dwErr == NOERROR ) {

        //
        // Invoke add subscription method on connection object
        //
        if (!LookupConnectionByHandle(Handle,&pConnectionObject)) {
            return ERROR_INVALID_HANDLE;
        }

        fRet = pConnectionObject->SetSubscribeInfo(lpSubscribe);

        pConnectionObject->Release();

        // Go back
        ::RpcRevertToSelf();
    }
    else {
        // Failed to impersonate
        return( dwErr );
    }

    return fRet ? NOERROR : ERROR_INVALID_PARAMETER;

}

DWORD
WINAPI
R_StiApiGetLastNotificationData(
    STI_DEVICE_HANDLE Handle,
    LPBYTE pData,
    DWORD nSize,
    LPDWORD pcbNeeded
    )
{
    //
    // Find connection object and if we are subscribed , retreive
    // first waiting message
    //
    STI_CONN   *pConnectionObject;

    DWORD       cbNeeded = nSize;
    DWORD       dwErr;

    dwErr = StiApiAccessCheck(STI_GENERIC_READ);
    if (NOERROR != dwErr ) {
        return dwErr;
    }

    //
    // Validate contents of subscribe request
    //

    if (!LookupConnectionByHandle(Handle,&pConnectionObject)) {
        return ERROR_INVALID_HANDLE;
    }

    dwErr = pConnectionObject->GetNotification(pData,&cbNeeded);

    pConnectionObject->Release();

    if (pcbNeeded) {
        *pcbNeeded = cbNeeded;
    }

    return dwErr;

}

DWORD
WINAPI
R_StiApiUnSubscribe(
    STI_DEVICE_HANDLE Handle
    )
{
    STI_CONN   *pConnectionObject;
    BOOL        fRet;

    DWORD   dwErr;

    dwErr = StiApiAccessCheck(STI_GENERIC_READ);
    if (NOERROR != dwErr ) {
        return( dwErr );
    }


    // For this call we need to impersonate , because we will need
    // access to client process handle
    //

    dwErr = ::RpcImpersonateClient( NULL ) ;

    if( dwErr == NOERROR ) {

        //
        // Invoke set subscription method on connection object
        //
        if (!LookupConnectionByHandle(Handle,&pConnectionObject)) {
            return ERROR_INVALID_HANDLE;
        }

        fRet = pConnectionObject->SetSubscribeInfo(NULL);

        pConnectionObject->Release();

        // Go back
        ::RpcRevertToSelf();

    }
    else {
        // Failed to impersonate
        return dwErr;
    }

    return fRet ? NOERROR : ERROR_INVALID_PARAMETER;

}


DWORD
WINAPI
R_StiApiEnableHwNotifications(
    LPCWSTR  pszServer,
    LPCWSTR  pszDeviceName,
    BOOL    bNewState
    )
{
USES_CONVERSION;

    ACTIVE_DEVICE   *pOpenedDevice;
    BOOL            fRet;


    DWORD   dwErr;

    dwErr = StiApiAccessCheck(STI_GENERIC_READ);
    if (NOERROR != dwErr ) {
        return dwErr;
    }

    //
    // Locate device incrementing it's ref count
    //
    pOpenedDevice = g_pDevMan->IsInList(DEV_MAN_IN_LIST_DEV_ID, pszDeviceName);
    if(!pOpenedDevice) {
        // Failed to connect to the device
        return ERROR_DEV_NOT_EXIST              ;
    }

    {
        TAKE_ACTIVE_DEVICE  t(pOpenedDevice);

        if (bNewState) {
            pOpenedDevice->EnableDeviceNotifications();
        }
        else {
            pOpenedDevice->DisableDeviceNotifications();
        }
    }

    pOpenedDevice->Release();

    return NOERROR;
}

DWORD
R_StiApiGetHwNotificationState(
    LPCWSTR  pszServer,
    LPCWSTR  pszDeviceName,
    LPDWORD     pState
    )
{
USES_CONVERSION;

    ACTIVE_DEVICE   *pOpenedDevice;
    BOOL            fRet;

    DWORD   dwErr;

    dwErr = StiApiAccessCheck(STI_GENERIC_READ);
    if (NOERROR != dwErr ) {
        return dwErr;
    }

    //
    // Locate device incrementing it's ref count
    //
    pOpenedDevice = g_pDevMan->IsInList(DEV_MAN_IN_LIST_DEV_ID, pszDeviceName);
    if(!pOpenedDevice) {
        // Failed to connect to the device
        return ERROR_DEV_NOT_EXIST              ;
    }

    if (pOpenedDevice->QueryFlags() & STIMON_AD_FLAG_NOTIFY_ENABLED) {
        *pState = TRUE;
    }
    else {
        *pState = FALSE;
    }

    pOpenedDevice->Release();

    return NOERROR;

}

DWORD
WINAPI
R_StiApiLaunchApplication(
    LPCWSTR  pszServer,
    LPCWSTR  pszDeviceName,
    LPCWSTR  pAppName,
    LPSTINOTIFY  pStiNotify
    )
{

USES_CONVERSION;

    ACTIVE_DEVICE   *pOpenedDevice;
    BOOL            fRet;
    DWORD           dwError;


    DWORD   dwErr;

    dwErr = StiApiAccessCheck(STI_GENERIC_READ | STI_GENERIC_EXECUTE);
    if (NOERROR != dwErr ) {
        return dwErr;
    }

    //
    // Locate device incrementing it's ref count
    //
    pOpenedDevice = g_pDevMan->IsInList(DEV_MAN_IN_LIST_DEV_ID, pszDeviceName);
    if(!pOpenedDevice) {
        // Failed to connect to the device
        return ERROR_DEV_NOT_EXIST              ;
    }

    //
    // Attempt to launch registered application
    //
    {
        TAKE_ACTIVE_DEVICE  t(pOpenedDevice);

        fRet = pOpenedDevice->ProcessEvent(pStiNotify,TRUE,W2CT(pAppName));

        dwError = fRet ? NOERROR : pOpenedDevice->QueryError();
    }

    pOpenedDevice->Release();

    return dwError;

}

DWORD
WINAPI
R_StiApiLockDevice(
    LPCWSTR  pszServer,
    LPCWSTR pszDeviceName,
    DWORD   dwWait,
    BOOL    bInServerProcess,
    DWORD   dwClientThreadId
    )
{
    BSTR    bstrDevName =   SysAllocString(pszDeviceName);
    DWORD   dwError     =   0;


    if (bstrDevName) {

        dwError = (DWORD) g_pStiLockMgr->RequestLock(bstrDevName,
                                                     (ULONG) dwWait,
                                                     bInServerProcess,
                                                     dwClientThreadId);

        SysFreeString(bstrDevName);
    } else {
        dwError = (DWORD) E_OUTOFMEMORY;
    }

    return dwError;
}

DWORD
WINAPI
R_StiApiUnlockDevice(
    LPCWSTR  pszServer,
    LPCWSTR pszDeviceName,
    BOOL    bInServerProcess,
    DWORD   dwClientThreadId

    )
{
    BSTR    bstrDevName =   SysAllocString(pszDeviceName);
    DWORD   dwError     =   0;


    if (bstrDevName) {
        dwError = (DWORD) g_pStiLockMgr->RequestUnlock(bstrDevName,
                                                       bInServerProcess,
                                                       dwClientThreadId);
        SysFreeString(bstrDevName);
    } else {
        dwError = (DWORD) E_OUTOFMEMORY;
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\rpcsvr.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rpcsvr.c

Abstract:

    This file contains routines for starting and stopping RPC servers.

        StartRpcServerListen
        StopRpcServerListen

Author:

    Vlad Sadovsky (vlads)   10-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    26-Jan-1997     VladS       created

--*/

#include "precomp.h"

//#define NOMINMAX

#include "stiexe.h"

#include <apiutil.h>
#include <stirpc.h>

#ifndef stirpc_ServerIfHandle
#define stirpc_ServerIfHandle stirpc_v2_0_s_ifspec
#endif


RPC_STATUS RPC_ENTRY StiRpcSecurityCallBack(
    RPC_IF_HANDLE hIF,
    void *Context)
{
    RPC_STATUS rpcStatus    = RPC_S_ACCESS_DENIED;
    WCHAR     *pBinding     = NULL;
    WCHAR     *pProtSeq     = NULL;

    RPC_AUTHZ_HANDLE    hPrivs;
    DWORD               dwAuthenticationLevel;

    rpcStatus = RpcBindingInqAuthClient(Context,
                                        &hPrivs,
                                        NULL,
                                        &dwAuthenticationLevel,
                                        NULL,
                                        NULL);
    if (rpcStatus != RPC_S_OK)
    {
        DBG_ERR(("STI Security:  Error calling RpcBindingInqAuthClient"));
        goto CleanUp;
    }

    //
    //  We require at least packet-level authentication with integrity checking
    //
    if (dwAuthenticationLevel < RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
    {
        DBG_ERR(("STI Security: Error, client attempting to use weak authentication."));
        rpcStatus = RPC_S_ACCESS_DENIED;
        goto CleanUp;
    }

    //
    //  Also, we only accept LRPC requests i.e. we only process requests from this machine,
    //  and we disallow any remote calls to us.
    //
    rpcStatus = RpcBindingToStringBindingW(Context, &pBinding);
    if (rpcStatus == RPC_S_OK)
    {
        rpcStatus = RpcStringBindingParseW(pBinding,
                                           NULL,
                                           &pProtSeq,
                                           NULL,
                                           NULL,
                                           NULL);
        if (rpcStatus == RPC_S_OK)
        {
            if (lstrcmpiW(pProtSeq, L"ncalrpc") == 0)
            {
                DBG_TRC(("STI Security: We have a local client"));
                rpcStatus = RPC_S_OK;
            }
            else
            {
                DBG_ERR(("STI Security: Error, remote client attempting to connect to STI RPC server"));
                rpcStatus = RPC_S_ACCESS_DENIED;
            }
        }
        else
        {
            DBG_ERR(("STI Security: Error 0x%08X calling RpcStringBindingParse", rpcStatus));
            goto CleanUp;
        }
    }
    else
    {
        DBG_ERR(("STI Security: Error 0x%08X calling RpcBindingToStringBinding", rpcStatus));
        goto CleanUp;
    }


CleanUp: 

    if (pBinding)
    {
        RpcStringFree(&pBinding);
        pBinding = NULL;

    }
    if (pProtSeq)
    {
        RpcStringFree(&pProtSeq);
        pProtSeq = NULL;
    }

    DBG_TRC(("STI Security: returning 0x%08X", rpcStatus));
    return rpcStatus;
}


RPC_STATUS 
PrepareStiAcl(
    ACL **ppAcl)
/*++

Routine Description:

    This function prepares appropriate ACL for our RPC endpoint

Arguments:
    ppAcl - points to ACL pointer we allocate and fill in. 

    The ACL is allocated from the process heap and stays allocated for the 
    lifetime of the process


Return Value:

    NOERROR, or any GetLastError() codes.

--*/
{
    RPC_STATUS RpcStatus = NOERROR;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AuthenticatedUsers = NULL;
    PSID BuiltinAdministrators = NULL;
    ULONG AclSize;

    if(!AllocateAndInitializeSid(&NtAuthority, 
        2, 
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,
        &BuiltinAdministrators)) 
    {
        RpcStatus = GetLastError();
        DBG_ERR(("PrepareStiAcl: failed to allocate SID for BuiltinAdministrators, RpcStatus = %d", 
            RpcStatus));
        goto Cleanup;
    }                  

    if(!AllocateAndInitializeSid(&NtAuthority, 
        1, 
        SECURITY_AUTHENTICATED_USER_RID,
        0,0,0,0,0,0, 0,
        &AuthenticatedUsers))
    {
        RpcStatus = GetLastError();
        DBG_ERR(("PrepareStiAcl: failed to allocate SID for AuthenticatedUsers, RpcStatus = %d", 
            RpcStatus));
        goto Cleanup;
    }   
    
    AclSize = sizeof(ACL) + 
        2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG)) + 
        GetLengthSid(AuthenticatedUsers) + 
        GetLengthSid(BuiltinAdministrators);

    *ppAcl = (ACL *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, AclSize);
    if(*ppAcl == NULL) 
    {
        RpcStatus = GetLastError();
        DBG_ERR(("PrepareStiAcl: failed to allocate ACL (LastError = %d)", 
            RpcStatus));
        goto Cleanup;
    }

    if(!InitializeAcl(*ppAcl, AclSize, ACL_REVISION))
    {
        RpcStatus = GetLastError();
        DBG_ERR(("PrepareStiAcl: failed to initialize ACL (LastError = %d)", 
            RpcStatus));
        goto Cleanup;
    }

    if(!AddAccessAllowedAce(*ppAcl, ACL_REVISION, 
        SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
        AuthenticatedUsers))
    {
        RpcStatus = GetLastError();
        DBG_ERR(("PrepareStiAcl: failed to allow AuthenticatedUsers (LastError = %d)", 
            RpcStatus));
        goto Cleanup;
    }

    if(!AddAccessAllowedAce(*ppAcl, ACL_REVISION, 
        GENERIC_ALL,
        BuiltinAdministrators))
    {
        RpcStatus = GetLastError();
        DBG_ERR(("PrepareStiAcl: failed to allow BuiltinAdministrators (LastError = %d)", 
            RpcStatus));
        goto Cleanup;
    }

Cleanup:
    if(RpcStatus != NOERROR) 
    {
        if(AuthenticatedUsers) 
        {
            FreeSid(AuthenticatedUsers);
        }

        if(BuiltinAdministrators)
        {
            FreeSid(BuiltinAdministrators);
        }

        if(*ppAcl)
        {
            HeapFree(GetProcessHeap(), 0, *ppAcl);
            *ppAcl = NULL;
        }
    }

    return RpcStatus;
}


RPC_STATUS
StartRpcServerListen(
    VOID)
/*++

Routine Description:

    This function starts RpcServerListen for this process.

    RPC server only binds to LRPC transport , if STI becomes remotable
    it will need to bind to named pipe and/or tcp/ip ( or netbios) transports
    
    Shouldn't happen though, since WIA will be the remotable part, while STI will
    be local to the machine.
    
Arguments:



Return Value:

    NERR_Success, or any RPC error codes that can be returned from
    RpcServerUnregisterIf.

--*/
{

    DBG_FN(StartRpcServerListen);

    RPC_STATUS  RpcStatus;

    SECURITY_DESCRIPTOR SecurityDescriptor;
    ACL *pAcl = NULL;


    // prepare our ACL
    RpcStatus = PrepareStiAcl(&pAcl);
    if(pAcl == NULL) {
        DBG_ERR(("StartRpcServerListen: PrepareStiAcl() returned RpcStatus=0x%X", RpcStatus));
        return RpcStatus;
    }

    // Give access to everybody
    InitializeSecurityDescriptor(&SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&SecurityDescriptor, TRUE, pAcl, FALSE);

    //
    // For now, ignore the second argument.
    //

    RpcStatus = RpcServerUseProtseqEp((RPC_STRING)STI_LRPC_SEQ,
                                      STI_LRPC_MAX_REQS,
                                      (RPC_STRING)STI_LRPC_ENDPOINT,
                                      &SecurityDescriptor);

    if ( NOERROR != RpcStatus) {
        DBG_ERR(("StartRpcServerListen: RpcServerUseProtseqEp returned RpcStatus=0x%X",RpcStatus));
        return RpcStatus;
    }

    //
    // Add interface by using implicit handle, generated by MIDL
    //
    RpcStatus = RpcServerRegisterIfEx(stirpc_ServerIfHandle,      //RpcInterface
                                      0,                          //MgrUuid
                                      0,                          //MgrEpv
                                      RPC_IF_ALLOW_SECURE_ONLY,
                                      RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                      StiRpcSecurityCallBack);

    if ( NOERROR != RpcStatus) {
        DBG_ERR(("StartRpcServerListen: RpcServerRegisterIf returned RpcStatus=0x%X",RpcStatus));
        return RpcStatus;
    }

    //
    // Now initiate servicing
    //
    RpcStatus = RpcServerListen(STI_LRPC_THREADS,         // Minimum # of listen threads
                                STI_LRPC_MAX_REQS,        // Concurrency
                                TRUE);                    // Immediate return

    if ( NOERROR != RpcStatus) {
        DBG_ERR(("StartRpcServerListen: RpcServerListen returned RpcStatus=0x%X",RpcStatus));
    }

    return (RpcStatus);
}


RPC_STATUS
StopRpcServerListen(
    VOID
    )

/*++

Routine Description:

    Deletes the interface.

Arguments:


Return Value:

    RPC_S_OK or any RPC error codes that can be returned from
    RpcServerUnregisterIf.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcServerUnregisterIf(stirpc_ServerIfHandle,
                                      NULL,         // MgrUuid
                                      TRUE);        // wait for calls to complete

    // BUGBUG RPC server should stop only after all interfaces are unregistered. For now we
    // only have one, so this is non-issue. When adding new interfaces to this RPC server, keep
    // ref count on register/unregister

    RpcStatus = RpcMgmtStopServerListening(0);

    //
    // wait for all RPC threads to go away.
    //

    if( RpcStatus == RPC_S_OK) {
        RpcStatus = RpcMgmtWaitServerListen();
    }

    return (RpcStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\sched.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sched.cpp

Abstract:

    Scheduling work items

    Allows scheduling callbacks based on timeout or sognalling event handle

Author:

    Vlad Sadovsky (vlads)   31-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    31-Jan-1997     VladS       created
    30-Apr-1997     VladS       Added support for asyncronous events

--*/

//
//  Include Headers
//

#include "precomp.h"
#include "stiexe.h"
#include <stilib.h>

//
//  Global definitions
//

//
// Use reference counting on context objects
//
#define  USE_REF                 1

#define EVENT_ARRAY_SIZE        32

#define LockScheduleList()      g_SchedulerLock.Lock();
#define UnlockScheduleList()    g_SchedulerLock.Unlock();

#define SIGNATURE_SCHED         (DWORD)'SCHa'
#define SIGNATURE_SCHED_FREE    (DWORD)'SCHf'

class SCHED_ITEM
{
public:

    SCHED_ITEM( PFN_SCHED_CALLBACK pfnCallback,
                PVOID              pContext,
                DWORD              msecTime,
                int                nPriority,
                DWORD              dwSerial,
                HANDLE             hEvent)
        :m_pfnCallback   ( pfnCallback ),
         m_pContext      ( pContext ),
         m_nPriority     ( nPriority ),
         m_dwSerialNumber( dwSerial ),
         m_hRegisteredEventHandle(hEvent),
         m_Signature     ( SIGNATURE_SCHED )
    {
        if (m_hRegisteredEventHandle) {
            m_msecExpires = INFINITE;
        }
        else {
            m_msecExpires = GetTickCount() + msecTime;
        }
    }

    ~SCHED_ITEM( VOID )
    {
        ASSERT(m_ListEntry.Flink == NULL );
       m_Signature = SIGNATURE_SCHED_FREE;
    }

    BOOL CheckSignature( VOID ) const
        { return m_Signature == SIGNATURE_SCHED; }

    #ifdef DEBUG
    VOID DumpObject(VOID)
    {
        /*  This will cause problems in 64bit (the m_Signature)....
        DBG_TRC(("ScheduleWorkItem: Dumping itself:this(%X) Sign(%4c) ListEntry(%X,%X,%X) Ser#(%d) Context(%X)"), \
                this,(char *)m_Signature,
                &m_ListEntry,m_ListEntry.Flink,m_ListEntry.Blink,
                m_dwSerialNumber,m_pContext);
        */                
    }
    #endif

    LIST_ENTRY         m_ListEntry;         // Connection field
    DWORD              m_Signature;         // Validity verification
    PFN_SCHED_CALLBACK m_pfnCallback;       // Work processing callback
    PVOID              m_pContext;          // Context pointer ( usually object ptr)
    DWORD              m_msecExpires;       // Time when timeout expires for this item (in ms)
    int                m_nPriority;         //
    DWORD              m_dwSerialNumber;    // To identify work item when removing
    HANDLE             m_hRegisteredEventHandle; //
};

DWORD
SchedulerThread(
    LPDWORD lpdwParam
    );

//
//  Global data items
//

CRIT_SECT         g_SchedulerLock;
LIST_ENTRY        g_ScheduleListHead;

BOOL              g_fSchedulerInitialized = FALSE;
BOOL              g_fSchedulePaused = FALSE;
BOOL              g_fSchedShutdown = FALSE;

HANDLE            g_hSchedulerEvent;

HANDLE            g_aEventArray[EVENT_ARRAY_SIZE];
UINT              g_uiUsedHandles = 0;

//
//  Used as identification for work items, incremented on each new item allocated
//

static LONG       g_dwSchedSerial = 0;

BOOL
SchedulerInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the scheduler package

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    DWORD   idThread;
    HANDLE  hSchedulerThread;

    if ( g_fSchedulerInitialized )
        return TRUE;

    ::ZeroMemory(g_aEventArray,sizeof(g_aEventArray));

    g_hSchedulerEvent = CreateEvent( NULL,
                                   FALSE,
                                   FALSE,
                                   NULL );

    if ( !g_hSchedulerEvent ) {
        return FALSE;
    }

    // Save event handle in global array as first element
    g_aEventArray[g_uiUsedHandles++] = g_hSchedulerEvent;

    InitializeListHead( &g_ScheduleListHead );

    hSchedulerThread = ::CreateThread( NULL,
                                     0,
                                     (LPTHREAD_START_ROUTINE) SchedulerThread,
                                     NULL,
                                     0,
                                     &idThread );

    if ( !hSchedulerThread ) {
        CloseHandle( g_hSchedulerEvent );
        return FALSE;
    }

    CloseHandle( hSchedulerThread );

    g_fSchedulerInitialized = TRUE;

    STIMONWPRINTF(TEXT("Work item scheduler initialized"));

    return TRUE;
}

VOID
SchedulerTerminate(
    VOID
    )
/*++

Routine Description:

    Terminates and cleans up the scheduling package.  Any items left on the
    list are *not* called during cleanup.

--*/
{
    SCHED_ITEM *psi;

    if ( !g_fSchedulerInitialized )
        return;

    g_fSchedShutdown = TRUE;

    SetEvent( g_hSchedulerEvent ) ;

    // Protected code block
    {
        TAKE_CRIT_SECT t(g_SchedulerLock);

        //
        //  Delete all of the items that were scheduled, note we do *not*
        //  call any scheduled items in the list (there shouldn't be any)
        //
        while ( !IsListEmpty( &g_ScheduleListHead ) ) {

            psi = CONTAINING_RECORD( g_ScheduleListHead.Flink,
                                     SCHED_ITEM,
                                     m_ListEntry );

            ASSERT( psi->CheckSignature() );

            RemoveEntryList( &psi->m_ListEntry );
            psi->m_ListEntry.Flink = NULL;

            delete psi;
        }
    }

    Sleep( 250 );

    CloseHandle( g_hSchedulerEvent );

    g_fSchedulerInitialized = FALSE;
}

BOOL
SchedulerSetPauseState(
    BOOL    fNewState
    )
{
    BOOL    fOldState = g_fSchedulePaused;

    g_fSchedulePaused = fNewState;

    return fOldState;
}

DWORD
ScheduleWorkItem(
    PFN_SCHED_CALLBACK pfnCallback,
    PVOID              pContext,
    DWORD              msecTime,
    HANDLE             hEvent,
    int                nPriority
    )
/*++

Routine Description:

    Adds a timed work item to the work list

Arguments:

    pfnCallback - Function to call
    pContext - Context to pass to the callback
    hEvent      - handle of event to wait on before signalling callback
    msecTime - number of milliseconds to wait before calling timeout
    nPriority - Thread priority to set for work item

Return Value:

    zero on failure, non-zero on success.  The return value can be used to
    remove the scheduled work item.

--*/
{
    SCHED_ITEM *psi;
    SCHED_ITEM *psiList;
    LIST_ENTRY *pEntry;
    DWORD       dwRet = 0;
    BOOL        fValidRequest = FALSE;

    ASSERT( g_fSchedulerInitialized );

    if ( !g_fSchedulerInitialized )
        return 0;

    //
    //  Scheduler currently only supports normal thread priority
    //

    ASSERT( nPriority == THREAD_PRIORITY_NORMAL );

    InterlockedIncrement(&g_dwSchedSerial);

    psi = new SCHED_ITEM( pfnCallback,
                          pContext,
                          msecTime,
                          nPriority,
                          g_dwSchedSerial,
                          hEvent );

    if ( !psi ) {
        return 0;
    }

    // BEGIN PROTECTED CODE
    {
        TAKE_CRIT_SECT t(g_SchedulerLock);

        //  Commented out to reduce debug output when lock management auto-unlocking is enabled
        //DBG_TRC(("Scheduler adding work item (%X) "),psi);

        //
        // Validate scheduling request. If it timer based - always valid
        // if it is passing event handle, we are limited by the size of wait array, so first check to see
        // if array is not full
        //
        fValidRequest = TRUE;
        if (hEvent && (hEvent!=INVALID_HANDLE_VALUE)) {
            if (g_uiUsedHandles < EVENT_ARRAY_SIZE) {
                g_aEventArray[g_uiUsedHandles++] = hEvent;
            }
            else {
                fValidRequest = FALSE;
                dwRet = 0;
            }
        }

        //
        //  Insert the list in order based on expires time
        //

        if(fValidRequest) {

            for ( pEntry =  g_ScheduleListHead.Flink;
                  pEntry != &g_ScheduleListHead;
                  pEntry =  pEntry->Flink ) {

                psiList = CONTAINING_RECORD( pEntry, SCHED_ITEM,m_ListEntry );

                if ( psiList->m_msecExpires > psi->m_msecExpires ) {
                    break;
                }
            }

            //
            //  This should work in whether the list is empty or this is the last item
            //  on the list
            //

            psi->m_ListEntry.Flink = pEntry;
            psi->m_ListEntry.Blink = pEntry->Blink;

            pEntry->Blink->Flink = &psi->m_ListEntry;
            pEntry->Blink        = &psi->m_ListEntry;

            dwRet = psi->m_dwSerialNumber;

            #if 0
            DBG_TRC(("Scheduler added work item (%X) with cookie(%d) before (%X). Head=(%X)  "),psi,psi->m_dwSerialNumber,pEntry,&g_ScheduleListHead);
            psi->DumpObject();
            #endif
        }

    }
    // END PROTECTED CODE

    //
    // Kick off scheduler thread
    //
    if(fValidRequest) {
        SetEvent( g_hSchedulerEvent );
    }
    else {
        delete psi;
    }

    return dwRet;
}

BOOL
RemoveWorkItem(
    DWORD  dwCookie
    )
/*++

Routine Description:

    Removes a scheduled work item

Arguments:

    dwCookie - The return value from a previous call to ScheduleWorkItem

Return Value:

    TRUE if the item was found, FALSE if the item was not found.

--*/
{
    SCHED_ITEM * psi;
    LIST_ENTRY * pEntry;

    // BEGIN PROTECTED CODE
    {
        TAKE_CRIT_SECT t(g_SchedulerLock);

        DBG_TRC(("Schedule::RemoveWorkItem (%X) ", dwCookie));

        //
        // Walk the list to find an item with matching id
        //

        for ( pEntry =  g_ScheduleListHead.Flink;
              pEntry != &g_ScheduleListHead;
              pEntry = pEntry->Flink ) {

            psi = CONTAINING_RECORD( pEntry, SCHED_ITEM,m_ListEntry );

            ASSERT( psi->CheckSignature() );

            if ( dwCookie == psi->m_dwSerialNumber ) {

                //
                // Found our item
                //
                #if 0
                DBG_TRC(("Scheduler removing work item (%X) "),psi);
                psi->DumpObject();
                #endif

                RemoveEntryList( pEntry );
                pEntry->Flink = NULL;

                //
                // If this work item is associated with asyncronous event , remove event handle
                // from wait array
                //
                if (psi->m_hRegisteredEventHandle && psi->m_hRegisteredEventHandle != INVALID_HANDLE_VALUE) {

                    UINT        uiIndex;

                    // Find handle in wait array
                    for (uiIndex = 0;
                         uiIndex < g_uiUsedHandles;
                         uiIndex++ ) {

                        if ( g_aEventArray[uiIndex] == psi->m_hRegisteredEventHandle ) {

                            memcpy(&g_aEventArray[uiIndex],
                                   &g_aEventArray[uiIndex+1],
                                   sizeof(g_aEventArray[0])*(g_uiUsedHandles - uiIndex - 1)
                                   );

                            g_aEventArray[g_uiUsedHandles--] = NULL;
                        }
                    }
                }

                // Destroy work item now
                delete psi;

                return TRUE;
            }
        }

    }
    // END PROTECTED CODE

    //
    // Item with given number not found
    //

    return FALSE;
}

DWORD
SchedulerThread(
    LPDWORD lpdwParam
    )
/*++

Routine Description:

    Initializes the scheduler/timer package

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    DWORD       cmsecWait = INFINITE;
    DWORD       TickCount;
    SCHED_ITEM *psi = NULL;
    LIST_ENTRY *pEntry;
    DWORD       dwErr;
    UINT        uiSignalledIndex;
    BOOL        fFoundSignalledItem = FALSE;

    while ( TRUE ) {

        dwErr = ::WaitForMultipleObjects(g_uiUsedHandles,
                                         g_aEventArray,
                                         FALSE,
                                         cmsecWait );

        uiSignalledIndex = dwErr - WAIT_OBJECT_0;

        //
        //  If we're shutting down, get out
        //
        if ( g_fSchedShutdown ) {
            goto Exit;
        }


        #if 0
        DebugDumpScheduleList(TEXT("SchedulerThread"));
        #endif

        switch (dwErr)
        {
        default:
                if ((uiSignalledIndex > 0) && (uiSignalledIndex < g_uiUsedHandles )) {
                    //
                    // One of the devices signalled event. Find work item for this device
                    // and invoke callback
                    //
                    LockScheduleList()

                    fFoundSignalledItem = FALSE;

                    for ( pEntry  = g_ScheduleListHead.Flink;
                          pEntry != &g_ScheduleListHead;
                          pEntry = pEntry->Flink
                        ) {

                        psi = CONTAINING_RECORD( pEntry, SCHED_ITEM,m_ListEntry );

                        ASSERT( psi->CheckSignature() );

                        if ( g_aEventArray[uiSignalledIndex] == psi->m_hRegisteredEventHandle ) {

                            fFoundSignalledItem = TRUE;

                            RemoveEntryList( &psi->m_ListEntry );
                            psi->m_ListEntry.Flink = NULL;

                            #ifdef USE_REF
                            // Reference context object
                            if(psi->m_pContext) {
                                ((IUnknown *)psi->m_pContext)->AddRef();
                            }
                            #endif

                            //
                            // Delete event handle from the array
                            //
                            if (uiSignalledIndex < g_uiUsedHandles-1 ) {
                                memcpy(&g_aEventArray[uiSignalledIndex],
                                       &g_aEventArray[uiSignalledIndex+1],
                                       sizeof(g_aEventArray[0])*(g_uiUsedHandles - uiSignalledIndex - 1)
                                       );
                            }

                            g_aEventArray[g_uiUsedHandles--] = NULL;

                            break;
                        }
                    }

                    UnlockScheduleList()

                    //
                    // If signalled item had been found and verified - invoke callback and remove it
                    //
                    if (fFoundSignalledItem) {

                        if(psi->m_pContext) {
                            psi->m_pfnCallback( psi->m_pContext );
                            #ifdef USE_REF
                            ((IUnknown *)psi->m_pContext)->Release();
                            #endif
                        }

                        delete psi;
                    }

                    continue;
                }

            //
            //  Fall through to signalled scheduler event
            //

        case WAIT_OBJECT_0:

            //
            //  Means a new item has been scheduled, reset the timeout or
            //  we are shutting down
            //

            if ( g_fSchedShutdown ) {
                goto Exit;
            }

            LockScheduleList();

            //
            //  Get the timeout value for the first item in the list
            //

            if ( !IsListEmpty( &g_ScheduleListHead ) ) {

                psi = CONTAINING_RECORD( g_ScheduleListHead.Flink,
                                         SCHED_ITEM,
                                        m_ListEntry );

                ASSERT( psi->CheckSignature() );

                //
                //  Make sure the front item hasn't already expired
                //

                TickCount = GetTickCount();

                if ( TickCount > psi->m_msecExpires ) {
                    // We have at least one work item needing attention
                    goto RunItems;
                }

                cmsecWait = psi->m_msecExpires - TickCount;
            }
            else
            {
                cmsecWait = INFINITE;
            }

            UnlockScheduleList();

            break;

        case WAIT_TIMEOUT:

StartAgain:
            //
            //  If we're shutting down, get out
            //

            if ( g_fSchedShutdown ) {
                goto Exit;
            }

            if (g_fSchedulePaused ) {
                continue;
            }

            TickCount = GetTickCount();

            //
            //  Walk the sorted list for expired work items
            //

            LockScheduleList();
RunItems:
            //
            //  If no items, schedule no timeout
            //

            if ( IsListEmpty( &g_ScheduleListHead ))
            {
                cmsecWait = INFINITE;
            }

            for ( pEntry  = g_ScheduleListHead.Flink;
                  pEntry != &g_ScheduleListHead;
                )
            {
                psi = CONTAINING_RECORD( pEntry, SCHED_ITEM,m_ListEntry );

                ASSERT( psi->CheckSignature() );

                //
                // Go through expired items, skipping the ones with event handle set
                //
                if ( (TickCount > psi->m_msecExpires) &&
                      !psi->m_hRegisteredEventHandle ) {

                    pEntry = pEntry->Flink;

                    // Take item off the list
                    RemoveEntryList( &psi->m_ListEntry );
                    psi->m_ListEntry.Flink = NULL;

                    #ifdef USE_REF
                    // Reference context object
                    if(psi->m_pContext) {
                        ((IUnknown *)psi->m_pContext)->AddRef();
                    }
                    #endif

                    //
                    //  Unlock the list so clients can add additional
                    //  schedule items
                    //

                    UnlockScheduleList();

                    if (psi->m_pContext) {
                        psi->m_pfnCallback( psi->m_pContext );
                        #ifdef USE_REF
                        ((IUnknown *)psi->m_pContext)->Release();
                        #endif
                    }

                    delete psi;

                    //
                    //  Start looking in the list from the beginning in case
                    //  new items have been added or removed
                    //

                    goto StartAgain;
                }
                else {
                    //
                    //  Since they are in sorted order once we hit one that's
                    //  not expired we don't need to look further
                    //

                    cmsecWait = psi->m_msecExpires - TickCount;
                    break;
                }
            }

            UnlockScheduleList();

            break;
        }
    } // while ( TRUE )

Exit:

    return 0;
}

#ifdef DEBUG

VOID
DebugDumpScheduleList(
    LPCTSTR  pszId
    )
{
    if ( !g_fSchedulerInitialized ) {
        STIMONWPRINTF(TEXT("Schedule list not initialized"));
        return;
    }

    LIST_ENTRY * pentry;
    LIST_ENTRY * pentryNext;

    SCHED_ITEM * psi = NULL;

    TAKE_CRIT_SECT t(g_SchedulerLock);

    DBG_TRC(("Validating schedule list . Called from (%S)" ,pszId ? pszId : TEXT("Unknown")));

    for ( pentry  = g_ScheduleListHead.Flink;
          pentry != &g_ScheduleListHead;
          pentry  = pentryNext ) {

        pentryNext = pentry->Flink;

        psi = CONTAINING_RECORD( pentry, SCHED_ITEM,m_ListEntry );

        ASSERT( psi->CheckSignature() );
        psi->DumpObject();

    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\security.cpp ===
/*++


Copyright (c)   1997    Microsoft Corporation

Module Name:

    security.cpp

Abstract:

    Initializes security descriptor object for STI services
    access validation

Author:

    Vlad  Sadovsky  (vlads)     09-28-97

Environment:

    User Mode - Win32

Revision History:

    28-Sep-1997     VladS       created

--*/


//
//  Include Headers
//
#include "precomp.h"
#include "stiexe.h"
#include <stisvc.h>

#ifdef DEBUG
#define STATIC
#else
#define STATIC  static
#endif

#ifdef WINNT

//
// Globals
//

//
// NT well-known SIDs
//

PSID psidNull       = NULL;                 // No members SID
PSID psidWorld      = NULL;                 // All users SID
PSID psidLocal      = NULL;                 // NT local users SID
PSID psidLocalSystem= NULL;                 // NT system processes SID
PSID psidNetwork    = NULL;                 // NT remote users SID
PSID psidAdmins     = NULL;
PSID psidServerOps  = NULL;
PSID psidPowerUsers = NULL;
PSID psidGuestUser  = NULL;
PSID psidProcessUser= NULL;
PSID psidBuiltinDomain = NULL;              // Domain Id of the Builtin Domain

//
// Well Known Aliases.
//
// These are aliases that are relative to the built-in domain.
//

PSID psidLocalAdmin = NULL;            // NT local admins
PSID psidAliasAdmins = NULL;
PSID psidAliasUsers = NULL;
PSID psidAliasGuests = NULL;
PSID psidAliasPowerUsers = NULL;
PSID psidAliasAccountOps = NULL;
PSID psidAliasSystemOps = NULL;
PSID psidAliasPrintOps = NULL;
PSID psidAliasBackupOps = NULL;

//
// List of well-known SID data structures we use to initialize globals
//
struct _SID_DATA {
    PSID    *Sid;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    ULONG   SubAuthority;
} SidData[] = {
 {&psidNull,          SECURITY_NULL_SID_AUTHORITY,  SECURITY_NULL_RID},
 {&psidWorld,         SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID},
 {&psidLocal,         SECURITY_LOCAL_SID_AUTHORITY, SECURITY_LOCAL_RID},
 {&psidNetwork,       SECURITY_NT_AUTHORITY,        SECURITY_NETWORK_RID},
 {&psidLocalSystem,   SECURITY_NT_AUTHORITY,        SECURITY_LOCAL_SYSTEM_RID},
 {&psidBuiltinDomain, SECURITY_NT_AUTHORITY,        SECURITY_BUILTIN_DOMAIN_RID}
};

#define NUM_SIDS (sizeof(SidData) / sizeof(SidData[0]))


STATIC
struct _BUILTIN_DOMAIN_SID_DATA {
    PSID *Sid;
    ULONG RelativeId;
} psidBuiltinDomainData[] = {
    { &psidLocalAdmin, DOMAIN_ALIAS_RID_ADMINS},
    { &psidAliasAdmins, DOMAIN_ALIAS_RID_ADMINS },
    { &psidAliasUsers, DOMAIN_ALIAS_RID_USERS },
    { &psidAliasGuests, DOMAIN_ALIAS_RID_GUESTS },
    { &psidAliasPowerUsers, DOMAIN_ALIAS_RID_POWER_USERS },
    { &psidAliasAccountOps, DOMAIN_ALIAS_RID_ACCOUNT_OPS },
    { &psidAliasSystemOps, DOMAIN_ALIAS_RID_SYSTEM_OPS },
    { &psidAliasPrintOps, DOMAIN_ALIAS_RID_PRINT_OPS },
    { &psidAliasBackupOps, DOMAIN_ALIAS_RID_BACKUP_OPS }
};

#define NUM_DOMAIN_SIDS (sizeof(psidBuiltinDomainData) / sizeof(psidBuiltinDomainData[0]))

//
// List of ACEs definitions to initialize our security descriptor
//

typedef struct {
    BYTE    AceType;
    BYTE    InheritFlags;
    BYTE    AceFlags;
    ACCESS_MASK Mask;
    PSID    *Sid;
} ACE_DATA, *PACE_DATA;

STATIC
ACE_DATA AcesData[] =
                 {
                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         STI_ALL_ACCESS,
                         &psidLocalSystem
                     },

                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         STI_ALL_ACCESS,
                         &psidAliasAdmins
                     },

                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         STI_ALL_ACCESS,
                         &psidAliasSystemOps
                     },

                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         STI_ALL_ACCESS,
                         &psidAliasPowerUsers
                     },
                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         STI_ALL_ACCESS, // BUGBUG only need to syncronize
                         // STI_GENERIC_EXECUTE | SYNCHRONIZE,
                         &psidWorld
                     },

                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         STI_ALL_ACCESS, // BUGBUG only need to syncronize
                         &psidLocal
                     },

//                     {
//                         ACCESS_ALLOWED_ACE_TYPE,
//                         0,
//                         0,
//                         STI_GENERIC_EXECUTE,
//                         &psidProcessUser
//                     },
                 };

#define NUM_ACES (sizeof(AcesData) / sizeof(AcesData[0]))

//
//  Local variables and types definitions
//

//
//  The API security object.  Client access STI Server APIs
//  are validated against this object.
//

PSECURITY_DESCRIPTOR    sdApiObject;

//
//  This table maps generic rights (like GENERIC_READ) to
//  specific rights (like STI_QUERY_SECURITY).
//

GENERIC_MAPPING         ApiObjectMapping = {
                            STI_GENERIC_READ,          // generic read
                            STI_GENERIC_WRITE,         // generic write
                            STI_GENERIC_EXECUTE,       // generic execute
                            STI_ALL_ACCESS             // generic all
                        };

//
//  Private prototypes.
//

DWORD
CreateWellKnownSids(
        VOID
        );

VOID
FreeWellKnownSids(
    VOID
    );

DWORD
CreateSecurityObject(
    IN  PACE_DATA   AceData,
    IN  ULONG       AceCount,
    IN  PSID        psidOwner,
    IN  PSID        psidGroup,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

DWORD
DeleteSecurityObject(
    IN PSECURITY_DESCRIPTOR *Descriptor
    );

//
// Code
//
DWORD
AllocateAndInitializeSid(
    OUT PSID *Sid,
    IN  PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN  ULONG SubAuthorityCount
    )
/*++

Routine Description:

    This function allocates memory for a SID and initializes it.

Arguments:

    None.

Return Value:

    WIN32 Error Code.

--*/
{
    *Sid = (PSID)
        LocalAlloc(LPTR,
            GetSidLengthRequired( (BYTE)SubAuthorityCount) );

    if (*Sid == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    InitializeSid( *Sid, IdentifierAuthority, (BYTE)SubAuthorityCount );

    return( NOERROR );
}

DWORD
DomainIdToSid(
    IN PSID     DomainId,
    IN ULONG    RelativeId,
    OUT PSID    *Sid
    )
/*++

Routine Description:

    Given a domain Id and a relative ID create a SID

Arguments:

    DomainId - The template SID to use.

    RelativeId - The relative Id to append to the DomainId.

    Sid - Returns a pointer to an allocated buffer containing the resultant Sid.

Return Value:

    WIN32 Error Code.

--*/
{
    DWORD   dwError;
    BYTE    DomainIdSubAuthorityCount;  // Number of sub authorities in domain ID
    UINT    SidLength;                  // Length of newly allocated SID

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(GetSidSubAuthorityCount( DomainId ));

    SidLength = GetSidLengthRequired( (BYTE)(DomainIdSubAuthorityCount+1) );

    if ((*Sid = (PSID) LocalAlloc(LPTR, SidLength )) == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if( CopySid(SidLength, *Sid, DomainId) == FALSE ) {

        dwError = GetLastError();

        LocalFree( *Sid );
        return( dwError );
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(GetSidSubAuthorityCount( *Sid ))) ++;
    *GetSidSubAuthority( *Sid, DomainIdSubAuthorityCount ) = RelativeId;

    return( NOERROR );

}

DWORD
WINAPI
CreateWellKnownSids(
    VOID
    )
/*++

Routine Description:

    This function creates some well-known SIDs and store them in global
    variables.

Arguments:

    none.

Return Value:

    WIN32 Error Code.

--*/
{
    DWORD dwError;
    DWORD i;

    //
    // Allocate and initialize well-known SIDs which aren't relative to
    // the Domain Id.
    //

    for (i = 0; i< NUM_SIDS ; i++) {

        dwError = AllocateAndInitializeSid(
                        SidData[i].Sid,
                        &(SidData[i].IdentifierAuthority),
                        1);

        if ( dwError != NOERROR ) {
            return dwError;
        }

        *(GetSidSubAuthority(*(SidData[i].Sid), 0)) = SidData[i].SubAuthority;
    }

    //
    // Build each SID which is relative to the Builtin Domain Id.
    //

    for ( i = 0;i < NUM_DOMAIN_SIDS; i++) {

        dwError = DomainIdToSid(
                        psidBuiltinDomain,
                        psidBuiltinDomainData[i].RelativeId,
                        psidBuiltinDomainData[i].Sid );

        if ( dwError != NOERROR ) {
            return dwError;
        }
    }

    return NOERROR;

} // CreateWellKnownSids

VOID
WINAPI
FreeWellKnownSids(
    VOID
    )
/*++

Routine Description:

    This function frees up the dynamic memory consumed by the well-known
    SIDs.

Arguments:

    none.

Return Value:

    none

--*/
{
    DWORD i;

    //
    // free up memory allocated for well-known SIDs
    //

    for (i = 0; i < NUM_SIDS ; i++) {

        if( *SidData[i].Sid != NULL ) {
            LocalFree( *SidData[i].Sid );
            *SidData[i].Sid = NULL;
        }
    }

    //
    // free up memory allocated for Builtin Domain SIDs
    //

    for (i = 0; i < NUM_DOMAIN_SIDS; i++) {

        if( *psidBuiltinDomainData[i].Sid != NULL ) {
            LocalFree( *psidBuiltinDomainData[i].Sid );
            *psidBuiltinDomainData[i].Sid = NULL;
        }
    }

} //FreeWellKnownSids

DWORD
WINAPI
InitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an allowed type ACE.

Arguments:

    AllowedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is allowed
        the specified access.

Return Value:

    WIN32 Error Code.

--*/
{
    AllowedAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    AllowedAce->Header.AceSize = AceSize;
    AllowedAce->Header.AceFlags = AceFlags | InheritFlags;

    AllowedAce->Mask = Mask;

    if( CopySid(
            GetLengthSid(AllowedSid), // should be valid SID ??
            &(AllowedAce->SidStart),
            AllowedSid ) == FALSE ) {

        return( GetLastError() );
    }

    return( NOERROR );
}

DWORD
WINAPI
InitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into a denied type ACE.

Arguments:

    DeniedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the denied access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is denied
        the specified access.

Return Value:

    WIN32 Error Code.

--*/
{
    DeniedAce->Header.AceType = ACCESS_DENIED_ACE_TYPE;
    DeniedAce->Header.AceSize = AceSize;
    DeniedAce->Header.AceFlags = AceFlags | InheritFlags;

    DeniedAce->Mask = Mask;

    if( CopySid(
            GetLengthSid(DeniedSid), // should be valid SID ??
            &(DeniedAce->SidStart),
            DeniedSid ) == FALSE ) {

        return( GetLastError() );
    }

    return( NOERROR );
}

DWORD
WINAPI
InitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  BYTE InheritFlags,
    IN  BYTE AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an audit type ACE.

Arguments:

    AuditAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AuditSid - Supplies the pointer to the SID of user/group which is to be
        audited.

Return Value:

    WIN32 Error Code.

--*/
{
    AuditAce->Header.AceType = SYSTEM_AUDIT_ACE_TYPE;
    AuditAce->Header.AceSize = AceSize;
    AuditAce->Header.AceFlags = AceFlags | InheritFlags;

    AuditAce->Mask = Mask;

    if( CopySid(
               GetLengthSid(AuditSid),
               &(AuditAce->SidStart),
               AuditSid ) == FALSE ) {

        return( GetLastError() );
    }

    return( NOERROR );
}

DWORD
WINAPI
CreateSecurityDescriptorHelper(
    IN  PACE_DATA   AceData,
    IN  ULONG       AceCount,
    IN  PSID        psidOwner OPTIONAL,
    IN  PSID        psidGroup OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates an absolute security descriptor containing
    the supplied ACE information.

    A sample usage of this function:

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &psidLocalAdmin},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &psidNetwork},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        return CreateSecurityDescriptor(
                   AceData,
                   4,
                   psidNull,
                   psidLocalSystem,
                   &ConfigurationInfoSd
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    psidOwner - Supplies the pointer to the SID of the security descriptor
        owner.  If not specified, a security descriptor with no owner
        will be created.

    psidGroup - Supplies the pointer to the SID of the security descriptor
        primary group.  If not specified, a security descriptor with no primary
        group will be created.

    NewDescriptor - Returns a pointer to the absolute secutiry descriptor
        allocated using MemoryAllocate.

Return Value:

    WIN32 Error Code.

--*/
{
    DWORD dwError = 0;
    DWORD i;

    //
    // Pointer to memory dynamically allocated by this routine to hold
    // the absolute security descriptor, the DACL, the SACL, and all the ACEs.
    //
    // +---------------------------------------------------------------+
    // |                     Security Descriptor                       |
    // +-------------------------------+-------+---------------+-------+
    // |          DACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    // |          SACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    //

    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    PACL                 Dacl = NULL;   // Pointer to the DACL portion of above buffer
    PACL                 Sacl = NULL;   // Pointer to the SACL portion of above buffer

    DWORD               DaclSize = sizeof(ACL);
    DWORD               SaclSize = sizeof(ACL);
    DWORD               MaxAceSize = 0;
    PVOID               MaxAce = NULL;

    LPBYTE              CurrentAvailable;
    DWORD               Size;

    // ASSERT( AceCount > 0 );

    //
    // Compute the total size of the DACL and SACL ACEs and the maximum
    // size of any ACE.
    //
    for (i = 0; i < AceCount; i++) {

        DWORD AceSize;

        AceSize = GetLengthSid( *(AceData[i].Sid) );

        switch (AceData[i].AceType) {
            case ACCESS_ALLOWED_ACE_TYPE:
                AceSize += sizeof(ACCESS_ALLOWED_ACE);
                DaclSize += AceSize;
                break;

            case ACCESS_DENIED_ACE_TYPE:
                AceSize += sizeof(ACCESS_DENIED_ACE);
                DaclSize += AceSize;
                break;

            case SYSTEM_AUDIT_ACE_TYPE:
                AceSize += sizeof(SYSTEM_AUDIT_ACE);
                SaclSize += AceSize;
                break;

            default:
                return( ERROR_INVALID_PARAMETER );
        }

        MaxAceSize = max( MaxAceSize, AceSize );
    }

    //
    // Allocate a chunk of memory large enough the security descriptor
    // the DACL, the SACL and all ACEs.
    //
    // A security descriptor is of opaque data type but
    // SECURITY_DESCRIPTOR_MIN_LENGTH is the right size.
    //

    __try {

        Size = SECURITY_DESCRIPTOR_MIN_LENGTH;

        if ( DaclSize != sizeof(ACL) ) {
            Size += DaclSize;
        }

        if ( SaclSize != sizeof(ACL) ) {
            Size += SaclSize;
        }

        if ((AbsoluteSd = LocalAlloc(LPTR, Size )) == NULL) {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        //
        // Initialize the Dacl and Sacl
        //
        CurrentAvailable = (LPBYTE)AbsoluteSd + SECURITY_DESCRIPTOR_MIN_LENGTH;

        if ( DaclSize != sizeof(ACL) ) {

            Dacl = (PACL)CurrentAvailable;
            CurrentAvailable += DaclSize;

            if( InitializeAcl( Dacl, DaclSize, ACL_REVISION ) == FALSE ) {
                dwError = GetLastError();
                __leave;
            }
        }

        if ( SaclSize != sizeof(ACL) ) {

            Sacl = (PACL)CurrentAvailable;
            CurrentAvailable += SaclSize;

            if( InitializeAcl( Sacl, SaclSize, ACL_REVISION ) == FALSE ) {
                dwError = GetLastError();
                __leave;
            }
        }

        //
        // Allocate a temporary buffer big enough for the biggest ACE.
        //

        if ((MaxAce = LocalAlloc(LPTR, MaxAceSize )) == NULL ) {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        //
        // Initialize each ACE, and append it into the end of the DACL or SACL.
        //

        for (i = 0; i < AceCount; i++) {

            DWORD AceSize;
            PACL CurrentAcl = NULL;

            AceSize = GetLengthSid( *(AceData[i].Sid) );

            switch (AceData[i].AceType) {
            case ACCESS_ALLOWED_ACE_TYPE:

                AceSize += sizeof(ACCESS_ALLOWED_ACE);
                CurrentAcl = Dacl;

                dwError = InitializeAllowedAce(
                                (PACCESS_ALLOWED_ACE)MaxAce,
                                (USHORT) AceSize,
                                AceData[i].InheritFlags,
                                AceData[i].AceFlags,
                                AceData[i].Mask,
                                *(AceData[i].Sid) );
                break;

            case ACCESS_DENIED_ACE_TYPE:

                AceSize += sizeof(ACCESS_DENIED_ACE);
                CurrentAcl = Dacl;

                dwError = InitializeDeniedAce(
                                (PACCESS_DENIED_ACE)MaxAce,
                                (USHORT) AceSize,
                                AceData[i].InheritFlags,
                                AceData[i].AceFlags,
                                AceData[i].Mask,
                                *(AceData[i].Sid) );
                break;

            case SYSTEM_AUDIT_ACE_TYPE:

                AceSize += sizeof(SYSTEM_AUDIT_ACE);
                CurrentAcl = Sacl;

                dwError = InitializeAuditAce(
                                (PACCESS_ALLOWED_ACE)MaxAce,
                                (USHORT) AceSize,
                                AceData[i].InheritFlags,
                                AceData[i].AceFlags,
                                AceData[i].Mask,
                                *(AceData[i].Sid) );
                break;
            }

            if ( dwError != NOERROR ) {
                __leave;
            }

            //
            // Append the initialized ACE to the end of DACL or SACL
            //

            if ( AddAce(
                    CurrentAcl,
                    ACL_REVISION,
                    MAXDWORD,
                    MaxAce,
                    AceSize ) == FALSE ) {
                dwError = GetLastError();
                __leave;
            }
        }

        //
        // Create the security descriptor with absolute pointers to SIDs
        // and ACLs.
        //
        // Owner = psidOwner
        // Group = psidGroup
        // Dacl  = Dacl
        // Sacl  = Sacl
        //

        if ( InitializeSecurityDescriptor(
                AbsoluteSd,
                SECURITY_DESCRIPTOR_REVISION ) == FALSE ) {
            dwError = GetLastError();
            __leave;
        }

        if ( SetSecurityDescriptorOwner(
                AbsoluteSd,
                psidOwner,
                FALSE ) == FALSE ) {
            dwError = GetLastError();
            __leave;
        }

        if ( SetSecurityDescriptorGroup(
                AbsoluteSd,
                psidGroup,
                FALSE ) == FALSE ) {
            dwError = GetLastError();
            __leave;
        }

        if ( SetSecurityDescriptorDacl(
                AbsoluteSd,
                TRUE,
                Dacl,
                FALSE ) == FALSE ) {
            dwError = GetLastError();
            __leave;
        }

        if ( SetSecurityDescriptorSacl(
                AbsoluteSd,
                FALSE,
                Sacl,
                FALSE ) == FALSE ) {

            dwError = GetLastError();
            __leave;
        }

        //
        // Done
        //

        *NewDescriptor = AbsoluteSd;
        AbsoluteSd = NULL;
        dwError = NOERROR;

    }
    __finally {

        // Cleanup

        if( AbsoluteSd != NULL ) {
            //
            // delete the partially made SD if we are not completely
            // successful
            //
            LocalFree( AbsoluteSd );
            AbsoluteSd = NULL;
        }

        //
        // Delete the temporary ACE
        //
        if ( MaxAce != NULL ) {
            LocalFree( MaxAce );
            MaxAce  = NULL;
        }
    }

    return( dwError );

}

DWORD
WINAPI
CreateSecurityObject(
    IN  PACE_DATA   AceData,
    IN  ULONG       AceCount,
    IN  PSID        psidOwner,
    IN  PSID        psidGroup,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates the DACL for the security descriptor based on
    on the ACE information specified, and creates the security descriptor
    which becomes the user-mode security object.

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    psidOwner - Supplies the pointer to the SID of the security descriptor
        owner.

    psidGroup - Supplies the pointer to the SID of the security descriptor
        primary group.

    GenericMapping - Supplies the pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

    NewDescriptor - Returns a pointer to the self-relative security descriptor
        which represents the user-mode object.

Return Value:

    WIN32 Error Code.

    NOTE : the security object created by calling this function may be
                freed up by calling DeleteSecurityObject().

--*/
{
    DWORD   dwError;
    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    HANDLE  hTokenHandle = NULL;

    __try {

        dwError = CreateSecurityDescriptorHelper(
                       AceData,
                       AceCount,
                       psidOwner,
                       psidGroup,
                       &AbsoluteSd
                       );

        if( dwError != NOERROR ) {
            __leave;
        }

        if( OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY,
                &hTokenHandle ) == FALSE ) {

            hTokenHandle = INVALID_HANDLE_VALUE;
            dwError = GetLastError();
            __leave;
        }

        //
        // Create the security object (a user-mode object is really a pseudo-
        // object represented by a security descriptor that have relative
        // pointers to SIDs and ACLs).  This routine allocates the memory to
        // hold the relative security descriptor so the memory allocated for the
        // DACL, ACEs, and the absolute descriptor can be freed.
        //
        if( CreatePrivateObjectSecurity(
                NULL,                   // Parent descriptor
                AbsoluteSd,             // Creator descriptor
                NewDescriptor,          // Pointer to new descriptor
                FALSE,                  // Is directory object
                hTokenHandle,            // Token
                GenericMapping          // Generic mapping
                    ) == FALSE ) {

            dwError = GetLastError();
            __leave;
        }

        dwError = NOERROR;

    }

    __finally {

        //
        // Finally clean up used resources

        if( hTokenHandle != NULL ) {
            CloseHandle( hTokenHandle );
        }

        //
        // Free dynamic memory before returning
        //

        if( AbsoluteSd != NULL ) {
            LocalFree( AbsoluteSd );
        }

    }

    return( dwError );
}


DWORD
WINAPI
DeleteSecurityObject(
    IN PSECURITY_DESCRIPTOR *Descriptor
    )
/*++

Routine Description:

    This function deletes a security object that was created by calling
    CreateSecurityObject() function.

Arguments:

    Descriptor - Returns a pointer to the self-relative security descriptor
        which represents the user-mode object.

Return Value:

    WIN32 Error Code.

--*/
{
    if( DestroyPrivateObjectSecurity( Descriptor ) == FALSE ) {
        return( GetLastError() );
    }

    return( NOERROR );
}


DWORD
WINAPI
StiAccessCheckAndAuditW(
    IN  LPCWSTR SubsystemName,
    IN  LPWSTR ObjectTypeName,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheckAndAuditAlarm; and reverts back to
    itself before returning.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling this routine.

    ObjectTypeName - Supplies the name of the type of the object being
        accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

Return Value:

    WIN32 Error - NOERROR or reason for failure.

--*/
{
    DWORD dwError;

    ACCESS_MASK GrantedAccess;
    BOOL GenerateOnClose;
    BOOL AccessStatus;

    dwError = RpcImpersonateClient( NULL ) ;

    if( dwError != NOERROR ) {
        return( dwError );
    }

    __try {

        if( AccessCheckAndAuditAlarmW(
                SubsystemName,
                NULL,                        // No handle for object
                ObjectTypeName,
                NULL,
                SecurityDescriptor,
                DesiredAccess,
                GenericMapping,
                FALSE,  // open existing object.
                &GrantedAccess,
                &AccessStatus,
                &GenerateOnClose ) == FALSE ) {

            dwError = GetLastError();
            __leave;
        }

        if ( AccessStatus == FALSE ) {
            dwError = ERROR_ACCESS_DENIED;
            __leave;
        }

        dwError = NOERROR;
    }
    __finally {
        DWORD dwTemp = RpcRevertToSelf();   // We don't care about the return here
    }

    return( dwError );
}

DWORD
WINAPI
StiAccessCheckAndAuditA(
    IN  LPCSTR SubsystemName,
    IN  LPSTR ObjectTypeName,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheckAndAuditAlarm; and reverts back to
    itself before returning.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling this routine.

    ObjectTypeName - Supplies the name of the type of the object being
        accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

Return Value:

    WIN32 Error - NOERROR or reason for failure.

--*/
{
    DWORD   dwError;

    ACCESS_MASK GrantedAccess;
    BOOL    GenerateOnClose;
    BOOL    AccessStatus;

    dwError = RpcImpersonateClient( NULL ) ;

    if( dwError != NOERROR ) {
        return( dwError );
    }
    __try {

        if( AccessCheckAndAuditAlarmA(
                SubsystemName,
                NULL,                        // No handle for object
                ObjectTypeName,
                NULL,
                SecurityDescriptor,
                DesiredAccess,
                GenericMapping,
                FALSE,  // open existing object.
                &GrantedAccess,
                &AccessStatus,
                &GenerateOnClose ) == FALSE ) {
            dwError = GetLastError();
            __leave;
        }

        if ( AccessStatus == FALSE ) {
            dwError = ERROR_ACCESS_DENIED;
            __leave;
        }

        dwError = NOERROR;
    }
    __finally {
        DWORD dwTemp = RpcRevertToSelf();   // We don't care about the return here
    }

    return( dwError );
}

DWORD
WINAPI
StiAccessCheck(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using AccessCheck; and reverts back to
    itself before returning.

    This routine differs from AccessCheckAndAudit in that it doesn't require
    the caller to have SE_AUDIT_PRIVILEGE nor does it generate audits.
    That is typically fine since the passed in security descriptor typically doesn't
    have a SACL requesting an audit.

Arguments:

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

Return Value:

    WINAPI_STATUS - NOERROR or  reason for failure.

--*/
{
    DWORD   dwError;

    HANDLE  hClientToken = NULL;

    DWORD   GrantedAccess;
    BOOL    AccessStatus;
    BYTE    PrivilegeSet[500]; // Large buffer
    DWORD   PrivilegeSetSize;


    //
    // Impersonate the client.
    //

    dwError = RpcImpersonateClient(NULL);

    if ( dwError != NOERROR ) {
        return( dwError );
    }

    __try {
        //
        // Open the impersonated token.
        //

        if ( OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                TRUE, // use process security context to open token
                &hClientToken ) == FALSE ) {

            dwError = GetLastError();
            __leave;
        }

        //
        // Check if the client has the required access.
        //

        PrivilegeSetSize = sizeof(PrivilegeSet);
        if ( AccessCheck(
                SecurityDescriptor,
                hClientToken,
                DesiredAccess,
                GenericMapping,
                (PPRIVILEGE_SET)&PrivilegeSet,
                &PrivilegeSetSize,
                &GrantedAccess,
                &AccessStatus ) == FALSE ) {
            dwError = GetLastError();
            __leave;
        }

        if ( AccessStatus == FALSE ) {
            dwError = ERROR_ACCESS_DENIED;
            __leave;
        }

        //
        // Success
        //
        dwError = NOERROR;
    }
    __finally {

        DWORD dwTemp = RpcRevertToSelf();   // We don't care about the return here

        if ( hClientToken != NULL ) {
            CloseHandle( hClientToken );
        }
    }

    return( dwError );
}


DWORD
WINAPI
StiApiAccessCheck(
    IN  ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

Arguments:

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

Return Value:

    WINAPI_STATUS - NOERROR or  reason for failure.

--*/
{
    return StiAccessCheck(
                sdApiObject,
                DesiredAccess,
                &ApiObjectMapping
                );
}


BOOL
WINAPI
AdjustSecurityDescriptorForSync(
    HANDLE  hObject
    )
/*++

    Routine Description:

    Arguments:

        None

    Return Value:

--*/
{
    #define SD_SIZE (65536 + SECURITY_DESCRIPTOR_MIN_LENGTH)

    BOOL    fRet;

    BYTE    *bSDbuf = NULL;
    PSECURITY_DESCRIPTOR pProcessSD;
    DWORD          dwSDLengthNeeded;

    PACL           pACL;

    BOOL           bDaclPresent;
    BOOL           bDaclDefaulted;
    ACL_SIZE_INFORMATION AclInfo;
    PACL           pNewACL = NULL;
    DWORD          dwNewACLSize;
    UCHAR          NewSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR psdNewSD=(PSECURITY_DESCRIPTOR)NewSD;
    PVOID          pTempAce;
    UINT           CurrentAceIndex;


    fRet = FALSE;

    bSDbuf = (BYTE*) LocalAlloc(LPTR, SD_SIZE);
    if (!bSDbuf) {
        DBG_ERR(("AdjustSecurityDescriptorForSync, Out of memory!"));
        return FALSE;
    }

    pProcessSD = (PSECURITY_DESCRIPTOR)bSDbuf;

    __try {

        if (!GetKernelObjectSecurity(hObject,
                                     DACL_SECURITY_INFORMATION,
                                     pProcessSD,
                                     SD_SIZE,
                                     (LPDWORD)&dwSDLengthNeeded)) {
            __leave;
       }

       // Initialize new SD
       if(!InitializeSecurityDescriptor(psdNewSD,SECURITY_DESCRIPTOR_REVISION)) {
           fRet = FALSE;
           __leave;
       }

       // Get DACL from SD
       if (!GetSecurityDescriptorDacl(pProcessSD,&bDaclPresent,&pACL,&bDaclDefaulted)) {
           fRet = FALSE;
           __leave;
       }

       // Get file ACL size information
       if(!GetAclInformation(pACL,&AclInfo,sizeof(ACL_SIZE_INFORMATION),AclSizeInformation)) {
           fRet = FALSE;
           __leave;
       }

       // Compute size needed for the new ACL
       dwNewACLSize = AclInfo.AclBytesInUse +
                      sizeof(ACCESS_ALLOWED_ACE) +
                      GetLengthSid(psidLocal) - sizeof(DWORD);

       // Allocate memory for new ACL
       pNewACL = (PACL)LocalAlloc(LPTR, dwNewACLSize);

       if (!pNewACL) {
           fRet = FALSE;
           __leave;
       }

       // Initialize the new ACL
       if(!InitializeAcl(pNewACL, dwNewACLSize, ACL_REVISION2)) {
           fRet = FALSE;
           __leave;
       }

       //  If DACL is present, copy it to a new DACL

       if(bDaclPresent)  {

          if(AclInfo.AceCount) {

             for(CurrentAceIndex = 0;
                 CurrentAceIndex < AclInfo.AceCount;
                 CurrentAceIndex++) {

                if(!GetAce(pACL,CurrentAceIndex,&pTempAce)) {
                    fRet = FALSE;
                    __leave;
                }

                 // Add the ACE to the new ACL

                if(!AddAce(pNewACL, ACL_REVISION, MAXDWORD, pTempAce,((PACE_HEADER)pTempAce)->AceSize)){
                    fRet = FALSE;
                    __leave;
                }
              }
          }

       }

       // Add the access-allowed ACE to the new DACL
       if(!AddAccessAllowedAce(pNewACL,ACL_REVISION2, READ_CONTROL | SYNCHRONIZE,psidLocal)) {
           fRet = FALSE;
           __leave;
       }

       // Set our new DACL to the file SD

       if (!SetSecurityDescriptorDacl(psdNewSD,TRUE,pNewACL,FALSE)) {
           fRet = FALSE;
           __leave;
       }

       if (!SetKernelObjectSecurity(hObject,DACL_SECURITY_INFORMATION,psdNewSD)) {
           fRet = FALSE;
           __leave;
       }

       fRet = TRUE;

   }
   __finally {
       if (bSDbuf) {
           LocalFree(bSDbuf);
           bSDbuf = NULL;
       }

       if (pNewACL) {
           LocalFree((HLOCAL) pNewACL);
           pNewACL = NULL;
       }
   }

   return(fRet);

}

BOOL
WINAPI
InitializeNTSecurity(
    VOID
    )
/*++

    Routine Description:

        Creates and initializes security related data

    Arguments:

        None

    Return Value:

        TRUE if successful
--*/
{

    DWORD   dwError = NOERROR;
    HANDLE  hProcess = NULL;

    DBG_FN(InitializeNTSecurity);

    CreateWellKnownSids();

    //
    // Set proper process and thread security descriptor
    //
    hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,GetCurrentProcessId());

    if (IS_VALID_HANDLE(hProcess)) {
        AdjustSecurityDescriptorForSync(hProcess);
        CloseHandle(hProcess);
    }
    else {
        dwError = GetLastError();
        return FALSE;
    }

    AdjustSecurityDescriptorForSync(GetCurrentThread());

    dwError = CreateSecurityObject( AcesData,
                                NUM_ACES,
                                NULL,
                                NULL,
                                &ApiObjectMapping,
                                &sdApiObject  );

    return (dwError == NOERROR) ? TRUE : FALSE;

}   // InitializeNTSecurity

BOOL
WINAPI
TerminateNTSecurity(
    VOID
    )
/*++

    Routine Description:

        Cleans up security related data

    Arguments:

        None

    Return Value:

        TRUE if successful

--*/
{
    DeleteSecurityObject(&sdApiObject);

    FreeWellKnownSids();

    return TRUE;

} //TerminateNTSecurity





#else

//
// We don't support security on non-NT platforms
//

DWORD
WINAPI
StiApiAccessCheck(
    IN  ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

Arguments:

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

Return Value:

    WINAPI_STATUS - NOERROR or  reason for failure.

--*/
{
    return NOERROR;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\sched.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sched.h

Abstract:

    Scheduling time-based work items

Author:

    Vlad Sadovsky (vlads)   31-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    31-Jan-1997     VladS       created

--*/

# ifndef _SCHED_H_
# define _SCHED_H_

#include <windows.h>

//
//  Scheduler stuff
//

typedef
VOID
(* PFN_SCHED_CALLBACK)(
    VOID * pContext
    );


BOOL
SchedulerInitialize(
    VOID
    );


VOID
SchedulerTerminate(
    VOID
    );


DWORD
ScheduleWorkItem(
    PFN_SCHED_CALLBACK pfnCallback,
    PVOID              pContext,
    DWORD              msecTime,
    HANDLE             hEvent = NULL,
    int                nPriority = THREAD_PRIORITY_NORMAL
    );


BOOL
RemoveWorkItem(
    DWORD  pdwCookie
    );

BOOL
SchedulerSetPauseState(
    BOOL    fNewState
    );

#ifdef DEBUG
VOID
DebugDumpScheduleList(
    LPCTSTR  pszId = NULL
    );
#endif


# endif // _SCHED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\simpletokenreplacement.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/22/2002
 *
 *  @doc    INTERNAL
 *
 *  @module SimpleTokenReplacement.h - Definitions for <c SimpleTokenReplacement> |
 *
 *  This file contains the class definition for <c SimpleTokenReplacement>.
 *
 *****************************************************************************/

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class SimpleTokenReplacement | This class can do simple replacement of tokens in a string
 *  
 *  @comm
 *  The <c SimpleTokenReplacement> class is similar to sprintf.  Basically, 
 *  an input string contains tokens that represent other values, and these
 *  values must be substituted for the tokens (e.g. in sprintf, %s
 *  means that a string value will be put in place of the %s).
 *
 *****************************************************************************/
class SimpleTokenReplacement 
{
//@access Public members
public:

    class TokenValueList;

    // @cmember Constructor
    SimpleTokenReplacement(const CSimpleString &csOriginalString);
    // @cmember Destructor
    virtual ~SimpleTokenReplacement();

    // @cmember Replaces the first instance of a given token in our string (starting from dwStartIndex) with the token value
    int ExpandTokenIntoString(const CSimpleString &csToken,
                              const CSimpleString &csTokenValue,
                              const DWORD         dwStartIndex = 0);
    // @cmember Replaces all instances of all tokens in our string with the token value
    VOID ExpandArrayOfTokensIntoString(TokenValueList &ListOfTokenValuePairs);
    
    // @cmember Returns the resulting string
    CSimpleStringWide getString();

    class TokenValuePair
    {
    public:
        TokenValuePair(const CSimpleString &csToken, const CSimpleString &csValue) :
            m_csToken(csToken),
            m_csValue(csValue)
        {
        }

        virtual ~TokenValuePair()
        {
        }

        CSimpleString getToken()
        {
            return m_csToken;
        }

        CSimpleString getValue()
        {
            return m_csValue;
        }

    private:
        CSimpleString m_csToken;
        CSimpleString m_csValue;
    };

    class TokenValueList
    {
    public:
        TokenValueList()
        {
        }

        virtual ~TokenValueList()
        {
            for (m_Iter = m_ListOfTokenValuePairs.Begin(); m_Iter != m_ListOfTokenValuePairs.End(); ++m_Iter)
            {
                TokenValuePair *pTokenValuePair = *m_Iter;

                if (pTokenValuePair)
                {
                    delete pTokenValuePair;
                }
            }
            m_ListOfTokenValuePairs.Destroy();
        }

        void Add(const CSimpleString &csToken, const CSimpleString &csValue)
        {
            TokenValuePair *pTokenValuePair = new TokenValuePair(csToken, csValue);
            if (pTokenValuePair)
            {
                m_ListOfTokenValuePairs.Prepend(pTokenValuePair);
            }
        }

        TokenValuePair* getFirst()
        {
            m_Iter = m_ListOfTokenValuePairs.Begin();
            if (m_Iter == m_ListOfTokenValuePairs.End())
            {
                return NULL;
            }
            else
            {
                return *m_Iter;
            }
        }

        TokenValuePair* getNext()
        {
            ++m_Iter;
            if (m_Iter == m_ListOfTokenValuePairs.End())
            {
                return NULL;
            }
            else
            {
                return *m_Iter;
            }
        }

    private:
        CSimpleLinkedList<TokenValuePair*>::Iterator  m_Iter;
        CSimpleLinkedList<TokenValuePair*> m_ListOfTokenValuePairs;
    };

//@access Private members
private:

    CSimpleString m_csResult;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\simpletokenreplacement.cpp ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/22/2002
 *
 *  @doc    INTERNAL
 *
 *  @module SimpleTokenReplacement.cpp - Implementation for <c SimpleTokenReplacement> |
 *
 *  This file contains the implmentation for the <c SimpleTokenReplacement> class.
 *
 *****************************************************************************/
#include "precomp.h"

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc   | SimpleTokenReplacement | SimpleTokenReplacement |
 *
 *  We initialize all member variables.  Here, we initialize our resulting string
 *  to be the input string.
 *
 *****************************************************************************/
SimpleTokenReplacement::SimpleTokenReplacement(
    const CSimpleString &csOriginalString) :
        m_csResult(csOriginalString)
{
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc   | SimpleTokenReplacement | ~SimpleTokenReplacement |
 *
 *  Do any cleanup that is not already done.
 *
 *****************************************************************************/
SimpleTokenReplacement::~SimpleTokenReplacement()
{
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  BOOL | SimpleTokenReplacement | ExpandTokenIntoString |
 *
 *  This method inserts a value string in place of a token, similar to how
 *  printf expands:
 *  <nl>CHAR *szMyString = "TokenValue";
 *  <nl>printf("left %s right", szMyString);
 *  <nl>into the string "left TokenValue right".
 *
 *  This method will only substitute the first matching token.
 *
 *  @parm   const CSimpleString& | csToken | 
 *          The token we're looking for
 *  @parm   const CSimpleString& | csTokenValue | 
 *          The value we want to substitute for the token.  It does not have to
 *          be the same size as the token.
 *  @parm   const DWORD | dwStartIndex | 
 *          The character index to start the search from
 *
 *  @rvalue <gt> 0    | 
 *              The token was found and replaced.  The value returned is the
 *              character position following the token value substitution.
 *              This is useful in subsequent searches for the token, 
 *              since we can start the next search from this index.
 *              
 *  @rvalue -1    | 
 *              The token was not found, therefore no replacement occured.
 *              The resulting string is unchanged.
 *****************************************************************************/
int SimpleTokenReplacement::ExpandTokenIntoString(
    const CSimpleString &csToken,
    const CSimpleString &csTokenValue,
    const DWORD         dwStartIndex)
{
    CSimpleString   csExpandedString;
    int             iRet               = -1;

    if (csToken.Length() > 0)
    {
        //
        //  Look for the token start
        //
        int iTokenStart = m_csResult.Find(csToken, dwStartIndex); 

        if (iTokenStart != -1)
        {
            //
            //  We found the token, so let's make the substitution.
            //  The original string looks like this:
            //  lllllllTokenrrrrrrr
            //         |
            //         |
            //         iTokenStart
            //  We want the string to look like this:
            //  lllllllTokenValuerrrrrrr
            //  Therefore, take everything before the Token, add the token value, then
            //  everything following the token i.e.
            //  lllllll + TokenValue + rrrrrrr
            //        |                |
            //        iTokenStart -1   |
            //                         iTokenStart + Token.length()
            //
            csExpandedString =     m_csResult.SubStr(0, iTokenStart);
            csExpandedString +=    csTokenValue;
            csExpandedString +=    m_csResult.SubStr(iTokenStart + csToken.Length(), -1);

            m_csResult = csExpandedString;

            iRet = iTokenStart + csToken.Length();
        }
        else
        {
            iRet = -1;
        }
    }
    return iRet;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  VOID | SimpleTokenReplacement | ExpandArrayOfTokensIntoString |
 *
 *  This method will replace all instances of the input tokens with their
 *  corresponding values.  It basically calls <mf SimpleTokenReplacement::ExpandTokenIntoString>
 *  for each token/value pair in the input list, until -1 is returned (i.e.
 *  no more instances of that token were found).
 *
 *  @parm   TokenValueList& | ListOfTokenValuePairs | 
 *          A list class containing the tokens and values to substitute.
 *
 *****************************************************************************/
VOID SimpleTokenReplacement::ExpandArrayOfTokensIntoString(TokenValueList &ListOfTokenValuePairs)
{
    SimpleTokenReplacement::TokenValuePair *pTokenValuePair;
    //
    //  Loop through the list of Token/Value pairs, and for each element,
    //  replace the token with the value
    //
    for (pTokenValuePair = ListOfTokenValuePairs.getFirst(); 
         pTokenValuePair != NULL; 
         pTokenValuePair = ListOfTokenValuePairs.getNext())
    {
        //
        //  We need to replace the token element number dwIndex with the value
        //  element number dwIndex.  Since ExpandTokenIntoString only replaces the
        //  first occurence, we need to loop through until we have replaced all
        //  occurrences of this token.
        //
        int iSearchIndex = 0;
        while (iSearchIndex != -1)
        {
            iSearchIndex = ExpandTokenIntoString(pTokenValuePair->getToken().String(), pTokenValuePair->getValue(), iSearchIndex);
        }
    }
}


/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleString | SimpleTokenReplacement | getString |
 *
 *  This method returns the resulting string, after any calls to
 *  <mf SimpleTokenReplacement::ExpandTokenIntoString> or
 *  <mf SimpleTokenReplacement::ExpandArrayOfTokensIntoString> have been
 *  made.
 *
 *  @rvalue CSimpleString    | 
 *              The resulting string.
 *****************************************************************************/
CSimpleString SimpleTokenReplacement::getString()
{
    return m_csResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     wiaservc.lib    - WIA Service Helper library for drivers...
#     wiaservc.dll    - WIA Service dll housing WIA and STI server components
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiaservc
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=DYNLINK
DLLENTRY=_DllMainCRTStartup

UMENTRY=winmain

PASS1_PUBLISH= \
    {$(O)\wiaservc.lib=$(DDK_LIB_PATH)\wiaservc.lib}

#
# Compiler environment
#
USE_STATIC_ATL=1

INCLUDES=$(INCLUDES);..\..\rpc;..\..\rpc\$(O);$(PROJECT_ROOT)\inc;$(PROJECT_ROOT)\inc\psutil;$(BASE_INC_PATH);$(BASEDIR)\public\internal\shell\inc;$(BASEDIR)\public\internal\termsrv\inc;$(O)

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_CXX=1

DLLDEF = ..\stisvc.src

SOURCES=    \
        ..\stismsg.mc       \
        ..\wiadevman.cpp    \
        ..\drvwrap.cpp      \
        ..\handler.cpp      \
        ..\wiagitm.cpp      \
        ..\wiasvc.cpp       \
        ..\lockmgr.cpp      \
        ..\fstidev.cpp      \
        ..\wiacfact.cpp     \
        ..\wiatrans.cpp     \
        ..\wiapsc.cpp       \
        ..\ienumwfi.cpp     \
        ..\iitem.cpp        \
        ..\ipropitm.cpp     \
        ..\globals.cpp      \
        ..\stidev.cpp       \
        ..\stiexe.cpp       \
        ..\stisvc.cpp       \
        ..\security.cpp     \
        ..\conn.cpp         \
        ..\monui.cpp        \
        ..\debug.cpp        \
        ..\rpcsupp.cpp      \
        ..\util.cpp         \
        ..\rpcsvr.cpp       \
        ..\wndproc.cpp      \
        ..\sched.cpp        \
        ..\stirpc_server.c  \
        ..\wiamain.cpp      \
        ..\devinfo.cpp      \
        ..\devmgr.cpp       \
        ..\wiaevent.cpp     \
        ..\idrvitem.cpp     \
        ..\ienumitm.cpp     \
        ..\callback.cpp     \
        ..\wiaservc.cpp     \
        ..\helpers.cpp      \
        ..\ienumdc.cpp      \
        ..\wiatree.cpp      \
        ..\wiatiff.cpp      \
        ..\extras.cpp       \
	..\SimpleTokenReplacement.cpp \
        ..\sticfunc.c       \
         ..\stimon.rc

TARGETLIBS= \
        $(TARGETLIBS)                   \
        $(SDK_LIB_PATH)\winmm.lib       \
        $(SDK_LIB_PATH)\userenv.lib     \
        $(SDK_LIB_PATH)\comdlg32.lib    \
        $(SDK_LIB_PATH)\wiaguid.lib     \
        $(WIA_LIB_PATH)\stirt.lib       \
        $(SDK_LIB_PATH)\mscms.lib       \
        $(BASEDIR)\public\internal\shell\lib\*\shguidp.lib     \
        $(BASEDIR)\public\internal\termsrv\lib\*\syslib.lib    \
        $(SDK_LIB_PATH)\winsta.lib \
        $(SDK_LIB_PATH)\version.lib \
#       $(SDK_LIB_PATH)\shell32.lib     \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\sticfunc.h ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       sticfunc.h
*
*  VERSION:     1.0
*
*  DATE:        6 March, 2001
*
*  DESCRIPTION:
*   Header file used for "C" functions defined in sticfunc.c
*
******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

ULONG GetCurrentSessionID();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\stidev.cpp ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

     stidev.cpp

Abstract:

     Code to maintain list of STI devices and poll them

Author:

     Vlad Sadovsky   (VladS)    11-Feb-1997
     Byron Changuion (ByronC)

History:

    12/15/1998  VladS   "List invalidate" support for unknown ADD/REMOVE device messages
    01/08/1999  VladS   Support for PnP interface notifications
    12/08/1999  VladS   Initiate move to complete server environment by using direct calls to the driver
    11/06/2000  ByronC  Enabled JIT loading/unloading of drivers, and inactive enumeration


--*/



//
//  Include Headers
//
#include "precomp.h"
#include "stiexe.h"

#include <rpc.h>
#include <userenv.h>

#include <mmsystem.h>
#include <stilib.h>
#include <validate.h>

#include  "stiusd.h"

#include "device.h"
#include "conn.h"
#include "monui.h"

#include "wiapriv.h"
#include "lockmgr.h"
#include "fstidev.h"

#include <apiutil.h>
#include "enum.h"
#include "wiadevdp.h"

#define PRIVATE_FOR_NO_SERVICE_UI


//
// Local defines and macros
//

//
// Delay hardware initialization till happy time.
//
#define POSTPONE_INIT2


//
// Global service window handle

extern HWND                     g_hStiServiceWindow;
extern SERVICE_STATUS_HANDLE    g_StiServiceStatusHandle;

//
// Validate guid of the event received from USD against the list of device events
//
#define  VALIDATE_EVENT_GUID    1

//
// Static variables
//
//

//
// Linked list of maintained device objects, along with syncronization object
// to guard access to it
//
LIST_ENTRY      g_DeviceListHead;
CRIT_SECT       g_DeviceListSync;
BOOL            g_fDeviceListInitialized = FALSE;

//
// REMOVE:
// Counter of active device objects
//
LONG            g_lTotalActiveDevices = 0;

//
// Value of unique identified assigned to a device object to use as a handle.
//
LONG            g_lGlobalDeviceId;                   // Use temporarily to identify opened device

//
// Connection list , used in connection objects methods, initialize here
//
extern      LIST_ENTRY  g_ConnectionListHead;
extern      LONG        g_lTotalOpenedConnections ;

//
// Static function prototypes
//

EXTERN_C
HANDLE
GetCurrentUserTokenW(
    WCHAR Winsta[],
    DWORD DesiredAccess
      );

BOOL
WINAPI
DumpTokenInfo(
    LPTSTR      pszPrefix,
    HANDLE      hToken
    );

VOID
WINAPI
ScheduleDeviceCallback(
    VOID * pContext
    );

VOID
WINAPI
DelayedDeviceInitCallback(
    VOID * pContext
    );

VOID
WINAPI
AutoLaunchThread(
    LPVOID  lpParameter
    );

VOID
CleanApplicationsListForEvent(
    LPCTSTR         pDeviceName,
    PDEVICEEVENT    pDeviceEvent,
    LPCTSTR         pAppName
    );

DWORD
GetNumRegisteredApps(
    VOID
    );

BOOL
inline
IsWildCardEvent(
    PDEVICEEVENT    pev
    )
/*++

Routine Description:

    Check if given event app list represents wild-card

Arguments:

Return Value:

    TRUE , FALSE

--*/

{
    return !lstrcmp((LPCTSTR)pev->m_EventData,TEXT("*"));
}

//
// Methods for device object
//

ACTIVE_DEVICE::ACTIVE_DEVICE(IN LPCTSTR lpszDeviceName, DEVICE_INFO *pInfo)
{

    DBG_FN("ACTIVE_DEVICE::ACTIVE_DEVICE");

USES_CONVERSION;


    PSTI_DEVICE_INFORMATION pDevInfo;

    HRESULT     hres;

    m_dwSignature = ADEV_SIGNATURE;
    m_fValid = FALSE;

    m_fRefreshedBusOnFailure = FALSE;

    m_hDeviceEvent      = NULL;
    m_pLastLaunchEvent  = NULL;

    m_dwUserDisableNotifications = FALSE;

    m_hDeviceInterface = NULL;
    m_hDeviceNotificationSink = NULL;

    m_fLaunchableEventListNotEmpty = FALSE;
    m_dwSchedulerCookie = 0L;
    m_dwDelayedOpCookie = 0L;

    m_uiPollFailureCount = 0L;
    m_dwLaunchEventTimeExpire = 0;

    m_pLockInfo = NULL;

    m_pFakeStiDevice = NULL;
    m_pRootDrvItem   = NULL;


    InitializeListHead(&m_ListEntry );
    InitializeListHead(&m_ConnectionListHead);
    InitializeListHead(&m_DeviceEventListHead );

    InterlockedIncrement(&g_lTotalActiveDevices);

    SetFlags(0L);

    if (!lpszDeviceName || !*lpszDeviceName) {
        ASSERT(("Trying to create device with invalid name", 0));
        return;
    }

    m_lDeviceId = InterlockedIncrement(&g_lGlobalDeviceId);

    hres = m_DrvWrapper.Initialize();
    if (FAILED(hres)) {
        m_fValid = FALSE;
        DBG_WRN(("ACTIVE_DEVICE::ACTIVE_DEVICE, Could not initialize driver wrapper class, marking this object invalid"));
        return;
    }
    m_DrvWrapper.setDevInfo(pInfo);

    //
    // Initialize device settings
    //
    GetDeviceSettings();

    //
    // object state is valid
    //
    m_fValid = TRUE;

    //
    //  Check whether driver should be loaded on startup
    //

    if (!m_DrvWrapper.getJITLoading()) {

        //  Also note that if the device is not active, we simply do not load
        //  the driver, regardless of whether it's JIT or not.
        //

        if (m_DrvWrapper.getDeviceState() & DEV_STATE_ACTIVE) {
            //
            //  Note that this object is still valid, even if driver cannot be loaded.
            //  For example, driver will not be loaded if device is not plugged in.
            //
            LoadDriver();
        }
    }

    DBG_TRC(("Created active device object for device (%ws)",GetDeviceID()));

    return;

} /* eop constructor */

ACTIVE_DEVICE::~ACTIVE_DEVICE( VOID )
{
    DBG_FN(ACTIVE_DEVICE::~ACTIVE_DEVICE);

    //LIST_ENTRY * pentry;
    STI_CONN    *pConnection = NULL;

    //
    // When we are coming to a destructor it is assumed no current usage by any
    // other thread. We don't need to lock device object therefore.
    //
    //
    if (!IsValid() ) {
        return;
    }

    DBG_TRC(("Removing device object for device(%ws)", GetDeviceID()));

    //
    // Mark device object as being removed
    //
    SetFlags(QueryFlags() | STIMON_AD_FLAG_REMOVING);

    //
    // Stop PnP notifications  if is enabled
    //

    StopPnPNotifications();

    //
    //  Remove any delayed operation from scheduler queue
    //
    if (m_dwDelayedOpCookie) {
        RemoveWorkItem(m_dwDelayedOpCookie);
        m_dwDelayedOpCookie = 0;
    }

    //
    // Unload the driver.
    //
    UnLoadDriver(TRUE);

    //
    //  Destroy Fake Sti Device
    //

    if (m_pFakeStiDevice) {
        delete m_pFakeStiDevice;
        m_pFakeStiDevice = NULL;
    }

    //
    //  Destroy Lock information
    //

    if (m_pLockInfo) {
        LockInfo *pLockInfo = (LockInfo*) m_pLockInfo;
        if (pLockInfo->hDeviceIsFree != NULL) {
            CloseHandle(pLockInfo->hDeviceIsFree);
            pLockInfo->hDeviceIsFree = NULL;
        }
        LocalFree(m_pLockInfo);
        m_pLockInfo = NULL;
    }

    //
    // Delete all connection objects
    //
    {
        while (!IsListEmpty(&m_ConnectionListHead)) {

            pConnection = CONTAINING_RECORD( m_ConnectionListHead.Flink , STI_CONN, m_DeviceListEntry );

            if (pConnection->IsValid()) {
                DestroyDeviceConnection(pConnection->QueryID(),TRUE);
            }
        }
    }

    //
    // Remove from scheduled list if still there
    //
    if (m_ListEntry.Flink &&!IsListEmpty(&m_ListEntry)) {

        ASSERT(("Device is destructed, but still on the list", 0));

        RemoveEntryList(&m_ListEntry);
        InitializeListHead( &m_ListEntry );
    }

    //
    // Close the device's event handle
    //
    if (m_hDeviceEvent) {
        CloseHandle(m_hDeviceEvent);
        m_hDeviceEvent = NULL;
    }

    m_dwSignature = ADEV_SIGNATURE_FREE;

    //
    // We are gone completely
    //
    InterlockedDecrement(&g_lTotalActiveDevices);
} /* eop destructor */

//
// IUnknown methods. Used only for reference counting
//
STDMETHODIMP
ACTIVE_DEVICE::QueryInterface( REFIID riid, LPVOID * ppvObj)
{
    return E_FAIL;
}

STDMETHODIMP_(ULONG)
ACTIVE_DEVICE::AddRef( void)
{
    ::InterlockedIncrement(&m_cRef);

    //DBG_TRC(("Device(%x)::AddRef  RefCount=%d "),this,m_cRef);

    return m_cRef;
}

STDMETHODIMP_(ULONG)
ACTIVE_DEVICE::Release( void)
{
    LONG    cNew;

    //DBG_TRC(("Device(%x)::Release (before)  RefCount=%d "),this,m_cRef);

    if(!(cNew = ::InterlockedDecrement(&m_cRef))) {
        delete this;
    }

    return cNew;

}

VOID
ACTIVE_DEVICE::
GetDeviceSettings(
    VOID
    )
/*++

Routine Description:

    Get settings for the device being opened , for future use.  This routine also marks whether
    the driver should be loaded on startup, or JIT

Arguments:

Return Value:

--*/
{
    DBG_FN(ACTIVE_DEVICE::GetDeviceSettings);

    //
    // Build device event list
    //
    m_fLaunchableEventListNotEmpty = BuildEventList();
    if (!m_fLaunchableEventListNotEmpty) {
        DBG_TRC(("ACTIVE_DEVICE::GetDeviceSettings,  Device registry indicates no events for %ws ", GetDeviceID()));
    }


    //
    // Get value of poll timeout if device is polled
    //
    m_dwPollingInterval = m_DrvWrapper.getPollTimeout();
    if (m_dwPollingInterval < STIDEV_MIN_POLL_TIME) {
        m_dwPollingInterval = g_uiDefaultPollTimeout;
    }

    HRESULT hr      = S_OK;
    DWORD   dwType  = REG_DWORD;
    DWORD   dwSize  = sizeof(m_dwUserDisableNotifications);

    //
    // Always read this value from the registry, just in case user changed it.
    //
    hr = g_pDevMan->GetDeviceValue(this,
                                   STI_DEVICE_VALUE_DISABLE_NOTIFICATIONS,
                                   &dwType,
                                   (BYTE*) &m_dwUserDisableNotifications,
                                   &dwSize);

    /*  TDB:  When we can load normal drivers JIT
    //
    //  Decide whether driver should be loaded on Startup or JIT.  Our rules for
    //  determining this are:
    //  1.  If devices is not capable of generating ACTION events, then load it JIT
    //  2.  If notifications for this device are disabled, then load JIT
    //  3.  In all other cases, load on startup.
    //

    if (!m_fLaunchableEventListNotEmpty || m_dwUserDisableNotifications) {
        m_DrvWrapper.setJITLoading(TRUE);
        DBG_TRC(("ACTIVE_DEVICE::GetDeviceSettings, Driver will be loaded JIT"));
    } else {
        m_DrvWrapper.setJITLoading(FALSE);
        DBG_TRC(("ACTIVE_DEVICE::GetDeviceSettings, Driver will be loaded on startup"));
    }
    */

    //
    //  Decide whether driver should be loaded on Startup or JIT.  Until we enable for
    //  normal drivers like the comments above, our descision is based on:
    //  1)  Is this a volume device?  If so, then load JIT
    //

    if (m_DrvWrapper.getInternalType() & INTERNAL_DEV_TYPE_VOL) {
        m_DrvWrapper.setJITLoading(TRUE);
        DBG_TRC(("ACTIVE_DEVICE::GetDeviceSettings, Driver will be loaded JIT"));
    } else {
        m_DrvWrapper.setJITLoading(FALSE);
        DBG_TRC(("ACTIVE_DEVICE::GetDeviceSettings, Driver will be loaded on startup"));
    }

}

BOOL
ACTIVE_DEVICE::
LoadDriver(
    BOOL bReReadDevInfo /*= FALSE*/
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

USES_CONVERSION;

    HRESULT         hres            = E_FAIL;
    DEVICE_INFO     *pDeviceInfo    = NULL;

    //
    //  We don't want to re-load the driver if it's already loaded.
    //
    if (m_DrvWrapper.IsDriverLoaded()) {
        return TRUE;
    }

    if (m_DrvWrapper.IsPlugged()) {

        HKEY hKeyDevice = g_pDevMan->GetDeviceHKey(this, NULL);

        //
        //  If asked, re-read the device information.  The easiest way to do this
        //  is to re-create the Dev. Info. structure.
        //
        if (bReReadDevInfo) {

            pDeviceInfo = m_DrvWrapper.getDevInfo();
            if (pDeviceInfo) {
                //
                //  This only applies to non-volume devices.  Volume devices' dev. info.
                //  stucts are always re-created on enumeration, so are always current.
                //
                if (!(pDeviceInfo->dwInternalType & INTERNAL_DEV_TYPE_VOL)) {

                    DEVICE_INFO *pNewDeviceInfo = NULL;
                    //
                    //  When calling CreateDevInfoFromHKey, make sure that the 
                    //  SP_DEVICE_INTERFACE_DATA parameter is NULL for
                    //  DevNode devices and non-NULL for interface devices.
                    //
                    SP_DEVICE_INTERFACE_DATA *pspDevInterfaceData = NULL;
                    if (pDeviceInfo->dwInternalType & INTERNAL_DEV_TYPE_INTERFACE) {
                        pspDevInterfaceData = &(pDeviceInfo->spDevInterfaceData);    
                    }


                    pNewDeviceInfo = CreateDevInfoFromHKey(hKeyDevice, 
                                                           pDeviceInfo->dwDeviceState,
                                                           &(pDeviceInfo->spDevInfoData),
                                                           pspDevInterfaceData);
                    //
                    //  If we successfully created the new one, destroy the old one
                    //  and set the new one as the DevInfo for this device.
                    //  Otherwise, leave the old one intact.
                    //
                    if (pNewDeviceInfo) {
                        DestroyDevInfo(pDeviceInfo);
                        m_DrvWrapper.setDevInfo(pNewDeviceInfo);
                    }
                }
            }
        }

        //
        //  Get the device information pointer here, in case it was updated above.
        //
        pDeviceInfo = m_DrvWrapper.getDevInfo();
        if (!pDeviceInfo) {
            DBG_ERR(("ACTIVE_DEVICE::LoadDriver, Cannot function with NULL Device Info.!"));
            return FALSE;
        }

        DBG_TRC(("ACTIVE_DEVICE::LoadDriver, Device is plugged: about to load driver"));
        hres = m_DrvWrapper.LoadInitDriver(hKeyDevice);

        if (SUCCEEDED(hres)) {

            //
            // For those devices who may modify their Friendly Name (e.g. PTP),
            //  we refresh their settings here.  Notice this only applies to
            //  "real", non-interface devices.
            //
            if (m_DrvWrapper.getInternalType() & INTERNAL_DEV_TYPE_REAL) {

                if (pDeviceInfo && hKeyDevice) {
                    RefreshDevInfoFromHKey(pDeviceInfo,
                                           hKeyDevice,
                                           pDeviceInfo->dwDeviceState,
                                           &(pDeviceInfo->spDevInfoData),
                                           &(pDeviceInfo->spDevInterfaceData));

                    //
                    //  Also update the Friendly Name in device manager for
                    //  non-interface (i.e. DevNode) devices.
                    //  Note: Only do this if the Friendly name is non-NULL,
                    //  not empty, and doesn't already exist in registry.
                    //
                    if (!(m_DrvWrapper.getInternalType() & INTERNAL_DEV_TYPE_INTERFACE)) {

                        //
                        //  Check whether the friendly name exists
                        //
                        DWORD   dwSize = 0;
                        CM_Get_DevNode_Registry_Property(pDeviceInfo->spDevInfoData.DevInst,
                                                         CM_DRP_FRIENDLYNAME,
                                                         NULL,
                                                         NULL,
                                                         &dwSize,
                                                         0);
                        if (dwSize == 0) {

                            //
                            //  Check the our LocalName string is non-NULL and not empty
                            //
                            if (pDeviceInfo->wszLocalName && lstrlenW(pDeviceInfo->wszLocalName)) {
                                CM_Set_DevNode_Registry_PropertyW(pDeviceInfo->spDevInfoData.DevInst,
                                                                  CM_DRP_FRIENDLYNAME,
                                                                  pDeviceInfo->wszLocalName,
                                                                  (lstrlenW(pDeviceInfo->wszLocalName) + 1) * sizeof(WCHAR),
                                                                  0);
                            }
                        }
                    }

                }
            }
            

            //
            // Verify device capabilities require polling
            //

            if (m_DrvWrapper.getGenericCaps() & STI_GENCAP_NOTIFICATIONS) {

                //
                // Mark device object as receiving USD Notifications
                //
                SetFlags(QueryFlags() | STIMON_AD_FLAG_NOTIFY_CAPABLE);

                //
                // If timeout polling required, mark it.
                //
                if (m_DrvWrapper.getGenericCaps() & STI_GENCAP_POLLING_NEEDED) {
                    DBG_TRC(("ACTIVE_DEVICE::LoadDriver, Polling device"));
                    SetFlags(QueryFlags() | STIMON_AD_FLAG_POLLING);
                }
                else {
                    DBG_TRC(("ACTIVE_DEVICE::LoadDriver, Device is marked for async events"));
                    //
                    // No polling required - USD should support async events
                    //
                    if (!m_hDeviceEvent) {
                        m_hDeviceEvent = CreateEvent( NULL,     // Security
                                                      TRUE,     // Manual reset
                                                      FALSE,    // No signalled initially
                                                      NULL );   // Name
                    }

                    if (!m_hDeviceEvent) {
                        ASSERT(("Failed to create event for notifications ", 0));
                    }
                    m_dwPollingInterval = INFINITE;
                }
            }

            //
            // Set poll interval and initiate poll
            //

            SetPollingInterval(m_dwPollingInterval);

            DBG_TRC(("Polling interval is set to %d sec on device (%ws)", (m_dwPollingInterval == INFINITE) ? -1 : (m_dwPollingInterval/1000), GetDeviceID()));

            //
            // Schedule EnableDeviceNotifications() and device reset
            //
        #ifdef POSTPONE_INIT2

            SetFlags(QueryFlags() | STIMON_AD_FLAG_DELAYED_INIT);

            //
            // Constructor of active device object is called with global list critical section taken
            // so we want to get out of here as soon as possible
            //
            m_dwDelayedOpCookie = ScheduleWorkItem((PFN_SCHED_CALLBACK) DelayedDeviceInitCallback,
                                                   this,
                                                   STIDEV_DELAYED_INTIT_TIME,
                                                   NULL);
            if (!m_dwDelayedOpCookie) {

                DBG_ERR(("Could not schedule EnableNotificationsCallback"));
            }
        #else
            {
                TAKE_ACTIVE_DEVICE _t(this);

                EnableDeviceNotifications();
            }
        #endif

            if (!m_pFakeStiDevice) {
                //
                // Set the Fake Sti Device for WIA clients
                //

                m_pFakeStiDevice = new FakeStiDevice();
                if (m_pFakeStiDevice) {
                    //
                    //  Note that this form of init cannot fail
                    //
                    m_pFakeStiDevice->Init(this);
                }
            }
        }

        if (IsValidHANDLE(hKeyDevice)) {
            RegCloseKey(hKeyDevice);
            hKeyDevice = NULL;
        }

        return TRUE;
    } else {
        DBG_TRC(("ACTIVE_DEVICE::LoadDriver, Device is unplugged: not loading driver"));
    }

    return FALSE;
}

BOOL
ACTIVE_DEVICE::
UnLoadDriver(
    BOOL bForceUnLoad
    )
/*++

Routine Description:


Arguments:

Return Value:

--*/
{
    DBG_FN(ACTIVE_DEVICE::UnloadSTIDevice);

    BOOL bUnLoadDriver = FALSE;

    //
    //  Decide whether driver should be unloaded.  If bForceUnLoad == TRUE,
    //  we always unload.
    //

    if (bForceUnLoad) {
        bUnLoadDriver = TRUE;
    } else {
        //
        //  If this device is JIT, and there are no pending connections,
        //  unload it.
        //

        if (m_DrvWrapper.getJITLoading() && !m_DrvWrapper.getWiaClientCount()) {
            bUnLoadDriver = TRUE;
        }
    }

    if (bUnLoadDriver) {

        //
        //  Disable device notifications
        //
        DisableDeviceNotifications();

        HRESULT hr = S_OK;

        if (m_DrvWrapper.IsDriverLoaded()) {
            __try {
        
                hr = g_pStiLockMgr->RequestLock(this, INFINITE);  // Should this be infinite?????
        
                //
                //  Make sure we call drvUninitializeWia on any connected App. Items
                //
                if (m_pRootDrvItem) {
                    m_pRootDrvItem->CallDrvUninitializeForAppItems(this);
                    m_pRootDrvItem = NULL;
                }
            }
            __finally
            {
                //
                //  Call USD's unlock, before unloading driver.  Notice that we 
                //  don't call g_pStiLockMgr->RequestUnlock(..).  This is to avoid
                //  a race condition between us calling RequestUnlock and 
                //  unloading the driver.  This way, the device is always locked
                //  for mutally exclusive acess, including when we call 
                //  m_DrvWrapper.UnLoadDriver().  Our subsequent call to 
                //  g_pStiLockMgr->ClearLockInfo(..) then clears the service
                //  lock we just acquired.
                //
                if (SUCCEEDED(hr)) {
                    hr = g_pStiLockMgr->UnlockDevice(this);
                }
            }
            //
            //  Unload the driver.
            //
            m_DrvWrapper.UnLoadDriver();

            //
            //  Clear the USD lock information
            //
            if (m_pLockInfo) {
                g_pStiLockMgr->ClearLockInfo((LockInfo*) m_pLockInfo);
            }
        }
    }

    return TRUE;
}

BOOL
ACTIVE_DEVICE::
BuildEventList(
    VOID
    )
/*++

Routine Description:

    Loads list of device notifications, which can activate application launch
    If device generates notification, which is not in this list, no app will start

Arguments:

Return Value:

    TRUE if successfully built event list with at least one launchable application

    FALSE on error or if there are no applications to be launched for any events on this device

--*/
{

    DEVICEEVENT * pDeviceEvent;

    TCHAR    szTempString[MAX_PATH];
    DWORD   dwSubkeyIndex = 0;

    BOOL    fRet = FALSE;

    UINT    cEventsRead = 0;
    UINT    cEventsLaunchables = 0;

    HKEY    hDevKey = NULL;
    HRESULT hr      = S_OK;

    //
    // Get the device key
    //

    hDevKey = g_pDevMan->GetDeviceHKey(this, NULL);
    if (!hDevKey) {
        DBG_WRN(("Could not open device key for (%ws) hr = 0x%X.",GetDeviceID(), hr));
        return FALSE;
    }

    //
    // Open the events sub-key
    //

    RegEntry        reEventsList(EVENTS,hDevKey);
    StiCString      strEventSubKeyName;

    strEventSubKeyName.GetBufferSetLength(MAX_PATH);
    dwSubkeyIndex = 0;

    //
    // Clear existing list first
    //
    DestroyEventList();

    while (reEventsList.EnumSubKey(dwSubkeyIndex++,&strEventSubKeyName)) {

        //
        // Open new key for individual event
        //
        RegEntry    reEvent((LPCTSTR)strEventSubKeyName,reEventsList.GetKey());
        if (!reEvent.IsValid()) {
            // ASSERT
            continue;
        }

        //
        // Allocate and fill event structure
        //
        pDeviceEvent = new DEVICEEVENT;
        if (!pDeviceEvent) {
            // ASSERT
            break;
        }

       cEventsRead++;

        //
        // Read and parse event guid
        //
        pDeviceEvent->m_EventGuid = GUID_NULL;
        pDeviceEvent->m_EventSubKey.CopyString(strEventSubKeyName);

        *szTempString = TEXT('\0');
        reEvent.GetString(TEXT("GUID"),szTempString,sizeof(szTempString));

        if (!IS_EMPTY_STRING(szTempString)) {
            ParseGUID(&pDeviceEvent->m_EventGuid,szTempString);
        }

        //
        // Get event descriptive name
        //
        *szTempString = TEXT('\0');
        reEvent.GetString(TEXT(""),szTempString,sizeof(szTempString));

        pDeviceEvent->m_EventName.CopyString(szTempString);

        //
        // Get applications list
        //
        *szTempString = TEXT('\0');
        reEvent.GetString(TEXT("LaunchApplications"),szTempString,sizeof(szTempString));

        pDeviceEvent->m_EventData.CopyString(szTempString);

        //
        // Mark launchability of the event
        //

        pDeviceEvent->m_fLaunchable = (BOOL)reEvent.GetNumber(TEXT("Launchable"),(long)TRUE);

        if (pDeviceEvent->m_fLaunchable && (pDeviceEvent->m_EventData.GetLength()!= 0 )) {
           cEventsLaunchables++;
            fRet = TRUE;
        }

        //
        // Finally insert filled structure into the list
        //
        InsertTailList(&m_DeviceEventListHead, &(pDeviceEvent->m_ListEntry));

    } // end while

    if (hDevKey) {
        RegCloseKey(hDevKey);
        hDevKey = NULL;
    }
    DBG_TRC(("Reading event list for device:%ws Total:%d Launchable:%d ",
                 GetDeviceID(),
                 cEventsRead,
                 cEventsLaunchables));

    return fRet;

} // endproc BuildEventList

BOOL
ACTIVE_DEVICE::
DestroyEventList(
    VOID
    )
{
    //
    // Destroy event list
    //
    LIST_ENTRY * pentry;
    DEVICEEVENT * pDeviceEvent;

    while (!IsListEmpty(&m_DeviceEventListHead)) {

        pentry = m_DeviceEventListHead.Flink;

        //
        // Remove from the list ( reset list entry )
        //
        RemoveHeadList(&m_DeviceEventListHead);
        InitializeListHead( pentry );

        pDeviceEvent = CONTAINING_RECORD( pentry, DEVICEEVENT,m_ListEntry );

        delete pDeviceEvent;
    }

    return TRUE;
}

BOOL
ACTIVE_DEVICE::DoPoll(VOID)
{
USES_CONVERSION;

    HRESULT     hres;
    BOOL        fDeviceEventDetected = FALSE;
    STINOTIFY       sNotify;

    //
    // verify state of the device object
    //
    if (!IsValid() || !m_DrvWrapper.IsDriverLoaded() ||
        !(QueryFlags() & (STIMON_AD_FLAG_POLLING | STIMON_AD_FLAG_NOTIFY_RUNNING))) {
        DBG_WRN(("Polling on non-activated  or non-polled device."));
        return FALSE;
    }

    m_dwSchedulerCookie = 0;

    //
    // Lock device to get status information
    //
    {
        hres = g_pStiLockMgr->RequestLock(this, STIMON_AD_DEFAULT_WAIT_LOCK);

        if (SUCCEEDED(hres) ) {

            ZeroMemory(&m_DevStatus,sizeof(m_DevStatus));
            m_DevStatus.StatusMask = STI_DEVSTATUS_EVENTS_STATE;

            DBG_TRC(("Polling called on device:%ws", GetDeviceID()));

            hres = m_DrvWrapper.STI_GetStatus(&m_DevStatus);
            if (SUCCEEDED(hres) ) {
                //
                // If event detected, ask USD for additional information and
                // unlock device
                //
                if (m_DevStatus.dwEventHandlingState & STI_EVENTHANDLING_PENDING ) {

                    fDeviceEventDetected = TRUE;

                    if (!FillEventFromUSD(&sNotify)) {
                        DBG_WRN(("Device driver claimed presence of notification, but failed to fill notification block"));
                    }
                }

                // Reset failure skip count
                m_uiPollFailureCount = STIDEV_POLL_FAILURE_REPORT_COUNT;

            }
            else {

                //
                // Report error not on each polling attempt.
                //
                if (!m_uiPollFailureCount) {

                    DBG_ERR(("Device (%ws) failed get status for events. HResult=(%x)", GetDeviceID(), hres));
                    m_uiPollFailureCount = STIDEV_POLL_FAILURE_REPORT_COUNT;

                    //
                    // Too many subsequent polling failures - time to refresh device parent.
                    // Do it only once and only if failures had been due to device absence
                    //
                    if (hres == STIERR_DEVICE_NOTREADY)  {

                        //
                        // Stop polling on inactive device.
                        // Nb: there is no way currently to restart polling
                        //
                        DBG_TRC(("Device not ready ,stopping notifications for device (%ws)",GetDeviceID()));

                        //
                        // First turn off running flag
                        //
                        m_dwFlags &= ~STIMON_AD_FLAG_NOTIFY_RUNNING;


                        if (g_fRefreshDeviceControllerOnFailures &&
                            !m_fRefreshedBusOnFailure ) {

                            DBG_WRN(("Too many polling failures , refreshing parent object for the device "));
                            // TDB:
                            //hres = g_pSti->RefreshDeviceBus(T2W((LPTSTR)GetDeviceID()));

                            m_fRefreshedBusOnFailure = TRUE;
                        }
                    }
                }

                m_uiPollFailureCount--;
            }

            hres = g_pStiLockMgr->RequestUnlock(this);
            if(FAILED(hres)) {
                DBG_ERR(("Failed to unlock device, hr = %x", hres));
            }
        }
        else {
            DBG_ERR(("Device locked , could not get status . HResult=(%x)",hres));
        }

    }   /* end block on GetLockMgrDevice */

    //
    // If successfully detected device event and filled notification information -
    // proceed to processing method
    //
    if (fDeviceEventDetected) {
        ProcessEvent(&sNotify);
    }

    //
    // Schedule next poll, unless notifications disabled
    //

    if (m_dwFlags & STIMON_AD_FLAG_NOTIFY_RUNNING) {
        m_dwSchedulerCookie = ::ScheduleWorkItem(
                                            (PFN_SCHED_CALLBACK) ScheduleDeviceCallback,
                                            (LPVOID)this,
                                            m_dwPollingInterval,
                                            m_hDeviceEvent );

        if ( !m_dwSchedulerCookie ){
            ASSERT(("Polling routine could not schedule work item", 0));
            return FALSE;
        }
    }

    return TRUE;

} /* eop DoPoll */

BOOL
ACTIVE_DEVICE::DoAsyncEvent(VOID)
{

    HRESULT     hres;
    BOOL        fRet;

    BOOL        fDeviceEventDetected = FALSE;
    STINOTIFY   sNotify;

    DBG_FN(ACTIVE_DEVICE::DoAsyncEvent);
    //
    // verify state of the device object
    //
    if (!IsValid() || !m_DrvWrapper.IsDriverLoaded() ||
        !(QueryFlags() & STIMON_AD_FLAG_NOTIFY_RUNNING)) {
        DBG_WRN(("Async event  on non-activated device."));
        return FALSE;
    }

    m_dwSchedulerCookie = 0;

    //
    // Lock device to get event information
    //
    hres = g_pStiLockMgr->RequestLock(this, STIMON_AD_DEFAULT_WAIT_LOCK);
    if (SUCCEEDED(hres) ) {
        //
        // If event detected, ask USD for additional information and
        // unlock device
        //
        if (!FillEventFromUSD(&sNotify)) {
            DBG_WRN(("Device driver claimed presence of notification, but failed to fill notification block "));
        }

        g_pStiLockMgr->RequestUnlock(this);

        fDeviceEventDetected = TRUE;

    }
    else {
        DBG_TRC(("Device locked , could not get status . HResult=(%x)",hres));
    }

    //
    // If successfully detected device event and filled notification information -
    // proceed to processing method
    //
    if (fDeviceEventDetected) {
        ProcessEvent(&sNotify);
    }

    //
    // Schedule next event  unless polling disabled
    //
    if (m_dwFlags & STIMON_AD_FLAG_NOTIFY_RUNNING) {

        fRet = FALSE;

        if (m_hDeviceEvent) {
            ::ResetEvent(m_hDeviceEvent);
            fRet = SetHandleForUSD(m_hDeviceEvent);
        }

        if (!fRet) {
            DBG_ERR(("USD refused to take event handle , or event was not created "));
            ReportError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        m_dwSchedulerCookie = ::ScheduleWorkItem(
                                            (PFN_SCHED_CALLBACK) ScheduleDeviceCallback,
                                            (LPVOID)this,
                                            m_dwPollingInterval,
                                            m_hDeviceEvent );
        if ( !m_dwSchedulerCookie ){
            ASSERT(("Async routine could not schedule work item", 0));
            return FALSE;
        }
    }

    return TRUE;

} /* eop DoAsyncEvent */

DWORD
ACTIVE_DEVICE::
DisableDeviceNotifications(
    VOID
)
{
    //
    // First turn off running and enable flags
    //
    DBG_TRC(("Request to disable notifications for device (%S)",GetDeviceID()));

    m_dwFlags &= ~STIMON_AD_FLAG_NOTIFY_ENABLED;

    StopNotifications();

    return TRUE;

}

DWORD
ACTIVE_DEVICE::
EnableDeviceNotifications(
    VOID
    )
{

    DWORD   dwRet = FALSE;

    m_dwFlags |= STIMON_AD_FLAG_NOTIFY_ENABLED;

    DBG_TRC(("Request to enable notifications for device (%S)",GetDeviceID()));

    if (NotificationsNeeded()) {

        dwRet = StartRunningNotifications();
    }
    else {
        DBG_TRC(("No notifications support needed for this device (%S)",GetDeviceID()));
    }

    return dwRet;
}

DWORD
ACTIVE_DEVICE::
StopNotifications(
    VOID
)
{
    BOOL    fNotificationsOn = FALSE;

    fNotificationsOn = (m_dwFlags & STIMON_AD_FLAG_NOTIFY_RUNNING ) ? TRUE : FALSE;

    DBG_TRC(("Stopping notifications for device (%S)",GetDeviceID()));

    //
    // First turn off running and enable flags
    //
    m_dwFlags &= ~STIMON_AD_FLAG_NOTIFY_RUNNING;

    //
    // Remove from scheduler list
    //
    if (fNotificationsOn || m_dwSchedulerCookie) {
        RemoveWorkItem(m_dwSchedulerCookie);
        m_dwSchedulerCookie = NULL;
    }

    //
    // Clear event handle for USD
    //
    if ((m_DrvWrapper.IsDriverLoaded()) &&
        (m_dwFlags & STIMON_AD_FLAG_NOTIFY_CAPABLE ) &&
        !(m_dwFlags & STIMON_AD_FLAG_POLLING) ) {
        SetHandleForUSD(NULL);
    }

    return TRUE;

}

DWORD
ACTIVE_DEVICE::
StartRunningNotifications(
    VOID
    )
{

    BOOL    fRet = FALSE;

    if (!(m_dwFlags & STIMON_AD_FLAG_NOTIFY_CAPABLE )) {
        // Device is not capable of notifications
        DBG_WRN(("Trying to run notifications on non capable device "));
        return FALSE;
    }

    //
    // If not enabled for notifications - return
    //
    if ( !(m_dwFlags & STIMON_AD_FLAG_NOTIFY_ENABLED )) {
        DBG_TRC(("Trying to run notifications on device (%S), disabled for notifications", GetDeviceID()));
        ReportError(ERROR_SERVICE_DISABLED);
        return FALSE;
    }

    if ( m_dwFlags & STIMON_AD_FLAG_NOTIFY_RUNNING ) {
        ASSERT(("Notifications enabled, but cookie ==0", m_dwSchedulerCookie));
        return TRUE;
    }

    if (!IsDeviceAvailable()) {
        ReportError(ERROR_NOT_READY);
        return FALSE;
    }

    //
    // We are starting receiving notifications first time, flush events from USD
    //
    FlushDeviceNotifications();

    //
    // Set event handle for USD if it is capable of async notifications
    //
    if ( (m_dwFlags & STIMON_AD_FLAG_NOTIFY_CAPABLE ) &&
        !(m_dwFlags & STIMON_AD_FLAG_POLLING) ) {

        fRet = FALSE;

        if (m_hDeviceEvent) {
            ::ResetEvent(m_hDeviceEvent);
            fRet = SetHandleForUSD(m_hDeviceEvent);
        }

        if (!fRet) {
            DBG_ERR(("USD refused to take event handle , or event was not created "));
            ReportError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    fRet =  FALSE;

    //
    // Starting accepting notifications - mark refresh flag as not done yet
    //
    m_fRefreshedBusOnFailure = FALSE;

    //
    // Schedule event processing for this device
    //
    m_dwSchedulerCookie = ::ScheduleWorkItem(
                                        (PFN_SCHED_CALLBACK) ScheduleDeviceCallback,
                                        (LPVOID)this,
                                        m_dwPollingInterval,
                                        m_hDeviceEvent );

    if ( m_dwSchedulerCookie ){

        m_dwFlags |= STIMON_AD_FLAG_NOTIFY_RUNNING;

        DBG_TRC(("Started receiving notifications for device (%S)",GetDeviceID()));

        fRet = TRUE;
    }

    return fRet;

} /* eop StartRunningNotifications */

BOOL
ACTIVE_DEVICE::
FlushDeviceNotifications(
        VOID
        )
/*++

Routine Description:

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    HRESULT hres;
    STINOTIFY       sNotify;


    //
    // verify state of the device object
    //
    if (!IsValid() || m_DrvWrapper.IsDriverLoaded() ||
        !(QueryFlags() & (STIMON_AD_FLAG_NOTIFY_ENABLED ))) {
        return FALSE;
    }

    //
    // Lock device to get status information
    //
    hres = g_pStiLockMgr->RequestLock(this, STIMON_AD_DEFAULT_WAIT_LOCK);
    if (SUCCEEDED(hres) ) {

        ZeroMemory(&m_DevStatus,sizeof(m_DevStatus));
        m_DevStatus.StatusMask = STI_DEVSTATUS_EVENTS_STATE;

        hres = m_DrvWrapper.STI_GetStatus(&m_DevStatus);
        if (SUCCEEDED(hres) ) {
            //
            // If event detected, ask USD for additional information and
            // unlock device
            //
            if (m_DevStatus.dwEventHandlingState & STI_EVENTHANDLING_PENDING ) {
                FillEventFromUSD(&sNotify);
            }
        }
        g_pStiLockMgr->RequestUnlock(this);
    }

    return TRUE;

} /* eop FlushDeviceNotifications */


BOOL
ACTIVE_DEVICE::
ProcessEvent(
    STINOTIFY   *psNotify,
    BOOL        fForceLaunch,   // = FALSE
    LPCTSTR     pszAppName      // =NULL
    )
/*++

Routine Description:

    Is invoked when monitored device is issuing a device notification
    ( either by poll , or by signalling handle).

    USD is called to obtain notification parameters.
    If device is already connected to, notification is passed to connection, currently in
    focus.
    If device is not connected to and notification is in the list of "launchable" , attempt is made
    to launch application, which will acquire image from the device

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{

    PDEVICEEVENT    pDeviceEvent = NULL;

    DWORD           dwCurrentTickCount;

    HANDLE          hThread;
    DWORD           dwThread;

    BOOL            fRet;

    STIMONWPRINTF(TEXT("Processing device notification for device (%s)"),GetDeviceID());

    //
    // Notify WIA of event if this is a valid WIA device event.
    //

    if (m_DrvWrapper.IsWiaDevice()  &&
        psNotify) {

        HRESULT hr;

        hr = NotifyWiaDeviceEvent(GetDeviceID(),
                                  &psNotify->guidNotificationCode,
                                  &psNotify->abNotificationData[0],
                                  0,
                                  g_dwMessagePumpThreadId);
        if (hr == S_FALSE) {

            //
            // WIA has handled this event and doesn't want to
            // chain the event to STI for further processing.
            //

            return TRUE;
        }
    }

    if (!fForceLaunch ) {
        //
        // If there is at least one connection to this device, pass notification
        // information to connection in focus
        //
        if (IsConnectedTo() ) {

            STIMONWPRINTF(TEXT("Notification delivered to subscriber"));

            STI_CONN    *pConnection = NULL;
            LIST_ENTRY *pentry;

            pentry = m_ConnectionListHead.Flink;
            pConnection = CONTAINING_RECORD( pentry, STI_CONN,m_DeviceListEntry );

            pConnection->QueueNotificationToProcess(psNotify);

            return TRUE;
        }
    }

    //
    // Nobody connected to this device, so we need to see if associated
    // application can be launched

    // STIMONWPRINTF(TEXT("ProcessEvent received device notification, requiring auto launch."));

    //
    // Validate event against list of launchable events, associated with device object.
    // If user explicitly disabled "events" for this device - don't launch anything
    //

    if (m_dwUserDisableNotifications || IsListEmpty(&m_DeviceEventListHead)) {
        // No active launchable events , associated with this device
        STIMONWPRINTF(TEXT("User disabled events or event list is empty for the device, ignoring notification"));
        return FALSE;
    }

    LIST_ENTRY * pentry;
    LIST_ENTRY * pentryNext;

    for ( pentry  = m_DeviceEventListHead.Flink;
          pentry != &m_DeviceEventListHead;
          pentry  = pentryNext ) {

        pentryNext = pentry->Flink;
        pDeviceEvent = CONTAINING_RECORD( pentry,DEVICEEVENT ,m_ListEntry );

        if(IsEqualIID(pDeviceEvent->m_EventGuid,psNotify->guidNotificationCode)) {
            break;
        }
        else {
            pDeviceEvent = NULL;
        }
    }

    if (!pDeviceEvent || !pDeviceEvent->m_fLaunchable) {
        // Not launchable event - don't do anything
        DBG_TRC(("Did not recognize launchable event or event list is empty, notification ignored."));

        #ifdef VALIDATE_EVENT_GUID
        return FALSE;
        #else
        pDeviceEvent = CONTAINING_RECORD( m_DeviceEventListHead.Flink,DEVICEEVENT ,m_ListEntry );
        DBG_ERR(("Using first event in the list for interim testing"));
        #endif
    }

    //
    // If we are already in after launch period - skip event
    //
    if (m_dwFlags & STIMON_AD_FLAG_LAUNCH_PENDING) {

       dwCurrentTickCount = ::GetTickCount();

       if ( dwCurrentTickCount < m_dwLaunchEventTimeExpire ) {
           DBG_TRC(("Waiting since last event had not expired yet, notification ignored"));
           ReportError(ERROR_NOT_READY);
           return FALSE;
       }

    }

    //
    // Launching application may cause unpredictable delays . We don't want to hold
    // main event processing thread , so kick in another dedicated thread to control
    // process spawning. Before device lock is released, it is marked as waiting for pending
    // launch, to prevent laucnchable events in quick succession from autolaunching
    //

    m_dwFlags |= STIMON_AD_FLAG_LAUNCH_PENDING;
    //
    // Set waiting period expiration limit, so we know when to start paying attention to
    // launch events again
    //
    m_dwLaunchEventTimeExpire = ::GetTickCount() + STIMON_AD_DEFAULT_WAIT_LAUNCH;

    m_pLastLaunchEvent = pDeviceEvent;

    PAUTO_LAUNCH_PARAM_CONTAINER pAutoContainer = new AUTO_LAUNCH_PARAM_CONTAINER;
    if (!pAutoContainer) {
        ReportError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    pAutoContainer->pActiveDevice = this;
    pAutoContainer->pLaunchEvent = pDeviceEvent;
    pAutoContainer->pAppName = pszAppName;

    //
    // If application name already requested, we will not display UI, so perform
    // syncronous call.
    //
    if (pszAppName) {
       fRet = AutoLaunch(pAutoContainer);

       delete pAutoContainer;
    }
    else {

        //
        // AddRef here to ensure we're not unloaded or destroyed while processing this
        // event.
        // Note:  AutoLaunchThread must Release() this refcount.
        //
        AddRef();
        hThread = ::CreateThread(NULL,
                              0,
                              (LPTHREAD_START_ROUTINE)AutoLaunchThread,
                              (LPVOID)pAutoContainer,
                              0,
                              &dwThread);

        if ( hThread ) {
            ::CloseHandle(hThread);
        }

        fRet = TRUE;
    }

    return fRet;

} // endproc ProcessEvent


BOOL
ACTIVE_DEVICE::
AutoLaunch(
    PAUTO_LAUNCH_PARAM_CONTAINER pAutoContainer
    )
/*++

Routine Description:

    Attempt to automatically launch application, which is associated with active device
    event


Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

{

    PDEVICEEVENT    pDeviceEvent ;
    BOOL            fRet;

    BOOL            fChooseAgain;
    BOOL            fFailedFirstSelection = FALSE;
    BOOL            fFailedUserEnv = FALSE;

    STRArray        saAppList;
    STRArray        saCommandLineList;

    DWORD           dwError;

    pDeviceEvent = (pAutoContainer->pLaunchEvent) ? (pAutoContainer->pLaunchEvent) : m_pLastLaunchEvent;

    if (!pDeviceEvent) {
        ASSERT(("No event available to AutoLaunch routine", 0));
        return FALSE;
    }

    ASSERT(m_dwFlags & STIMON_AD_FLAG_LAUNCH_PENDING);

    //
    // Attract user attention
    //
    #ifdef PLAYSOUND_ALWAYS
    ::PlaySound(TEXT("StillImageDevice"),NULL,SND_ALIAS | SND_ASYNC | SND_NOWAIT | SND_NOSTOP);
    #endif

    //
    // Nothing appears to be launched, so continue with it
    // Retreive command line

    m_strLaunchCommandLine.CopyString(TEXT("\0"));

    fRet = FALSE;

    fRet = RetrieveSTILaunchInformation(pDeviceEvent,
                                        pAutoContainer->pAppName,
                                        saAppList,
                                        saCommandLineList,
                                        fFailedFirstSelection ? TRUE : FALSE
                                        );

    if (fRet) {

        DEVICE_INFO *pDeviceInfo = pAutoContainer->pActiveDevice->m_DrvWrapper.getDevInfo();

        if (pDeviceInfo) {
            HRESULT             hr          = S_OK;
            WCHAR               *wszDest    = NULL;
            LONG                *plSize     = NULL;
            IWiaEventCallback   *pIEventCB  = NULL;
            ULONG               ulEventType = WIA_ACTION_EVENT;

            //
            // Variables used as parameters for the ImageEventCallback() method.
            //
            BSTR  bstrEventDescription  = SysAllocString((LPCTSTR)pDeviceEvent->m_EventName);
            BSTR  bstrDeviceID          = SysAllocString(pDeviceInfo->wszDeviceInternalName);
            BSTR  bstrDeviceDescription = SysAllocString(pDeviceInfo->wszDeviceDescription);
            DWORD dwDeviceType          = (DWORD) pDeviceInfo->DeviceType;

            if (bstrEventDescription && bstrDeviceID && bstrDeviceDescription) {
                //
                // Package the Application list and the relevant command line info in a double 
                // NULL terminated BSTR.  First calculate the number of bytes this will take.
                //  Our calculations are made up as follows:
                //  For every item in the AppList, add space for App name plus terminating NULL.
                //  For every item in the CommandLineList, add space for command line plus terminating NULL.
                //  Lastly, add space for terminating NULL (ensuring that the list is double NULL terminated)
                //
                //  NOTE:  Assumption here is that RetrieveSTILaunchInformation returns saAppList and
                //         saCommandLineList to have the same number of elements.
                //
                INT    iCount;
                LONG   lSize = 0;
                for (iCount = 0; iCount < saAppList.GetSize(); iCount++) {
                    lSize += (lstrlenW((LPCTSTR)*saAppList[iCount]) * sizeof(WCHAR)) + sizeof(L'\0');
                    lSize += (lstrlenW((LPCTSTR)*saCommandLineList[iCount]) * sizeof(WCHAR)) + sizeof(L'\0');
                }
                lSize += sizeof(L'\0') + sizeof(LONG);

                BSTR bstrAppList = SysAllocStringByteLen(NULL, lSize);
                if (bstrAppList) {

                    //
                    //  Copy each null termintaed string into the BSTR (including the terminating null),
                    //  and make sure the end is double terminated.
                    //
                    wszDest = bstrAppList;
                    for (iCount = 0; iCount < saAppList.GetSize(); iCount++) {
                        lstrcpyW(wszDest, (LPCTSTR)*saAppList[iCount]);
                        wszDest += lstrlenW(wszDest) + 1;
                        lstrcpyW(wszDest, (LPCTSTR)*saCommandLineList[iCount]);
                        wszDest += lstrlenW(wszDest) + 1;
                    }
                    wszDest[0] = L'\0';

                    //
                    //  CoCreate our event UI handler.  Note that it will not display any UI
                    //  if there is only one application.
                    //

                    hr = _CoCreateInstanceInConsoleSession(
                             CLSID_StiEventHandler,
                             NULL,
                             CLSCTX_LOCAL_SERVER,
                             IID_IWiaEventCallback,
                             (void**)&pIEventCB);

                    if (SUCCEEDED(hr)) {

                        //
                        //  Make the callback.
                        //

                        hr = pIEventCB->ImageEventCallback(&pDeviceEvent->m_EventGuid,
                                                           bstrEventDescription,
                                                           bstrDeviceID,
                                                           bstrDeviceDescription,
                                                           dwDeviceType,
                                                           bstrAppList,
                                                           &ulEventType,
                                                           0);
                        pIEventCB->Release();
                        if (FAILED(hr)) {
                            DBG_ERR(("ACTIVE_DEVICE::AutoLaunch, could not launch STI event handler"));
                            fRet = FALSE;
                        }
                    }
                    SysFreeString(bstrAppList);

                    if (SUCCEEDED(hr)) {

                        //
                        // Application was launched
                        //

                        fRet = TRUE;
                    }
                } else {
                    DBG_ERR(("ACTIVE_DEVICE::AutoLaunch, Out of memory!"));
                    fRet = FALSE;
                }
            } else {
                DBG_ERR(("ACTIVE_DEVICE::AutoLaunch, Out of memory!"));
                fRet = FALSE;
            }
        
            if (bstrEventDescription) {
                SysFreeString(bstrEventDescription);
                bstrEventDescription = NULL;
            }
            if (bstrDeviceID) {
                SysFreeString(bstrDeviceID);
                bstrDeviceID = NULL;
            }
            if (bstrDeviceDescription) {
                SysFreeString(bstrDeviceDescription);
                bstrDeviceDescription = NULL;
            }
        } else {
            DBG_WRN(("ACTIVE_DEVICE::AutoLaunch, Device Information is NULL, ignoring event"));
            fRet = FALSE;
        }
    }
    else {

        DBG_WRN(("ACTIVE_DEVICE::AutoLaunch, Could not get command line to launch application"));
        // m_dwFlags &= ~STIMON_AD_FLAG_LAUNCH_PENDING;

        fRet = FALSE;
    }

    //
    //  Clear the launch pending flag
    //
    m_dwFlags &= ~STIMON_AD_FLAG_LAUNCH_PENDING;

    return fRet;
} // endproc AutoLaunch

BOOL
ACTIVE_DEVICE::
RetrieveSTILaunchInformation(
    PDEVICEEVENT    pev,
    LPCTSTR         pAppName,
    STRArray&       saAppList,
    STRArray&       saCommandLine,
    BOOL            fForceSelection             // =FALSE
    )
/*++

Routine Description:

    Get command line for automatic process launch.

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    //
    // If all registered applications are allowed to start on this event
    // create array of names from registered list. Otherwise , parse list of
    // allowed applications
    //

    ReportError(NOERROR);

    if (IsWildCardEvent(pev) || fForceSelection ) {

        RegEntry re(REGSTR_PATH_REG_APPS,HKEY_LOCAL_MACHINE);
        RegEnumValues   regenum(&re);

        while (ERROR_SUCCESS == regenum.Next() ) {
            if ( ((regenum.GetType() == REG_SZ ) ||(regenum.GetType() == REG_EXPAND_SZ ))
                 && !IS_EMPTY_STRING(regenum.GetName())) {
                saAppList.Add((LPCTSTR)regenum.GetName());
            }
        }
    }
    else {
        //
        // Split into array of strings
        //
        TokenizeIntoStringArray(saAppList,
                                (LPCTSTR)pev->m_EventData,
                                TEXT(','));
    }

    //
    // Work with filled array of applications
    //
    if  (saAppList.GetSize() < 1) {
        return FALSE;
    }

    //
    // If application name requested, validate it against available list. Otherwise proceed
    // with UI
    //
    if (pAppName) {

        //
        // Search through the list of available applications for the name of requested
        //
        INT    iCount;
        BOOL   fFound = FALSE;

        for (iCount = 0;
             iCount < saAppList.GetSize();
             iCount++) {
            if (::lstrcmpi(pAppName,(LPCTSTR)*saAppList[iCount]) == 0) {

                fFound = TRUE;
            }
        }

        if (!fFound) {
            // Invalid application name requested
            ReportError(ERROR_INVALID_PARAMETER);
            return FALSE;
        } else {
            //
            // The app list should only contain this app's name, so remove all elements
            // and add this one.
            //
            saAppList.RemoveAll();
            saAppList.Add(pAppName);
        }
    }

    //
    // saAppList now contains the list of Applications to launch.
    // We must fill saCommandLine with the relevant command lines.
    //

    INT    iCount;

    DBG_TRC(("Processing Device Event:  AppList and CommandLines are:"));
    for (iCount = 0; iCount < saAppList.GetSize(); iCount++) {

        //
        // Format command line for execution
        //
        RegEntry    re(REGSTR_PATH_REG_APPS,HKEY_LOCAL_MACHINE);
        StiCString  strLaunchCommandLine;

        TCHAR   szRegCommandLine[2*255];
        TCHAR   szEventName[255] = {TEXT("")};
        TCHAR   *pszUuidString = NULL;

        *szRegCommandLine = TEXT('\0');
        re.GetString((LPCTSTR)*saAppList[iCount],szRegCommandLine,sizeof(szRegCommandLine));

        if(!*szRegCommandLine) {
            DBG_WRN(("ACTIVE_DEVICE::RetrieveSTILaunchInformation, RegEntry::GetString failed!"));
            return FALSE;
        }
        if (UuidToString(&pev->m_EventGuid,(RPC_STRING *)&pszUuidString) != RPC_S_OK)
        {
            DBG_WRN(("ACTIVE_DEVICE::RetrieveSTILaunchInformation, UuidToString() failed!"));
            return FALSE;
        }
        ASSERT(pszUuidString);

        wsprintf(szEventName,TEXT("{%s}"),pszUuidString ? (TCHAR *)pszUuidString :TEXT(""));
        strLaunchCommandLine.FormatMessage(szRegCommandLine,GetDeviceID(),szEventName);

        //
        // Add this to the list of Command Lines
        //
        saCommandLine.Add((LPCTSTR)strLaunchCommandLine);

        if (pszUuidString) {
            RpcStringFree((RPC_STRING *)&pszUuidString);
            pszUuidString = NULL;
        }

        DBG_PRT(("    AppName       = (%ls)", (LPCTSTR)*saAppList[iCount]));
        DBG_PRT(("    CommandLine   = (%ls)", (LPCTSTR)*saCommandLine[iCount]));
    };

    //
    //  Check that saAppList and saCommandLine have the same number of elements
    //
    if (saAppList.GetSize() != saCommandLine.GetSize()) {
        DBG_WRN(("ACTIVE_DEVICE::RetrieveSTILaunchInformation, Application list and Command Line list have different number of elements!"));
        return FALSE;
    }

    return TRUE;
}   // endproc RetrieveAutoLaunchCommandLine

BOOL
ACTIVE_DEVICE::
IsDeviceAvailable(
    VOID
    )
/*++

Routine Description:

    Returns TRUE if device is available for monitoring .


Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    STI_DEVICE_STATUS   sds;
    HRESULT             hRes = STI_OK;
    BOOL                bRet;

    //
    // Check valid state
    //
    if (!IsValid() || !m_DrvWrapper.IsDriverLoaded()) {
        return FALSE;
    }

    //
    // Get and analyze status information from active device
    //
    ::ZeroMemory(&sds,sizeof(sds));

    sds.StatusMask = STI_DEVSTATUS_ONLINE_STATE;

    hRes = g_pStiLockMgr->RequestLock(this, 1000);
    if (SUCCEEDED(hRes)) {
        hRes = m_DrvWrapper.STI_GetStatus(&sds);

        g_pStiLockMgr->RequestUnlock(this);
    }
    else {

        //
        // Ignore locking violation, as it may indicate device is in normal
        // state
        //
        if ((STIERR_SHARING_VIOLATION == hRes) || (WIA_ERROR_BUSY == hRes) ) {
            hRes = STI_OK;
            //
            //  Since we couldn't talk to the device because someone else is speaking to it,
            //  we assume it's online
            //
            sds.dwOnlineState = STI_ONLINESTATE_OPERATIONAL;
        }
    }

    bRet = SUCCEEDED(hRes) &&
           (sds.dwOnlineState & STI_ONLINESTATE_OPERATIONAL) ;

    DBG_TRC(("Request to check state on device (%S). RESULT:%s", GetDeviceID(),bRet ? "Available" : "Not available"));

    return bRet;

} // endproc IsDeviceAvailable

BOOL
ACTIVE_DEVICE::
RemoveConnection(
    STI_CONN    *pConnection
    )
{
    TAKE_ACTIVE_DEVICE t(this);

    STI_CONN   *pExistingConnection = NULL;
    BOOL       fRet = FALSE;

    pExistingConnection = FindMyConnection((HANDLE)pConnection->QueryID());

    if (pExistingConnection) {

        DBG_TRC(("Device(%S) removing  connection (%x)", GetDeviceID(), pConnection));
        pConnection->DumpObject();

        RemoveEntryList(&pConnection->m_DeviceListEntry);

        //
        // Reset flags on device object
        //
        if (pConnection->QueryOpenMode() & STI_DEVICE_CREATE_DATA) {
            SetFlags(QueryFlags() & ~STIMON_AD_FLAG_OPENED_FOR_DATA);
        }

        SetFlags(QueryFlags() & ~STIMON_AD_FLAG_LAUNCH_PENDING);

        //
        // If this was the last connection, stop notifications on a device
        //
        if (!NotificationsNeeded()) {
            StopNotifications();
        }

        fRet = TRUE;
    }
    else {
        // No connection on this device list
        DBG_ERR(("Removing connection not on the list for this device (%S)",GetDeviceID()));
    }

    return fRet;

}

BOOL
ACTIVE_DEVICE::
AddConnection(
    STI_CONN    *pConnection
    )
/*++

Routine Description:

    This function is called when new connection is requested from client to active device

Arguments:


--*/
{
    TAKE_ACTIVE_DEVICE t(this);

    STI_CONN   *pExistingConnection = NULL;
    BOOL       fRet = FALSE;

    pExistingConnection = FindMyConnection((HANDLE)pConnection->QueryID());

    if (!pExistingConnection) {

        //
        // Check if we are not in data mode
        //
        if (pConnection->QueryOpenMode() & STI_DEVICE_CREATE_DATA) {
            if (QueryFlags() & STIMON_AD_FLAG_OPENED_FOR_DATA) {
                DBG_TRC(("Device(%x) is being opened second time in data mode",this));
                ::SetLastError(ERROR_ACCESS_DENIED);
                return FALSE;
            }

            SetFlags(QueryFlags() | STIMON_AD_FLAG_OPENED_FOR_DATA);
        }

        //
        // Add connection object to connected list
        //
        InsertHeadList(&m_ConnectionListHead,&pConnection->m_DeviceListEntry);

        DBG_TRC(("Device(%S) added connection (%X) ", GetDeviceID(), pConnection));

        pConnection->DumpObject();

        //
        // Set device object flags
        //
        SetFlags(QueryFlags() & ~STIMON_AD_FLAG_LAUNCH_PENDING);

        //
        // If notifications allowed, explicitly enable them.
        //
        if ( QueryFlags() & STIMON_AD_FLAG_NOTIFY_ENABLED ) {
            StartRunningNotifications();
        }

        fRet = TRUE;
    }
    else {
        // Already present - something is wrong
        ASSERT(("Device adding connection which is already there ", 0));
    }

    return fRet;
}


STI_CONN   *
ACTIVE_DEVICE::
FindMyConnection(
    HANDLE    hConnection
    )
/*++

Routine Description:

    This function is used to locate connection object from connection handle

Arguments:


--*/
{

    LIST_ENTRY *pentry;
    LIST_ENTRY *pentryNext;

    STI_CONN   *pConnection = NULL;

    HANDLE      hInternalHandle = hConnection;

    for ( pentry  = m_ConnectionListHead.Flink;
          pentry != &m_ConnectionListHead;
          pentry  = pentryNext ) {

        pentryNext = pentry->Flink;

        pConnection = CONTAINING_RECORD( pentry, STI_CONN,m_DeviceListEntry );

        if (hInternalHandle == pConnection->QueryID()) {
            return pConnection;
        }
    }

    return NULL;
}

BOOL
ACTIVE_DEVICE::
FillEventFromUSD(
    STINOTIFY *psNotify
    )
/*++

Routine Description:

    This function is called after USD signalled presence of hardware event and if successful it
    returns event descriptor filled with information about event

Arguments:


--*/
{
    HRESULT     hres;

    psNotify->dwSize = sizeof STINOTIFY;
    psNotify->guidNotificationCode = GUID_NULL;

    if (!m_DrvWrapper.IsDriverLoaded()) {
        ASSERT(("FillEventFromUSD couldn't find direct driver interface", 0));
        return FALSE;
    }

    hres = m_DrvWrapper.STI_GetNotificationData(psNotify);

    return SUCCEEDED(hres) ? TRUE : FALSE;

}

BOOL
ACTIVE_DEVICE::
SetHandleForUSD(
    HANDLE  hEvent
    )
/*++

Routine Description:

    This function is called to pass event handle to USD for later signalling in case of
    hardware event

Arguments:

    pContext - pointer to device object

--*/
{
    HRESULT     hres = E_FAIL;

    if (!IsValid() || !m_DrvWrapper.IsDriverLoaded()) {
        ASSERT(("SetHandleForUSD couldn't find direct driver interface", 0));
        return FALSE;
    }

    //
    // Ask device object for USD interface. Should get it because sti device aggregates
    // USD
    //
    hres = m_DrvWrapper.STI_SetNotificationHandle(hEvent);
    if (hres == STIERR_UNSUPPORTED) {
        hres = S_OK;
    }

    return SUCCEEDED(hres) ? TRUE : FALSE;
}

BOOL
ACTIVE_DEVICE::
IsEventOnArrivalNeeded(
    VOID
    )
/*++

Routine Description:

    Returns TRUE if this device needs to generate event on arrival.

    Conditions are:
        - Device successully initialized
        - Device capabilities ( static or dynamic) include appropriate bit
        - Device is capable and enabled for event generation

Arguments:

    None

--*/
{

    HRESULT         hres;
    STI_USD_CAPS    sUsdCaps;
    BOOL            fRet;

    fRet = FALSE;

    ZeroMemory(&sUsdCaps,sizeof(sUsdCaps));

    hres = m_DrvWrapper.STI_GetCapabilities(&sUsdCaps);
    if (SUCCEEDED(hres))  {

        if ( (m_dwFlags & STIMON_AD_FLAG_NOTIFY_ENABLED ) &&
             (m_dwFlags & STIMON_AD_FLAG_NOTIFY_CAPABLE ) ) {

            //
            // Check that either static or dynamic capabilities mask conatins needed bit
            //
            if ( (sUsdCaps.dwGenericCaps | m_DrvWrapper.getGenericCaps()) &
                  STI_GENCAP_GENERATE_ARRIVALEVENT
               ) {
                fRet = TRUE;
            }
        }
    }

    return fRet;

} //

BOOL
ACTIVE_DEVICE::
InitPnPNotifications(
    HWND    hwnd
    )
/*++

Routine Description:

       Assumes device object to be locked

Arguments:

    None

--*/
{
    BOOL    fRet = FALSE;

#ifdef WINNT

    //
    //  First, stop any existing PnP notifications
    //
    StopPnPNotifications();

    WCHAR           *wszInterfaceName = NULL;
    DWORD           dwError;

    //
    // Get interface name for out device
    //
    wszInterfaceName = g_pDevMan->AllocGetInterfaceNameFromDevInfo(m_DrvWrapper.getDevInfo());
    if (wszInterfaceName) {

        //
        // Open handle on this interface
        //
        m_hDeviceInterface = ::CreateFileW(wszInterfaceName,
                                           GENERIC_READ,   // Access
                                           0,              // Share mode
                                           NULL,           // Sec attributes
                                           OPEN_EXISTING,  // Disposition
                                           0,              // Attributes
                                           NULL            // Template file
                                           );
        if (IS_VALID_HANDLE(m_hDeviceInterface)) {
            //
            // Register to receive PnP notifications on interface handle
            //

            DEV_BROADCAST_HDR           *psh;
            DEV_BROADCAST_HANDLE        sNotificationFilter;

            //
            // Register to receive device notifications from PnP
            //

            psh = (DEV_BROADCAST_HDR *)&sNotificationFilter;

            psh->dbch_size = sizeof(DEV_BROADCAST_HANDLE);
            psh->dbch_devicetype = DBT_DEVTYP_HANDLE;
            psh->dbch_reserved = 0;

            sNotificationFilter.dbch_handle = m_hDeviceInterface;

            DBG_TRC(("Attempting to register with PnP for interface device handle"));

            m_hDeviceNotificationSink = RegisterDeviceNotification(g_StiServiceStatusHandle,
                                                                   (LPVOID)&sNotificationFilter,
                                                                   DEVICE_NOTIFY_SERVICE_HANDLE);
            dwError = GetLastError();
            if( !m_hDeviceNotificationSink && (NOERROR != dwError)) {
                m_hDeviceNotificationSink = NULL;
                //
                // Failed to create notification sink with PnP subsystem
                //
                DBG_ERR(("InitPnPNotifications: Attempt to register %S with PnP failed. Error:0x%X",
                         GetDeviceID(), ::GetLastError()));
            } else {
                fRet = TRUE;
            }
        }
        else {
            DBG_WRN(("InitPnPNotifications: Attempt to open device interface on (%ws) failed. Error:0x%X", GetDeviceID(), ::GetLastError()));
        }

        delete [] wszInterfaceName;
    }
    else {
        DBG_WRN(("InitPnPNotifications: Lookup for device interface name on (%ws) failed. Error:0x%X", GetDeviceID(), ::GetLastError()));
    }

#else

    fRet = TRUE;

#endif

    return fRet;

}

BOOL
ACTIVE_DEVICE::
IsRegisteredForDeviceRemoval(
        VOID
        )
{
    //
    //  Check whether we registered for device notifications on this
    //  device's interface.
    //
    if (IsValidHANDLE(m_hDeviceNotificationSink)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
ACTIVE_DEVICE::
StopPnPNotifications(
    VOID
    )
/*++

Routine Description:

       Assumes device object to be locked

Arguments:

    None

--*/
{

#ifdef WINNT


    //
    // Unregister for PnP notifications on interface handle
    //
    if (IS_VALID_HANDLE(m_hDeviceNotificationSink)) {
        ::UnregisterDeviceNotification(m_hDeviceNotificationSink);
        m_hDeviceNotificationSink = NULL;
    }
    else {
        DBG_TRC(("StopPnPNotifications: Device sink is invalid "));
    }
    //
    // Close interface handle
    //
    if (IS_VALID_HANDLE(m_hDeviceInterface)) {
        ::CloseHandle(m_hDeviceInterface);
        m_hDeviceInterface = NULL;
    }
    else {
        DBG_TRC(("StopPnPNotifications: Device interface handle is invalid"));
    }

#endif

    return TRUE;
}


BOOL
ACTIVE_DEVICE::
UpdateDeviceInformation(
    VOID
    )
/*++

Routine Description:

       Updates the cached device information struct.

Arguments:

    None

--*/
{
USES_CONVERSION;

    HRESULT hres;
    BOOL    bRet = TRUE;

    /*  TBD:
    if (!m_strStiDeviceName) {
        DBG_ERR(("Error updating device info cache, device name is invalid"));
        bRet = FALSE;
    }

    //
    // Update the cached WIA_DEVICE_INFORMATION in the ACTICVE_DEVICE
    //

    if (bRet) {
        PSTI_WIA_DEVICE_INFORMATION pWiaDevInfo;

        hres = StiPrivateGetDeviceInfoHelperW((LPWSTR)T2CW(m_strStiDeviceName),(LPVOID *)&pWiaDevInfo );

        if (!SUCCEEDED(hres) || !pWiaDevInfo) {
            DBG_ERR(("Loading device (%ws) . Failed to get WIA information from STI. HResult=(%x)", m_strStiDeviceName, hres));
            m_pWiaDeviceInformation = NULL;
            bRet = FALSE;
        } else {
            m_pWiaDeviceInformation = pWiaDevInfo;
        }
    }
    */

    return bRet;
}

//
// Functions
//
//

VOID
WINAPI
ScheduleDeviceCallback(
    VOID * pContext
    )
/*++

Routine Description:

    This function is the callback called by the scheduler thread after the
    specified timeout period has elapsed.

Arguments:

    pContext - pointer to device object

--*/

{
    ACTIVE_DEVICE*  pActiveDevice = (ACTIVE_DEVICE* )pContext;

    ASSERT(("Callback invoked with null context", pContext));

    if (pContext) {
        //
        //  No need to take the active device here - the caller
        //  has already AddRef'd, and will Release when
        //  we're done.  A dealock will occur unless we first
        //  take the global list CS, then the ACTIVE_DEVICE's
        //  CS...
        //TAKE_ACTIVE_DEVICE t(pActiveDevice);

        pActiveDevice->AddRef();

        if (pActiveDevice->QueryFlags() & STIMON_AD_FLAG_POLLING) {
            pActiveDevice->DoPoll();
        }
        else {
           //
           // Async event arrived - call methods
           //
           pActiveDevice->DoAsyncEvent();
        }

        pActiveDevice->Release();
    }
}

VOID
WINAPI
DelayedDeviceInitCallback(
    VOID * pContext
    )
/*++

Routine Description:

    This function is the callback called by the scheduler thread after the
    device is first created to enable notifications.

Arguments:

    pContext - pointer to device object

--*/

{
    ACTIVE_DEVICE*  pActiveDevice = (ACTIVE_DEVICE* )pContext;

    ASSERT(("Callback invoked with null context", pContext));
    if (pContext) {

        TAKE_ACTIVE_DEVICE t(pActiveDevice);

        pActiveDevice->m_dwDelayedOpCookie = 0;

        if (pActiveDevice->IsValid()) {

            //
            // If there is nobody to receive notifications, don't really enable them
            //
            pActiveDevice->EnableDeviceNotifications();

            #ifdef DO_INITIAL_RESET
            //  NOTE:
            //  Resetting the device is a good way of ensuring that the device
            //  starts off in a stable state.  Unfortunately, this can be bad
            //  because 1) It is often time consuming
            //          2) We may wake up devices unecessarily (e.g. most
            //             serial cameras).
            //
            //  Device reset is not necessary for WIA drivers, since it is a
            //  requirement that they are always in a stable state, so we
            //  could compromise and reset only non-WIA devices.
            //

            hres = g_pStiLockMgr->RequestLock(pActiveDevice, STIMON_AD_DEFAULT_WAIT_LOCK);
            if (SUCCEEDED(hres) ) {
                pActiveDevice->m_DrvWrapper.STI_DeviceReset();
                g_pStiLockMgr->RequestUnLock(pActiveDevice);
            }
            #endif

            //
            // As we are done with delayed initialization - clear the flag
            //
            pActiveDevice->SetFlags(pActiveDevice->QueryFlags() & ~STIMON_AD_FLAG_DELAYED_INIT);

        } /* endif IsValid */
        else {
            ASSERT(("DelayedDeviceInitCallback received invalid device object", 0));
        }
    }
}



VOID
WINAPI
AutoLaunchThread(
    LPVOID  lpParameter
    )
/*++

Routine Description:

    Worker routine for autolaunching thread.
    Validates parameter and invokes proper method

Arguments:

    None.

Return Value:

    None.

--*/
{
    PAUTO_LAUNCH_PARAM_CONTAINER pAutoContainer = static_cast<AUTO_LAUNCH_PARAM_CONTAINER *>(lpParameter);

    if (!lpParameter || !pAutoContainer->pActiveDevice) {
        ASSERT(("No parameter passed to launch thread", 0));
        return;
    }

    ACTIVE_DEVICE   *pActiveDevice = pAutoContainer->pActiveDevice;

    pActiveDevice->AutoLaunch(pAutoContainer);
    pActiveDevice->Release();

    delete pAutoContainer;
}

//
// Adding new device to the active list.
// This function is not reentrant with adding/removal
//

BOOL
AddDeviceByName(
    LPCTSTR     pszDeviceName,
    BOOL        fPnPInitiated   // = FALSE
    )
{
    /*
    USES_CONVERSION;

    LIST_ENTRY * pentry;
    LIST_ENTRY * pentryNext;

    ACTIVE_DEVICE*   pActiveDevice  = NULL;

    BOOL        fAlreadyExists      = FALSE;

    DBG_TRC(("Requested arrival of device (%ws) ",pszDeviceName));

    // BEGIN PROTECTED CODE
    {
        TAKE_CRIT_SECT t(g_DeviceListSync);

        for ( pentry  = g_DeviceListHead.Flink;
              pentry != &g_DeviceListHead;
              pentry  = pentryNext ) {

            pentryNext = pentry->Flink;

            pActiveDevice = CONTAINING_RECORD( pentry,ACTIVE_DEVICE ,m_ListEntry );

            if ( pActiveDevice->m_dwSignature != ADEV_SIGNATURE ) {
                ASSERT(("Invalid device signature", 0));
                break;
            }

            if (!::lstrcmpi(pszDeviceName,(LPCTSTR)pActiveDevice->m_strStiDeviceName)) {

                fAlreadyExists = TRUE;
                break;
            }
        }

        if (!fAlreadyExists) {

            pActiveDevice = new ACTIVE_DEVICE(pszDeviceName);

            if (!pActiveDevice || !pActiveDevice->IsValid()) {

                DBG_ERR(("Creating device  failed "));
                if (pActiveDevice) {
                    delete pActiveDevice;
                }

                return FALSE;
            }

            // Finally insert new object into the list
            InsertTailList(&g_DeviceListHead,&pActiveDevice->m_ListEntry);
        }
        else {
            STIMONWPRINTF(TEXT("Request to add new device found device is already maintained"));
            return FALSE;
        }
    }
    // END PROTECTED CODE

    //
    // If new device appeared - initialize PnP interface notifications
    //
    if ( pActiveDevice ) {

        TAKE_ACTIVE_DEVICE t(pActiveDevice);

        pActiveDevice->InitPnPNotifications(g_hStiServiceWindow);

    }

    //
    // If this device or it's USD requests auto-generating a launch event on arrival
    // schedule it here
    //
    // NOTE : This will also happen for WIA devices.  Generally, this is what we want,
    // when a new device arrives we should generate the event, since devices such as
    // serial cameras wont generate this on their own.
    //

    //
    // For STI devices we must check whether we need to generate the
    // event.  For WIA devices, we always want to, so it's not an issue.
    //
    BOOL bStiDeviceMustThrowEvent = (pActiveDevice->QueryFlags() & STIMON_AD_FLAG_NOTIFY_RUNNING)
                                    && pActiveDevice->IsEventOnArrivalNeeded();
    if (fPnPInitiated &&
        pActiveDevice) {

        TAKE_ACTIVE_DEVICE t(pActiveDevice);

        STINOTIFY       sNotify;
        BOOL            fRet;

        //
        // If this is a WIA device, then the event should be WIA_EVENT_DEVICE_CONNECTED.
        // If this is an sti device, then it should be GUID_DeviceArrivedLaunch;
        //

        sNotify.dwSize = sizeof STINOTIFY;
        if (pActiveDevice->m_pWiaDeviceInformation) {
            sNotify.guidNotificationCode = WIA_EVENT_DEVICE_CONNECTED;
        } else {

            //
            // Check whether this STI device should throw the event
            //

            if (!bStiDeviceMustThrowEvent) {
                return TRUE;
            }
            sNotify.guidNotificationCode = GUID_DeviceArrivedLaunch;
        }

        DBG_TRC(("::AddDeviceByName, processing CONNECT event (STI or WIA) for %ws", T2W((TCHAR*)pszDeviceName)));
        fRet = pActiveDevice->ProcessEvent(&sNotify);

        if (!fRet) {
            DBG_ERR(("Attempted to generate event on device(%ws) arrival and failed ", pszDeviceName));
        }
    }
    */
    return TRUE;
}

//
// Remove device identified by name
//
BOOL
RemoveDeviceByName(
    LPTSTR          pszDeviceName
    )
{

    USES_CONVERSION;


    DBG_FN(RemoveDeviceByName);

    LIST_ENTRY * pentry;
    LIST_ENTRY * pentryNext;

    ACTIVE_DEVICE*   pActiveDevice = NULL;

    BOOL        fRet = FALSE;

    DBG_TRC(("Requested removal of device (%ws)", pszDeviceName));

    // BEGIN PROTECTED CODE
    {
        TAKE_CRIT_SECT t(g_DeviceListSync);

        for ( pentry  = g_DeviceListHead.Flink;
              pentry != &g_DeviceListHead;
              pentry  = pentryNext ) {

            pentryNext = pentry->Flink;

            pActiveDevice = CONTAINING_RECORD( pentry,ACTIVE_DEVICE ,m_ListEntry );

            if ( pActiveDevice->m_dwSignature != ADEV_SIGNATURE ) {
                ASSERT(("Invalid device signature", 0));
                fRet = FALSE;
                break;
            }
            TCHAR       *tszDeviceID = NULL;

            tszDeviceID = W2T(pActiveDevice->GetDeviceID());
            if (tszDeviceID) {
                if (!::lstrcmp(pszDeviceName,tszDeviceID)) {


                   // Mark device as being removed
                   pActiveDevice->SetFlags(pActiveDevice->QueryFlags() | STIMON_AD_FLAG_REMOVING);

                   //
                   // Remove any device notification callbacks
                   //
                   pActiveDevice->DisableDeviceNotifications();

                   //
                   // Stop PnP notifications immediately. This is important to free interface handle
                   //
                   pActiveDevice->StopPnPNotifications();

                   //
                   // Remove from the list
                   //
                   RemoveEntryList(&pActiveDevice->m_ListEntry);
                   pActiveDevice->m_ListEntry.Flink = pActiveDevice->m_ListEntry.Blink = NULL;

                   //
                   // Destroy device object if there are no references to it
                   //
                   ULONG ulRef = pActiveDevice->Release();
                   if (ulRef != 0) {

                       //
                       // The ACTIVE_DEVICE should have been destroyed i.e. it's
                       // ref count should have been 0.  Someone is still holding
                       // an active count on it, which may indicate a problem
                       // since USD wont be unloaded until ACTIVE_DEVICE is
                       // destroyed...
                       //
                       //  NOTE:  If a transfer is occuring while deleteing, then
                       //  the ACTIVE_DEVICE will not be destroyed here (since
                       //  ref count > 0), but will be destroyed when the transfer
                       //  finishes.
                       //

                       DBG_TRC(("* ACTIVE_DEVICE is removed from list but not yet destroyed!"));
                       //Break();
                   }

                   fRet = TRUE;

                   break;
               }
            }
        }

    }
    // END PROTECTED CODE

    return fRet;
}

//
// Mark device identified by name for removal
//
BOOL
MarkDeviceForRemoval(
    LPTSTR          pszDeviceName
    )
{

    USES_CONVERSION;


    DBG_FN(MarkDeviceForRemoval);

    LIST_ENTRY * pentry;
    LIST_ENTRY * pentryNext;

    ACTIVE_DEVICE*   pActiveDevice = NULL;

    BOOL        fRet = FALSE;

    DBG_TRC(("Requested marking of device (%S) for removal",pszDeviceName));

    // BEGIN PROTECTED CODE
    {
        TAKE_CRIT_SECT t(g_DeviceListSync);

        for ( pentry  = g_DeviceListHead.Flink;
              pentry != &g_DeviceListHead;
              pentry  = pentryNext ) {

            pentryNext = pentry->Flink;

            pActiveDevice = CONTAINING_RECORD( pentry,ACTIVE_DEVICE ,m_ListEntry );

            if ( pActiveDevice->m_dwSignature != ADEV_SIGNATURE ) {
                ASSERT(("Invalid device signature", 0));
                fRet = FALSE;
                break;
            }
            TCHAR       *tszDeviceID = NULL;

            tszDeviceID = W2T(pActiveDevice->GetDeviceID());
            if (tszDeviceID) {
                if (!::lstrcmp(pszDeviceName, tszDeviceID)) {

                   // Mark device as being removed
                   pActiveDevice->SetFlags(pActiveDevice->QueryFlags() | STIMON_AD_FLAG_REMOVING);
                   fRet = TRUE;
                   break;
               }
            }
        }

    }
    // END PROTECTED CODE

    return fRet;
}

//
// Initialize/Terminate linked list
//
VOID
InitializeDeviceList(
    VOID
    )
{
    InitializeListHead( &g_DeviceListHead );
    InitializeListHead( &g_ConnectionListHead );

    g_lTotalOpenedConnections = 0;
    g_lTotalActiveDevices = 0;

    g_fDeviceListInitialized = TRUE;
}

VOID
TerminateDeviceList(
    VOID
    )
{
    LIST_ENTRY * pentry;
    ACTIVE_DEVICE*  pActiveDevice = NULL;

    DBG_TRC(("Destroying list of active devices"));

    if (!g_fDeviceListInitialized) {
        return;
    }

    TAKE_CRIT_SECT t(g_DeviceListSync);

    //
    // Go through the list terminating devices
    //
    while (!IsListEmpty(&g_DeviceListHead)) {

        pentry = g_DeviceListHead.Flink;

        //
        // Remove from the list ( reset list entry )
        //
        RemoveHeadList(&g_DeviceListHead);
        InitializeListHead( pentry );

        pActiveDevice = CONTAINING_RECORD( pentry, ACTIVE_DEVICE,m_ListEntry );

        // Destroy device object
        // delete pActiveDevice;
        pActiveDevice->Release();

    }

    g_fDeviceListInitialized = FALSE;
}

VOID
RefreshDeviceList(
    WORD    wCommand,
    WORD    wFlags
    )
/*++

Routine Description:

    Update device list. Invalidate if necessary

Arguments:

    wCommand - update command code
    wFlags   - update flags

Return Value:

    None

--*/
{

    BOOL    fOldState;

    // TDB:  Call CWiaDevMan::ReEnumerateDevices

    /*
    //
    // Pause work item scheduler
    //
    fOldState = SchedulerSetPauseState(TRUE);

    //
    // Indicate that the device list refresh is not yet complete
    //
    ResetEvent(g_hDevListCompleteEvent);

    //
    // If needed, add devices , which might appear first.
    //

    if (wFlags & STIMON_MSG_REFRESH_NEW) {

        //
        // If request been made to purge removed devices - do it in 2 steps:
        //  - First, mark all devices currently active as inactive
        //  - Second, go through all devices from PnP and for each device either create new
        //    active device object ( if it does not exist yet), or mark existing one as active
        //  - Third , purge all device objects, marked as inactive from the list.
        //

        //
        //  NOTE:  None of the parameters using LongToPtr are actually pointer values!  They're
        //  actually wParams and lParams of Windows messages (equivalents).
        //

        if (wFlags & STIMON_MSG_PURGE_REMOVED) {

            DBG_TRC(("Purging device list. Phase1: Marking all devices inactive "));

            EnumerateActiveDevicesWithCallback(&RefreshExistingDevicesCallback,
                                               (LPVOID)LongToPtr(MAKELONG(STIMON_MSG_REFRESH_SET_FLAG,STIMON_MSG_NOTIF_SET_INACTIVE)));
        }

        EnumerateStiDevicesWithCallback(&AddNewDevicesCallback, (LPVOID)LongToPtr(MAKELONG(0,wFlags)));

        if (wFlags & STIMON_MSG_PURGE_REMOVED) {

            DBG_TRC(("Purging device list. Phase2: Removing unconfirmed devices "));

            EnumerateActiveDevicesWithCallback(&RefreshExistingDevicesCallback,
                                                (LPVOID)LongToPtr(MAKELONG(STIMON_MSG_REFRESH_PURGE,0)));
        }

    }

    //
    // If requested, go through all known active devices and refresh their settings
    //
    if (wFlags & STIMON_MSG_REFRESH_EXISTING) {
        EnumerateActiveDevicesWithCallback(&RefreshExistingDevicesCallback,(LPVOID)LongToPtr(MAKELONG(wCommand,wFlags)));
    }

    SetEvent(g_hDevListCompleteEvent);

    // UnPause work item scheduler
    SchedulerSetPauseState(fOldState);
    */
}



//
// Set new value of interval for all polled devices
//

VOID
CALLBACK
ResetAllPollIntervalsCallback(
    ACTIVE_DEVICE   *pActiveDevice,
    VOID            *pContext
    )
/*++

Routine Description:

Arguments:

Return Value:

    TRUE , FALSE

--*/
{
    ULONG   ulContextLong = PtrToUlong(pContext);

    TAKE_ACTIVE_DEVICE t(pActiveDevice);

    //
    // If device is polled - reset it's interval to new value
    //
    if(pActiveDevice->QueryFlags() & STIMON_AD_FLAG_POLLING) {

        pActiveDevice->SetPollingInterval(ulContextLong);

        DBG_TRC(("Polling interval is set to %d on device (%ws)",
                    pActiveDevice->QueryPollingInterval(),
                    pActiveDevice->GetDeviceID()));
    }
}


BOOL
ResetAllPollIntervals(
    UINT   dwNewPollInterval
    )
/*++

Routine Description:

Arguments:

Return Value:

    TRUE , FALSE

--*/
{
    EnumerateActiveDevicesWithCallback(&ResetAllPollIntervalsCallback,(LPVOID)LongToPtr(dwNewPollInterval));

    return TRUE;
}


VOID
CALLBACK
DumpActiveDevicesCallback(
    ACTIVE_DEVICE   *pActiveDevice,
    VOID            *pContext
    )
/*++

Routine Description:

Arguments:

Return Value:

    TRUE , FALSE

--*/
{
    STIMONWPRINTF(TEXT("Device:%ws  DeviceId:%d  Flags:%4x   Poll interval:%d"),
                   pActiveDevice->GetDeviceID(),
                   pActiveDevice->m_lDeviceId,
                   pActiveDevice->QueryFlags(),
                   pActiveDevice->m_dwPollingInterval);
}


VOID
DebugDumpDeviceList(
    VOID
    )
/*++

Routine Description:

Arguments:

Return Value:

    TRUE , FALSE

--*/
{
    EnumerateActiveDevicesWithCallback(&DumpActiveDevicesCallback,NULL);
}

VOID
CALLBACK
PurgeDevicesCallback(
    PSTI_DEVICE_INFORMATION pDevInfo,
    VOID                    *pContext
    )
/*++

Routine Description:

    Callback routine to invoke when removing all devices

Arguments:

    pDevInfo - pointer to device information block

Return Value:

    None

--*/
{
USES_CONVERSION;

    if (RemoveDeviceByName(W2T(pDevInfo->szDeviceInternalName))) {
        STIMONWPRINTF(TEXT("Destroyed device object (%S)"),pDevInfo->szDeviceInternalName);
    }
    else {
        STIMONWPRINTF(TEXT("Attempted destroying device object (%S), but failed"),pDevInfo->szDeviceInternalName);
    }
}

VOID
DebugPurgeDeviceList(
    VOID *pContext
    )
/*++

Routine Description:

    Unconditionally destroy active device list

Arguments:

    Context to pass to callback

--*/
{

    // Pause work item scheduler
    SchedulerSetPauseState(TRUE);

    // TBD:  Find replacement
    //EnumerateStiDevicesWithCallback(&PurgeDevicesCallback,pContext);

    // UnPause work item scheduler
    SchedulerSetPauseState(FALSE);

}

//
// Enumerators with callbacks
//

VOID
WINAPI
EnumerateStiDevicesWithCallback(
    PFN_DEVINFO_CALLBACK    pfn,
    VOID                    *pContext
    )
/*++

Routine Description:

    Walk the list of installed devices, calling given routine for each device

Arguments:

    pfn     -   Address of the callback
    pContext-   Pointer to context information to pass to callback

Return Value:

    None

--*/
{
    /*  TDB:  Find out who calls this and convert them over to CWiaDevMan
    if (!g_fDeviceListInitialized) {
        STIMONWPRINTF(TEXT("Device list not initialized"));
        return;
    }

    if (!pfn) {
        ASSERT(("Incorrect callback", 0));
        return;
    }

    HRESULT hres;

    PSTI_DEVICE_INFORMATION pDevInfo;

    PVOID   pBuffer;

    UINT    iDev;
    DWORD   dwItemsReturned;

    //
    // Enumerate STI devices
    //

    hres = g_pSti->GetDeviceList(0,                 // Type
                                 FLAG_NO_LPTENUM,   // Flags
                                 &dwItemsReturned,
                                 &pBuffer);

    if (!SUCCEEDED(hres) || !pBuffer) {
        DBG_ERR(("Enumeration call failed - abort. HRes=%x \n",hres));
        goto Cleanup;
    }

    DBG_TRC(("EnumerateStiDevicesWithCallback, returned from GetList: counter=%d", dwItemsReturned));


    pDevInfo = (PSTI_DEVICE_INFORMATION) pBuffer;

    //
    // Walk the device list and for each device add active object
    //

    for (iDev=0;
         iDev<dwItemsReturned ;
         iDev++, pDevInfo++) {

        pfn(pDevInfo,pContext);

    } // end_for

Cleanup:

    if (pBuffer) {
        LocalFree(pBuffer);
        pBuffer = NULL;
    }
    */
}

VOID
WINAPI
EnumerateActiveDevicesWithCallback(
    PFN_ACTIVEDEVICE_CALLBACK   pfn,
    VOID                    *pContext
    )
/*++

Routine Description:

    Walk the list of known active devices, calling given routine for each device

Arguments:

    pfn     -   Address of the callback
    pContext-   Pointer to context information to pass to callback

Return Value:

    None

--*/
{

    if (!pfn) {
        ASSERT(("Incorrect callback", 0));
        return;
    }

    LIST_ENTRY * pentry;
    LIST_ENTRY * pentryNext;

    ACTIVE_DEVICE*  pActiveDevice;

    // BEGIN PROTECTED CODE
    {
        TAKE_CRIT_SECT t(g_DeviceListSync);

        for ( pentry  = g_DeviceListHead.Flink;
              pentry != &g_DeviceListHead;
              pentry  = pentryNext ) {

            pentryNext = pentry->Flink;

            pActiveDevice = CONTAINING_RECORD( pentry, ACTIVE_DEVICE,m_ListEntry );

            if (!pActiveDevice->IsValid()) {
                ASSERT(("Invalid device signature", 0));
                break;
            }

            pfn(pActiveDevice,pContext);
        }
    }
    // END PROTECTED CODE

}

VOID
CleanApplicationsListForEvent(
    LPCTSTR         pDeviceName,
    PDEVICEEVENT    pDeviceEvent,
    LPCTSTR         pAppName
    )
/*++

Routine Description:

    After it had been determined that application , associated with this event is not valid,
    we want to make event function as wild card ( i.e. all eligibale apps are selected)

Arguments:

Return Value:

--*/
{

    USES_CONVERSION;

    //
    // Build up reg path for event info
    //
    StiCString     strRegPath;

    strRegPath.CopyString((LPCTSTR)(IsPlatformNT() ? REGSTR_PATH_STIDEVICES_NT : REGSTR_PATH_STIDEVICES));

    strRegPath+=TEXT("\\");
    strRegPath+=pDeviceName;

    RegEntry    reEvent((LPCTSTR)strRegPath,HKEY_LOCAL_MACHINE);

    if (reEvent.IsValid()) {

        reEvent.MoveToSubKey(EVENTS);
        reEvent.MoveToSubKey((LPCTSTR)pDeviceEvent->m_EventSubKey);

        reEvent.SetValue(REGSTR_VAL_LAUNCH_APPS,TEXT("*"));

        // Reset data in loaded event descriptor
        pDeviceEvent->m_EventData.CopyString(TEXT("*"));
    }

}

DWORD
GetNumRegisteredApps(
    VOID
    )
/*++

Routine Description:

    Count number of currently registered applications

Arguments:

    None

Return Value:

    Number of registered apps


--*/
{
    RegEntry re(REGSTR_PATH_REG_APPS,HKEY_LOCAL_MACHINE);
    RegEnumValues   regenum(&re);

    DWORD   dwCount = 0;

    if (re.IsValid()) {

        while (ERROR_SUCCESS == regenum.Next() ) {

        #ifndef USE_QUERY_INFO
            if ((regenum.GetType() == REG_SZ ) && !IS_EMPTY_STRING(regenum.GetName())) {
                dwCount++;
            }
        }
        #else
        dwErrorReg = RegQueryInfoKey ( re.GetKey(),     // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &dwCount,            // Number of value entries
                                   NULL,                // Longest value name
                                   NULL,                // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
        #endif
    }

    return dwCount;

}

HRESULT
WiaGetDeviceInfo(
    LPCWSTR         pwszDeviceName,
    DWORD           *pdwDeviceType,
    BSTR            *pbstrDeviceDescription,
    ACTIVE_DEVICE   **ppDevice)

/*++

Routine Description:

    Retrieve device information of device

Arguments:


Return Value:

    status

--*/

{
USES_CONVERSION;

    HRESULT          hr = S_FALSE;
    ACTIVE_DEVICE   *pActiveDevice;

    if (!ppDevice) {
        return E_POINTER;
    }

    pActiveDevice = g_pDevMan->IsInList(DEV_MAN_IN_LIST_DEV_ID, (WCHAR*)pwszDeviceName);
    if (pActiveDevice) {
        //
        // If that device is WIA capable
        //

        if (pActiveDevice->m_DrvWrapper.IsWiaDevice()) {
            *ppDevice = pActiveDevice;

            //
            // Copy necessary information
            //

            DEVICE_INFO *pDeviceInfo = pActiveDevice->m_DrvWrapper.getDevInfo();

            if (pDeviceInfo) {
                *pbstrDeviceDescription =
                    SysAllocString(
                        pDeviceInfo->wszDeviceDescription);

                if (*pbstrDeviceDescription) {

                    *pdwDeviceType =
                        pDeviceInfo->DeviceType;

                    hr = S_OK;
                }
            }
        }
    }

    if (hr != S_OK) {

        *pdwDeviceType          = 0;
        *pbstrDeviceDescription = NULL;
        *ppDevice               = NULL;
    }

    return (hr);
}

HRESULT
WiaUpdateDeviceInfo()

/*++

Routine Description:

    Refreshes the cached STI_WIA_DEVICE_INFORMATION in each device.

Arguments:


Return Value:

    status

--*/
{
    RefreshDeviceList(STIMON_MSG_REFRESH_DEV_INFO, STIMON_MSG_REFRESH_EXISTING);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\stirpc_server.c ===
#include <stirpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\sticfunc.c ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       sticfunc.h
*
*  VERSION:     1.0
*
*  DATE:        6 March, 2001
*
*  DESCRIPTION:
*  This file contains "C" style functions used in the STI/WIA service.
*
******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
//  This function is here because of a problem with header files.  Our 
//  precompiled header includes <winnt.h>, which defines NT_INCLUDED.  
//  Unfortuneately, <nt.h> also defines NT_INCLUDED.  However, the definition for
//  the USER_SHARED_DATA structure can only be retrieved from nt.h.  This 
//  creates a problem for us, since we cannot include nt.h in a C++ source file
//  that needs this structure, since we'll get multiple re-definitions of
//  most of the structures in nt.h.  We also cannot include nt.h in the 
//  precompiled header itsself, since our files need certain fields defined
//  in winnt.h (and remember that including nt.h will define NT_INCLUDED, which
//  means everything in winnt.h is skipped).
//  The easiest solution was to put this function in a C file, since the CXX
//  precompiled header will not be used for this file.
//
ULONG GetCurrentSessionID() 
{
    return USER_SHARED_DATA->ActiveConsoleId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\stiexe.cpp ===
/*++


Copyright (c)   1997-1999    Microsoft Corporation

Module Name:

    STIEXE.CPP

Abstract:

    This module contains code for process, running STI+WIA services

Author:

    Vlad  Sadovsky  (vlads)     09-20-97

Environment:

    User Mode - Win32

Revision History:

    22-Sep-1997     VladS       created
    13-Apr-1999     VladS       merged with WIA service code


--*/

//
//  Include Headers
//
#include "precomp.h"
#include "stiexe.h"

#include "device.h"
#include "wiapriv.h"
#include "lockmgr.h"

#include <shlwapi.h>
#include <regstr.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
//    OBJECT_ENTRY(CLSID_Ubj, CObj)
END_OBJECT_MAP()

extern CRITICAL_SECTION g_semDeviceMan;
extern CRITICAL_SECTION g_semEventNode;


//
//  Local variables and types definitions
//

//
// Event used for detecting previously started instance of the server
//
static HANDLE       ServerStartedEvent;

//
// Flag to use service controller PnP event sink vs window message based sink
//
extern BOOL         g_fUseServiceCtrlSink;

//
// Still Image entry in Registry
//

char* g_szStiKey = "SYSTEM\\CurrentControlSet\\Control\\StillImage";

//
// WIA Debug Window value name
//

char* g_szWiaDebugValue = "ShowWiaDebugWindow";

//
// String value to indicate that debug window should be shown
//

char* g_szShowWiaWinString = "Yes";

//
// Bool values indicating whether Critical Section initialization was successful
//
BOOL g_bEventCritSectInitialized    = FALSE;
BOOL g_bDevManCritSectInitialized   = FALSE;

//
//  Local prototypes
//

DWORD
InitGlobalConfigFromReg(
    VOID
    );

BOOL
DoGlobalInit(
    UINT        argc,
    LPTSTR      *argv
    );

BOOL
DoGlobalTermination(
    VOID
    );


BOOL
UpdateRunningServer(
    VOID
    );

HWND
CreateMasterWindow(
    VOID
    );

BOOL
StartMasterLoop(
    LPVOID lpv
    );

BOOL
StartOperation(
    VOID
    );

BOOL
ParseCommandLine(
    LPSTR   lpszCmdLine,
    UINT    *pargc,
    LPTSTR  *argv
    );

//
// Code section
//

extern "C"
BOOL
APIENTRY
DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved
    )
/*++

Routine Description:

   DllEntryPoint

   Main DLL entry point.

Arguments:

    hinst       - module instance
    dwReason    - reason called
    lpReserved  - reserved

Return Value:

    Status

Side effects:

    None

--*/

{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:

            DBG_INIT(hinst);
#if 0           
            #ifdef DEBUG
            StiSetDebugMask(0xffff);
            StiSetDebugParameters(TEXT("WIASERVC"),TEXT(""));
            #endif
#endif          

            g_hInst = hinst;
            ::DisableThreadLibraryCalls(hinst);

            _Module.Init(ObjectMap,hinst);
            break;

        case DLL_PROCESS_DETACH:

            _Module.Term();
            break;
    }
    return 1;
}

extern "C"
BOOL
APIENTRY
DllMain(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved
    )
{
    return DllEntryPoint(hinst,     dwReason,  lpReserved );
}


VOID
WINAPI
ServiceMain(
    UINT        argc,
    LPTSTR      *argv
)
/*++

Routine Description:

    Main initialization point of imaging services library

Arguments:

    argc    - counter of arguments
    argv    - arguments array

Return Value:

    None

Side effects:

    None

--*/
{

    DBG_FN(ServiceMain);

    //
    // Register our Service control handler.  Note that we must do this as early as possible.
    //
    if (!RegisterServiceControlHandler()) {
        goto ExitMain;
    }

    //
    // Do global initialization, independent of specific service
    //
    if (!DoGlobalInit(argc,argv)) {
        goto ExitMain;
    }

    //
    // Start running service
    //

    StartOperation();

ExitMain:

    //
    // Global cleanup
    //
    DoGlobalTermination();

    UpdateServiceStatus(SERVICE_STOPPED,NOERROR,0);
} /* Endproc ServiceMain */


BOOL
DoGlobalInit(
    UINT        argc,
    LPTSTR      *argv
    )
/*++

Routine Description:

    Perform one time service initialization

Arguments:

    None

Return Value:

    None.

--*/
{

    DBG_FN(DoGlobalInit);

    //
    // To use built-in ATL conversion macros
    //

    USES_CONVERSION;

#ifdef DEBUG

    //
    // Create a debug context.
    //

    #define VALUE_SIZE 5
    char    valueData[VALUE_SIZE];
    DWORD   retVal, type = 0, size = VALUE_SIZE;

    //
    // Search the registry
    //

    retVal = SHGetValueA(HKEY_LOCAL_MACHINE,
                         g_szStiKey,
                         g_szWiaDebugValue,
                         &type,
                         valueData,
                         &size);

    //
    // Found the entry in the registry
    //

    BOOLEAN bDisplayUi = FALSE;

    if (retVal == ERROR_SUCCESS) {

        //
        // Compare value found in registry to g_szShowWinString
        // If same, then show it
        //

        if (lstrcmpiA(g_szShowWiaWinString, valueData) == 0) {
            bDisplayUi = TRUE;
        }
    }

    //remove
    //WIA_DEBUG_CREATE( g_hInst,
    //                  TEXT("OLD Debugging/TRACE Window (STI/WIA Service)"),
    //                  bDisplayUi,
    //                  FALSE);

#endif

    //
    // Initialize COM.
    //

    HRESULT hr = CoInitializeEx(0,COINIT_MULTITHREADED);
    if (FAILED(hr)) {
        #ifdef DEBUG
            OutputDebugString(TEXT("DoGlobalInit, CoInitializeEx failed\n"));
        #endif
        return FALSE;
    }

    //
    // Initialize our global critical sections...
    //
    __try {

        //
        // Initialize the critical sections.
        //
        if (InitializeCriticalSectionAndSpinCount(&g_semDeviceMan, MINLONG)) {
            g_bDevManCritSectInitialized = TRUE;
        }
        if (InitializeCriticalSectionAndSpinCount(&g_semEventNode, MINLONG)) {
            g_bEventCritSectInitialized = TRUE;
        }

        if(!g_bDevManCritSectInitialized || !g_bEventCritSectInitialized)
        {
            #ifdef DEBUG
                OutputDebugString(TEXT("DoGlobalInit, InitializeCriticalSectionAndSpinCount failed\n"));
            #endif
            return FALSE;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // Couldn't initialize critical sections - this is really bad,
        // so bail
        //

        #ifdef DEBUG
            OutputDebugString(TEXT("DoGlobalInit, InitializeCriticalSectionAndSpinCount threw an exception!\n"));
        #endif
        return FALSE;
    }

    //
    // Setup some global variables from the registry.
    //

    #ifndef WINNT
    g_fRunningAsService  = FALSE;
    #endif

    InitGlobalConfigFromReg();

    //
    // Create event log class object
    //

    g_EventLog = new EVENT_LOG(TEXT("StillImage"));
    if (!g_EventLog) {
        #ifdef DEBUG
            OutputDebugString(TEXT("DoGlobalInit, unable to allocate EVENT_LOG\n"));
        #endif
        return FALSE;
    }

    //
    // Create file log class object, requesting truncating file if set by user
    //

    g_StiFileLog = new STI_FILE_LOG(TEXT("STISVC"),NULL,STIFILELOG_CHECK_TRUNCATE_ON_BOOT, g_hInst);
    if (g_StiFileLog) {
        if(g_StiFileLog->IsValid()) {
          // Set UI bit in reporting
            if (g_fUIPermitted) {
                g_StiFileLog->SetReportMode(g_StiFileLog->QueryReportMode()  | STI_TRACE_LOG_TOUI);
            }
        }
        else {
            #ifdef DEBUG
                OutputDebugString(TEXT("DoGlobalInit, could not open log file\n"));
            #endif
            return FALSE;
        }
    }
    else {
        #ifdef DEBUG
            OutputDebugString(TEXT("DoGlobalInit, unable to allocate STI_FILE_LOG\n"));
        #endif
        return FALSE;
    }

    //
    // Start Logging object's class factory
    //

    hr = StartLOGClassFactories();

    if (SUCCEEDED(hr)) {

        //
        // Create COM Logging Object
        //

        IWiaLog *pWiaLog = NULL;
        
        hr = CWiaLog::CreateInstance(IID_IWiaLog,(void**)&g_pIWiaLog);
        if (SUCCEEDED(hr)) {
            g_pIWiaLog->InitializeLogEx((BYTE*)g_hInst);
            DBG_TRC(("Starting STI/WIA Service..."));
        } else {
            #ifdef DEBUG
                OutputDebugString(TEXT("Failed to QI for IWiaLogEx...\n"));
            #endif
            return FALSE;
        }
    } else {
        return FALSE;
    }

    //
    //  Initialize the lock manager
    //

    g_pStiLockMgr = new StiLockMgr();
    if (g_pStiLockMgr) {

        hr = g_pStiLockMgr->Initialize();
        if (FAILED(hr)) {
            #ifdef DEBUG
                OutputDebugString(TEXT("DoGlobalInit, could not initialize Lock Manager\n"));
            #endif
            return FALSE;
        }
    } else {
        #ifdef DEBUG
            OutputDebugString(TEXT("DoGlobalInit, unable to allocate Lock Manager\n"));
        #endif
        return FALSE;
    }
    //
    // Initialize work item scheduler
    //

    SchedulerInitialize();

    //
    //  Create DeviceList event.
    //
    g_hDevListCompleteEvent = CreateEvent( NULL,           //  lpsaSecurity
                                           TRUE,           //  fManualReset
                                           FALSE,          //  fInitialState
                                           NULL );         //  lpszEventName
    if( g_hDevListCompleteEvent == NULL ) {
        return FALSE;
    }


    //
    // Create and initialize global Device Manager
    //

    g_pDevMan = new CWiaDevMan();
    if (g_pDevMan) {
        hr = g_pDevMan->Initialize();
        if (SUCCEEDED(hr)) {
            hr = g_pDevMan->ReEnumerateDevices(DEV_MAN_FULL_REFRESH | DEV_MAN_STATUS_STARTP);
            if (FAILED(hr)) {
                DBG_ERR(("::DoGlobalInit, unable to enumerate devices"));
            }
        } else {
            DBG_ERR(("::DoGlobalInit, unable to initialize WIA device manager"));
        }
    } else {
        DBG_ERR(("::DoGlobalInit, Out of memory, could not create WIA device manager"));
        return FALSE;
    }

    //
    //  Create and initialize global message handler
    //

    g_pMsgHandler = new CMsgHandler();
    if (g_pMsgHandler) {
        hr = g_pMsgHandler->Initialize();
        if (FAILED(hr)) {
            DBG_ERR(("::DoGlobalInit, unable to initialize internal Message handler"));
        }
    } else {
        DBG_ERR(("::DoGlobalInit, Out of memory, could not create internal Message handler"));
        return FALSE;
    }

    //
    //  Initialize the Wia Service controller
    //

    hr = CWiaSvc::Initialize();
    if (FAILED(hr)) {
        #ifdef DEBUG
            OutputDebugString(TEXT("DoGlobalInit, unable to initialize Wia Service controller\n"));
        #endif
        return FALSE;
    }

    //
    // Read the command line arguments and set global data.
    //

    for (UINT uiParam = 0; uiParam < argc; uiParam ++ ) {

        switch (*argv[uiParam]) {
            case TEXT('A'): case TEXT('a'):
                // Running as user mode process
                g_fRunningAsService  = FALSE;
                break;
            case TEXT('V'): case TEXT('v'):
                // Service UI is allowed
                g_fUIPermitted  = TRUE;
                break;
        }
    }

    //
    // Do misc. cleanup, which we need to do on startup  .
    //
    // 1. Some shipping packages for Win98 register STIMON entry to Run section, which
    //    after upgrade creates problem with racing two copies of STIMON. Remove it.
    //

    {
        HKEY    hkRun = NULL;
        LONG    lRet ;
        LONG    lcbValue = 0;
        BOOL    fNeedToRegister = FALSE;

        if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUN, &hkRun) == NO_ERROR) {

            DBG_TRC(("Removing erroneous entry on cleanup: HKLM\\..\\Run\\%S",REGSTR_VAL_MONITOR));

            lRet = RegQueryValue(hkRun,REGSTR_VAL_MONITOR,NULL,&lcbValue);

            fNeedToRegister = (lRet == NOERROR);

            RegDeleteValue (hkRun, REGSTR_VAL_MONITOR);
            RegCloseKey(hkRun);
        }

        // If needed register service
        if (fNeedToRegister ) {
            StiServiceInstall(NULL,NULL);
        }
    }

    return TRUE;
}

BOOL
DoGlobalTermination(
    VOID
    )
/*++

Routine Description:

    Final termination

Arguments:

    None

Return Value:

    None.

--*/
{
    DBG_FN(DoGlobalTermination);

    //
    // Terminate work item scheduler
    //
    SchedulerTerminate();

    //
    // Delete the lock manager (which also removes it from the ROT)
    //

    if (g_pStiLockMgr) {
        delete g_pStiLockMgr;
        g_pStiLockMgr = NULL;
    }

    //
    // Delete global device manager
    //
    if (g_pDevMan) {
        delete g_pDevMan;
        g_pDevMan = NULL;
    }

    //
    // Close hDevListRefreshCompleteEvent event handle
    //
    CloseHandle(g_hDevListCompleteEvent);
    g_hDevListCompleteEvent = NULL;

    //
    // Release WIA Logging object
    //

    if(g_pIWiaLog) {
        DBG_TRC(("Exiting STI/WIA Service..."));

        if (g_pIWiaLog) {
            g_pIWiaLog->Release();
        }
        g_pIWiaLog = NULL;
    }

    if(g_EventLog) {
        delete g_EventLog;
        g_EventLog = NULL;
    }

    if (g_StiFileLog) {
        delete g_StiFileLog;
        g_StiFileLog = NULL;
    }

    if (ServerStartedEvent) {
        ::CloseHandle(ServerStartedEvent);
    }

    //
    // Shut down message loop
    //

    ::PostQuitMessage(0);

    //
    // Uninitialize COM.
    //

    ::CoUninitialize();

    if (g_bEventCritSectInitialized) {
        DeleteCriticalSection(&g_semEventNode);
    }
    if (g_bDevManCritSectInitialized) {
        DeleteCriticalSection(&g_semDeviceMan);
    }

    //
    // Destroy the debug context.
    //

//    WIA_DEBUG_DESTROY();

    return TRUE;
}

//
// Guard to avoid reentrance in refresh routine
//
static LONG lRunningMessageLoop = 0L;

HANDLE
CreateMessageLoopThread(
    VOID
    )
/*++

Routine Description:

    Running primary service thread.
    If process is running as NT service, we don't have any messages to
    pump, so call it synchronously.
Arguments:

Return Value:

    None.

--*/
{
    if (InterlockedExchange(&lRunningMessageLoop,1L)) {
        return 0;
    }
    HANDLE  hThread = NULL;

#ifndef WINNT

    hThread = ::CreateThread(NULL,
                          0,
                          (LPTHREAD_START_ROUTINE)StartMasterLoop,
                          (LPVOID)NULL,
                          0,
                          &g_dwMessagePumpThreadId);

#else
    StartMasterLoop(NULL);
#endif

    return hThread;
}

BOOL
StartMasterLoop(
    LPVOID  lpParam
    )
/*++

Routine Description:

    Running primary service thread

Arguments:

Return Value:

    None.

--*/
{
    MSG msg;

    DBG_FN(StartMasterLoop);

    //
    // If visible create master window
    //

    CreateMasterWindow();

    VisualizeServer(g_fUIPermitted);

    //
    // Initialize WIA.
    //

    InitWiaDevMan(WiaInitialize);

#ifndef WINNT
    //Don't use windows messaging on NT

    //
    // Run message pump
    //
    while(GetMessage(&msg,NULL,0,0)) {

        //
        // Give WIA the first chance at dispatching messages. Note that
        // WIA hooks both message dispatch and the window proc. so that
        // both posted and sent messages can be detected.
        //
        //
        // currently there are no cases where sti needs to dispatch messages
        // to wia. Events are now dealt with directly.
        //

        #if 0

            if (DispatchWiaMsg(&msg) == S_OK) {
                continue;
            }

        #endif

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Indicate we are entering shutdown
    g_fServiceInShutdown = TRUE;

    InterlockedExchange(&lRunningMessageLoop,0L);
#endif

    return TRUE;

} // StartMasterLoop

BOOL
StartOperation(
    VOID
    )
/*++

Routine Description:

    Running primary service thread.
    If process is running as NT service, separate thread is created to
    handle window messages. This is necessary because primary thread becomes
    blocked as a control dispatcher , but we still need to have message loop
    running to deliver window messages.

Arguments:

Return Value:

    None.

--*/
{
    DBG_FN(StartOperation);

    DWORD   dwError;

    #ifdef MAXDEBUG
    DBG_TRC(("Start operation entered"));
    #endif

    if (g_fRunningAsService) {

        //
        // If UI is permitted - create visible window
        // Note that we always create window for now, to allow hiding/unhiding it dynamically
        //
        g_hMessageLoopThread = CreateMessageLoopThread();

        // !!!??? need to pass command line args down from svchost.
        StiServiceMain(0, NULL);

        if ( g_hMessageLoopThread ) {
            ::CloseHandle(g_hMessageLoopThread);
            g_hMessageLoopThread = NULL;
        }

    }
    else {
        //
        // Running as application
        //

        // First thing - allow PnP sink to register properly
        g_fUseServiceCtrlSink = FALSE;


        dwError = StiServiceInitialize();

        g_dwMessagePumpThreadId = GetCurrentThreadId();

        StartMasterLoop(NULL);

        StiServiceStop();
    }

    return TRUE;

} // StartOperation

BOOL
VisualizeServer(
    BOOL    fVisualize
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{

    g_fUIPermitted = fVisualize;

    if (::IsWindow(g_hMainWindow)) {
        ::ShowWindow(g_hMainWindow,fVisualize ? SW_SHOWNORMAL : SW_HIDE);
    }

    if (g_StiFileLog) {
        if(g_StiFileLog->IsValid()) {
          // Set UI bit in reporting
            if (g_fUIPermitted) {
                g_StiFileLog->SetReportMode(g_StiFileLog->QueryReportMode()  | STI_TRACE_LOG_TOUI);
            }
        }
    }

    return TRUE;
}

BOOL
UpdateRunningServer(
    VOID
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

--*/

{

    HWND        hExistingWindow;

    hExistingWindow = FindWindow(g_szClass,NULL);

    if (!hExistingWindow) {
        return FALSE;
    }

    DBG_TRC(("Updating running service with refresh parameters"));

    //
    // Server already running , find it 's window and send a message
    // with new values of parameters
    //
    ::ShowWindow(hExistingWindow,g_fUIPermitted ? SW_SHOWNORMAL : SW_HIDE);

    // Refresh requested ?
    if (g_fRefreshDeviceList) {
        // Refresh device list
        ::PostMessage(hExistingWindow,STIMON_MSG_REFRESH,1,0L);
    }

    if (STIMON_AD_DEFAULT_POLL_INTERVAL != g_uiDefaultPollTimeout) {
        ::SendMessage(hExistingWindow,STIMON_MSG_SET_PARAMETERS,STIMON_MSG_SET_TIMEOUT,g_uiDefaultPollTimeout);
    }

    return TRUE;
}


STDAPI
DllRegisterServer(
    VOID
    )
{
    StiServiceInstall(NULL,NULL);

    InitWiaDevMan(WiaRegister);

    return S_OK;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllUnregisterServer |
 *
 *          Unregister our classes from OLE/COM/ActiveX/whatever its name is.
 *
 *****************************************************************************/

STDAPI
DllUnregisterServer(
    VOID
    )
{
    InitWiaDevMan(WiaUnregister);

    StiServiceRemove();

    return S_OK;

}

//
//  Methods needed for linking to STIRT (stiobj.c calls these).
//  Some of these methods are simply dummies.
//

#ifdef __cplusplus
extern "C" {
#endif

BOOL
EXTERNAL
DllInitializeCOM(
    void
    )
{
    //
    // Initialize COM.
    //

    HRESULT hr = CoInitializeEx(0,COINIT_MULTITHREADED);
    if (FAILED(hr)) {
        return FALSE;
    }

    return TRUE;
}

BOOL EXTERNAL
DllUnInitializeCOM(
    void
    )
{
    //
    // Uninitialize COM
    //

    CoUninitialize();

    return TRUE;
}

void EXTERNAL
DllAddRef(void)
{
    return;
}

void EXTERNAL
DllRelease(void)
{
    return;
}

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\stiexe.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stiexe.h

Abstract:

    Main header file


Author:

    Vlad Sadovsky (vlads)   10-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    26-Jan-1997     VladS       created
    30-Sep-1997     VladS       Added SCM glue layer
    13-Apr-1999     VladS       merged with WIA service code

--*/


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

//
// Additional ATL headers
//



#define IS_32

#include <dbt.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <cfgmgr32.h>
#include "stipriv.h"

#ifdef __cplusplus
};
#endif

#ifdef DEFINE_GLOBAL_VARIABLES
#include <initguid.h>
#endif


#include <stistr.h>


#include "enum.h"
#include "wiamindr.h"
#include "globals.h"

#include "stismsg.h"
#include "resource.h"
#include "sched.h"
#include "util.h"
#include "stismsg.h"
#include "drvwrap.h"
#include "device.h"
#include "stiapi.h"
#include "wiapriv.h"
#include "wiaprivd.h"
#include "wiadevman.h"
#include "helpers.h"
#include "wiasvc.h"

//
// StiRT helper functions
//

typedef LPVOID      PV, *PPV;

#ifdef __cplusplus
    extern "C" {
#endif

extern STDMETHODIMP StiPrivateGetDeviceInfoHelperW(
    LPWSTR  pwszDeviceName,
    LPVOID  *ppBuffer
    );

extern STDMETHODIMP StiCreateHelper(
    HINSTANCE hinst,
    DWORD       dwVer,
    LPVOID      *ppvObj,
    LPUNKNOWN   punkOuter,
    REFIID      riid
    );

extern STDMETHODIMP NewDeviceControl(
    DWORD               dwDeviceType,
    DWORD               dwMode,
    LPCWSTR             pwszPortName,
    DWORD               dwFlags,
    PSTIDEVICECONTROL   *ppDevCtl);

#ifdef __cplusplus
    }
#endif

//
// RPC server helper functions
//
RPC_STATUS
StopRpcServerListen(
    VOID
    );

RPC_STATUS
StartRpcServerListen(
    VOID);


extern SERVICE_TABLE_ENTRY ServiceDispatchTable[];

//
// Service controller glue layer
//
DWORD
StiServiceInstall(
    LPTSTR  lpszUserName,
    LPTSTR  lpszUserPassword
    );

DWORD
StiServiceRemove(
    VOID
    );

BOOL 
RegisterServiceControlHandler(
    );

VOID
WINAPI
StiServiceMain(
    IN DWORD    argc,
    IN LPTSTR   *argv
    );

HWND
CreateServiceWindow(
    VOID
    );

LRESULT
CALLBACK
StiSvcWinProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    );

VOID
WINAPI
StiServiceMain(
    IN DWORD    argc,
    IN LPTSTR   *argv
    );

VOID
StiServiceStop(
    VOID
    );

VOID
StiServicePause(
    VOID
    );

VOID
StiServiceResume(
    VOID
    );


DWORD
WINAPI
UpdateServiceStatus(
        IN DWORD dwState,
        IN DWORD dwWin32ExitCode,
        IN DWORD dwWaitHint );

DWORD
StiServiceInitialize(
    VOID
    );

BOOL
VisualizeServer(
    BOOL    fVisualize
    );

//
//  Message worker functions
//

DWORD
StiWnd_OnPowerControlMessage(
    HWND    hwnd,
    DWORD   dwPowerEvent,
    LPARAM  lParam
    );

LRESULT
StiWnd_OnDeviceChangeMessage(
    HWND    hwnd,
    UINT    DeviceEvent,
    LPARAM  lParam
    );

VOID
WINAPI
StiMessageCallback(
    VOID *pArg
    );

LRESULT
StiSendMessage(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam
);

BOOL
StiPostMessage(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam
);

//
//  UI and debugging
//
BOOL
SizeDiff(
    HWND    hWnd,
    UINT    wMsgID,
    WPARAM  wParam,
    LPARAM lParam
    );

BOOL
HScroll(
    HWND    hWnd,
    UINT    wMsgID,
    WPARAM  wParam,
    LPARAM lParam
    );

BOOL
VScroll(
    HWND    hWnd,
    UINT    wMsgID,
    WPARAM  wParam,
    LPARAM lParam
    );

void
__cdecl
StiMonWndDisplayOutput(
    LPTSTR pString,
    ...
    );

void
__cdecl
vStiMonWndDisplayOutput(
    LPTSTR pString,
    va_list arglist
    );


#ifdef SHOWMONUI

#define STIMONWPRINTF   StiMonWndDisplayOutput

#else
// Nb: Following definition is needed to avoid compiler complaining
// about empty function name in expression. In retail builds using this macro
// will cause string parameters not appear in executable
//
#define STIMONWPRINTF     1?(void)0 : (void)

#endif

//
// Tracing function
//
void
WINAPI
StiLogTrace(
    DWORD   dwType,
    LPTSTR   lpszMessage,
    ...
    );

void
WINAPI
StiLogTrace(
    DWORD   dwType,
    DWORD   idMessage,
    ...
    );

//
//  Utils
//

BOOL
IsStillImagePnPMessage(
    PDEV_BROADCAST_HDR  pDev
    );


//
// WIA device manager initialization actions, for use with InitWiaDevMan.
//

typedef enum _WIA_SERVICE_INIT_ACTION {
    WiaInitialize = 0,
    WiaRegister,
    WiaUnregister,
    WiaUninitialize
} WIA_SERVICE_INIT_ACTION, *PWIA_SERVICE_INIT_ACTION;

//
// WIA entry points called by the STI service.
//

HRESULT DispatchWiaMsg(MSG*);
HRESULT ProcessWiaMsg(HWND, UINT, WPARAM, LPARAM);
HRESULT InitWiaDevMan(WIA_SERVICE_INIT_ACTION);
HRESULT NotifyWiaDeviceEvent(LPWSTR, const GUID*, PBYTE, ULONG, DWORD);
HRESULT StartLOGClassFactories();

//
// STI entry points in wiaservc.dll, called by the WIA device manager.
//

HRESULT      WiaUpdateDeviceInfo();

class STI_MESSAGE : public IUnknown
{
public:

    //
    //  IUnknown methods needed for Scheduler thread
    //

    HRESULT _stdcall QueryInterface(
        REFIID iid,
        void **ppvObject)
    {
        return E_NOTIMPL;
    };

    ULONG _stdcall AddRef()
    {
        InterlockedIncrement(&m_cRef);
        return m_cRef;
    };

    ULONG _stdcall Release()
    {
        LONG    lRef = InterlockedDecrement(&m_cRef);

        if (lRef < 1) {
            delete this;
            lRef = 0;;
        }

        return lRef;
    };

    STI_MESSAGE(UINT    uMsg,
                WPARAM  wParam,
                LPARAM  lParam
                )
    {
        m_uMsg      = uMsg;
        m_wParam    = wParam;
        m_lParam    = lParam;
        m_cRef      = 0;
    };

    ~STI_MESSAGE()
    {
    }

public:
    LONG    m_cRef;
    UINT    m_uMsg;
    WPARAM  m_wParam;
    LPARAM  m_lParam;
};

//
// Macros
//

#ifndef USE_WINDOWS_MESSAGING
    #undef SendMessage
    #undef PostMessage
    #define SendMessage StiSendMessage
    #define PostMessage StiPostMessage
#endif

//
// Shutdown event
//
extern HANDLE  hShutdownEvent;

//
// Array of non Image device interfaces we listen on
//

#define NOTIFICATION_GUIDS_NUM  16

extern const GUID        g_pguidDeviceNotificationsGuidArray[];

//
// Array of initialized notificaiton sinks for non Image interfaces
//
extern       HDEVNOTIFY  g_phDeviceNotificationsSinkArray[NOTIFICATION_GUIDS_NUM];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\util.cpp ===
/*++


Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    UTIL.CPP

Abstract:

    Utility functions

Author:

    Vlad  Sadovsky  (vlads)     4-20-97

Revision History:



--*/

//
// Headers
//
#include "precomp.h"

#include "stiexe.h"

#include <windowsx.h>

#include <setupapi.h>
#include <devguid.h>

#include "device.h"

#define PNP_WORKS   1

CONFIGRET
WINAPI
PrivateLocateDevNode(
    DEVNODE     *pDevNode,
    LPTSTR      szDevDriver,
    LPCTSTR     pszDeviceName
    );

//
// Code
//

BOOL
IsStillImagePnPMessage(
                      PDEV_BROADCAST_HDR  pDev
                      )
/*++

Routine Description:

    Returns TRUE if devnode is associated with StillImage class of devices
Arguments:

    None.

Return Value:

    None.

--*/
{
    CONFIGRET   cr;

    TCHAR        szClassString[MAX_PATH];

    PDEV_BROADCAST_DEVNODE  pDevNode = (PDEV_BROADCAST_DEVNODE)pDev;
    PDEV_BROADCAST_DEVICEINTERFACE       pDevInterface = (PDEV_BROADCAST_DEVICEINTERFACE)pDev;
    PDEV_BROADCAST_HANDLE  pDevHandle = (PDEV_BROADCAST_HANDLE)pDev;

    HKEY        hKeyDevice = NULL;
    DEVNODE     dnDevNode = NULL;

    BOOL        fRet = FALSE;
    ULONG       ulType;
    DWORD       dwSize = 0;

    if ( (pDev->dbch_devicetype == DBT_DEVTYP_DEVNODE) && pDevNode ) {

        DBG_TRC(("IsStillImagePnPMessage - DeviceType = DEVNODE, "
                 "verifying if this is our device..."));

        dnDevNode = pDevNode->dbcd_devnode;

        //
        // Nb: CM APIs take  number of bytes vs number of characters .
        //
        dwSize = sizeof(szClassString);
        *szClassString = TEXT('\0');
        cr = CM_Get_DevNode_Registry_PropertyA(dnDevNode,
                                               CM_DRP_CLASS,
                                               &ulType,
                                               szClassString,
                                               &dwSize,
                                               0);

        DBG_TRC(("IsStillImagePnPMessage::Class name found :%S", szClassString));

        if ((CR_SUCCESS != cr) || ( lstrcmpi(szClassString,CLASSNAME) != 0 ) ) {
            DBG_WRN(("IsStillImagePnPMessage::Class name did not match"));
            return FALSE;
        }

        //
        // Now read class from software key
        //
        cr = CM_Open_DevNode_Key(dnDevNode,
                                 KEY_READ,
                                 0,
                                 RegDisposition_OpenExisting,
                                 &hKeyDevice,
                                 CM_REGISTRY_SOFTWARE
                                );

        if (CR_SUCCESS != cr) {
            DBG_ERR(("IsStillImagePnPMessage::Failed to open dev node key"));
            return FALSE;
        }

        dwSize = sizeof(szClassString);
        if (RegQueryValueEx(hKeyDevice,
                            REGSTR_VAL_USD_CLASS,
                            NULL,
                            NULL,
                            (UCHAR *)szClassString,
                            &dwSize) == ERROR_SUCCESS) {
            fRet = TRUE;
        }

        RegCloseKey(hKeyDevice);

        /*
        if ((CR_SUCCESS != cr) ||
            lstrcmpi(STILLIMAGE,szDevNodeClass)
            ) {
            return FALSE;
        }
        */

    }
    else {

        fRet = FALSE;

        if ( (pDev->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE) && pDevInterface) {

            DBG_TRC(("IsStillImagePnPMessage - DeviceType = DEVICEINTERFACE, "
                     "verifying if this is our device..."));
            //
            // First check if it is our GUID
            //
            if ( IsEqualIID(pDevInterface->dbcc_classguid,GUID_DEVCLASS_IMAGE)) {

                DBG_TRC(("IsStillImagePnPMessage::Class GUID matched for device "
                         "interface '%ls' - must be ours", pDevInterface->dbcc_name));

                return TRUE;
            }

            TCHAR *pszDevInstance = NULL;

            //
            // We have the interface name but we need the device instance
            // name to call CM_Locate_DevNode.  
            //
            // Notice that this function will return a pointer to allocated
            // memory so it must be freed when you are finished using it.
            //
            ConvertDevInterfaceToDevInstance(&pDevInterface->dbcc_classguid,
                                             pDevInterface->dbcc_name,
                                             &pszDevInstance);

            if (pszDevInstance) {

                DBG_TRC(("IsStillImagePnPMessage, converted Device Interface '%ls' "
                         "to Device Instance '%ls'", 
                         pDevInterface->dbcc_name, pszDevInstance));

                cr = CM_Locate_DevNode(&dnDevNode,
                                       pszDevInstance,
                                       CM_LOCATE_DEVNODE_NORMAL |
                                       CM_LOCATE_DEVNODE_PHANTOM);

                delete [] pszDevInstance;

                if (CR_SUCCESS != cr) {
                    DBG_WRN(("LocateDevNode failed. cr=%x",cr));
                    return FALSE;
                }
                else {
                    DBG_TRC(("IsStillImagePnPMessage - found DevNode for device instance "
                             "'%ls'", pszDevInstance));
                }

            }
            else {
                DBG_WRN(("Failed to Convert Dev Interface to Dev Instance, "
                         "Last Error = %lu", GetLastError()));

                return FALSE;
            }

            dwSize = sizeof(szClassString);
            cr = CM_Get_DevNode_Registry_Property(dnDevNode,
                                                  CM_DRP_CLASS,
                                                  &ulType,
                                                  szClassString,
                                                  &dwSize,
                                                  0);

            if (CR_SUCCESS != cr) {
                DBG_WRN(("ReadRegValue failed for dev node : DevNode(%X) ValName(DRP_CLASS),cr(%X)  ",
                         dnDevNode,
                         cr));
            }

            if ((CR_SUCCESS != cr) || (lstrcmpi(szClassString, TEXT("Image")) != 0)) {
                return FALSE;
            }
            else {
                DBG_TRC(("IsStillImagePnPMessage - found Class=Image for device "
                         "interface '%ls'", pDevInterface->dbcc_name));
            }

            //
            // Now read subclass from software key
            //
            cr = CM_Open_DevNode_Key(dnDevNode,
                                     KEY_READ,
                                     0,
                                     RegDisposition_OpenExisting,
                                     &hKeyDevice,
                                     CM_REGISTRY_SOFTWARE
                                    );

            if (CR_SUCCESS != cr) {
                DBG_WRN(("OpenDevNodeKey failed. cr=%x",cr));
            }

            if (CR_SUCCESS != cr) {
                return FALSE;
            }

            dwSize = sizeof(szClassString);
            if ((RegQueryValueEx(hKeyDevice,
                                 REGSTR_VAL_SUBCLASS,
                                 NULL,
                                 NULL,
                                 (UCHAR *)szClassString,
                                 &dwSize) == ERROR_SUCCESS) &&
                (lstrcmpi(szClassString, STILLIMAGE) == 0)) {
                fRet = TRUE;

                DBG_TRC(("IsStillImagePnPMessage - found SubClass=StillImage for "
                         "device interface '%ls'.  This is a still image device.", 
                         pDevInterface->dbcc_name));

                // Skip this one.
                //
            }

            RegCloseKey(hKeyDevice);

            return fRet;
        }
        else if ( (pDev->dbch_devicetype == DBT_DEVTYP_HANDLE ) && pDevHandle) {
            //
            // Targeted broadcasts are ours always because we don't register on service window
            // for any other targeted notifications.
            // Otherwise we would need to match embedded handle vs list of devices waiting for
            // notifications
            //

            DBG_TRC(("IsStillImagePnPMessage - DeviceType = HANDLE - this event "
                     "is ours for sure"));

            return TRUE;
        }
    }

    return fRet;

} // IsStillImageMessage

BOOL
GetDeviceNameFromDevBroadcast(
                             DEV_BROADCAST_HEADER *psDevBroadcast,
                             DEVICE_BROADCAST_INFO *pBufDevice
                             )
/*++

Routine Description:

    Return device name , used for opening device , obtained from dev node

Arguments:

    None.

Return Value:

    None.

Caveats:

    Relies on the fact that STI names are identical to internal device names
    used by PnP subsystem

--*/
{
    USES_CONVERSION;

    PDEV_BROADCAST_DEVICEINTERFACE  pDevInterface = (PDEV_BROADCAST_DEVICEINTERFACE)psDevBroadcast;
    PDEV_BROADCAST_HANDLE  pDevHandle = (PDEV_BROADCAST_HANDLE)psDevBroadcast;
    PDEV_BROADCAST_DEVNODE  pDevNode = (PDEV_BROADCAST_DEVNODE)psDevBroadcast;

    TCHAR           szDevNodeDriver[STI_MAX_INTERNAL_NAME_LENGTH] = {0};
    BOOL            bSuccess        = TRUE;
    CONFIGRET       cr              = CR_SUCCESS;
    ULONG           ulType          = 0;
    DEVNODE         dnDevNode       = NULL;
    DWORD           dwSize          = 0;
    TCHAR           *pszDevInstance = NULL;
    HKEY            hkDevice        = NULL;
    LONG            lResult         = ERROR_SUCCESS;
    DWORD           dwType          = REG_SZ;
    ACTIVE_DEVICE   *pDeviceObject  = NULL;

    switch (psDevBroadcast->dbcd_devicetype) {
        case DBT_DEVTYP_DEVNODE:

            DBG_WRN(("GetDeviceNameFromDevBroadcast, devicetype = DEVNODE"));

            dnDevNode = pDevNode->dbcd_devnode;

            //
            // Get proper device ID from registry.
            //
            if (bSuccess) {
                cr = CM_Open_DevNode_Key_Ex(dnDevNode,
                                            KEY_READ,
                                            0,
                                            RegDisposition_OpenExisting,
                                            &hkDevice,
                                            CM_REGISTRY_SOFTWARE,
                                            NULL);

                if ((cr != CR_SUCCESS) || (hkDevice == NULL)) {
                    DBG_WRN(("CM_Open_DevNode_Key_Ex failed. cr=0x%x",cr));
                    bSuccess = FALSE;
                }
            }

            if (bSuccess) {
                dwType = REG_SZ;
                dwSize = sizeof(szDevNodeDriver);

                lResult = RegQueryValueEx(hkDevice,
                                          REGSTR_VAL_DEVICE_ID,
                                          0,
                                          &dwType,
                                          (LPBYTE) szDevNodeDriver,
                                          &dwSize);

                if (lResult != ERROR_SUCCESS) {
                    DBG_WRN(("RegQueryValueExA failed. lResult=0x%x",lResult));
                    bSuccess = FALSE;
                }
            }

            if (bSuccess) {
                pBufDevice->m_strDeviceName.CopyString(szDevNodeDriver);

                DBG_WRN(("GetDeviceNameFromDevBroadcast::returning device name %S",
                         szDevNodeDriver));
            }

            //
            // Close device registry key first.
            //
            if (hkDevice) {
                RegCloseKey(hkDevice);
                hkDevice = NULL;
            }

            break;

        case DBT_DEVTYP_HANDLE:

            DBG_WRN(("GetDeviceNameFromDevBroadcast, devicetype = HANDLE"));

            //
            // This is directed device broadcast.
            // We need to locate device object by embedded handles and
            // extract STI name from it
            //

            if (bSuccess) {
                pDeviceObject = g_pDevMan->LookDeviceFromPnPHandles(pDevHandle->dbch_handle,
                                                                    pDevHandle->dbch_hdevnotify);

                if (pDeviceObject) {
                    pBufDevice->m_strDeviceName.CopyString(W2T(pDeviceObject->GetDeviceID()));
                    pDeviceObject->Release();
                    bSuccess = TRUE;
                }
                else {
                    bSuccess = FALSE;
                    DBG_WRN(("GetDeviceNameFromDevBroadcast, DBT_DEVTYP_HANDLE: LookupDeviceByPnPHandles failed"));
                }
            }

            break;

        case DBT_DEVTYP_DEVICEINTERFACE:

            DBG_WRN(("GetDeviceNameFromDevBroadcast, devicetype = DEVICEINTERFACE"));

            //
            // We are given a device interface.
            // Convert this device interface into a device instance.
            //

            if (bSuccess) {
                ConvertDevInterfaceToDevInstance(&pDevInterface->dbcc_classguid,
                                                 pDevInterface->dbcc_name,
                                                 &pszDevInstance);

                if (pszDevInstance == NULL) {
                    bSuccess = FALSE;
                    DBG_WRN(("Failed to Convert Dev Interface to Dev Instance, "
                             "Last Error = %lu", GetLastError()));
                }
            }

            if (bSuccess) {
                //
                // Given the device instance, locate the DevNode associated 
                // with this device instace.
                //
                cr = CM_Locate_DevNode(&dnDevNode,
                                       pszDevInstance,
                                       CM_LOCATE_DEVNODE_NORMAL |
                                       CM_LOCATE_DEVNODE_PHANTOM);

                delete [] pszDevInstance;

                if (cr != CR_SUCCESS) {
                    DBG_WRN(("LocateDevNode failed. cr=%x",cr));
                    bSuccess = FALSE;
                }
            }

            //
            // Get proper device ID from registry.  By the time we reach here,
            // we've already checked that our dnDevNode is valid.
            //
            if (bSuccess) {
                cr = CM_Open_DevNode_Key_Ex(dnDevNode,
                                            KEY_READ,
                                            0,
                                            RegDisposition_OpenExisting,
                                            &hkDevice,
                                            CM_REGISTRY_SOFTWARE,
                                            NULL);

                if ((cr != CR_SUCCESS) || (hkDevice == NULL)) {
                    DBG_WRN(("CM_Open_DevNode_Key_Ex failed. cr=0x%x",cr));
                    bSuccess = FALSE;
                }
            }

            if (bSuccess) {
                dwType = REG_SZ;
                dwSize = sizeof(szDevNodeDriver);

                lResult = RegQueryValueEx(hkDevice,
                                          REGSTR_VAL_DEVICE_ID,
                                          0,
                                          &dwType,
                                          (LPBYTE)szDevNodeDriver,
                                          &dwSize);

                if (lResult != ERROR_SUCCESS) {
                    DBG_WRN(("RegQueryValueEx failed. lResult=0x%x", lResult));
                    bSuccess = FALSE;
                }
            }

            if (bSuccess) {
                pBufDevice->m_strDeviceName.CopyString(szDevNodeDriver);
                DBG_TRC(("GetDeviceNameFromDevBroadcast, returning Driver ID '%ls'", szDevNodeDriver));
            }

            //
            // Close device registry key first.
            //
            if (hkDevice) {
                RegCloseKey(hkDevice);
                hkDevice = NULL;
            }

            break;

        default:
            DBG_WRN(("GetDeviceNameFromDevBroadcast, received unrecognized "
                     "dbcd_devicetype = '%lu'", psDevBroadcast->dbcd_devicetype ));
            break;
    }

    return bSuccess;

} // GetDeviceNameFromDevBroadcast


BOOL
ConvertDevInterfaceToDevInstance(const GUID  *pClassGUID,
                                 const TCHAR *pszDeviceInterface, 
                                 TCHAR       **ppszDeviceInstance)
{
    HDEVINFO                    hDevInfo       = NULL;
    BOOL                        bSuccess       = TRUE;
    SP_INTERFACE_DEVICE_DATA    InterfaceDeviceData;
    SP_DEVINFO_DATA             DevInfoData;
    DWORD                       dwDetailSize   = 0;
    DWORD                       dwError        = NOERROR;
    DWORD                       dwInstanceSize = 0;
    CONFIGRET                   ConfigResult   = CR_SUCCESS;

    ASSERT(pClassGUID         != NULL);
    ASSERT(pszDeviceInterface != NULL);
    ASSERT(ppszDeviceInstance != NULL);

    if ((pClassGUID         == NULL) ||
        (pszDeviceInterface == NULL) ||
        (ppszDeviceInstance == NULL)) {
        return FALSE;
    }

    //
    // Create a devinfo list without any specific class.
    //
    hDevInfo = SetupDiGetClassDevs(pClassGUID,
                                   NULL,
                                   NULL,
                                   DIGCF_DEVICEINTERFACE);

    if (hDevInfo == INVALID_HANDLE_VALUE) {
        dwError = GetLastError();
        DBG_ERR(("ConvertDevInterfaceToDevInstance, SetupDiGetClassDevs "
                 "returned an error, LastError = %lu", dwError));

        return FALSE;
    }

    memset(&InterfaceDeviceData, 0, sizeof(SP_INTERFACE_DEVICE_DATA));

    InterfaceDeviceData.cbSize = sizeof(SP_INTERFACE_DEVICE_DATA);
    InterfaceDeviceData.Flags  = DIGCF_DEVICEINTERFACE;

    if (bSuccess) {
        bSuccess = SetupDiOpenDeviceInterface(hDevInfo, pszDeviceInterface, 0, &InterfaceDeviceData);

        if (!bSuccess) {
            dwError = GetLastError();
            DBG_ERR(("ConvertDevInterfaceToDevInstance, SetupDiOpenDeviceInterface failed, "
                     "Last Error = %lu", dwError));
        }
    }

    if (bSuccess) {
        memset(&DevInfoData, 0, sizeof(SP_DEVINFO_DATA));
        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        bSuccess = SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                                   &InterfaceDeviceData,
                                                   NULL,
                                                   0,
                                                   &dwDetailSize,
                                                   &DevInfoData);

        if (!bSuccess) {
            dwError = GetLastError();

            //
            // We don't care if we received an insufficient buffer.  We are 
            // only interested in the devinst field in this buffer anyway,
            // which is returned to us even on this error.
            //
            if (dwError == ERROR_INSUFFICIENT_BUFFER) {
                bSuccess = TRUE;
                dwError  = NOERROR;
            }
            else {
                DBG_ERR(("ConvertDevInterfaceToDevInstance, SetupDiGetDeviceInterfaceDetail "
                         "returned an error, LastError = %lu", dwError));
            }
        }
    }

    if (bSuccess) {
        ConfigResult = CM_Get_Device_ID_Size_Ex(&dwInstanceSize, 
                                                DevInfoData.DevInst, 
                                                0, 
                                                NULL);

        if (ConfigResult != CR_SUCCESS) {
            DBG_ERR(("ConvertDevInterfaceToDevInstance, CM_Get_DeviceID_Size_Ex "
                     "returned an error, ConfigResult = %lu", ConfigResult));

            bSuccess = FALSE;
        }
    }

    if (bSuccess) {
        *ppszDeviceInstance = new TCHAR[(dwInstanceSize + 1) * sizeof(TCHAR)];

        if (*ppszDeviceInstance == NULL) {
            bSuccess = FALSE;
            DBG_ERR(("ConvertDevInterfaceToDevInstance, memory alloc failure"));
        }
    }

    if (bSuccess) {
        memset(*ppszDeviceInstance, 0, (dwInstanceSize + 1) * sizeof(TCHAR));

        ConfigResult = CM_Get_Device_ID(DevInfoData.DevInst,
                                        *ppszDeviceInstance,
                                        dwInstanceSize + 1,
                                        0);

        if (ConfigResult == CR_SUCCESS) {
            DBG_WRN(("ConvertDevInterfaceToDevInstance successfully converted "
                     "Interface '%ls' to Instance '%ls'",
                     pszDeviceInterface, *ppszDeviceInstance));

            bSuccess = TRUE;
        }
        else {
            DBG_ERR(("ConvertDevInterfaceToDevInstance, CM_Get_Device_ID "
                     "returned an error, ConfigResult = %lu", ConfigResult));

            delete [] *ppszDeviceInstance;
            *ppszDeviceInstance = NULL;
            bSuccess = FALSE;
        }
    }

    if (hDevInfo) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    return bSuccess;
}

BOOL
GetDeviceNameFromDevNode(
    DEVNODE     dnDevNode,
    StiCString& strDeviceName
    )
/*++

Routine Description:

    Return device name , used for opening device , obtained from dev node

Arguments:

    None.

Return Value:

    None.

Caveats:

    Relies on the fact that STI names are identical to internal device names
    used by PnP subsystem

--*/
{

USES_CONVERSION;

    CONFIGRET   cr = 1;

    DWORD       cbLen,dwSize;
    CHAR        szDevNodeDriver[MAX_PATH];
    ULONG       ulType;

    #ifndef WINNT
    //
    // Get value from config manager
    //

    dwSize = sizeof(szDevNodeDriver);
    *szDevNodeDriver = TEXT('\0');
    cr = CM_Get_DevNode_Registry_PropertyA(dnDevNode,
                                          CM_DRP_DRIVER,
                                          &ulType,
                                          szDevNodeDriver,
                                          &dwSize,
                                          0);

    if (CR_SUCCESS != cr) {
        return FALSE;
    }

    strDeviceName.CopyString(A2CT(szDevNodeDriver));

    return TRUE;

    #else

    #pragma message("Routine not implemented on NT!")
    return FALSE;
    #endif


} // GetDeviceNameFromDevNode


CONFIGRET
WINAPI
PrivateLocateDevNode(
    DEVNODE     *pDevNode,
    LPTSTR      szDevDriver,
    LPCTSTR     pszDeviceName
    )
/*++

Routine Description:

    Locate internal STI name for device by broadcased name

Arguments:

Return Value:

    CR - defined return values

Caveats:

    Relies on the fact that STI names are identical to internal device names
    used by PnP subsystem

--*/
{

    CONFIGRET               cmRet = CR_NO_SUCH_DEVINST;

#ifdef WINNT

    HANDLE                  hDevInfo;
    SP_DEVINFO_DATA         spDevInfoData;
    SP_DEVICE_INTERFACE_DATA   spDevInterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pspDevInterfaceDetailData;

    BUFFER                  bufDetailData;

    //char                    szDevClass[32];

    ULONG                   cbData;

    GUID                    guidClass = GUID_DEVCLASS_IMAGE;

    DWORD                   dwRequired;
    DWORD                   dwSize;
    DWORD                   Idx;
    DWORD                   dwError;

    BOOL                    fRet;

    dwRequired = 0;

    bufDetailData.Resize(sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                         MAX_PATH * sizeof(TCHAR) +
                         16
                        );

    pspDevInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) bufDetailData.QueryPtr();

    if (!pspDevInterfaceDetailData) {
        return CR_OUT_OF_MEMORY;
    }

    hDevInfo = SetupDiGetClassDevs (&guidClass,
                                    NULL,
                                    NULL,
                                    //DIGCF_PRESENT |
                                    DIGCF_DEVICEINTERFACE
                                    );

    if (hDevInfo != INVALID_HANDLE_VALUE) {

        ZeroMemory(&spDevInfoData,sizeof(spDevInfoData));

        spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
        spDevInfoData.ClassGuid = GUID_DEVCLASS_IMAGE;

        pspDevInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) bufDetailData.QueryPtr();

        for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

            ZeroMemory(&spDevInterfaceData,sizeof(spDevInterfaceData));
            spDevInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
            spDevInterfaceData.InterfaceClassGuid = GUID_DEVCLASS_IMAGE;

            fRet = SetupDiEnumDeviceInterfaces (hDevInfo,
                                                NULL,
                                                &guidClass,
                                                Idx,
                                                &spDevInterfaceData);

            dwError = ::GetLastError();

            if (!fRet) {
                //
                // Failed - assume we are done with all devices of the class
                //
                break;
            }


            dwRequired = 0;
            pspDevInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

            fRet = SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                                   &spDevInterfaceData,
                                                   pspDevInterfaceDetailData,
                                                   bufDetailData.QuerySize(),
                                                   &dwRequired,
                                                   &spDevInfoData);
            dwError = ::GetLastError();

            if (!fRet) {
                continue;
            }

            if (lstrcmpi(pspDevInterfaceDetailData->DevicePath,pszDeviceName) == 0 ) {

                *szDevDriver = TEXT('\0');
                dwSize = cbData = STI_MAX_INTERNAL_NAME_LENGTH;

                //
                *pDevNode =spDevInfoData.DevInst;

                fRet = SetupDiGetDeviceRegistryProperty (hDevInfo,
                                                         &spDevInfoData,
                                                         SPDRP_DRIVER,
                                                         NULL,
                                                         (LPBYTE)szDevDriver,
                                                         STI_MAX_INTERNAL_NAME_LENGTH,
                                                         &cbData
                                                         );

                dwError = ::GetLastError();

                cmRet = ( fRet ) ? CR_SUCCESS : CR_OUT_OF_MEMORY;
                break;
            }

        }

        //
        SetupDiDestroyDeviceInfoList (hDevInfo);

    }

#endif

    return cmRet;

}

/*
<    if (CM_Get_DevNode_Key( phwi -> dn, NULL, szDevNodeCfg,
<                            sizeof( szDevNodeCfg ),
<                            CM_REGISTRY_SOFTWARE ))

*/

#define ctchGuid    (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

LPCTSTR
_ParseHex(
    LPCTSTR ptsz,
    LPBYTE  *ppb,
    int     cb,
    TCHAR tchDelim
)
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    if (ptsz) {
        int i = cb * 2;
        DWORD dwParse = 0;

        do {
            DWORD uch;
            uch = (TBYTE)*ptsz - TEXT('0');
            if (uch < 10) {             /* a decimal digit */
            } else {
                uch = (*ptsz | 0x20) - TEXT('a');
                if (uch < 6) {          /* a hex digit */
                    uch += 10;
                } else {
                    return 0;           /* Parse error */
                }
            }
            dwParse = (dwParse << 4) + uch;
            ptsz++;
        } while (--i);

        if (tchDelim && *ptsz++ != tchDelim) return 0; /* Parse error */

        for (i = 0; i < cb; i++) {
            (*ppb)[i] = ((LPBYTE)&dwParse)[i];
        }
        *ppb += cb;
    }
    return ptsz;

} // _ParseHex

BOOL
ParseGUID(
    LPGUID  pguid,
    LPCTSTR ptsz
)
/*++

Routine Description:

    Parses GUID value from strin representation

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (lstrlen(ptsz) == ctchGuid - 1 && *ptsz == TEXT('{')) {
        ptsz++;
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 4, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 2, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 2, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1, TEXT('}'));
        return ( (ptsz == NULL ) ? FALSE : TRUE);
    } else {
        return 0;
    }

} // ParseGUID

BOOL
ParseCommandLine(
    LPTSTR  lpszCmdLine,
    UINT    *pargc,
    LPTSTR  *argv
    )
/*++

Routine Description:

    Parses command line into standard arg.. array.

Arguments:

    None.

Return Value:

    TRUE - command line parsed

--*/
{

    LPTSTR       pszT = lpszCmdLine;
    TCHAR       cOption;
    UINT        iCurrentOption = 0;
USES_CONVERSION;

    *pargc=0;

    //
    // Get to first parameter in command line.
    //
    while (*pszT && ((*pszT != TEXT('-')) && (*pszT != TEXT('/'))) ) {
         pszT++;
    }

    //
    // Parse options from command line
    //
    while (*pszT) {

        // Skip white spaces
        while (*pszT && *pszT <= TEXT(' ')) {
            pszT++;
        }

        if (!*pszT)
            break;

        if (TEXT('-') == *pszT || TEXT('/') == *pszT) {
            pszT++;
            if (!*pszT)
                break;

            argv[*pargc] = pszT;
            (*pargc)++;
        }

        // Skip till space
        while (*pszT && *pszT > TEXT(' ')) {
            pszT++;
        }

        if (!*pszT)
            break;

        // Got next argument
        *pszT++=TEXT('\0');
    }

    //
    // Interpret options
    //

    if (*pargc) {

        for (iCurrentOption=0;
             iCurrentOption < *pargc;
             iCurrentOption++) {

            cOption = *argv[iCurrentOption];
            pszT = argv[iCurrentOption]+ 2 * sizeof(TCHAR);


            switch ((TCHAR)LOWORD(::CharUpper((LPTSTR)cOption))) {
                case TEXT('V'):
                    // Become visible
                    g_fUIPermitted = TRUE;
                    break;

                case TEXT('H'):
                    // Become invisible
                    g_fUIPermitted = FALSE;
                    break;


                case TEXT('R'):
                    // Refresh device list
                    g_fRefreshDeviceList = TRUE;
                    break;

                case TEXT('A'):
                    // Not running as a service, but as an app
                    g_fRunningAsService = FALSE;
                    break;

                case TEXT('T'):
                    // Value of timeout in seconds
                    {
                        UINT    uiT = atoi((char *) T2A(pszT));
                        if (uiT) {
                            g_uiDefaultPollTimeout = uiT * 1000;
                        }
                    }
                    break;

                case TEXT('I'):
                    // Install STI service
                    g_fInstallingRequest = TRUE;
                    break;
                case TEXT('U'):
                    // Uninstall STI service
                    g_fRemovingRequest = TRUE;
                    break;

                default:;
                    break;
            }
        }
    }

    //
    // Print parsed options for debug build
    //

    return TRUE;

} // ParseCommandLine

BOOL
IsSetupInProgressMode(
    BOOL    *pUpgradeFlag   // = NULL
    )
/*++

Routine Description:

    IsSetupInProgressMode

Arguments:

    Pointer to the flag, receiving InUpgrade value

Return Value:

    TRUE - setup is in progress
    FALSE - not

Side effects:

--*/
{
   LPCTSTR szKeyName = TEXT("SYSTEM\\Setup");
   DWORD dwType, dwSize;
   HKEY hKeySetup;
   DWORD dwSystemSetupInProgress,dwUpgradeInProcess;
   LONG lResult;

   DBG_FN(IsSetupInProgressMode);

   if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szKeyName, 0,
                     KEY_READ, &hKeySetup) == ERROR_SUCCESS) {

       dwSize = sizeof(DWORD);
       lResult = RegQueryValueEx (hKeySetup, TEXT("SystemSetupInProgress"), NULL,
                                  &dwType, (LPBYTE) &dwSystemSetupInProgress, &dwSize);

       if (lResult == ERROR_SUCCESS) {

           lResult = RegQueryValueEx (hKeySetup, TEXT("UpgradeInProgress"), NULL,
                                      &dwType, (LPBYTE) &dwUpgradeInProcess, &dwSize);

           if (lResult == ERROR_SUCCESS) {

               DBG_TRC(("[IsInSetupUpgradeMode] dwSystemSetupInProgress =%d, dwUpgradeInProcess=%d ",
                      dwSystemSetupInProgress,dwUpgradeInProcess));

               if( pUpgradeFlag ) {
                   *pUpgradeFlag = dwUpgradeInProcess ? TRUE : FALSE;
               }

               if (dwSystemSetupInProgress != 0) {
                   return TRUE;
               }
           }
       }
       RegCloseKey (hKeySetup);
   }

   return FALSE ;
}

BOOL WINAPI
AuxFormatStringV(
    IN LPTSTR   lpszStr,
    ...
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD   cch;
    LPTSTR   pchBuff = NULL;
    BOOL    fRet = FALSE;
    DWORD   dwErr;

    va_list va;

    va_start(va,lpszStr);

    pchBuff = (LPTSTR)::LocalAlloc(LPTR,1024);
    if (!pchBuff) {
        return FALSE;
    }

    cch = ::FormatMessage( //FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_STRING,
                            lpszStr,
                            0L,
                            0,
                            (LPTSTR) pchBuff,
                            1024 / sizeof(TCHAR),
                            &va);
    dwErr = ::GetLastError();

    if ( cch )     {
        ::lstrcpy(lpszStr,(LPCTSTR) pchBuff );
    }

    if (pchBuff) {
        ::LocalFree( (VOID*) pchBuff );
    }

    return fRet;

} // AuxFormatStringV

BOOL WINAPI
IsPlatformNT()
{
    OSVERSIONINFOA  ver;
    BOOL            bReturn = FALSE;

    ZeroMemory(&ver,sizeof(ver));
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    // Just always call the ANSI function
    if(!GetVersionExA(&ver)) {
        bReturn = FALSE;
    }
    else {
        switch(ver.dwPlatformId) {

            case VER_PLATFORM_WIN32_WINDOWS:
                bReturn = FALSE;
                break;

            case VER_PLATFORM_WIN32_NT:
                bReturn = TRUE;
                break;

            default:
                bReturn = FALSE;
                break;
        }
    }

    return bReturn;

}  //  endproc IsPlatformNT

void
WINAPI
StiLogTrace(
    DWORD   dwType,
    LPTSTR   lpszMessage,
    ...
    )
{
    va_list list;
    va_start (list, lpszMessage);

    if(g_StiFileLog) {

        g_StiFileLog->vReportMessage(dwType,lpszMessage,list);

        // NOTE : This will soon be replaced by WIA logging
        if(g_StiFileLog->QueryReportMode()  & STI_TRACE_LOG_TOUI) {
            #ifdef SHOWMONUI
            vStiMonWndDisplayOutput(lpszMessage,list);
            #endif
        }

    }

    va_end(list);
}

void
WINAPI
StiLogTrace(
    DWORD   dwType,
    DWORD   idMessage,
    ...
    )
{
    va_list list;
    va_start (list, idMessage);

    if (g_StiFileLog && (g_StiFileLog->IsValid()) ) {

        TCHAR    *pchBuff = NULL;
        DWORD   cch;

        pchBuff = NULL;

        cch = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                               FORMAT_MESSAGE_MAX_WIDTH_MASK |
                               FORMAT_MESSAGE_FROM_HMODULE,
                               GetModuleHandle(NULL),
                               idMessage,
                               0,
                               (LPTSTR) &pchBuff,
                               1024,
                               (va_list *)&list
                               );

        if (cch) {
            g_StiFileLog->vReportMessage(dwType,pchBuff,list);
        }

        //
        //  NOTE:  This logging will be replaced shortly by WIA logging
        //
        if((g_StiFileLog->QueryReportMode()  & STI_TRACE_LOG_TOUI) && pchBuff) {

            #ifdef SHOWMONUI
            vStiMonWndDisplayOutput(pchBuff,list);
            #endif
        }

        if (pchBuff) {
            LocalFree(pchBuff);
        }


    }

    va_end(list);
}


#ifdef MAXDEBUG
BOOL
WINAPI
DumpTokenInfo(
    LPTSTR      pszPrefix,
    HANDLE      hToken
    )
{

    BYTE        buf[2*MAX_PATH];
    TCHAR       TextualSid[2*MAX_PATH];
    TCHAR       szDomain[MAX_PATH];
    PTOKEN_USER ptgUser = (PTOKEN_USER)buf;
    DWORD       cbBuffer=MAX_PATH;

    BOOL        bSuccess;

    PSID pSid;
    PSID_IDENTIFIER_AUTHORITY psia;
    SID_NAME_USE    SidUse;

    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD cchSidCopy;

    DWORD cchSidSize = sizeof(TextualSid);
    DWORD cchDomSize = sizeof(szDomain);

    DBG_WRN((("Dumping token information for %S"),pszPrefix));

    if ((hToken == NULL) || ( hToken == INVALID_HANDLE_VALUE)) {
        return FALSE;
    }

    bSuccess = GetTokenInformation(
                hToken,    // identifies access token
                TokenUser, // TokenUser info type
                ptgUser,   // retrieved info buffer
                cbBuffer,  // size of buffer passed-in
                &cbBuffer  // required buffer size
                );

    if(!bSuccess) {
        DBG_WRN(("Failed to get token info"));
        return FALSE;
    }

    pSid = ptgUser->User.Sid;

        //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid)) {
        DBG_WRN(("SID is not valid"));
        return FALSE;
    }
#if 0
    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute approximate buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidCopy = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(cchSidSize < cchSidCopy) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidCopy = wsprintf(TextualSid, TEXT("S-%lu-"), SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for(dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }

    DBG_WRN(("Textual SID: %s"),TextualSid);
#endif

    cchSidSize = sizeof(TextualSid);
    cchDomSize = sizeof(szDomain);

    bSuccess = LookupAccountSid(NULL,
                                pSid,
                                TextualSid,
                                &cchSidSize,
                                szDomain,
                                &cchDomSize,
                                &SidUse
                                );

    if (!bSuccess) {
        DBG_WRN((("Failed to lookup SID . Lasterror: %d"), GetLastError()));
        return FALSE;
    }

    DBG_WRN((("Looked up user account: Domain:%S User: %S Use:%d "), szDomain, TextualSid, SidUse));

    return TRUE;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\stismsg.h ===
/*++;

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stismsg.mc, stismsg.h

Abstract:

    This file contains the message definitions for the STI service

    This header file is generated by the MC tool from the INETMSG.MC message
    file.
Author:

    Vlad Sadovsky   (VladS)    01-Oct-1997

Revision History:

Notes:

--*/

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: MSG_STARTUP
//
// MessageText:
//
//  The Still Image service starting up.
//
#define MSG_STARTUP                      0x40002001L

//
// MessageId: MSG_REMOVE_SUCCESS
//
// MessageText:
//
//  The Still Image service is removed from the system.
//
#define MSG_REMOVE_SUCCESS               0x40002002L

//
// MessageId: MSG_REMOVE_FAIL
//
// MessageText:
//
//  The Still Image service failed to be removed from the system. Error = %1.
//
#define MSG_REMOVE_FAIL                  0x40002003L

//
// MessageId: MSG_INSTALL_SUCCESS
//
// MessageText:
//
//  The Still Image service is installed on the system.
//
#define MSG_INSTALL_SUCCESS              0x40002004L

//
// MessageId: MSG_INSTALL_FAIL
//
// MessageText:
//
//  The Still Image service failed to be installed on the system. Error = %1.
//
#define MSG_INSTALL_FAIL                 0x40002005L

//
// MessageId: MSG_IDENTIFICATION
//
// MessageText:
//
//  Still Image Service
//
#define MSG_IDENTIFICATION               0x40002006L

//
// MessageId: MSG_STOP
//
// MessageText:
//
//  The Still Image service stopped
//
#define MSG_STOP                         0x40002007L

//
// MessageId: MSG_TRACE_SVC_INIT
//
// MessageText:
//
//  StiService entered initialization phase. String=%1!s! Integer=%2!d!
//
#define MSG_TRACE_SVC_INIT               0x40002008L

//
// MessageId: MSG_TRACE_PWR_SUSPEND
//
// MessageText:
//
//  StiService is suspending, due to power suspend message PowerEvent code: %1!d!
//
#define MSG_TRACE_PWR_SUSPEND            0x40002009L

//
// MessageId: MSG_TRACE_PWR_RESUME
//
// MessageText:
//
//  StiService is resuming, due to power resume message PowerEvent code: %1!d!
//
#define MSG_TRACE_PWR_RESUME             0x4000200AL

//
// MessageId: MSG_ERROR_APP_NOT_LAUNCHED_CLEAN
//
// MessageText:
//
//  The application associated with this event could not be launched. Make sure the application is available and functioning.
//
#define MSG_ERROR_APP_NOT_LAUNCHED_CLEAN 0xC000200BL

//
// MessageId: MSG_ERROR_APP_NOT_LAUNCHED
//
// MessageText:
//
//  The application you selected could not be launched. Do you want to select a different one?
//
#define MSG_ERROR_APP_NOT_LAUNCHED       0xC000200CL

//
// MessageId: MSG_ERROR_APP_NOT_LAUNCHED_NORETRY
//
// MessageText:
//
//  The application associated with this event could not be launched. Do you want to stop launching this application for this event?
//
#define MSG_ERROR_APP_NOT_LAUNCHED_NORETRY 0xC000200DL

//
// MessageId: MSG_ERROR_APP_NO_REGISTERED
//
// MessageText:
//
//  There are no applications currently registered to be used with imaging devices.
//
#define MSG_ERROR_APP_NO_REGISTERED      0xC000200EL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\util.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    util.h

Abstract:


Author:

    Vlad Sadovsky (vlads)   10-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    26-Jan-1997     VladS       created

--*/

#include <stistr.h>
#include <dbt.h>

typedef struct _DEV_BROADCAST_HEADER DEV_BROADCAST_HEADER,*PDEV_BROADCAST_HEADER;

//
// PnP support utilities
//
BOOL
IsStillImageDevNode(
    DEVNODE     dnDevNode
    );

BOOL
GetDeviceNameFromDevBroadcast(
    DEV_BROADCAST_HEADER  *psDevBroadcast,
    DEVICE_BROADCAST_INFO *psDevInfo
    );

BOOL
ConvertDevInterfaceToDevInstance(
    const GUID  *pClassGUID,
    const TCHAR *pszDeviceInterface, 
    TCHAR       **ppszDeviceInstance
    );

BOOL
GetDeviceNameFromDevNode(
    DEVNODE     dnDevNode,
    StiCString& strDeviceName
    );

BOOL
ParseGUID(
    LPGUID  pguid,
    LPCTSTR ptsz
);

//
// Misc. utility functions
//
BOOL WINAPI
AuxFormatStringV(
    IN LPTSTR   lpszStr,
    ...
    );


BOOL
ParseCommandLine(
    LPSTR   lpszCmdLine,
    UINT    *pargc,
    LPTSTR  *argv
    );


BOOL WINAPI
IsPlatformNT(
    VOID
    );

BOOL
IsSetupInProgressMode(
    BOOL    *pUpgradeFlag = NULL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiacfact.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       CFactory.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        26 Dec, 1997
*
*  DESCRIPTION:
*   Class factory implementation for ImageIn.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

//#include <assert.h>

#include "wiacfact.h"
#include <sddl.h>

extern HINSTANCE g_hInst;

BOOL setValue(LPCTSTR, LPCTSTR, LPCTSTR);
BOOL setBinValue(LPCTSTR, LPCTSTR, DWORD, BYTE*);
BOOL setKeyAndValue(LPCTSTR, LPCTSTR, LPCTSTR);
BOOL SubkeyExists(LPCTSTR, LPCTSTR);
LONG recursiveDeleteKey(HKEY, LPCTSTR);

BOOL GetWiaDefaultDCOMSecurityDescriptor(
    VOID   **ppSecurityDescriptor,
    ULONG   *pulSize)
{
    ULONG   ulAclSize       = 0;
    BOOL    bRet            = FALSE;


    //
    //  Create our security descriptor.  We do this using a string format security
    //  descriptor, which we then convert to a real security descriptor.
    //
    //  NOTE:  Caller has to free the security descriptor with LocalFree...
    //
    if ( ConvertStringSecurityDescriptorToSecurityDescriptor(wszDefaultDaclForDCOMAccessPermission,
                                                             SDDL_REVISION_1, 
                                                             (PSECURITY_DESCRIPTOR*)ppSecurityDescriptor,
                                                             pulSize)) {
        bRet = TRUE;
    } else {
        DBG_ERR(("ConvertStringSecurityDescriptorToSecurityDescriptor Failed"));
    }
    return bRet;

}

/*******************************************************************************
*
*  RegisterServer
*
*  DESCRIPTION:
*   Register a COM component in the Registry. From Inside COM.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT RegisterServer(
    LPCTSTR         szModuleFileName,
    const CLSID*    pclsid,
    LPCTSTR         szFriendlyName,
    LPCTSTR         szVerIndProgID,
    LPCTSTR         szProgID,
    LPCTSTR         szService,
    const GUID*     plibid,
    BOOLEAN         bOutProc)
{
    BOOL    bResult = TRUE;

    //
    // Fill in the path to the module file name.
    //

    TCHAR szModule[MAX_PATH] = TEXT("\0");

    if (!GetModuleFileName(g_hInst, szModule, sizeof(szModule)/sizeof(szModule[0]))) {
#ifdef DEBUG
        OutputDebugString(TEXT("Error extracting service module name."));
#endif
        return E_FAIL;
    }

    //
    // Strip the filename from the path
    //

    TCHAR   *pChar = &szModule[lstrlen(szModule)];
    while ((pChar > szModule) && (*pChar != '\\')) {
        pChar--;
    }

    if (pChar == szModule) {
#ifdef DEBUG
        OutputDebugString(TEXT("Error extracting Still Image service path."));
#endif
        return E_FAIL;
    } else {
        pChar++;
        *pChar = '\0';
    }

    if (szModuleFileName) {
        if (lstrlen(szModuleFileName) > (int)((sizeof(szModule) / sizeof(szModule[0]) - lstrlen(szModule)))) {
#ifdef DEBUG
            OutputDebugString(TEXT("szModuleFileName parameter is too long."));
#endif
        return E_INVALIDARG;
        }
    } else {
#ifdef DEBUG
        OutputDebugString(TEXT("NULL szModuleFileName parameter"));
#endif
        return E_INVALIDARG;
    }

    //
    // Concatenate server module name (XXXXX.exe) with path
    //

    if( lstrcat(szModule, szModuleFileName) == NULL)
    {
#ifdef DEBUG
        OutputDebugString(TEXT("Error concatenating module file name and path"));
#endif
        return E_FAIL;
    }

        // Convert the CLSID into a char.
    LPOLESTR   pszCLSID;
    LPOLESTR   pszLIBID;
    TCHAR      szCLSID[64];
    TCHAR      szLIBID[64];

    HRESULT hr = StringFromCLSID(*pclsid, &pszCLSID);
    if (FAILED(hr)) {
        return hr;
    }

    hr = StringFromCLSID(*plibid, &pszLIBID);
    if (FAILED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szCLSID, pszCLSID);
    lstrcpy(szLIBID, pszLIBID);
#else
    WideCharToMultiByte(CP_ACP,
                        0,
                        pszCLSID,
                        -1,
                        szCLSID,
                        sizeof(szCLSID),
                        NULL,
                        NULL);
    WideCharToMultiByte(CP_ACP,
                        0,
                        pszLIBID,
                        -1,
                        szLIBID,
                        sizeof(szLIBID),
                        NULL,
                        NULL);
#endif

    // Build the key CLSID\\{...}
    TCHAR szKey[64] = TEXT("CLSID\\");

    lstrcat(szKey, szCLSID);


        // Add the CLSID to the registry.
    bResult &= setKeyAndValue(szKey, NULL, szFriendlyName) ;

        // Add the server filename subkey under the CLSID key.
    if (bOutProc) {
       bResult &= setKeyAndValue(szKey, TEXT("LocalServer32"), szModule);

       // If the server is implemented as a service add the service
       // AppID keys and values.
       if (szService) {
           // Add the service AppID value to the CLSID key.
           bResult &= setValue(szKey, TEXT("AppID"), szCLSID);

           // Add the AppID key.
           TCHAR szAppID[64] = TEXT("AppID\\");

           lstrcat(szAppID, szCLSID);
           bResult &= setKeyAndValue(szAppID, NULL, szFriendlyName);

           bResult &= setValue(szAppID, TEXT("LocalService"), szService);

           //
           //   This is needed for Win98/Millenium
           //

           bResult &= setValue(szAppID, TEXT("Run As"), TEXT("Interactive User"));

           //
           //   Add an ACL to protect instantiation.
           //
           DWORD                dwSize = 0;
           PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

           if (GetWiaDefaultDCOMSecurityDescriptor((VOID**)&pSecurityDescriptor, &dwSize)) {
              //
              // Write this self-relative security descriptor to the AccessPermission value
              //  under our AppID
              //
              setBinValue(szAppID, TEXT("AccessPermission"), dwSize, (BYTE*)pSecurityDescriptor);
              LocalFree(pSecurityDescriptor);
              pSecurityDescriptor = NULL;
           } else {
               DBG_ERR(("GetWiaDefaultDCOMSecurityDescriptor failed"));
           }
       }
    }
    else {
       bResult &= setKeyAndValue(szKey, TEXT("InprocServer32"), szModule);
    }

        // Add the ProgID subkey under the CLSID key.
    bResult &= setKeyAndValue(szKey, TEXT("ProgID"), szProgID) ;

        // Add the version-independent ProgID subkey under CLSID key.
    bResult &= setKeyAndValue(szKey, TEXT("VersionIndependentProgID"),
                              szVerIndProgID) ;

    // Add the Type Library ID subkey under the CLSID key.
    bResult &= setKeyAndValue(szKey, TEXT("TypeLib"), szLIBID) ;

        // Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
    bResult &= setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ;
    bResult &= setKeyAndValue(szVerIndProgID, TEXT("CLSID"), szCLSID) ;
    bResult &= setKeyAndValue(szVerIndProgID, TEXT("CurVer"), szProgID) ;

        // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
    bResult &= setKeyAndValue(szProgID, NULL, szFriendlyName) ;
    bResult &= setKeyAndValue(szProgID, TEXT("CLSID"), szCLSID) ;
    CoTaskMemFree(pszCLSID);
    CoTaskMemFree(pszLIBID);

    if (bResult) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

/*******************************************************************************
*
*  UnregisterServer
*
*  DESCRIPTION:
*   Remove a COM component from the registry. From Inside COM.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT UnregisterServer(
    const CLSID* pclsid,
    LPCTSTR      szVerIndProgID,
    LPCTSTR      szProgID,
    LPCTSTR      szService)
{
   // Convert the CLSID into a char.
   LPOLESTR pszCLSID;

   HRESULT hr = StringFromCLSID(*pclsid, &pszCLSID);

   if (FAILED(hr) || !pszCLSID) {
       return E_UNEXPECTED;
   }

   TCHAR      szCLSID[64];

#ifdef UNICODE
   lstrcpy(szCLSID, pszCLSID);
#else
   WideCharToMultiByte(CP_ACP,
                       0,
                       pszCLSID,
                       -1,
                       szCLSID,
                       sizeof(szCLSID),
                       NULL,
                       NULL);
#endif

   // Build the key CLSID\\{...}
   TCHAR szKey[64] =  TEXT("CLSID\\");
   lstrcat(szKey, szCLSID) ;

   // Delete the CLSID Key - CLSID\{...}
   LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey);
   if ((lResult != ERROR_SUCCESS) &&
       (lResult != ERROR_FILE_NOT_FOUND)) {
      return HRESULT_FROM_WIN32(lResult);
   }

   // Delete the AppID Key - AppID\{...}
   if (szService) {
       TCHAR szAppID[64] = TEXT("AppID\\");
       lstrcat(szAppID, szCLSID) ;

       lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szAppID);
       if ((lResult != ERROR_SUCCESS) &&
           (lResult != ERROR_FILE_NOT_FOUND)) {
          return HRESULT_FROM_WIN32(lResult);
       }
   }

   // Delete the version-independent ProgID Key.
   lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID);
   if ((lResult != ERROR_SUCCESS) &&
       (lResult != ERROR_FILE_NOT_FOUND)) {
      return HRESULT_FROM_WIN32(lResult);
   }

   // Delete the ProgID key.
   lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID);
   if ((lResult != ERROR_SUCCESS) &&
       (lResult != ERROR_FILE_NOT_FOUND)) {
      return HRESULT_FROM_WIN32(lResult);
   }

   CoTaskMemFree(pszCLSID);
   return S_OK ;
}

/*******************************************************************************
*
*  recursiveDeleteKey
*
*  DESCRIPTION:
*   Delete a key and all of its descendents. From Inside COM.
*  PARAMETERS:
*
*******************************************************************************/

LONG recursiveDeleteKey(
    HKEY    hKeyParent,
    LPCTSTR lpszKeyChild
)
{
        // Open the child.
        HKEY hKeyChild ;
        LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
                                 KEY_ALL_ACCESS, &hKeyChild) ;
        if (lRes != ERROR_SUCCESS)
        {
                return lRes ;
        }

        // Enumerate all of the decendents of this child.
        FILETIME time ;
        TCHAR szBuffer[256] ;
        DWORD dwSize = 256 ;
        while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
                            NULL, NULL, &time) == S_OK)
        {
                // Delete the decendents of this child.
                lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
                if (lRes != ERROR_SUCCESS)
                {
                        // Cleanup before exiting.
                        RegCloseKey(hKeyChild) ;
                        return lRes;
                }
                dwSize = 256 ;
        }

        // Close the child.
        RegCloseKey(hKeyChild) ;

        // Delete this child.
        return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

/*******************************************************************************
*
*  SubkeyExists
*
*  DESCRIPTION:
*   Determine if a particular subkey exists. From Inside COM.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL SubkeyExists(
    LPCTSTR pszPath,
    LPCTSTR szSubkey
)
{
    HKEY hKey ;
    TCHAR szKeyBuf[80];
    UINT  uSubKeyChars = 0;

    if (!pszPath) {
        return FALSE;
    }

    if (szSubkey)
    {
        // The "+1" is for the TEXT("\\")
        uSubKeyChars = lstrlen(szSubkey) + 1;
    }

    if ((lstrlen(pszPath)+uSubKeyChars) > (sizeof(szKeyBuf) / sizeof(szKeyBuf[0]) - 1)) {
        return FALSE;
    }

    // Copy keyname into buffer.
    lstrcpy(szKeyBuf, pszPath) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
    lstrcat(szKeyBuf, TEXT("\\")) ;
    lstrcat(szKeyBuf, szSubkey ) ;
    }

    // Determine if key exists by trying to open it.
    LONG lResult = ::RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                  szKeyBuf,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hKey) ;
    if (lResult == ERROR_SUCCESS)
    {
        RegCloseKey(hKey) ;
        return TRUE ;
    }
    return FALSE ;
}

/*******************************************************************************
*
*  setKeyAndValue
*
*  DESCRIPTION:
*   Create a key and set its value. From Inside OLE.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL setKeyAndValue(
    LPCTSTR szKey,
    LPCTSTR szSubkey,
    LPCTSTR szValue)
{
    HKEY    hKey;
    TCHAR   szKeyBuf[1024] ;
    BOOL    bVal = FALSE;
    UINT    uSubKeyChars = 0;

    if (!szKey) {
        return FALSE;
    }

    if (szSubkey)
    {
        // the "+1" is for the TEXT("\\")
        uSubKeyChars = lstrlen(szSubkey) + 1;
    }

    if ((lstrlen(szKey)+uSubKeyChars) > (sizeof(szKeyBuf) / sizeof(szKeyBuf[0]) - 1)) {
        return FALSE;
    }

    // Copy keyname into buffer.
    lstrcpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        lstrcat(szKeyBuf, TEXT("\\")) ;
        lstrcat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
                                  szKeyBuf,
                                  0, NULL, REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS, NULL,
                                  &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        lResult = RegSetValueEx(hKey, NULL, 0, REG_SZ,
                                (BYTE *)szValue,
                                (lstrlen(szValue)+1) * sizeof(TCHAR)) ;
        if (lResult == ERROR_SUCCESS) {
            bVal = TRUE;
        }
    }

    RegCloseKey(hKey) ;
    return bVal;
}

/*******************************************************************************
*
*  setValue
*
*  DESCRIPTION:
*   Create and set a value.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL setValue(
    LPCTSTR pszKey,
    LPCTSTR pszValueName,
    LPCTSTR pszValue)
{
        HKEY    hKey;
    DWORD   dwSize;
    BOOL    bRet = FALSE;

    if (RegOpenKey(HKEY_CLASSES_ROOT, pszKey, &hKey) == ERROR_SUCCESS) {

        dwSize = (lstrlen(pszValue) + 1) * sizeof(TCHAR);
        if (RegSetValueEx(hKey,
                          pszValueName,
                          0,
                          REG_SZ,
                          (PBYTE) pszValue,
                          dwSize) == ERROR_SUCCESS) {
            bRet = TRUE;
            //
            //  NOTE: Leak here on failure - this should be moved out of this block
            //
            RegCloseKey(hKey);
        }
    }
        return bRet;
}

/*******************************************************************************
*
*  setBinValue
*
*  DESCRIPTION:
*   Create and set a binary value.
*
*  PARAMETERS:
*
*******************************************************************************/
BOOL setBinValue(
    LPCTSTR pszKey,
    LPCTSTR pszValueName,
    DWORD   dwSize,
    BYTE    *pbValue)
{
    HKEY    hKey;
    BOOL    bRet = FALSE;

    if (RegOpenKey(HKEY_CLASSES_ROOT, pszKey, &hKey) == ERROR_SUCCESS) {

        if (RegSetValueEx(hKey,
                          pszValueName,
                          0,
                          REG_BINARY,
                          pbValue,
                          dwSize) == ERROR_SUCCESS) {
            bRet = TRUE;
        }
        RegCloseKey(hKey);
    }
    return bRet;
}


/*******************************************************************************
*
*                     S T A T I C   D A T A
*
*******************************************************************************/

LONG    CFactory::s_cServerLocks = 0;       // Count of server locks
HMODULE CFactory::s_hModule      = NULL;    // DLL module handle
DWORD   CFactory::s_dwThreadID   = 0;

/*******************************************************************************
*
*  CFactory constructor
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

CFactory::CFactory(PFACTORY_DATA pFactoryData): m_cRef(1)
{
    m_pFactoryData = pFactoryData;
}

/*******************************************************************************
*
*  CFactory::QueryInterface
*
*  DESCRIPTION:
*   IUnknown implementation.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT __stdcall CFactory::QueryInterface(REFIID iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid==IID_IClassFactory)) {
        *ppv = (IClassFactory*)this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

/*******************************************************************************
*
*  CFactory::AddRef
*  CFactory::Release
*
*  DESCRIPTION:
*   Reference counting methods.
*
*  PARAMETERS:
*
*******************************************************************************/

ULONG __stdcall CFactory::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

ULONG __stdcall CFactory::Release()
{
    if (::InterlockedDecrement(&m_cRef) == 0) {
                delete this;
                return 0 ;
        }
        return m_cRef;
}

/*******************************************************************************
*
*  CreateInstance
*  LockServer
*
*  DESCRIPTION:
*   Class Factory Interface.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT __stdcall CFactory::CreateInstance(
    IUnknown* pOuter,
    const IID& iid,
    void** ppv
)
{
    *ppv = NULL;

    // No support for aggregation, if we have an outer class then bail.
    if (pOuter) {
        return CLASS_E_NOAGGREGATION;
    }

    return m_pFactoryData->CreateInstance(iid, ppv);
}

HRESULT __stdcall CFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        CWiaSvc::AddRef();
        }
    else {
        CWiaSvc::Release();
        }

    return S_OK;
}

/*******************************************************************************
*
*  CFactory::CanUnloadNow
*
*  DESCRIPTION:
*   Determine if the component can be unloaded.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT CFactory::CanUnloadNow()
{
    if (IsLocked()) {
        return S_FALSE;
        }
    else {
        return S_OK;
        }
}

/*******************************************************************************
*
*  CFactory::RegisterUnregisterAll
*
*  DESCRIPTION:
*   Register/Unregister all components.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT CFactory::RegisterUnregisterAll(
    PFACTORY_DATA   pFactoryData,
    UINT            uiFactoryDataCount,
    BOOLEAN         bRegister,
    BOOLEAN         bOutProc
)
{
    HRESULT hr = E_FAIL;
    UINT    i;

    for (i = 0; i < uiFactoryDataCount; i++) {
        if (bRegister) {
            hr = RegisterServer(pFactoryData[i].szModuleFileName,
                                pFactoryData[i].pclsid,
                                pFactoryData[i].szRegName,
                                pFactoryData[i].szVerIndProgID,
                                pFactoryData[i].szProgID,
                                pFactoryData[i].szService,
                                pFactoryData[i].plibid,
                                bOutProc);
        }
        else {
            hr = UnregisterServer(pFactoryData[i].pclsid,
                                  pFactoryData[i].szVerIndProgID,
                                  pFactoryData[i].szProgID,
                                  pFactoryData[i].szService);

        }

        if (FAILED(hr)) {
            break;
        }
    }
    return hr;
}

/*******************************************************************************
*
*  CFactory::StartFactories
*
*  DESCRIPTION:
*   Start the class factories.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL CFactory::StartFactories(
    PFACTORY_DATA   pFactoryData,
    UINT            uiFactoryDataCount
)
{
    PFACTORY_DATA pData, pStart = pFactoryData;
    PFACTORY_DATA pEnd = &pFactoryData[uiFactoryDataCount - 1];


    for (pData = pStart; pData <= pEnd; pData++) {

        // Initialize the class factory pointer and cookie.
        pData->pIClassFactory = NULL;
        pData->dwRegister = NULL;

                // Create the class factory for this component.
        IClassFactory* pIFactory = new CFactory(pData);
        if (pIFactory) {
            // Register the class factory.
            DWORD dwRegister;
            HRESULT hr = ::CoRegisterClassObject(
                              *(pData->pclsid),
                              static_cast<IUnknown*>(pIFactory),
                              CLSCTX_LOCAL_SERVER,
                              REGCLS_MULTIPLEUSE,
                              &dwRegister);

            if (FAILED(hr)) {
                DBG_ERR(("CFactory::StartFactories, CoRegisterClassObject CFactory Failed 0x%X", hr));
                pIFactory->Release();
                return FALSE;
            }

            // Set the data.
            pData->pIClassFactory = pIFactory;
            pData->dwRegister = dwRegister;
        }
        else {
            DBG_ERR(("CFactory::StartFactories, New CFactory Failed"));
        }
    }
    DBG_TRC(("CFactory::StartFactories, Success"));
    return TRUE;
}

/*******************************************************************************
*
*  CFactory::StopFactories
*
*  DESCRIPTION:
*   Stop the class factories.
*
*  PARAMETERS:
*
*******************************************************************************/

void CFactory::StopFactories(
    PFACTORY_DATA    pFactoryData,
    UINT            uiFactoryDataCount
)
{
    PFACTORY_DATA pData, pStart = pFactoryData;
    PFACTORY_DATA pEnd = &pFactoryData[uiFactoryDataCount - 1];

    for (pData = pStart; pData <= pEnd; pData++) {

        // Get the magic cookie and stop the factory from running.
        DWORD dwRegister = pData->dwRegister;
        if (dwRegister != 0) {
            ::CoRevokeClassObject(dwRegister);
                }

                // Release the class factory.
        IClassFactory* pIFactory  = pData->pIClassFactory ;
        if (pIFactory != NULL) {
                        pIFactory->Release() ;
                }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiadbg.cpp ===
#include "precomp.h"


#include "wiadbgp.h"

#ifdef WIA_DEBUG
CWiaDebugger *_global_pWiaDebugger = NULL;
#endif

CWiaDebugger::CWiaDebugger( HINSTANCE hInstance, LPTSTR pszModuleName, BOOL bDisplayUi, BOOL bLogFile, HANDLE hStartedEvent )
:   m_bDisplayUi(bDisplayUi),
    m_bLogFile(bLogFile),
    m_hWnd(NULL),
    m_hLogFile(NULL),
    m_nStackLevel(0),
    m_nFlags(DebugToWindow|DebugToFile|DebugToDebugger|DebugPrintThreadId),
    m_hStartedEvent(hStartedEvent),
    m_dwThreadId(0),
    m_hInstance(hInstance)
{
    if (pszModuleName)
        lstrcpy( m_szModuleName, pszModuleName );
    else lstrcpy( m_szModuleName, TEXT("") );
    if (bLogFile)
    {
        TCHAR szLogFileName[MAX_PATH]=TEXT("");
        LPTSTR pPtr=szLogFileName;
        GetWindowsDirectory( szLogFileName, MAX_PATH );
        while (*pPtr && *pPtr != TEXT('\\'))
            pPtr++;
        if (*pPtr == TEXT('\\'))
            pPtr++;
        else pPtr = szLogFileName;
        lstrcpy( pPtr, pszModuleName );
        for (int i=lstrlen(szLogFileName);i>0;i--)
        {
            if (szLogFileName[i-1]==TEXT('.'))
            {
                szLogFileName[i-1]=TEXT('\0');
                break;
            }
        }
        lstrcat(szLogFileName, TEXT(".log"));
        if ((m_hLogFile = CreateFile(szLogFileName,
                                     GENERIC_WRITE,
                                     FILE_SHARE_WRITE,
                                     NULL,
                                     CREATE_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL)) == INVALID_HANDLE_VALUE)
        {
            m_hLogFile =  NULL;
            m_nFlags   &= ~DebugToFile;
            OutputDebugString( TEXT("WIADBG: Unable to create log file\n") );
        }
        else
        {
            m_nFlags |= DebugToFile;
        }
    }
}

DWORD CWiaDebugger::DebugLoop(void)
{
    if (m_bDisplayUi)
    {
        m_hWnd = CWiaDebugWindow::Create( m_szModuleName, m_hInstance, true );
        ShowWindow( m_hWnd, SW_SHOW );
        UpdateWindow( m_hWnd );
    }
    SetEvent(m_hStartedEvent);
    MSG msg;
    while (GetMessage(&msg, 0, 0, 0))
    {
        if (!msg.hwnd)
        {
            if (msg.message==WM_CLOSE)
                PostQuitMessage(0);
        }
        else
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return 0;
}

DWORD CWiaDebugger::ThreadProc( LPVOID pParam )
{
    DWORD dwResult = 0;
    CWiaDebugger *This = (CWiaDebugger*)pParam;
    if (This)
    {
        dwResult = (DWORD)This->DebugLoop();
        delete This;
    }
    return dwResult;
}

CWiaDebugger::~CWiaDebugger(void)
{
    if (m_hThread)
        CloseHandle( m_hThread );
}


CWiaDebugger * __stdcall CWiaDebugger::Create( HINSTANCE hInstance, LPTSTR pszModuleName, BOOL bDisplayUi, BOOL bLogFile )
{
    CWiaDebugger *pDebugger = NULL;
    HANDLE hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if (hEvent)
    {
        pDebugger = new CWiaDebugger( hInstance, pszModuleName, bDisplayUi, bLogFile, hEvent );
        if (pDebugger)
        {
            pDebugger->m_hThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)ThreadProc, (PVOID)pDebugger, 0, &pDebugger->m_dwThreadId );
            if (pDebugger->m_hThread)
            {
                // Wait for up to 5 seconds. If someone tries to create a debug
                // context in the DLL startup code, the wait will fail and
                // we'll output a debug message.
                if (WAIT_TIMEOUT == WaitForSingleObject( hEvent, 5000 )) {
                    OutputDebugString(TEXT("Wait failed while creating a debug context. No context creation in DLL startup."));
                }
            }
            else
            {
                delete pDebugger;
                pDebugger = NULL;
            }
        }
        CloseHandle(hEvent);
    }
    return pDebugger;
}

int CWiaDebugger::AddString( LPCTSTR szStr, COLORREF cr )
{
    if (!m_hWnd || !IsWindow(m_hWnd))
    {
        return -1;
    }
    LPTSTR pszStr = (LPTSTR)szStr;
    if (pszStr)
    {
        pszStr = (LPTSTR)LocalAlloc(LPTR,(lstrlen(szStr)+1)*sizeof(TCHAR));
        if (pszStr)
            lstrcpy(pszStr,szStr);
    }
    SendMessage( m_hWnd, CWiaDebugWindow::sc_nMsgAddString, (WPARAM)pszStr, (LPARAM)cr);
    return 1;
}

HANDLE CWiaDebugger::SetLogFileHandle( HANDLE hFile )
{
    HANDLE hOld = m_hLogFile;
    m_hLogFile = hFile;
    return hOld;
}

HANDLE CWiaDebugger::GetLogFileHandle(void)
{
    return m_hLogFile;
}

void CWiaDebugger::WiaTrace( LPCWSTR lpszFormat, ... )
{
    WCHAR   szMsg[m_nBufferMax];
    va_list arglist;

    va_start(arglist, lpszFormat);
    ::wvsprintfW(szMsg, lpszFormat, arglist);
    va_end(arglist);

    RouteString( szMsg, RGB(0,0,0) );
}

void CWiaDebugger::WiaTrace( LPCSTR lpszFormat, ... )
{
    CHAR    szMsg[m_nBufferMax];
    va_list arglist;

    va_start(arglist, lpszFormat);
    ::wvsprintfA(szMsg, lpszFormat, arglist);
    va_end(arglist);

    RouteString( szMsg, RGB(0,0,0) );
}

void CWiaDebugger::PrintColor( COLORREF crColor, LPCWSTR lpszMsg )
{
    WCHAR szMsg[m_nBufferMax];
    lstrcpyW( szMsg, lpszMsg );
    RouteString( szMsg, crColor );
}

void CWiaDebugger::PrintColor( COLORREF crColor, LPCSTR lpszMsg )
{
    CHAR szMsg[m_nBufferMax];
    lstrcpyA( szMsg, lpszMsg );
    RouteString( szMsg, crColor );
}

void CWiaDebugger::WiaTrace( HRESULT hr )
{
    DWORD   dwLen;
    LPTSTR  pMsgBuf;

    dwLen = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (LPTSTR)&pMsgBuf, 0, NULL);

    if (dwLen)
    {
        RouteString( pMsgBuf, RGB(0,0,0) );
        LocalFree(pMsgBuf);
    }
    else
        WiaTrace( TEXT("WiaError: Can't format WiaError message 0x%08X"), hr );
}

void CWiaDebugger::WiaError( LPCWSTR lpszFormat, ... )
{
    WCHAR   szMsg[m_nBufferMax];
    va_list arglist;

    va_start(arglist, lpszFormat);
    ::wvsprintfW( szMsg, lpszFormat, arglist);
    va_end(arglist);

    RouteString( szMsg, RGB(255,0,0) );
}

void CWiaDebugger::WiaError( HRESULT hr )
{
    ULONG   ulLen;
    LPTSTR  pMsgBuf;

    ulLen = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (LPTSTR)&pMsgBuf, 0, NULL);

    if (ulLen)
    {
        RouteString( pMsgBuf, RGB(255,0,0) );
        LocalFree(pMsgBuf);
    }
    else
        WiaError( TEXT("WiaError: Can't format WiaError message 0x%08X"), hr );
}

void CWiaDebugger::WiaError( LPCSTR lpszFormat, ... )
{
    CHAR    szMsg[m_nBufferMax];
    va_list arglist;

    va_start(arglist, lpszFormat);
    ::wvsprintfA(szMsg, lpszFormat, arglist);
    va_end(arglist);

    RouteString( szMsg, RGB(255,0,0) );
}

LPTSTR CWiaDebugger::RemoveTrailingCrLf( LPTSTR lpszStr )
{
    for (int i=lstrlen(lpszStr);i>0;i--)
        if (lpszStr[i-1]==TEXT('\n') || lpszStr[i-1]==TEXT('\r'))
            lpszStr[i-1]=TEXT('\0');
        else break;
    return lpszStr;
}

LPSTR CWiaDebugger::UnicodeToAnsi( LPSTR lpszAnsi, LPTSTR lpszUnicode )
{
#if defined(_UNICODE) || defined(UNICODE)
    WideCharToMultiByte( CP_ACP, 0, lpszUnicode, -1, lpszAnsi, lstrlen(lpszUnicode)+1, NULL, NULL );
#else
    lstrcpy( lpszAnsi, lpszUnicode );
#endif
    return lpszAnsi;
}

void CWiaDebugger::WriteMessageToFile( LPTSTR lpszMsg )
{
    HANDLE hFile = GetLogFileHandle();
    if (hFile != NULL && hFile != INVALID_HANDLE_VALUE)
    {
        DWORD dwBytes;
        CHAR lpszAnsiMsg[m_nBufferMax];
        UnicodeToAnsi( lpszAnsiMsg, lpszMsg );
        ULONG ulLength = lstrlenA(lpszAnsiMsg);
        WriteFile(hFile, lpszAnsiMsg, ulLength, &dwBytes, NULL);
        FlushFileBuffers(hFile);
    }
}

static BOOL ContainsNonWhitespace( LPTSTR lpszMsg )
{
    for (LPTSTR lpszPtr = lpszMsg;*lpszPtr;lpszPtr++)
        if (*lpszPtr != TEXT(' ') && *lpszPtr != TEXT('\n') && *lpszPtr != TEXT('\r') && *lpszPtr != TEXT('\t'))
            return TRUE;
    return FALSE;
}

void CWiaDebugger::PrependString( LPTSTR lpszTgt, LPCTSTR lpszStr )
{
    if (ContainsNonWhitespace(lpszTgt))
    {
        int iLen = lstrlen(lpszTgt);
        int iThreadIdLen = lstrlen(lpszStr);
        LPTSTR lpszTmp = (LPTSTR)LocalAlloc( LPTR, (iLen + iThreadIdLen + 2)*sizeof(TCHAR));
        if (lpszTmp)
        {
            lstrcpy( lpszTmp, lpszStr );
            lstrcat( lpszTmp, TEXT(" ") );
            lstrcat( lpszTmp, lpszTgt );
            lstrcpy( lpszTgt, lpszTmp );
            LocalFree(lpszTmp);
        }
    }
}


void CWiaDebugger::PrependThreadId( LPTSTR lpszMsg )
{
    if (ContainsNonWhitespace(lpszMsg))
    {
        TCHAR szThreadId[20];
        wsprintf( szThreadId, TEXT("[%08X]"), GetCurrentThreadId() );
        PrependString( lpszMsg, szThreadId );
    }
}


void CWiaDebugger::PrependModuleName( LPTSTR lpszMsg )
{
    if (ContainsNonWhitespace(lpszMsg))
    {
        TCHAR szModuleName[MAX_PATH+1];
        lstrcpy( szModuleName, m_szModuleName );
        lstrcat( szModuleName, TEXT(":") );
        PrependString( lpszMsg, szModuleName );
    }
}

void CWiaDebugger::InsertStackLevelIndent( LPTSTR lpszMsg, int nStackLevel )
{
    const LPTSTR lpszIndent = TEXT("  ");
    TCHAR szTmp[m_nBufferMax], *pstrTmp, *pstrPtr;
    pstrTmp=szTmp;
    pstrPtr=lpszMsg;
    while (pstrPtr && *pstrPtr)
    {
        // if the current character is a newline and it isn't the
        // last character, append the indent string
        if (*pstrPtr==TEXT('\n') && ContainsNonWhitespace(pstrPtr))
        {
            *pstrTmp++ = *pstrPtr++;
            for (int i=0;i<nStackLevel;i++)
            {
                lstrcpy(pstrTmp,lpszIndent);
                pstrTmp += lstrlen(lpszIndent);
            }
        }
        // If this is the first character, insert the indent string before the
        // first character
        else if (pstrPtr == lpszMsg && ContainsNonWhitespace(pstrPtr))
        {
            for (int i=0;i<nStackLevel;i++)
            {
                lstrcpy(pstrTmp,lpszIndent);
                pstrTmp += lstrlen(lpszIndent);
            }
            *pstrTmp++ = *pstrPtr++;
        }
        else *pstrTmp++ = *pstrPtr++;
    }
    *pstrTmp = TEXT('\0');
    lstrcpy( lpszMsg, szTmp );
}

LPTSTR CWiaDebugger::AnsiToTChar( LPCSTR pszAnsi, LPTSTR pszTChar )
{
#if defined(UNICODE) || defined(_UNICODE)
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszAnsi, lstrlenA(pszAnsi)+1, pszTChar, m_nBufferMax );
#else
    lstrcpyA( pszTChar, pszAnsi );
#endif
    return pszTChar;
}

LPTSTR CWiaDebugger::WideToTChar( LPWSTR pszWide, LPTSTR pszTChar )
{
#if !defined(UNICODE) && !defined(_UNICODE)
    WideCharToMultiByte( CP_ACP, 0, pszWide, lstrlenW(pszWide)+1, pszTChar, m_nBufferMax, NULL, NULL );
#else
    lstrcpyW( pszTChar, pszWide );
#endif
    return pszTChar;
}

void CWiaDebugger::RouteString( LPWSTR lpszMsg, COLORREF nColor )
{
    TCHAR szMsg[m_nBufferMax];
    WideToTChar( lpszMsg, szMsg );
    // Remove extra CRs and LFs - we want to control them
    RemoveTrailingCrLf( szMsg );
    if (m_nFlags & DebugPrintModuleName)
        PrependModuleName( szMsg );
    if (m_nFlags & DebugPrintThreadId)
        PrependThreadId( szMsg );
    InsertStackLevelIndent( szMsg, GetStackLevel() );
    if (m_nFlags & DebugToWindow)
        AddString( szMsg, nColor );
#ifdef WIA_DEBUG
    if (m_nFlags & DebugToDebugger)
    {
        OutputDebugString( szMsg );
        OutputDebugString( TEXT("\n") );
    }
#endif
    if (m_nFlags & DebugToFile)
    {
        WriteMessageToFile( szMsg );
        WriteMessageToFile( TEXT("\n") );
    }
}

void CWiaDebugger::RouteString( LPSTR lpszMsg, COLORREF nColor )
{
    TCHAR szMsg[m_nBufferMax];
    AnsiToTChar( lpszMsg, szMsg );
    // Remove extra CRs and LFs - we want to control them
    RemoveTrailingCrLf( szMsg );
    if (m_nFlags & DebugPrintModuleName)
        PrependModuleName( szMsg );
    if (m_nFlags & DebugPrintThreadId)
        PrependThreadId( szMsg );
    InsertStackLevelIndent( szMsg, GetStackLevel() );
    if (m_nFlags & DebugToWindow)
        AddString( szMsg, nColor );
#ifdef WIA_DEBUG
    if (m_nFlags & DebugToDebugger)
    {
        OutputDebugString( szMsg );
        OutputDebugString( TEXT("\n") );
    }
#endif
    if (m_nFlags & DebugToFile)
    {
        WriteMessageToFile( szMsg );
        WriteMessageToFile( TEXT("\n") );
    }
}

int CWiaDebugger::SetDebugFlags( int nDebugFlags )
{
    int nOld = m_nFlags;
    m_nFlags = nDebugFlags;
    return nOld;
}

int CWiaDebugger::GetDebugFlags(void)
{
    return m_nFlags;
}

int CWiaDebugger::GetStackLevel(void)
{
    return m_nStackLevel;
}

int CWiaDebugger::PushLevel( LPCTSTR lpszFunctionName )
{
    WiaTrace( TEXT("Entering function %s, (Level %d)"), lpszFunctionName, GetStackLevel() );
    return m_nStackLevel++;
}

int CWiaDebugger::PopLevel( LPCTSTR lpszFunctionName )
{
    m_nStackLevel--;
    if (m_nStackLevel < 0)
        m_nStackLevel = 0;
    if (!m_nStackLevel)
        WiaTrace( TEXT("\n") );
    return m_nStackLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\stisvc.cpp ===
/*++                                                           '


Copyright (c)   1997    Microsoft Corporation

Module Name:

    STISvc.CPP

Abstract:

    Code for performing STI service related functions ( Start/Stop etc)
    It is separated from main process code make it possible to share process for
    multiple services ever needed

Author:

    Vlad  Sadovsky  (vlads)     09-20-97

Environment:

    User Mode - Win32

Revision History:

    22-Sep-1997     VladS       created

--*/

//
//  Include Headers
//
#include "precomp.h"

#include "stiexe.h"
#include "device.h"

#include <stisvc.h>
#include <regstr.h>
#include <devguid.h>

typedef LONG NTSTATUS;
#include <svcs.h>

extern HWND        g_hStiServiceWindow;

extern BOOL
StiRefreshWithDelay(
  ULONG  ulDelay,
  WPARAM wParam,
  LPARAM lParam);

//
//  Delay in milliseconds to wait before processing PnP device event
//
#define DEVICEEVENT_WAIT_TIME   1000

//
//  Local variables and types definitions
//

//
//  Service status data
//
SERVICE_STATUS  g_StiServiceStatus;

//
// Handle of registered service, used for updating running status
//
SERVICE_STATUS_HANDLE   g_StiServiceStatusHandle;

//
// Initialization flag
//
BOOL    g_fStiServiceInitialized = FALSE;

//
// What type of sink to use
//
#ifdef WINNT
BOOL    g_fUseServiceCtrlSink = TRUE;
#else
BOOL    g_fUseServiceCtrlSink = FALSE;
#endif

//
// Hidden service window
//
HWND    g_hStiServiceWindow = NULL;

//
// Notification sink for PnP notifications
//
HDEVNOTIFY  g_hStiServiceNotificationSink = NULL;


//
// Shutdown event
//
HANDLE  hShutdownEvent = NULL;


#ifdef WINNT
//
//  Local prototypes
//

BOOL
WINAPI
InitializeNTSecurity(
    VOID
    );

BOOL
WINAPI
TerminateNTSecurity(
    VOID
    );
#endif

//
// Service status variable dispatch table
//
SERVICE_TABLE_ENTRY ServiceDispatchTable[] = {
    { STI_SERVICE_NAME, StiServiceMain  },
    { NULL,             NULL            }
};


//
// Code section
//

DWORD
WINAPI
UpdateServiceStatus(
        IN DWORD dwState,
        IN DWORD dwWin32ExitCode,
        IN DWORD dwWaitHint )
/*++
    Description:

        Updates the local copy status of service controller status
         and reports it to the service controller.

    Arguments:

        dwState - New service state.

        dwWin32ExitCode - Service exit code.

        dwWaitHint - Wait hint for lengthy state transitions.

    Returns:

        NO_ERROR on success and returns Win32 error if failure.
        On success the status is reported to service controller.

--*/
{


const TCHAR*   szStateDbgMsg[] = {
    TEXT("SERVICE_UNKNOWN          "),    // 0x00000000
    TEXT("SERVICE_STOPPED          "),    // 0x00000001
    TEXT("SERVICE_START_PENDING    "),    // 0x00000002
    TEXT("SERVICE_STOP_PENDING     "),    // 0x00000003
    TEXT("SERVICE_RUNNING          "),    // 0x00000004
    TEXT("SERVICE_CONTINUE_PENDING "),    // 0x00000005
    TEXT("SERVICE_PAUSE_PENDING    "),    // 0x00000006
    TEXT("SERVICE_PAUSED           "),    // 0x00000007
    TEXT("SERVICE_UNKNOWN          "),    // 0x00000008
};

    DWORD dwError = NO_ERROR;

    //
    // If state is changing - save the new one
    //
    if (dwState) {
        g_StiServiceStatus.dwCurrentState  = dwState;
    }

    g_StiServiceStatus.dwWin32ExitCode = dwWin32ExitCode;
    g_StiServiceStatus.dwWaitHint      = dwWaitHint;

    //
    // If we are in the middle of lengthy operation, increment checkpoint value
    //
    if ((g_StiServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
        (g_StiServiceStatus.dwCurrentState == SERVICE_STOPPED) ) {
        g_StiServiceStatus.dwCheckPoint    = 0;
    }
    else {
        g_StiServiceStatus.dwCheckPoint++;
    }

#ifdef WINNT

    //
    // Now update SCM running database
    //
    if ( g_fRunningAsService ) {

        DBG_TRC(("Updating service status. CurrentState=%S StateCode=%d",
                g_StiServiceStatus.dwCurrentState < (sizeof(szStateDbgMsg) / sizeof(TCHAR *)) ?
                   szStateDbgMsg[g_StiServiceStatus.dwCurrentState] : szStateDbgMsg[0],
                g_StiServiceStatus.dwCurrentState));

        if( !SetServiceStatus( g_StiServiceStatusHandle, &g_StiServiceStatus ) ) {
            dwError = GetLastError();
        } else {
            dwError = NO_ERROR;
        }
    }

#endif

    return ( dwError);

} // UpdateServiceStatus()


DWORD
WINAPI
StiServiceInitialize(
    VOID
    )
/*++

Routine Description:

    Service initialization, creates all needed data structures

    Nb: This routine has upper limit for execution time, so if it takes too much time
    separate thread will have to be created to queue initialization work

Arguments:

Return Value:

    None.

--*/
{
    HRESULT     hres;
    DWORD       dwError;

    DBG_FN(StiServiceInitialize);

    #ifdef MAXDEBUG
    DBG_TRC(("Start service entered"));
    #endif

    g_StiFileLog->ReportMessage(STI_TRACE_INFORMATION,
                MSG_TRACE_SVC_INIT,TEXT("STISVC"),0);

    //
    //  Create shutdown event.
    //
    hShutdownEvent = CreateEvent( NULL,           //  lpsaSecurity
                                  TRUE,           //  fManualReset
                                  FALSE,          //  fInitialState
                                  NULL );         //  lpszEventName
    if( hShutdownEvent == NULL ) {
        dwError = GetLastError();
        return dwError;
    }

    UpdateServiceStatus(SERVICE_START_PENDING,NOERROR,START_HINT);

    //
    //   Initialize active device list
    //
    InitializeDeviceList();

    //
    // Start RPC servicing
    //
    UpdateServiceStatus(SERVICE_START_PENDING,NOERROR,START_HINT);

    if (NOERROR != StartRpcServerListen()) {
        dwError = GetLastError();
        DBG_ERR(("StiService failed to start RPC listen. ErrorCode=%d", dwError));
        goto Cleanup;
    }

#ifdef WINNT
    //
    // Allow setting window to foreground
    //
    dwError = AllowSetForegroundWindow(GetCurrentProcessId());  // ASFW_ANY
    DBG_TRC((" AllowSetForegroundWindow is called for id:%d . Ret code=%d. LastError=%d ",
            GetCurrentProcessId(),
            dwError,
            ::GetLastError()));
#endif

    //
    // Create hidden window for receiving PnP notifications
    //
    if (!CreateServiceWindow()) {
        dwError = GetLastError();
        DBG_ERR(("Failed to create hidden window for PnP notifications. ErrorCode=%d",dwError));
        goto Cleanup;
    }

#ifdef WINNT
    //
    // Initialize NT security parameters
    //
    InitializeNTSecurity();
#endif

    // No longer needed - the equivalent exists in CWiaDevMan
    // g_pDeviceInfoSet = new DEVICE_INFOSET(GUID_DEVCLASS_IMAGE);
    g_pDeviceInfoSet = NULL;

    //
    // Initiate device list refresh
    //

    //::PostMessage(g_hStiServiceWindow,
    //              STIMON_MSG_REFRESH,
    //              STIMON_MSG_REFRESH_REREAD,
    //              STIMON_MSG_REFRESH_NEW | STIMON_MSG_REFRESH_EXISTING
    //              | STIMON_MSG_BOOT  // This shows this is the first device enumeration - no need to generate events
    //              );

    //
    // Finally we are running
    //
    g_fStiServiceInitialized = TRUE;

    UpdateServiceStatus(SERVICE_RUNNING,NOERROR,0);

    #ifdef MAXDEBUG
    g_EventLog->LogEvent(MSG_STARTUP,
                         0,
                         (LPCSTR *)NULL);
    #endif

    g_StiFileLog->ReportMessage(STI_TRACE_INFORMATION,MSG_STARTUP);

    return NOERROR;

Cleanup:

    //
    // Something failed , call stop routine to clean up
    //
    StiServiceStop();

    return dwError;

} // StiServiceInitialize

VOID
WINAPI
StiServiceStop(
    VOID
    )
/*++

Routine Description:

    Stopping STI service

Arguments:

Return Value:

    None.

--*/
{

    DBG_FN(StiServiceStop);

    DBG_TRC(("Service is exiting"));

    UpdateServiceStatus(SERVICE_STOP_PENDING,NOERROR,START_HINT);

#ifdef WINNT


    //
    // Clean up PnP notification handles
    //
    if (g_hStiServiceNotificationSink && g_hStiServiceNotificationSink!=INVALID_HANDLE_VALUE) {
        UnregisterDeviceNotification(g_hStiServiceNotificationSink);
        g_hStiServiceNotificationSink = NULL;
    }

    for (UINT uiIndex = 0;
              (uiIndex < NOTIFICATION_GUIDS_NUM );
              uiIndex++)
    {
        if (g_phDeviceNotificationsSinkArray[uiIndex] && (g_phDeviceNotificationsSinkArray[uiIndex]!=INVALID_HANDLE_VALUE)) {
            UnregisterDeviceNotification(g_phDeviceNotificationsSinkArray[uiIndex]);
            g_phDeviceNotificationsSinkArray[uiIndex]  = NULL;
        }
    }

#endif

    //
    // Stop item scheduler
    //
    SchedulerSetPauseState(TRUE);

    //
    // Destroy service window
    //
    if (g_hStiServiceWindow) {
        DestroyWindow(g_hStiServiceWindow);
        g_hStiServiceWindow = NULL;
    }

#ifdef WINNT
    //
    // Free security objects
    //
    if(!TerminateNTSecurity()) {
        DBG_ERR(("Failed to clean up security objects"));
    }
#endif

    //
    // Stop RPC servicing
    //
    if(NOERROR != StopRpcServerListen()) {
        DBG_ERR(("Failed to stop RpcServerListen"));
    }

    //
    // Terminate device list
    //
    TerminateDeviceList();

    // Destroy info set
    //if (g_pDeviceInfoSet) {
    //    delete g_pDeviceInfoSet;
    // }

    //
    // Resume scheduling to allow for internal work items to complete
    // At this point all device related items should've been purged by
    // device object destructors
    //
    SchedulerSetPauseState(FALSE);

    //
    // Finish
    //

    g_fStiServiceInitialized = FALSE;

    #ifdef MAXDEBUG
    g_EventLog->LogEvent(MSG_STOP,
                         0,
                         (LPCSTR *)NULL);
    #endif

    //
    // UnRegister the WiaDevice manager from the ROT
    //
    InitWiaDevMan(WiaUninitialize);

    //
    // Signal shutdown
    //
    SetEvent(hShutdownEvent);

    //UpdateServiceStatus(SERVICE_STOPPED,NOERROR,0);

}  // StiServiceStop

VOID
WINAPI
StiServicePause(
    VOID
    )
/*++

Routine Description:

    Pausing  STI service

Arguments:

Return Value:

    None.

--*/
{

    DBG_FN(StiServicePause);

    //
    // System is suspending - take snapshot of currently active devices
    //
    UpdateServiceStatus(SERVICE_PAUSE_PENDING,NOERROR,PAUSE_HINT);

    if ( (g_StiServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
         (g_StiServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ){

        // Stop running work items queue
        //
        // Nb:  if refresh routine is scheduled to run as work item, this is a problem
        //
        SchedulerSetPauseState(TRUE);


        /*  The equivalent done by HandlePowerEvent
        SendMessage(g_hStiServiceWindow,
                    STIMON_MSG_REFRESH,
                    STIMON_MSG_REFRESH_SUSPEND,
                    STIMON_MSG_REFRESH_EXISTING
                    );
       */
    }

} // StiServicePause

VOID
WINAPI
StiServiceResume(
    VOID
    )
/*++

Routine Description:

    Resuming STI service

Arguments:

Return Value:

    None.

--*/
{

    DBG_FN(StiServiceResume);

    SchedulerSetPauseState(FALSE);

    PostMessage(g_hStiServiceWindow,
                STIMON_MSG_REFRESH,
                STIMON_MSG_REFRESH_RESUME,
                STIMON_MSG_REFRESH_NEW | STIMON_MSG_REFRESH_EXISTING
                );

    UpdateServiceStatus(SERVICE_RUNNING,NOERROR,0);

}  // StiServiceResume

ULONG
WINAPI
StiServiceCtrlHandler(
    IN DWORD    dwOperation,
    DWORD       dwEventType,
    PVOID       EventData,
    PVOID       pData
    )
/*++

Routine Description:

    STI service control dispatch function

Arguments:

    SCM OpCode

Return Value:

    None.
--*/
{
    ULONG retval = NO_ERROR;
    
    DBG_TRC(("Entering CtrlHandler OpCode=%d",dwOperation));

    switch (dwOperation) {
        case SERVICE_CONTROL_STOP:
            StiServiceStop();
            break;

        case SERVICE_CONTROL_PAUSE:
            StiServicePause();
            break;

        case SERVICE_CONTROL_CONTINUE:
            StiServiceResume();
            break;

        case SERVICE_CONTROL_SHUTDOWN:
            StiServiceStop();
            break;

        case SERVICE_CONTROL_PARAMCHANGE:
            //
            // Refresh device list.
            //
            g_pMsgHandler->HandleCustomEvent(SERVICE_CONTROL_PARAMCHANGE);
            break;

        case SERVICE_CONTROL_INTERROGATE:
            // Report current state and status
            UpdateServiceStatus(0,NOERROR,0);
            break;

        case SERVICE_CONTROL_DEVICEEVENT:
            //
            // PnP event.
            //

            //
            // Until our PnP issues are resolved, keep logging PnP events so we know
            // whether we received it or not...
            //

            DBG_WRN(("::StiServiceCtrlHandler, Received PnP event..."));

            g_pMsgHandler->HandlePnPEvent(dwEventType, EventData);
            break;

        case SERVICE_CONTROL_POWEREVENT:
            //
            // Power management event
            //
            retval = g_pMsgHandler->HandlePowerEvent(dwEventType, EventData);
            break;

        case STI_SERVICE_CONTROL_REFRESH:

            //
            // Refresh device list.
            //
            DBG_TRC(("::StiServiceCtrlHandler, Received STI_SERVICE_CONTROL_REFRESH"));
            g_pMsgHandler->HandleCustomEvent(STI_SERVICE_CONTROL_REFRESH);

            break;

        case STI_SERVICE_CONTROL_EVENT_REREAD:
            //
            // Refresh device list.
            //
            DBG_TRC(("::StiServiceCtrlHandler, Received STI_SERVICE_CONTROL_EVENT_REREAD"));
            g_pMsgHandler->HandleCustomEvent(STI_SERVICE_CONTROL_EVENT_REREAD);

            break;


        case STI_SERVICE_CONTROL_LPTENUM:

            //
            // Enumerate LPT port.
            //

            EnumLpt();
            break;

        default:
            // Unknown opcode
            ;
    }

    DBG_TRC(("Exiting CtrlHandler"));

    return retval;

} // StiServiceCtrlHandler

BOOL RegisterServiceControlHandler()
{
    DWORD dwError = 0;

#ifdef WINNT

    g_StiServiceStatusHandle = RegisterServiceCtrlHandlerEx(
                                        STI_SERVICE_NAME,
                                        StiServiceCtrlHandler,
                                        (LPVOID)STI_SERVICE__DATA
                                        );
    if(!g_StiServiceStatusHandle) {
        // Could not register with SCM

        dwError = GetLastError();
        DBG_ERR(("Failed to register CtrlHandler,ErrorCode=%d",dwError));
        return FALSE;
    }

#endif
    return TRUE;
}


VOID
WINAPI
StiServiceMain(
    IN DWORD    argc,
    IN LPTSTR   *argv
    )
/*++

Routine Description:

    This is service main entry, that is called by SCM

Arguments:

Return Value:

    None.

--*/
{
    DWORD   dwError;
    DEV_BROADCAST_DEVICEINTERFACE PnPFilter;

    DBG_FN(StiServiceMain);
    #ifdef MAXDEBUG
    DBG_TRC(("StiServiceMain entered"));
    #endif
    
    //
    //  REMOVE:  This is not actually an error, but we will use error logging to gurantee
    //  it always get written to the log.    This should be removed as soon as we know what
    //  causes #347835.
    //
    SYSTEMTIME SysTime;
    GetLocalTime(&SysTime);
    DBG_ERR(("*> StiServiceMain entered, Time: %d/%02d/%02d %02d:%02d:%02d:%02d", 
                  SysTime.wYear,
                  SysTime.wMonth,
                  SysTime.wDay,
                  SysTime.wHour,
                  SysTime.wMinute,
                  SysTime.wSecond,
                  SysTime.wMilliseconds));

    g_StiServiceStatus.dwServiceType    =   STI_SVC_SERVICE_TYPE;
    g_StiServiceStatus.dwCurrentState   =   SERVICE_START_PENDING;
    g_StiServiceStatus.dwControlsAccepted=  SERVICE_ACCEPT_STOP |
                                            SERVICE_ACCEPT_SHUTDOWN |
                                            SERVICE_ACCEPT_PARAMCHANGE |
                                            SERVICE_ACCEPT_POWEREVENT;

    g_StiServiceStatus.dwWin32ExitCode  = NO_ERROR;
    g_StiServiceStatus.dwServiceSpecificExitCode = NO_ERROR;
    g_StiServiceStatus.dwCheckPoint     = 0;
    g_StiServiceStatus.dwWaitHint       = 0;

    dwError = StiServiceInitialize();

    if (NOERROR == dwError) {


#ifdef WINNT

        if (g_fUseServiceCtrlSink && !g_hStiServiceNotificationSink) {

            DBG_WRN(("::StiServiceMain, About to register for PnP..."));

            //
            // Register for the PnP Device Interface change notifications
            //

            memset(&PnPFilter, 0, sizeof(PnPFilter));
            PnPFilter.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
            PnPFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
            PnPFilter.dbcc_reserved = 0x0;
            PnPFilter.dbcc_classguid = *g_pguidDeviceNotificationsGuid;

            //memcpy(&PnPFilter.dbcc_classguid,
            //       (LPGUID) g_pguidDeviceNotificationsGuid,
            //       sizeof(GUID));

            g_hStiServiceNotificationSink = RegisterDeviceNotification(
                                 (HANDLE) g_StiServiceStatusHandle,
                                 &PnPFilter,
                                 DEVICE_NOTIFY_SERVICE_HANDLE
                                 );
            if (NULL == g_hStiServiceNotificationSink) {
                //
                // Could not register with PnP - attempt to use window handle
                //
                g_fUseServiceCtrlSink = FALSE;
            }

            //
            // Separately from main Image interface , register list of optional device interfaces
            // we will monitor to allow parameters refresh.
            //
            for (UINT uiIndex = 0;
                      (uiIndex < NOTIFICATION_GUIDS_NUM ) && (!::IsEqualGUID(g_pguidDeviceNotificationsGuidArray[uiIndex],GUID_NULL));
                      uiIndex++)
            {
                ::ZeroMemory(&PnPFilter, sizeof(PnPFilter));

                PnPFilter.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
                PnPFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
                PnPFilter.dbcc_reserved = 0x0;
                PnPFilter.dbcc_classguid = g_pguidDeviceNotificationsGuidArray[uiIndex];

                g_phDeviceNotificationsSinkArray[uiIndex] = RegisterDeviceNotification(
                        (HANDLE) g_StiServiceStatusHandle,
                        &PnPFilter,
                        DEVICE_NOTIFY_SERVICE_HANDLE
                        );

                DBG_TRC(("Registering optional interface #%d . Returned handle=%X",
                        uiIndex,g_phDeviceNotificationsSinkArray[uiIndex]));
            }
        }

#else
    // Windows 98 case
    g_fUseServiceCtrlSink = FALSE;

#endif
        //
        // Service initialized , process command line arguments
        //
        BOOL    fVisualize = FALSE;
        BOOL    fVisualizeRequest = FALSE;
        TCHAR   cOption;
        UINT    iCurrentOption = 0;

        for (iCurrentOption=0;
             iCurrentOption < argc ;
             iCurrentOption++ ) {

            cOption = *argv[iCurrentOption];
            // pszT = argv[iCurrentOption]+ 2 * sizeof(TCHAR);

            switch ((TCHAR)LOWORD(::CharUpper((LPTSTR)cOption))) {
                case 'V':
                    fVisualizeRequest = TRUE;
                    fVisualize = TRUE;
                    break;
                case 'H':
                    fVisualizeRequest = TRUE;
                    fVisualize = FALSE;
                    break;
                default:
                    break;
            }

            if (fVisualizeRequest ) {
                VisualizeServer(fVisualizeRequest);
            }
        }

        //
        // Wait for shutdown processing messages.  We make ourselves alertable so we
        // can receive Shell's Volume notifications via APCs.  If we're woken
        // up to process the APC, then we must wait again.
        //
        while(WaitForSingleObjectEx(hShutdownEvent, INFINITE, TRUE) == WAIT_IO_COMPLETION);

#ifndef WINNT
        //Don't use windows messaging on NT

        //
        // Close down message pump
        //
        if (g_dwMessagePumpThreadId) {

            // Indicate we are entering shutdown
            g_fServiceInShutdown = TRUE;

            PostThreadMessage(g_dwMessagePumpThreadId, WM_QUIT, 0, 0L );
        }
#endif

        CloseHandle( hShutdownEvent );
        hShutdownEvent = NULL;
    }
    else {
        // Could not initialize service, service failed to start
    }

    //
    //  REMOVE:  This is not actually an error, but we will use error logging to gurantee
    //  it always get written to the log.    This should be removed as soon as we know what
    //  causes #347835.
    //
    GetLocalTime(&SysTime);
    DBG_ERR(("<* StiServiceMain ended, Time: %d/%02d/%02d %02d:%02d:%02d:%02d", 
                  SysTime.wYear,
                  SysTime.wMonth,
                  SysTime.wDay,
                  SysTime.wHour,
                  SysTime.wMinute,
                  SysTime.wSecond,
                  SysTime.wMilliseconds));
    return;

} // StiServiceMain

HWND
WINAPI
CreateServiceWindow(
    VOID
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/

{
#ifndef WINNT
    //Don't use windows messaging on NT

    WNDCLASSEX  wc;
    DWORD       dwError;
    HWND        hwnd = FindWindow(g_szStiSvcClassName,NULL);

    // Window should NOT exist at this time
    if (hwnd) {
        DPRINTF(DM_WARNING  ,TEXT("Already registered window"));
        return NULL;
    }

    //
    // Create class
    //
    ZeroMemory(&wc, sizeof(wc));

    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_GLOBALCLASS;
    wc.lpfnWndProc = StiSvcWinProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hInst;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW+1);
    wc.lpszClassName = g_szStiSvcClassName;
    wc.lpszMenuName = MAKEINTRESOURCE(IDR_MENU);

    if (!RegisterClassEx(&wc)) {

        dwError = GetLastError();
        if (dwError != ERROR_CLASS_ALREADY_EXISTS) {
            DBG_ERR(("Failed to register window class ErrorCode=%d",dwError));
            return NULL;
        }
    }

    #ifndef WINNT
    #ifdef FE_IME
    // Disable IME processing on Millenium
    ImmDisableIME(::GetCurrentThreadId());
    #endif
    #endif

    g_hStiServiceWindow = CreateWindowEx(0,         // Style bits
                          g_szStiSvcClassName,      // Class name
                          g_szTitle,                // Title
                          WS_DISABLED ,             // Window style bits
                          CW_USEDEFAULT,            // x
                          CW_USEDEFAULT,            // y
                          CW_USEDEFAULT,            // h
                          CW_USEDEFAULT,            // w
                          NULL,                     // Parent
                          NULL,                     // Menu
                          g_hInst,       // Module instance
                          NULL);                    // Options

    if (!g_hStiServiceWindow) {
        dwError = GetLastError();
        DBG_ERR(("Failed to create PnP window ErrorCode=%d"),dwError);
    }

#else
    g_hStiServiceWindow = (HWND) INVALID_HANDLE_VALUE;
#endif
    return g_hStiServiceWindow;

} // CreateServiceWindow

//
// Installation routines.
// They are here to simplify debugging and troubleshooting, called by switches
// on command line
//
DWORD
WINAPI
StiServiceInstall(
    LPTSTR  lpszUserName,
    LPTSTR  lpszUserPassword
    )
/*++

Routine Description:

    Service installation function.
    Calls SCM to install STI service, which is running in user security context

Arguments:

Return Value:

    None.

--*/
{

    DWORD       dwError = NOERROR;

#ifdef WINNT

    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hService = NULL;

    TCHAR       szDisplayName[MAX_PATH];

    //
    //  Write the svchost group binding to stisvc
    //

    RegEntry SvcHostEntry(STI_SVC_HOST, HKEY_LOCAL_MACHINE);
    TCHAR szValue[MAX_PATH];
    lstrcpy (szValue, STI_SERVICE_NAME);
    // REG_MULTI_SZ is double null terminated
    *(szValue+lstrlen(szValue)+1) = TEXT('\0');
    SvcHostEntry.SetValue(STI_IMGSVC, STI_SERVICE_NAME, REG_MULTI_SZ);

#endif // winnt

    //
    // Write parameters key for svchost
    //

    TCHAR   szMyPath[MAX_PATH] = TEXT("\0");
    TCHAR   szSvcPath[MAX_PATH] = SYSTEM_PATH;
    LONG    lLen;
    LONG    lNameIndex = 0;

    if (lLen = ::GetModuleFileName(g_hInst, szMyPath, sizeof(szMyPath)/sizeof(szMyPath[0])) ) {

        RegEntry SvcHostParm(STI_SERVICE_PARAMS, HKEY_LOCAL_MACHINE);

        //
        //  Get the name of the service file (not including the path)
        //

        for (lNameIndex = lLen; lNameIndex > 0; lNameIndex--) {
            if (szMyPath[lNameIndex] == '\\') {
                lNameIndex++;
                break;
            }
        }

        if (lNameIndex) {

#ifndef WINNT
            //
            //  Windows 98 specific entry
            //

            TCHAR szWinDir[MAX_PATH] = TEXT("\0");

            if (!GetWindowsDirectory(szWinDir, MAX_PATH)) {
                DPRINTF(DM_ERROR  ,TEXT("Error extracting Still Image service filename."));
                return dwError;
            }

            lstrcat(szWinDir, SYSTEM_PATH);
            lstrcpy(szSvcPath, szWinDir);
#endif

            lstrcat(szSvcPath, &szMyPath[lNameIndex]);
            SvcHostParm.SetValue(REGSTR_SERVICEDLL, szSvcPath, PATH_REG_TYPE);

        } else {
            DBG_ERR(("Error extracting Still Image service filename."));
        }
    }
    else {
        DBG_ERR(("Failed to get my own path registering Still Image service . LastError=%d",
                 ::GetLastError()));
    }

    // Add registry settings for event logging
    RegisterStiEventSources();

    return dwError;

} //StiServiceInstall


DWORD
WINAPI
StiServiceRemove(
    VOID
    )

/*++

Routine Description:

    Service removal function.  This function calls SCM to remove the STI  service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success

--*/

{
    DWORD       dwError = NOERROR;

#ifdef WINNT

    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hService = NULL;

    SERVICE_STATUS  ServiceStatus;
    UINT        uiRetry = 10;

    __try  {

        hSCM = ::OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);

        if (!hSCM) {
            dwError = GetLastError();
            __leave;
        }

        hService = OpenService(
                            hSCM,
                            STI_SERVICE_NAME,
                            SERVICE_ALL_ACCESS
                            );
        if (!hService) {
            dwError = GetLastError();
            __leave;
        }


        //
        // Stop service first
        //

        if (ControlService( hService, SERVICE_CONTROL_STOP, &ServiceStatus )) {
            //
            // Wait a little
            //
            Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );

            ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;

            while( QueryServiceStatus( hService, &ServiceStatus ) &&
                  (SERVICE_STOP_PENDING ==  ServiceStatus.dwCurrentState)) {
                Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );
                if (!uiRetry--) {
                    break;
                }
            }

            if (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
                dwError = GetLastError();
                __leave;
            }
        }
        else {
            dwError = GetLastError();

            //
            //  ERROR_SERVICE_NOT_ACTIVE is fine, since it means that the service has
            //  already been stopped.  If the error is not ERROR_SERVICE_NOT_ACTIVE then
            //  something has gone wrong, so __leave.
            //

            if (dwError != ERROR_SERVICE_NOT_ACTIVE) {
                __leave;
            }
        }

        if (!DeleteService( hService )) {
            dwError = GetLastError();
            __leave;
        }
        else {
            DBG_TRC(("StiServiceRemove, removed STI service"));
        }
    }
    __finally {
        CloseServiceHandle( hService );
        CloseServiceHandle( hSCM );
    }

#endif

    return dwError;

} // StiServiceRemove

VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA    pGlobals
    )
{

    //
    //  For now, we do nothing here.  We will need to revisit when we run under
    //  a shared SvcHost Group.
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiadevman.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiadevman.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        6 Nov, 2000
*
*  DESCRIPTION:
*   Declarations and definitions for the WIA device manager class.
*   It controls the enumeration of devices, the internal device list, adding
*   removing of devices from this list (PnP initiated) and implements the
*   IWiaDevMgr interface.
*
*******************************************************************************/

#include "precomp.h"
#include "stiexe.h"
#include "enum.h"
#include "shpriv.h"
#include "devmgr.h"
#include "wiaevntp.h"

//
//  NOTE:   For Automated testing of FS devices, the volume devices need to
//          be visible from normal WIA enumeration and not just Autoplay.
//
//          Uncomment the "#define PRIVATE_FOR_TEST"
//          This will enable ALL mass storage devices to show up as normal
//          WIA devices (i.e. accessible by all WIA apps, Shell etc.).  That
//          includes your floppy drives, CD-ROMs, ZIP and so on.
//
//  #define PRIVATE_FOR_TEST

//
//  Helper functions
//

#define DEV_STATE_MASK  0xFFFFFFF8

/**************************************************************************\
* ::IsCorrectVolumeType
*
*   This function checks whether the given volume is one that WIA will
*   accept as a possible candidate for the FS driver.  We only
*   allow:
*       Removable drives
*       File systems that don't enforce security
*
* Arguments:
*
*   wszMountPoint   -   The volume mount point
*
* Return Value:
*
*   DeviceState
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
BOOL    IsCorrectVolumeType(
    LPWSTR wszMountPoint)
{
    BOOL    bValid      = FALSE;
    DWORD   dwFSFlags   = 0;

    //
    //  Do parameter validation
    //
    if (wszMountPoint) {

        UINT    uDriveType  = GetDriveTypeW(wszMountPoint);
        //
        //  Check whether this is a fixed drive.  We don't allow fixed drives.
        //  Note that we don't worry about network drives because our
        //  volume enumerator only enumerates local volumes.
        //
        if (uDriveType != DRIVE_FIXED) {

            //
            //  Skip floppy drives
            //  
            if ((towupper(wszMountPoint[0]) != L'A') && (towupper(wszMountPoint[0]) != L'B')) {

                //
                //  Check whether file system is securable...
                //
                if (GetVolumeInformationW(wszMountPoint,
                                          NULL,
                                          0,
                                          NULL,
                                          NULL,
                                          &dwFSFlags,
                                          NULL,
                                          0))
                {
                    if (!(dwFSFlags & FS_PERSISTENT_ACLS)) {
                        bValid = TRUE;
                    }
                }
            }
        }
    } else {
        ASSERT(("NULL wszMountPoint parameter - this should never happen!", wszMountPoint));
    }

    return bValid;
}

/**************************************************************************\
* ::MapCMStatusToDeviceState
*
*   This function translates status and problem number information returned
*   from CM_Get_DevNode_STatus to our internal device state flags.  The
*   status of the dev node tells us whether the device is active or disabled
*   etc.
*
* Arguments:
*
*   dwOldDevState   -   The previous device state.  This contains other
*                       bits we wamt to carry over.  Currently, this
*                       is only the DEV_STATE_CON_EVENT_WAS_THROWN
*                       bit.
*   ulStatus        -   Status from CM_Get_DevNode_Status
*   ulProblemNumber -   Problem from CM_Get_DevNode_Status
*
* Return Value:
*
*   DeviceState
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
DWORD MapCMStatusToDeviceState(
    DWORD   dwOldDevState,
    ULONG   ulStatus,
    ULONG   ulProblemNumber)
{
    //
    // Clear the lower 3 bits
    //
    DWORD   dwDevState = dwOldDevState & DEV_STATE_MASK;

    if (ulStatus & DN_STARTED) {
        dwDevState |= DEV_STATE_ACTIVE;
    } else if (ulStatus & DN_HAS_PROBLEM) {

        if (CM_PROB_DISABLED) {
            dwDevState |= DEV_STATE_DISABLED;
        }
        if (CM_PROB_HARDWARE_DISABLED) {
            dwDevState |= DEV_STATE_DISABLED;
        }
        if (CM_PROB_WILL_BE_REMOVED) {
            dwDevState |= DEV_STATE_REMOVED;
        }
    }
    
    return dwDevState;
}

/**************************************************************************\
* ::MapMediaStatusToDeviceState
*
*   This function translates media status to our device internal state.
*
* Arguments:
*
*   dwMediaStatus   -   Media status returned from Shell volume enumeration.
*
* Return Value:
*
*   DeviceState
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
DWORD MapMediaStatusToDeviceState(
    DWORD   dwMediaStatus
    )
{
    DWORD   dwDevState = 0;

    if (dwMediaStatus & HWDMS_PRESENT) {
        dwDevState |= DEV_STATE_ACTIVE;
    }

    return dwDevState;
}

//
//  CWiaDevMan Methods
//

/**************************************************************************\
* CWiaDevMan::CWiaDevMan
*
*   Constructor
*
* Arguments:
*
*   None
*
* Return Value:
*
*   None
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
CWiaDevMan::CWiaDevMan()
{
    m_DeviceInfoSet = NULL;
    m_bMakeVolumesVisible = FALSE;
    m_bVolumesEnabled = TRUE;
    m_dwHWCookie            = 0;
}

/**************************************************************************\
* CWiaDevMan::~CWiaDevMan
*
*   Destructor - kills the device list and destroys our infoset
*
* Arguments:
*
*   None
*
* Return Value:
*
*   None
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
CWiaDevMan::~CWiaDevMan()
{
    //  Destroy all our device objects
    DestroyDeviceList();

    //  Destroy our device infoset
    DestroyInfoSet();

    if (m_dwHWCookie) {

        //
        //  Unregister for notifications
        //
        HRESULT             hr          = S_OK;
        IHardwareDevices    *pihwdevs   = NULL;

         hr = CoCreateInstance(CLSID_HardwareDevices, 
                              NULL,
                              CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG, 
                              IID_IHardwareDevices, 
                              (VOID**)&pihwdevs);
         if (SUCCEEDED(hr)) {
             pihwdevs->Unadvise(m_dwHWCookie);
             m_dwHWCookie = 0;
             pihwdevs->Release();
         } else {
             DBG_WRN(("CWiaDevMan::~CWiaDevMan, CoCreateInstance, looking for Shell interface IHardwareDevices failed"));
         }
    }
}

/**************************************************************************\
* CWiaDevMan::Initialize
*
*   This method initializes the device manager object.  It does not enumerate
*   any devices - ReEnumerateDevices needs to be called to populate our
*   device list.
*
* Arguments:
*
*   dwCallbackThreadId  - This specifies the id of the thread on which we 
*                         will receive volume notifications.  Notice
*                         that these callbacks are done via APCs, so this 
*                         ThreadId must not change, or we should reregister
*                         with the new ThreadId.
*
* Return Value:
*
*   Status
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
HRESULT CWiaDevMan::Initialize()
{
    HRESULT             hr          = S_OK;
    IHardwareDevices    *pihwdevs   = NULL;

    //
    //  Initialize the device list head
    //
    InitializeListHead(&m_leDeviceListHead);

    //
    //  Check that our critical section was initialized correctly
    //
    if (!m_csDevList.IsInitialized()) {
        DBG_ERR(("CWiaDevMan::Initialize, Critical section could not be initialized"));
        return E_UNEXPECTED;
    }

    //
    //  Check our relevant registry settings
    //
    GetRegistrySettings();

    if (VolumesAreEnabled()) {

        /*  This code has been removed for this release.  It would be used
            to enable scenarios based on Mass Storage Class cameras behaving
            like normal WIA devices, specifically with us being able to 
            throw "Connect" and "Disconnect" events.
            This may be re-enabled for the next release.  When it does, we must
            be sure to revisit our APC notification handler:  CWiaDevMan::ShellHWEventAPCProc.
            It should be re-written not to make any COM calls, else we'll hit a problem when
            multiple APCs are queued, as soon as we make a COM invocation, we enter a wait
            state, which causes the next APC request to execute.  This leads to "nested"
            COM calls, which is not supported by the OS.
        hr = CoCreateInstance(CLSID_HardwareDevices,
                              NULL,
                              CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG,
                              IID_IHardwareDevices,
                              (VOID**)&pihwdevs);
        if (SUCCEEDED(hr)) {

            HANDLE hPseudoThread = GetCurrentThread();  // Note that this is a pseudo handle and need not be closed
            HANDLE hThread = NULL;                      // IHardwareDevices will close this handle when it is done
            if (DuplicateHandle(GetCurrentProcess(), 
                                hPseudoThread,
                                GetCurrentProcess(), 
                                &hThread, 
                                DUPLICATE_SAME_ACCESS, 
                                FALSE, 
                                0)) {
                //
                //  Register this object for Volume notifications.
                //

                hr = pihwdevs->Advise(GetCurrentProcessId(), 
                                      (ULONG_PTR)hThread, 
                                      (ULONG_PTR)CWiaDevMan::ShellHWEventAPCProc,
                                      &m_dwHWCookie);
            } else {
                DBG_WRN(("CWiaDevMan::Initialize, DuplicateHandle failed, could not register for Volume Notifications"));
            }
            pihwdevs->Release();
        } else {
            DBG_WRN(("CWiaDevMan::Initialize, CoCreateInstance on CLSID_HardwareDevices failed, could not register for Volume Notifications"));
        }
        */
    }

    //
    //  Create our infoset.  Note that we overwrite hr here, since if we cannot
    //  see volumes, it is not fatal to us.
    //
    hr = CreateInfoSet();

    return hr;
}

/**************************************************************************\
* CWiaDevMan::GetRegistrySettings
*
*   This method reads certain registry entries related to the WiaDevMan
*   operation.  Currently, we're looking for:
*
*   EnableVolumeDevices      -  Indicates whether we enable volumes.  We
*                               assume they're enabled unless it's registry
*                               value is specifically 0.
*   MakeVolumeDevicesVisible -  Indicates whether volume device should be
*                               included in normal device enumeration.  This
*                               makes them visible to the outside world by
*                               default.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   None
*
* History:
*
*    01/27/2001 Original Version
*
\**************************************************************************/
VOID CWiaDevMan::GetRegistrySettings()
{
    HRESULT hr      = S_OK;
    DWORD   dwVal   = 0;
    DWORD   dwRet   = 0;
    HKEY    hKey    = NULL;

    //
    //  Open the registry in the right place
    //

    dwRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           REGSTR_PATH_STICONTROL_W,
                           0,
                           0,
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ,
                           NULL,
                           &hKey,
                           NULL);
    if (dwRet == ERROR_SUCCESS && IsValidHANDLE(hKey)) {

        //
        //  Read "EnableVolumeDevices"
        //
        hr = ReadRegistryDWORD(hKey,
                               REGSTR_VAL_ENABLE_VOLUMES_W,
                               &dwVal);
        if ((hr == S_OK) && (dwVal == 0)) {

            //
            //  Disable volume device
            //
            m_bVolumesEnabled = FALSE;
            DBG_TRC(("CWiaDevMan::GetRegistrySettings, volume devices disabled"));
        } else {

            //
            //  Enable volume devices
            //
            m_bVolumesEnabled = TRUE;
            DBG_TRC(("CWiaDevMan::GetRegistrySettings, volume devices Enabled"));
        }

        dwVal = 0;

#ifdef PRIVATE_FOR_TEST
        //
        //  Read "MakeVolumeDevicesVisible"
        //
        hr = ReadRegistryDWORD(hKey,
                               REGSTR_VAL_MAKE_VOLUMES_VISIBLE_W,
                               &dwVal);
#endif
        if (dwVal == 0) {

            //
            //  Make volume devices invisible from normal enumeration
            //
            m_bMakeVolumesVisible = FALSE;
            DBG_TRC(("CWiaDevMan::GetRegistrySettings, volume devices invisible by default"));
        } else {

            //
            //  Make volume devices visible in normal enumeration
            //
            m_bMakeVolumesVisible = TRUE;
            DBG_TRC(("CWiaDevMan::GetRegistrySettings, volume devices now visible by default"));
        }

        RegCloseKey(hKey);
    }
}

/**************************************************************************\
* CWiaDevMan::ReEnumerateDevices
*
*   This method enumerates devices (both real WIA and volumes).  Flags
*   specify whether we should do a refresh or throw events.
*
*   Refresh means:  Re-Enumerate devices and find out whether we
*   have any extra or missing entries.
*   GenEvents means throw connect events for devices.
*   that we noticed have arrived or left since last eneumeration.  Only
*   valid with Refresh.  We always throw disconnect events.
*
* Arguments:
*
*   ulFlags -   Options for enumeration.  See DEV_MAN_FULL_REFRESH
*                                             DEV_MAN_GEN_EVENTS
*
* Return Value:
*
*   Status
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
HRESULT CWiaDevMan::ReEnumerateDevices(
    ULONG ulFlags)
{
    TAKE_CRIT_SECT  tcs(m_csDevList);
    HRESULT         hr                  = S_OK;

    ResetEvent(g_hDevListCompleteEvent);

    //
    //  Check whether flags indicate refresh.
    //

    if (ulFlags & DEV_MAN_FULL_REFRESH) {
        DestroyInfoSet();
        hr = CreateInfoSet();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaDevMan::ReEnumerateDevices, failed to CreateInfoSet"));
            SetEvent(g_hDevListCompleteEvent);
            return hr;
        }
    }

    //
    //  To generate events, we do it in 3 steps:
    //  1.  Mark existing devices in list as  "inactive".
    //  2.  Do low level enumeration to find out what devices exist now, and
    //      create new DEVICE_OBJECTS if necessary.  On creation, throw connect
    //      event.  Mark device as "active", whether newly created or not.
    //  3.  Traverse device list to see whether any devices in list are still
    //      marked "inactive" - these devices need to be removed.  For each
    //      device that needs to be removed, throw diconnect event.
    //  NOTE:  This method is NOT the preferred method to handle device arrivals!
    //

    if (ulFlags & DEV_MAN_GEN_EVENTS) {

        //
        //  This is Step 1. of events
        //
        ForEachDeviceInList(DEV_MAN_OP_DEV_SET_FLAGS, STIMON_AD_FLAG_MARKED_INACTIVE);
    }

    //
    //  Update service status with start pending if requested
    //
    if (ulFlags & DEV_MAN_STATUS_STARTP) {
        UpdateServiceStatus(SERVICE_START_PENDING,NOERROR,START_HINT);
    }

    //
    //  Now, let's enumerate WIA "devnode" devices
    //  This is Step 2. of events
    //

    //  NOTE: Always Continue with enumeration, so skip the usual "if (SUCCEEDED)" checks
    EnumDevNodeDevices(ulFlags);

    //
    //  Update service status with start pending if requested
    //
    if (ulFlags & DEV_MAN_STATUS_STARTP) {
        UpdateServiceStatus(SERVICE_START_PENDING,NOERROR,START_HINT);
    }

    //
    //  Now, let's enumerate WIA "interface" devices
    //
    EnumInterfaceDevices(ulFlags);

    //
    //  Update service status with start pending if requested
    //
    if (ulFlags & DEV_MAN_STATUS_STARTP) {
        UpdateServiceStatus(SERVICE_START_PENDING,NOERROR,START_HINT);
    }

    //
    //  If volumes are enabled, then enumerate them.
    //
    //
    //  Issue - do we ever generate connect events for volumes?
    //
    if (VolumesAreEnabled()) {
        EnumVolumes(ulFlags);
    }

    //
    //  Update service status with start pending if requested
    //
    if (ulFlags & DEV_MAN_STATUS_STARTP) {
        UpdateServiceStatus(SERVICE_START_PENDING,NOERROR,START_HINT);
    }

    if (ulFlags & DEV_MAN_GEN_EVENTS) {

        //
        //  This is Step 3. of events
        //
        ForEachDeviceInList(DEV_MAN_OP_DEV_REMOVE_MATCH, STIMON_AD_FLAG_MARKED_INACTIVE);
    }

    //
    //  Update service status with start pending if requested
    //
    if (ulFlags & DEV_MAN_STATUS_STARTP) {
        UpdateServiceStatus(SERVICE_START_PENDING,NOERROR,START_HINT);
    }

    SetEvent(g_hDevListCompleteEvent);
    return hr;
}

//  ulFlags indicate whether we should throw connect event
HRESULT CWiaDevMan::AddDevice(
    ULONG       ulFlags,
    DEVICE_INFO *pInfo)
{
    TAKE_CRIT_SECT  tcs(m_csDevList);
    HRESULT         hr              = S_OK;
    ACTIVE_DEVICE   *pActiveDevice  = NULL;

    if (pInfo) {
        pActiveDevice = new ACTIVE_DEVICE(pInfo->wszDeviceInternalName, pInfo);
        //
        //  Note that the ACTIVE_DEVICE will decide whether it should load
        //  the driver or not.
        //
        if (pActiveDevice) {
            if (pActiveDevice->IsValid()) {
                //
                //  Add this device to the device list.  TBD:  We may want
                //  exclusive access to the list here.  Do we do it, or the caller?
                //
                InsertTailList(&m_leDeviceListHead,&pActiveDevice->m_ListEntry);

                TAKE_ACTIVE_DEVICE tad(pActiveDevice);

                pActiveDevice->InitPnPNotifications(NULL);

                //
                //  Throw CONNECT event, if we're told to.  Notice that GenerateEventForDevice
                //  willl change WIA_EVENT_DEVICE_CONNECTED to GUID_DeviceArrivedLaunch in
                //  the case of STI only devices.
                //
                if (ulFlags & DEV_MAN_GEN_EVENTS) {
                    //
                    //  Only throw connect event if device is active, and it is not a
                    //  generic mass storage device (MSC cameras are marked as MSC not 
                    //  VOL).
                    //
                    if ((pInfo->dwDeviceState & DEV_STATE_ACTIVE) && !(pInfo->dwInternalType & INTERNAL_DEV_TYPE_VOL)) {

                        GenerateSafeConnectEvent(pActiveDevice);
                    }
                } else {


                    //
                    //  Mark that the event was generated, even though we didn't actually throw it.
                    //  This is so that the disconnect event will be thrown correctly.
                    //
                    if (pInfo->dwDeviceState & DEV_STATE_ACTIVE)
                    {
                        //
                        //  NOTE:  We only do this if the device is ACTIVE.  Basically, this case
                        //  is used for service startup.  We would miss the device arrival events if
                        //  we did this for inactive devices, because when the device is subsequently
                        //  plugged in, the event would not be generated (if it was already marked).
                        //
                        pActiveDevice->m_DrvWrapper.setConnectEventState(TRUE);
                    }
                }
            } else {
                DBG_ERR(("CWiaDevMan::AddDevice, could not create the device object"));
                delete pActiveDevice;
            }
        } else {
            DBG_ERR(("CWiaDevMan::AddDevice, Out of memory"));
            hr = E_OUTOFMEMORY;
        }
    } else {
        DBG_ERR(("CWiaDevMan::AddDevice, called with no device information"));
    }
    return hr;
}

HRESULT CWiaDevMan::RemoveDevice(ACTIVE_DEVICE *pActiveDevice)
{
    HRESULT         hr = S_OK;

    if (pActiveDevice) {

        TAKE_ACTIVE_DEVICE t(pActiveDevice);

        //
        //  Only throw disconnect event if device is not a generic mass storage device 
        //  (MSC cameras are marked as MSC not VOL).
        //
        DEVICE_INFO *pInfo = pActiveDevice->m_DrvWrapper.getDevInfo();
        if (!(pInfo->dwInternalType & INTERNAL_DEV_TYPE_VOL)) {
            //
            // Generate disconnect event
            //
            GenerateSafeDisconnectEvent(pActiveDevice);
        }

        //
        // Mark device as being removed
        //
        pActiveDevice->SetFlags(pActiveDevice->QueryFlags() | STIMON_AD_FLAG_REMOVING);

        //
        // Remove any device notification callbacks
        //
        pActiveDevice->DisableDeviceNotifications();

        //
        // Stop PnP notifications immediately. This is important to free interface handle
        //
        pActiveDevice->StopPnPNotifications();

        //
        // Remove from the list
        //
        RemoveEntryList(&pActiveDevice->m_ListEntry);
        pActiveDevice->m_ListEntry.Flink = pActiveDevice->m_ListEntry.Blink = NULL;
    }

    if (pActiveDevice) {
        //
        // NOTE:  Make sure that TAKE_ACTIVE_DEVICE has released the critical section BEFORE
        //  we call the final release
        // NOTE also an assumption:  The device list critical section must be grabbed before
        //  calling this function, else it may be unsafe.
        //

        //
        // Destroy device object if there are no references to it
        //
        pActiveDevice->Release();
    }



    return hr;
}

HRESULT CWiaDevMan::RemoveDevice(DEVICE_INFO *pInfo)
{
    HRESULT hr = E_NOTIMPL;

    DBG_WRN(("* Not implemented method: CWiaDevMan::RemoveDevice is being called"));

    return hr;
}

HRESULT CWiaDevMan::GenerateEventForDevice(
    const   GUID            *guidEvent,
            ACTIVE_DEVICE   *pActiveDevice)
{
    HRESULT     hr      = S_OK;
    BOOL        bRet    = FALSE;
    STINOTIFY   sNotify;

    if (!guidEvent || !pActiveDevice) {
        DBG_WRN(("CWiaDevMan::GenerateEventForDevice, one or more NULL parameters"));
        return E_POINTER;
    }

    memset(&sNotify, 0, sizeof(sNotify));
    sNotify.dwSize                  = sizeof(STINOTIFY);
    sNotify.guidNotificationCode    = *guidEvent;

    if (*guidEvent == WIA_EVENT_DEVICE_CONNECTED) {
        //
        // If this device or it's USD requests auto-generating a launch event on arrival
        // schedule it here
        //
        //
        // For STI devices we must check whether we need to generate the
        // event.  For WIA devices, we always want to, so it's not an issue.
        //
        if (!pActiveDevice->m_DrvWrapper.IsWiaDevice()) {
            BOOL bStiDeviceMustThrowEvent = (pActiveDevice->QueryFlags() & STIMON_AD_FLAG_NOTIFY_RUNNING)
                                            && pActiveDevice->IsEventOnArrivalNeeded();
            if (!bStiDeviceMustThrowEvent) {
                return S_OK;
            } else {
                //
                //  Make sure we change WIA_EVENT_DEVICE_CONNECTED to the appropriate STI guid
                //
                sNotify.guidNotificationCode = GUID_DeviceArrivedLaunch;
            }
        }
    }

    //
    //  Inform the ACTIVE_DEVICE to process the event
    //
    {
        //TDB:  DO we really need exclusive access to the device object?
        //TAKE_ACTIVE_DEVICE t(pActiveDevice);

        DBG_TRC(("CWiaDevMan::GenerateEventForDevice,, processing event (STI or WIA) for %ws", pActiveDevice->GetDeviceID()));
        bRet = pActiveDevice->ProcessEvent(&sNotify);

        if (!bRet) {
            DBG_WRN(("CWiaDevMan::GenerateEventForDevice, Attempted to generate event on device(%ws) arrival and failed ", pActiveDevice->GetDeviceID()));
        }
    }
    return hr;
}

HRESULT CWiaDevMan::NotifyRunningDriversOfEvent(
    const GUID *pEvent)
{
    TAKE_CRIT_SECT  tcs(m_csDevList);

    HRESULT hr = S_OK;

    //
    //  Walk through list of devices
    //
    LIST_ENTRY      *pentry         = NULL;
    LIST_ENTRY      *pentryNext     = NULL;
    ACTIVE_DEVICE   *pActiveDevice  = NULL;

    {
        //
        //  For each device in list, we want to notify the driver of an event.  Note
        //  this only applies to WIA drivers that are already loaded.
        //
        for ( pentry  = m_leDeviceListHead.Flink; pentry != &m_leDeviceListHead; pentry  = pentryNext ) {

            pentryNext = pentry->Flink;
            pActiveDevice = CONTAINING_RECORD( pentry, ACTIVE_DEVICE,m_ListEntry );

            //
            //  Check whether this is a WIA driver and whether it is loaded
            //
            if (pActiveDevice->m_DrvWrapper.IsWiaDriverLoaded()) {

                BSTR    bstrDevId = SysAllocString(pActiveDevice->GetDeviceID());

                if (bstrDevId) {

                    //
                    //  Call the driver to let it know about this event.  Note that we
                    //  don't care whether it fails or not - we simply move on to the next
                    //  device in our list.
                    //
                    pActiveDevice->m_DrvWrapper.WIA_drvNotifyPnpEvent(pEvent,
                                                                      bstrDevId,
                                                                      0);
                    SysFreeString(bstrDevId);
                    bstrDevId = NULL;
                }
            }
        }
    }

    return hr;
}

HRESULT CWiaDevMan::ProcessDeviceArrival()
{
    HRESULT hr = S_OK;

    hr = ReEnumerateDevices(DEV_MAN_GEN_EVENTS /*| DEV_MAN_FULL_REFRESH*/);

    return hr;
}

HRESULT CWiaDevMan::ProcessDeviceRemoval(
    WCHAR   *wszDeviceID)
{
    HRESULT         hr              = S_OK;
    ACTIVE_DEVICE   *pActiveDevice  = NULL;

    if (wszDeviceID) {

        DBG_TRC(("CWiaDevMan::ProcessDeviceRemoval, finding device ID '%ls'",
                 wszDeviceID));

        //
        //  Attempt to find the device
        //
        pActiveDevice = IsInList(DEV_MAN_IN_LIST_DEV_ID, wszDeviceID);

        if (pActiveDevice) {
            hr = ProcessDeviceRemoval(pActiveDevice, TRUE);
            //
            //  Release it since it was addref'd
            //
            pActiveDevice->Release();
        }
        else
        {
            DBG_TRC(("CWiaDevMan::ProcessDeviceRemoval, did not find device ID '%ls'",
                     wszDeviceID));
        }
    } else {
        DBG_TRC(("CWiaDevMan::ProcessDeviceRemoval, ProcessDeviceRemoval called with NULL device ID"));
    }

    return hr;
}

HRESULT CWiaDevMan::ProcessDeviceRemoval(
    ACTIVE_DEVICE   *pActiveDevice,
    BOOL            bGenEvent)
{

    HRESULT hr = S_OK;
    if (pActiveDevice) {

        //
        //  Mark the device as inactive
        //
        pActiveDevice->m_DrvWrapper.setDeviceState(pActiveDevice->m_DrvWrapper.getDeviceState() & ~DEV_STATE_ACTIVE);

        if (bGenEvent) {
            //
            // Generate disconnect event
            //

            DBG_TRC(("ProcessDeviceRemoval, generating SafeDisconnect Event "
                     "for device '%ls'", pActiveDevice->GetDeviceID()));

            GenerateSafeDisconnectEvent(pActiveDevice);
        }

        {
            //
            //  Note that we do not take the active device during event generation.
            //
            //TAKE_ACTIVE_DEVICE  tad(pActiveDevice);

            //
            // Remove any device notification callbacks
            //
            pActiveDevice->DisableDeviceNotifications();

            //
            // Stop PnP notifications immediately. This is important to free interface handle
            //
            pActiveDevice->StopPnPNotifications();

            //
            //  Unload the driver
            //
            pActiveDevice->UnLoadDriver(TRUE);
        }
    } else {
        DBG_TRC(("CWiaDevMan::ProcessDeviceRemoval, Device not in list"));
    }
    return hr;
}


ACTIVE_DEVICE* CWiaDevMan::IsInList(
            ULONG   ulFlags,
    const   WCHAR   *wszID)
{
    TAKE_CRIT_SECT  tcs(m_csDevList);

    LIST_ENTRY      *pentry         = NULL;
    LIST_ENTRY      *pentryNext     = NULL;
    ACTIVE_DEVICE   *pActiveDevice  = NULL;
    DEVICE_INFO     *pDevInfo       = NULL;

    //
    //  Walk through list of devices and count the ones of appropriate type
    //
    {
        for ( pentry  = m_leDeviceListHead.Flink; pentry != &m_leDeviceListHead; pentry  = pentryNext ) {

            pentryNext = pentry->Flink;
            pActiveDevice = CONTAINING_RECORD( pentry, ACTIVE_DEVICE,m_ListEntry );

            pDevInfo = pActiveDevice->m_DrvWrapper.getDevInfo();

            if (pDevInfo) {

                //
                //  Decide what to compare, based on the flags.  Note that if more
                //  that one flag is set, then the comarison will be done on more
                //  than one field.  We will return TRUE on the first hit.
                //

                //
                //  Here's a quick workaround for volume devices:  whenever we hit 
                //  potential match, check whether this is of the correct VolumeType.
                //
                if (pDevInfo->dwInternalType & INTERNAL_DEV_TYPE_VOL) {
                    if (!IsCorrectVolumeType(pDevInfo->wszAlternateID)) {
                        DBG_TRC(("CWiaDevMan::IsInList, Volume (%ws) is not of correct type.", pDevInfo->wszAlternateID));
                        continue;
                    }
                }

                if (DEV_MAN_IN_LIST_DEV_ID) {
                    if (lstrcmpiW(pDevInfo->wszDeviceInternalName, wszID) == 0) {
                        pActiveDevice->AddRef();
                        return pActiveDevice;
                    }
                }
                if (ulFlags & DEV_MAN_IN_LIST_ALT_ID) {
                    if (pDevInfo->wszAlternateID) {
                        if (lstrcmpiW(pDevInfo->wszAlternateID, wszID) == 0) {
                            pActiveDevice->AddRef();
                            return pActiveDevice;
                        }
                    }
                }
            }
        }
    }

    return FALSE;
}

ULONG CWiaDevMan::NumDevices(ULONG ulFlags)
{
    TAKE_CRIT_SECT  tcs(m_csDevList);

    LIST_ENTRY      *pentry         = NULL;
    LIST_ENTRY      *pentryNext     = NULL;
    ACTIVE_DEVICE   *pActiveDevice  = NULL;
    ULONG           ulCount         = 0;

    //
    //  Walk through list of devices and count the ones of appropriate type
    //
    {
        for ( pentry  = m_leDeviceListHead.Flink; pentry != &m_leDeviceListHead; pentry  = pentryNext ) {

            pentryNext = pentry->Flink;
            pActiveDevice = CONTAINING_RECORD( pentry, ACTIVE_DEVICE,m_ListEntry );

            //
            //  Check whether this device is one of the ones we want to count.
            //  If it is, then increment the count.
            //

            if (IsCorrectEnumType(ulFlags, pActiveDevice->m_DrvWrapper.getDevInfo())) {
                ++ulCount;
            }
        }
    }

    return ulCount;
}

VOID WINAPI CWiaDevMan::EnumerateActiveDevicesWithCallback(
    PFN_ACTIVEDEVICE_CALLBACK   pfn,
    VOID                        *pContext
    )
/*++

Routine Description:

    Walk the list of known active devices, calling given routine for each device

Arguments:

    pfn     -   Address of the callback
    pContext-   Pointer to context information to pass to callback

Return Value:

    None

--*/
{

    if (!pfn) {
        ASSERT(("Incorrect callback", 0));
        return;
    }

    LIST_ENTRY * pentry;
    LIST_ENTRY * pentryNext;

    ACTIVE_DEVICE*  pActiveDevice;

    // BEGIN PROTECTED CODE
    {
        TAKE_CRIT_SECT _tcs(m_csDevList);

        for ( pentry  = m_leDeviceListHead.Flink;
              pentry != &m_leDeviceListHead;
              pentry  = pentryNext ) {

            pentryNext = pentry->Flink;

            pActiveDevice = CONTAINING_RECORD( pentry, ACTIVE_DEVICE,m_ListEntry );

            if (!pActiveDevice->IsValid()) {
                ASSERT(("CWiaDevMan::EnumerateActiveDevicesWithCallback, Invalid device signature", 0));
                break;
            }

            pfn(pActiveDevice,pContext);
        }
    }
    // END PROTECTED CODE

}


HRESULT CWiaDevMan::GetDevInfoStgs(
    ULONG               ulFlags,
    ULONG               *pulNumDevInfoStream,
    IWiaPropertyStorage ***pppOutputStorageArray)
{
    TAKE_CRIT_SECT  tcs(m_csDevList);

    HRESULT                 hr              = S_OK;
    ULONG                   ulCount         = 0;
    ULONG                   ulIndex         = 0;
    IWiaPropertyStorage     **ppDevInfoStgs = NULL;
    IWiaPropertyStorage     **ppDevAndRemoteDevStgs = NULL;
    ULONG                   ulRemoteDevices         = 0;
                           
    *pulNumDevInfoStream    = 0;
    *pppOutputStorageArray  = NULL;

    //
    //  Count number of devices matching our category flags
    //

    ulCount = NumDevices(ulFlags);
    if (ulCount) {

        //
        //  Allocate space for that many streams
        //
        ppDevInfoStgs = new IWiaPropertyStorage*[ulCount];
        if (ppDevInfoStgs) {

            memset(ppDevInfoStgs, 0, sizeof(IWiaPropertyStorage*) * ulCount);
            //
            //  Go through device list, and for every device is our category, save
            //  its information to a stream
            //
            LIST_ENTRY      *pentry         = NULL;
            LIST_ENTRY      *pentryNext     = NULL;
            ACTIVE_DEVICE   *pActiveDevice  = NULL;

            {
                ulIndex = 0;
                for ( pentry  = m_leDeviceListHead.Flink; pentry != &m_leDeviceListHead; pentry  = pentryNext ) {

                    pentryNext = pentry->Flink;
                    pActiveDevice = CONTAINING_RECORD( pentry, ACTIVE_DEVICE,m_ListEntry );

                    //
                    //  Paranoid check for overflow - break if we've reached our count
                    //
                    if (ulIndex >= ulCount) {
                        break;
                    }

                    //
                    //  Check whether this device is one of the ones we want
                    //

                    if (IsCorrectEnumType(ulFlags, pActiveDevice->m_DrvWrapper.getDevInfo())) {

                        DEVICE_INFO *pDeviceInfo = pActiveDevice->m_DrvWrapper.getDevInfo();
                        if (pDeviceInfo) {

                            //
                            //  Here's a work-around for MSC or Volume devices.  Since we cant get the 
                            //  display name when we receive the volume arrival notification, we should
                            //  refresh it here
                            //
                            if (pDeviceInfo->dwInternalType & (INTERNAL_DEV_TYPE_VOL | INTERNAL_DEV_TYPE_MSC_CAMERA)) {
                                RefreshDevInfoFromMountPoint(pDeviceInfo, pDeviceInfo->wszAlternateID);
                            }

                            ppDevInfoStgs[ulIndex] = CreateDevInfoStg(pDeviceInfo);
                            if (!ppDevInfoStgs[ulIndex]) {
                                hr = E_OUTOFMEMORY;
                                break;
                            }
                        }

                        ++ulIndex;
                    }
                }
            }
        } else {
            hr = E_OUTOFMEMORY;
        }

    } else {
        hr = S_FALSE;
    }

    //
    //  If everything succeeded, check whether there are any remote devices installed.
    //  If there are, add them to the list.  Skip this step if local devices only was 
    //  requested.
    //

    if (SUCCEEDED(hr) && !(ulFlags & DEV_MAN_ENUM_TYPE_LOCAL_ONLY)) {

        ulRemoteDevices = CountRemoteDevices(0);
        if (ulRemoteDevices) {
            //
            //  Allocate space for the new device list.  It must be big enough to hold both
            //  local and remote dev. info. stgs.
            //

            ppDevAndRemoteDevStgs = new IWiaPropertyStorage*[ulCount + ulRemoteDevices];
            if (ppDevAndRemoteDevStgs) {
                memset(ppDevAndRemoteDevStgs, 0, sizeof(IWiaPropertyStorage*) * (ulCount + ulRemoteDevices));

                //
                //  Copy the local dev. info. storages
                //
                for (ulIndex = 0; ulIndex < ulCount; ulIndex++) {
                    ppDevAndRemoteDevStgs[ulIndex] = ppDevInfoStgs[ulIndex];
                }

                //
                //  No need for the local only array, since we have a copy of the local 
                //  dev. info. stgs in the ppDevAndRemoteDevStgs array.
                //
                if (ppDevInfoStgs) {
                    delete [] ppDevInfoStgs;
                    ppDevInfoStgs = NULL;
                }

                //
                //  Set ppDevInfoStgs to point to ppDevAndRemoteDevStgs.  This is simply cosmetic,
                //  since our code that sets the return values can now always use the ppDevInfoStgs
                //  pointer.
                //
                ppDevInfoStgs = ppDevAndRemoteDevStgs;

                //
                //  Create dev. info. stgs for the remote devices.  We pass in the address where
                //  the first dev. info. stg. will reside, and the maxiumum number of dev. info. stgs
                //  to fill in.  This is to avoid the problem where the registry might be updated
                //  in between us counting the number of remote devices with CountRemoteDevices(..),
                //  and actually enumerating them with FillRemoteDeviceStgs(..).
                //
                hr = FillRemoteDeviceStgs(&ppDevAndRemoteDevStgs[ulCount], &ulRemoteDevices);
                if (SUCCEEDED(hr)) {
                    
                    //
                    //  Increment the device count to be local + remote devices
                    //
                    ulCount += ulRemoteDevices;
                } else {

                    //
                    //  If we failed to get remote devices, that's OK since it's non-fatal.
                    //  Do some clean-up so we return local devices only.  This involves
                    //  deleting any remote device info. stgs. that were added after the
                    //  local dev. info. stgs.
                    //

                    for (ulIndex = ulCount; ulIndex < (ulCount + ulRemoteDevices); ulIndex++) {
                        if (ppDevAndRemoteDevStgs[ulIndex]) {
                            delete ppDevAndRemoteDevStgs[ulIndex];
                            ppDevAndRemoteDevStgs[ulIndex] = NULL;
                        }
                    }
                    hr = S_OK;
                }
            } else {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    //
    //  Set the return
    //

    if (SUCCEEDED(hr)) {

        *pulNumDevInfoStream    = ulCount;
        *pppOutputStorageArray  = ppDevInfoStgs;

        if (*pulNumDevInfoStream) {
            hr = S_OK;
        } else {
            hr = S_FALSE;
        }
    } else {
        //
        //  On failure, cleanup.
        //

        if (ppDevInfoStgs) {
            for (ulIndex = 0; ulIndex < ulCount; ulIndex++) {
                if (ppDevInfoStgs[ulIndex]) {
                    delete ppDevInfoStgs[ulIndex];
                    ppDevInfoStgs[ulIndex] = NULL;
                }
            }
            delete [] ppDevInfoStgs;
            ppDevInfoStgs = NULL;
        }
    }
    return hr;
}

HRESULT CWiaDevMan::GetDeviceValue(
    ACTIVE_DEVICE   *pActiveDevice,
    WCHAR           *pValueName,
    DWORD           *pType,
    BYTE            *pData,
    DWORD           *cbData)
{
    HRESULT     hr              = E_FAIL;
    DEVICE_INFO *pInfo          = NULL;
    HKEY        hDevRegKey      = NULL;
    HKEY        hDevDataRegKey  = NULL;
    DWORD       dwError         = 0;


    if (pActiveDevice) {

        TAKE_ACTIVE_DEVICE  tad(pActiveDevice);

        pInfo = pActiveDevice->m_DrvWrapper.getDevInfo();
        if (pInfo) {

            //
            //  Get the device registry key
            //

            hDevRegKey = GetDeviceHKey(pActiveDevice, NULL);
            if (hDevRegKey) {

                //
                //  Open the DeviceData section
                //
                dwError = RegCreateKeyExW(hDevRegKey,
                                   REGSTR_VAL_DATA_W,
                                   0,
                                   NULL,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_READ,
                                   NULL,
                                   &hDevDataRegKey,
                                   NULL);
                if (dwError == ERROR_SUCCESS) {

                    //
                    //  Call RegQueryValueEx.
                    //
                    dwError = RegQueryValueExW(hDevDataRegKey,
                                               pValueName,
                                               NULL,
                                               pType,
                                               pData,
                                               cbData);
                    if (dwError == ERROR_SUCCESS) {
                        hr = S_OK;
                    }
                    RegCloseKey(hDevDataRegKey);
                }

                //
                //  Close the device registry key
                //
                RegCloseKey(hDevRegKey);
            }
        } else {
            DBG_WRN(("CWiaDevMan::GetDeviceValue, DeviceInfo is not valid"));
        }
    } else {
        DBG_TRC(("CWiaDevMan::GetDeviceValue, called with NULL"));
    }

    return hr;
}

WCHAR*  CWiaDevMan::AllocGetInterfaceNameFromDevInfo(DEVICE_INFO *pDevInfo)
{
    TAKE_CRIT_SECT  tcs(m_csDevList);

    WCHAR   *wszInterface = NULL;
    GUID    guidClass     = GUID_DEVCLASS_IMAGE;
    BOOL    bRet          = FALSE;
    DWORD   dwStrLen      = 0;

    SP_DEVICE_INTERFACE_DATA *pspDevInterfaceData = NULL;
    SP_DEVICE_INTERFACE_DATA spTemp;

    DWORD                              dwDetailSize                 = 0;
    SP_DEVICE_INTERFACE_DETAIL_DATA_W  *pspDevInterfaceDetailData   = NULL;

    if (pDevInfo) {
        //
        //  Check whether this is an interface or devnode device
        //
        if (pDevInfo->dwInternalType & INTERNAL_DEV_TYPE_INTERFACE) {
            pspDevInterfaceData = &pDevInfo->spDevInterfaceData;
        } else {
            spTemp.cbSize               = sizeof(SP_DEVICE_INTERFACE_DATA);
            spTemp.InterfaceClassGuid   = guidClass;
            bRet = SetupDiEnumDeviceInterfaces (m_DeviceInfoSet,
                                                &pDevInfo->spDevInfoData,
                                                &guidClass,
                                                0,
                                                &spTemp);
            if (bRet) {
                pspDevInterfaceData = &spTemp;
            } else {
                DBG_WRN(("CWiaDevMan::AllocGetInterfaceNameFromDevInfo, SetupDiEnumDeviceInterfaces failed to return interface information"))
            }
        }

        //
        //  If we have a valid pspDevInterfaceData, then we can get the interface
        //  detail information, which includes the interface name
        //

        if (pspDevInterfaceData) {

            SP_DEVINFO_DATA spDevInfoData;

            spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

            //
            //  Get the required size for the interface detail
            //
            bRet = SetupDiGetDeviceInterfaceDetailW(m_DeviceInfoSet,
                                                   pspDevInterfaceData,
                                                   NULL,
                                                   0,
                                                   &dwDetailSize,
                                                   &spDevInfoData);
            DWORD dwError = GetLastError();
            if ((dwError == ERROR_INSUFFICIENT_BUFFER) && dwDetailSize) {
                pspDevInterfaceDetailData = (SP_DEVICE_INTERFACE_DETAIL_DATA_W*) new BYTE[dwDetailSize];
                if (pspDevInterfaceDetailData) {
                    pspDevInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

                    //
                    //  Get the actual interface detail
                    //
                    bRet = SetupDiGetDeviceInterfaceDetailW(m_DeviceInfoSet,
                                                           pspDevInterfaceData,
                                                           pspDevInterfaceDetailData,
                                                           dwDetailSize,
                                                           &dwDetailSize,
                                                           NULL);
                    if (bRet) {

                        dwStrLen        = lstrlenW(pspDevInterfaceDetailData->DevicePath);
                        wszInterface    = new WCHAR[dwStrLen + 1];
                        if (wszInterface) {
                            lstrcpyW(wszInterface, pspDevInterfaceDetailData->DevicePath);
                        } else {
                            DBG_WRN(("CWiaDevMan::AllocGetInterfaceNameFromDevInfo, out of memory"))
                        }
                    } else {
                        DBG_TRC(("CWiaDevMan::AllocGetInterfaceNameFromDevInfo, Could not get SP_DEVICE_INTERFACE_DETAIL_DATA"));
                    }

                    delete [] pspDevInterfaceDetailData;
                } else {
                    DBG_WRN(("CWiaDevMan::AllocGetInterfaceNameFromDevInfo, out of memory"))
                }
            } else {
                DBG_WRN(("CWiaDevMan::AllocGetInterfaceNameFromDevInfo, SetupDiGetDeviceInterfaceDetail returned an error, could not determine buffer size"))
            }
        } else {
            DBG_TRC(("CWiaDevMan::AllocGetInterfaceNameFromDevInfo, Could not get SP_DEVICE_INTERFACE_DATA"));
        }
    }

    return wszInterface;
}

//
// Look up driver name by interface name
//  NOTE:  In the interests of time, this was copied directly from infoset.h

BOOL
CWiaDevMan::LookupDriverNameFromInterfaceName(
    LPCTSTR     pszInterfaceName,
    StiCString  *pstrDriverName)
{
    TAKE_CRIT_SECT  tcs(m_csDevList);

    BUFFER                      bufDetailData;

    SP_DEVINFO_DATA             spDevInfoData;
    SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pspDevInterfaceDetailData;

    TCHAR   szDevDriver[STI_MAX_INTERNAL_NAME_LENGTH];

    DWORD   cbData          = 0;
    DWORD   dwErr           = 0;

    HKEY    hkDevice        = (HKEY)INVALID_HANDLE_VALUE;
    LONG    lResult         = ERROR_SUCCESS;
    DWORD   dwType          = REG_SZ;

    BOOL    fRet            = FALSE;
    BOOL    fDataAcquired   = FALSE;

    bufDetailData.Resize(sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                         MAX_PATH * sizeof(TCHAR) +
                         16
                        );

    pspDevInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) bufDetailData.QueryPtr();

    if (!pspDevInterfaceDetailData) {
        return (CR_OUT_OF_MEMORY);
    }

    //
    // Locate this device interface in our device information set.
    //
    spDevInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    if (SetupDiOpenDeviceInterface(m_DeviceInfoSet,
                                   pszInterfaceName,
                                   DIODI_NO_ADD,
                                   &spDevInterfaceData)) {


        //
        // First try to open interface regkey.
        //

        hkDevice = SetupDiOpenDeviceInterfaceRegKey(m_DeviceInfoSet,
                                                    &spDevInterfaceData,
                                                    0,
                                                    KEY_READ);
        if(INVALID_HANDLE_VALUE != hkDevice){

            *szDevDriver = TEXT('\0');
            cbData = sizeof(szDevDriver);
            lResult = RegQueryValueEx(hkDevice,
                                      REGSTR_VAL_DEVICE_ID,
                                      NULL,
                                      &dwType,
                                      (LPBYTE)szDevDriver,
                                      &cbData);
            dwErr = ::GetLastError();
            RegCloseKey(hkDevice);
            hkDevice = (HKEY)INVALID_HANDLE_VALUE;

            if(ERROR_SUCCESS == lResult){
                fDataAcquired = TRUE;
            }
        }

        if(!fDataAcquired){

            //
            // Try to open devnode regkey.
            //

            cbData = 0;
            pspDevInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
            spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

            fRet = SetupDiGetDeviceInterfaceDetail(m_DeviceInfoSet,
                                                   &spDevInterfaceData,
                                                   pspDevInterfaceDetailData,
                                                   bufDetailData.QuerySize(),
                                                   &cbData,
                                                   &spDevInfoData);
            if(fRet){

                //
                // Get device interface registry key.
                //

                hkDevice = SetupDiOpenDevRegKey(m_DeviceInfoSet,
                                                &spDevInfoData,
                                                DICS_FLAG_GLOBAL,
                                                0,
                                                DIREG_DRV,
                                                KEY_READ);
                dwErr = ::GetLastError();
            } else {
                DBG_ERR(("SetupDiGetDeviceInterfaceDetail() Failed Err=0x%x",GetLastError()));
            }

            if (INVALID_HANDLE_VALUE != hkDevice) {

                *szDevDriver = TEXT('\0');
                cbData = sizeof(szDevDriver);

                lResult = RegQueryValueEx(hkDevice,
                                          REGSTR_VAL_DEVICE_ID,
                                          NULL,
                                          &dwType,
                                          (LPBYTE)szDevDriver,
                                          &cbData);
                dwErr = ::GetLastError();
                RegCloseKey(hkDevice);
                hkDevice = (HKEY)INVALID_HANDLE_VALUE;

                if(ERROR_SUCCESS == lResult){
                    fDataAcquired = TRUE;
                }
            } else {
                DBG_ERR(("SetupDiOpenDevRegKey() Failed Err=0x%x",GetLastError()));
                fRet = FALSE;
            }
        }

        if (fDataAcquired) {
            //
            // Got it
            //
            pstrDriverName->CopyString(szDevDriver);
            fRet =  TRUE;
        }
    } else {
        DBG_ERR(("CWiaDevMan::LookupDriverNameFromInterfaceName() Failed Err=0x%x",GetLastError()));
        fRet = FALSE;
    }

    return (fRet);
}

ACTIVE_DEVICE* CWiaDevMan::LookDeviceFromPnPHandles(
    HANDLE          hInterfaceHandle,
    HANDLE          hPnPSink)
{
    TAKE_CRIT_SECT  tcs(m_csDevList);

    LIST_ENTRY *pentry;
    LIST_ENTRY *pentryNext;

    ACTIVE_DEVICE   *pActiveDevice = NULL;
    ACTIVE_DEVICE   *pCurrent      = NULL;

    {
        for ( pentry  = m_leDeviceListHead.Flink; pentry != &m_leDeviceListHead; pentry  = pentryNext ) {

            pentryNext = pentry->Flink;
            pCurrent = CONTAINING_RECORD( pentry, ACTIVE_DEVICE,m_ListEntry );

            if ( !pCurrent->IsValid()) {
                DBG_WRN(("CWiaDevMan::LookupDeviceByPnPHandles, Invalid device object, aborting search..."));
                break;
            }

            //
            //  Check whether this PnP notification handle returned from
            //  RegisterDeviceNotification is the one we're looking for
            //
            if ( hPnPSink == pCurrent->GetNotificationsSink()) {
                pActiveDevice = pCurrent;
                pActiveDevice->AddRef();
                break;
            }
        }
    }

    return pActiveDevice;
}

VOID CWiaDevMan::DestroyInfoSet()
{
    TAKE_CRIT_SECT  tcs(m_csDevList);

    if (m_DeviceInfoSet) {
        SetupDiDestroyDeviceInfoList(m_DeviceInfoSet);
        m_DeviceInfoSet = NULL;
    }
}

HRESULT CWiaDevMan::CreateInfoSet()
{
    TAKE_CRIT_SECT  tcs(m_csDevList);

    HRESULT     hr      = S_OK;
    DWORD       dwErr   = 0;
    HDEVINFO    hdvNew  = NULL;

    //
    //  Create a blank infoset
    //

    m_DeviceInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL);

    if ( m_DeviceInfoSet && (m_DeviceInfoSet != INVALID_HANDLE_VALUE)) {


        //
        //  Now we can retrieve the existing list of WIA devices
        //  into the device information set we created above.
        //

        //
        //  This adds WIA "devnode" devices
        //
        hdvNew = SetupDiGetClassDevsEx(&(GUID_DEVCLASS_IMAGE),
                                       NULL,
                                       NULL,
                                       DIGCF_DEVICEINTERFACE,
                                       m_DeviceInfoSet,
                                       NULL,
                                       NULL);
        if (hdvNew == INVALID_HANDLE_VALUE) {
            dwErr = ::GetLastError();
            DBG_ERR(("CWiaDevMan::CreateInfoSet, SetupDiGetClassDevsEx failed with 0x%lx\n", dwErr));
        } else {

            //
            //  This adds WIA "interface" devices
            //
            hdvNew = SetupDiGetClassDevsEx(&(GUID_DEVCLASS_IMAGE),
                                           NULL,
                                           NULL,
                                           0,
                                           m_DeviceInfoSet,
                                           NULL,
                                           NULL);
            if (hdvNew == INVALID_HANDLE_VALUE) {
                dwErr = ::GetLastError();
                DBG_ERR(("CWiaDevMan::CreateInfoSet, second SetupDiGetClassDevsEx failed with 0x%lx\n", dwErr));
            }
        }
    } else {
        dwErr = ::GetLastError();
        DBG_ERR(("CWiaDevMan::CreateInfoSet, SetupDiCreateDeviceInfoList failed with 0x%lx\n", dwErr));
    }

    if (dwErr) {
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    return hr;
}



VOID CWiaDevMan::DestroyDeviceList()
{
    TAKE_CRIT_SECT  tcs(m_csDevList);

    LIST_ENTRY      *pentry         = NULL;
    ACTIVE_DEVICE   *pActiveDevice  = NULL;

    DBG_TRC(("Destroying list of active devices"));

    //
    // Go through the list terminating devices
    //
    while (!IsListEmpty(&m_leDeviceListHead)) {

        pentry = m_leDeviceListHead.Flink;

        //
        // Remove from the list ( reset list entry )
        //
        RemoveHeadList(&m_leDeviceListHead);
        InitializeListHead( pentry );

        pActiveDevice = CONTAINING_RECORD( pentry, ACTIVE_DEVICE,m_ListEntry );

        //
        // Remove any device notification callbacks
        //
        pActiveDevice->DisableDeviceNotifications();

        // Release device object
        pActiveDevice->Release();
    }

}

BOOL CWiaDevMan::VolumesAreEnabled()
{
    return m_bVolumesEnabled;
}

HRESULT CWiaDevMan::ForEachDeviceInList(
    ULONG   ulFlags,
    ULONG   ulParam)
{
    TAKE_CRIT_SECT  tcs(m_csDevList);

    HRESULT hr = S_OK;

    //
    //  Walk through list of devices
    //
    LIST_ENTRY      *pentry         = NULL;
    LIST_ENTRY      *pentryNext     = NULL;
    ACTIVE_DEVICE   *pActiveDevice  = NULL;

    {
        //
        //  For each device in list, call the appropriate device manager method
        //
        for ( pentry  = m_leDeviceListHead.Flink; pentry != &m_leDeviceListHead; pentry  = pentryNext ) {

            pentryNext = pentry->Flink;
            pActiveDevice = CONTAINING_RECORD( pentry, ACTIVE_DEVICE,m_ListEntry );

            switch (ulFlags) {
                case DEV_MAN_OP_DEV_SET_FLAGS:
                    {
                        //
                        //  Set the flags on the ACTIVE_DEVICE
                        //
                        pActiveDevice->SetFlags(pActiveDevice->QueryFlags() | ulParam);
                        break;
                    }

                case DEV_MAN_OP_DEV_REMOVE_MATCH:
                    {
                        //
                        //  Remove device if the ACTIVE_DEVICE flags have the specified bit set
                        //
                        if (pActiveDevice->QueryFlags() & ulParam) {

                            hr = RemoveDevice(pActiveDevice);
                        }
                        break;
                    }
                case DEV_MAN_OP_DEV_REREAD:
                    {
                        //
                        //  Get the device settings, which includes rebuilding 
                        //  the STI event list from registry
                        //
                        pActiveDevice->GetDeviceSettings();
                        break;
                    }

                case DEV_MAN_OP_DEV_RESTORE_EVENT:
                    {

                        DEVICE_INFO *pDeviceInfo    = pActiveDevice->m_DrvWrapper.getDevInfo();

                        if (pDeviceInfo) {

                            //
                            //  NOTE:  We don't want to restore MSC camera device event handlers
                            //  here.  This is because they are restored along with the global handlers
                            //  in RestoreAllPersistentCBs
                            //
                            if (!(pDeviceInfo->dwInternalType & INTERNAL_DEV_TYPE_MSC_CAMERA)) {
                                HKEY    hKey = NULL;

                                //
                                //  Get the device's HKEY and restore any device specific event handlers
                                //
                                hKey = GetDeviceHKey(pActiveDevice, NULL);
                                if (hKey) {
                                    g_eventNotifier.RestoreDevPersistentCBs(hKey);
                                }
                            }
                        }

                    }
                    

                default:
                    // do nothing
                    ;
            };

            if (FAILED(hr)) {
                DBG_WRN(("CWiaDevMan::ForEachDeviceInList, failed with params (0x%8X, 0x%8X), on device %ws",
                          ulFlags, ulParam, pActiveDevice->GetDeviceID()));
                break;
            }
        }
    }

    return hr;
}



HRESULT CWiaDevMan::EnumDevNodeDevices(
    ULONG   ulFlags)
{
    HRESULT hr  = S_OK;     //  Notice that none of these errors are fatal.  We always return S_OK.


    ULONG           ulIndex                     = 0;
    DWORD           dwError                     = ERROR_SUCCESS;
    DWORD           dwFlags                     = DIGCF_PROFILE;
    CONFIGRET       ConfigRet                   = CR_SUCCESS;
    ULONG           ulStatus                    = 0;
    ULONG           ulProblemNumber             = 0;
    HKEY            hDevRegKey                  = (HKEY)INVALID_HANDLE_VALUE;
    DWORD           dwDeviceState               = 0;
    DWORD           cbData                      = 0;
    DEVICE_INFO     *pDevInfo                   = NULL;
    ACTIVE_DEVICE   *pActiveDevice              = NULL;


    SP_DEVINFO_DATA spDevInfoData;
    WCHAR           wszDeviceID[STI_MAX_INTERNAL_NAME_LENGTH];

    //
    // Enumerate "devnode" devices.
    //

    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    for (ulIndex = 0; SetupDiEnumDeviceInfo (m_DeviceInfoSet, ulIndex, &spDevInfoData); ulIndex++) {

        //
        //  See if this node is active.
        //

        ulStatus = 0;
        ulProblemNumber = 0;
        ConfigRet = CM_Get_DevNode_Status(&ulStatus,
                                          &ulProblemNumber,
                                          spDevInfoData.DevInst,
                                          0);
        if(CR_SUCCESS != ConfigRet){
            DBG_WRN(("CWiaDevMan::EnumDevNodeDevices, On index %d, CM_Get_DevNode_Status returned error, assuming device is inactive", ulIndex));
        }

        //
        // Get device regkey.
        //

        hDevRegKey = SetupDiOpenDevRegKey(m_DeviceInfoSet,
                                          &spDevInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ | KEY_WRITE);
        if(hDevRegKey != INVALID_HANDLE_VALUE) {
            //
            // See if it has "StillImage" in SubClass key.
            //

            if(IsStiRegKey(hDevRegKey)){
                //
                //  Get this device name
                //

                cbData = sizeof(wszDeviceID);
                dwError = RegQueryValueExW(hDevRegKey,
                                           REGSTR_VAL_DEVICE_ID_W,
                                           NULL,
                                           NULL,
                                           (LPBYTE)wszDeviceID,
                                           &cbData);
                if (dwError == ERROR_SUCCESS) {
                    wszDeviceID[STI_MAX_INTERNAL_NAME_LENGTH-1] = L'\0';

                    //
                    //  Check whether  we already have the appropriate DEVICE_OBJECT in the list.
                    //  If we do, find out whether we should generate a connect/disconnect event, else fill
                    //  out the DeviceInformation struct and create a new DEVICE_OBJECT for it.
                    //

                    DBG_TRC(("EnumDevNodeDevices, searching for device '%ls' in list",
                             wszDeviceID));

                    pActiveDevice = IsInList(DEV_MAN_IN_LIST_DEV_ID, wszDeviceID);
                    if (pActiveDevice) {
                        //
                        //  Mark this device as active
                        //
                        pActiveDevice->SetFlags(pActiveDevice->QueryFlags() & ~STIMON_AD_FLAG_MARKED_INACTIVE);

                        DWORD   dwOldDevState;
                        dwOldDevState = pActiveDevice->m_DrvWrapper.getDeviceState();

                        //
                        //  Mark the new device state appropriately
                        //

                        dwDeviceState = MapCMStatusToDeviceState(dwOldDevState, ulStatus, ulProblemNumber);

                        //
                        //  Update the device information.  Certain fields are transient e.g.
                        //  device state and port name
                        //

                        RefreshDevInfoFromHKey(pActiveDevice->m_DrvWrapper.getDevInfo(),
                                               hDevRegKey,
                                               dwDeviceState,
                                               &spDevInfoData,
                                               NULL);
                        DBG_TRC(("EnumDevNodeDevices, device '%ls' is in the list, "
                                 "Old Device State = '%lu', New Device State = %lu",
                                 wszDeviceID, dwOldDevState, dwDeviceState));

                        if (ulFlags & DEV_MAN_GEN_EVENTS) {

                            //
                            //  Check whether its state changed.  If it changed
                            //  from inactive to active, throw connect event.  If
                            //  state changed from active to inactive, throw disconnect event.
                            //
                            if (((~dwOldDevState) & DEV_STATE_ACTIVE) &&
                                (dwDeviceState & DEV_STATE_ACTIVE)) {

                                //
                                //  Load the driver
                                //
                                pActiveDevice->LoadDriver(TRUE);
                                GenerateSafeConnectEvent(pActiveDevice);

                                DBG_TRC(("EnumDevNodeDevices, generating SafeConnect Event "
                                         "for device '%ls'", wszDeviceID));

                            } else if ((dwOldDevState & DEV_STATE_ACTIVE) &&
                                       ((~dwDeviceState) & DEV_STATE_ACTIVE)) {

                                DBG_TRC(("EnumDevNodeDevices, generating SafeDisconnect Event "
                                         "for device '%ls'", wszDeviceID));

                                GenerateSafeDisconnectEvent(pActiveDevice);
                                pActiveDevice->UnLoadDriver(FALSE);
                            }
                        }

                        //
                        //  NOTE:  In the case when we are not started yet, and the class installer
                        //  starts us to install a device, certain timing conditions make it so that
                        //  the device is enumerated on startup, but the device is not registred
                        //  for PnP notifications like device removal.  This is because it is not fully installed
                        //  yet, so the lookup of the interface name to do a CreateFile on fails.
                        //  So, to get around that, when the class installer is finished installing,
                        //  and tells us to reenumerate, we also check whether the device is registered
                        //  for PnP notifications.  If it isn't, we attempt to register.  If successful, we
                        //  generate connect event (since we missed it the first time round)
                        //
                        if (!pActiveDevice->IsRegisteredForDeviceRemoval() && (dwDeviceState & DEV_STATE_ACTIVE)) {

                            //
                            //  This device is active but is not yet registered.  Let's attempt to register it
                            //
                            if (pActiveDevice->InitPnPNotifications(NULL)) {

                                //
                                //  Successful.  So now generate connect event if told to do so
                                //
                                if (ulFlags & DEV_MAN_GEN_EVENTS) {
                                    GenerateSafeConnectEvent(pActiveDevice);
                                }
                            }
                        }

                        pActiveDevice->Release();
                    } else {
                        //
                        //  Create and fill out a DEVICE_INFO structure.  For
                        //

                        dwDeviceState = MapCMStatusToDeviceState(0, ulStatus, ulProblemNumber);

                        DBG_TRC(("EnumDevNodeDevices, device '%ls' is NOT in the list, "
                                 "Device State = %lu", wszDeviceID, dwDeviceState));

                        pDevInfo = CreateDevInfoFromHKey(hDevRegKey, dwDeviceState, &spDevInfoData, NULL);
                        DumpDevInfo(pDevInfo);
                        AddDevice(ulFlags, pDevInfo);
                    }
                } else {
                    DBG_WRN(("CWiaDevMan::EnumDevNodeDevices, On index %d, could not read DeviceID", ulIndex));
                }
            } else {
                DBG_WRN(("CWiaDevMan::EnumDevNodeDevices, device on index %d is not StillImage", ulIndex));
            }

            //
            //  Close the device registry key
            //

            RegCloseKey(hDevRegKey);
            hDevRegKey = NULL;
        } else {
            DBG_WRN(("CWiaDevMan::EnumDevNodeDevices, SetupDiOpenDevRegKey on index %d return INVALID_HANDLE_VALUE", ulIndex));
        }

    }

    return S_OK;
}


HRESULT CWiaDevMan::EnumInterfaceDevices(
    ULONG   ulFlags)
{
    HRESULT hr  = S_OK;     //  Notice that none of these errors are fatal.  We always return S_OK.


    ULONG           ulIndex                     = 0;
    DWORD           dwError                     = ERROR_SUCCESS;
    DWORD           dwFlags                     = DIGCF_PROFILE;
    CONFIGRET       ConfigRet                   = CR_SUCCESS;
    GUID            guidInterface               = GUID_DEVCLASS_IMAGE;
    ULONG           ulStatus                    = 0;
    ULONG           ulProblemNumber             = 0;
    HKEY            hDevRegKey                  = (HKEY)INVALID_HANDLE_VALUE;
    DWORD           dwDeviceState               = 0;
    DWORD           cbData                      = 0;
    DEVICE_INFO     *pDevInfo                   = NULL;
    ACTIVE_DEVICE   *pActiveDevice              = NULL;
    DWORD           dwDetailDataSize            = 0;
    BOOL            bSkip                       = FALSE;


    SP_DEVINFO_DATA             spDevInfoData;
    SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;
    WCHAR                       wszDeviceID[STI_MAX_INTERNAL_NAME_LENGTH];

    //
    // Enumerate "devnode" devices.
    //

    spDevInfoData.cbSize        = sizeof (SP_DEVINFO_DATA);
    spDevInterfaceData.cbSize   = sizeof (SP_DEVICE_INTERFACE_DATA);
    for (ulIndex = 0; SetupDiEnumDeviceInterfaces(m_DeviceInfoSet, NULL, &guidInterface, ulIndex, &spDevInterfaceData); ulIndex++) {



        dwDeviceState   = 0;
        bSkip           = FALSE;
        hDevRegKey = SetupDiOpenDeviceInterfaceRegKey(m_DeviceInfoSet,
                                                      &spDevInterfaceData,
                                                      0,
                                                      KEY_READ | KEY_WRITE);
        if(hDevRegKey != INVALID_HANDLE_VALUE) {
            //
            // See if it has "StillImage" in SubClass key.
            //

            if(IsStiRegKey(hDevRegKey)) {
                //
                //  Get this device name
                //

                cbData = sizeof(wszDeviceID);
                dwError = RegQueryValueExW(hDevRegKey,
                                           REGSTR_VAL_DEVICE_ID_W,
                                           NULL,
                                           NULL,
                                           (LPBYTE)wszDeviceID,
                                           &cbData);
                if (dwError == ERROR_SUCCESS) {
                    //
                    // Get devnode which this interface is created on.
                    //

                    dwError = SetupDiGetDeviceInterfaceDetail(m_DeviceInfoSet,
                                                              &spDevInterfaceData,
                                                              NULL,
                                                              0,
                                                              NULL,
                                                              &spDevInfoData);
                    if(ERROR_INSUFFICIENT_BUFFER){

                        //
                        //  See if this node is active.
                        //

                        ulStatus = 0;
                        ulProblemNumber = 0;
                        ConfigRet = CM_Get_DevNode_Status(&ulStatus,
                                                          &ulProblemNumber,
                                                          spDevInfoData.DevInst,
                                                          0);

                        if(CR_SUCCESS != ConfigRet){
                            DBG_WRN(("CWiaDevMan::EnumInterfaceDevices, On index %d, CM_Get_DevNode_Status returned error, assuming device is inactive", ulIndex));
                        }
                    } else {
                        bSkip = TRUE;
                    }
                } else {
                DBG_WRN(("CWiaDevMan::EnumInterfaceDevices, device on index %d, could not read DeviceID", ulIndex));
                bSkip = TRUE;
                }
            }else {
                DBG_WRN(("CWiaDevMan::EnumInterfaceDevices, device on index %d, not a StillImage", ulIndex));
                bSkip = TRUE;
            }
        } else {
            DBG_WRN(("CWiaDevMan::EnumInterfaceDevices, SetupDiOpenDeviceInterfaceRegKey on index %d return INVALID_HANDLE_VALUE", ulIndex));
            bSkip = TRUE;
        }

        if (!bSkip) {
            //
            //  If we get to here, it means we have a valid StillImage device, it's HKEY, spDevInterfaceData, and spDevInfoData
            //

            wszDeviceID[STI_MAX_INTERNAL_NAME_LENGTH-1] = L'\0';

            //
            //  Check whether  we already have the appropriate DEVICE_OBJECT in the list.
            //  If we do, find out whether we should generate a connect/disconnect event, else fill
            //  out the DeviceInformation struct and create a new DEVICE_OBJECT for it.
            //
            pActiveDevice = IsInList(DEV_MAN_IN_LIST_DEV_ID, wszDeviceID);
            if (pActiveDevice) {

                //
                //  Mark this device as active
                //
                pActiveDevice->SetFlags(pActiveDevice->QueryFlags() & ~STIMON_AD_FLAG_MARKED_INACTIVE);

                DWORD   dwOldDevState;
                dwOldDevState = pActiveDevice->m_DrvWrapper.getDeviceState();

                //
                //  Mark the device state appropriately
                //
                dwDeviceState = MapCMStatusToDeviceState(dwOldDevState, ulStatus, ulProblemNumber);

                DBG_TRC(("EnumInterfaceDevices, device '%ls' is in the list, "
                         "Old Device State = %lu, New Device State = %lu", 
                         wszDeviceID, dwOldDevState, dwDeviceState));

                //
                //  Update the device information.  Certain fields are transient e.g.
                //  device state and port name
                //

                RefreshDevInfoFromHKey(pActiveDevice->m_DrvWrapper.getDevInfo(),
                                       hDevRegKey,
                                       dwDeviceState,
                                       &spDevInfoData,
                                       &spDevInterfaceData);
                if (ulFlags & DEV_MAN_GEN_EVENTS) {

                    //
                    //  Check whether its state changed.  If it changed
                    //  from inactive to active, throw connect event.  If
                    //  state changed from active to inactive, throw disconnect event.
                    //
                    if (((~dwOldDevState) & DEV_STATE_ACTIVE) &&
                        (dwDeviceState & DEV_STATE_ACTIVE)) {

                        //
                        //  Load the driver
                        //
                        pActiveDevice->LoadDriver(TRUE);
                        GenerateSafeConnectEvent(pActiveDevice);
                    } else if ((dwOldDevState & DEV_STATE_ACTIVE) &&
                               ((~dwDeviceState) & DEV_STATE_ACTIVE)) {

                        GenerateSafeDisconnectEvent(pActiveDevice);
                        pActiveDevice->UnLoadDriver(FALSE);
                    }
                }

                //
                //  NOTE:  In the case when we are not started yet, and the class installer
                //  starts us to install a device, certain timing conditions make it so that
                //  the device is enumerated on startup, but the device is not registred
                //  for PnP notifications like device removal.  This is because it is not fully installed
                //  yet, so the lookup of the interface name to do a CreateFile on fails.
                //  So, to get around that, when the class installer is finished installing,
                //  and tells us to reenumerate, we also check whether the device is registered
                //  for PnP notifications.  If it isn't, we attempt to register.  If successful, we
                //  generate connect event (since we missed it the first time round)
                //
                if (!pActiveDevice->IsRegisteredForDeviceRemoval() && (dwDeviceState & DEV_STATE_ACTIVE)) {

                    //
                    //  This device is active but is not yet registered.  Let's attempt to register it
                    //
                    if (pActiveDevice->InitPnPNotifications(NULL)) {

                        //
                        //  Successful.  So now generate connect event if told to do so
                        //
                        if (ulFlags & DEV_MAN_GEN_EVENTS) {
                            GenerateSafeConnectEvent(pActiveDevice);
                        }
                    }
                }

                pActiveDevice->Release();
            } else {
                //
                //  Create and fill out a DEVICE_INFO structure.  For
                //

                dwDeviceState = MapCMStatusToDeviceState(0, ulStatus, ulProblemNumber);

                DBG_TRC(("EnumInterfaceDevices, device '%ls' is NOT in the list, "
                         "Device State = %lu", wszDeviceID, dwDeviceState));

                pDevInfo = CreateDevInfoFromHKey(hDevRegKey, dwDeviceState, &spDevInfoData, &spDevInterfaceData);
                DumpDevInfo(pDevInfo);
                AddDevice(ulFlags, pDevInfo);
            }
        }

        //
        //  Close the device registry key
        //

        if (hDevRegKey != INVALID_HANDLE_VALUE) {
            RegCloseKey(hDevRegKey);
            hDevRegKey = NULL;
        }
    }

    return S_OK;
}


//
//  Shortcut:  for now, we're only going to enum mount points.  Maybe, we might want to enumerate
//  volumes, see which are removable media, cdroms etc., then match them up with corresponding
//  mount points.
//
HRESULT CWiaDevMan::EnumVolumes(
    ULONG   ulFlags)
{
    HRESULT                         hr              = S_OK;
    IHardwareDevices                *pihwdevs       = NULL;
    ACTIVE_DEVICE                   *pActiveDevice  = NULL;
    DEVICE_INFO                     *pDevInfo       = NULL;

    hr = CoCreateInstance(CLSID_HardwareDevices,
                          NULL,
                          CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG,
                          IID_IHardwareDevices,
                          (VOID**)&pihwdevs);
    if (SUCCEEDED(hr))
    {
        IHardwareDevicesMountPointsEnum *penum          = NULL;

        hr = pihwdevs->EnumMountPoints(&penum);
        if (SUCCEEDED(hr))
        {
            LPWSTR pszMountPoint        = NULL;
            LPWSTR pszDeviceIDVolume    = NULL;

            while (penum->Next(&pszMountPoint, &pszDeviceIDVolume) == S_OK)
            {
                //
                //  Check if this is one of the volumes we "allow".  We only
                //  allow:
                //  Removable drives with
                //  Non-securable file system
                //
                if (IsCorrectVolumeType(pszMountPoint)) {
                    //
                    //  Check whether  we already have the appropriate DEVICE_OBJECT in the list.
                    //  If we do, find out whether we should generate a connect/disconnect event, else fill
                    //  out the DeviceInformation struct and create a new DEVICE_OBJECT for it.
                    //
                    pActiveDevice = IsInList(DEV_MAN_IN_LIST_ALT_ID, pszMountPoint);
                    if (pActiveDevice) {

                        //  TDB:
                        //  We'd want to generate a connect/disconnect event for MSC camera
                        //  Right now, there is no way to tell if it is MSC camera
                        //  DWORD dwDevState = MapMediaStatusToDeviceState(dwMediaState);

                        //
                        //  Mark this device as active
                        //
                        pActiveDevice->SetFlags(pActiveDevice->QueryFlags() & ~STIMON_AD_FLAG_MARKED_INACTIVE);
                        /*

                        DWORD   dwOldDevState;
                        dwOldDevState = pActiveDevice->m_DrvWrapper.getDeviceState();

                        //
                        //  Update the device information.  Certain fields are transient e.g.
                        //  device state and port name
                        //


                        RefreshDevInfoFromHKey(pActiveDevice->m_DrvWrapper.getDevInfo(),
                                               hDevRegKey,
                                               dwDeviceState,
                                               &spDevInfoData);
                        if (ulFlags & DEV_MAN_GEN_EVENTS) {

                            //
                            //  Check whether its state changed.  If it changed
                            //  from inactive to active, throw connect event.  If
                            //  state changed from active to inactive, throw disconnect event.
                            //
                            if (((~dwOldDevState) & DEV_STATE_ACTIVE) &&
                                (dwDeviceState & DEV_STATE_ACTIVE)) {

                                //
                                //  Load the driver
                                //
                                //DumpDevInfo(pActiveDevice->m_DrvWrapper.getDevInfo());
                                //pActiveDevice->LoadDriver();

                                GenerateEventForDevice(&WIA_EVENT_DEVICE_CONNECTED, pActiveDevice);
                            } else if ((dwOldDevState & DEV_STATE_ACTIVE) &&
                                       ((~dwDeviceState) & DEV_STATE_ACTIVE)) {
                                GenerateSafeDisconnectEvent(pActiveDevice);
                                pActiveDevice->UnLoadDriver(FALSE);
                            }
                        }
                        */
                        pActiveDevice->Release();

                    } else {
                        //
                        //  Create and fill out a DEVICE_INFO structure.  For
                        //
                        pDevInfo = CreateDevInfoForFSDriver(pszMountPoint);
                        DumpDevInfo(pDevInfo);
                        AddDevice(ulFlags, pDevInfo);
                    }
                }

                if (pszMountPoint) {
                    CoTaskMemFree(pszMountPoint);
                    pszMountPoint        = NULL;
                }
                if (pszDeviceIDVolume) {
                    CoTaskMemFree(pszDeviceIDVolume);
                    pszDeviceIDVolume    = NULL;
                }
            }

            penum->Release();
        }

        pihwdevs->Release();
    } else {
        DBG_WRN(("CWiaDevMan::EnumVolumes, CoCreateInstance on CLSID_HardwareDevices failed"));
    }

    return hr;
}

/**************************************************************************\
* CWiaDevMan::FillRemoteDeviceStgs
*
*   Enumerate remote devices and create a device info. storage for each
*   remote device we come accross.  We don't touch the network here - the
*   remote devices are represented by the appropriate entries in the 
*   registry.  Only if the calling application calls CreateDevice(..) to 
*   talk to the device, do we hit the remote machine.
*
* Arguments:
*
*   ppRemoteDevList - Caller allocated array to store the dev. info. 
*                       interface pointers.
*   pulDevices      - This is an IN/OUT parameter.  
*                       On entry, this is the maximum number of dev. info. 
*                       stgs to add to the ppRemoteDevList array.  
*                       On return, this contains the actual number of dev.
*                       info. stgs added to the array.
*
* Return Value:
*
*   Status
*
* History:
*
*    2/05/2001 Original Version
*
\**************************************************************************/
HRESULT CWiaDevMan::FillRemoteDeviceStgs(
    IWiaPropertyStorage     **ppRemoteDevList, 
    ULONG                   *pulDevices)
{
    DBG_FN(::FillRemoteDeviceStgs);
    HRESULT         hr              = S_OK;

    //
    //  Check parameters
    //
    if (!ppRemoteDevList || !pulDevices) {
        DBG_WRN(("CWiaDevMan::FillRemoteDeviceStgs, NULL parameters are not allowed!"));
        return E_INVALIDARG;
    }

    ULONG   ulMaxDevicesToAdd   = *pulDevices;
    ULONG   ulNumDevices        = 0;

    //
    //  Enumerate remote devices and create a dev. info. storage for each one we find.
    //  We must not add more devices than ppRemoteDevList can hold, and we must set the 
    //  return value to indicate how many dev. info storages we did actually add.
    //

    //
    // find remote device entry in registry
    //
    LPWSTR szKeyName = REGSTR_PATH_STICONTROL_DEVLIST_W;

    HKEY    hKeySetup,hKeyDevice;
    LONG    lResult;
    DWORD   dwMachineIndex = 0;

    if (RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                  szKeyName,
                  0,
                  KEY_READ | KEY_WRITE,
                  &hKeySetup) == ERROR_SUCCESS) {


        //
        // look for machine names
        //
        WCHAR wszTemp[MAX_PATH+1];
        WCHAR *pwszTempVal = NULL;

        //
        // go through enumeration, open key
        //
        dwMachineIndex = 0;

        do {

            hr = S_OK;
            lResult = RegEnumKeyW(hKeySetup,dwMachineIndex,wszTemp,MAX_PATH+1);

            if (lResult == ERROR_SUCCESS) {

                //
                //  Increment the index so we can get the next key on next
                //  iteration
                //
                dwMachineIndex++;

                //
                //  Paranoid overflow check.  If we don't have enough space for
                //  this, then break out of the loop.
                //
                if (ulNumDevices >= ulMaxDevicesToAdd) {
                    break;
                }

                lResult = RegOpenKeyExW (hKeySetup,
                              wszTemp,
                              0,
                              KEY_READ | KEY_WRITE,
                              &hKeyDevice);

                if (lResult == ERROR_SUCCESS) {

                    DEVICE_INFO *pDeviceInfo = NULL;

                    //
                    //  We need to create a Dev. Info. for this remote device.  The 
                    //  property storage is created from the DEVICE_INFO struct we
                    //  create from the remote device registry entry.
                    //  
                    pDeviceInfo = CreateDevInfoForRemoteDevice(hKeyDevice);
                    if (pDeviceInfo) {

                        ppRemoteDevList[ulNumDevices] = CreateDevInfoStg(pDeviceInfo);
                        if (ppRemoteDevList[ulNumDevices]) {

                            //
                            //  We successfully created a dev. info. for this remote device,
                            //  so increment the returned dev. info. count.
                            //
                            ulNumDevices++;
                        }
                        
                        //
                        //  Cleanup the DEVICE_INFO struct since it's no longer needed
                        // 
                        delete pDeviceInfo;
                        pDeviceInfo = NULL;
                    }

                    RegCloseKey(hKeyDevice);
                    hKeyDevice = NULL;
                } else {
                    DBG_ERR(("CWiaDevMan::FillRemoteDeviceStgs, failed RegOpenKeyExW, status = %lx",lResult));
                }
            }
        } while (lResult == ERROR_SUCCESS);

        RegCloseKey(hKeySetup);
    }

    *pulDevices = ulNumDevices;
    return hr;
}

/**************************************************************************\
* CWiaDevMan::CountRemoteDevices
*
*   This method counts the number of remote devices.  The remote devices
*   are represented by registry entries in the DevList section under
*   the StillImage key.
*
* Arguments:
*
*   ulFlags - Currently unused
*
* Return Value:
*
*   Number of remote devices.
*
* History:
*
*    2/05/2001 Original Version
*
\**************************************************************************/
ULONG CWiaDevMan::CountRemoteDevices(
    ULONG   ulFlags)
{
    DBG_FN(::CountRemoteDevices);

    HRESULT         hr              = S_OK;

    //
    // find remote device entry in registry
    //

    LPWSTR szKeyName = REGSTR_PATH_STICONTROL_DEVLIST_W;

    HKEY    hKeyDeviceList;
    LONG    lResult;
    DWORD   dwNumDevices = 0;

    if (RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                       szKeyName,
                       0,
                       KEY_READ | KEY_WRITE,
                       &hKeyDeviceList) == ERROR_SUCCESS) {

        //
        //  Get the number of sub-keys.  Since each remote device is stored 
        //  under a separate key, this will give us the total number of
        //  remote devices.
        //
        lResult = RegQueryInfoKey(hKeyDeviceList,
                                  NULL,
                                  0,
                                  NULL,
                                  &dwNumDevices,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);

        RegCloseKey(hKeyDeviceList);
    }

    return dwNumDevices;
}


/**************************************************************************\
* CWiaDevMan::IsCorrectEnumType
*
*   This function checks whether a given device (represented by pInfo)
*   matches the category of devices specified in the enumeration flags
*   (specified by ulEnumType)
*
*   This function works on the principle that if the device is of type X, and
*   you didn't ask for X, then it returns FALSE.  Else, it returns TRUE.
*
* Arguments:
*
*   ulEnumType  -   Enumeration flags (see DEV_MAN_ENUM_TYPE_XXXX in header)
*   pInfo       -   Pointer to DEVICE_INFO
*
* Return Value:
*
*   TRUE    - This device falls into the category of devices
*   FALSE   - This device does not fall into the category of devices we want
*
* History:
*
*    11/06/2000 Original Version
*
\**************************************************************************/
BOOL CWiaDevMan::IsCorrectEnumType(
    ULONG       ulEnumType,
    DEVICE_INFO *pInfo)
{

    if (!pInfo) {
        return FALSE;
    }

    // Shortcut - if ulEnumType == ALL_DEVICES return TRUE?

    if (!(pInfo->dwDeviceState & DEV_STATE_ACTIVE) &&
        !(ulEnumType & DEV_MAN_ENUM_TYPE_INACTIVE)) {
        //
        //  This device is inactive and caller only wanted active
        //
        return FALSE;
    }

    if (!(pInfo->dwInternalType & INTERNAL_DEV_TYPE_WIA) &&
        !(ulEnumType & DEV_MAN_ENUM_TYPE_STI)) {
        //
        //  This is an STI only device, and caller asked for WIA
        //
        return FALSE;
    }

    if (!(ulEnumType & DEV_MAN_ENUM_TYPE_VOL) &&
        (pInfo->dwInternalType & INTERNAL_DEV_TYPE_VOL)) {

        //
        //  This is volume device and caller didn't ask to include volume.  We
        //  first check whether the bMakeVolumesVisible override is set to TRUE,
        //  else we don't want it to show up, so we return FALSE.
        //

        if (!m_bMakeVolumesVisible) {
            return FALSE;
        }
    }

    if ((ulEnumType & DEV_MAN_ENUM_TYPE_LOCAL_ONLY) &&
        !(pInfo->dwInternalType & INTERNAL_DEV_TYPE_LOCAL)) {

        //
        //  This is remote and asked not to include remote
        //
        return FALSE;
    }

    return TRUE;
}

/**************************************************************************\
* CWiaDevMan::GenerateSafeConnectEvent
*
*   This function generates a connect event for a device, IFF it has not
*   been generated already.
*
* Arguments:
*
*   pActiveDevice   -   Indicates which device we want to generate the event
*                       for.
*
* Return Value:
*
*   Status
*
* History:
*
*    01/29/2001 Original Version
*
\**************************************************************************/
HRESULT CWiaDevMan::GenerateSafeConnectEvent(
    ACTIVE_DEVICE   *pActiveDevice)
{
    HRESULT     hr      = S_OK;

    if (pActiveDevice) {

        //
        //  Check whether we have already thrown a connect event for the
        //  device.  We don't want to throw it twice, so only throw it if
        //  the connect event state shows it hasn't been done yet.
        //
        if (!pActiveDevice->m_DrvWrapper.wasConnectEventThrown()) {
            DBG_PRT(("CWiaDevMan::GenerateSafeConnectEvent, generating event for device (%ws)", pActiveDevice->GetDeviceID()));

            //
            //  Generate the connect event
            //
            hr = GenerateEventForDevice(&WIA_EVENT_DEVICE_CONNECTED, pActiveDevice);
            if (SUCCEEDED(hr)) {

                //
                //  Mark that the event was generated
                //
                pActiveDevice->m_DrvWrapper.setConnectEventState(TRUE);
            } else {
                DBG_WRN(("CWiaDevMan::GenerateSafeConnectEvent, could not generate connect event for device (%ws)",
                         pActiveDevice->GetDeviceID()));
            }
        }
    } else {
        DBG_WRN(("CWiaDevMan::GenerateSafeConnectEvent, called with NULL parameter, ignoring request..."));
    }
    return hr;
}

/**************************************************************************\
* CWiaDevMan::GenerateSafeDisconnectEvent
*
*   This function generates a disconnect event for a device, and clears the
*   connect event flag set by GenerateSafeConnectEvent(...).
*
* Arguments:
*
*   pActiveDevice   -   Indicates which device we want to generate the event
*                       for.
*
* Return Value:
*
*   Status
*
* History:
*
*    01/29/2001 Original Version
*
\**************************************************************************/
HRESULT CWiaDevMan::GenerateSafeDisconnectEvent(
    ACTIVE_DEVICE   *pActiveDevice)
{
    HRESULT     hr      = S_OK;

    if (pActiveDevice) {


        //
        //  Check the connect event flag for the device.  We only want to 
        //  throw the disconnect event if this bit is set, so it
        //  prevents us from throwing it twice.
        //
        if (pActiveDevice->m_DrvWrapper.wasConnectEventThrown()) {
            DBG_PRT(("CWiaDevMan::GenerateSafeDisconnectEvent, generating event for device (%ws)", pActiveDevice->GetDeviceID()));

            //
            //  Generate the disconnect event
            //
            hr = GenerateEventForDevice(&WIA_EVENT_DEVICE_DISCONNECTED, pActiveDevice);
    
            //
            //  Whether we succeeded or not, clear the Connect Event State
            //
            pActiveDevice->m_DrvWrapper.setConnectEventState(FALSE);
        }
    } else {
        DBG_WRN(("CWiaDevMan::GenerateSafeDisconnectEvent, called with NULL parameter, ignoring request..."));
    }
    return hr;
}

HKEY CWiaDevMan::GetHKeyFromMountPoint(WCHAR *wszMountPoint)
{
    HKEY    hDevRegKey      = NULL;
    DWORD   dwError         = 0;
    DWORD   dwDisposition   = 0;

    WCHAR   wszKeyPath[MAX_PATH * 2];

    if (!wszMountPoint) {
        return NULL;
    } 

    //
    //  Create the sub-key name.  It will be something like:
    //   System\CurrentControlSet\Control\StillImage\MSCDeviceList\F:
    //
    lstrcpynW(wszKeyPath, REGSTR_PATH_WIA_MSCDEVICES_W, sizeof(wszKeyPath) / sizeof(wszKeyPath[0]));
    lstrcpynW(wszKeyPath + lstrlenW(wszKeyPath), L"\\", sizeof(wszKeyPath) / sizeof(wszKeyPath[0]) - lstrlenW(wszKeyPath));
    if (lstrlenW(wszMountPoint) < (int)((sizeof(wszKeyPath) / sizeof(wszKeyPath[0]) - lstrlenW(wszKeyPath)))) {
        lstrcatW(wszKeyPath, wszMountPoint);

        //
        //  Strip off the \ at the end of the mount point
        //
        wszKeyPath[lstrlenW(wszKeyPath) - 1] = L'\0';
    } else {
        dwError = ERROR_BAD_ARGUMENTS;
        DBG_WRN(("CWiaDevMan::GetHKeyFromMountPoint, bad parameters, returning NULL for HKEY"));
        return NULL;
    }

    //
    //  Since this is a MSC device, we don't have normal device registry key.
    //  So, we create a "fake" set of entries in a known place, and use those
    //  to store the relevant info for MSC devices.  This is used mainly to
    //  store the user's event settings.
    //

    dwError = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                             wszKeyPath,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hDevRegKey,
                             &dwDisposition);
    if (dwError == ERROR_SUCCESS) {

        if (dwDisposition == REG_CREATED_NEW_KEY) {

            //
            //  This is a newly created key, so we have to fill in the
            //  relevant entries.
            //
            HRESULT hr = S_OK;

            hr = CreateMSCRegEntries(hDevRegKey, wszMountPoint);
        } 
    } else {
        DBG_WRN(("CWiaDevMan::GetHKeyFromMountPoint, RegCreateKeyExW on (%ws) failed!", wszKeyPath));
    }

    return hDevRegKey;
}


HKEY CWiaDevMan::GetHKeyFromDevInfoData(SP_DEVINFO_DATA *pspDevInfoData)
{
    HKEY    hDevRegKey    = NULL;

    //
    // Get device regkey.
    //

    if (pspDevInfoData) {
        hDevRegKey = SetupDiOpenDevRegKey(m_DeviceInfoSet,
                                          pspDevInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ | KEY_WRITE);
        if(hDevRegKey == INVALID_HANDLE_VALUE){
            DBG_WRN(("CWiaDevMan::GetHKeyFromDevInfoData, SetupDiOpenDevRegKey returned INVALID_HANDLE_VALUE"));
            hDevRegKey = NULL;
        }
    }

    return hDevRegKey;
}

HKEY CWiaDevMan::GetHKeyFromDevInterfaceData(SP_DEVICE_INTERFACE_DATA *pspDevInterfaceData)
{
    HKEY    hDevRegKey    = NULL;

    //
    // Get device regkey using interface data
    //

    if (pspDevInterfaceData) {
        hDevRegKey = SetupDiOpenDeviceInterfaceRegKey(m_DeviceInfoSet,
                                                      pspDevInterfaceData,
                                                      0,
                                                      KEY_READ | KEY_WRITE);
        if(hDevRegKey == INVALID_HANDLE_VALUE){
            DBG_WRN(("CWiaDevMan::GetHKeyFromDevInterfaceData, SetupDiOpenDevRegKey returned INVALID_HANDLE_VALUE"));
            hDevRegKey = NULL;
        }
    }

    return hDevRegKey;
}

HKEY CWiaDevMan::GetDeviceHKey(
    WCHAR   *wszDeviceID,
    WCHAR   *wszSubKeyName)
{
    TAKE_CRIT_SECT  tcs(m_csDevList);
    ACTIVE_DEVICE   *pActiveDevice  = NULL;
    HKEY            hKey            = NULL;

    pActiveDevice = IsInList(DEV_MAN_IN_LIST_DEV_ID, wszDeviceID);
    if (pActiveDevice) {

        hKey = GetDeviceHKey(pActiveDevice, wszSubKeyName);

        //
        //  Release the active device since it was addref'd by IsInList
        //
        pActiveDevice->Release();
    }

    if (!IsValidHANDLE(hKey)) {
        DBG_TRC(("CWiaDevMan::GetDeviceHKey (name), Key not found for (%ws), returning NULL", wszDeviceID));
    }
    return hKey;
}

HKEY CWiaDevMan::GetDeviceHKey(
    ACTIVE_DEVICE   *pActiveDevice,
    WCHAR           *wszSubKeyName)
{
    DEVICE_INFO     *pDevInfo       = NULL;
    HKEY            hKeyTemp        = NULL;
    HKEY            hKey            = NULL;
    DWORD           dwRet           = 0;

    if (pActiveDevice) {

        //
        //  Get the device's HKEY
        //
        pDevInfo = pActiveDevice->m_DrvWrapper.getDevInfo();
        if (pDevInfo) {

            //
            //  If it's a volume device i.e. normal MSC like a card reader,
            //  then we don't have a Device HKEY, so skip this.
            //

            if (!(pDevInfo->dwInternalType & INTERNAL_DEV_TYPE_VOL)) {
                //
                //  We have 3 cases: 1, it's a MSC camera
                //                   2, it's a normal DevNode device
                //                   3, it's an interface device
                //

                if (pDevInfo->dwInternalType & INTERNAL_DEV_TYPE_MSC_CAMERA) {
                    hKeyTemp = GetHKeyFromMountPoint(pDevInfo->wszAlternateID);
                } else if (pDevInfo->dwInternalType & INTERNAL_DEV_TYPE_INTERFACE) {
                    hKeyTemp = GetHKeyFromDevInterfaceData(&pDevInfo->spDevInterfaceData);
                } else {
                    hKeyTemp = GetHKeyFromDevInfoData(&pDevInfo->spDevInfoData);
                }
            }

            //
            //  Set the return.  Note that hKey may be over written with the subkey later on
            //
            hKey = hKeyTemp;
        }

        //
        //  If asked, get the subkey instead
        //
        if (wszSubKeyName) {

            //
            //  Check that we have a valid device registry key first
            //
            if (IsValidHANDLE(hKeyTemp)) {
                dwRet = RegCreateKeyExW(hKeyTemp,
                                        wszSubKeyName,
                                        NULL,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ | KEY_WRITE,
                                        NULL,
                                        &hKey,
                                        NULL);
                if (dwRet != ERROR_SUCCESS) {
                    hKey = NULL;
                }
                //
                //  Close the device registry key, we will be returning the sub-key instead
                //
                RegCloseKey(hKeyTemp);
            }
        }
    }

    if (!IsValidHANDLE(hKey)) {
        DBG_TRC(("CWiaDevMan::GetDeviceHKey, Key not found for (%ws), returning NULL", pActiveDevice->GetDeviceID()));
    }
    return hKey;
}

HRESULT CWiaDevMan::UpdateDeviceRegistry(
    DEVICE_INFO    *pDevInfo)
{
    HRESULT hr          = S_OK;
    HKEY    hDevRegKey  = NULL;
    HKEY    hKeyDevData = NULL;

    if (!pDevInfo) {
        return E_INVALIDARG;
    }

    //
    //  Grab the device's HKey
    //

    hDevRegKey = GetDeviceHKey(pDevInfo->wszDeviceInternalName, NULL);
    if (IsValidHANDLE(hDevRegKey)) {
        //
        //  Write any properties that may have changed.  So far, we only allow updating of:
        //      Friendly name
        //      Port name
        //      BaudRate
        //

        DWORD   dwRet   = 0;
        DWORD   dwType  = REG_SZ;
        DWORD   dwSize  = 0;

        //
        //  These properties are written to the device registry key
        //

        if (pDevInfo->wszLocalName) {
            dwType = REG_SZ;
            dwSize = (lstrlenW(pDevInfo->wszLocalName) + 1) * sizeof(WCHAR);
            dwRet  = RegSetValueExW(hDevRegKey,
                                    REGSTR_VAL_FRIENDLY_NAME_W,
                                    0,
                                    dwType,
                                    (LPBYTE) pDevInfo->wszLocalName,
                                    dwSize);
            if (dwRet != ERROR_SUCCESS) {
                DBG_WRN(("CWiaDevMan::UpdateDeviceRegistry, error updating %ws for device %ws", REGSTR_VAL_FRIENDLY_NAME_W, pDevInfo->wszDeviceInternalName));
            }
        }

        if (pDevInfo->wszPortName) {
            dwType = REG_SZ;
            dwSize = (lstrlenW(pDevInfo->wszPortName) + 1) * sizeof(WCHAR);
            dwRet  = RegSetValueExW(hDevRegKey,
                                    REGSTR_VAL_DEVICEPORT_W,
                                    0,
                                    dwType,
                                    (LPBYTE) pDevInfo->wszPortName,
                                    dwSize);
            if (dwRet != ERROR_SUCCESS) {
                DBG_WRN(("CWiaDevMan::UpdateDeviceRegistry, error updating %ws for device %ws", REGSTR_VAL_DEVICEPORT_W, pDevInfo->wszDeviceInternalName));
            }
        }

        //
        //  These properties are written to the device data registry key.  Since we
        //  only have the device registry key open, we have to open the device data
        //  data key for these properties
        //

        dwRet = RegCreateKeyExW(hDevRegKey, REGSTR_VAL_DATA_W, NULL, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                             NULL, &hKeyDevData, NULL);
        if (IsValidHANDLE(hKeyDevData)) {
            if (pDevInfo->wszBaudRate) {
                dwType = REG_SZ;
                dwSize = (lstrlenW(pDevInfo->wszBaudRate) + 1) * sizeof(WCHAR);
                dwRet  = RegSetValueExW(hKeyDevData,
                                        REGSTR_VAL_BAUDRATE,
                                        0,
                                        dwType,
                                        (LPBYTE) pDevInfo->wszBaudRate,
                                        dwSize);
                if (dwRet != ERROR_SUCCESS) {
                    DBG_WRN(("CWiaDevMan::UpdateDeviceRegistry, error updating %ws for device %ws", REGSTR_VAL_DEVICEPORT_W, pDevInfo->wszDeviceInternalName));
                }
            }
        } else {
            DBG_TRC(("CWiaDevMan::UpdateDeviceRegistry, could not find device data section in registry for %ws", pDevInfo->wszDeviceInternalName));
            hr = E_INVALIDARG;
        }
    } else {
        DBG_TRC(("CWiaDevMan::UpdateDeviceRegistry, could not find device registry key for %ws", pDevInfo->wszDeviceInternalName));
        hr = E_INVALIDARG;
    }

    //
    //  Close the registry keys
    //

    if (IsValidHANDLE(hDevRegKey)) {
        RegCloseKey(hDevRegKey);
    }
    if (IsValidHANDLE(hKeyDevData)) {
        RegCloseKey(hKeyDevData);
    }

    return hr;
}


VOID CWiaDevMan::UnloadAllDrivers(
    BOOL    bForceUnload,
    BOOL    bGenEvents)
{
    TAKE_CRIT_SECT  tcs(m_csDevList);

    //
    //  Walk list and unload all drivers.
    //

    //
    //  Walk through list of devices
    //
    LIST_ENTRY      *pentry         = NULL;
    LIST_ENTRY      *pentryNext     = NULL;
    ACTIVE_DEVICE   *pActiveDevice  = NULL;

    {
        //
        //  For each device in list, call the UnLoadDriver(...) method
        //
        for ( pentry  = m_leDeviceListHead.Flink; pentry != &m_leDeviceListHead; pentry  = pentryNext ) {

            pentryNext = pentry->Flink;
            pActiveDevice = CONTAINING_RECORD( pentry, ACTIVE_DEVICE,m_ListEntry );

            //
            //  If asked, make sure we send out disconnect event, only for WIA devices
            //
            if (bGenEvents && pActiveDevice->m_DrvWrapper.IsWiaDevice()) {

                //
                //  Only throw disconnect events for devices that are active
                //
                if (pActiveDevice->m_DrvWrapper.getDeviceState() & DEV_STATE_ACTIVE) {
                    GenerateSafeDisconnectEvent(pActiveDevice);
                }
            }
            ProcessDeviceRemoval(pActiveDevice, TRUE);
        }
    }
}


void CALLBACK CWiaDevMan::ShellHWEventAPCProc(ULONG_PTR ulpParam)
{
    SHHARDWAREEVENT *pShellHWEvent = (SHHARDWAREEVENT*)ulpParam;
    CWiaDevMan      *pDevMan       = g_pDevMan;

    if (!pShellHWEvent || !pDevMan) {
        return;
    }
    switch (pShellHWEvent->dwEvent)
    {
        case SHHARDWAREEVENT_MOUNTPOINTARRIVED:
        {
            DBG_PRT(("MOUNTPOINTARRIVED"));
            TAKE_CRIT_SECT  tcs(pDevMan->m_csDevList);

            //
            //  ReEnumerate volumes
            //
            pDevMan->EnumVolumes(DEV_MAN_GEN_EVENTS);

            break;
        }

        case SHHARDWAREEVENT_MOUNTPOINTREMOVED:
        {
            DBG_PRT(("MOUNTPOINTREMOVED"));
            LPCWSTR pszMountPoint = (LPCWSTR)(&(pShellHWEvent->rgbPayLoad));  // Do we need to worry about alignment?

            TAKE_CRIT_SECT  tcs(pDevMan->m_csDevList);
            //
            //  If volume devices are enabled, then remove this mount point
            //
            if (pDevMan->VolumesAreEnabled()) {
                ACTIVE_DEVICE   *pActiveDevice;

                pActiveDevice = pDevMan->IsInList(DEV_MAN_IN_LIST_ALT_ID, pszMountPoint);
                if (pActiveDevice) {

                    pDevMan->RemoveDevice(pActiveDevice);
                    pActiveDevice->Release();
                }
            }
            break;
        }

        case SHHARDWAREEVENT_VOLUMEARRIVED:
        case SHHARDWAREEVENT_VOLUMEUPDATED:
        case SHHARDWAREEVENT_VOLUMEREMOVED:
        case SHHARDWAREEVENT_MOUNTDEVICEARRIVED:
        case SHHARDWAREEVENT_MOUNTDEVICEUPDATED:
        case SHHARDWAREEVENT_MOUNTDEVICEREMOVED:

        default:
            {
                DBG_PRT(("DEFAULT_EVENT"));
                TAKE_CRIT_SECT  tcs(pDevMan->m_csDevList);

                //
                //  ReEnumerate volumes
                //
                pDevMan->EnumVolumes(DEV_MAN_GEN_EVENTS);
            }
            break;
    }

    //
    //  Notice that it's a VirtualFree!
    //
    VirtualFree((void*)ulpParam, 0, MEM_RELEASE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiadevman.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiadevman.h
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        6 Nov, 2000
*
*  DESCRIPTION:
*   Declarations and definitions for the WIA device manager class.
*   It controls the enumeration of devices, the internal device list, adding
*   removing of devices from this list (PnP initiated) and implements the
*   IWiaDevMgr interface.
*
*******************************************************************************/

//
//  Flags used to control refreshing device list
//      DEV_MAN_FULL_REFRESH    means throw away old infoset and get a new one.
//                              This is not something that should happen very 
//                              often, in fact, you only really want to do it
//                              when a device is installed/uninstalled
//      DEV_MAN_GEN_EVENTS      means generate connect/disconnect events.
//                              There are 2 cases where we send out CONNECT events:
//                              1.  If device_object doesn't exist, and we we 
//                              create a new one i.e. we've noticed a new device
//                              2.  If a device_object exists, and the device 
//                              was unplugged, and is now plugged in.
//      DEV_MAN_STATUS_STARTP   Update service status with Start Pending
//      
#define DEV_MAN_FULL_REFRESH    0x00000001
#define DEV_MAN_GEN_EVENTS      0x00000002
#define DEV_MAN_STATUS_STARTP   0x00000004

//
//  Operational flags for ForEachDeviceInList(...)
//      DEV_MAN_OP_DEV_SET_FLAGS    This operation is to set each ACTIVE_DEVICE's
//                                  flags.
//      DEV_MAN_OP_DEV_REMOVE_MATCH This operation is to remove any ACTIVE_DEVICE
//                                  matching the corresponding flags.  This is 
//                                  usually used to purge the device list of
//                                  devices that have been uninstalled (NOT unplugged!)
//
#define DEV_MAN_OP_DEV_SET_FLAGS        1
#define DEV_MAN_OP_DEV_REMOVE_MATCH     2
#define DEV_MAN_OP_DEV_REREAD           3
#define DEV_MAN_OP_DEV_RESTORE_EVENT    4

//
//  Flags for IsInList(...)
//      DEV_MAN_IN_LIST_DEV_ID      Match should be made on DeviceID
//      DEV_MAN_IN_LIST_ALT_ID      Match should be made on AlternateID
//
#define DEV_MAN_IN_LIST_DEV_ID      1
#define DEV_MAN_IN_LIST_ALT_ID      2

//  NOTE: These flags are mirrored in wiadevdp.h.  Any updates should be made in both places.
//
//  Flags for enumeration.  Used in GetDevInfoStgs(...) to create device lists
//  for WIA device enumeration
//      DEV_MAN_ENUM_TYPE_VOL       Will enumerate our volume devices
//      DEV_MAN_ENUM_TYPE_INACTIVE  Will enumerate inactive devices (e.g. USB 
//                                  device thaat is unplugged)
//      DEV_MAN_ENUM_TYPE_STI       Will enumerate STI only devices too
//      DEV_MAN_ENUM_TYPE_ALL       Will enumerate all devices
//      DEV_MAN_ENUM_TYPE_LOCAL_ONLY Will exclude remote devices
//
#define DEV_MAN_ENUM_TYPE_VOL       0x00000002
#define DEV_MAN_ENUM_TYPE_INACTIVE  0x00000004
#define DEV_MAN_ENUM_TYPE_STI       0x00000008
#define DEV_MAN_ENUM_TYPE_ALL       0x0000000F
#define DEV_MAN_ENUM_TYPE_LOCAL_ONLY    WIA_DEVINFO_ENUM_LOCAL  // 0x00000010

//
//  This class manages the device list.  Generally, our device list works as follows:
//  1.  We create an infoset from SetupApis for all StillImage devices on the system.
//      This includes devnode and interface type devices, and disabled ones.
//  2.  We also enumerate volumes.
//  3.  For each device we find in the above two categories, we create an ACTIVE_DEVICE
//      object (rename to DEVICE_OBJECT?).  This is essentially a place holder for that
//      device.  It will include a CDrvWrapper object that contains all the information
//      we know about that device and anything needed to load the driver.
//  4.  Each ACTIVE_DEVICE object will decide whether the driver for its device should
//      be loaded on startup or JIT.  If the device is not present (i.e. INACTIVE), it
//      is not loaded.
//  5.  Once we have this device list, we can enumerate active/inactive devices, load
//      /unload drivers when a device comes or goes etc.
//

class CWiaDevMan {
public:

    //
    //  Public methods
    //

    CWiaDevMan();
    ~CWiaDevMan();
    HRESULT Initialize();
    VOID    GetRegistrySettings();
    
    HRESULT ReEnumerateDevices(ULONG ulFlags);                      //  Flags indicate: GenEvents, Full Refresh.

    HRESULT GenerateEventForDevice(const GUID* event, ACTIVE_DEVICE *pActiveDevice);
    HRESULT NotifyRunningDriversOfEvent(const GUID *pEvent);

    ACTIVE_DEVICE*  IsInList(ULONG ulFlags, const WCHAR *wszID);    // Can search on DeviceID, AlternateID

    //
    //  Methods for Device arrival/removal.  Note that these are not for device
    //  installation/uninstallation.  When a WIA device is installed/removed, the
    //  class installer will call us, and we will do a full refresh.
    //
    HRESULT ProcessDeviceArrival();
            // This is not mean device uninstallation - it is for hot-unplugging of devices
    HRESULT ProcessDeviceRemoval(WCHAR  *wszDeviceId);              
            // This is not mean device uninstallation
    HRESULT ProcessDeviceRemoval(ACTIVE_DEVICE *pActiveDevice, BOOL bGenEvent = TRUE);

    //
    //  Methods for counting and enumeration
    //
                    // Get number of devices.  Flags are the DEV_MAN_ENUM_TYPE_XXXXX
    ULONG           NumDevices(ULONG ulFlags);  
                    // Flags are DEV_MAN_ENUM_TYPE_XXXX
    HRESULT         GetDevInfoStgs(ULONG ulFlags, ULONG *pulNumDevInfoStream, IWiaPropertyStorage ***pppOutputStorageArray);  
    VOID    WINAPI  EnumerateActiveDevicesWithCallback(PFN_ACTIVEDEVICE_CALLBACK   pfn, VOID *pContext);
    HRESULT         ForEachDeviceInList(ULONG ulFLags, ULONG ulParam);  // Do some operation for each device in the device list

    //
    //  Methods for getting device information from registry
    //
    HRESULT GetDeviceValue(ACTIVE_DEVICE *pActiveDevice, WCHAR* pValueName, DWORD *pType, BYTE *pData, DWORD *cbData);
    HKEY    GetDeviceHKey(WCHAR *wszDeviceID, WCHAR *wszSubKeyName);
    HKEY    GetDeviceHKey(ACTIVE_DEVICE *pActiveDevice, WCHAR *wszSubKeyName);
    HKEY    GetHKeyFromMountPoint(WCHAR *wszMountPoint);
    HKEY    GetHKeyFromDevInfoData(SP_DEVINFO_DATA *pspDevInfoData);
    HKEY    GetHKeyFromDevInterfaceData(SP_DEVICE_INTERFACE_DATA *pspDevInterfaceData);

    //
    //  Method for setting device information to registry
    //
    HRESULT UpdateDeviceRegistry(DEVICE_INFO    *pDevInfo);

    //
    //  Methods for matching information PnP gives us to our actual device
    //
    WCHAR           *AllocGetInterfaceNameFromDevInfo(DEVICE_INFO *pDevInfo);
    BOOL            LookupDriverNameFromInterfaceName(LPCTSTR pszInterfaceName, StiCString *pstrDriverName);
    ACTIVE_DEVICE   *LookDeviceFromPnPHandles(HANDLE hInterfaceHandle, HANDLE hPnPSink);

    //
    //  Methods for unloading/destroying our device list
    //
    VOID    UnloadAllDrivers(BOOL bForceUnload, BOOL bGenEvents);
    VOID    DestroyDeviceList();

    //
    //  Public fields
    //

private:

    //
    //  Private methods
    //

    //
    //  Methods to create and destroy our underlying device infoset
    //
    VOID    DestroyInfoSet();
    HRESULT CreateInfoSet();

    //
    //  Methods for adding/removing devices from the list
    //

    //
    //  AddDevice means create a new device object
    //
    HRESULT AddDevice(ULONG ulFlags, DEVICE_INFO *pInfo);

    //
    //  Remove device means remove a device object from the list.
    //  This is not the same as device disconnected - if a device is
    //  disconnected, the inactive device may still be enumerated, therefore
    //  it should stay in this list.
    //
    HRESULT RemoveDevice(ACTIVE_DEVICE *pActiveDevice);
    HRESULT RemoveDevice(DEVICE_INFO *pInfo);
    
    //
    //  Helper methods
    //
    BOOL    VolumesAreEnabled();                                // Checks whether we should enable volume devices
                                                                //  Disabled for IA64 for now.

    HRESULT EnumDevNodeDevices(ULONG ulFlags);                  // Enumerate our devnode devices
    HRESULT EnumInterfaceDevices(ULONG ulFlags);                // Enumerate our interface devices
    HRESULT EnumVolumes(ULONG ulFlags);                         // Enumerate volumes

    //
    //  Remote device helpers
    //
    HRESULT FillRemoteDeviceStgs(                               // Enumerate remote devices and create a dev. info.
        IWiaPropertyStorage     **ppRemoteDevList,              //  stg. for each one.  Put the dev. info. pointers
        ULONG                   *pulDevices);                   //  into caller allocated array.
    ULONG   CountRemoteDevices(ULONG   ulFlags);                // Returns count for number of remote device entries.
    
    BOOL    IsCorrectEnumType(ULONG ulEnumType, 
                              DEVICE_INFO *pInfo);              // Checks whether a given device falls into device category specified by the enumeration flags

    HRESULT GenerateSafeConnectEvent(
        ACTIVE_DEVICE  *pActiveDevice);                         // Only generates connect event if it has not already been done
    HRESULT GenerateSafeDisconnectEvent(
        ACTIVE_DEVICE  *pActiveDevice);                         // Generates disconnect event and clears device's connect event flag set by GenerateSafeConnectEvent

    //
    //  Static function for Shell's HW notification callback.
    //
    static VOID CALLBACK ShellHWEventAPCProc(ULONG_PTR ulpParam);

    //
    //  Private fields
    //

    LIST_ENTRY          m_leDeviceListHead; // List of DEVICE_OBJECTs.  Currently correspond to ACTIVE_DEVICE
    HDEVINFO            m_DeviceInfoSet;    // DeviceInfoSet for real WIA devices, both DevNode type and Interface type
    CRIT_SECT           m_csDevList;        // Critical section for device list access
    BOOL                m_bMakeVolumesVisible;  // Indicates whether volume device should be included in normal device enumeration
    BOOL                m_bVolumesEnabled;  // Indicates whether we enable volumes
    DWORD               m_dwHWCookie;       // Cookie for use in unregistering for volume notifications
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiagitm.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       WiaGItm.Cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        14 Jan, 2000
*
*  DESCRIPTION:
*   Implementation of CGenWiaItem.
*
*******************************************************************************/
#include "precomp.h"

#include "stiexe.h"
#include "wiapsc.h"
#define WIA_DECLARE_MANAGED_PROPS
#include "helpers.h"


/**************************************************************************\
* Initialize
*
*   CGenWiaItem Initialize method.  This method overrieds the base class
*   CWiaItem::Initialize, since a generated item
*
* Arguments:
*
*   pIWiaItemRoot   -
*   pIWiaMiniDrv    -
*   pWiaDrvItem     -
*   pIUnknownInner  -
*
* Return Value:
*
*    Status
*
* History:
*
*    14 Jan, 2000   -   Original Version
*
\**************************************************************************/

HRESULT _stdcall CGenWiaItem::Initialize(
    IWiaItem                *pIWiaItemRoot,
    IWiaPropertyStorage     *pIWiaDevInfoProps,
    ACTIVE_DEVICE           *pActiveDevice,
    CWiaDrvItem             *pWiaDrvItem,
    IUnknown                *pIUnknownInner)
{

    DBG_FN(CGenWiaItem::Initialize);
    
    HRESULT hr = S_OK;

#ifdef DEBUG
    BSTR bstr;
    if (SUCCEEDED(pWiaDrvItem->GetItemName(&bstr))) {
        DBG_TRC(("CGenWiaItem::Initialize: 0x%08X, %ws, drv item: 0x%08X", this, bstr, pWiaDrvItem));
        SysFreeString(bstr);
    }
#endif

    //
    // Validate parameters
    //

    if (!pActiveDevice || !pIWiaItemRoot || !pWiaDrvItem) {
        DBG_ERR(("CGenWiaItem::Initialize NULL input parameters"));
        return E_POINTER;
    }

    //
    // If optional inner component is present, save a pointer to it.
    //

    if (pIUnknownInner) {
        DBG_TRC(("CGenWiaItem::Initialize, pIUnknownInner: %X", pIUnknownInner));
        m_pIUnknownInner = pIUnknownInner;
    }

    //
    // Save driver info.
    //

    m_pWiaDrvItem   = pWiaDrvItem;
    m_pActiveDevice = pActiveDevice;
    m_pIWiaItemRoot = pIWiaItemRoot;

    hr = pWiaDrvItem->LinkToDrvItem(this);
    if (FAILED(hr)) {
        DBG_ERR(("CGenWiaItem::Initialize, LinkToDrvItem failed"));
        return hr;
    }

    //
    // Create streams and property storage for item properties.
    //

    m_pPropStg = new CWiaPropStg();
    if (m_pPropStg) {
        hr = m_pPropStg->Initialize();
        if (FAILED(hr)) {
            delete m_pPropStg;
            m_pPropStg = NULL;
            DBG_ERR(("CGenWiaItem::Initialize, PropertyStorage Initialize failed"));
            return hr;
        }
    } else {
        DBG_ERR(("CGenWiaItem::Initialize, not enough memory to create CWiaPropStg"));
        hr = E_OUTOFMEMORY;
        return hr;
    }
    m_bInitialized = TRUE;

    //
    // AddRef the driver item which can not be deleted until all
    // CWiaItem references are released and the driver item has been
    // removed from the driver item tree.
    //

    pWiaDrvItem->AddRef();

    return hr;
}

/**************************************************************************\
* GetItemType
*
*   Get the item type from the corresponding driver item.
*
* Arguments:
*
*    pItemType - Pointer to the returned item type.
*
* Return Value:
*
*    Status
*
* History:
*
*    14 Jan, 2000   -   Original Version
*
\**************************************************************************/

HRESULT _stdcall CGenWiaItem::GetItemType(LONG *pItemType)
{
    DBG_FN(CGenWiaItem::GetItemType);

    return m_pCWiaTree->GetItemFlags(pItemType);
}                        

/**************************************************************************\
* InitManagedItemProperties
*
*   A private helper for CGenWiaItem::Initialize, which initializes the
*   WIA managed item properties.
*
* Arguments:
*
*   None
*
* Return Value:
*
*    Status
*
* History:
*
*    14 Jan, 2000   -   Original Version
*
\**************************************************************************/

HRESULT _stdcall CGenWiaItem::InitManagedItemProperties(
    LONG    lFlags,
    BSTR    bstrItemName,
    BSTR    bstrFullItemName)
{
    DBG_FN(CWiaItem::InitManagedItemProperties);
    ULONG   ulNumProps;
    
    ulNumProps = NUM_WIA_MANAGED_PROPS;

    //
    // WIA manages the item name and type properties, so set the
    // property names here.
    //

    HRESULT hr = wiasSetItemPropNames((BYTE*)this,
                                      ulNumProps,
                                      s_piItemNameType,
                                      s_pszItemNameType);

    //
    // Set the name and type properties attributes.
    //

    PROPVARIANT propvar;
    ULONG       ulFlag;
    for (UINT i = 0; i < ulNumProps; i++) {

        if (i == PROFILE_INDEX) {
            propvar.vt      = VT_BSTR | VT_VECTOR;
            ulFlag          = WIA_PROP_RW | WIA_PROP_CACHEABLE | WIA_PROP_LIST;
        } else {
            propvar.vt      = VT_I4;
            ulFlag          = WIA_PROP_READ | WIA_PROP_CACHEABLE | WIA_PROP_NONE;
        }
        propvar.ulVal   = 0;

        hr = wiasSetPropertyAttributes((BYTE*)this,
                                       1,
                                       &s_psItemNameType[i],
                                       &ulFlag,
                                       &propvar);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::InitManagedItemProperties, wiasSetPropertyAttributes failed, index: %d", i));
            break;
        }
    }

    //
    // Set the item names and type.
    //

    PROPVARIANT *ppropvar;

    ppropvar = (PROPVARIANT*) LocalAlloc(LPTR, sizeof(PROPVARIANT) * ulNumProps);
    if (ppropvar) {
        memset(ppropvar, 0, sizeof(ppropvar[0]) * ulNumProps);

        ppropvar[0].vt      = VT_BSTR;
        ppropvar[0].bstrVal = bstrItemName;
        ppropvar[1].vt      = VT_BSTR;
        ppropvar[1].bstrVal = bstrFullItemName;
        ppropvar[2].vt      = VT_I4;
        ppropvar[2].lVal    = lFlags;

        hr = (m_pPropStg->CurStg())->WriteMultiple(ulNumProps,
                                                   s_psItemNameType,
                                                   ppropvar,
                                                   WIA_DIP_FIRST);
        if (FAILED(hr)) {
            ReportReadWriteMultipleError(hr, "CWiaItem::InitManagedItemProperties", 
                                         NULL, 
                                         FALSE, 
                                         ulNumProps, 
                                         s_psItemNameType);
        }
        LocalFree(ppropvar);
    } else {
        DBG_ERR(("CWiaItem::InitManagedItemProperties, Out of Memory!"));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT GetParamsForInitialize(
    BYTE        *pWiasContext, 
    CWiaItem    **ppRoot,
    ACTIVE_DEVICE **ppActiveDevice,
    CWiaDrvItem **ppDrvItem)
{
    DBG_FN(GetParamsForInitialize);
    HRESULT hr;

    //
    //  Get the root item, the nearest driver item, and the minidriver
    //  interfaces.  These are needed for the child item's initialization.
    //

    hr = wiasGetRootItem(pWiasContext, (BYTE**) ppRoot);
    if (SUCCEEDED(hr)) {

        *ppDrvItem = ((CWiaItem*)pWiasContext)->GetDrvItemPtr();
        if (*ppDrvItem) {
            CWiaItem *pItem = (CWiaItem*) pWiasContext;

            *ppActiveDevice = pItem->m_pActiveDevice;
        } else {
            DBG_ERR(("GetParamsForInitialize, No driver item found!"));
            hr = E_INVALIDARG;
        }
    } else {
        DBG_ERR(("GetParamsForInitialize, Could not get root item!"));
    }

    return hr;
}

HRESULT AddGenItemToParent(
    CWiaItem    *pParent,
    LONG        lFlags,
    BSTR        bstrItemName,
    BSTR        bstrFullItemName,
    CGenWiaItem *pChild)
{
    DBG_FN(GetParamsForInitialize);
    HRESULT hr = E_FAIL;

    //
    //  Create the Tree
    //

    CWiaTree *pNewTreeItem  = new CWiaTree;

    if (pNewTreeItem) {

        //
        //  Adjust parent's flags to indicate folder
        //

        pParent->m_pCWiaTree->SetFolderFlags();

        //
        //  Initialize the tree with flags, names and payload
        //

        hr = pNewTreeItem->Initialize(lFlags,
                                      bstrItemName,
                                      bstrFullItemName,
                                      (void*)pChild);
        if (SUCCEEDED(hr)) {

            pChild->m_pCWiaTree = pNewTreeItem;

            hr = pChild->m_pCWiaTree->AddItemToFolder(pParent->m_pCWiaTree);
            if (FAILED(hr)) {
                DBG_ERR(("AddGenItemToParent, Could not add item to folder!"));
            }
        } else {
            DBG_ERR(("AddGenItemToParent, Failed to initialize the tree!"));
        }

        if (FAILED(hr)) {
            delete pNewTreeItem;
            pChild->m_pCWiaTree = NULL;
        }
    } else {
        DBG_ERR(("AddGenItemToParent, Out of Memory!"));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

/**************************************************************************\
* wiasCreateChildAppItem
*
*   This function creates a new App. Item and inserts it as a child of the
*   specified (parent) item.  Note, that this item will not have any 
*   properties in it's property sets, until the driver/app actaully fills
*   them in.
*
* Arguments:
*
*   pWiasContext        -   the address of the item context to which we 
*                           want to add a child.
*   ppWiasChildContext  -   the address of a pointer which will contain the 
*                           address of the newly created child item's 
*                           context.
*
* Return Value:
*
*    Status
*
* History:
*
*    14 Jan, 2000   -   Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasCreateChildAppItem(
    BYTE        *pParentWiasContext,
    LONG        lFlags,
    BSTR        bstrItemName,
    BSTR        bstrFullItemName,
    BYTE        **ppWiasChildContext)
{

    DBG_FN(wiasCreateChildAppItem);
    HRESULT     hr = S_OK;
    CGenWiaItem *pChild;
    CWiaItem    *pItem      = (CWiaItem*) pParentWiasContext;
    CWiaItem    *pRoot      = NULL;
    CWiaDrvItem *pDrvItem   = NULL;
    ACTIVE_DEVICE *pActiveDevice   = NULL;

    if ((ValidateWiaItem((IWiaItem*) pParentWiasContext) != S_OK) ||
        (IsBadWritePtr(ppWiasChildContext, sizeof(BYTE*)))) {

        DBG_ERR(("wiasCreateChildAppItem, Invalid parameter!"));
        return E_INVALIDARG;
    } else {
        *ppWiasChildContext = NULL;
    }

    //
    //  Mark that this item is a generated item.
    //

    lFlags |= WiaItemTypeGenerated;

    //
    //  Create a new instance of a generated WIA app. item.
    //
    
    pChild = new CGenWiaItem();
    if (pChild) {

        hr = GetParamsForInitialize(pParentWiasContext, &pRoot, &pActiveDevice, &pDrvItem);
        if (SUCCEEDED(hr)) {

            //
            //  Initialize the new child item
            //

            hr = pChild->Initialize((IWiaItem*) pRoot, NULL, pActiveDevice, pDrvItem, NULL);
            if (SUCCEEDED(hr)) {

                //
                //  Initialize the WIA managed item properties (name, full name, type, ...)
                //  from the driver item.  Must set m_bInitialized to TRUE so that
                //  InitWiaManagedProperties doesn't attempt to InitLazyProps()
                //

                hr = pChild->InitManagedItemProperties(lFlags,
                                                       bstrItemName,
                                                       bstrFullItemName);
                if (SUCCEEDED(hr)) {

                    //
                    //  Add to the parent's Tree
                    //

                    hr = AddGenItemToParent(pItem,
                                            lFlags,
                                            bstrItemName,
                                            bstrFullItemName,
                                            pChild);

                    if (SUCCEEDED(hr)) {
                        //
                        //  Initialization successful.  Note that we 
                        //  don't AddRef here since if the caller was
                        //  a driver, IWiaItems are BYTE* pWiasContexts
                        //  and not COM objects.  Caller must AddRef
                        //  if handing the created to an Application.
                        //

                        //
                        //  Fill in ICM Profile information, if not root item.
                        //  This would normally go in InitManagedItemProperties,
                        //  but the item had not been added to the tree by that
                        //  time...
                        //

                        if (pRoot != pChild) {
                            hr = FillICMPropertyFromRegistry(NULL, (IWiaItem*) pChild);
                        }
                    }
                }
            }
        }

        if (FAILED(hr)) {
            delete pChild;
            pChild = NULL;
        }
    } else {
        DBG_ERR(("wiasCreateChildAppItem, Out of Memory!"));
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr)) {
        *ppWiasChildContext = (BYTE*)pChild;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiaevent.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       DevMgr.Cpp
*
*  VERSION:     2.0
*
*  DATE:        26 Dec, 1997
*
*  DESCRIPTION:
*   Class implementation for WIA device manager.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include "wiamindr.h"
#include "wiamdef.h"

#include "wiacfact.h"
#include "devmgr.h"
#include "devinfo.h"
#include "tchar.h"
#include "helpers.h"
#include "ienumdc.h"
#include "shlwapi.h"
#include "device.h"
#include "wiapriv.h"
#include "lockmgr.h"
#ifdef  UNICODE
#include "userenv.h"
#endif
#define INITGUID
#include "initguid.h"
#include "wiaevntp.h"

//
// Critical section protecting event node list defined in wiamain.cpp
//

extern CRITICAL_SECTION     g_semEventNode;


//
// Since there is only Event Notifier needed, it is staticly allocated
//

CEventNotifier              g_eventNotifier;


//
// Private look up function defined in STIDEV.CPP
//

HRESULT
WiaGetDeviceInfo(
    LPCWSTR                 pwszDeviceName,
    DWORD                  *pdwDeviceType,
    BSTR                   *pbstrDeviceDescription,
    ACTIVE_DEVICE         **ppDevice);

//
//  Helper function to look for action events
//

BOOL ActionGuidExists(
    BSTR        bstrDevId,
    const GUID        *pEventGUID);

//
// Special handler's class ID {D13E3F25-1688-45A0-9743-759EB35CDF9A}
//

DEFINE_GUID(
    CLSID_DefHandler,
    0xD13E3F25, 0x1688, 0x45A0,
    0x97, 0x43, 0x75, 0x9E, 0xB3, 0x5C, 0xDF, 0x9A);


#ifdef UNICODE
void
PrepareCommandline(
    BSTR                    bstrDeviceID,
    const GUID             &guidEvent,
    LPCWSTR                 pwszOrigCmdline,
    LPWSTR                  pwszCommandline);
#else
void
PrepareCommandline(
    BSTR                    bstrDeviceID,
    const GUID             &guidEvent,
    LPCSTR                  pwszOrigCmdline,
    LPSTR                   pwszCommandline);
#endif


/**************************************************************************\
* EventThreadProc
*
*   Thread is created to send events back to client. !!! may want to
*   create a permanent thread to do this instead of creating a new one
*   each time
*
* Arguments:
*
*   lpParameter - pointer to PWIAEventThreadInfo data
*
* Return Value:
*
*    Status
*
* History:
*
*    11/19/1998 Original Version
*
\**************************************************************************/

DWORD WINAPI
EventThreadProc(
    LPVOID                  lpParameter)
{
    DBG_FN(::EventThreadProc);
    HRESULT                  hr;

    PWIAEventThreadInfo     pInfo = (PWIAEventThreadInfo)lpParameter;

    DBG_TRC(("Thread callback 0x%lx", pInfo->pIEventCB));

    hr = CoInitializeEx(0, COINIT_MULTITHREADED);

    if (FAILED(hr)) {

        DBG_ERR(("Thread callback, ImageEventCallback failed (0x%X)", hr));
    }

    hr = pInfo->pIEventCB->ImageEventCallback(
                               &pInfo->eventGUID,
                               pInfo->bstrEventDescription,
                               pInfo->bstrDeviceID,
                               pInfo->bstrDeviceDescription,
                               pInfo->dwDeviceType,
                               pInfo->bstrFullItemName,
                               &pInfo->ulEventType,
                               pInfo->ulReserved);

    pInfo->pIEventCB->Release();

    if (FAILED(hr)) {
        DBG_ERR(("Thread callback, ImageEventCallback failed (0x%X)", hr));
    }

    if (pInfo->bstrDeviceID) {
        ::SysFreeString(pInfo->bstrDeviceID);
    }

    if (pInfo->bstrEventDescription) {
        ::SysFreeString(pInfo->bstrEventDescription);
    }

    if (pInfo->bstrDeviceDescription) {
        ::SysFreeString(pInfo->bstrDeviceDescription);
    }

    if (pInfo->bstrFullItemName) {
        ::SysFreeString(pInfo->bstrFullItemName);
    }

    LocalFree(pInfo);

    CoUninitialize();

    return 0;
}

/***************************************************************************
*
* CEventNotifier
* ~CEventNotifier
*
*   Class constructor/destructors
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

CEventNotifier::CEventNotifier()
{
    m_ulRef = 0;
    m_pEventDestNodes = NULL;
}

CEventNotifier::~CEventNotifier()
{
    // Clean up
}

/**************************************************************************\
* CEventNotifier::UnlinkNode
*
*   remove node from double linkeed list
*
* Arguments:
*
*   pCurNode - node to remove
*
* Return Value:
*
*   Status
*
* History:
*
*    5/20/1999 Original Version
*
\**************************************************************************/

VOID
CEventNotifier::UnlinkNode(
    PEventDestNode          pCurNode)
{
    DBG_FN(CEventNotifier::UnlinkNode);
    //
    // Unlink the current node
    //

    if (pCurNode->pPrev) {
        pCurNode->pPrev->pNext = pCurNode->pNext;
    } else {

        //
        // The head of the list is deleted
        //

        m_pEventDestNodes = pCurNode->pNext;
    }

    if (pCurNode->pNext) {
        pCurNode->pNext->pPrev = pCurNode->pPrev;
    }
}


/**************************************************************************\
*
* CEventNotifier::LinkNode
*
*   add the node to the double linked list of nodes
*
* Arguments:
*
*    pCurNode - node to add to list
*
* Return Value:
*
*    Status
*
* History:
*
*    5/20/1999 Original Version
*
\**************************************************************************/

VOID
CEventNotifier::LinkNode(
    PEventDestNode          pCurNode)
{
    DBG_FN(CEventNotifier::LinkNode);
    //
    // Put the new node at the head of the list
    //

    if (m_pEventDestNodes) {
        m_pEventDestNodes->pPrev = pCurNode;
    }

    pCurNode->pNext   = m_pEventDestNodes;
    pCurNode->pPrev   = NULL;
    m_pEventDestNodes = pCurNode;
}


/**************************************************************************\
*
* CEventNotifier::FireEventAsync
*
*   Fires a Async event
*
* Arguments:
*
*    pMasterInfo - Thread information
*
* Return Value:
*
*    Status
*
* History:
*
*    8/9/1999 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::FireEventAsync(
    PWIAEventThreadInfo     pMasterInfo)
{
    DBG_FN(CEventNotifier::FireEventAsync);
    HRESULT                 hr = E_OUTOFMEMORY;
    PWIAEventThreadInfo     pInfo = NULL;
    DWORD                   dwThreadID;
    HANDLE                  hThread;

    do {

        pInfo = (PWIAEventThreadInfo)
                    LocalAlloc(LPTR, sizeof(WIAEventThreadInfo));
        if (! pInfo) {
            break;
        }

        //
        // Copy information from the master thread info block
        //

        pInfo->eventGUID             = pMasterInfo->eventGUID;

        pInfo->bstrDeviceID          =
            SysAllocString(pMasterInfo->bstrDeviceID);
        if (! pInfo->bstrDeviceID) {
            break;
        }

        pInfo->bstrEventDescription  =
            SysAllocString(pMasterInfo->bstrEventDescription);
        if (! pInfo->bstrEventDescription) {
            break;
        }

        if (pMasterInfo->bstrDeviceDescription) {

            pInfo->bstrDeviceDescription =
                SysAllocString(pMasterInfo->bstrDeviceDescription);
            if (! pInfo->bstrDeviceDescription) {
                break;
            }
        }

        if (pMasterInfo->bstrFullItemName) {

            pInfo->bstrFullItemName =
                SysAllocString(pMasterInfo->bstrFullItemName);
            if (! pInfo->bstrFullItemName) {
                break;
            }
        }

        pInfo->dwDeviceType          = pMasterInfo->dwDeviceType;
        pInfo->ulEventType           = pMasterInfo->ulEventType;
        pInfo->ulReserved            = pMasterInfo->ulReserved;

        pMasterInfo->pIEventCB->AddRef();
        hr = S_OK;

        pInfo->pIEventCB             = pMasterInfo->pIEventCB;

        //
        // Fire the event callback
        //

        hThread = CreateThread(
                      NULL, 0, EventThreadProc, pInfo, 0, &dwThreadID);
        if (hThread) {

            //
            // Close the handler, so that kernel mode thread object is
            // closed when the thread finishes its mission
            //

            CloseHandle(hThread);

        } else {

            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        //
        // Don't wait for completion
        //

    } while (FALSE);

    //
    // The notification should free the allocated resources
    //

    if (hr == S_OK) {

        return (hr);
    }

    if (hr == E_OUTOFMEMORY) {

        DBG_ERR(("FireEventAsync : Memory alloc failed"));
    }

    //
    // Garbage collection to avoid memory leak
    //

    if (pInfo) {

        if (pInfo->bstrDeviceDescription) {
            SysFreeString(pInfo->bstrDeviceDescription);
        }
        if (pInfo->bstrDeviceID) {
            SysFreeString(pInfo->bstrDeviceID);
        }
        if (pInfo->bstrEventDescription) {
            SysFreeString(pInfo->bstrEventDescription);
        }
        if (pInfo->bstrFullItemName) {
            SysFreeString(pInfo->bstrFullItemName);
        }
        if (pInfo->pIEventCB) {
            pInfo->pIEventCB->Release();
        }

        LocalFree(pInfo);
    }

    return (hr);
}

/**************************************************************************\
* CEventNotifier::NotifySTIEvent
*
*   Search through list of registered events and notify anyone who
*   matched current event
*
* Arguments:
*
*   pWiaNotify  -   Event infor
*
* Return Value:
*
*   Status
*
* History:
*
*   5/18/1999 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::NotifySTIEvent(
    PWIANOTIFY              pWiaNotify,
    ULONG                   ulEventType,
    BSTR                    bstrFullItemName)
{
    DBG_FN(CEventNotifier::NotifySTIEvent);

    HRESULT                 hr = S_FALSE;
    EventDestNode          *pCurNode;
    BOOL                    bDeviceLocked;
    DWORD                   dwDeviceType;
    BSTR                    bstrDevDescription = NULL;
    IWiaMiniDrv            *pIWiaMiniDrv = NULL;
    WIA_DEV_CAP_DRV        *pWiaDrvDevCap = NULL;
    BSTR                    bstrEventDescription = NULL;
    LONG                    lNumEntries = 0;
    LONG                    i = 0;
    LONG                    lDevErrVal;
    WIAEventThreadInfo      masterInfo;
    ULONG                   ulNumHandlers;
    EventDestNode          *pDefHandlerNode;
    IWiaEventCallback      *pIEventCB;
    ACTIVE_DEVICE          *pDevice = NULL;
    ULONG                  *pulTemp;



    do {

        ZeroMemory(&masterInfo, sizeof(masterInfo));

        //
        // Get device information from STI active device list
        //

        hr = WiaGetDeviceInfo(
                 pWiaNotify->bstrDevId,
                 &dwDeviceType,
                 &bstrDevDescription,
                 &pDevice);
        if (hr != S_OK) {
            DBG_ERR(("Failed to get WiaGetDeviceInfo from NotifySTIEvent, 0x%X", hr));
            break;
        }

        //
        //  Make sure we only grab global event Critical Section AFTER we've released the
        //  device list Critical Section (used and released in WiaGetDeviceInfo).
        //
        CWiaCritSect            CritSect(&g_semEventNode);

        //
        // QI for the WIA mini driver interface
        //

        hr = pDevice->m_DrvWrapper.QueryInterface(
                      IID_IWiaMiniDrv, (void **)&pIWiaMiniDrv);
        if (FAILED(hr)) {
            DBG_WRN(("Failed to QI for IWiaMini from NotifySTIEvent (0x%X)", hr));
        }

        //
        // Hardware might be gone, access to it should not be allowed
        //

        bDeviceLocked = FALSE;

        if (SUCCEEDED(hr)) {
            __try {

                __try {

                    //
                    // Notify the mini driver of the new event.
                    // NOTE: We don't lock here.  The event must be delivered
                    //       to the driver regardless.  A queued system would
                    //       be better, but it MUST guarantee delivery.
                    //

                    hr = pDevice->m_DrvWrapper.WIA_drvNotifyPnpEvent(
                                           &pWiaNotify->stiNotify.guidNotificationCode,
                                           pWiaNotify->bstrDevId,
                                           0);
                    if (FAILED(hr)) {
                        __leave;
                    }

                    //
                    //  This is a "work-around" for our in-box HP scanner driver, which
                    //  calls down to the microdriver even after it has been informed
                    //  via drvNotifyPnPEvent that the device no longer exists...
                    //  Only if this is not a disconnect event, do we want to 
                    //  call driver
                    //
                    if (pWiaNotify->stiNotify.guidNotificationCode != WIA_EVENT_DEVICE_DISCONNECTED) {

                        //
                        // Lock the device since the drvInitializeWia may have not been
                        // called and the IWiaMiniDrv can not lock the device
                        //
                        // NOTE:  Timeout is 20sec
                        //
                        // NOTE:  We don't lock serial devices here...
                        // , this function on a connection should be as fast as possible
                        //
    
                        if (!( pDevice->m_DrvWrapper.getHWConfig() & STI_HW_CONFIG_SERIAL) ||
                            !IsEqualGUID(pWiaNotify->stiNotify.guidNotificationCode,WIA_EVENT_DEVICE_CONNECTED)
                            ) {
    
                            hr = g_pStiLockMgr->RequestLock(pDevice, 20000);
                            if (FAILED(hr)) {
                                __leave;
                            }
                            bDeviceLocked = TRUE;
                        }
    
                        //
                        // Note that a NULL context passed to the minidriver.  This should be OK since
                        // capabilities are not tied to any item context.
                        //
    
                        hr = pDevice->m_DrvWrapper.WIA_drvGetCapabilities(
                                               NULL,
                                               WIA_DEVICE_EVENTS,
                                               &lNumEntries,
                                               &pWiaDrvDevCap,
                                               &lDevErrVal);
                    }
                }
                __finally {

                    //
                    // Unlock the device first
                    //

                    if (bDeviceLocked) {
                        g_pStiLockMgr->RequestUnlock(pDevice);
                        bDeviceLocked = FALSE;
                    }
                }

            }
            __except(EXCEPTION_EXECUTE_HANDLER) {

                DBG_ERR(("NotifySTIEvent() : Exception happened in the drvGetCapabilities"));

                SysFreeString(bstrDevDescription);

                if (pIWiaMiniDrv) {
                    pIWiaMiniDrv->Release();
                }
                return (E_FAIL);
            }
        }

        //
        // Mini driver failed the operation
        //

        if (SUCCEEDED(hr)) {

            if (pWiaDrvDevCap) {

                __try {
                    //
                    // Retrieve event related information
                    //

                    for (i = 0; i < lNumEntries; i++) {

                        if (pWiaDrvDevCap[i].guid != NULL) {
                            if (*pWiaDrvDevCap[i].guid == pWiaNotify->stiNotify.guidNotificationCode) {

                                if (! ulEventType) {
                                    ulEventType      = pWiaDrvDevCap[i].ulFlags;
                                }
                                bstrEventDescription = SysAllocString(pWiaDrvDevCap[i].wszDescription);
                                break;
                            }
                        } else {
                            DBG_WRN(("NotifySTIEvent() : Driver's event guid is NULL, index = %d", i));
                        }
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER) {
                    DBG_ERR(("NotifySTIEvent() : Exception occurred while accessing driver's event array"));
                    hr = E_FAIL;
                }

                //
                // The device is not supposed to generate this event
                //

                if ((i == lNumEntries) || (!bstrEventDescription)) {
                    DBG_ERR(("NotifySTIEvent() : Event description is NULL or Event GUID not found"));
                    hr = E_FAIL;
                }
            }
            else {
                // Minidriver is wrong, claiming success and returning NULL
                DBG_ERR(("NotifySTIEvent() got NULL cap list from drivers .") );
                hr = E_FAIL;
            }
        }

        //
        //  If the event is a connect or diconnect event, always fire it.
        //

        if (FAILED(hr) &&
            ((pWiaNotify->stiNotify.guidNotificationCode == WIA_EVENT_DEVICE_CONNECTED) ||
             (pWiaNotify->stiNotify.guidNotificationCode == WIA_EVENT_DEVICE_DISCONNECTED))) {

            DBG_WRN(("NotifySTIEvent() : hr indicates FAILURE, but event is Connect/Disconnect"));

            //
            //  Set the event type and string
            //

            if (! ulEventType) {
                ulEventType = WIA_NOTIFICATION_EVENT;
            }
            if (pWiaNotify->stiNotify.guidNotificationCode == WIA_EVENT_DEVICE_CONNECTED) {

                bstrEventDescription = SysAllocString(WIA_EVENT_DEVICE_CONNECTED_STR);
            } else {
                bstrEventDescription = SysAllocString(WIA_EVENT_DEVICE_DISCONNECTED_STR);
            }

        }

        //
        // Prepare the master thread info block
        //

        masterInfo.eventGUID             = pWiaNotify->stiNotify.guidNotificationCode;
        masterInfo.bstrEventDescription  = bstrEventDescription;
        masterInfo.bstrDeviceID          = pWiaNotify->bstrDevId;
        masterInfo.bstrDeviceDescription = bstrDevDescription;
        masterInfo.dwDeviceType          = dwDeviceType;

        //
        // Retrieve the full item name set by the driver
        //

        masterInfo.bstrFullItemName      = bstrFullItemName;

        masterInfo.ulEventType           = ulEventType;
        masterInfo.ulReserved            = 0;
        masterInfo.pIEventCB             = NULL;

        //
        // For Notification type of event
        //

        if (ulEventType & WIA_NOTIFICATION_EVENT) {

            for (pCurNode = m_pEventDestNodes;
                 pCurNode; pCurNode = pCurNode->pNext) {

                 if (! pCurNode->pIEventCB) {
                     continue;
                 }

                 if (
                      (
                         (wcscmp(pWiaNotify->bstrDevId, pCurNode->bstrDeviceID) == 0) ||
                         (wcscmp(L"All",                pCurNode->bstrDeviceID) == 0)
                      ) &&

                      (pWiaNotify->stiNotify.guidNotificationCode == pCurNode->iidEventGUID)
                    ) {

                    masterInfo.pIEventCB = pCurNode->pIEventCB;

                    DBG_WRN(("NotifySTIEvent() : About to FireEventAsync(...)"));
                    FireEventAsync(&masterInfo);
                 }
            }
        }

        //
        // For Action type of event, find the default handler and fire it
        //


        if (ulEventType & WIA_ACTION_EVENT) {

#ifndef UNICODE

            //
            // Get whether there is an user logged in
            //

            HWND            hWin;

            hWin = FindWindow("Progman", NULL);
            if (! hWin) {
                break;
            }
#endif

            GetNumPersistentHandlerAndDefault(
                pWiaNotify->bstrDevId,
                &pWiaNotify->stiNotify.guidNotificationCode,
                &ulNumHandlers,
                &pDefHandlerNode);

            if (pDefHandlerNode) {

                if (pDefHandlerNode->tszCommandline[0] != '\0') {

                    //
                    // This is a traditional handler with command line
                    //

                    StartCallbackProgram(
                        pDefHandlerNode, &masterInfo);

                } else {

                    hr = _CoCreateInstanceInConsoleSession(
                             pDefHandlerNode->ClsID,
                             NULL,
                             CLSCTX_LOCAL_SERVER,
                             IID_IWiaEventCallback,
                             (void**)&pIEventCB);

                    if (SUCCEEDED(hr)) {

                        masterInfo.pIEventCB = pIEventCB;

                        FireEventAsync(&masterInfo);

                        //
                        // Release the callback interface
                        //

                        pIEventCB->Release();

                    } else {
                        DBG_ERR(("NotifySTIEvent:CoCreateInstance of event callback failed (0x%X)", hr));
                    }
                }
            }
        }

    } while (FALSE);

    //
    // Release the temporary BSTRs
    //

    if (bstrDevDescription) {
        SysFreeString(bstrDevDescription);
    }
    if (bstrEventDescription) {
        SysFreeString(bstrEventDescription);
    }
    if (masterInfo.bstrFullItemName) {
        SysFreeString(masterInfo.bstrFullItemName);
    }

    if (pDevice) {
        pDevice->Release();
        pDevice = NULL;
    }
    if (pIWiaMiniDrv) {
        pIWiaMiniDrv->Release();
        pIWiaMiniDrv = NULL;
    }

    return (hr);
}

/**************************************************************************\
* CEventNotifier::RegisterEventCallback
*
*   Register for event callbacks based on an interface
*
* Arguments:
*
*   lFlags              - op flags, register/unregister
*   bstrDeviceID        - device ID registering for
*   pEventGUID          - Event GUID to register for
*   pIWiaEventCallback  - interface to call with event
*   ppEventObj          -
*
* Return Value:
*
*   Status
*
* History:
*
*   11/19/1998 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::RegisterEventCallback(
    LONG                    lFlags,
    BSTR                    bstrDeviceID,
    const GUID             *pEventGUID,
    IWiaEventCallback      *pIWiaEventCallback,
    IUnknown              **ppEventObj)
{
    DBG_FN(CEventNotifier::RegisterEventCallback);
    HRESULT                 hr = E_FAIL;
    PEventDestNode          pEventNode = NULL;

    DBG_TRC(("CEventNotifier::RegisterEventCallback flag %d", lFlags));

    ASSERT(pIWiaEventCallback != NULL);
    ASSERT(ppEventObj != NULL);
    ASSERT(pEventGUID != NULL);

    //
    // must have exclusive access when changing list
    //

    CWiaCritSect     CritSect(&g_semEventNode);

    //
    // if bstrDeviceID is not NULL, make sure it is a device ID
    //

    if (bstrDeviceID) {
/*  No longer valid
#ifdef WINNT

        if (wcslen(bstrDeviceID) != 43) { // {...}\DDDD

#else

        if (wcslen(bstrDeviceID) != 10) { // Image\DDDD

#endif

            DBG_ERR(("CEventNotifier::RegisterEventCallback: invalid DeviceID"));
            return (E_INVALIDARG);
        }
*/
    }

    //
    // Check whether the same CB interface is already registered
    //

    pEventNode = FindEventCBNode(FLAG_EN_FINDCB_EXACT_MATCH,bstrDeviceID, pEventGUID, pIWiaEventCallback);

    if (! pEventNode) {
        hr = RegisterEventCB(
                 bstrDeviceID,
                 pEventGUID,
                 pIWiaEventCallback,
                 ppEventObj);
    }

    return (hr);
}

/**************************************************************************\
* CEventNotifier::RegisterEventCallback
*
*   Register event based on CLSID
*
* Arguments:
*
*   lFlags              - op flags, register/unregister, set default
*   bstrDeviceID        - device ID registering for
*   pEventGUID          - Event GUID to register for
*   pClsid              - CLSID to call CoCreateInst on with event
*   bstrDescription     -
*   bstrIcon            -
*
* Return Value:
*
*    Status
*
* History:
*
*    12/8/1998 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::RegisterEventCallback(
    LONG                    lFlags,
    BSTR                    bstrDeviceID,
    const GUID             *pEventGUID,
    const GUID             *pClsid,
    LPCTSTR                 ptszCommandline,
    BSTR                    bstrName,
    BSTR                    bstrDescription,
    BSTR                    bstrIcon)
{

    DBG_FN(CEventNotifier::RegisterEventCallback (CLSID));

    HRESULT                 hr = S_OK;
    SYSTEMTIME              sysTime;
    FILETIME                fileTime;
    PEventDestNode          pEventNode = NULL;
    CLSID                   clsidApp;
    RPC_STATUS              rpcStatus;
    BOOL                    bUnRegCOMServer;
    BOOL                    bShowPrompt = FALSE;
    ULONG                   ulNumExistingHandlers = 0;
    EventDestNode           ednTempNode;


    DBG_TRC(("CEventNotifier::RegisterEventCallback flag %d", lFlags));

    ASSERT(pEventGUID != NULL);

    //DBG_WRN(("RegisterEventCallback: CommandLine=%s"),ptszCommandline);


    //
    // Must have exclusive access when changing list
    //

    CWiaCritSect            CritSect(&g_semEventNode);

    //
    // If there is a device ID, check if id looks proper.
    //

    if (bstrDeviceID) {

        //
        // An empty device ID is the same as NULL
        //

        if (wcslen(bstrDeviceID) == 0) {
            bstrDeviceID = NULL;
        } else {

/*  No longer valid
#ifdef WINNT

            if (wcslen(bstrDeviceID) != 43) { // {...}\DDDD

#else

            if (wcslen(bstrDeviceID) != 10) { // Image\DDDD

#endif

                DBG_ERR(("RegisterEventCallback : invalid DeviceID"));
                return (E_INVALIDARG);

            }
*/
        }
    }

    //
    // Default handler is per device / per event
    //

    if ((lFlags == WIA_SET_DEFAULT_HANDLER) && (! bstrDeviceID)) {

        DBG_ERR(("RegisterEventCallback : DeviceID required to set default handler"));

        return (E_INVALIDARG);
    }

    //
    // Check whether a callback node with the same commandline already exist
    //

    if (ptszCommandline) {

        //
        // Do parameter check.  Note that we look for >= MAX_PATH because
        // we still need space for terminating NULL.
        //
        if ((lstrlen(ptszCommandline) / sizeof(TCHAR)) >= MAX_PATH) {
            DBG_ERR(("RegisterEventCallback: ptszCommandline is greater than MAX_PATH characters!"));
            return E_INVALIDARG;
        }

        hr = FindCLSIDForCommandline(ptszCommandline, &clsidApp);
        if (FAILED(hr)) {

            //
            // Generate a CLSID for the callbacl program
            //

            rpcStatus = UuidCreate(&clsidApp);
            if (FAILED(rpcStatus)) {
                return (rpcStatus);
            }

        }

        //
        // Assign the faked CLSID for the callback program
        //

        pClsid  = &clsidApp;
    }

    ASSERT(pClsid != NULL);

    switch (lFlags) {

    case WIA_REGISTER_EVENT_CALLBACK :
        DBG_WRN(("RegisterEventCallback : Setting handler for %S", (bstrDeviceID) ? (bstrDeviceID) : L"*"));
        //
        //  REMOVE:  This is not actually an error, but we will use error logging to gurantee
        //  it always get written to the log.    This should be removed as soon as we know what
        //  causes #347835.
        //
        DBG_ERR(("RegisterEventCallback : Setting handler for %S", (bstrDeviceID) ? (bstrDeviceID) : L"*"));
        DBG_ERR(("RegisterEventCallback : Handler is %S", (bstrName) ? (bstrName) : L"NULL"));

        //
        // Name, description, and icon are required
        //

        if ((! bstrName) || (! bstrDescription) || (! bstrIcon)) {

            DBG_ERR(("RegisterEventCallback : Name | Description | Icon are missing"));
            return (E_INVALIDARG);
        }

        //
        // Check whether the same CB interface is already registered
        //

        pEventNode = FindEventCBNode(0,bstrDeviceID, pEventGUID, pClsid);
        if (pEventNode) {
            break;
        }

        //
        // Find the handler of the CLSID for all the devices
        //

        pEventNode = FindEventCBNode(0,NULL, pEventGUID, pClsid);

        //
        // Initialize the time stamp for the registration
        //

        //GetSystemTime(&sysTime);
        //SystemTimeToFileTime(&sysTime, &fileTime);
        memset(&fileTime, 0, sizeof(fileTime));

        if (! pEventNode) {

            hr = RegisterEventCB(
                     bstrDeviceID,
                     pEventGUID,
                     pClsid,
                     ptszCommandline,
                     bstrName,
                     bstrDescription,
                     bstrIcon,
                     fileTime);
            if (FAILED(hr)) {
                break;
            }

            hr = SavePersistentEventCB(
                     bstrDeviceID,
                     pEventGUID,
                     pClsid,
                     ptszCommandline,
                     bstrName,
                     bstrDescription,
                     bstrIcon,
                     NULL,
                     &ulNumExistingHandlers);
        } else {

            hr = RegisterEventCB(
                     bstrDeviceID,
                     pEventGUID,
                     pClsid,
                     pEventNode->tszCommandline,
                     pEventNode->bstrName,
                     pEventNode->bstrDescription,
                     pEventNode->bstrIcon,
                     fileTime);
            if (FAILED(hr)) {
                break;
            }

            hr = SavePersistentEventCB(
                     bstrDeviceID,
                     pEventGUID,
                     pClsid,
                     pEventNode->tszCommandline,
                     pEventNode->bstrName,
                     pEventNode->bstrDescription,
                     pEventNode->bstrIcon,
                     NULL,
                     &ulNumExistingHandlers);
        }

        //
        //  If this is the only event handler, make it the default.  This will guarantee that
        //  there is always a default handler.
        //

        if (ulNumExistingHandlers == 0) {
            RegisterEventCallback(WIA_SET_DEFAULT_HANDLER,
                                  bstrDeviceID,
                                  pEventGUID,
                                  pClsid,
                                  ptszCommandline,
                                  bstrName,
                                  bstrDescription,
                                  bstrIcon);
        };


        //
        //  Check whether this is a registration for a global handler.
        //
        if (!bstrDeviceID) {

            //
            //  This is a global event handler, so find out how many global handlers
            //  there are for this event.  If there is more than one, make sure
            //  the prompt is Registered.
            //
            PEventDestNode  pTempEventNode     = NULL;
            BSTR            bstrGlobalDeviceID = SysAllocString(L"All");

            if (bstrGlobalDeviceID) {
                GetNumPersistentHandlerAndDefault(bstrGlobalDeviceID,
                                                  pEventGUID,
                                                  &ulNumExistingHandlers,
                                                  &pTempEventNode);
                if (ulNumExistingHandlers > 1) {

                    //
                    //  If the number of global handlers is > 1, then we must register the prompt.
                    //

                    DBG_WRN(("RegisterEventCallback : Registering Prompt Dialog as global handler"));

                    BSTR bstrInternalString = SysAllocString(L"Internal");
                    if (bstrInternalString) {
                        RegisterEventCallback(WIA_REGISTER_EVENT_CALLBACK,
                                              bstrDeviceID,
                                              pEventGUID,
                                              &WIA_EVENT_HANDLER_PROMPT,
                                              NULL,
                                              bstrInternalString,
                                              bstrInternalString,
                                              bstrInternalString);
                        SysFreeString(bstrInternalString);
                    } else {
                        DBG_ERR(("RegisterEventCallback : Out of memory!"));
                    }
                }

                SysFreeString(bstrGlobalDeviceID);
                bstrGlobalDeviceID = NULL;
            }
        }

        break;

    case WIA_SET_DEFAULT_HANDLER :
        DBG_WRN(("RegisterEventCallback : Setting default handler for for %S", (bstrDeviceID) ? (bstrDeviceID) : L"*"));
        //
        //  REMOVE:  This is not actually an error, but we will use error logging to gurantee
        //  it always get written to the log.    This should be removed as soon as we know what
        //  causes #347835.
        //
        DBG_ERR(("RegisterEventCallback : Setting handler for %S", (bstrDeviceID) ? (bstrDeviceID) : L"*"));
        DBG_ERR(("RegisterEventCallback : Handler is %S", (bstrName) ? (bstrName) : L"NULL"));

        //
        // Find the handler of the CLSID for this devices. Note that STI proxy event match is considered here
        // to allow for STI handlers to be default.
        //
        //

        DBG_WRN(("RegisterEventCallback:SDH CommandLine=%S \n",ptszCommandline));

        #ifdef DEBUG
        WCHAR                   wszGUIDStr[40];

        StringFromGUID2(*pEventGUID, wszGUIDStr, 40);

        DBG_WRN(("SetDefaultHandler: DevId=%S EventUID=%S Commandline=%S",
                (bstrDeviceID) ? (bstrDeviceID) : L"*",
                wszGUIDStr,
                ptszCommandline));
        #endif

        {
            //
            // Find the existing default handler node, and clear the flag indicating it is
            // the default, since it will now be replaced by a new default
            //

            ULONG           ulNumHandlers   = 0;
            PEventDestNode  pDefaultNode    = NULL;
            hr = GetNumPersistentHandlerAndDefault(bstrDeviceID,
                                                   pEventGUID,
                                                   &ulNumHandlers,
                                                   &pDefaultNode);
            if (SUCCEEDED(hr) && pDefaultNode) {

                //
                // Clear the flag indicating that it is the default handler, since the
                // current node will now replace it as the default.
                //

               pDefaultNode->bDeviceDefault = FALSE;
            }
        }

        pEventNode = FindEventCBNode(0,bstrDeviceID, pEventGUID, pClsid);
        if (! pEventNode) {

            //
            // Find the handler of the CLSID for all the devices
            //

            pEventNode = FindEventCBNode(0,NULL, pEventGUID, pClsid);
            if (! pEventNode) {

                //
                //  We couldn't find an existing node for this handler, so fill in
                //  information to the temporary event node so we can register this
                //  new one anyway.
                //
                memset(&ednTempNode, 0, sizeof(ednTempNode));

                if (ptszCommandline) {
                    lstrcpy(ednTempNode.tszCommandline, ptszCommandline);
                }
                ednTempNode.bstrName = bstrName;
                ednTempNode.bstrDescription = bstrDescription;
                ednTempNode.bstrIcon = bstrIcon;

                pEventNode = &ednTempNode;
            }

            //
            // Register the handler of the CLSID for this device
            //

            GetSystemTime(&sysTime);
            SystemTimeToFileTime(&sysTime, &fileTime);

            DBG_WRN(("SetDefaultHandler:Found event node  EvName=%S CommandLine=%S",
                    pEventNode->bstrName,
                    pEventNode->tszCommandline));

            hr = RegisterEventCB(
                     bstrDeviceID,
                     pEventGUID,
                     pClsid,
                     pEventNode->tszCommandline,
                     pEventNode->bstrName,
                     pEventNode->bstrDescription,
                     pEventNode->bstrIcon,
                     fileTime,
                     TRUE);
            if (FAILED(hr)) {
                DBG_WRN(("RegisterEventCallback : RegisterEventCB for %S failed", (bstrDeviceID) ? (bstrDeviceID) : L"*"));
                break;
            }
        } else {

            //
            // Change the time stamp so that it is regarded as default
            //

            GetSystemTime(&sysTime);
            SystemTimeToFileTime(&sysTime, &pEventNode->timeStamp);

            //
            // NOTE:  Timestamps not valid on Win9x, so use a flag to indicate default handler.
            // Change this node's flag to indicate this is the default
            //

            pEventNode->bDeviceDefault = TRUE;

            DBG_WRN(("RegisterEventCallback : Resetting default handler for %S", (bstrDeviceID) ? (bstrDeviceID) : L"*"));
        }

        //
        // Save the persistent event callback node.  Note that we specify TRUE as the last
        // parameter to indicate that the default handler is now this node.  This will
        // cause a registry entry to be written that indicates this as the default handler.
        //

        hr = SavePersistentEventCB(
                 bstrDeviceID,
                 pEventGUID,
                 pClsid,
                 pEventNode->tszCommandline,
                 pEventNode->bstrName,
                 pEventNode->bstrDescription,
                 pEventNode->bstrIcon,
                 &bShowPrompt,
                 &ulNumExistingHandlers,
                 TRUE);

        if (FAILED(hr)) {
            DBG_ERR(("SetDefaultHandler:SavePers CommandLine=%S failed!!!!",pEventNode->tszCommandline));
        }

        break;

    case WIA_UNREGISTER_EVENT_CALLBACK :

        hr = UnregisterEventCB(
                 bstrDeviceID, pEventGUID, pClsid, &bUnRegCOMServer);
        if (FAILED(hr)) {
            DBG_ERR(("CEventNotifier::RegisterEventCallback, UnregisterEventCB failed"));
            break;
        }

        hr = DelPersistentEventCB(
                 bstrDeviceID, pEventGUID, pClsid, bUnRegCOMServer);
        if (FAILED(hr)) {
            DBG_ERR(("CEventNotifier::RegisterEventCallback, DelPersistentEventCB failed"));
        }

        break;

    default:

        hr = E_FAIL;
        break;
    }

    if (bShowPrompt && (*pClsid != WIA_EVENT_HANDLER_PROMPT)) {

        //
        //  This is a new event handler being registered.  Our semantics are as follows:
        //  The new application may not simply override any existing handlers.  Therefore,
        //  if a default handler already exists for this device, we must show a prompt.
        //

        if (ulNumExistingHandlers > 0) {

            //
            // This is a new default event registration, so
            // we must show Prompt dialog
            //

            DBG_WRN(("RegisterEventCallback : About to Register Prompt Dialog for device %S", (bstrDeviceID) ? (bstrDeviceID) : L"*"));

            BSTR bstrInternalString = SysAllocString(L"Internal");
            if (bstrInternalString) {
                RegisterEventCallback(WIA_SET_DEFAULT_HANDLER,
                                      bstrDeviceID,
                                      pEventGUID,
                                      &WIA_EVENT_HANDLER_PROMPT,
                                      NULL,
                                      bstrInternalString,
                                      bstrInternalString,
                                      bstrInternalString);
                SysFreeString(bstrInternalString);
            }

            DBG_WRN(("RegisterEventCallback : Registered Prompt Dialog for device %S", (bstrDeviceID) ? (bstrDeviceID) : L"*"));
        }
    }

    return (hr);
}

/**************************************************************************\
* CEventNotifier::RegisterEventCB
*
*   add event notify to list
*
* Arguments:
*
*   bstrDeviceID        - device event is being registered to monitor
*   pEventGUID          - guid that defines device event of interest
*   pIWiaEventCallback  - app's event interface
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::RegisterEventCB(
    BSTR                    bstrDeviceID,
    const GUID             *pEventGUID,
    IWiaEventCallback      *pIWiaEventCallback,
    IUnknown              **ppIEventObj)
{
    DBG_FN(CEventNotifier::RegisterEventCB);
    HRESULT                 hr;
    PEventDestNode          pEventDestNode = NULL;

    ASSERT(pIWiaEventCallback != NULL);
    ASSERT(pEventGUID != NULL);

    if (!pEventGUID || !pIWiaEventCallback) {
        return E_POINTER;
    }

    //
    // Allocate and initialize the new node
    //

    pEventDestNode = (EventDestNode *)LocalAlloc(LPTR, sizeof(EventDestNode));

    if (! pEventDestNode) {
        DBG_ERR(("RegisterEventCB: Out of memory"));
        return (E_OUTOFMEMORY);
    }


    // Initialize default flag
    pEventDestNode->bDeviceDefault = FALSE;

    //
    // is a device name given? If not then match all devices
    //

    if (bstrDeviceID == NULL) {
        pEventDestNode->bstrDeviceID = SysAllocString(L"All");
    } else {
        pEventDestNode->bstrDeviceID = SysAllocString(bstrDeviceID);
    }

    //
    // check allocs
    //

    if (pEventDestNode->bstrDeviceID == NULL) {
        LocalFree(pEventDestNode);
        DBG_ERR(("RegisterEventCB: Out of memory"));
        return (E_OUTOFMEMORY);
    }

    //
    // create an object to track the lifetime of this event
    //

    CWiaInterfaceEvent *pEventObj = new CWiaInterfaceEvent(pEventDestNode);

    if (pEventObj == NULL) {
        DBG_ERR(("RegisterEventCB: Out of memory"));
        SysFreeString(pEventDestNode->bstrDeviceID);
        LocalFree(pEventDestNode);
        return (E_OUTOFMEMORY);
    }

    //
    // get simple iunknown from object
    //

    hr = pEventObj->QueryInterface(IID_IUnknown,(void **)ppIEventObj);

    if (FAILED(hr)) {
        DBG_ERR(("RegisterEventCB: QI of pEventObj failed"));

        delete pEventObj;
        SysFreeString(pEventDestNode->bstrDeviceID);
        LocalFree(pEventDestNode);
        return (hr);
    }

    //
    // add info to event list
    //

    pEventDestNode->iidEventGUID = *pEventGUID;

    pIWiaEventCallback->AddRef();
    pEventDestNode->pIEventCB = pIWiaEventCallback;
    memset(&pEventDestNode->ClsID, 0, sizeof(pEventDestNode->ClsID));

    //
    // Put the new node at the head of the list
    //

    LinkNode(pEventDestNode);

    return (S_OK);
}

/**************************************************************************\
* RegisterEventCB
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    12/8/1998 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::RegisterEventCB(
    BSTR                    bstrDeviceID,
    const GUID             *pEventGUID,
    const GUID             *pClsID,
    LPCTSTR                 ptszCommandline,
    BSTR                    bstrName,
    BSTR                    bstrDescription,
    BSTR                    bstrIcon,
    FILETIME               &timeStamp,
    BOOL                    bIsDeafult)  // = FALSE
{
    DBG_FN(CEventNotifier::RegisterEventCB);
    HRESULT                 hr = E_OUTOFMEMORY;
    EventDestNode          *pEventDestNode = NULL;

    ASSERT(pClsID != NULL);
    ASSERT(pEventGUID != NULL);


    if (!pEventGUID || !pClsID) {
        return E_POINTER;
    }

    do {

        //
        // Do parameter check.  Note that we look for >= MAX_PATH because
        // we still need space for terminating NULL.
        //
        if ((lstrlen(ptszCommandline) / sizeof(TCHAR)) >= MAX_PATH) {
            DBG_ERR(("CEventNotifier::RegisterEventCB: ptszCommandline is greater than MAX_PATH characters!"));
            hr = E_INVALIDARG;
            break;
        }

        //
        // Allocate and initialize the new node
        //

        pEventDestNode = (EventDestNode *)LocalAlloc(LPTR, sizeof(EventDestNode));

        if (! pEventDestNode) {
            DBG_ERR(("CEventNotifier::RegisterEventCB: Out of memory"));
            break;
        }

        //
        // Is a device name given ? If not then match all devices
        //

        if (bstrDeviceID == NULL) {
            pEventDestNode->bstrDeviceID = SysAllocString(L"All");
        } else {
            pEventDestNode->bstrDeviceID = SysAllocString(bstrDeviceID);
        }

        //
        // Check callback node allocation
        //

        if (pEventDestNode->bstrDeviceID == NULL) {
            DBG_ERR(("CEventNotifier::RegisterEventCB: Out of memory"));
            break;
        }

        //
        // Add info to event callback node
        //

        pEventDestNode->iidEventGUID    = *pEventGUID;
        pEventDestNode->pIEventCB       = NULL;
        pEventDestNode->ClsID           = *pClsID;

        pEventDestNode->bstrName        = SysAllocString(bstrName);
        if (! pEventDestNode->bstrName) {
            break;
        }

        pEventDestNode->bstrDescription = SysAllocString(bstrDescription);
        if (! pEventDestNode->bstrDescription) {
            break;
        }

        pEventDestNode->bstrIcon        = SysAllocString(bstrIcon);
        if (! pEventDestNode->bstrIcon) {
            break;
        }

        //
        // Copy the commandline of the callback app
        //

        if ((ptszCommandline) && (ptszCommandline[0])) {
            _tcscpy(pEventDestNode->tszCommandline, ptszCommandline);
        } else {
            pEventDestNode->tszCommandline[0] = '\0';
        }

        //
        // Set the time stamp of registration
        //

        pEventDestNode->timeStamp       = timeStamp;

        //
        // Set whether this is the default event handler
        //

        if (bIsDeafult) {
            pEventDestNode->bDeviceDefault = TRUE;
        }

        hr = S_OK;
    } while (FALSE);

    //
    // Unwind the partial created node in case of failure
    //

    if (hr != S_OK) {

        if (pEventDestNode) {

            if (pEventDestNode->bstrDeviceID) {
                SysFreeString(pEventDestNode->bstrDeviceID);
            }
            if (pEventDestNode->bstrName) {
                SysFreeString(pEventDestNode->bstrName);
            }
            if (pEventDestNode->bstrDescription) {
                SysFreeString(pEventDestNode->bstrDescription);
            }
            if (pEventDestNode->bstrIcon) {
                SysFreeString(pEventDestNode->bstrIcon);
            }

            LocalFree(pEventDestNode);
        }

        return (hr);
    }

    //
    // Put the new node at the header of the list
    //

    LinkNode(pEventDestNode);

    return (S_OK);
}


/**************************************************************************\
* CEventNotifier::UnregisterEventCB
*
*   Unregister the specified Event Callback
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::UnregisterEventCB(
    PEventDestNode          pCurNode)
{
    DBG_FN(CEventNotifier::UnregisterEventCB);

    ASSERT(pCurNode != NULL);

    if (!pCurNode) {
        return E_POINTER;
    }

    UnlinkNode(pCurNode);

    //
    // Free the node
    //

    if (pCurNode->bstrDeviceID) {
        SysFreeString(pCurNode->bstrDeviceID);
    }

    if (pCurNode->bstrDescription) {
        SysFreeString(pCurNode->bstrDescription);
    }

    if (pCurNode->bstrIcon) {
        SysFreeString(pCurNode->bstrIcon);
    }

    pCurNode->pIEventCB->Release();

    LocalFree(pCurNode);

    return (S_OK);
}

/**************************************************************************\
* CEventNotifier::UnregisterEventCB
*
*   Unregister the specified Event Callback
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::UnregisterEventCB(
    BSTR                    bstrDeviceID,
    const GUID             *pEventGUID,
    const GUID             *pClsID,
    BOOL                   *pbUnRegCOMServer)
{
    DBG_FN(CEventNotifier::UnregisterEventCB);
    HRESULT              hr = E_INVALIDARG;
    EventDestNode       *pCurNode, *pNextNode;
    int                  nHandlerRef;

    //
    // Clear out the return value
    //

    *pbUnRegCOMServer = FALSE;

    //
    // Delete the handler(s) from the list
    //

    pCurNode = m_pEventDestNodes;

    while (pCurNode) {

        if ((bstrDeviceID) &&
            (lstrcmpiW(pCurNode->bstrDeviceID, bstrDeviceID))) {

            pCurNode = pCurNode->pNext;
            continue;
        }

        if ((*pEventGUID != pCurNode->iidEventGUID) ||
            (*pClsID != pCurNode->ClsID)) {

            pCurNode = pCurNode->pNext;
            continue;
        }

        //
        // Unlink the current node if it is not busy
        //

        pNextNode = pCurNode->pNext;
        UnlinkNode(pCurNode);

        //
        // Need to consider deleteing the faked server
        //

        if (pCurNode->tszCommandline[0] != '\0') {
            *pbUnRegCOMServer = TRUE;
        }

        //
        // Free the node
        //

        if (pCurNode->bstrDeviceID) {
            SysFreeString(pCurNode->bstrDeviceID);
        }

        if (pCurNode->bstrDescription) {
            SysFreeString(pCurNode->bstrDescription);
        }

        if (pCurNode->bstrIcon) {
            SysFreeString(pCurNode->bstrIcon);
        }

        LocalFree(pCurNode);

        hr = S_OK;

        //
        // Delete the event handler for specific device
        //

        if (bstrDeviceID) {
            break;
        }

        //
        // Move on to the next node
        //

        pCurNode = pNextNode;
    }

    //
    // The faked COM server should not be removed if it is still in use
    //

    if (*pbUnRegCOMServer) {

        nHandlerRef = 0;

        for (pCurNode = m_pEventDestNodes;
             pCurNode;
             pCurNode = pCurNode->pNext) {

            //
            // Ignode the callback interface pointers
            //

            if (*pClsID == pCurNode->ClsID) {
                nHandlerRef++;
            }
        }

        if (nHandlerRef) {
            *pbUnRegCOMServer = FALSE;
        } else {
            *pbUnRegCOMServer = TRUE;
        }
    }

    //
    // Indicate that the IWiaEventCallback is not found.
    //

    return (hr);
}

/**************************************************************************\
* CEventNotifier::FindEventCBNode
*
*   Check whether the specified Event Callback is already registered
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\**************************************************************************/

PEventDestNode
CEventNotifier::FindEventCBNode(
    UINT                    uiFlags,
    BSTR                    bstrDeviceID,
    const GUID             *pEventGUID,
    IWiaEventCallback      *pIWiaEventCallback)
{
    DBG_FN(CEventNotifier::FindEventCBNode);
    HRESULT                 hr;
    EventDestNode          *pCurNode;
    IUnknown               *pICurUnk, *pINewUnk;

    //
    // Retrieve the IUnknown of the new Event Callback
    //

    hr = pIWiaEventCallback->QueryInterface(IID_IUnknown, (void **)&pINewUnk);
    if (FAILED(hr)) {
        DBG_ERR(("CEventNotifier::IsDupEventCB, QI for IID_IUnknown failed"));
        return (NULL);
    }

    for (pCurNode = m_pEventDestNodes; pCurNode; pCurNode = pCurNode->pNext) {

        if (wcscmp(
                pCurNode->bstrDeviceID,
                bstrDeviceID ? bstrDeviceID : L"All") != 0) {
            continue;
        }

        if (pCurNode->iidEventGUID != *pEventGUID) {

            //
            // If we are instructed to allow STI proxy event matches - check node GUID against STI event proxy GUID
            // If exact match is required - continue without checking
            //
            if ( (uiFlags & FLAG_EN_FINDCB_EXACT_MATCH ) ||
                 (pCurNode->iidEventGUID != WIA_EVENT_STI_PROXY)) {
                 continue;
            }
        }

        if (pCurNode->pIEventCB) {

            hr = pCurNode->pIEventCB->QueryInterface(
                                          IID_IUnknown, (void **)&pICurUnk);
            if (FAILED(hr)) {
                pINewUnk->Release();
                return (NULL);
            }

            //
            // COM can only guarantee that IUnknowns are the same
            //

            if (pICurUnk == pINewUnk) {

                pICurUnk->Release();
                pINewUnk->Release();

                return (pCurNode);
            } else {

                pICurUnk->Release();
            }
        }
    }

    pINewUnk->Release();

    return (NULL);
}


/**************************************************************************\
* CEventNotifier::FindEventCBNode
*
*   Check whether the specified Event Callback is already registered
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\**************************************************************************/

PEventDestNode
CEventNotifier::FindEventCBNode(
    UINT                    uiFlags,
    BSTR                    bstrDeviceID,
    const GUID             *pEventGUID,
    const GUID             *pClsID)
{
    DBG_FN(CEventNotifier::FindEventCBNode);
    PEventDestNode          pCurNode;

    for (pCurNode = m_pEventDestNodes; pCurNode; pCurNode = pCurNode->pNext) {

        if (wcscmp(
                pCurNode->bstrDeviceID,
                bstrDeviceID ? bstrDeviceID : L"All") != 0) {
            continue;
        }

        if (pCurNode->iidEventGUID != *pEventGUID) {
            //
            // If we are instructed to allow STI proxy event matches - check node GUID against STI event proxy GUID
            // If exact match is required - continue without checking
            //
            if ( (uiFlags & FLAG_EN_FINDCB_EXACT_MATCH ) ||
                 (pCurNode->iidEventGUID != WIA_EVENT_STI_PROXY))  {
                 continue;
            }
        }

        if ((! pCurNode->pIEventCB) && (pCurNode->ClsID == *pClsID)) {
            return (pCurNode);
        }
    }

    return (NULL);
}


/**************************************************************************\
* CEventNotifier::FindCLSIDForCommandline
*
*   Find the CLSID for the specified commandline
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::FindCLSIDForCommandline(
    LPCTSTR                 ptszCommandline,
    CLSID                  *pClsID)
{
    DBG_FN(CEventNotifier::FindCLSIDForCommandline);
    PEventDestNode          pCurNode;

    for (pCurNode = m_pEventDestNodes; pCurNode; pCurNode = pCurNode->pNext) {

        if ((pCurNode->tszCommandline[0] != '\0') &&
            (_tcsicmp(pCurNode->tszCommandline, ptszCommandline) == 0)) {

            *pClsID = pCurNode->ClsID;
            return (S_OK);
        }
    }

    return (E_FAIL);
}


/**************************************************************************\
* CEventNotifier::RestoreAllPersistentCBs
*
*   Restore all the persistent Event Callbacks
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    12/1/1998 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::RestoreAllPersistentCBs()
{
    DBG_FN(CEventNotifier::RestoreAllPresistentCBs);
    HKEY                    hStillImage = NULL;
    HKEY                    hMSCDevList = NULL;
    DWORD                   dwIndex;
    HRESULT                 hr      = S_OK;
    DWORD                   dwError = 0;

    //
    // Restore device specific handlers
    //
    g_pDevMan->ForEachDeviceInList(DEV_MAN_OP_DEV_RESTORE_EVENT, 0);

    CWiaCritSect            CritSect(&g_semEventNode);

    //
    // Restore device events for MSC Cameras under Control\StillImage\MSCDevList
    //
    dwError = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            REGSTR_PATH_WIA_MSCDEVICES_W,
                            0,
                            KEY_READ,
                            &hMSCDevList);
    if (dwError == ERROR_SUCCESS) {

        for (dwIndex = 0; ;dwIndex++) {

            WCHAR       wszDeviceName[STI_MAX_INTERNAL_NAME_LENGTH];
            FILETIME    fileTime;
            HKEY        hKeyDev     = NULL;
            DWORD       dwSize      = sizeof(wszDeviceName) / sizeof(wszDeviceName[0]);

            dwError = RegEnumKeyExW(hMSCDevList,
                                    dwIndex,
                                    wszDeviceName,
                                    &dwSize,
                                    0,
                                    NULL,
                                    0,
                                    &fileTime);
            if (dwError != ERROR_SUCCESS) {
                //
                // No more keys to enumerate
                //
                break;
            }
            wszDeviceName[STI_MAX_INTERNAL_NAME_LENGTH - 1] = L'\0';

            //
            // Open the device key
            //

            dwError = RegOpenKeyExW(hMSCDevList,
                                    wszDeviceName,
                                    0,
                                    KEY_READ,
                                    &hKeyDev);
            if (dwError != ERROR_SUCCESS) {
                //
                // Skip this key
                //
                continue;
            }

            //
            // Restore the event hanlders for this device
            //
            RestoreDevPersistentCBs(hKeyDev);
            RegCloseKey(hKeyDev);
        }
        RegCloseKey(hMSCDevList);
        hMSCDevList = NULL;
    }

    //
    // Restore the global event callback under the Control\StillImage
    //

    dwError = RegOpenKeyEx(
               HKEY_LOCAL_MACHINE,
               REG_PATH_STILL_IMAGE_CONTROL,
               0,
               KEY_READ,
               &hStillImage);

    if (dwError != ERROR_SUCCESS) {

        //
        // The registry entry for the STI is corrupted
        //

        DBG_ERR(("CEventNotifier::RestoreAllPersistentCBs : Can not open STI control key."));
        hr = (HRESULT_FROM_WIN32(dwError));

    } else {

        RestoreDevPersistentCBs(hStillImage);

        //
        // Close the STI control key (Control\StillImage)
        //

        RegCloseKey(hStillImage);
    }

    return S_OK;
}

/**************************************************************************\
* CEventNotifier::RestoreAllPersistentCBs
*
*  Restore specific devices' persistent Event Callbacks
*
* Arguments:
*
*   hParentOfEventKey   - This is either the device key or the still
*                         image key.  Either way, the key must have a
*                         "Events" subkey.
*
* Return Value:
*
*    Status
*
* History:
*
*    12/1/1998 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::RestoreDevPersistentCBs(
    HKEY                    hParentOfEventKey)
{
    DBG_FN(CEventNotifier::RestoreDevPresistantCBs);
#ifdef UNICODE
    WCHAR                   tszBuf[MAX_PATH];
#else
    CHAR                    tszBuf[MAX_PATH];
#endif
    LPTSTR                  ptszEvents = tszBuf;
    LONG                    lRet;
    HKEY                    hEvents;
    DWORD                   dwIndex;
    LPTSTR                  ptszEventName = tszBuf;
    DWORD                   dwEventNameLen;
    FILETIME                fileTime;
    HKEY                    hEvent;
    HKEY                    hCBCLSID;
    DWORD                   dwValueType;
    LPTSTR                  ptszGUIDStr = tszBuf;
    GUID                    eventGUID;
    GUID                    guidDefaultDevHandler;
    BOOL                    bIsDefault = FALSE;
    DWORD                   dwCLSIDIndex;
    DWORD                   dwGUIDStrLen;
    LPTSTR                  ptszCBCLSIDStr = tszBuf;
    CLSID                   callbackCLSID;
    TCHAR                   tszDeviceID[STI_MAX_INTERNAL_NAME_LENGTH];
#ifdef UNICODE
    LPWSTR                  pwszGUIDStr = tszBuf;
    LPWSTR                  pwszCBCLSIDStr = tszBuf;
#else
    WCHAR                   wszBuf[MAX_PATH];
    LPWSTR                  pwszGUIDStr = wszBuf;
    LPWSTR                  pwszCBCLSIDStr = wszBuf;
#endif
    DWORD                   dwValueLen;
    BSTR                    bstrName, bstrDescription;
    SYSTEMTIME              sysTime;
    TCHAR                   tszCommandline[MAX_PATH];
    DWORD                   dwType = REG_SZ;
    DWORD                   dwSize = sizeof(tszDeviceID);
    DWORD                   dwError = 0;
    HRESULT                 hr = E_FAIL;
    BSTR                    bstrDeviceID = NULL;

    lstrcpy(ptszEvents, EVENTS);

    //
    // Attempt to read the DeviceID
    //

    dwError = RegQueryValueEx(hParentOfEventKey,
                              REGSTR_VAL_DEVICE_ID,
                              NULL,
                              &dwType,
                              (LPBYTE)&tszDeviceID,
                              &dwSize);
    if (dwError == ERROR_SUCCESS) {
        bstrDeviceID = SysAllocString(T2W(tszDeviceID));
        if (!bstrDeviceID) {
            DBG_ERR(("CEventNotifier::RestoreDevPersistentCBs, Out of memory!"));
            return E_OUTOFMEMORY;
        }
    } else {
        bstrDeviceID = NULL;
    }


    //
    // Open the Events subkey
    //

    lRet = RegOpenKeyEx(
               hParentOfEventKey,
               ptszEvents,
               0,
               KEY_READ,
               &hEvents);
    if (lRet != ERROR_SUCCESS) {
        return (HRESULT_FROM_WIN32(lRet)); // Events may not exist
    }

    //
    // Enumerate all the events under the "Events" subkey
    //

    for (dwIndex = 0; ;dwIndex++) {

        dwEventNameLen = sizeof(tszBuf)/sizeof(TCHAR);
        lRet = RegEnumKeyEx(
                   hEvents,
                   dwIndex,
                   ptszEventName,
                   &dwEventNameLen,
                   NULL,
                   NULL,
                   NULL,
                   &fileTime);

        if (lRet != ERROR_SUCCESS) {
            break;
        }

        //
        // Open the event subkey
        //

        lRet = RegOpenKeyEx(
                   hEvents,
                   ptszEventName,
                   0,
                   KEY_READ,
                   &hEvent);
        if (lRet != ERROR_SUCCESS) {
            continue;
        }

        //
        // Get GUID of the default handler (if present), and save it in
        // guidDefaultDevHandler
        //
        dwValueLen = sizeof(tszBuf);
        lRet = RegQueryValueEx(
                   hEvent,
                   DEFAULT_HANDLER_VAL,
                   NULL,
                   &dwValueType,
                   (LPBYTE)ptszGUIDStr,
                   &dwValueLen);
        if ((lRet == ERROR_SUCCESS) && (dwValueType == REG_SZ)) {

            WCHAR   wszDefGUIDStr[MAX_PATH];
#ifndef UNICODE
            MultiByteToWideChar(CP_ACP,
                                0,
                                ptszGUIDStr,
                                -1,
                                wszDefGUIDStr,
                                sizeof(wszDefGUIDStr) / sizeof(WCHAR));
            pwszGUIDStr[38] = 0;
#else
            lstrcpyW(wszDefGUIDStr, ptszGUIDStr);
#endif

            if (SUCCEEDED(CLSIDFromString(wszDefGUIDStr, &guidDefaultDevHandler))) {
               DBG_TRC(("CEventNotifier::RestoreDevPersistentCBs, Default guid: %S",
                       ptszGUIDStr));
            }

        } else {
            //
            // We zero out guidDefaultDevHandler to make sure we don't accidentaly hit
            // a match later...
            //
            ::ZeroMemory(&guidDefaultDevHandler,sizeof(guidDefaultDevHandler));
        }

        //
        // Retrieve the GUID of the event
        //

        dwGUIDStrLen = 39*sizeof(TCHAR);  // GUID string is 38 characters long
        lRet = RegQueryValueEx(
                   hEvent,
                   TEXT("GUID"),
                   NULL,
                   &dwValueType,
                   (LPBYTE)ptszGUIDStr,
                   &dwGUIDStrLen);
        if ((lRet != ERROR_SUCCESS) || (dwValueType != REG_SZ)) {

            //
            // Junk event found, skip to the next
            //

            DBG_TRC(("CEventNotifier::RestoreDevPersistentCBs, Junk event %S found", ptszEventName));
            continue;
        }
#ifndef UNICODE
        mbstowcs(pwszGUIDStr, ptszGUIDStr, 38);
        pwszGUIDStr[38] = 0;
#endif
        if (FAILED(CLSIDFromString(pwszGUIDStr, &eventGUID))) {

            //
            // Invalid event GUID found, skip to the next
            //

            DBG_TRC(("CEventNotifier::RestoreDevPersistentCBs, invalid event GUID %S found", ptszGUIDStr));
            continue;
        }

        //
        // Enumerate all the event handler CLSIDs under this event
        //

        for (dwCLSIDIndex = 0; ;dwCLSIDIndex++) {

            dwGUIDStrLen = 39;  // CLSID string is 38 character long.

            lRet = RegEnumKeyEx(
                       hEvent,
                       dwCLSIDIndex,
                       ptszCBCLSIDStr,
                       &dwGUIDStrLen,
                       NULL,
                       NULL,     // All the other information is not interesting
                       NULL,
                       &fileTime);
            if (lRet != ERROR_SUCCESS) {
                break;   // End enumeration
            }

#ifndef UNICODE
            mbstowcs(pwszCBCLSIDStr, ptszCBCLSIDStr, 38);
            pwszCBCLSIDStr[38] = 0;
#endif

            //
            // Convert CLSID and register this callback
            //

            if (SUCCEEDED(CLSIDFromString(pwszCBCLSIDStr, &callbackCLSID))) {

                hCBCLSID        = NULL;
                bstrName        = NULL;
                bstrDescription = NULL;

                do {

                    //
                    // Open the event handler CLSID subkey
                    //

                    lRet = RegOpenKeyEx(
                               hEvent,
                               ptszCBCLSIDStr,
                               0,
                               KEY_QUERY_VALUE,
                               &hCBCLSID);
                    if (lRet != ERROR_SUCCESS) {

                        DBG_ERR(("CEventNotifier::RestoreDevPersistentCBs, RegOpenKeyEx() for CLSID failed."));
                        break;
                    }

                    //
                    // Retrieve the name, description and icon
                    //

                    dwValueLen = sizeof(tszBuf);
                    lRet = RegQueryValueEx(
                               hCBCLSID,
                               NAME_VAL,
                               NULL,
                               &dwValueType,
                               (LPBYTE)tszBuf,
                               &dwValueLen);
                    if ((lRet != ERROR_SUCCESS) || (dwValueType != REG_SZ)) {

                        DBG_ERR(("CEventNotifier::RestoreDevPersistentCBs, RegQueryValueEx() for Name failed."));
                        break;
                    }
#ifndef UNICODE
                    MultiByteToWideChar(CP_ACP,
                                        0,
                                        tszBuf,
                                        -1,
                                        wszBuf,
                                        MAX_PATH);
                    bstrName = SysAllocString(wszBuf);
#else
                    bstrName = SysAllocString(tszBuf);
#endif
                    if (! bstrName) {
                        break;
                    }

                    dwValueLen = sizeof(tszBuf);
                    lRet = RegQueryValueEx(
                               hCBCLSID,
                               DESC_VAL,
                               NULL,
                               &dwValueType,
                               (LPBYTE)tszBuf,
                               &dwValueLen);
                    if ((lRet != ERROR_SUCCESS) || (dwValueType != REG_SZ)) {

                        DBG_ERR(("CEventNotifier::RestoreDevPersistentCBs, RegQueryValueEx() for Desc failed."));
                        break;
                    }
#ifndef UNICODE
                    MultiByteToWideChar(CP_ACP,
                                        0,
                                        tszBuf,
                                        -1,
                                        wszBuf,
                                        MAX_PATH);
                    bstrDescription = SysAllocString(wszBuf);
#else
                    bstrDescription = SysAllocString(tszBuf);
#endif
                    if (! bstrDescription) {
                        break;
                    }

                    dwValueLen = sizeof(tszBuf);
                    lRet = RegQueryValueEx(
                               hCBCLSID,
                               ICON_VAL,
                               NULL,
                               &dwValueType,
                               (LPBYTE)tszBuf,
                               &dwValueLen);
                    if ((lRet != ERROR_SUCCESS) || (dwValueType != REG_SZ)) {

                        DBG_ERR(("CEventNotifier::RestoreDevPersistentCBs, RegQueryValueEx() for Desc failed."));
                        break;
                    }
#ifndef UNICODE
                    MultiByteToWideChar(CP_ACP,
                                        0,
                                        tszBuf,
                                        -1,
                                        wszBuf,
                                        MAX_PATH);
#endif

                    //
                    // Retrieve the command line, it may not exist
                    //

                    dwValueLen = sizeof(tszCommandline);
                    lRet = RegQueryValueEx(
                               hCBCLSID,
                               CMDLINE_VAL,
                               NULL,
                               &dwValueType,
                               (LPBYTE)tszCommandline,
                               &dwValueLen);
                    if ((lRet != ERROR_SUCCESS) || (dwValueType != REG_SZ)) {

                        //
                        // Initialize the commandline to null
                        //

                        tszCommandline[0] = '\0';
                    }

#ifdef DEBUG
                    FileTimeToSystemTime(&fileTime, &sysTime);
#endif
                    //
                    // Register the callback without the persistent flag
                    //

                    //
                    // Check whether this is the default...
                    //

                    if (callbackCLSID == guidDefaultDevHandler) {
                        bIsDefault = TRUE;
                    } else {
                        bIsDefault = FALSE;
                    }

                    //DBG_WRN(("=> Restoring CBs for Device %S, Program named %S",
                    //              bstrDeviceID ? bstrDeviceID : L"NULL",
                    //              bstrName));
                    DBG_TRC(("CEventNotifier::RestoreDevPersistentCBs, Restoring CBs for Device %S, Program named %S",
                                        bstrDeviceID ? bstrDeviceID : L"NULL",
                                        bstrName));

#ifdef UNICODE

                    if (FAILED(RegisterEventCB(
                                   bstrDeviceID,
                                   &eventGUID,
                                   &callbackCLSID,
                                   tszCommandline,
                                   bstrName,
                                   bstrDescription,
                                   tszBuf,
                                   fileTime,
                                   bIsDefault))) {
                        DBG_ERR(("CEventNotifier::RestoreDevPersistentCBs, RegisterEventCB() failed."));
                    }
#else
                    if (FAILED(RegisterEventCB(
                                   bstrDeviceID,
                                   &eventGUID,
                                   &callbackCLSID,
                                   tszCommandline,
                                   bstrName,
                                   bstrDescription,
                                   wszBuf,
                                   fileTime,
                                   bIsDefault))) {
                        DBG_ERR(("CEventNotifier::RestoreDevPersistentCBs, RegisterEventCB() failed."));
                    }
#endif

                } while (FALSE);

                //
                // Close the subkey for the event handler CLSID
                //

                if (hCBCLSID) {
                    RegCloseKey(hCBCLSID);
                }

                if (bstrName) {
                    SysFreeString(bstrName);
                }

                if (bstrDescription) {
                    SysFreeString(bstrDescription);
                }
            }

        }

        //
        // Close the key for the specific event
        //

        RegCloseKey(hEvent);
    }

    //
    // Close the event subkey
    //

    RegCloseKey(hEvents);

    //
    // Free the deviceID, if one was allocated
    //

    if (bstrDeviceID) {
        SysFreeString(bstrDeviceID);
        bstrDeviceID = NULL;
    }

    return (S_OK);
}

/**************************************************************************\
* CEventNotifier::SavePersistentEventCB
*
*  Save the persistent Event Callbacks CLSID for the Device ID / Event GUID
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    12/1/1998 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::SavePersistentEventCB(
    BSTR                    bstrDeviceID,
    const GUID             *pEventGUID,
    const GUID             *pClsid,
    LPCTSTR                 ptszCommandline,
    BSTR                    bstrName,
    BSTR                    bstrDescription,
    BSTR                    bstrIcon,
    BOOL                   *pbCreatedKey,
    ULONG                  *pulNumExistingHandlers,
    BOOL                    bMakeDefault        // = FALSE
    )
{

    DBG_FN(CEventNotifier::SavePresistentEventCB);
    HRESULT                 hr;
    HKEY                    hEvent, hCBCLSID;
    LONG                    lRet;
    DWORD                   dwDisposition;
    WCHAR                   wszCBClsIDStr[40];
#ifndef UNICODE
    CHAR                    szCBClsIDStr[40];
    CHAR                    szString[MAX_PATH];
#endif
    HKEY                    hClsid;
    HKEY                    hCOMServerCLSID;
    HKEY                    hLocalServer;

    //
    // Initialize the resources to NULL
    //

    hEvent          = NULL;
    hCBCLSID        = NULL;
    hClsid          = NULL;
    hCOMServerCLSID = NULL;
    hLocalServer    = NULL;

    if (pbCreatedKey) {
        *pbCreatedKey = FALSE;
    }

    do {

        //
        //
        // Find the event subkey
        //

        hr = FindEventByGUID(bstrDeviceID, pEventGUID, &hEvent);
        if (hr != S_OK) {
            LPOLESTR    wstrGuid = NULL;
            HRESULT     hres;

            hres = StringFromCLSID(*pEventGUID,
                                   &wstrGuid);
            if (hres == S_OK) {
                DBG_ERR(("CEventNotifier::SavePersistentEventCB() FindEventByGUID() failed, GUID=%S, hr=0x%08X", wstrGuid, hr));
                CoTaskMemFree(wstrGuid);
            } else {
                DBG_ERR(("CEventNotifier::SavePersistentEventCB() FindEventByGUID() failed, hr=0x%08X", hr));
            }
            break;
        }

        //
        // If asked, let's find out how many handlers already exist for this event
        //

        if (pulNumExistingHandlers) {
            *pulNumExistingHandlers = 0;

            lRet = RegQueryInfoKey(hEvent,
                                   NULL,
                                   NULL,
                                   NULL,
                                   pulNumExistingHandlers,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL);
        }

        //
        // Convert the Event Callback CLSID as a string value
        //

        StringFromGUID2(*pClsid, wszCBClsIDStr, 40);
#ifndef UNICODE

        //
        // Convert the CLSID to ANSI string (including terminating NULL)
        //

        WideCharToMultiByte(CP_ACP,
                            0,
                            wszCBClsIDStr,
                            -1,
                            szCBClsIDStr,
                            40,
                            NULL,
                            NULL);
#endif

        //
        // Open / Create the Event Handler CLSID subkey
        //

        lRet = RegCreateKeyEx(
                   hEvent,
#ifdef UNICODE
                   wszCBClsIDStr,
#else
                   szCBClsIDStr,
#endif
                   0,
                   NULL,            // Mysterious class string
                   REG_OPTION_NON_VOLATILE,
                   KEY_SET_VALUE,
                   NULL,            // Use default security descriptor
                   &hCBCLSID,
                   &dwDisposition);
        if (lRet != ERROR_SUCCESS) {

            DBG_ERR(("SavePersistentEventCB() RegCreateKeyEx() failed for CallbackCLSIDs subkey. lRet = %d", lRet));

            hr = HRESULT_FROM_WIN32(lRet);
            break;
        }

        if ((dwDisposition == REG_CREATED_NEW_KEY) && (pbCreatedKey)) {
            *pbCreatedKey = TRUE;
        }

        //
        // Set the event handler description value
        //

#ifndef UNICODE
        WideCharToMultiByte(CP_ACP,
                            0,
                            bstrName,
                            -1,
                            szString,
                            MAX_PATH,
                            NULL,
                            NULL);
#endif
        lRet = RegSetValueEx(
                   hCBCLSID,
                   NAME_VAL,
                   0,
                   REG_SZ,
#ifdef UNICODE
                   (const PBYTE)bstrName,
                   (wcslen(bstrName) + 1) << 1);
#else
                   (const PBYTE)szString,
                   strlen(szString) + 1);
#endif
        if (lRet != ERROR_SUCCESS) {

            DBG_ERR(("SavePersistentEventCB() RegSetValueEx() failed for name"));

            hr = HRESULT_FROM_WIN32(lRet);
            break;
        }

#ifndef UNICODE
        WideCharToMultiByte(CP_ACP,
                            0,
                            bstrDescription,
                            -1,
                            szString,
                            MAX_PATH,
                            NULL,
                            NULL);
#endif
        lRet = RegSetValueEx(
                   hCBCLSID,
                   DESC_VAL,
                   0,
                   REG_SZ,
#ifdef UNICODE
                   (const PBYTE)bstrDescription,
                   (wcslen(bstrDescription) + 1) << 1);
#else
                   (const PBYTE)szString,
                   strlen(szString) + 1);
#endif
        if (lRet != ERROR_SUCCESS) {

            DBG_ERR(("SavePersistentEventCB() RegSetValueEx() failed for description"));

            hr = HRESULT_FROM_WIN32(lRet);
            break;
        }

        //
        // Set the event handler icon value
        //

#ifndef UNICODE
        WideCharToMultiByte(CP_ACP,
                            0,
                            bstrIcon,
                            -1,
                            szString,
                            MAX_PATH,
                            NULL,
                            NULL);
#endif
        lRet = RegSetValueEx(
                   hCBCLSID,
                   ICON_VAL,
                   0,
                   REG_SZ,
#ifdef UNICODE
                   (const PBYTE)bstrIcon,
                   (wcslen(bstrIcon) + 1) << 1);
#else
                   (const PBYTE)szString,
                   strlen(szString) + 1);
#endif
        if (lRet != ERROR_SUCCESS) {

            DBG_ERR(("SavePersistentEventCB() RegSetValueEx() failed for icon"));

            hr = HRESULT_FROM_WIN32(lRet);
            break;
        }

        //
        // Set the command line and fake the program as COM local server
        //

        if ((ptszCommandline) && (ptszCommandline[0])) {

            lRet = RegSetValueEx(
                       hCBCLSID,
                       CMDLINE_VAL,
                       0,
                       REG_SZ,
                       (PBYTE)ptszCommandline,
                       (_tcslen(ptszCommandline) + 1)*sizeof(TCHAR));
            if (lRet != ERROR_SUCCESS) {

                DBG_ERR(("SavePersistentEventCB() RegSetValueEx() failed for cmdline"));

                hr = HRESULT_FROM_WIN32(lRet);
                break;
            }

            lRet = RegCreateKeyEx(
                HKEY_CLASSES_ROOT,
                TEXT("CLSID"),
                0,
                NULL,            // Mysterious class string
                REG_OPTION_NON_VOLATILE,
                KEY_SET_VALUE,
                NULL,            // Use default security descriptor
                &hClsid,
                &dwDisposition);
            if (lRet != ERROR_SUCCESS) {
                hr = HRESULT_FROM_WIN32(lRet);
                break;
            }

            lRet = RegCreateKeyEx(
                hClsid,
#ifdef UNICODE
                wszCBClsIDStr,
#else
                szCBClsIDStr,
#endif
                0,
                NULL,            // Mysterious class string
                REG_OPTION_NON_VOLATILE,
                KEY_SET_VALUE,
                NULL,            // Use default security descriptor
                &hCOMServerCLSID,
                &dwDisposition);
            if (lRet != ERROR_SUCCESS) {
                hr = HRESULT_FROM_WIN32(lRet);
                break;
            }

            lRet = RegCreateKeyEx(
                       hCOMServerCLSID,
                       TEXT("LocalServer32"),
                       0,
                       NULL,            // Mysterious class string
                       REG_OPTION_NON_VOLATILE,
                       KEY_SET_VALUE,
                       NULL,            // Use default security descriptor
                       &hLocalServer,
                       &dwDisposition);
            if (lRet != ERROR_SUCCESS) {
                hr = HRESULT_FROM_WIN32(lRet);
                break;
            }

            lRet = RegSetValueEx(
                       hLocalServer,
                       NULL,
                       0,
                       REG_SZ,
                       (PBYTE)ptszCommandline,
                       (_tcslen(ptszCommandline) + 1)*sizeof(TCHAR));
            hr = HRESULT_FROM_WIN32(lRet);
        }

        //
        // If asked - set as default handler for current device/event pair
        //
        if ( bMakeDefault ) {
            DBG_WRN(("CEventNotifier::SavePersistentEventCB,  Writing DEFAULT_HANDLER_VAL"));

            lRet = ::RegSetValueEx(
                       hEvent,
                       DEFAULT_HANDLER_VAL,
                       0,
                       REG_SZ,
#ifdef UNICODE
                       (PBYTE)wszCBClsIDStr,
                       (lstrlen(wszCBClsIDStr) + 1)*sizeof(TCHAR));
#else
                       (PBYTE)szCBClsIDStr,
                       (lstrlen(szCBClsIDStr) + 1)*sizeof(TCHAR));
#endif

#ifdef UNICODE
            DBG_TRC(("SavePersCB:: Setting default == %S lRet=%d",
                       wszCBClsIDStr, lRet));
#else
            DBG_TRC(("SavePersCB:: Setting default == %s lRet=%d",
                     szCBClsIDStr, lRet));
#endif
        } // endif bMakeDefault

    } while (FALSE);

    //
    // Close the registry keys
    //

    if (hCBCLSID) {
        RegCloseKey(hCBCLSID);
    }
    if (hCOMServerCLSID) {
        RegCloseKey(hCOMServerCLSID);
    }
    if (hLocalServer) {
        RegCloseKey(hLocalServer);
    }
    if (hEvent) {
        if (FAILED(hr)) {

            //
            // Unwind the whole thing
            //

#ifdef UNICODE
            RegDeleteKey(hEvent, wszCBClsIDStr);
#else
            RegDeleteKey(hEvent, szCBClsIDStr);
#endif
        }

        RegCloseKey(hEvent);
    }
    if (hClsid) {
        if (FAILED(hr)) {

            //
            // Unwind the whole thing
            //

#ifdef UNICODE
            RegDeleteKey(hEvent, wszCBClsIDStr);
#else
            RegDeleteKey(hEvent, szCBClsIDStr);
#endif
        }

        RegCloseKey(hClsid);
    }

    return (hr);
}

/**************************************************************************\
* CEventNotifier::DelPersistentEventCB(
*
*  Delete the persistent Event Callback CLSID for the Device ID / Event GUID
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    12/1/1998 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::DelPersistentEventCB(
    BSTR                    bstrDeviceID,
    const GUID             *pEventGUID,
    const GUID             *pClsid,
    BOOL                    bUnRegCOMServer)
{
    DBG_FN(CEventNotifier::DelPersistentEventCB);
    HRESULT                 hr;
    HKEY                    hStillImage, hEvent;
    TCHAR                   tcSubkeyName[8];
    DWORD                   dwIndex, dwSubkeyNameLen;
    LONG                    lRet;
    WCHAR                   wszCBClsIDStr[40];
#ifndef UNICODE
    CHAR                    szCBClsIDStr[40];
#endif
    WCHAR                   wszDeviceID[50];
    FILETIME                fileTime;
    HKEY                    hClsid;

    //
    // Find the event subkey
    //

    hr = FindEventByGUID(bstrDeviceID, pEventGUID, &hEvent);

    if (hr != S_OK) {
        DBG_ERR(("DelPersistentEventCB() FindEventByGUID() failed, hr=0x%08X", hr));
        return (hr);
    }

    StringFromGUID2(*pClsid, wszCBClsIDStr, 40);
#ifndef UNICODE

    //
    // Convert the CLSID to ANSI string (including terminating NULL)
    //

    WideCharToMultiByte(CP_ACP,
                        0,
                        wszCBClsIDStr,
                        -1,
                        szCBClsIDStr,
                        40,
                        NULL,
                        NULL);
#endif

    //
    // Delete the corresponding event handler CLSID key
    //

    lRet = RegDeleteKey(
               hEvent,
#ifdef UNICODE
               wszCBClsIDStr);
#else
               szCBClsIDStr);
#endif
    if ((lRet != ERROR_SUCCESS) && (lRet != ERROR_FILE_NOT_FOUND)) {
        DBG_ERR(("DelPersistentEventCB() RegDeleteValue() failed, lRet = 0x%08X", lRet));
    }

    //
    // Close the registry keys
    //

    RegCloseKey(hEvent);

    if (bstrDeviceID) {

        return (HRESULT_FROM_WIN32(lRet));
    }

    //
    // Delete the event handler clsid from under devices
    //

    lRet = RegOpenKeyEx(
               HKEY_LOCAL_MACHINE,
               REG_PATH_STILL_IMAGE_CLASS,
               0,
               KEY_READ,
               &hStillImage);

    if (lRet != ERROR_SUCCESS) {

        DBG_ERR(("DelPersistentEventCBs : Can not open Image device class key."));

        hr = (HRESULT_FROM_WIN32(lRet));

    } else {

        //
        // Enumerate all the subkey
        //

        for (dwIndex = 0; ;dwIndex++) {

            dwSubkeyNameLen = sizeof(tcSubkeyName)/sizeof(TCHAR);
            lRet = RegEnumKeyEx(
                       hStillImage,
                       dwIndex,
                       tcSubkeyName,
                       &dwSubkeyNameLen,
                       NULL,
                       NULL,
                       NULL,
                       &fileTime);

            if (lRet == ERROR_SUCCESS) {

                //
                // Make up the device ID
                //

#ifdef UNICODE
                *(DWORD *)wszDeviceID = (38 + 1 + 4) << 1;
                wcscpy(
                    wszDeviceID+2, L"{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}\\");
                wcscat(wszDeviceID+2, tcSubkeyName);
#else
                *(DWORD *)wszDeviceID = 10 << 1;
                wcscpy(
                    wszDeviceID+2, L"Image\\");
                mbstowcs(wszDeviceID+8, tcSubkeyName, 5);
#endif

                hr = FindEventByGUID(wszDeviceID+2, pEventGUID, &hEvent);

                //
                // This event key may not exist under specific device
                //

                if (hr != S_OK) {
                    continue;
                }

                //
                // Delete the corresponding event handler CLSID key
                //

                lRet = RegDeleteKey(
                           hEvent,
#ifdef UNICODE
                           wszCBClsIDStr);
#else
                           szCBClsIDStr);
#endif
                if ((lRet != ERROR_SUCCESS) && (lRet != ERROR_FILE_NOT_FOUND)) {
                    DBG_ERR(("DelPersistentEventCB() RegDeleteValue() failed, lRet = 0x%08X", lRet));
                }

                //
                // Close event key and device key
                //

                RegCloseKey(hEvent);
            } else {
                break;
            }
        }
    }

    //
    // Close the image class key
    //

    RegCloseKey(hStillImage);

    //
    // If the fake COM server should be unregistered
    //

    if (bUnRegCOMServer) {

        lRet = RegOpenKeyEx(
                    HKEY_CLASSES_ROOT,
                    TEXT("CLSID"),
                    0,
                    KEY_WRITE,
                    &hClsid);
        if (lRet != ERROR_SUCCESS) {

            //
            // Unable to recover data anyway
            //

            return (S_OK);
        }

#ifndef UNICODE
        lRet = RegDeleteKey(
                   hClsid,
                   szCBClsIDStr);
#else
        lRet = SHDeleteKey(
                   hClsid,
                   wszCBClsIDStr);
#endif
    }

    return (S_OK);
}

/**************************************************************************\
* CEventNotifier::FindEventByGUID(
*
*  Find the registry key for DeviceID / Event GUID pair
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    12/1/1998 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::FindEventByGUID(
    BSTR                    bstrDeviceID,
    const GUID             *pEventGUID,
    HKEY                   *phEventKey)
{
    DBG_FN(CEventNotifier::FindEventByGUID);
    TCHAR                   tszBuf[96];
    LPTSTR                  ptszEventName = tszBuf;
    LONG                    lRet;
    HKEY                    hEvents, hEvent;
    DWORD                   dwSubKeyIndex, dwEventNameLen;
    DWORD                   dwGUIDStrLen, dwValueType, dwDisp;
    FILETIME                fileTime;
    GUID                    eventGUID;
#ifdef UNICODE
    LPWSTR                  pwszGUIDStr = tszBuf;
#else
    WCHAR                   wszGUIDStr[39]; // {CLSID} + NULL
    LPWSTR                  pwszGUIDStr = wszGUIDStr;
#endif
    HRESULT                 hr = E_FAIL;

    //
    //
    //

    if (!pEventGUID) {
        DBG_WRN(("CEventNotifier::FindEventByGUID, Event pointer is NULL"));
        return E_INVALIDARG;
    }

    //
    // Initialize the return value
    //

    *phEventKey = NULL;

    //
    // Prepare the event path
    //

    if (bstrDeviceID) {

        //
        // Open the device's event sub-key
        //

        hEvents = g_pDevMan->GetDeviceHKey(bstrDeviceID,
                                           EVENTS);
        if (!IsValidHANDLE(hEvents)) {
            DBG_TRC(("CEventNotifier::FindEventByGUID() Couldn't open Events subkey, on device %S", bstrDeviceID));
            return hr;
        } else {
            DBG_TRC(("CEventNotifier::FindEventByGUID() Found Events key on device %S", bstrDeviceID));
            hr = S_OK;
        }
    } else {

        //
        // If there's no Device ID, look under StillImage
        //

        _tcscpy(tszBuf, REG_PATH_STILL_IMAGE_CONTROL);
        _tcscat(tszBuf, TEXT("\\Events"));
        //
        // Open the device specific or the global Events subkey
        //

        lRet = RegCreateKeyEx(
                   HKEY_LOCAL_MACHINE,
                   tszBuf,
                   0,
                   NULL,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ | KEY_WRITE,
                   NULL,
                   &hEvents,
                   &dwDisp);
        if (lRet != ERROR_SUCCESS) {
#ifdef UNICODE
            DBG_WRN(("CEventNotifier::FindEventByGUID() Couldn't find Events subkey, named %S", tszBuf));
#else
            DBG_WRN(("CEventNotifier::FindEventByGUID() Couldn't find Events subkey, named %s", tszBuf));
#endif
            return (HRESULT_FROM_WIN32(lRet));
        }
    }


    //
    // Enumerate all the events under Events subkey
    //

    for (dwSubKeyIndex = 0; ;dwSubKeyIndex++) {

        dwEventNameLen = sizeof(tszBuf)/sizeof(TCHAR) - 1;
        lRet = RegEnumKeyEx(
                   hEvents,
                   dwSubKeyIndex,
                   ptszEventName,
                   &dwEventNameLen,
                   NULL,
                   NULL,
                   NULL,
                   &fileTime);

        if (lRet != ERROR_SUCCESS) {
            break;
        }

        //
        // Open the event subkey
        //

        dwEventNameLen = sizeof(tszBuf);
        lRet = RegOpenKeyEx(
                   hEvents,
                   ptszEventName,
                   0,
                   KEY_READ | KEY_WRITE,
                   &hEvent);
        if (lRet != ERROR_SUCCESS) {
            continue;
        }

        //
        // Query the GUID value
        //

        dwGUIDStrLen = sizeof(tszBuf);
        lRet = RegQueryValueEx(
                   hEvent,
                   TEXT("GUID"),
                   NULL,
                   &dwValueType,
                   (LPBYTE)tszBuf,
                   &dwGUIDStrLen);
        if ((lRet != ERROR_SUCCESS) || (dwValueType != REG_SZ)) {

            if (hEvent) {
                RegCloseKey(hEvent);
                hEvent = NULL;
            }
            //
            // Junk event found, skip to the next
            //

#ifdef UNICODE
            DBG_WRN(("CEventNotifier::FindEventByGUID() Junk event %S found", ptszEventName));
#else
            DBG_WRN("CEventNotifier::FindEventByGUID() Junk event %s found", ptszEventName));
#endif
            continue;
        }
#ifndef UNICODE

        //
        // Convert the CLSID into UNICODE including the terminating NULL
        //

        mbstowcs(wszGUIDStr, tszBuf, 39);
#endif
        if (SUCCEEDED(CLSIDFromString(pwszGUIDStr, &eventGUID))) {
            if (eventGUID == *pEventGUID) {

                RegCloseKey(hEvents);

                *phEventKey = hEvent;
                return (S_OK);
            }
        }

        if (hEvent) {
            RegCloseKey(hEvent);
            hEvent = NULL;
        }
    } // End of for (...)

    DBG_WRN(("CEventNotifier::FindEventByGUID() Event GUID not found in reg key enumeration, creating one..."));

    if (ActionGuidExists(bstrDeviceID, pEventGUID)) {

        //
        // Someone forgot to add the EVENT entry to their INF, so create a
        // sub-key with the event GUID as a value
        //

#define DEFAULT_EVENT_STR TEXT("Event")
#define GUID_STR          TEXT("GUID")
        TCHAR   Name[MAX_PATH];
        HKEY    hEventName = NULL;
        WCHAR   *wsGUID = NULL;
        USES_CONVERSION;

#ifdef UNICODE
        wsprintf(Name, L"%ws%d", DEFAULT_EVENT_STR, dwSubKeyIndex);
#else
        sprintf(Name, "%s%d", DEFAULT_EVENT_STR, dwSubKeyIndex);
#endif

        lRet = RegCreateKeyEx(
                   hEvents,
                   Name,
                   0,
                   NULL,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ | KEY_WRITE,
                   NULL,
                   &hEvent,
                   &dwDisp);
        if (lRet == ERROR_SUCCESS) {

            hr = StringFromCLSID(*pEventGUID, &wsGUID);
            if (hr == S_OK) {
                lRet = RegSetValueEx(
                        hEvent,
                        GUID_STR,
                        0,
                        REG_SZ,
                        (BYTE*) W2T(wsGUID),
                        (lstrlen(W2T(wsGUID)) * sizeof(TCHAR))  + sizeof(TEXT('\0')));
                if (lRet == ERROR_SUCCESS) {
                    *phEventKey = hEvent;
                    hr = S_OK;
                } else {
                    hr = E_FAIL;
                }
                CoTaskMemFree(wsGUID);
                wsGUID = NULL;
            }
        }

    }
    //
    // Close Events key
    //

    RegCloseKey(hEvents);
    if (FAILED(hr)) {
        if (hEvent) {
            RegCloseKey(hEvent);
        }
    }
    return hr;
}


/**************************************************************************\
* CEventNotifier::CreateEnumEventInfo
*
*   Build enumerator for specific device's persistent handlers
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    8/8/1999 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::CreateEnumEventInfo(
    BSTR                    bstrDeviceID,
    const GUID             *pEventGUID,
    IEnumWIA_DEV_CAPS     **ppIEnumDevCap)
{
    DBG_FN(CEventNotifier::CreateEnumEventInfo);
    HRESULT                 hr;
    EventDestNode          *pCurNode;
    EventDestNode          *pDefDevHandlerNode;
    ULONG                   numHandlers, i;
    WIA_EVENT_HANDLER      *pEventHandlers, *pHandler;
    CEnumDC                *pEnumDC;
    TCHAR                   tszCommandline[MAX_PATH];
#ifndef UNICODE
    WCHAR                   wszBuf[MAX_PATH];
#endif

    CWiaCritSect            CritSect(&g_semEventNode);

    ASSERT(bstrDeviceID);

    //
    // Clear the returned value
    //

    *ppIEnumDevCap = NULL;

    //
    // Find the number of handlers
    //

    GetNumPersistentHandlerAndDefault(
        bstrDeviceID, pEventGUID, &numHandlers, &pDefDevHandlerNode);

    //
    // Build the enumerator
    //

    pEnumDC = new CEnumDC;
    if (! pEnumDC) {
        return (E_OUTOFMEMORY);
    }

    //
    // If there is no handler registered for this event
    //

    if (! numHandlers) {

        DBG_TRC(("CreateEnumEventInfo() : No handler registered for this event"));

        //
        // Trivial case
        //

        pEnumDC->Initialize(0, (WIA_EVENT_HANDLER*)NULL);

        return (pEnumDC->QueryInterface(
                             IID_IEnumWIA_DEV_CAPS, (void **)ppIEnumDevCap));
    }

    //
    // Prepare the Event Handler information
    //

    pEventHandlers =
        (WIA_EVENT_HANDLER *)LocalAlloc(
                                 LPTR, sizeof(WIA_EVENT_HANDLER)*numHandlers);
    if (! pEventHandlers) {

        delete pEnumDC;
        return (E_OUTOFMEMORY);
    }

    memset(pEventHandlers, 0, sizeof(WIA_EVENT_HANDLER) * numHandlers);
    pHandler = pEventHandlers;
    hr = S_OK;
    for (pCurNode = m_pEventDestNodes, i = 0;
         pCurNode && (i <numHandlers);
         pCurNode = pCurNode->pNext) {

        //
        // If this handler is a callback interface ponter
        //

        if (pCurNode->pIEventCB) {
            continue;
        }

        //
        // If this handler can not handle this event
        //

        if (( pCurNode->iidEventGUID != *pEventGUID) &&
           (pCurNode->iidEventGUID != WIA_EVENT_STI_PROXY) ) {
            continue;
        }

        //
        // If this is generic fallback handler
        //

        if (wcscmp(pCurNode->bstrDeviceID, L"All") != 0) {

            //
            // If this handler is not for this device
            //

            if (wcscmp(pCurNode->bstrDeviceID, bstrDeviceID) != 0) {
                continue;
            }

        } else {

            //
            // If this handler was registered for this device as default
            //

            if (FindEventCBNode(0,bstrDeviceID, pEventGUID, &pCurNode->ClsID)) {
                continue;
            }
        }

        //
        // Copy the information from the current node
        //

        pHandler->guid            = pCurNode->ClsID;
        pHandler->bstrName        = SysAllocString(pCurNode->bstrName);
        pHandler->bstrDescription = SysAllocString(pCurNode->bstrDescription);
        pHandler->bstrIcon        = SysAllocString(pCurNode->bstrIcon);
        if (pCurNode->tszCommandline[0] != '\0') {
#ifdef UNICODE

            PrepareCommandline(
                bstrDeviceID,
                *pEventGUID,
                pCurNode->tszCommandline,
                tszCommandline);

            pHandler->bstrCommandline =
                SysAllocString(tszCommandline);
#else
            PrepareCommandline(
                bstrDeviceID,
                *pEventGUID,
                pCurNode->tszCommandline,
                tszCommandline);

            MultiByteToWideChar(CP_ACP,
                                0,
                                tszCommandline,
                                -1,
                                wszBuf,
                                MAX_PATH);
            pHandler->bstrCommandline = SysAllocString(wszBuf);
#endif
        }

        //
        // Check whether the copy is successful
        //

        if ((! pHandler->bstrName) ||
            (! pHandler->bstrDescription) ||
            (! pHandler->bstrIcon) ||
            ((pCurNode->tszCommandline[0] != '\0') && (! pHandler->bstrCommandline))) {

            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Set the flag if this handler is the default one
        //

        if (pCurNode == pDefDevHandlerNode) {
            pHandler->ulFlags = WIA_IS_DEFAULT_HANDLER;
        }

        pHandler++;
        i++;
    }

    //
    // Unwind the partial result if error occured
    //

    if (FAILED(hr)) {

        for (i = 0, pHandler = pEventHandlers;
             i < numHandlers; i++, pHandler++) {

            if (pHandler->bstrName) {
                SysFreeString(pHandler->bstrName);
            }
            if (pHandler->bstrDescription) {
                SysFreeString(pHandler->bstrDescription);
            }
            if (pHandler->bstrIcon) {
                SysFreeString(pHandler->bstrIcon);
            }
        }

        LocalFree(pEventHandlers);

        delete pEnumDC;

        return (hr);
    }

    //
    // Initilization will never fail
    //

    pEnumDC->Initialize(numHandlers, pEventHandlers);

    return (pEnumDC->QueryInterface(
                         IID_IEnumWIA_DEV_CAPS, (void **)ppIEnumDevCap));
}


/**************************************************************************\
* CEventNotifier::GetNumPersistentHandlerAndDefault
*
*   Find the total number of persistent handlers and the default
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    8/8/1999 Original Version
*
\**************************************************************************/

HRESULT
CEventNotifier::GetNumPersistentHandlerAndDefault(
    BSTR                    bstrDeviceID,
    const GUID             *pEventGUID,
    ULONG                  *pulNumHandlers,
    EventDestNode         **ppDefaultNode)
{
    DBG_FN(CEventNotifier::GetNumPersistentHandlerAndDefault);
    EventDestNode          *pCurNode;
    EventDestNode          *pDefDevHandlerNode, *pDefGenHandlerNode, *pTempNode;

    *pulNumHandlers = 0;

    pDefDevHandlerNode = NULL;
    pDefGenHandlerNode = NULL;

    for (pCurNode = m_pEventDestNodes; pCurNode; pCurNode = pCurNode->pNext) {

        //
        // If this handler is a callback interface ponter
        //

        if (pCurNode->pIEventCB) {
            continue;
        }

        //
        // If this handler can not handle this event and this handler is not proxy for STI handlers
        //

        if ( (pCurNode->iidEventGUID != *pEventGUID) &&
             (pCurNode->iidEventGUID != WIA_EVENT_STI_PROXY) ) {

            //
            //  If the pEventGUID is the STI Proxy GUID, then we need to
            //  include WIA Global event handlers i.e. those with
            //  DeviceIDs of "ALL".
            //  Otherwise, just skip it.
            //
            if ((*pEventGUID == WIA_EVENT_STI_PROXY) && (lstrcmpW(bstrDeviceID, L"All") == 0)) {
                (*pulNumHandlers)++;
            }
            continue;
        }

        if (wcscmp(pCurNode->bstrDeviceID, L"All") != 0) {

            //
            // If this handler is not for this device
            //

            if (wcscmp(pCurNode->bstrDeviceID, bstrDeviceID) != 0) {
                continue;
            }

            //
            // Remember the default handler's node
            //

            if (! pDefDevHandlerNode) {
                pDefDevHandlerNode = pCurNode;
            } else {

                /* Original code
                if (CompareFileTime(
                        &pCurNode->timeStamp,
                        &pDefDevHandlerNode->timeStamp) > 0) {

                    pDefDevHandlerNode = pCurNode;
                }
                */

                //
                //  Timestamps are not valid on Win9x, so use the flag which indicates
                //  whether this is the default handler for this device.
                //

                if (pCurNode->bDeviceDefault) {
                    pDefDevHandlerNode = pCurNode;
                }
            }

        } else {
            //
            // If this handler was registered for this device as default, then skip it
            // since we'll hit the device specific registration on our pass anyway.
            //

            if (FindEventCBNode(0,bstrDeviceID, pEventGUID, &pCurNode->ClsID)) {

                if (lstrcmpW(bstrDeviceID, L"All") == 0) {
                    //
                    // If the request is for ALL devices, then we're simply being asked to count the number
                    // of global handlers.
                    //

                    (*pulNumHandlers)++;
                }
                continue;
            }

            //
            // If no device specific handler is found, then we want to go with a global one.
            //
            if (! pDefDevHandlerNode) {

                if (! pDefGenHandlerNode) {

                    //
                    // We found our first global Handler
                    //
                    pDefGenHandlerNode = pCurNode;
                } else {

                    //
                    //  Since there is more than one global handler, let's use the "Prompt", if we can find it.
                    //  NOTE:  We assume that on registration of more than one global handler, the "Prompt" handler
                    //  will be registered; so if we don't find it, this would generally indicate a problem during
                    //  registration.  However, in cases of upgrade, this is possible, and entirely normal, so we
                    //  don't flag it as an error here, since it's not fatal anyway.
                    //

                    pTempNode = FindEventCBNode(0, NULL, pEventGUID, &WIA_EVENT_HANDLER_PROMPT);
                    if (pTempNode) {
                        pDefGenHandlerNode = pTempNode;
                    }
                }
            }
        }

        (*pulNumHandlers)++;
    }

    //
    // If there is no device specific default handler, fall back
    //

    if (! pDefDevHandlerNode) {

        *ppDefaultNode = pDefGenHandlerNode;
    } else {

        *ppDefaultNode = pDefDevHandlerNode;
    }

    return (S_OK);
}


/**************************************************************************\
* CEventNotifier::StartCallbackProgram
*
*   Start the callback program in security context of the user who logged on
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    8/8/1999 Original Version
*
\**************************************************************************/


HRESULT
CEventNotifier::StartCallbackProgram(
    EventDestNode          *pCBNode,
    PWIAEventThreadInfo     pMasterInfo)
#ifndef UNICODE
{
    STARTUPINFO             startupInfo;
    PROCESS_INFORMATION     processInfo;
    int                     nCmdLineLen;
    BOOL                    bRet;
    CHAR                    szCommandline[MAX_PATH];

    do {

        //
        // Set up start up info
        //

        ZeroMemory(&startupInfo, sizeof(startupInfo));

        startupInfo.cb          = sizeof(startupInfo);
        startupInfo.wShowWindow = SW_SHOWNORMAL;

        //
        // Set up the command line
        //    program /StiDevice Image\NNNN /StiEvent {GUID}
        //
        ZeroMemory(szCommandline, sizeof(szCommandline));

        nCmdLineLen = strlen(pCBNode->tszCommandline);
        if ((MAX_PATH - nCmdLineLen) < (1 + 11 + 10 + 1 + 10 + 38 + 1)) {
            break;
        }

        //
        // Prepare the command line
        // Nb: It may be important to pick up event GUID from master info block, not from event callback node, because
        // GUID match could've been found against STI proxy event GUID, in which case callback node would contain
        // STI proxy event GUID, not the hardware event GUID, which we need
        //

        PrepareCommandline(
            pMasterInfo->bstrDeviceID,
            pMasterInfo->eventGUID,
            //pCBNode->iidEventGUID,
            pCBNode->tszCommandline,
            szCommandline);

        //
        // Create the process in user's context
        //

        bRet = CreateProcess(
                   NULL,                    // Application name
                   szCommandline,
                   NULL,                    // Process attributes
                   NULL,                    // Thread attributes
                   FALSE,                   // Handle inheritance
                   0,                       // Creation flag
                   NULL,                    // Environment
                   NULL,                    // Current directory
                   &startupInfo,
                   &processInfo);

        if (! bRet) {
            break;
        }

        //
        // Close the handle passed back
        //

        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);

    } while (FALSE);

    return (HRESULT_FROM_WIN32(::GetLastError()));
}
#else
{
    HANDLE                  hTokenUser;
    STARTUPINFO             startupInfo;
    PROCESS_INFORMATION     processInfo;
    LPVOID                  pEnvBlock;
    int                     nCmdLineLen;
    BOOL                    bRet;
    WCHAR                   wszCommandline[MAX_PATH];

    hTokenUser = NULL;
    pEnvBlock  = NULL;

    do {

        nCmdLineLen = wcslen(pCBNode->tszCommandline);
        if ((MAX_PATH - nCmdLineLen) < (1 + 11 + 43 + 1 + 10 + 38 + 1)) {
            break;
        }

        //
        // Get interactive user's token
        //

        hTokenUser = GetUserTokenForConsoleSession();

        //
        // Maybe nobody is loggon in
        //

        if (! hTokenUser) {
            break;
        }

        //
        // Set up start up info
        //

        ZeroMemory(&startupInfo, sizeof(startupInfo));
        startupInfo.lpDesktop   = L"WinSta0\\Default";
        startupInfo.cb          = sizeof(startupInfo);
        startupInfo.wShowWindow = SW_SHOWNORMAL;

        //
        // Create the user's environment block
        //

        bRet = CreateEnvironmentBlock(
                   &pEnvBlock,
                   hTokenUser,
                   FALSE);
        if (! bRet) {
            DBG_WRN(("CEventNotifier::StartCallbackProgram, CreateEnvironmentBlock failed!  GetLastError() = 0x%08X", GetLastError()));
            break;
        }

        //
        // Prepare the command line.  Make sure we pass in the EVENT guid, not the STI proxy guid.
        //

        PrepareCommandline(
            pMasterInfo->bstrDeviceID,
            pMasterInfo->eventGUID,
            pCBNode->tszCommandline,
            wszCommandline);

        //
        // Create the process in user's context
        //

        bRet = CreateProcessAsUser(
                   hTokenUser,
                   NULL,                    // Application name
                   wszCommandline,
                   NULL,                    // Process attributes
                   NULL,                    // Thread attributes
                   FALSE,                   // Handle inheritance
                   NORMAL_PRIORITY_CLASS |
                       CREATE_UNICODE_ENVIRONMENT | CREATE_NEW_PROCESS_GROUP,
                   pEnvBlock,               // Environment
                   NULL,                    // Current directory
                   &startupInfo,
                   &processInfo);

        if (! bRet) {
            DBG_WRN(("CEventNotifier::StartCallbackProgram, CreateProcessAsUser failed!  GetLastError() = 0x%08X", GetLastError()));
            break;
        }

        //
        // Close the handle passed back
        //

        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);

    } while (FALSE);

    //
    // Garbage collection
    //

    if (hTokenUser) {
        CloseHandle(hTokenUser);
    }
    if (pEnvBlock) {
        DestroyEnvironmentBlock(pEnvBlock);
    }

    return (HRESULT_FROM_WIN32(::GetLastError()));
}
#endif


/**************************************************************************\
*  QueryInterface
*  AddRef
*  Release
*
*    CWiaInterfaceEvent IUnknown Interface
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

HRESULT __stdcall
CWiaInterfaceEvent::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown) {
        *ppv = (IUnknown*) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG __stdcall
CWiaInterfaceEvent::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}


ULONG __stdcall
CWiaInterfaceEvent::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) {

        delete this;
        return 0;
    }

    return ulRefCount;
}

/*******************************************************************************
*
* CWiaInterfaceEvent
* ~CWiaInterfaceEvent
*
* CWiaInterfaceEvent Constructor/Destructor Methods.
*
* History:
*
*    9/2/1998 Original Version
*
\**************************************************************************/

CWiaInterfaceEvent::CWiaInterfaceEvent(PEventDestNode  pEventDestNode)
{
    ASSERT(pEventDestNode != NULL);

    m_cRef           = 0;
    m_pEventDestNode = pEventDestNode;
}

CWiaInterfaceEvent::~CWiaInterfaceEvent()
{
    //
    // must have exclusive access when changing list
    //

    CWiaCritSect     CritSect(&g_semEventNode);

    //
    // make sure registered event is removed
    //

    if (m_pEventDestNode != NULL) {
        g_eventNotifier.UnregisterEventCB(m_pEventDestNode);
    }
}


/**************************************************************************\
*  QueryInterface
*  AddRef
*  Release
*
*    CWiaEventContext IUnknown Interface
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/6/2000 Original Version
*
\**************************************************************************/

HRESULT __stdcall
CWiaEventContext::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown) {
        *ppv = (IUnknown*) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG __stdcall
CWiaEventContext::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}


ULONG __stdcall
CWiaEventContext::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) {

        delete this;
        return 0;
    }

    return ulRefCount;
}

/*******************************************************************************
*
* CWiaEventContext
* ~CWiaEventContext
*
* CWiaEventContext Constructor/Destructor Methods.
*
* History:
*
*    1/6/2000 Original Version
*
\**************************************************************************/

CWiaEventContext::CWiaEventContext(
    BSTR                    bstrDeviceID,
    const GUID             *pGuidEvent,
    BSTR                    bstrFullItemName)
{
    //
    // Reference count initialized to 1
    //

    m_cRef              = 1;

    m_ulEventType       = 0;

    m_guidEvent         = *pGuidEvent;
    m_bstrFullItemName  = bstrFullItemName;

    m_bstrDeviceId      = bstrDeviceID;
}

CWiaEventContext::~CWiaEventContext()
{
    //
    // bstrFullItemName is free in NotifySTIEvent
    //

    if (m_bstrDeviceId) {
        SysFreeString(m_bstrDeviceId);
        m_bstrDeviceId = NULL;
    }
}


/**************************************************************************\
*
*  WiaDelayedEvent
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/6/2000 Original Version
*
\**************************************************************************/

VOID WINAPI
WiaDelayedEvent(
    VOID                   *pArg)
{
    CWiaEventContext       *pCEventCtx;
    WIANOTIFY               wn;

    //
    // Cast back the context
    //

    if (! pArg) {
        return;
    }

    pCEventCtx = (CWiaEventContext *)pArg;

    //
    // Prepare the notification structure
    //

    wn.lSize                          = sizeof(WIANOTIFY);
    wn.bstrDevId                      = pCEventCtx->m_bstrDeviceId;
    wn.stiNotify.dwSize               = sizeof(STINOTIFY);
    wn.stiNotify.guidNotificationCode = pCEventCtx->m_guidEvent;

    //
    // Fire the event
    //

    g_eventNotifier.NotifySTIEvent(
                        &wn,
                        pCEventCtx->m_ulEventType,
                        pCEventCtx->m_bstrFullItemName);

    //
    // Release the initial reference
    //

    pCEventCtx->Release();
}

/**************************************************************************\
*
*  wiasQueueEvent
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/6/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall
wiasQueueEvent(
    BSTR                    bstrDeviceId,
    const GUID             *pEventGUID,
    BSTR                    bstrFullItemName)
{
    HRESULT                 hr = S_OK;
    BYTE                   *pRootItemCtx;
    CWiaEventContext       *pCEventCtx = NULL;
    BSTR                    bstrDeviceIdCopy = NULL;
    BSTR                    bstrFullItemNameCopy = NULL;
    BOOL                    bRet;

    //
    // Basic sanity check of the parameters
    //

    if ((! bstrDeviceId) || (! pEventGUID)) {
        return (E_INVALIDARG);
    }

    //
    // Poor man's exception handler
    //

    do {

        bstrDeviceIdCopy = SysAllocString(bstrDeviceId);
        if (! bstrDeviceIdCopy) {
            hr = E_OUTOFMEMORY;
            break;
        }

        if (bstrFullItemName) {
            bstrFullItemNameCopy = SysAllocString(bstrFullItemName);
            if (! bstrFullItemNameCopy) {
                hr = E_OUTOFMEMORY;
                break;
            }
        }

        //
        // Create an event context
        //

        pCEventCtx = new CWiaEventContext(
                             bstrDeviceIdCopy,
                             pEventGUID,
                             bstrFullItemNameCopy);
        if (! pCEventCtx) {
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Queue a scheduler item
        //

        bRet = ScheduleWorkItem(
                   WiaDelayedEvent,
                   pCEventCtx,
                   0,
                   NULL);
        if (! bRet) {
            hr = E_FAIL;
        }

    } while (FALSE);

    //
    // Garbage collection
    //

    if (hr != S_OK) {

        if (pCEventCtx) {
            delete pCEventCtx;
        } else {

            if (bstrDeviceIdCopy) {
                SysFreeString(bstrDeviceIdCopy);
            }
        }

        if (bstrFullItemNameCopy) {
            SysFreeString(bstrFullItemNameCopy);
        }
    }

    return (hr);
}


#ifdef UNICODE
void
PrepareCommandline(
    BSTR                    bstrDeviceID,
    const GUID             &guidEvent,
    LPCWSTR                 pwszOrigCmdline,
    LPWSTR                  pwszResCmdline)
{
    WCHAR                   wszGUIDStr[40];
    WCHAR                   wszCommandline[MAX_PATH];
    WCHAR                  *pPercentSign;
    WCHAR                  *pTest = NULL;

    //
    // Fix up the commandline.  First check that it has at least two %
    //

    pTest = wcschr(pwszOrigCmdline, '%');
    if (pTest) {
        pTest = wcschr(pTest + 1, '%');
    }

    if (!pTest) {
        _snwprintf(
            wszCommandline,
            sizeof(wszCommandline) / sizeof( wszCommandline[0] ),
            L"%s /StiDevice:%%1 /StiEvent:%%2",
            pwszOrigCmdline);
    } else {
        wcsncpy(wszCommandline, pwszOrigCmdline, sizeof(wszCommandline) / sizeof( wszCommandline[0] ));
    }

    //
    // enforce null termination
    //

    wszCommandline[ (sizeof(wszCommandline) / sizeof(wszCommandline[0])) - 1 ] = 0;

    //
    // Change the number {1|2} into s
    //

    pPercentSign = wcschr(wszCommandline, L'%');
    *(pPercentSign + 1) = L's';
    pPercentSign = wcschr(pPercentSign + 1, L'%');
    *(pPercentSign + 1) = L's';

    //
    // Convert the GUID into string
    //

    StringFromGUID2(guidEvent, wszGUIDStr, 40);

    //
    // Final comand line
    //

    swprintf(pwszResCmdline, wszCommandline, bstrDeviceID, wszGUIDStr);
}

#else
void
PrepareCommandline(
    BSTR                    bstrDeviceID,
    const GUID             &guidEvent,
    LPCSTR                  pszOrigCmdline,
    LPSTR                   pszResCmdline)
{
    CHAR                    szCommandline[MAX_PATH];
    CHAR                   *pPercentSign;
    WCHAR                   wszGUIDStr[40];
    char                    szGUIDStr[40];
    char                    szDeviceID[12];     // Image\NNNN

    //
    // Fix up the commandline
    //
    DBG_WRN(("PrepareCommandLine"));

    if (! strchr(pszOrigCmdline, '%')) {
        _snprintf(
            szCommandline,
            sizeof(szCommandline) / sizeof( szCommandline[0] ),
            "%s /StiDevice:%%1 /StiEvent:%%2",
            pszOrigCmdline);
    } else {
        strncpy(szCommandline, pszOrigCmdline, sizeof(wszCommandline) / sizeof( wszCommandline[0] ));
    }

    //
    // enforce null termination
    //

    szCommandline[ (sizeof(szCommandline) / sizeof(szCommandline[0])) - 1 ] = 0;


    //
    // Change the number {1|2} into s
    //

    pPercentSign = strchr(szCommandline, '%');
    *(pPercentSign + 1) = 's';
    pPercentSign = strchr(pPercentSign + 1, '%');
    *(pPercentSign + 1) = 's';

    //
    // Convert the GUID into string
    //

    StringFromGUID2(guidEvent, wszGUIDStr, 40);

    WideCharToMultiByte(CP_ACP,
                        0,
                        bstrDeviceID,
                        -1,
                        szDeviceID,
                        sizeof(szDeviceID),
                        NULL,
                        NULL);

    WideCharToMultiByte(CP_ACP,
                        0,
                        wszGUIDStr,
                        -1,
                        szGUIDStr,
                        sizeof(szGUIDStr),
                        NULL,
                        NULL);

    //
    // Final result
    //

    sprintf(pszResCmdline, szCommandline, szDeviceID, szGUIDStr);
}
#endif

/**************************************************************************\
*
*  ActionGuidExists
*
*   Returns true if the specified event GUID is reported as an ACTION event
*   by the driver
*
* Arguments:
*
*   bstrDevId   -   identifies the device we're interested in
*   pEventGUID  -   identifies the event we're looking for
*
* Return Value:
*
*   TRUE    -   The driver reports this event as an ACTION event
*   FALSE   -   This is not an ACTION event for this device
*
* History:
*
*    03/01/2000 Original Version
*
\**************************************************************************/

BOOL ActionGuidExists(
          BSTR        bstrDevId,
    const GUID        *pEventGUID)
{
    BOOL                bRet        = FALSE;
    IWiaDevMgr          *pIDevMgr   = NULL;
    IWiaItem            *pIItem     = NULL;
    IEnumWIA_DEV_CAPS   *pIEnum     = NULL;
    WIA_DEV_CAP         DevCap;
    ULONG               ulVal;
    HRESULT             hr          = E_FAIL;

    //
    // Get the device manager and create an item interface for that device
    //

    hr = CWiaDevMgr::CreateInstance(IID_IWiaDevMgr, (VOID**) &pIDevMgr);
    if (SUCCEEDED(hr)) {
        hr = pIDevMgr->CreateDevice(bstrDevId, &pIItem);
        if (SUCCEEDED(hr)) {

            //
            // Get an enumerator for the events
            //

            hr = pIItem->EnumDeviceCapabilities(WIA_DEVICE_EVENTS, &pIEnum);
            if (SUCCEEDED(hr)) {

                //
                // Iterate through events to check whether we have a
                // match
                //

                while(pIEnum->Next(1, &DevCap, &ulVal) == S_OK) {

                    if (DevCap.guid == *pEventGUID) {

                        //
                        // Check whether it's an action event, and mark
                        // our return to TRUE if it is.
                        //

                        if (DevCap.ulFlags & WIA_ACTION_EVENT) {
                            bRet = TRUE;
                            break;
                        }
                    }
                }
                pIEnum->Release();
            } else {
                DBG_WRN(("ActionGuidExists() : Failed to enumerate (0x%X)", hr));
            }
            pIItem->Release();
        } else {
            DBG_WRN(("ActionGuidExists() : Failed to create device (0x%X)", hr));
        }
        pIDevMgr->Release();
    } else {
        DBG_WRN(("ActionGuidExists() : Failed to create device manager (0x%X)", hr));
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiamain.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       Main.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        9 Jan, 1998
*
*  DESCRIPTION:
*
*   Implementation of WinMain for WIA device manager server device object.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include "wiamindr.h"

#include "wiacfact.h"
#include "devmgr.h"
#include "wialog.h"
#include "wiaevntp.h"

//
// Image transfer critical section.
//

CRITICAL_SECTION g_semDeviceMan;

//
// Critical section for event node, should only be used in event notifier
//

CRITICAL_SECTION g_semEventNode;

//
// data to initialize WiaDevMgr CLSID
//

FACTORY_DATA g_FactoryData[] =
{
    {CWiaDevMgr::CreateInstance,     // Object creator
     NULL,                           // Pointer to running class factory
     0,                              // ID for running object
     &CLSID_WiaDevMgr,               // Class ID
     &LIBID_WiaDevMgr,               // Type Library ID
     TEXT("WIA Device Manager"),    // Friendly Name
     TEXT("WiaDevMgr.1"),           // Program ID
     TEXT("WiaDevMgr"),             // Version-independent Program ID
     TEXT("StiSvc"),                // Service ID
     SERVICE_FILE_NAME}             // Filename
};

UINT g_uiFactoryDataCount = sizeof(g_FactoryData) / sizeof(FACTORY_DATA);

//
// data to initialize WiaLog CLSID
//

FACTORY_DATA g_LogFactoryData[] =
{
    {CWiaLog::CreateInstance,        // Object creator
     NULL,                           // Pointer to running class factory
     0,                              // ID for running object
     &CLSID_WiaLog,                  // Class ID
     &LIBID_WiaDevMgr,               // Type Library ID (Logging shares Type lib)
     TEXT("WIA Logger"),            // Friendly Name
     TEXT("WiaLog.1"),              // Program ID
     TEXT("WiaLog"),                // Version-independent Program ID
     TEXT("StiSvc"),                // Service ID (Logging uses same service)
     SERVICE_FILE_NAME}             // Filename (Logging uses same .exe)
};

UINT g_uiLogFactoryDataCount = sizeof(g_LogFactoryData) / sizeof(FACTORY_DATA);

//
// Private function proto's:
//

LRESULT CALLBACK WiaMainWndProc(HWND, UINT, UINT, LONG);


/**************************************************************************\
* ProcessWiaMsg
*
*   !!! minimal message server: is this needed
*
* Arguments:
*
*   hwnd   - window handle
*   uMsg   - message
*   wParam - param
*   lParam - param
*
* Return Value:
*
*    Status
*
* History:
*
*    4/8/1999 Original Version
*
\**************************************************************************/

HRESULT ProcessWiaMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
       case WM_CREATE:
          break;

       case WM_DESTROY:
          if (CFactory::CanUnloadNow() != S_OK) {

              //
              // Don't let STI process this message.
              //

              return S_OK;
          }
          break;

       case WM_CLOSE:
         break;

    }

    //
    // Let STI handle the message.
    //

    return S_FALSE;
}

#if 0

/**************************************************************************\
* DispatchWiaMsg
*
*   Handle Event messages
*
*
*   !!! WM_NOTIFY_WIA_VOLUME_EVENT is a temp hack and needs to be
*       added for real or removed
*
* Arguments:
*
*   pMsg    WM_NOTIFY_WIA_DEV_EVENT or WM_NOTIFY_WIA_VOLUME_EVENT
*
* Return Value:
*
*    Status
*
* History:
*
*    4/8/1999 Original Version
*
\**************************************************************************/

HRESULT DispatchWiaMsg(MSG *pMsg)
{
    DBG_FN(::DispatchWiaMsg);
    PWIANOTIFY pwn;

    if (pMsg->message == WM_NOTIFY_WIA_DEV_EVENT) {

        //
        // find out if this is a valid WIA event, call handler
        //

        DBG_ERR(("WIA Processing WM_NOTIFY_WIA_DEV_EVENT: shouldn't be called"));

        //
        // event are now directly fired, not posted
        //

        #if 0
            pwn = (PWIANOTIFY) pMsg->lParam;

            if (pwn && (pwn->lSize == sizeof(WIANOTIFY))) {

                if (g_eventNotifier.NotifySTIEvent(pwn) == S_FALSE) {
                    DBG_WRN(("::DispatchWiaMsg, No Applications were registered for this event"));
                }

                SysFreeString(pwn->bstrDevId);
                LocalFree(pwn);
            }
            else {
                DBG_ERR(("::DispatchWiaMsg, Bad WIA notify data"));
            }
        #endif

    } else if (pMsg->message == WM_NOTIFY_WIA_VOLUME_EVENT) {

        //
        // WIA volume arrival
        //

        DBG_TRC(("::DispatchWiaMsg, WIA Processing WM_NOTIFY_WIA_VOLUME_EVENT"));

        PWIANOTIFY_VOLUME pwn = (PWIANOTIFY_VOLUME) pMsg->lParam;

        if (pwn && (pwn->lSize == sizeof(WIANOTIFY_VOLUME))) {

            //
            // look at root fo volume for WIA File wia.cmd
            //

            int     i;
            char    c    = 'A';
            DWORD   mask = pwn->unitmask;

            //
            // find drive letter
            //

            if (mask & 0x07ffffff) {

                for (i=0;i<24;i++) {
                    if (mask & 0x00000001) {
                        break;
                    }

                    c++;
                    mask >>= 1;
                }

                //
                // build file name
                //

                char FileName[MAX_PATH];

                FileName[0]  = c;
                FileName[1]  = ':';
                FileName[2]  = '\\';
                FileName[3]  = 'w';
                FileName[4]  = 'i';
                FileName[5]  = 'a';
                FileName[6]  = '.';
                FileName[7]  = 'c';
                FileName[8]  = 'm';
                FileName[9]  = 'd';
                FileName[10] = '\0';

                //
                // open file
                //



                HANDLE hFile = CreateFileA(
                    FileName,
                    GENERIC_WRITE | GENERIC_READ  ,
                    FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

                if (hFile != INVALID_HANDLE_VALUE) {

                    //
                    // file name is on volume root
                    //

                    if (g_eventNotifier.NotifyVolumeEvent(pwn) == S_FALSE) {
                        DBG_WRN(("::DispatchWiaMsg, No Applications were registered for this Volume event"));
                    }

                    CloseHandle(hFile);
                }
            }

            //
            // free message
            //

            LocalFree(pwn);
        }
        else {
            DBG_ERR(("::DispatchWiaMsg, Bad WIA notify data"));
        }
    }

    //
    // Let STI handle the message.
    //

    return S_FALSE;

}

#endif

/**************************************************************************\
* RegisterWiaDevMan
*
*   Register WiaDevMgr class factory
*
* Arguments:
*
*    bRegister - register/unregister
*
* Return Value:
*
*    Status
*
* History:
*
*    4/8/1999 Original Version
*
\**************************************************************************/

HRESULT RegisterWiaDevMan(BOOLEAN bRegister)
{
    HRESULT hr = CFactory::RegisterUnregisterAll(g_FactoryData,
                                                 g_uiFactoryDataCount,
                                                 bRegister,
                                                 TRUE);
    if(SUCCEEDED(hr)) {
        hr = CFactory::RegisterUnregisterAll(g_LogFactoryData,
                                         g_uiLogFactoryDataCount,
                                         bRegister,
                                         TRUE);
    }
    return hr;
}

/**************************************************************************\
* StartLOGClassFactories
*
*   Starts the Class factories for WIA logging object
*
* Arguments:
*
*   none
*
* Return Value:
*
*    Status
*
* History:
*
*    8/23/1999 Original Version
*
\**************************************************************************/
HRESULT StartLOGClassFactories()
{

#ifdef WINNT
    HRESULT hr = S_OK;

    //
    // Set COM security options.
    // NOTE:  Calling CoInitializeSecurity will override any DCOM 
    //  AccessPermissions that have been set (these are stored under
    //  our AppID key).  We really want to use these permissions and
    //  not a hardcoded security descriptor, so that if a vendor wanted
    //  to enable shared/remote scanning, all they need to do is adjust
    //  the DCOM AccessPermissions on the Wia Device Manager object.
    //  This can be done either through DCOM Config GUI, or programatically
    //  via the vendor's installation program.  (See our ClassFactory for
    //  an example of how to set the AccessPermissions.  When we are installed,
    //  we set default access permissions when doing our COM registration).
    // The way we get COM to use the DCOM AccessPermissions for the WIA 
    //  Device Manager, is we pass in the AppID (as a pointer to a GUID); and 
    //  the EOAC_APPID flag indicating that the first parameter is an AppID 
    //  rather than a security descriptor.  This informs COM that the 
    //  security descriptor should be taken from this objects AppID entry 
    //  in the registry.
    //

    hr =  CoInitializeSecurity((PVOID)&CLSID_WiaDevMgr,
                               -1,
                               NULL,
                               NULL,
                               RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE,
                               NULL,
                               EOAC_DYNAMIC_CLOAKING | EOAC_APPID,
                               NULL);
    if (FAILED(hr)) {

        DBG_ERR(("StartLOGClassFactories() CoInitializeSecurity failed, hr = 0x%08X", hr));

        ::CoUninitialize();
    }
#endif

    if (CFactory::StartFactories(g_LogFactoryData, g_uiLogFactoryDataCount))
        return S_OK;
    else
        return E_FAIL;
}

/**************************************************************************\
* InitWiaDevMan
*
*   Wia Initialization called from STI
*
* Arguments:
*
*   action - Action to be taken
*
* Return Value:
*
*    Status
*
* History:
*
*    4/8/1999 Original Version
*
\**************************************************************************/

HRESULT InitWiaDevMan(
    WIA_SERVICE_INIT_ACTION         action)
{

    DBG_FN("InitWiaDevMan");

    HRESULT             hr = E_FAIL;

    switch (action) {
        case WiaInitialize:

            //
            // Get Thread ID and process handle for the class factory.
            //

            CFactory::s_dwThreadID  = GetCurrentThreadId();
            CFactory::s_hModule     = g_hInst;

        /*
        //
        // This was moved to StartLOGClassFactories(), because of COM security's need
        // to be initialized before an object can be CoCreated correctly.
        // (investigate better way to do this..)
        //

        #ifdef WINNT

            //
            // Set COM security options. For now we set no security.
            // We will need to investigate this before shipping.
            //


            hr =  CoInitializeSecurity(NULL,
                                       -1,
                                       NULL,
                                       NULL,
                                       RPC_C_AUTHN_LEVEL_CONNECT,
                                       RPC_C_IMP_LEVEL_IMPERSONATE,
                                       NULL,
                                       0,
                                       NULL);
            if (FAILED(hr)) {

                DBG_ERR(("CoInitializeSecurity failed  (0x%X)", hr));

                ::CoUninitialize();

                break;
            }

        #endif
         */
            //
            // Register all of the class factories.
            //

            if (CFactory::StartFactories(g_FactoryData, g_uiFactoryDataCount)) {

                //
                // Restore persistent Event Callbacks
                //

                hr = g_eventNotifier.RestoreAllPersistentCBs();
            }

            hr = E_FAIL;
            break;

        case WiaUninitialize:

            //
            // Unregister the class factories.
            //

            CFactory::StopFactories(g_FactoryData, g_uiFactoryDataCount);
            CFactory::StopFactories(g_LogFactoryData, g_uiLogFactoryDataCount);

            hr = S_OK;
            break;

        case WiaRegister:
            hr = RegisterWiaDevMan(TRUE);
            break;

        case WiaUnregister:
            hr = RegisterWiaDevMan(FALSE);
            break;
    }
    return hr;
}

/**************************************************************************\
* NotifyWiaDeviceEvent
*
*    Called by STI service when WIA needs an async notification.
*
* Arguments:
*
*    pwszDevID   - ID of device generating event
*    pEventGUID  - event GUID
*    dwThreadId  - thread event msg needs to be posted to
*
* Return Value:
*
*    Status
*
* History:
*
*    4/8/1999 Original Version
*
\**************************************************************************/

HRESULT NotifyWiaDeviceEvent(
    LPWSTR      pwszDevID,
    const GUID  *pEventGUID,
    PBYTE       pNotificationData,
    ULONG       ulEventType,
    DWORD       dwThreadId)
{
    DBG_FN(NotifyWiaDeviceEvent);

    HRESULT     hr;
    BSTR        bstrDevId;
    WIANOTIFY   wn;

    DBG_TRC(("NotifyWiaDeviceEvent, pwszDevID= %S", pwszDevID));
    bstrDevId = SysAllocString(pwszDevID);

    if (bstrDevId != NULL) {

        wn.lSize                          = sizeof(WIANOTIFY);
        wn.bstrDevId                      = bstrDevId;
        wn.stiNotify.dwSize               = sizeof(STINOTIFY);
        wn.stiNotify.guidNotificationCode = *pEventGUID;

        if (! pNotificationData) {
            ZeroMemory(&wn.stiNotify.abNotificationData, MAX_NOTIFICATION_DATA);
        } else {
            CopyMemory(
                &wn.stiNotify.abNotificationData,
                pNotificationData,
                MAX_NOTIFICATION_DATA);
        }

        g_eventNotifier.NotifySTIEvent(&wn, ulEventType, NULL);

        //
        // We should return S_TRUE for events that we want STI to
        // handle also.
        //

        SysFreeString(bstrDevId);

        hr = S_FALSE;
    } else {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

/**************************************************************************\
* NotifyWiaVolumeEvent
*
*   Called by STI service when a removable volume arrives
*
* Arguments:
*
*    dbcv_unitmask - volume information flags
*    dwThreadId    - msg thread
*
* Return Value:
*
*    Status
*
* History:
*
*    4/8/1999 Original Version
*
\**************************************************************************/

HRESULT WINAPI NotifyWiaVolumeEvent(
    DWORD       dbcv_unitmask,
    DWORD       dwThreadId)
{
    PWIANOTIFY_VOLUME  pwn;

    //
    // Validate the thread ID.
    //

    if (!dwThreadId) {
        return E_FAIL;
    }

    //
    // Allocate and fill in WIANOTIFY structure for msg post.
    //

    pwn = (PWIANOTIFY_VOLUME)LocalAlloc(LPTR, sizeof(WIANOTIFY_VOLUME));

    if (pwn) {

        pwn->lSize    = sizeof(WIANOTIFY_VOLUME);
        pwn->unitmask = dbcv_unitmask;

        PostThreadMessage(dwThreadId,
                          WM_NOTIFY_WIA_VOLUME_EVENT,
                          0,
                          (LPARAM)pwn);
    } else {

        return E_OUTOFMEMORY;
    }

    //
    // We should return S_TRUE for events that we want STI to
    // handle also.
    //

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiapropp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       WiaPropP.H
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        14 Aug, 1998
*
*  DESCRIPTION:
*   Private definitions and declarations for WIA device properties.
*
\*******************************************************************************/

#ifndef __WIAPROPP_H_INCLUDED
#define __WIAPROPP_H_INCLUDED

#define NUMROOTITEMPROPS WIA_NUM_DIP + 3

PROPSPEC g_psRootItem[NUMROOTITEMPROPS] =
{
    {PRSPEC_PROPID, WIA_DIP_DEV_ID},
    {PRSPEC_PROPID, WIA_DIP_VEND_DESC},
    {PRSPEC_PROPID, WIA_DIP_DEV_DESC},
    {PRSPEC_PROPID, WIA_DIP_DEV_TYPE},
    {PRSPEC_PROPID, WIA_DIP_PORT_NAME},
    {PRSPEC_PROPID, WIA_DIP_DEV_NAME},
    {PRSPEC_PROPID, WIA_DIP_SERVER_NAME},
    {PRSPEC_PROPID, WIA_DIP_REMOTE_DEV_ID},
    {PRSPEC_PROPID, WIA_DIP_UI_CLSID},
    {PRSPEC_PROPID, WIA_DIP_HW_CONFIG},
    {PRSPEC_PROPID, WIA_DIP_BAUDRATE},
    {PRSPEC_PROPID, WIA_DIP_STI_GEN_CAPABILITIES},
    {PRSPEC_PROPID, WIA_IPA_ITEM_NAME},
    {PRSPEC_PROPID, WIA_IPA_FULL_ITEM_NAME},
    {PRSPEC_PROPID, WIA_IPA_ITEM_FLAGS},
    {PRSPEC_PROPID, WIA_DIP_WIA_VERSION},
    {PRSPEC_PROPID, WIA_DIP_DRIVER_VERSION},
};

PROPID g_piRootItem[NUMROOTITEMPROPS] =
{
    WIA_DIP_DEV_ID,
    WIA_DIP_VEND_DESC,
    WIA_DIP_DEV_DESC,
    WIA_DIP_DEV_TYPE,
    WIA_DIP_PORT_NAME,
    WIA_DIP_DEV_NAME,
    WIA_DIP_SERVER_NAME,
    WIA_DIP_REMOTE_DEV_ID,
    WIA_DIP_UI_CLSID,
    WIA_DIP_HW_CONFIG,
    WIA_DIP_BAUDRATE,
    WIA_DIP_STI_GEN_CAPABILITIES,
    WIA_IPA_ITEM_NAME,
    WIA_IPA_FULL_ITEM_NAME,
    WIA_IPA_ITEM_FLAGS,
    WIA_DIP_WIA_VERSION,
    WIA_DIP_DRIVER_VERSION,
};

LPOLESTR g_pszRootItem[NUMROOTITEMPROPS] =
{
    WIA_DIP_DEV_ID_STR,
    WIA_DIP_VEND_DESC_STR,
    WIA_DIP_DEV_DESC_STR,
    WIA_DIP_DEV_TYPE_STR,
    WIA_DIP_PORT_NAME_STR,
    WIA_DIP_DEV_NAME_STR,
    WIA_DIP_SERVER_NAME_STR,
    WIA_DIP_REMOTE_DEV_ID_STR,
    WIA_DIP_UI_CLSID_STR,
    WIA_DIP_HW_CONFIG_STR,
    WIA_DIP_BAUDRATE_STR,
    WIA_DIP_STI_GEN_CAPABILITIES_STR,
    WIA_IPA_ITEM_NAME_STR,
    WIA_IPA_FULL_ITEM_NAME_STR,
    WIA_IPA_ITEM_FLAGS_STR,
    WIA_DIP_WIA_VERSION_STR,
    WIA_DIP_DRIVER_VERSION_STR,
};

#define  WIA_PROP_RWNC (WIA_PROP_RW   | WIA_PROP_NONE | WIA_PROP_CACHEABLE)
#define  WIA_PROP_RNC  (WIA_PROP_READ | WIA_PROP_NONE | WIA_PROP_CACHEABLE)

WIA_PROPERTY_INFO g_wpiRootItem[NUMROOTITEMPROPS] =
{
   {WIA_PROP_RWNC,  VT_BSTR, 0, 0, 0, 0}, // WIA_DIP_DEV_ID
   {WIA_PROP_RNC,  VT_BSTR, 0, 0, 0, 0}, // WIA_DIP_VEND_DESC
   {WIA_PROP_RNC,  VT_BSTR, 0, 0, 0, 0}, // WIA_DIP_DEV_DESC
   {WIA_PROP_RNC,  VT_I4,   0, 0, 0, 0}, // WIA_DIP_DEV_TYPE
   {WIA_PROP_RNC,  VT_BSTR, 0, 0, 0, 0}, // WIA_DIP_PORT_NAME
   {WIA_PROP_RNC,  VT_BSTR, 0, 0, 0, 0}, // WIA_DIP_DEV_NAME
   {WIA_PROP_RWNC, VT_BSTR, 0, 0, 0, 0}, // WIA_DIP_SERVER_NAME
   {WIA_PROP_RWNC, VT_BSTR, 0, 0, 0, 0}, // WIA_DIP_REMOTE_DEV_ID
   {WIA_PROP_RNC,  VT_BSTR, 0, 0, 0, 0}, // WIA_DIP_UI_CLSID
   {WIA_PROP_RNC,  VT_I4,   0, 0, 0, 0}, // WIA_DIP_HW_CONFIG
   {WIA_PROP_RNC,  VT_BSTR, 0, 0, 0, 0}, // WIA_DIP_BAUDRATE
   {WIA_PROP_RNC,  VT_I4,   0, 0, 0, 0}, // WIA_DIP_STI_GEN_CAPABILITIES
   {WIA_PROP_RNC,  VT_BSTR, 0, 0, 0, 0}, // WIA_IPA_ITEM_NAME
   {WIA_PROP_RNC,  VT_BSTR, 0, 0, 0, 0}, // WIA_IPA_FULL_ITEM_NAME
   {WIA_PROP_RNC,  VT_I4,   0, 0, 0, 0}, // WIA_IPA_ITEM_TYPE
   {WIA_PROP_RNC,  VT_BSTR, 0, 0, 0, 0}, // WIA_DIP_WIA_VERSION
   {WIA_PROP_RNC,  VT_BSTR, 0, 0, 0, 0}, // WIA_DIP_DRIVER_VERSION
};

#endif //WIAPROPP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiaevntp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       DevMgr.h
*
*  VERSION:     2.0
*
*  DATE:        May 18, 1999
*
*  DESCRIPTION:
*   Declarations and definitions for the WIA device manager object.
*
*******************************************************************************/

//
// Constants used by Event Notifier
//

#ifdef UNICODE
#define REG_PATH_STILL_IMAGE_CLASS \
    L"System\\CurrentControlSet\\Control\\Class\\{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}"
#define REG_PATH_STILL_IMAGE_CONTROL \
    L"System\\CurrentControlSet\\Control\\StillImage"
#else
#define REG_PATH_STILL_IMAGE_CLASS \
    "System\\CurrentControlSet\\Services\\Class\\Image"
#define REG_PATH_STILL_IMAGE_CONTROL \
    "System\\CurrentControlSet\\Control\\StillImage"
#endif

#define NAME_VAL    TEXT("Name")
#define DESC_VAL    TEXT("Desc")
#define ICON_VAL    TEXT("Icon")
#define CMDLINE_VAL TEXT("Cmdline")
#define DEFAULT_HANDLER_VAL TEXT("DefaultHandler")

//
// Node used to contain information about a specific callback
//

typedef struct  __EventDestNode__
{
    //
    // Linking elements
    //

    struct  __EventDestNode__  *pPrev;
    struct  __EventDestNode__  *pNext;

    //
    // Event callback related fields
    //

    IWiaEventCallback          *pIEventCB;
    BSTR                        bstrDeviceID;
    GUID                        iidEventGUID;
    GUID                        ClsID;
    // Never returned to client in enumeration
    TCHAR                       tszCommandline[MAX_PATH];
    BSTR                        bstrName;
    BSTR                        bstrDescription;
    BSTR                        bstrIcon;
    FILETIME                    timeStamp;

    BOOL                        bDeviceDefault;

} EventDestNode, *PEventDestNode;


/**************************************************************************\
* WIA_EVENT_THREAD_INFO
*
*   Information for event callback thread
*
* Arguments:
*
*
*
*
* History:
*
*    4/9/1999 Original Version
*
\**************************************************************************/

typedef struct __WIAEventThreadInfo__ {
    GUID                        eventGUID;
    BSTR                        bstrEventDescription;
    BSTR                        bstrDeviceID;
    BSTR                        bstrDeviceDescription;
    DWORD                       dwDeviceType;
    BSTR                        bstrFullItemName;
    ULONG                       ulEventType;
    ULONG                       ulReserved;
    IWiaEventCallback          *pIEventCB;
} WIAEventThreadInfo, *PWIAEventThreadInfo;


//
// Implementation of IEventNotifier interface
//
//     Note : the class factory for CEventNotifier must be on the same
//            thread as CWiaDevMgr.
//


//
// Flags to use when searching for callbacks
//

// Ignore STI proxy event matches , look only for exact match
#define FLAG_EN_FINDCB_EXACT_MATCH    0x0001

class CEventNotifier
{
    friend class CWiaDevMgr;
    friend class CWiaInterfaceEvent;

public :
    static HRESULT CreateInstance(const IID& iid, void** ppv);

    //
    // Constructor and Destructor
    //

    CEventNotifier();
    ~CEventNotifier();

    VOID LinkNode(PEventDestNode);
    VOID UnlinkNode(PEventDestNode);

    //
    // Only the WIA device manager is allowed to use this method
    //

    HRESULT RegisterEventCallback(
        LONG                    lFlags,
        BSTR                    bstrDeviceID,
        const GUID             *pEventGUID,
        IWiaEventCallback      *pIWIAEventCallback,
        IUnknown              **ppIEventObj);

    HRESULT RegisterEventCallback(
        LONG                    lFlags,
        BSTR                    bstrDeviceID,
        const GUID             *pEventGUID,
        const GUID             *pClsID,
        LPCTSTR                 ptszCommandline,
        BSTR                    bstrName,
        BSTR                    bstrDescription,
        BSTR                    bstrIcon);

    //
    // Notify a STI event
    //

    HRESULT NotifySTIEvent(
        PWIANOTIFY              pWiaNotify,
        ULONG                   ulEventType,
        BSTR                    bstrFullItemName);
    HRESULT NotifyVolumeEvent(
        PWIANOTIFY_VOLUME       pWiaNotifyVolume);

    //
    // Fire the event
    //

    HRESULT NotifyEvent(
        LONG                    lReason,
        LONG                    lStatus,
        LONG                    lPercentComplete,
        const GUID             *pEventGUID,
        BSTR                    bstrDeviceID,
        LONG                    lReserved);

    //
    // Restore all the persistent Event Callbacks
    //

    HRESULT RestoreAllPersistentCBs();

    //
    // Build enumerator for specific device's persistent handler
    //

    HRESULT CreateEnumEventInfo(
        BSTR                    bstrDeviceID,
        const GUID             *pEventGUID,
        IEnumWIA_DEV_CAPS     **ppIEnumDevCap);

    //
    // Find the total number of persistent handlers and the default one
    //

    HRESULT GetNumPersistentHandlerAndDefault(
        BSTR                    bstrDeviceID,
        const GUID             *pEventGUID,
        ULONG                  *pulNumHandlers,
        EventDestNode         **ppDefaultNode);

    //
    // Restore specific devices' persistent Event Callbacks
    //

    HRESULT RestoreDevPersistentCBs(
        HKEY                    hParentOfEventKey);

private :

    //
    // Utility functions
    //

    HRESULT RegisterEventCB(
        BSTR                    bstrDeviceID,
        const GUID             *pEventGUID,
        IWiaEventCallback      *pIWiaEventCallback,
        IUnknown              **pEventObj);

    HRESULT RegisterEventCB(
        BSTR                    bstrDeviceID,
        const GUID             *pEventGUID,
        const GUID             *pClsID,
        LPCTSTR                 ptszCommandline,
        BSTR                    bstrName,
        BSTR                    bstrDescription,
        BSTR                    bstrIcon,
        FILETIME               &fileTime,
        BOOL                    bIsDefault = FALSE);

    HRESULT UnregisterEventCB(PEventDestNode);

    HRESULT UnregisterEventCB(
        BSTR                    bstrDeviceID,
        const GUID             *pEventGUID,
        const GUID             *pClsID,
        BOOL                   *pbUnRegCOMServer);

    PEventDestNode FindEventCBNode(
        UINT                    uiFlags,
        BSTR                    bstrDeviceID,
        const GUID             *pEventGUID,
        IWiaEventCallback      *pIWiaEventCallback);

    PEventDestNode FindEventCBNode(
        UINT                    uiFlags,
        BSTR                    bstrDeviceID,
        const GUID             *pEventGUID,
        const GUID             *pClsID);

    HRESULT FindCLSIDForCommandline(
        LPCTSTR                 ptszCommandline,
        CLSID                  *pClsID);

    HRESULT SavePersistentEventCB(
        BSTR                    bstrDeviceID,
        const GUID             *pEventGUID,
        const GUID             *pClsid,
        LPCTSTR                 ptszCommandline,
        BSTR                    bstrName,
        BSTR                    bstrDescription,
        BSTR                    bstrIcon,
        BOOL                   *pbCreatedKey,
        ULONG                  *pulNumExistingHandlers,
        BOOL                    bMakeDefault = FALSE);

    HRESULT DelPersistentEventCB(
        BSTR                    bstrDeviceID,
        const GUID             *pEventGUID,
        const GUID             *pClsid,
        BOOL                    bUnRegCOMServer);

    HRESULT FindEventByGUID(
        BSTR                    bstrDeviceID,
        const GUID             *pEventGUID,
        HKEY                   *phEventKey);

    //
    // Fire an event asynchronously
    //

    HRESULT FireEventAsync(
        PWIAEventThreadInfo     pMasterInfo);

    //
    // Start the callback program
    //

    HRESULT StartCallbackProgram(
        EventDestNode          *pCBNode,
        PWIAEventThreadInfo     pMasterInfo);

private :

    ULONG                       m_ulRef;

    //
    // Double-linked list containing all the parties interested in Event CB
    //

    EventDestNode              *m_pEventDestNodes;
};


/**************************************************************************\
* CWiaInterfaceEvent
*
*   This object is created when an application calls
*   RegisterForEventInterface. When this object is released, the
*   registered event is unregistered.
*
* History:
*
*    5/18/1999 Original Version
*
\**************************************************************************/

class CWiaInterfaceEvent : public IUnknown
{

    //
    // IUnknown methods
    //

public:

    HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

    //
    // private function
    //


    CWiaInterfaceEvent(PEventDestNode);
    ~CWiaInterfaceEvent();

private:

    //
    // member elements
    //

    ULONG                       m_cRef;
    PEventDestNode              m_pEventDestNode;
};

/**************************************************************************\
* CWiaEventContext
*
*   This object is created when an event is queued as scheduler item
*
* History:
*
*    5/18/1999 Original Version
*
\**************************************************************************/

class CWiaEventContext : public IUnknown
{

public:

    //
    // IUnknown methods
    //

    HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

    //
    // Constructor /Destructor
    //

    CWiaEventContext(
        BSTR                    bstrDeviceID,
        const GUID             *pGuidEvent,
        BSTR                    bstrFullItemName);
    ~CWiaEventContext();

public:

    //
    // Data members
    //

    ULONG                       m_cRef;
    BSTR                        m_bstrDeviceId;
    GUID                        m_guidEvent;
    BSTR                        m_bstrFullItemName;
    ULONG                       m_ulEventType;
};


extern CEventNotifier           g_eventNotifier;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiaprivd.h ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiaprivd.h
*
*  VERSION:     1.0
*
*  DATE:        14 Jan, 2000
*
*  DESCRIPTION:
*   Header file used to define private WIA classes, constants and globals.
*
******************************************************************************/

#pragma once

#define LOCAL_DEVICE_STR L"local"

//
// Exception handling covers for mini-driver entry points.  Defined in helpers
//

HRESULT _stdcall LockWiaDevice(IWiaItem*);
HRESULT _stdcall UnLockWiaDevice(IWiaItem*);

class CWiaDrvItem;
class CWiaTree;
class CWiaPropStg;
class CWiaRemoteTransfer;

//**************************************************************************
//  class CWiaItem
//
//
//
//
// History:
//
//    11/6/1998 Original Version
//
//**************************************************************************

#define CWIAITEM_SIG 0x49616957     // CWiaItem debug signature: "WiaI"

#define DELETE_ITEM  0              // UpdateWiaItemTree flags
#define ADD_ITEM     1

//
//  Item internal flag values
//
#define ITEM_FLAG_DRV_UNINITIALIZE_THROWN   1   

class CWiaItem :    public IWiaItem,
                    public IWiaPropertyStorage,
                    public IWiaDataTransfer,
                    public IWiaItemExtras,
                    public IWiaItemInternal
{

    //
    // IUnknown methods
    //

public:
    HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
    ULONG   _stdcall AddRef(void);
    ULONG   _stdcall Release(void);

    //
    // IWiaItem methods
    //

    virtual HRESULT _stdcall GetItemType(LONG*);
    HRESULT _stdcall EnumChildItems(IEnumWiaItem**);
    HRESULT _stdcall AnalyzeItem(LONG);
    HRESULT _stdcall DeleteItem(LONG);
    HRESULT _stdcall CreateChildItem(LONG, BSTR, BSTR, IWiaItem**);
    HRESULT _stdcall GetRootItem(IWiaItem**);
    HRESULT _stdcall DeviceCommand(LONG, const GUID*, IWiaItem**);
    HRESULT _stdcall DeviceDlg(HWND, LONG, LONG, LONG*, IWiaItem***);
    HRESULT _stdcall FindItemByName(LONG, BSTR, IWiaItem**);
    HRESULT _stdcall EnumRegisterEventInfo(LONG, const GUID *, IEnumWIA_DEV_CAPS**);
    HRESULT _stdcall EnumDeviceCapabilities(LONG, IEnumWIA_DEV_CAPS**);
    HRESULT _stdcall Diagnostic(ULONG, BYTE*);

    //
    // IWiaPropertyStorage methods
    //

    HRESULT _stdcall ReadMultiple(
        ULONG,
        const PROPSPEC[],
        PROPVARIANT[]);

    HRESULT _stdcall WriteMultiple(
        ULONG,
        const PROPSPEC[],
        const PROPVARIANT[],
        PROPID);

    HRESULT _stdcall ReadPropertyNames(
        ULONG,
        const PROPID[],
        LPOLESTR[]);

    HRESULT _stdcall WritePropertyNames(
        ULONG,
        const PROPID[],
        const LPOLESTR[]);

    HRESULT _stdcall Enum(IEnumSTATPROPSTG**);

    HRESULT _stdcall GetPropertyAttributes(
        ULONG,
        PROPSPEC[],
        ULONG[],
        PROPVARIANT[]);

    HRESULT _stdcall GetPropertyStream(
         GUID*,
         LPSTREAM*);

    HRESULT _stdcall SetPropertyStream(
         GUID*,
         LPSTREAM);

    HRESULT _stdcall GetCount(
        ULONG*);

    HRESULT _stdcall DeleteMultiple(
         ULONG cpspec,
         PROPSPEC const rgpspec[]);

    HRESULT _stdcall DeletePropertyNames(
         ULONG cpropid,
         PROPID const rgpropid[]);

    HRESULT _stdcall SetClass(
         REFCLSID clsid);

    HRESULT _stdcall Commit(
         DWORD  grfCommitFlags);

    HRESULT _stdcall Revert();

    HRESULT _stdcall Stat(
         STATPROPSETSTG *pstatpsstg);

    HRESULT _stdcall SetTimes(
         FILETIME const * pctime,
         FILETIME const * patime,
         FILETIME const * pmtime);

    //
    // IBandedTransfer methods
    //

    HRESULT _stdcall idtGetBandedData(PWIA_DATA_TRANSFER_INFO, IWiaDataCallback *);
    HRESULT _stdcall idtGetData(LPSTGMEDIUM, IWiaDataCallback*);
    HRESULT _stdcall idtQueryGetData(WIA_FORMAT_INFO*);
    HRESULT _stdcall idtEnumWIA_FORMAT_INFO(IEnumWIA_FORMAT_INFO**);
    HRESULT _stdcall idtGetExtendedTransferInfo(PWIA_EXTENDED_TRANSFER_INFO);

    //
    // IWiaItemExtras methods
    //

    HRESULT _stdcall GetExtendedErrorInfo(BSTR *);
    HRESULT _stdcall Escape(DWORD, BYTE *, DWORD, BYTE *, DWORD, DWORD *);
    HRESULT _stdcall CancelPendingIO();

    //
    // IWiaItemInternal methods
    //

    HRESULT _stdcall SetCallbackBufferInfo(WIA_DATA_CB_BUF_INFO  DataCBBufInfo);
    HRESULT _stdcall GetCallbackBufferInfo(WIA_DATA_CB_BUF_INFO  *pDataCBBufInfo);

    HRESULT _stdcall idtStartRemoteDataTransfer();
    HRESULT _stdcall CWiaItem::idtRemoteDataTransfer(
        ULONG nNumberOfBytesToRead,
        ULONG *pNumberOfBytesRead,
        BYTE *pBuffer,
        LONG *pOffset,
        LONG *pMessage,
        LONG *pStatus,
        LONG *pPercentComplete);
    HRESULT _stdcall idtStopRemoteDataTransfer();

    //
    // Driver helpers, not part of any interface.
    //

    CWiaTree*    _stdcall GetTreePtr(void);
    CWiaDrvItem* _stdcall GetDrvItemPtr(void);
    HRESULT      _stdcall WriteItemPropNames(LONG, PROPID *, LPOLESTR *);
    HRESULT      _stdcall GetItemPropStreams(IPropertyStorage **, IPropertyStorage **, IPropertyStorage **, IPropertyStorage **);
    HRESULT      _stdcall UpdateWiaItemTree(LONG, CWiaDrvItem*);
    HRESULT      _stdcall SendEndOfPage(LONG, PMINIDRV_TRANSFER_CONTEXT);

protected:

    //
    // banded transfer private methods
    //

    HRESULT _stdcall idtFreeTransferBufferEx(void);
    HRESULT _stdcall idtAllocateTransferBuffer(PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo);

    //
    // Private helper methods
    //

    HRESULT _stdcall UnlinkChildAppItemTree(LONG);
    HRESULT _stdcall UnlinkAppItemTree(LONG);
    HRESULT _stdcall BuildWiaItemTreeHelper(CWiaDrvItem*, CWiaTree*);
    HRESULT _stdcall BuildWiaItemTree(IWiaPropertyStorage*);
    HRESULT _stdcall InitWiaManagedItemProperties(IWiaPropertyStorage *pIWiaDevInfoProps);
    HRESULT _stdcall InitRootProperties(IWiaPropertyStorage*);
    HRESULT _stdcall SetMiniDrvItemProperties(PMINIDRV_TRANSFER_CONTEXT);
    HRESULT _stdcall SendDataHeader(LONG, PMINIDRV_TRANSFER_CONTEXT);
    HRESULT _stdcall SendOOBDataHeader(LONG, PMINIDRV_TRANSFER_CONTEXT);
    HRESULT _stdcall AcquireMiniDrvItemData(PMINIDRV_TRANSFER_CONTEXT);
    HRESULT _stdcall GetData(STGMEDIUM*, IWiaDataCallback*,PMINIDRV_TRANSFER_CONTEXT);
    HRESULT _stdcall GetDataBanded(PWIA_DATA_TRANSFER_INFO, IWiaDataCallback*, PMINIDRV_TRANSFER_CONTEXT);
    HRESULT _stdcall CommonGetData(STGMEDIUM*, PWIA_DATA_TRANSFER_INFO, IWiaDataCallback*);
    HRESULT _stdcall DumpItemData(BSTR*);
    HRESULT _stdcall DumpDrvItemData(BSTR*);
    HRESULT _stdcall DumpTreeItemData(BSTR*);
    HRESULT _stdcall InitLazyProps(BOOL = TRUE);
    HRESULT _stdcall AddVolumePropertiesToRoot(ACTIVE_DEVICE *pActiveDevice);

    //
    // Constructor, initialization and destructor methods.
    //

public:
    CWiaItem();
    virtual HRESULT _stdcall Initialize(
                                IWiaItem*,
                                IWiaPropertyStorage*,
                                ACTIVE_DEVICE*,
                                CWiaDrvItem*,
                                IUnknown* = NULL);
    ~CWiaItem();

    //
    // Misc. members
    //

    ULONG                   m_ulSig;                   // Object signature.
    CWiaTree                *m_pCWiaTree;              // Backing WIA tree item.
    BOOL                    m_bInitialized;            // Needed for lazy initialization
    BYTE                    *m_pICMValues;             // Cached ICM property values
    LONG                    m_lICMSize;                // Size of ICM values
    ACTIVE_DEVICE           *m_pActiveDevice;          // ptr to Device object.
    LONG                    m_lLastDevErrVal;          // Value of last device error
    LONG                    m_lInternalFlags;          // Internal flag value

protected:
    ULONG                   m_cRef;                    // Reference count for this object.
    ULONG                   m_cLocalRef;               // Local reference count for this object.
    CWiaDrvItem             *m_pWiaDrvItem;            // device item object
    IUnknown                *m_pIUnknownInner;         // Inner unknown for blind aggregation.

    //
    //  saved interface pointers
    //

    IWiaItem                *m_pIWiaItemRoot;          // owning device

    //
    // application properties
    //

    CWiaPropStg             *m_pPropStg;                // Wia Property Storage Class

    //
    // IWiaDataTransfer members
    //

    WIA_DATA_CB_BUF_INFO    m_dcbInfo;
    HANDLE                  m_hBandSection;
    PBYTE                   m_pBandBuffer;
    LONG                    m_lBandBufferLength;
    LONG                    m_ClientBaseAddress;
    BOOL                    m_bMapSection;
    ULONG                   m_cwfiBandedTran;           // Number of FORMATETCs in use for IBandedTransfer
    WIA_FORMAT_INFO         *m_pwfiBandedTran;          // Source of FORMATETCs for IBandedTransfer
    MINIDRV_TRANSFER_CONTEXT m_mdtc;                    // transfer context
    CWiaRemoteTransfer      *m_pRemoteTransfer;         // remote transfer support
};

//**************************************************************************
//  class CGenWiaItem
//
//      This class implements the IWiaItem interface for generated items.
//
//
// History:
//
//  14 Jan, 2000    -   Original version
//
//**************************************************************************

class CGenWiaItem : public CWiaItem
{
public:

    //
    //  CWiaItem methods overridden for Generated items
    //

    HRESULT _stdcall Initialize(
                        IWiaItem*,
                        IWiaPropertyStorage*,
                        ACTIVE_DEVICE*,
                        CWiaDrvItem*,
                        IUnknown* = NULL);

    HRESULT _stdcall GetItemType(LONG*);

    //
    //  Helper methods
    //

    HRESULT _stdcall InitManagedItemProperties(
        LONG        lFlags,
        BSTR        bstrItemName,
        BSTR        bstrFullItemName);

protected:
    LONG            m_lItemType;                        //  Item type flags
};


//**************************************************************************
//
// CWiaMiniDrvCallBack
//
//    This class is used by the driver services to callback to the client
//
//
// History:
//
//    11/12/1998 Original Version
//
//**************************************************************************

class CWiaMiniDrvCallBack : public IWiaMiniDrvCallBack
{
    //
    // IUnknown methods
    //

public:
    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

    //
    // IWiaMiniDrvCallBack methods
    //

    HRESULT _stdcall MiniDrvCallback(
                                    LONG,
                                    LONG,
                                    LONG,
                                    LONG,
                                    LONG,
                                    PMINIDRV_TRANSFER_CONTEXT,
                                    LONG);

    //
    // Constructor, initialization and destructor methods.
    //

    CWiaMiniDrvCallBack();
    HRESULT Initialize(PMINIDRV_TRANSFER_CONTEXT, IWiaDataCallback *);
    ~CWiaMiniDrvCallBack();

    //
    // Misc. members
    //

private:
    ULONG                       m_cRef;                     // Object reference count.
    IWiaDataCallback*           m_pIWiaDataCallback;        // Client callback interface pointer
    MINIDRV_TRANSFER_CONTEXT    m_mdtc;                     // transfer info
    HANDLE                      m_hThread;                  // callback thread
    DWORD                       m_dwThreadID;               // callback thread ID
    WIA_DATA_THREAD_INFO        m_ThreadInfo;               // thread info
};

//**************************************************************************
//  APP_ITEM_LIST_EL
//
//   Applictation item list element. Used by driver items to keep track
//   of their corresponding app items.
//
// History:
//
//    9/1/1998   - Initial Version
//
//**************************************************************************

typedef struct _APP_ITEM_LIST_EL {
    LIST_ENTRY ListEntry;               // Linked list management.
    CWiaItem   *pCWiaItem;              // Applictation item.
} APP_ITEM_LIST_EL, *PAPP_ITEM_LIST_EL;

//**************************************************************************
//
//  Driver Item Object
//
//
// Elements:
//
//
// History:
//
//    9/1/1998   - Initial Version
//
//**************************************************************************

#define CWIADRVITEM_SIG 0x44616957     // CWiaDrvItem debug signature: "WiaD"

class CWiaDrvItem : public IWiaDrvItem
{
    //
    // IUnknown methods
    //

public:

    HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
    ULONG   _stdcall AddRef(void);
    ULONG   _stdcall Release(void);

    //
    // Object Constructor/Initialization/Destructor methods
    //

    CWiaDrvItem();
    HRESULT  _stdcall Initialize(LONG,BSTR,BSTR,IWiaMiniDrv*,LONG,BYTE**);
    ~CWiaDrvItem();

    //
    // IWiaDrvItem interface, supports driver item list management.
    //

    HRESULT _stdcall GetItemFlags(LONG*);
    HRESULT _stdcall GetDeviceSpecContext(BYTE**);
    HRESULT _stdcall AddItemToFolder(IWiaDrvItem*);
    HRESULT _stdcall RemoveItemFromFolder(LONG);
    HRESULT _stdcall UnlinkItemTree(LONG);
    HRESULT _stdcall GetFullItemName(BSTR*);
    HRESULT _stdcall GetItemName(BSTR*);
    HRESULT _stdcall FindItemByName(LONG, BSTR, IWiaDrvItem**);
    HRESULT _stdcall FindChildItemByName(BSTR, IWiaDrvItem**);
    HRESULT _stdcall GetParentItem(IWiaDrvItem**);
    HRESULT _stdcall GetFirstChildItem(IWiaDrvItem**);
    HRESULT _stdcall GetNextSiblingItem(IWiaDrvItem**);
    HRESULT _stdcall DumpItemData(BSTR*);

    //
    // Class driver helpers, not part of any interface.
    //

    virtual HRESULT _stdcall LinkToDrvItem(CWiaItem*);
    virtual HRESULT _stdcall UnlinkFromDrvItem(CWiaItem*);

    HRESULT _stdcall CallDrvUninitializeForAppItems(ACTIVE_DEVICE   *pActiveDevice);

    VOID SetActiveDevice(ACTIVE_DEVICE *pActiveDevice)
    {
        //
        //  No need to AddRef here, since the ActiveDevice will always outlive
        //  us...
        //
        m_pActiveDevice = pActiveDevice;
    }
private:

    //
    // private helper functions
    //

    HRESULT _stdcall AllocDeviceSpecContext(LONG, PBYTE*);
    HRESULT _stdcall FreeDeviceSpecContext(void);

    //
    // member data
    //

public:
    ULONG           m_ulSig;                // Object signature.
    BYTE            *m_pbDrvItemContext;    // ptr to device specific context.
    IWiaMiniDrv     *m_pIWiaMiniDrv;        // ptr to Device object.
    ACTIVE_DEVICE   *m_pActiveDevice;       // ptr to Active Device object.

private:
    ULONG           m_cRef;                 // Reference count for this object.
    CWiaTree        *m_pCWiaTree;           // Backing WIA tree item.
    LIST_ENTRY      m_leAppItemListHead;    // Head of corresponding app items list.
};

//**************************************************************************
//
//  WIA Tree Object
//
//
// Elements:
//
//
// History:
//
//    4/27/1999 - Initial Version
//
//**************************************************************************

typedef VOID (* PFN_UNLINK_CALLBACK)(VOID *pData);


#define CWIATREE_SIG 0x44616954     // CWiaTree debug signature: "WiaT"

class CWiaTree
{

public:

    CWiaTree();
    HRESULT _stdcall Initialize(LONG, BSTR, BSTR, void*);
    ~CWiaTree();

    HRESULT _stdcall AddItemToFolder(CWiaTree*);
    HRESULT _stdcall RemoveItemFromFolder(LONG);
    HRESULT _stdcall UnlinkItemTree(LONG, PFN_UNLINK_CALLBACK = NULL);
    HRESULT _stdcall GetFullItemName(BSTR*);
    HRESULT _stdcall GetItemName(BSTR*);
    HRESULT _stdcall FindItemByName(LONG, BSTR, CWiaTree**);
    HRESULT _stdcall FindChildItemByName(BSTR, CWiaTree**);
    HRESULT _stdcall GetParentItem(CWiaTree**);
    HRESULT _stdcall GetFirstChildItem(CWiaTree**);
    HRESULT _stdcall GetNextSiblingItem(CWiaTree**);
    HRESULT _stdcall DumpTreeData(BSTR*);
    //HRESULT _stdcall DumpAllTreeData();

    CWiaTree * _stdcall GetRootItem(void);

    inline HRESULT  _stdcall CWiaTree::GetItemFlags(LONG *plFlags)
    {
        if (plFlags) {
            *plFlags = m_lFlags;
            return S_OK;
        }
        else {
            return E_POINTER;
        }
    }

    inline HRESULT _stdcall GetItemData(void **ppData)
    {
        if (ppData) {
            *ppData = m_pData;
            return S_OK;
        }
        else {
            return E_POINTER;
        }
    }

    inline HRESULT _stdcall SetItemData(void *pData)
    {
        m_pData = pData;
        return S_OK;
    }

    inline HRESULT _stdcall SetFolderFlags()
    {
        m_lFlags = (m_lFlags | WiaItemTypeFolder) & ~WiaItemTypeFile;
        return S_OK;
    }

    inline HRESULT _stdcall SetFileFlags()
    {
        m_lFlags = (m_lFlags | WiaItemTypeFile) & ~WiaItemTypeFolder;
        return S_OK;
    }

private:

    //
    // private helper functions
    //

    HRESULT _stdcall UnlinkChildItemTree(LONG, PFN_UNLINK_CALLBACK = NULL);
    HRESULT _stdcall AddChildItem(CWiaTree*);
    HRESULT _stdcall AddItemToLinearList(CWiaTree*);
    HRESULT _stdcall RemoveItemFromLinearList(CWiaTree*);

    //
    // member data
    //

public:
    ULONG                   m_ulSig;            // Object signature.

private:
    LONG                    m_lFlags;           // item flags
    CWiaTree                *m_pNext;           // next item (sibling)
    CWiaTree                *m_pPrev;           // prev item (sibling)
    CWiaTree                *m_pParent;         // parent item
    CWiaTree                *m_pChild;          // child item
    CWiaTree                *m_pLinearList;     // single linked list of all items
    BSTR                    m_bstrItemName;     // item name
    BSTR                    m_bstrFullItemName; // item name for searching
    void                    *m_pData;           // pay load
    CRITICAL_SECTION        m_CritSect;         // Critical section
    BOOL                    m_bInitCritSect;    // Critical section initialization flag
};

//
//  Helper classes
//

//
//  Helper class to lock/unlock WIA devices.  Note that this helper class will
//  record the return code (in phr), but does not log any errors.  Logging is
//  left up to the caller.
//

class LOCK_WIA_DEVICE
{
public:

    //
    //  This constructor will lock the device
    //
    LOCK_WIA_DEVICE(CWiaItem    *pItem,
                    HRESULT     *phr
                    )
    {
        LONG    lDevErrVal = 0;

        m_bDeviceIsLocked = FALSE;
        m_pItem           = NULL;


        if (pItem) {
            if (pItem->m_pActiveDevice) {
                *phr = pItem->m_pActiveDevice->m_DrvWrapper.WIA_drvLockWiaDevice((BYTE*) pItem, 0, &lDevErrVal);
                if (SUCCEEDED(*phr)) {
                    //
                    //  Mark that the device is locked, so we can unlock it in the destructor
                    //

                    m_bDeviceIsLocked   = TRUE;
                    m_pItem             = pItem;
                } else {
                    DBG_TRC(("LOCK_WIA_DEVICE, failed to lock device"));
                }
            } else {
                DBG_TRC(("LOCK_WIA_DEVICE, Item's ACTIVE_DEVICE is NULL"));
            }
        } else {
            DBG_TRC(("LOCK_WIA_DEVICE, Item is NULL"));
        }
    };

    //
    //  Sometimes, we only want to lock the device if we are told at run-time e.g.
    //  if the device is already locked, we don't need/want to lock it again.
    //
    LOCK_WIA_DEVICE(BOOL        bLockDevice,
                    CWiaItem    *pItem,
                    HRESULT     *phr
                    )
    {
        m_bDeviceIsLocked = FALSE;
        if (bLockDevice) {

            LONG    lDevErrVal = 0;
            //
            //  NOTE:  There seems to be some sort of compiler error if we call the
            //  other constructor from here.  The code genereated messes up the
            //  stack (almost like mismatched calling conventions).  To get around
            //  that, we simply duplicate the code.
            //

            m_pItem           = NULL;

            if (pItem) {
                if (pItem->m_pActiveDevice) {
                    *phr = pItem->m_pActiveDevice->m_DrvWrapper.WIA_drvLockWiaDevice((BYTE*) pItem, 0, &lDevErrVal);
                    if (SUCCEEDED(*phr)) {
                        //
                        //  Mark that the device is locked, so we can unlock it in the destructor
                        //

                        m_bDeviceIsLocked   = TRUE;
                        m_pItem             = pItem;
                    }
                }
            }
        }
    };

    //
    //  The destructor will unlock the device if it has been locked
    //
    ~LOCK_WIA_DEVICE()
    {
        if (m_bDeviceIsLocked) {

            LONG    lDevErrVal = 0;

            //
            // Notice that we don't care if we failed to unlock
            //
            m_pItem->m_pActiveDevice->m_DrvWrapper.WIA_drvUnLockWiaDevice((BYTE*) m_pItem, 0, &lDevErrVal);
        }
    };

private:
    BOOL        m_bDeviceIsLocked;
    CWiaItem    *m_pItem;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiapsc.h ===
/*****************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       wiapsc.h
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        2 June, 1999
*
*  DESCRIPTION:
*   Declarations and definitions for the WIA Property Storage class.
*   This class contains the IProperty storages used for an item's
*   properties (current value, old value, valid values and access flags).
*
*****************************************************************************/

#define NUM_PROP_STG    7
#define NUM_BACKUP_STG  4

//
//  These defines indicate the index in which the specified property storage
//  and stream reside in the arrays i.e. m_pIPropStg[WIA_VALID_STG] will give
//  a pointer to the valid value storage, and m_pIStream[WIA_OLD_STG] will 
//  give the pointer to the backing stream used by the old value property 
//  storage.  The normal storage indexes run from top to bottom, while their
//  corresponding backup storage indexes run from bottom to top - this is
//  to simplify the implementation of Backup()
//

#define WIA_CUR_STG     0
#define WIA_VALID_STG   1
#define WIA_ACCESS_STG  2
#define WIA_OLD_STG     3

#define WIA_ACCESS_BAK  4
#define WIA_VALID_BAK   5
#define WIA_CUR_BAK     6

#define WIA_NUM_PROPS_ID 111111
class CWiaPropStg {
public:

    //
    //  Methods to get a property storage/stream
    //

    IPropertyStorage* _stdcall CurStg();    //  Current value storage
    IPropertyStorage* _stdcall OldStg();    //  Old value storage
    IPropertyStorage* _stdcall ValidStg();  //  Valid value storage
    IPropertyStorage* _stdcall AccessStg(); //  Access flags storage
    
    IStream* _stdcall CurStm();    //  Returns stream for Current values
    IStream* _stdcall OldStm();    //  Returns stream for Old values
    IStream* _stdcall ValidStm();  //  Returns stream for Valid values
    IStream* _stdcall AccessStm(); //  Returns stream for Access flags

    //
    //  Methods used in WriteMultiple.  
    //

    HRESULT _stdcall NamesToPropIDs(
        LONG                celt,
        PROPSPEC            *pPropSpecIn,
        PROPSPEC            **ppPropSpecOut);
    HRESULT _stdcall GetPropIDFromName(
        PROPSPEC            *pPropSpecIn,
        PROPSPEC            *pPropSpecOut);
    HRESULT _stdcall CheckPropertyAccess(
        BOOL                bShowErrors,
        LONG                cpspec,
        PROPSPEC            *rgpspec);
    HRESULT _stdcall CheckPropertyType(
        IPropertyStorage    *pIPropStg,
        LONG                cpspec,
        PROPSPEC            *rgpspec,
        PROPVARIANT         *rgpvar);

    HRESULT _stdcall Backup();
    HRESULT _stdcall Undo();
    HRESULT _stdcall ReleaseBackups();

    //
    //  Other public methods
    //

    HRESULT _stdcall WriteItemPropNames(
        LONG                cItemProps,
        PROPID              *ppId,
        LPOLESTR            *ppszNames);
    HRESULT _stdcall GetPropertyStream(
        GUID                *pCompatibilityId,
        LPSTREAM            *ppstmProp);
    HRESULT _stdcall SetPropertyStream(
        GUID                *pCompatibilityId,
        IWiaItem            *pItem,   
        LPSTREAM            pstmProp);
    
    CWiaPropStg();
    HRESULT _stdcall Initialize();
    ~CWiaPropStg();

private:

    //
    //  Private helpers
    //

    HRESULT CopyItemProp(
        IPropertyStorage    *pIPropStgSrc,
        IPropertyStorage    *pIPropStgDst,
        PROPSPEC            *pps,
        LPSTR               pszErr);
    HRESULT CopyProps(
        IPropertyStorage    *src, 
        IPropertyStorage    *dest);
    HRESULT CreateStorage(
        ULONG ulIndex);
    HRESULT CopyRWStreamProps(
        LPSTREAM            pstmPropSrc, 
        LPSTREAM            pstmPropDst,
        GUID                *pCompatibilityId);
    HRESULT GetPropsFromStorage(
        IPropertyStorage    *pSrc,
        ULONG               *cPSpec,
        PROPSPEC            **ppPSpec,
        PROPVARIANT         **ppVar);

    //
    //  member variables
    //

    IPropertyStorage    *m_pIPropStg[NUM_PROP_STG]; // Array of Property storages 
    IStream             *m_pIStream[NUM_PROP_STG];  // Array of Streams for the Prop storages
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiapsc.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       wiapsc.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        2 June, 1999
*
*  DESCRIPTION:
*   Implementation for the WIA Property Storage class.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include <wiamindr.h>


#include "helpers.h"
#include "wiapsc.h"


/**************************************************************************\
* CurStg
*
*   Returns the IPropertyStorage used to store the current property values.
*
* Arguments:
*
*
* Return Value:
*
*    IPropertyStorage for current values.
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

IPropertyStorage* _stdcall CWiaPropStg::CurStg()
{
    return m_pIPropStg[WIA_CUR_STG];
}

/**************************************************************************\
* CurStm
*
*   Returns the IStream used to store the current property values.
*
* Arguments:
*
*
* Return Value:
*
*    IStream for current values.
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

IStream* _stdcall CWiaPropStg::CurStm()
{
    return m_pIStream[WIA_CUR_STG];
}

/**************************************************************************\
* OldStg
*
*   Returns the IPropertyStorage used to store the old property values.
*
* Arguments:
*
*
* Return Value:
*
*    IPropertyStorage for old values.
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

IPropertyStorage* _stdcall CWiaPropStg::OldStg()
{
    return m_pIPropStg[WIA_OLD_STG];
}

/**************************************************************************\
* OldStm
*
*   Returns the IStream used to store the old property values.
*
* Arguments:
*
*
* Return Value:
*
*    IStream for old values.
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

IStream* _stdcall CWiaPropStg::OldStm()
{
    return m_pIStream[WIA_OLD_STG];
}

/**************************************************************************\
* ValidStg
*
*   Returns the IPropertyStorage used to store the valid values.
*
* Arguments:
*
*
* Return Value:
*
*    IPropertyStorage for valid values.
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

IPropertyStorage* _stdcall CWiaPropStg::ValidStg()
{
    return m_pIPropStg[WIA_VALID_STG];
}

/**************************************************************************\
* ValidStm
*
*   Returns the IStream used to store the current property values.
*
* Arguments:
*
*
* Return Value:
*
*    IStream for valid values.
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

IStream* _stdcall CWiaPropStg::ValidStm()
{
    return m_pIStream[WIA_VALID_STG];
}

/**************************************************************************\
* AccessStg
*
*   Returns the IPropertyStorage used to store the access flags.
*
* Arguments:
*
*
* Return Value:
*
*    IPropertyStorage for access values.
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

IPropertyStorage* _stdcall CWiaPropStg::AccessStg()
{
    return m_pIPropStg[WIA_ACCESS_STG];
}

/**************************************************************************\
* AccessStm
*
*   Returns the IStream used to store the access flag values.
*
* Arguments:
*
*
* Return Value:
*
*    IStream for access values.
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

IStream* _stdcall CWiaPropStg::AccessStm()
{
    return m_pIStream[WIA_ACCESS_STG];
}

/**************************************************************************\
* Backup
*
*   This sets the backup storages and sets the old value storage.  The
*   backup storages are created here, but are released when either
*   Undo() or Save() are called (since they're no longer needed until the
*   next call to Backup()).
*
* Arguments:
*
*
* Return Value:
*
*    Status         -   S_OK if successful
*                   -   Error returns are those returned by CreateStorage
*                       and CopyProps
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaPropStg::Backup()
{
    HRESULT hr = S_OK;
    ULONG   ulIndexOfBackup;

    for (int lIndex = 0; lIndex < NUM_BACKUP_STG; lIndex++) {

        //
        //  The normal storage indexes run from top to bottom, while their
        //  corresponding backup storage indexes run from bottom to top -
        //  this is to simplify the implementation of Backup()
        //

        ulIndexOfBackup = NUM_PROP_STG - (lIndex + 1);

        //
        //  Create the corresponding backup storage.
        //

        hr = CreateStorage(ulIndexOfBackup);
        if (SUCCEEDED(hr)) {

            //
            //  Make the backup copy.
            //

            hr = CopyProps(m_pIPropStg[lIndex],
                           m_pIPropStg[ulIndexOfBackup]);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaPropStg::Backup, CopyProps failed"));
                break;
            }
        } else {
            break;
        }
    }

    if (SUCCEEDED(hr)) {

        //
        //  Backups worked, so set the old property values to the
        //  current property values.
        //

        hr = CopyProps(CurStg(), OldStg());
        if (FAILED(hr)) {
            DBG_ERR(("CWiaPropStg::Backup, Could not set old values"));
        }
    }

    if (FAILED(hr)) {

        //
        //  There was a failure, so clean up
        //

        ReleaseBackups();
    }

    return hr;
}


/**************************************************************************\
* Undo
*
*   This method is called if the properties fail validation and need to be
*   restored to their previous values.  The backup storages are then
*   released.
*
* Arguments:
*
*
* Return Value:
*
*   Status         -
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaPropStg::Undo()
{
    HRESULT hr = S_OK;
    ULONG   ulIndexOfBackup;

    for (int lIndex = 0; lIndex < NUM_BACKUP_STG; lIndex++) {

        //
        //  Restore the backup copy.
        //

        ulIndexOfBackup = NUM_PROP_STG - (lIndex + 1);
        hr = CopyProps(m_pIPropStg[ulIndexOfBackup],
                       m_pIPropStg[lIndex]);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaPropStg::Undo, CopyProps failed"));
            break;
        }
    }

    ReleaseBackups();

    return hr;
}

/**************************************************************************\
* Initialize
*
*   This method is called to set up the property streams and storages.
*   If the any of the creation fails, CleanUp() is called.
*
* Arguments:
*
*
* Return Value:
*
*   Status      -   S_OK if successful
*               -   E_OUTOFMEMORY if not enough memory
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaPropStg::Initialize()
{
    HRESULT hr = S_OK;

    for (int lIndex = 0; lIndex < (NUM_PROP_STG - NUM_BACKUP_STG); lIndex++) {

        hr = CreateStorage(lIndex);
        if (FAILED(hr)) {
            break;
        }
    }

    return hr;
}


/**************************************************************************\
* ReleaseBackups
*
*   This frees all resources used by the backup storages.
*
* Arguments:
*
*
* Return Value:
*
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaPropStg::ReleaseBackups()
{
    LONG    lIndex;

    //
    //  Release the property storages and property streams.  Start at the
    //  last element in the array, and work up until the number of
    //  backup storages has been reached.
    //  The normal storage indexes run from top to bottom, while their
    //  corresponding backup storage indexes run from bottom to top
    //

    for (int count = 1; count <= NUM_BACKUP_STG; count++) {

        lIndex = NUM_PROP_STG - count;

        if(m_pIPropStg[lIndex]) {
            m_pIPropStg[lIndex]->Release();
            m_pIPropStg[lIndex] = NULL;
        }
        if(m_pIStream[lIndex]) {
            m_pIStream[lIndex]->Release();
            m_pIStream[lIndex] = NULL;
        }
    }
    return S_OK;
}

/**************************************************************************\
* CheckPropertyAccess
*
*   This method checks the access flags for specified properties, and
*   fails if the access flags allow READ only access. Application
*   written properties will have no access flags and so are assumed
*   OK.
*
* Arguments:
*
*   bShowErrors -   specifies whether debug output should be shown when
*                   an error occurs.  This flag exists so that some methods
*                   can skip over properties which don't have the correct
*                   access flags set.
*   rgpspec     -   array of PROPSPECs specifying the properties.
*   cpspec      -   number of elements in rgpspec.
*
* Return Value:
*
*    Status             - S_OK if the access flags do not prohibit WRITEs.
*                         E_POINTER if rgpspec is a bad read pointer.
*                         E_ACCESSDENIED if any access does not allow WRITE
*                         access.
*
* History:
*
*    28/04/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaPropStg::CheckPropertyAccess(
    BOOL                bShowErrors,
    LONG                cpspec,
    PROPSPEC            *rgpspec)
{
    PROPVARIANT *ppvAccess;
    HRESULT hr;

    //
    //  PROPSPEC pointer has not been checked yet, so check that it is valid.
    //

    if (IsBadWritePtr(rgpspec, sizeof(PROPSPEC) * cpspec)) {
        DBG_ERR(("CWiaPropStg::CheckPropertyAccess, PROPSPEC array is invalid"));
        return E_POINTER;
    }

    ppvAccess = (PROPVARIANT*) LocalAlloc(LPTR, sizeof(PROPVARIANT) * cpspec);

    if (ppvAccess) {
        hr = (AccessStg())->ReadMultiple(cpspec,
                                         rgpspec,
                                         ppvAccess);

        if (hr == S_OK) {

            for (LONG i = 0; i < cpspec; i++) {
                if (ppvAccess[i].vt == VT_EMPTY) {
                    //
                    //  This is an application written property
                    //

                    hr = S_OK;
                } else if (!(ppvAccess[i].ulVal & WIA_PROP_WRITE)) {

                    if (!bShowErrors) {
                        hr = E_ACCESSDENIED;
                        break;
                    }
#ifdef WIA_DEBUG
                    if (rgpspec[i].ulKind == PRSPEC_PROPID) {
                        DBG_ERR(("CWiaPropStg::CheckPropertyAccess, no write access on prop ID: %d (%ws)",
                                   rgpspec[i].propid,
                                   GetNameFromWiaPropId(rgpspec[i].propid)));
                    }
                    else if (rgpspec[i].ulKind == PRSPEC_LPWSTR) {
                        DBG_ERR(("CWiaPropStg::CheckPropertyAccess, no write access prop ID: %ls", rgpspec[i].lpwstr));
                    }
                    else {
                        DBG_ERR(("CWiaPropStg::CheckPropertyAccess, bad property specification"));
                        hr = E_INVALIDARG;
                        break;
                    }
#endif
                    hr = E_ACCESSDENIED;
                }

                if (FAILED(hr)) {
                    break;
                }
            }
        } else {

            //
            // ??? What about the application written property case?
            // If return is S_FALSE then all the specified properties are
            // application written properties so return OK.
            //

            if (hr == S_FALSE) {
                hr = S_OK;
            } else {
                ReportReadWriteMultipleError(hr, "CWiaPropStg:CheckPropertyAccess", "access flags", TRUE, cpspec, rgpspec);
                DBG_ERR(("CWiaPropStg:CheckPropertyAccess, unable to read access rights for some properties"));
            }
        }
        LocalFree(ppvAccess);
    }
    else {
        DBG_ERR(("CWiaPropStg:CheckPropertyAccess, unable to allocate access propvar, count: %d", cpspec));
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

/**************************************************************************\
* CheckPropertyType
*
*   This method checks that the new property value type matches the current
*   property type for all properties being written.
*
* Arguments:
*
*   pIPropStg   -   the property storage to check against
*   cpspec      -   number of elements in rgpspec.
*   rgpspec     -   array of PROPSPECs specifying the properties.
*   rgpvar      -   array of PROPVARIANTS holding
*
* Return Value:
*
*    Status             - S_OK if the access flags allow WRITEs.
*                         E_INVALIDARG if property type is invalid
*                         E_POINTER if rgpvar is a bad read pointer.
*                         E_OUTOFMEMORY if temporary storage could not be
*                         allocated.
*
* History:
*
*    13/05/1999 Original Version
*
\**************************************************************************/
HRESULT _stdcall CWiaPropStg::CheckPropertyType(
    IPropertyStorage    *pIPropStg,
    LONG                cpspec,
    PROPSPEC            *rgpspec,
    PROPVARIANT         *rgpvar)
{
    PROPVARIANT *ppvCurrent;
    HRESULT hr;

    //
    //  PROPVARIANT pointer has not been checked yet, so check it now.
    //

    if (IsBadWritePtr(rgpvar, sizeof(PROPSPEC) * cpspec)) {
        DBG_ERR(("CWiaPropStg::CheckPropertyType, PROPVARIANT array is invalid"));
        return E_POINTER;
    }

    ppvCurrent = (PROPVARIANT*) LocalAlloc(LPTR, sizeof(PROPVARIANT) * cpspec);

    if (ppvCurrent) {

        //
        //  Get the current values
        //

        hr = pIPropStg->ReadMultiple(cpspec,
                                     rgpspec,
                                     ppvCurrent);

        if (SUCCEEDED(hr)) {

            //
            //  Check that the PROPVARIANT types match.  If VT is VT_EMPTY,
            //  then it's an application written property so skip check.
            //

            for (LONG i = 0; i < cpspec; i++) {
                if ((rgpvar[i].vt != ppvCurrent[i].vt) && (ppvCurrent[i].vt != VT_EMPTY)) {
                    hr = E_INVALIDARG;
                    break;
                }
            }

            FreePropVariantArray(cpspec, ppvCurrent);
        } else {
            ReportReadWriteMultipleError(hr,
                                         "CWiaPropStg::CheckPropertyType",
                                         "Reading current values",
                                         TRUE,
                                         1,
                                         rgpspec);
        }
        LocalFree(ppvCurrent);
    }
    else {
        DBG_ERR(("CWiaPropStg::CheckPropertyType, unable to allocate PropVar, count: %d", cpspec));
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

/**************************************************************************\
* GetPropIDFromName
*
*   This method takes in a PROPSPEC that identifies a property by its name
*   and returns a PROPSPEC with the corresponding PropID.  It checks against
*   the current value storage.
*
* Arguments:
*
*   pPropSpecIn     - A pointer to the input PROPSPEC containing the
*                     property name.
*   pPropSpecOut    - A pointer to a PROPSPEC where the corresponding
*                     PropID will be put.
*
* Return Value:
*
*    Status         -   An E_INVALIDARG will be returned if the property
*                       is not found.  If it is, then S_OK will be returned.
*                       If an error occurs getting the enumerator from the
*                       property storage, then that error is returned.
*
* History:
*
*    27/4/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaPropStg::GetPropIDFromName(
    PROPSPEC        *pPropSpecIn,
    PROPSPEC        *pPropSpecOut)
{
    HRESULT             hr;
    IEnumSTATPROPSTG    *pIEnum;

    hr = (CurStg())->Enum(&pIEnum);
    if (FAILED(hr)) {
        DBG_ERR(("GetPropIDFromName, error getting IEnumSTATPROPSTG"));
        return hr;
    }

    //
    //  Go through properties
    //

    STATPROPSTG statProp;
    ULONG       celtFetched;

    statProp.lpwstrName = NULL;
    for (celtFetched = 1; celtFetched > 0; pIEnum->Next(1, &statProp, &celtFetched)) {
        if (statProp.lpwstrName) {
            if ((wcscmp(statProp.lpwstrName, pPropSpecIn->lpwstr)) == 0) {

                //
                //  Found the right one, so get it's PropID
                //

                pPropSpecOut->ulKind = PRSPEC_PROPID;
                pPropSpecOut->propid = statProp.propid;

                CoTaskMemFree(statProp.lpwstrName);
                pIEnum->Release();
                return S_OK;
            }

            //
            //  Free the property name
            //

            CoTaskMemFree(statProp.lpwstrName);
            statProp.lpwstrName = NULL;
        }

    }

    pIEnum->Release();

    //
    //  Property not found
    //

    return E_INVALIDARG;
}

/**************************************************************************\
* NamesToPropIDs
*
*   This method takes in an array of PROPSPECs, and outputs an array
*   of PROPSPECs which contain only PropIDs.  This function should
*   be called by methods which only want to deal with PropIDs, and not
*   property names.
*
*   If none of the PropSpecs have to be converted, then the returned
*   PROPSPEC is NULL, else a new PropSpec array is allocated and
*   returned.  Users of this method must use LocalFree to free
*   up the returned array.
*
* Arguments:
*
*   pPropSpecIn     - A pointer to the input PROPSPEC containing the
*                     property name.
*   ppPropSpecOut   - A pointer to a PROPSPEC where the corresponding
*                     PropID will be put.
*   celt            - Number of PROPSPECS
*
* Return Value:
*
*    Status         -   An E_INVALIDARG will be returned if the property
*                       is not found. If it is, then S_OK will be returned
*                       E_OUTOFMEMORY will be returned if the new PROPSPEC
*                       array could not be allocated.
*
* History:
*
*    27/4/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaPropStg::NamesToPropIDs(
    LONG            celt,
    PROPSPEC        *pPropSpecIn,
    PROPSPEC        **ppPropSpecOut)
{
    HRESULT hr;

    *ppPropSpecOut = NULL;

    if (celt < 1) {

        return S_OK;
    }

    //
    //  Check whether conversion needs to be done.
    //

    for (int i = 0; i < celt; i++) {
        if (pPropSpecIn[i].ulKind == PRSPEC_LPWSTR) {

            //
            //  Found a Name, so we need to convert the whole thing
            //

            PROPSPEC *pOut;

            pOut = (PROPSPEC*) LocalAlloc(LPTR, sizeof(PROPSPEC) * celt);
            if (!pOut) {
                DBG_ERR(("NamesToPropIDs, out of memory"));
                return E_OUTOFMEMORY;
            }

            for (int j = 0; j < celt; j++) {
                if (pPropSpecIn[j].ulKind == PRSPEC_LPWSTR) {

                    hr = GetPropIDFromName(&pPropSpecIn[j], &pOut[j]);
                    if (FAILED(hr)) {
                        LocalFree(pOut);
                        return hr;
                    }

                }
                else {
                    pOut[j].ulKind = PRSPEC_PROPID;
                    pOut[j].propid = pPropSpecIn[j].propid;
                }
            }

            //
            //  Everything converted, so return
            //

            *ppPropSpecOut = pOut;
            return S_OK;
        }
    }

    //
    //  Nothing to convert
    //

    return S_OK;
}

/**************************************************************************\
* CopyItemProp
*
*   This method copies a single property from source to destination.
*
* Arguments:
*
*   pIPropStgSrc    -   The IPropertyStorage that contains the property to
*                       copy.
*   pIPropStgDst    -   The IPropertyStorage where the value is copied to.
*   pps             -   The PROPSPEC which specifies the source property.
*   pszErr          -   A string that will be printed out when an error
*                       occurs.
* Return Value:
*
*    Status         -   Returns HRESULT from ReadMultiple and WriteMultiple.
*
* History:
*
*    28/04/1999 Original Version
*
\**************************************************************************/

HRESULT CWiaPropStg::CopyItemProp(
    IPropertyStorage    *pIPropStgSrc,
    IPropertyStorage    *pIPropStgDst,
    PROPSPEC            *pps,
    LPSTR               pszErr)
{
    PROPVARIANT pv[1];

    HRESULT hr = pIPropStgSrc->ReadMultiple(1, pps, pv);
    if (SUCCEEDED(hr)) {

        hr = pIPropStgDst->WriteMultiple(1, pps, pv, WIA_DIP_FIRST);
        if (FAILED(hr)) {
            ReportReadWriteMultipleError(hr,
                                         "CopyItemProp",
                                         pszErr,
                                         FALSE,
                                         1,
                                         pps);
        }
        PropVariantClear(pv);
    }
    else {
        ReportReadWriteMultipleError(hr,
                                     "CopyItemProp",
                                     pszErr,
                                     TRUE,
                                     1,
                                     pps);
    }
    return hr;
}

/*******************************************************************************
*
*  CopyProps
*
*   This is a helper function used to copy the property values from one
*   property storage into another.
*
* Parameters:
*
*   pSrc    -   the source property storage
*   pDest   -   the destination property storage
*
* Return:
*
*   Status  -   S_OK if successful.
*               Error returns are those returned by WriteMultiple
*
* History
*
*   06/05/1999    Original Version
*
*******************************************************************************/

HRESULT CWiaPropStg::CopyProps(
    IPropertyStorage    *pSrc,
    IPropertyStorage    *pDest)
{
    IEnumSTATPROPSTG  *pIEnum;
    STATPROPSTG       StatPropStg;
    PROPSPEC          ps[1];
    HRESULT           hr;

    hr = pSrc->Enum(&pIEnum);
    if (SUCCEEDED(hr)) {
        ULONG ulFetched;

        ps[0].ulKind = PRSPEC_PROPID;

        while (pIEnum->Next(1, &StatPropStg, &ulFetched) == S_OK) {

            PROPID pi[1];
            LPWSTR psz[1];

            pi[0]  = StatPropStg.propid;
            psz[0] = StatPropStg.lpwstrName;

            if (StatPropStg.lpwstrName) {

                //
                //  Copy the property name
                //

                hr =  pDest->WritePropertyNames(1, pi, psz);
                if (FAILED(hr)) {
                    CoTaskMemFree(StatPropStg.lpwstrName);
                    break;
                }
            }

            ps[0].propid = StatPropStg.propid;

            //
            //  Copy the property value
            //

            hr = CopyItemProp(pSrc,
                              pDest,
                              ps,
                              "CopyProps");

            CoTaskMemFree(StatPropStg.lpwstrName);


            if (FAILED(hr)) {
                break; hr;
            }
        }
        pIEnum->Release();
    } else {
        return hr;
    }

    return hr;
}

/**************************************************************************\
* WriteItemPropNames
*
*   Write property names to all internal property storages (except the
*   storages used for backups).
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaPropStg::WriteItemPropNames(
    LONG                cItemProps,
    PROPID              *ppId,
    LPOLESTR            *ppszNames)
{
    HRESULT hr = S_OK;

    for(LONG lIndex = 0; lIndex < (NUM_PROP_STG - NUM_BACKUP_STG); lIndex++) {
        if (m_pIPropStg[lIndex]) {

            hr = m_pIPropStg[lIndex]->WritePropertyNames(cItemProps,
                                                         ppId,
                                                         ppszNames);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaPropStg::WriteItemPropNames, WritePropertyNames failed 0x%X", hr));
                return hr;
            }
        }
    }
    return hr;
}

/*******************************************************************************
*
*  CreateStorage
*
*   This is a helper function used to create streams and property storage.
*   The ulIndex argument indicates where the pointers are stored in the
*   streams and propertystorage arrays.
*
* Parameters:
*
*   ulIndex -   the index of the IPropertyStorage
*
* Return:
*
*   Status  -   S_OK if successful.
*           -   Error returns are those returned by CreateStreamOnHGlobal
*               and StgCreatePropStg
*
* History
*
*   06/05/1999    Original Version
*
*******************************************************************************/

HRESULT CWiaPropStg::CreateStorage(
    ULONG    ulIndex)
{
    HRESULT hr;

    //
    // Create stream and property storage.
    //

    hr = CreateStreamOnHGlobal(NULL, TRUE, &m_pIStream[ulIndex]);

    if (SUCCEEDED(hr)) {

        hr = StgCreatePropStg(m_pIStream[ulIndex],
                              FMTID_NULL,
                              &CLSID_NULL,
                              PROPSETFLAG_DEFAULT,
                              0,
                              &m_pIPropStg[ulIndex]);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaPropStg::CreateStorage, StgCreatePropStg failed 0x%X", hr));
        }
    } else {
        DBG_ERR(("CWiaPropStg::CreateStorage, CreateStreamOnHGlobal failed 0x%X", hr));
    }

    return hr;
}

/**************************************************************************\
* CopyRWStreamProps
*
*   Copies properties from source stream to destination stream.  Only copies
*   properties that the app. has read/write access to.
*
* Arguments:
*
*   pstmPropSrc         - Pointer to source property stream.
*   pstmPropDst         - Pointer to returned destination property stream.
*   pCompatibilityId    - Address of GUID to receive the property
*                         stream CompatibilityId.
*
* Return Value:
*
*   Status
*
* History:
*
*    9/3/1998 Original Version
*  06/04/1999 Moved from CWiaItem to CWiaPropStg
*
\**************************************************************************/

HRESULT CWiaPropStg::CopyRWStreamProps(
    LPSTREAM pstmPropSrc,
    LPSTREAM pstmPropDst,
    GUID     *pCompatibilityId)
{
    IPropertyStorage  *pSrc;
    IPropertyStorage  *pDst;
    IEnumSTATPROPSTG  *pIEnum;
    STATPROPSTG       StatPropStg;
    LONG              lNumProps = 0;
    HRESULT           hr;
    PROPSPEC          ps[1] = {{PRSPEC_PROPID, WIA_IPA_PROP_STREAM_COMPAT_ID}};
    PROPVARIANT       pv[1];

    //
    // Open a storage on the source stream.
    //

    hr = StgOpenPropStg(pstmPropSrc,
                        FMTID_NULL,
                        PROPSETFLAG_DEFAULT,
                        0,
                        &pSrc);
    if (SUCCEEDED(hr)) {

        //
        //  Get the compatibility ID.  If stream doesn't contain a
        //  compatibility ID then assume GUID_NULL.
        //

        PropVariantInit(pv);
        hr = pSrc->ReadMultiple(1, ps, pv);
        if (hr == S_OK) {
            *pCompatibilityId = *(pv[0].puuid);
        } else {
            *pCompatibilityId = GUID_NULL;
        }
        PropVariantClear(pv);

        //
        // Create a storage on the destination stream.
        //

        hr = StgCreatePropStg(pstmPropDst,
                              FMTID_NULL,
                              &CLSID_NULL,
                              PROPSETFLAG_DEFAULT,
                              0,
                              &pDst);
        if (SUCCEEDED(hr)) {
            hr = pSrc->Enum(&pIEnum);
            if (SUCCEEDED(hr)) {
                ULONG ulFetched;

                ps[0].ulKind = PRSPEC_PROPID;

                //
                //  Enumerate through the properties in the stream
                //

                while (pIEnum->Next(1, &StatPropStg, &ulFetched) == S_OK) {

                    PROPID pi[1];
                    LPWSTR psz[1];

                    pi[0]  = StatPropStg.propid;
                    psz[0] = StatPropStg.lpwstrName;
                    ps[0].propid = StatPropStg.propid;

                    //
                    //  Check whether property has read/write access.  Skip
                    //  property write if this check fails
                    //

                    hr = CheckPropertyAccess(FALSE, 1, ps);
                    if (hr != S_OK) {
                        hr = S_OK;

                        if (StatPropStg.lpwstrName) {
                            CoTaskMemFree(StatPropStg.lpwstrName);
                        }
                        continue;
                    }

                    //
                    //  Copy the property name (if it has one), and value
                    //

                    if (StatPropStg.lpwstrName) {

                        hr =  pDst->WritePropertyNames(1, pi, psz);
                        if (FAILED(hr)) {
                            DBG_ERR(("CWiaPropStg::CopyRWStreamProps WritePropertyNames failed"));
                            break;
                        }
                        CoTaskMemFree(StatPropStg.lpwstrName);
                    }

                    hr = CopyItemProp(pSrc,
                                      pDst,
                                      ps,
                                      "CWiaPropStg::CopyRWStreamProps");
                    if (FAILED(hr)) {
                        break;
                    }

                    //
                    //  Increase the property count
                    //

                    lNumProps++;
                }
                pIEnum->Release();
            } else {
                DBG_ERR(("CWiaPropStg::CopyRWStreamProps, Enum failed 0x%X", hr));
            }

            if (SUCCEEDED(hr)) {

                //
                //  Write the number of properties to stream
                //

                ps[0].propid = WIA_NUM_PROPS_ID;
                pv[0].vt = VT_I4;
                pv[0].lVal = lNumProps;

                hr = pDst->WriteMultiple(1, ps, pv, WIA_IPA_FIRST);
                if (FAILED(hr)) {
                    DBG_ERR(("CWiaPropStg::CopyRWStreamProps, Error writing number of properties"));
                }
            }
            pDst->Release();
        } else {
            DBG_ERR(("CWiaPropStg::CopyRWStreamProps, creating Dst storage failed 0x%X", hr));
        }
        pSrc->Release();
    } else {
        DBG_ERR(("CWiaPropStg::CopyRWStreamProps, StgCreatePropStg for pSrc failed 0x%X", hr));
    }

    return hr;
}

/**************************************************************************\
* GetPropertyStream
*
*   Get a copy of an items property stream. Caller must free returned
*   property stream.
*
* Arguments:
*
*   pCompatibilityId    - Address of GUID to receive the property
*                         stream CompatibilityId.
*   ppstmProp           - Pointer to returned property stream.
*
* Return Value:
*
*   Status
*
* History:
*
*    9/3/1998 Original Version
*  06/04/1999 Updated and moved from CWiaItem to CWiaPropStg
*  12/12/1999 Modified to use CompatibilityId
*
\**************************************************************************/

HRESULT _stdcall CWiaPropStg::GetPropertyStream(
    GUID        *pCompatibilityId,
    LPSTREAM    *ppstmProp)
{
    IStream *pStm;

    *ppstmProp = NULL;

    //
    // Commit any pending transactions.
    //

    HRESULT hr = m_pIPropStg[WIA_CUR_STG]->Commit(STGC_DEFAULT);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaPropStg::GetPropertyStream, Commit failed"));
        return hr;
    }

    //
    //  Create a stream
    //

    hr = CreateStreamOnHGlobal(NULL, TRUE, ppstmProp);
    if (SUCCEEDED(hr)) {

        //
        // Copy the RW properties from one stream to another.
        //

        hr = CopyRWStreamProps(m_pIStream[WIA_CUR_STG], *ppstmProp, pCompatibilityId);
        if (FAILED(hr)) {
            (*ppstmProp)->Release();
            *ppstmProp = NULL;
        }
    } else {
        DBG_ERR(("CWiaPropStg::GetPropertyStream, CreateStreamOnHGlobal failed"));

    }

    return hr;
}

/**************************************************************************\
* GetPropsFromStorage
*
*   Gets the properties contained in a storage which was opened on a stream
*   returned by GetPropertyStream.  The property values are returned in
*   ppVar, and the propID's are returned in ppPSpec.
*
* Arguments:
*
*   pSrc    -   pointer to the IProperty storage
*   pPSpec  -   address where the number of properties is returned
*   ppPSpec -   address of a pointer to hold PROPSPECs
*   ppVar   -   address of pointer to hold PROPVARIANTs
*
* Return Value:
*
*   Status
*
* History:
*
*  07/04/1999 Original Version
*
\**************************************************************************/

HRESULT CWiaPropStg::GetPropsFromStorage(
    IPropertyStorage    *pSrc,
    ULONG               *cPSpec,
    PROPSPEC            **ppPSpec,
    PROPVARIANT         **ppVar)
{
    IEnumSTATPROPSTG    *pIEnum = NULL;
    STATPROPSTG         StatPropStg;
    PROPSPEC            *ps = NULL;
    PROPVARIANT         *pv = NULL;
    LONG                lIndex = 0;

    //
    //  Read the number of properties
    //

    PROPSPEC    psNumProps[1];
    PROPVARIANT pvNumProps[1];

    psNumProps[0].ulKind = PRSPEC_PROPID;
    psNumProps[0].propid = WIA_NUM_PROPS_ID;
    PropVariantInit(pvNumProps);

    HRESULT hr = pSrc->ReadMultiple(1, psNumProps, pvNumProps);
    if (hr == S_OK) {

        //
        //  Get the memory for the values
        //

        ps = (PROPSPEC*) LocalAlloc(LPTR, sizeof(PROPSPEC) * pvNumProps[0].lVal);
        pv = (PROPVARIANT*) LocalAlloc(LPTR, sizeof(PROPVARIANT) * pvNumProps[0].lVal);
        if (!pv || !ps) {
            DBG_ERR(("CWiaPropStg::GetPropsFromStream, out of memory"));
            hr = E_OUTOFMEMORY;
        }
    } else {
        DBG_ERR(("CWiaPropStg::GetPropsFromStream, reading WIA_NUM_PROPS_ID failed"));
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr)) {

        hr = pSrc->Enum(&pIEnum);
        if (SUCCEEDED(hr)) {

            //
            //  Enumerate through the properties in the stream
            //

            for (lIndex = 0; lIndex < pvNumProps[0].lVal; lIndex++) {
                hr = pIEnum->Next(1, &StatPropStg, NULL);

                //
                //  Ignore the WIA_NUM_PROPS_ID property
                //

                if (StatPropStg.propid == WIA_NUM_PROPS_ID) {
                    hr = pIEnum->Next(1, &StatPropStg, NULL);
                }
                if (hr != S_OK) {
                    DBG_ERR(("CWiaPropStg::GetPropsFromStream, error enumerating properties"));
                    hr = E_INVALIDARG;
                    if(StatPropStg.lpwstrName) {
                        CoTaskMemFree(StatPropStg.lpwstrName);
                    }
                    break;
                }

                ps[lIndex].ulKind = PRSPEC_PROPID;
                ps[lIndex].propid = StatPropStg.propid;

                if(StatPropStg.lpwstrName) {
                    CoTaskMemFree(StatPropStg.lpwstrName);
                }
            }
            if (SUCCEEDED(hr)) {
                hr = pSrc->ReadMultiple(pvNumProps[0].lVal, ps, pv);
                if (hr != S_OK) {
                    DBG_ERR(("CWiaPropStg::GetPropsFromStream, read multiple failed"));
                    if (hr == S_FALSE) {
                        hr =  E_INVALIDARG;
                    }
                }
            }

            pIEnum->Release();
        } else {
            DBG_ERR(("CWiaPropStg::GetPropsFromStream, Enum failed"));
        }
    }
    if (FAILED(hr)) {
        if (ps) {
            LocalFree(ps);
            ps = NULL;
        }
        if (pv) {
            LocalFree(pv);
            pv = NULL;
        }
    }

    //
    //  Set return values
    //

    *cPSpec =  pvNumProps[0].lVal;
    PropVariantClear(pvNumProps);
    *ppPSpec = ps;
    *ppVar   = pv;

    return hr;
}

/**************************************************************************\
* SetPropertyStream
*
*   Sets the current value properties to the values contained in the argument
*   stream. The properties are written to the corresponding WiaItem.
*
* Arguments:
*
*   pCompatibilityId    - Pointer to a GUID representing the property
*                         stream CompatibilityId.
*   pItem               - Pointer to the WiaItem.
*   pstmProp            - Pointer to property stream.
*
* Return Value:
*
*   Status
*
* History:
*
*    07/06/1999 Original Version
*    12/12/1999 Modified to use CompatibilityId
*
\**************************************************************************/

HRESULT _stdcall CWiaPropStg::SetPropertyStream(
    GUID        *pCompatibilityId,
    IWiaItem    *pItem,
    LPSTREAM    pstmProp)
{
    IPropertyStorage    *pSrc;
    PROPSPEC            *ps = NULL;
    PROPVARIANT         *pv = NULL;
    PROPSPEC            psCompatId[1] = {{PRSPEC_PROPID, WIA_IPA_PROP_STREAM_COMPAT_ID}};
    PROPVARIANT         pvCompatId[1];
    ULONG               celt = 0;
    HRESULT hr          = S_OK;

    //
    //  Write the compatibility ID.  This way the driver will validate the
    //  ID before we attempt to write all the properties in this stream.
    //  Skip this step if pCompatibilityId is GUID_NULL.
    //

    if (*pCompatibilityId != GUID_NULL) {
        pvCompatId[0].vt    = VT_CLSID;
        pvCompatId[0].puuid = pCompatibilityId;
        hr = ((CWiaItem*) pItem)->WriteMultiple(1,
                                                psCompatId,
                                                pvCompatId,
                                                WIA_IPA_FIRST);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaPropStg::SetPropertyStream, Writing Compatibility ID failed!"));
            return hr;
        }
    }

    //
    //  If the stream is NULL, return here.  The stream will be NULL if the
    //  application simply wants to check whether the CompatibilityId is
    //  valid.
    //

    if (pstmProp == NULL) {
        return S_OK;
    }

    //
    //  Create a storage on the incoming stream
    //

    hr = StgOpenPropStg(pstmProp,
                        FMTID_NULL,
                        PROPSETFLAG_DEFAULT,
                        0,
                        &pSrc);
    if (SUCCEEDED(hr)) {
        //
        //  Get the properties from the stream
        //

        hr = GetPropsFromStorage(pSrc, &celt, &ps, &pv);
        if (SUCCEEDED(hr)) {

            //
            //  Write the properties to the item
            //

            hr = ((CWiaItem*) pItem)->WriteMultiple(celt, ps, pv, WIA_IPA_FIRST);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaPropStg::SetPropertyStream, WriteMultiple failed"));
            }
            LocalFree(ps);
            for (ULONG i = 0; i < celt; i++) {
                PropVariantClear(&pv[i]);
            }
            LocalFree(pv);
        }

        pSrc->Release();
    } else {
        DBG_ERR(("CWiaPropStg::SetPropertyStream, create storage failed 0x%X", hr));
    }

    return hr;
}

/**************************************************************************\
* CWiaPropStg
*
*   Constructor for CWiaPropStg.
*
* Arguments:
*
*
* Return Value:
*
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

CWiaPropStg::CWiaPropStg()
{
    //
    //  Set the property storage and property stream pointers to NULL
    //

    for (int lIndex = 0; lIndex < NUM_PROP_STG; lIndex++) {
        m_pIPropStg[lIndex] = NULL;
        m_pIStream[lIndex] = NULL;
    }
}

/**************************************************************************\
* ~CWiaPropStg
*
*   Destructor for CWiaPropStg.  Calls CleanUp to free resources.
*
* Arguments:
*
*
* Return Value:
*
*
* History:
*
*    06/03/1999 Original Version
*
\**************************************************************************/

CWiaPropStg::~CWiaPropStg()
{

    //
    //  Release the property storages and property streams
    //

    for (int lIndex = 0; lIndex < NUM_PROP_STG; lIndex++) {

        if(m_pIPropStg[lIndex]) {
            m_pIPropStg[lIndex]->Release();
            m_pIPropStg[lIndex] = NULL;
        }
        if(m_pIStream[lIndex]) {
            m_pIStream[lIndex]->Release();
            m_pIStream[lIndex] = NULL;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiaservc.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       WiaServc.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        20 Aug, 1998
*
*  DESCRIPTION:
*   Implementation of mini driver services in the WIA device class driver.
*
*******************************************************************************/
#include "precomp.h"

#define STD_PROPS_IN_CONTEXT

#include "stiexe.h"

#include <wiamindr.h>
#include <wiamdef.h>
#include <wiadbg.h>

#include "helpers.h"
#include "wiatiff.h"

#define DOWNSAMPLE_DPI  50

#define ENDORSER_TOKEN_DELIMITER    L"$"
#define ESCAPE_CHAR                 L'\\'

/**************************************************************************\
* wiasDebugTrace
*
*   Print a debug trace string in the device manager debug console.
*
* Arguments:
*
*   hInstance - Module handle of calling module.
*   pszFormat - ANSI format string.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

VOID __cdecl wiasDebugTrace( HINSTANCE hInstance, LPCSTR pszFormat, ... )
{
#if defined(WIA_DEBUG)
    _try {
        CHAR szMsg[1024 + MAX_PATH];
        CHAR szModuleName[MAX_PATH]="";
        va_list arglist;

        // Get the module name
        GetModuleFileNameA( hInstance, szModuleName, sizeof(szModuleName)/sizeof(szModuleName[0]) );
        // Nuke the path
        WORD wLen = sizeof(szMsg)/sizeof(szMsg[0]);
        GetFileTitleA( szModuleName, szMsg, wLen );
        // Nuke the extension
        for (LPSTR pszCurr = szMsg + lstrlenA(szMsg); pszCurr>szMsg; pszCurr--) {
            if (*(pszCurr-1)=='.') {
                *(pszCurr-1)='\0';
                break;
            }
        }
        // Append a colon:
        lstrcatA( szMsg, ": " );

        va_start(arglist, pszFormat);
        ::wvsprintfA(szMsg+lstrlenA(szMsg), pszFormat, arglist);
        va_end(arglist);

        DBG_TRC((szMsg));
    } _except(EXCEPTION_EXECUTE_HANDLER) {
        DBG_ERR(("::wiasDebugTrace, Error processing output string!"));

    }
#endif
}

/**************************************************************************\
* wiasDebugError
*
*   Print a debug error string in the device manager debug console. The
*   output color is always red.
*
* Arguments:
*
*   hInstance - Module handle of calling module.
*   pszFormat - ANSI format string.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

VOID __cdecl wiasDebugError( HINSTANCE hInstance, LPCSTR pszFormat, ... )
{
#if defined(WIA_DEBUG)
    _try {
        CHAR szMsg[1024 + MAX_PATH];
        CHAR szModuleName[MAX_PATH]="";
        va_list arglist;

        // Get the module name
        GetModuleFileNameA( hInstance, szModuleName, sizeof(szModuleName)/sizeof(szModuleName[0]) );
        // Nuke the path
        WORD wLen = sizeof(szMsg)/sizeof(szMsg[0]);
        GetFileTitleA( szModuleName, szMsg, wLen );
        // Nuke the extension
        for (LPSTR pszCurr = szMsg + lstrlenA(szMsg); pszCurr>szMsg; pszCurr--) {
            if (*(pszCurr-1)=='.') {
                *(pszCurr-1)='\0';
                break;
            }
        }
        // Append a colon:
        lstrcatA( szMsg, ": " );

        va_start(arglist, pszFormat);
        ::wvsprintfA(szMsg+lstrlenA(szMsg), pszFormat, arglist);
        va_end(arglist);

        DBG_ERR((szMsg));
    } _except (EXCEPTION_EXECUTE_HANDLER) {
        DBG_ERR(("::wiasDebugError, Error processing output string!"));

    }
#endif
}

/**************************************************************************\
* wiasPrintDebugHResult
*
*   Print an HRESULT string on the device manager debug console.
*
* Arguments:
*
*   hInstance - Module handle of calling module.
*   hr        - HRESULT to pe printed.
*
* Return Value:
*
*    None.
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

VOID __stdcall wiasPrintDebugHResult( HINSTANCE hInstance, HRESULT hr )
{
#if defined(WIA_DEBUG)
    DBG_ERR(("HResult = 0x%X", hr));
#endif
}

/**************************************************************************\
* wiasFormatArgs
*
*   Format an argument list into a packaged string for logging,
*   NOTE: This function adds a format signature, that tells the
*         logging engine that it is ok to FREE it.
*
* Arguments:
*
*    BSTR pszFormat - ANSI format string.
*
* Return Value:
*
*    None.
*
* History:
*
*    8/26/1999 Original Version
*
\**************************************************************************/
BSTR __cdecl wiasFormatArgs(LPCSTR lpszFormat, ...)
{

    USES_CONVERSION;

    CHAR pszbuffer[4*MAX_PATH];

    //
    // Signature needs to be defined somewhere else
    // It is here, until the old debugging system is
    // replaced.
    //

    CHAR pszFormatSignature[] = "F9762DD2679F";

    va_list arglist;

    //
    // Add signature value, because we are being used to format an
    // argument list
    //

    *pszbuffer = '\0';
    lstrcpynA(pszbuffer,pszFormatSignature,lstrlenA(pszFormatSignature) + 1 );

    va_start(arglist, lpszFormat);
    ::wvsprintfA((pszbuffer + (lstrlenA(pszFormatSignature))), lpszFormat, arglist);
    va_end(arglist);

    return A2BSTR(pszbuffer);
}

/**************************************************************************\
* wiasCreateDrvItem
*
*   Create a driver item.
*
* Arguments:
*
*   lObjectFlags      - Object flags.
*   bstrItemName      - Item name.
*   bstrFullItemName  - Full item name. Includes path info.
*   pIMiniDrv         - Pointer to mini-driver interface.
*   cbDevSpecContext  - Size of device specific context.
*   ppDevSpecContext  - Pointer to returned device specific context. Optional.
*   ppIWiaDrvItem     - Pointer to returned driver item.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/18/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasCreateDrvItem(
   LONG             lObjectFlags,
   BSTR             bstrItemName,
   BSTR             bstrFullItemName,
   IWiaMiniDrv      *pIMiniDrv,
   LONG             cbDevSpecContext,
   BYTE             **ppDevSpecContext,
   IWiaDrvItem      **ppIWiaDrvItem)
{
    DBG_FN(::wiasCreateDrvItem);
    HRESULT hr = E_FAIL;

    //
    // Objects can be either folders, files or both
    //

    if (!(lObjectFlags & (WiaItemTypeFolder | WiaItemTypeFile))) {

        DBG_ERR(("wiasCreateDrvItem, bad object flags"));
        return E_INVALIDARG;
    }

    //
    // Validate the item name strings.
    //

    if (IsBadStringPtrW(bstrItemName, SysStringLen(bstrItemName))) {
        DBG_ERR(("wiasCreateDrvItem, invalid bstrItemName pointer"));
        return E_POINTER;
    }

    if (IsBadStringPtrW(bstrFullItemName, SysStringLen(bstrFullItemName))) {
        DBG_ERR(("wiasCreateDrvItem, invalid bstrFullItemName pointer"));
        return E_POINTER;
    }

    //
    // Validate the rest of the pointers
    //

    if (IsBadReadPtr(pIMiniDrv, sizeof(IWiaMiniDrv*))) {
        DBG_ERR(("wiasCreateDrvItem, invalid pIMiniDrv pointer"));
        return E_POINTER;
    }

    if (!ppIWiaDrvItem) {
        DBG_ERR(("wiasCreateDrvItem, bad ppIWiaItemControl parameter"));
        return E_POINTER;
    }

    if (ppDevSpecContext) {
        if (IsBadWritePtr(ppDevSpecContext, sizeof(BYTE*))) {
            DBG_ERR(("wiasCreateDrvItem, invalid ppDevSpecContext pointer"));
            return E_POINTER;
        }
    }

    if (IsBadWritePtr(ppIWiaDrvItem, sizeof(IWiaDrvItem*))) {
        DBG_ERR(("wiasCreateDrvItem, invalid ppIWiaDrvItem pointer"));
        return E_POINTER;
    }

    CWiaDrvItem *pItem = new CWiaDrvItem();

    if (pItem) {

        hr = pItem->Initialize(lObjectFlags,
                               bstrItemName,
                               bstrFullItemName,
                               pIMiniDrv,
                               cbDevSpecContext,
                               ppDevSpecContext);

        if (hr == S_OK) {
            hr = pItem->QueryInterface(IID_IWiaDrvItem,(void **)ppIWiaDrvItem);
            if (FAILED(hr)) {
                DBG_ERR(("wiasCreateDrvItem, QI for IID_IWiaDrvItem failed"));
            }
        }
        else {
            delete pItem;
        }
    } else {
        DBG_ERR(("wiasCreateDrvItem, out of memory!"));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

/**************************************************************************\
* wiasReadMultiple
*
*   Read multiple properties helper.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item
*   ulCount         - Number of properties to read.
*   ps              - A caller allocated array of PROPSPEC.
*   pv              - A caller allocated array of PROPVARIANTS.
*   pvOld           - A caller allocated array of PROPVARIANTS for previous values.
*   pvOld           - A caller allocated array of PROPVARIANTS for the previous values.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasReadMultiple(
   BYTE                    *pWiasContext,
   ULONG                   ulCount,
   const PROPSPEC          *ps,
   PROPVARIANT             *pv,
   PROPVARIANT             *pvOld)
{
    DBG_FN(::wiasReadMultiple);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;
    HRESULT     hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasReadMultiple, invalid pItem"));
        return hr;
    }

    if (IsBadReadPtr(ps, sizeof(PROPSPEC) * ulCount)) {
        DBG_ERR(("wiasReadMultiple, invalid ps pointer"));
        return E_POINTER;
    }

    if (IsBadWritePtr(pv, sizeof(PROPVARIANT) * ulCount)) {
        DBG_ERR(("wiasReadMultiple, invalid pv pointer"));
        return E_POINTER;
    }

    if ((pvOld) && IsBadWritePtr(pvOld, sizeof(PROPVARIANT) * ulCount)) {
        DBG_ERR(("wiasReadMultiple, invalid pvOld pointer"));
        return E_POINTER;
    }

    IPropertyStorage *pIPropStg, *pIPropOldStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIPropStg,
                                                NULL,
                                                NULL,
                                                &pIPropOldStg);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Get the current values
    //

    hr = pIPropStg->ReadMultiple(ulCount, ps, pv);
    if (hr == S_OK) {

        //
        //  If requested, get the old values.
        //

        if (pvOld) {
            hr = pIPropOldStg->ReadMultiple(ulCount, ps, pvOld);
        };
        if (FAILED(hr)) {
            ReportReadWriteMultipleError(hr,
                                         "wiasReadMultiple",
                                         "old value",
                                         TRUE,
                                         ulCount,
                                         ps);
        }
    } else {
        ReportReadWriteMultipleError(hr,
                                     "wiasReadMultiple",
                                     "current value",
                                     TRUE,
                                     ulCount,
                                     ps);
    }
    return hr;
}

/**************************************************************************\
* wiasReadPropStr
*
*   Read property string helper.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item
*   propid          - Property ID
*   pbstr           - Pointer to returned BSTR
*   pbstrOld        - Pointer to old returned BSTR for previous value. Can
*                     be NULL
*   bMustExist      - Boolean value indicating whether the property must
*                     exist.  If this is true and the property is not found,
*                     an E_INVALIDARG is returned.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasReadPropStr(
    BYTE                    *pWiasContext,
    PROPID                  propid,
    BSTR                    *pbstr,
    BSTR                    *pbstrOld,
    BOOL                    bMustExist)
{
    DBG_FN(::wiasReadPropStr);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;
    HRESULT     hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasReadPropStr, invalid pItem"));
        return hr;
    }

    if (IsBadWritePtr(pbstr, sizeof(BSTR*))) {
        DBG_ERR(("wiasReadPropStr, invalid pbstr pointer"));
        return E_POINTER;
    }

    if ((pbstrOld) && IsBadWritePtr(pbstrOld, sizeof(BSTR*))) {
        DBG_ERR(("wiasReadMultiple, invalid pbstrOld pointer"));
        return E_POINTER;
    }

    IPropertyStorage *pIPropStg, *pIPropOldStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIPropStg,
                                                NULL,
                                                NULL,
                                                &pIPropOldStg);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Return the current value
    //

    PROPSPEC         propSpec;
    PROPVARIANT      propVar;

    propSpec.ulKind = PRSPEC_PROPID;
    propSpec.propid = propid;

    hr = pIPropStg->ReadMultiple(1, &propSpec, &propVar);
    if (hr == S_OK) {

        //
        //  NULL is a valid bstr value
        //

        if (propVar.bstrVal == NULL) {
            *pbstr = NULL;
            if (pbstrOld) {
                *pbstrOld = NULL;
            }
            return S_OK;
        }

        *pbstr = SysAllocString(propVar.bstrVal);
        PropVariantClear(&propVar);
        if (*pbstr) {

            //
            //  Check whether we must return the old value.
            //

            if (pbstrOld) {
                hr = pIPropOldStg->ReadMultiple(1, &propSpec, &propVar);
                if (hr == S_OK) {
                    *pbstrOld = SysAllocString(propVar.bstrVal);
                    PropVariantClear(&propVar);

                    //
                    //  Clear allocated memory.
                    //

                    if (!(*pbstrOld)) {
                        SysFreeString(*pbstr);
                        *pbstr = NULL;
                        DBG_ERR(("wiasReadPropStr, run out of memory"));
                        return E_OUTOFMEMORY;
                    }
                }
            }
        } else {
            DBG_ERR(("wiasReadPropStr, out of memory error"));
            return E_OUTOFMEMORY;
        }
    }
    if (((hr == S_FALSE) && bMustExist) || FAILED(hr)) {
        ReportReadWriteMultipleError(hr,
                                     "wiasReadPropStr",
                                     NULL,
                                     TRUE,
                                     1,
                                     &propSpec);
        if (bMustExist) {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}

/**************************************************************************\
* wiasReadPropLong
*
*   Read property long helper.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item
*   propid          - Property ID
*   plVal           - Pointer to returned LONG
*   plValOld        - Pointer to returned LONG for previous value
*   bMustExist      - Boolean value indicating whether the property must
*                     exist.  If this is true and the property is not found,
*                     an E_INVALIDARG is returned.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasReadPropLong(
    BYTE                    *pWiasContext,
    PROPID                  propid,
    LONG                    *plVal,
    LONG                    *plValOld,
    BOOL                    bMustExist)
{
    DBG_FN(::wiasReadPropLong);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;
    HRESULT     hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasReadPropLong, invalid pItem"));
        return hr;
    }

    if (IsBadWritePtr(plVal, sizeof(LONG))) {
        DBG_ERR(("wiasReadPropLong, invalid plVal pointer"));
        return E_POINTER;
    }

    if (plValOld && IsBadWritePtr(plValOld, sizeof(LONG))) {
        DBG_ERR(("wiasReadPropLong, invalid plValOld pointer"));
        return E_POINTER;
    }

    IPropertyStorage *pIPropStg, *pIPropOldStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIPropStg,
                                                NULL,
                                                NULL,
                                                &pIPropOldStg);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Return the current value
    //

    PROPSPEC         propSpec;
    PROPVARIANT      propVar;

    propSpec.ulKind = PRSPEC_PROPID;
    propSpec.propid = propid;

    hr = pIPropStg->ReadMultiple(1, &propSpec, &propVar);
    if (hr == S_OK) {
        *plVal = propVar.lVal;

        //
        //  Check whether we must return the old value.
        //

        if (plValOld) {
            hr = pIPropOldStg->ReadMultiple(1, &propSpec, &propVar);
            if (hr == S_OK) {
                *plValOld = propVar.lVal;
            }
        }
    }
    if (((hr == S_FALSE) && bMustExist) || FAILED(hr)) {
        ReportReadWriteMultipleError(hr,
                                     "wiasReadPropLong",
                                     NULL,
                                     TRUE,
                                     1,
                                     &propSpec);
        if (bMustExist) {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}

/**************************************************************************\
* wiasReadPropFloat
*
*   Read property floating point value helper.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item
*   propid          - Property ID
*   pfVal           - Pointer to returned float
*   pfValOld        - Pointer to returned float for previous value
*   bMustExist      - Boolean value indicating whether the property must
*                     exist.  If this is true and the property is not found,
*                     an E_INVALIDARG is returned.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasReadPropFloat(
    BYTE                    *pWiasContext,
    PROPID                  propid,
    FLOAT                   *pfVal,
    FLOAT                   *pfValOld,
    BOOL                    bMustExist)
{
    DBG_FN(::wiasReadPropFloat);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;
    HRESULT     hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasReadPropFloat, invalid pItem"));
        return hr;
    }

    if (IsBadWritePtr(pfVal, sizeof(float))) {
        DBG_ERR(("wiasReadPropFloat, invalid pfVal pointer"));
        return E_POINTER;
    }

    if (pfValOld && (IsBadWritePtr(pfValOld, sizeof(float)))) {
        DBG_ERR(("wiasReadPropFloat, invalid pfValOld pointer"));
        return E_POINTER;
    }

    IPropertyStorage *pIPropStg, *pIPropOldStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIPropStg, NULL, NULL, &pIPropOldStg);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Return the current value
    //

    PROPSPEC         propSpec;
    PROPVARIANT      propVar;

    propSpec.ulKind = PRSPEC_PROPID;
    propSpec.propid = propid;

    hr = pIPropStg->ReadMultiple(1, &propSpec, &propVar);
    if (hr == S_OK) {
        *pfVal = propVar.fltVal;

        //
        //  Check whether we must return the old value.
        //

        if (pfValOld) {
            hr = pIPropOldStg->ReadMultiple(1, &propSpec, &propVar);
            if (hr == S_OK) {
                *pfValOld = propVar.fltVal;
            }
        }
    }
    if (((hr == S_FALSE) && bMustExist) || FAILED(hr)) {
        ReportReadWriteMultipleError(hr,
                                     "wiasReadPropFloat",
                                     NULL,
                                     TRUE,
                                     1,
                                     &propSpec);
        if (bMustExist) {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}

/**************************************************************************\
* wiasReadPropGuid
*
*   Read property long helper.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item
*   propid          - Property ID
*   pguidVal           - Pointer to returned LONG
*   pguidValOld        - Pointer to returned LONG for previous value
*   bMustExist      - Boolean value indicating whether the property must
*                     exist.  If this is true and the property is not found,
*                     an E_INVALIDARG is returned.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasReadPropGuid(
    BYTE                    *pWiasContext,
    PROPID                  propid,
    GUID                    *pguidVal,
    GUID                    *pguidValOld,
    BOOL                    bMustExist)
{
    DBG_FN(::wiasReadPropGuid);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;
    HRESULT     hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasReadPropGuid, invalid pItem"));
        return hr;
    }

    if (IsBadWritePtr(pguidVal, sizeof(WIA_FORMAT_INFO))) {
        DBG_ERR(("wiasReadPropGuid, invalid plVal pointer"));
        return E_POINTER;
    }

    if (pguidValOld && IsBadWritePtr(pguidValOld, sizeof(WIA_FORMAT_INFO))) {
        DBG_ERR(("wiasReadPropGuid, invalid plValOld pointer"));
        return E_POINTER;
    }

    IPropertyStorage *pIPropStg, *pIPropOldStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIPropStg,
                                                NULL,
                                                NULL,
                                                &pIPropOldStg);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Return the current value
    //

    PROPSPEC         propSpec;
    PROPVARIANT      propVar;

    propSpec.ulKind = PRSPEC_PROPID;
    propSpec.propid = propid;

    hr = pIPropStg->ReadMultiple(1, &propSpec, &propVar);
    if (hr == S_OK) {
        memcpy(pguidVal, propVar.puuid, sizeof(GUID));
        PropVariantClear(&propVar);

        //
        //  Check whether we must return the old value.
        //

        if (pguidValOld) {
            hr = pIPropOldStg->ReadMultiple(1, &propSpec, &propVar);
            if (hr == S_OK) {
                memcpy(pguidValOld, propVar.puuid, sizeof(GUID));
                PropVariantClear(&propVar);
            }
        }
    }
    if (((hr == S_FALSE) && bMustExist) || FAILED(hr)) {
        ReportReadWriteMultipleError(hr,
                                     "wiasReadPropGuid",
                                     NULL,
                                     TRUE,
                                     1,
                                     &propSpec);
        if (bMustExist) {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}


/**************************************************************************\
* wiasReadPropBin
*
*   Read property binary helper.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item
*   propid          - Property ID
*   pbVal           - Pointer to caller allocated buffer.
*   pbValOld        - Pointer to caller allocated buffer for previous value.
*   bMustExist      - Boolean value indicating whether the property must
*                     exist.  If this is true and the property is not found,
*                     an E_INVALIDARG is returned.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasReadPropBin(
    BYTE             *pWiasContext,
    PROPID           propid,
    BYTE             **ppbVal,
    BYTE             **ppbValOld,
    BOOL             bMustExist)
{
    DBG_FN(::wiasReadPropBin);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;
    HRESULT     hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasReadPropBin, invalid pItem"));
        return hr;
    }

    if (IsBadWritePtr(ppbVal, sizeof(BYTE*))) {
        DBG_ERR(("wiasReadPropBin, invalid ppbVal pointer"));
        return E_POINTER;
    }

    if (ppbValOld && (IsBadWritePtr(ppbValOld, sizeof(BYTE*)))) {
        DBG_ERR(("wiasReadPropBin, invalid ppbVal pointer"));
        return E_POINTER;
    }

    *ppbVal = NULL;

    IPropertyStorage *pIPropStg, *pIPropOldStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIPropStg, NULL, NULL, &pIPropOldStg);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Return the current value
    //

    PROPSPEC         propSpec;
    PROPVARIANT      propVar;

    propSpec.ulKind = PRSPEC_PROPID;
    propSpec.propid = propid;

    hr = pIPropStg->ReadMultiple(1, &propSpec, &propVar);
    if (hr == S_OK) {
        if (propVar.vt == (VT_VECTOR | VT_UI1)) {
            *ppbVal = propVar.caub.pElems;
        }
        else {
            DBG_ERR(("wiasReadPropBin, invalid property type: %X", propVar.vt));
            PropVariantClear(&propVar);
            return E_INVALIDARG;
        }

        //
        //  If requested, get the old value.
        //

        if (ppbValOld) {
            hr = pIPropOldStg->ReadMultiple(1, &propSpec, &propVar);
            if (hr == S_OK) {
                if (propVar.vt == (VT_VECTOR | VT_UI1)) {
                    *ppbValOld = propVar.caub.pElems;
                }
                else {
                    DBG_ERR(("wiasReadPropBin, invalid property type: %X", propVar.vt));
                    PropVariantClear(&propVar);
                    return E_INVALIDARG;
                }
            }
        }
    }

    if (((hr == S_FALSE) && bMustExist) || FAILED(hr)) {
        ReportReadWriteMultipleError(hr,
                                     "wiasReadPropBin",
                                     NULL,
                                     TRUE,
                                     1,
                                     &propSpec);
        if (bMustExist) {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}

/**************************************************************************\
* wiasWriteMultiple
*
*   Write multiple properties helper.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item
*   ulCount         - Number of properties to write.
*   ps              - A caller alocated array of PROPSPEC.
*   pv              - A caller alocated array of PROPVARIANTS.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasWriteMultiple(
    BYTE                    *pWiasContext,
    ULONG                   ulCount,
    const PROPSPEC          *ps,
    const PROPVARIANT       *pv)
{
    DBG_FN(::wiasWriteMultiple);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;
    HRESULT     hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasWriteMultiple, invalid pItem"));
        return hr;
    }

    if (IsBadReadPtr(ps, sizeof(PROPSPEC) * ulCount)) {
        DBG_ERR(("wiasWriteMultiple, invalid ps pointer"));
        return E_POINTER;
    }

    if (IsBadReadPtr(pv, sizeof(PROPVARIANT) * ulCount)) {
        DBG_ERR(("wiasWriteMultiple, invalid pv pointer"));
        return E_POINTER;
    }

    IPropertyStorage *pIPropStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIPropStg, NULL, NULL, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Set the property to the new value
    //

    hr = pIPropStg->WriteMultiple(ulCount, ps, pv, WIA_DIP_FIRST);
    if (FAILED(hr)) {
        ReportReadWriteMultipleError(hr,
                                     "wiasWriteMultiple",
                                     NULL,
                                     FALSE,
                                     ulCount,
                                     ps);
    }
    return hr;

}

/**************************************************************************\
* wiasWritePropStr
*
*   Write property string helper.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item
*   propid          - Property ID
*   bstr            - BSTR to be written.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasWritePropStr(
    BYTE                    *pWiasContext,
    PROPID                  propid,
    BSTR                    bstr)
{
    DBG_FN(::wiasWritePropStr);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;
    BSTR        bstrOld;
    HRESULT     hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasWritePropStr, invalid pItem"));
        return hr;
    }

    // NULL is a valid BSTR value.
    if (bstr) {
        if (IsBadStringPtrW(bstr, SysStringLen(bstr))) {
            DBG_ERR(("wiasWriteMultiple, invalid bstr pointer"));
            return E_POINTER;
        }
    }

    IPropertyStorage *pIPropStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIPropStg, NULL, NULL, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Set the property to the new value
    //

    hr = WritePropStr(propid, pIPropStg, bstr);
    if (FAILED(hr)) {
        DBG_ERR(("wiasWriteMultiple, error writing new value"));
    }

    return hr;
}

/**************************************************************************\
* wiasWritePropLong
*
*   Write property long helper
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item
*   propid          - Property ID
*   lVal            - Value to write.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasWritePropLong(
    BYTE                    *pWiasContext,
    PROPID                  propid,
    LONG                    lVal)
{
    DBG_FN(::wiasWritePropLong);
    IWiaItem                *pItem = (IWiaItem*) pWiasContext;
    LONG                    lValOld;

    HRESULT hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasWritePropLong, invalid pItem"));
        return hr;
    }

    IPropertyStorage *pIPropStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIPropStg, NULL, NULL, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // Set new value
    //

    WritePropLong(propid, pIPropStg, lVal);

    return hr;
}

/**************************************************************************\
* wiasWritePropFloat
*
*   Write property float helper
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item
*   propid          - Property ID
*   fVal            - Float to be written.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasWritePropFloat(
    BYTE                    *pWiasContext,
    PROPID                  propid,
    float                   fVal)
{
    DBG_FN(::wiasWritePropFloat);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;
    float       fValOld;

    HRESULT hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasWritePropFloat, invalid pItem"));
        return hr;
    }

    IPropertyStorage *pIPropStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIPropStg, NULL, NULL, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    PROPSPEC         propSpec;
    PROPVARIANT      propVar;

    propSpec.ulKind = PRSPEC_PROPID;
    propSpec.propid = propid;

    //
    //  Write new value
    //

    PropVariantInit(&propVar);
    propVar.vt      = VT_R4;
    propVar.fltVal  = fVal;

    hr = pIPropStg->WriteMultiple(1, &propSpec, &propVar, WIA_DIP_FIRST);
    if (FAILED(hr)) {
        ReportReadWriteMultipleError(hr, "wiasWritePropFloat", NULL, FALSE, 1, &propSpec);
    }
    return hr;
}

/**************************************************************************\
* wiasWritePropGuid
*
*   Write property float helper
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item
*   propid          - Property ID
*   pguidVal        - pointer to GUID to be written.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasWritePropGuid(
    BYTE                    *pWiasContext,
    PROPID                  propid,
    GUID                    guidVal)
{
    DBG_FN(::wiasWritePropGuid);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;
    GUID        guidValOld;

    HRESULT hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasWritePropFloat, invalid pItem"));
        return hr;
    }

    IPropertyStorage *pIPropStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIPropStg, NULL, NULL, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    PROPSPEC         propSpec;
    PROPVARIANT      propVar;

    propSpec.ulKind = PRSPEC_PROPID;
    propSpec.propid = propid;

    //
    //  Write new value
    //

    PropVariantInit(&propVar);
    propVar.vt        = VT_CLSID;
    propVar.puuid     = &guidVal;

    hr = pIPropStg->WriteMultiple(1, &propSpec, &propVar, WIA_DIP_FIRST);
    if (FAILED(hr)) {
        ReportReadWriteMultipleError(hr, "wiasWritePropFloat", NULL, FALSE, 1, &propSpec);
    }
    return hr;
}

/**************************************************************************\
* wiasWritePropBin
*
*   Write property binary helper
*
* Arguments:
*
*   pWiasContext  - Pointer to WIA item
*   propid        - Property ID
*   cbVal         - Number of bytes to write.
*   pbVal         - Pointer to binary value to write.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasWritePropBin(
    BYTE             *pWiasContext,
    PROPID           propid,
    LONG             cbVal,
    BYTE             *pbVal)
{
    DBG_FN(::wiasWritePropBin);
    IWiaItem         *pItem = (IWiaItem*) pWiasContext;

    HRESULT hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasWritePropBin, invalid pItem"));
        return hr;
    }

    if (IsBadReadPtr(pbVal, cbVal)) {
        DBG_ERR(("wiasWritePropBin, invalid pbVal pointer"));
        return E_POINTER;
    }

    IPropertyStorage *pIPropStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIPropStg, NULL, NULL, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    PROPSPEC         propSpec;
    PROPVARIANT      propVar;

    propSpec.ulKind = PRSPEC_PROPID;
    propSpec.propid = propid;

    //
    //  Write the new value
    //

    propVar.vt          = VT_VECTOR | VT_UI1;
    propVar.caub.pElems = pbVal;
    propVar.caub.cElems = cbVal;

    hr = pIPropStg->WriteMultiple(1, &propSpec, &propVar, WIA_DIP_FIRST);
    if (FAILED(hr)) {
        ReportReadWriteMultipleError(hr, "wiasWritePropBin", NULL, FALSE, 1, &propSpec);
    }
    return hr;
}

/**************************************************************************\
* wiasGetPropertyAttributes
*
*   Get the access flags and valid values for a property.
*
* Arguments:
*
*   pWiasContext   - Pointer to WIA item
*   cPropSpec      - The number of properties
*   pPropSpec      - array of property specification.
*   pulAccessFlags - array of LONGs access flags.
*   pPropVar       - Pointer to returned valid values.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasGetPropertyAttributes(
    BYTE                          *pWiasContext,
    LONG                          cPropSpec,
    PROPSPEC                      *pPropSpec,
    ULONG                         *pulAccessFlags,
    PROPVARIANT                   *pPropVar)
{
    DBG_FN(::wiasGetPropertyAttributes);
    IWiaItem                      *pItem = (IWiaItem*) pWiasContext;

    //
    //  Do parameter validation.
    //

    HRESULT hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasGetPropertyAttributes, invalid pItem"));
        return hr;
    }

    if (IsBadReadPtr(pPropSpec, sizeof(PROPSPEC) * cPropSpec)) {
        DBG_ERR(("wiasGetPropertyAttributes, bad pPropSpec parameter"));
        return E_POINTER;
    }

    if (IsBadWritePtr(pulAccessFlags, sizeof(ULONG) * cPropSpec)) {
        DBG_ERR(("wiasGetPropertyAttributes, bad pulAccessFlags parameter"));
        return E_POINTER;
    }

    if (IsBadWritePtr(pPropVar, sizeof(PROPVARIANT) * cPropSpec)) {
        DBG_ERR(("wiasGetPropertyAttributes, bad pPropVar parameter"));
        return E_POINTER;
    }

    //
    //  Now that validation has been done, call helper function to get
    //  the property attributes
    //

    return GetPropertyAttributesHelper(pItem,
                                       cPropSpec,
                                       pPropSpec,
                                       pulAccessFlags,
                                       pPropVar);
}

/**************************************************************************\
* wiasSetPropertyAttributes
*
*   Set the access flags and valid values for a set of properties.
*
* Arguments:
*
*   pWiasContext   - Pointer to WIA item
*   cPropSpec      - The number of properties
*   pPropSpec      - Pointer to a property specification.
*   pulAccessFlags - Access flags.
*   pPropVar       - Pointer to valid values.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasSetPropertyAttributes(
    BYTE                          *pWiasContext,
    LONG                          cPropSpec,
    PROPSPEC                      *pPropSpec,
    ULONG                         *pulAccessFlags,
    PROPVARIANT                   *pPropVar)
{
    DBG_FN(::wiasSetPropertyAttributes);
    IWiaItem                      *pItem = (IWiaItem*) pWiasContext;

    //
    //  May be called by driver or application, do parameter validation.
    //

    HRESULT hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetPropertyAttributes, invalid pItem"));
        return hr;
    }

    if (IsBadReadPtr(pPropSpec, sizeof(PROPSPEC) * cPropSpec)) {
        DBG_ERR(("wiasSetPropertyAttributes, bad pPropSpec parameter"));
        return E_POINTER;
    }

    if (IsBadWritePtr(pulAccessFlags, sizeof(ULONG) * cPropSpec)) {
        DBG_ERR(("wiasSetPropertyAttributes, bad pulAccessFlags parameter"));
        return E_POINTER;
    }

    if (IsBadWritePtr(pPropVar, sizeof(PROPVARIANT) * cPropSpec)) {
        DBG_ERR(("wiasSetPropertyAttributes, bad pPropVar parameter"));
        return E_POINTER;
    }

    //
    // Get the item's internal property storage pointers.
    //

    IPropertyStorage *pIPropAccessStg;
    IPropertyStorage *pIPropValidStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(NULL,
                                                &pIPropAccessStg,
                                                &pIPropValidStg,
                                                NULL);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Set the Access flags for the properties.
    //

    PROPVARIANT *pVar;

    pVar = (PROPVARIANT*) LocalAlloc(LPTR, sizeof(PROPVARIANT) * cPropSpec);
    if (pVar) {
        for (int flagIndex = 0; flagIndex < cPropSpec; flagIndex++) {
            pVar[flagIndex].vt = VT_UI4;
            pVar[flagIndex].ulVal = pulAccessFlags[flagIndex];
        }

        hr = pIPropAccessStg->WriteMultiple(cPropSpec, pPropSpec, pVar, WIA_DIP_FIRST);
        LocalFree(pVar);
        if (SUCCEEDED(hr)) {

            //
            //  Set the valid values
            //

            hr = pIPropValidStg->WriteMultiple(cPropSpec, pPropSpec, pPropVar, WIA_DIP_FIRST);
            if (FAILED(hr)) {
                DBG_ERR(("wiasSetPropertyAttributes, could not set valid values"));
            }
        }   else {
            DBG_ERR(("wiasSetPropertyAttributes, could not set access flags"));
        }
    } else {
        DBG_ERR(("wiasSetPropertyAttributes, out of memory"));
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
        ReportReadWriteMultipleError(hr, "wiasSetPropertyAttributes",
                                     NULL,
                                     FALSE,
                                     cPropSpec,
                                     pPropSpec);
    }

    return hr;
}




/**************************************************************************\
* RangeToPropVariant
*
*   Move information from a WIA_PROPERTY_INFO struct to a PROPVARIANT.  The
*   WIA_PROPERTY_INFO is known to be of type WIA_PROP_RANGE.
*
* Arguments:
*
*   pwpi    -   pointer to WIA_PROPERTY_INFO structure
*   ppv     -   pointer to PROPVARIANT structure
*
* Return Value:
*
*    Status -   S_OK if successful
*           -   E_INVALIDARG if the vt type is not supported.
*           -   E_OUTOFMEMORY if storage for the range could not be
*               allocated.
*
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

//
//  Helper macro
//

#define MAKE_RANGE(WPI, PV, Type, VName, RType) {                           \
                                                                            \
    Type    *pArray = (Type*) CoTaskMemAlloc(sizeof(Type) * WIA_RANGE_NUM_ELEMS);\
                                                                            \
    if (pArray) {                                                           \
        PV->VName.cElems                 = WIA_RANGE_NUM_ELEMS;             \
        PV->VName.pElems                 = (Type*)pArray;                   \
        PV->VName.pElems[WIA_RANGE_MIN]  = (Type) WPI->ValidVal.RType.Min;  \
        PV->VName.pElems[WIA_RANGE_NOM]  = (Type) WPI->ValidVal.RType.Nom;  \
        PV->VName.pElems[WIA_RANGE_MAX]  = (Type) WPI->ValidVal.RType.Max;  \
        PV->VName.pElems[WIA_RANGE_STEP] = (Type) WPI->ValidVal.RType.Inc;  \
    } else {                                                                \
        DBG_ERR(("RangeToPropVariant, unable to allocate range list"));   \
        hr = E_OUTOFMEMORY;                                                 \
    }                                                                       \
};

HRESULT RangeToPropVariant(
    WIA_PROPERTY_INFO  *pwpi,
    PROPVARIANT        *ppv)
{
    DBG_FN(::RangeToPropVariant);
    HRESULT hr = S_OK;

    ppv->vt = VT_VECTOR | pwpi->vt;

    switch (pwpi->vt) {
        case (VT_UI1):
            MAKE_RANGE(pwpi, ppv, UCHAR, caub, Range);
            break;
        case (VT_UI2):
            MAKE_RANGE(pwpi, ppv, USHORT, caui, Range);
            break;
        case (VT_UI4):
            MAKE_RANGE(pwpi, ppv, ULONG, caul, Range);
            break;
        case (VT_I2):
            MAKE_RANGE(pwpi, ppv, SHORT, cai, Range);
            break;
        case (VT_I4):
            MAKE_RANGE(pwpi, ppv, LONG, cal, Range);
            break;
        case (VT_R4):
            MAKE_RANGE(pwpi, ppv, FLOAT, caflt, RangeFloat);
            break;
        case (VT_R8):
            MAKE_RANGE(pwpi, ppv, DOUBLE, cadbl, RangeFloat);
            break;
        default:

            //
            //  Type not supported
            //

            DBG_ERR(("RangeToPropVariant, type not supported"));
            hr = E_INVALIDARG;
    }
    return hr;
}

/**************************************************************************\
* ListToPropVariant
*
*   Move information from a WIA_PROPERTY_INFO struct to a PROPVARIANT.  The
*   WIA_PROPERTY_INFO is known to be of type WIA_PROP_LIST.
*
* Arguments:
*
*   pwpi    -   pointer to WIA_PROPERTY_INFO structure
*   ppv     -   pointer to PROPVARIANT structure
*
* Return Value:
*
*    Status -   S_OK if successful
*           -   E_INVALIDARG if the vt type is not supported.
*           -   E_OUTOFMEMORY if storage for the range could not be
*               allocated.
*
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

//
//  Helper macros
//

#define MAKE_LIST(WPI, PV, Type, Num, VName, LType)    {                    \
                                                                            \
    if (IsBadReadPtr(WPI->ValidVal.LType.pList, sizeof(Type) * Num)) {      \
        hr = E_POINTER;                                                     \
        break;                                                              \
    };                                                                      \
                                                                            \
    Type    *pArray = (Type*) CoTaskMemAlloc(sizeof(Type) * (Num + WIA_LIST_VALUES));\
                                                                            \
    if (pArray) {                                                           \
        PV->VName.cElems = Num + WIA_LIST_VALUES;                           \
        pArray[WIA_LIST_COUNT] = (Type) Num;                                \
        pArray[WIA_LIST_NOM]   = (Type) WPI->ValidVal.LType.Nom;            \
                                                                            \
        memcpy(&pArray[WIA_LIST_VALUES],                                    \
               WPI->ValidVal.LType.pList,                                   \
               Num * sizeof(Type));                                         \
        PV->VName.pElems = pArray;                                          \
    } else {                                                                \
        DBG_ERR(("ListToPropVariant (MAKE_LIST), unable to allocate list"));\
        hr = E_OUTOFMEMORY;                                                 \
    }                                                                       \
};

#define MAKE_LIST_GUID(WPI, PV, Type, Num)    {                             \
                                                                            \
    if (IsBadReadPtr(WPI->ValidVal.ListGuid.pList, sizeof(GUID) * Num)) {   \
        hr = E_POINTER;                                                     \
        break;                                                              \
    };                                                                      \
                                                                            \
    GUID *pArray = (GUID*) CoTaskMemAlloc(sizeof(GUID) * (Num + WIA_LIST_VALUES));\
                                                                            \
    if (pArray) {                                                           \
        PV->cauuid.cElems = Num + WIA_LIST_VALUES;                          \
        pArray[WIA_LIST_COUNT] = WiaImgFmt_UNDEFINED;                          \
        pArray[WIA_LIST_NOM]   = WPI->ValidVal.ListGuid.Nom;                \
                                                                            \
        memcpy(&pArray[WIA_LIST_VALUES],                                    \
               WPI->ValidVal.ListGuid.pList,                                \
               Num * sizeof(GUID));                                         \
        PV->cauuid.pElems = pArray;                                         \
    } else {                                                                \
        DBG_ERR(("ListToPropVariant (MAKE_LIST), unable to allocate list"));\
        hr = E_OUTOFMEMORY;                                                 \
    }                                                                       \
};

#define MAKE_LIST_BSTR(WPI, PV, Type, Num)    {                             \
                                                                            \
    if (IsBadReadPtr(WPI->ValidVal.ListBStr.pList, sizeof(Type) * Num)) {   \
            DBG_ERR(("ListToPropVariant (MAKE_LIST_BSTR), pList pointer is bad"));\
        hr = E_POINTER;                                                     \
        break;                                                              \
    };                                                                      \
                                                                            \
    Type    *pArray = (Type*) CoTaskMemAlloc(sizeof(Type) * (Num + WIA_LIST_VALUES));\
                                                                            \
    if (pArray) {                                                           \
        PV->cabstr.cElems = Num + WIA_LIST_VALUES;                          \
        pArray[WIA_LIST_COUNT] = SysAllocString(L"");                       \
                                          